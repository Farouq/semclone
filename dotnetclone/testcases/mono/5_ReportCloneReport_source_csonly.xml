<clones  nfragments="644" ngroups="189">
<clone_group groupid="0" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="130" endline="136">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="148" endline="154">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="1" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4273" endline="4279">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unchecked target = (Unchecked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4335" endline="4341">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unsafe target = (Unsafe) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="2" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="564" endline="570">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (break_origins);
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="588" endline="594">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (continue_origins);
 			return vector;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="3" nfragments="20" Csharpe_files="20" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1035" endline="1041">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			GotoCase target = (GotoCase) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="82" endline="88">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Yield target = (Yield) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="621" endline="627">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			StatementExpression target = (StatementExpression) t;
 
 			target.expr = (ExpressionStatement) expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1214" endline="1220">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnaryMutator target = (UnaryMutator) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="329" endline="336">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Do target = (Do) t;
 
 			target.EmbeddedStatement = EmbeddedStatement.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1084" endline="1091">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Throw target = (Throw) t;
 
 			if (expr != null)
 				target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5755" endline="5763">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Foreach target = (Foreach) t;
 
 			target.type = type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1606" endline="1613">
<![CDATA[
 		
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Cast target = (Cast) t;
 
 			target.target_type = target_type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="801" endline="808">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Return target = (Return) t;
 			// It's null for simple return;
 			if (Expr != null)
 				target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2038" endline="2046">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			if (expr == null)
 				return;
 
 			ShimExpression target = (ShimExpression) t;
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="246" endline="255">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			If target = (If) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.TrueStatement = TrueStatement.Clone (clonectx);
 			if (FalseStatement != null)
 				target.FalseStatement = FalseStatement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4518" endline="4526">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Conditional target = (Conditional) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.true_expr = true_expr.Clone (clonectx);
 			target.false_expr = false_expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5095" endline="5106">
<![CDATA[
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7908" endline="7914">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9303" endline="9309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CollectionElementInitializer target = (CollectionElementInitializer) t;
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7970" endline="7976">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CheckedExpr target = (CheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1199" endline="1206">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			NullCoalescingOperator target = (NullCoalescingOperator) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3862" endline="3869">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Binary target = (Binary) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4802" endline="4810">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			TryFinally target = (TryFinally) t;
 
 			target.stmt = (Statement) stmt.Clone (clonectx);
 			if (fini != null)
 				target.fini = clonectx.LookupBlock (fini);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5873" endline="5882">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			New target = (New) t;
 
 			target.RequestedType = RequestedType.Clone (clonectx);
 			if (arguments != null){
 				target.arguments = arguments.Clone (clonectx);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="4" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1475" endline="1481">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 			
 			ec.Emit (OpCodes.Box, child.Type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1205" endline="1211">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			child.Emit (ec);
 
 			ec.Emit (OpCodes.Call, operators [type]);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="5" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="763" endline="769">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddContinueOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="756" endline="762">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddBreakOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="6" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="792" endline="798">
<![CDATA[
 
 		public void EmitWriteLine(string text)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Ldstr, text);
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("WriteLine", new Type[] { u.System_String }));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="815" endline="822">
<![CDATA[
 
 		public void EmitWriteLine(LocalBuilder local)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("get_Out"));
 			Emit(OpCodes.Ldloc, local);
 			Emit(OpCodes.Callvirt, u.Import(typeof(System.IO.TextWriter)).GetMethod("WriteLine", new Type[] { local.LocalType }));
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="7" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="127" endline="133">
<![CDATA[
 
 		internal void WriteParamRecord(MetadataWriter mw)
 		{
 			mw.Write(flags);
 			mw.Write(sequence);
 			mw.WriteStringIndex(nameIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="150" endline="156">
<![CDATA[
 
 		internal void WriteFieldRecords(MetadataWriter mw)
 		{
 			mw.Write((short)attribs);
 			mw.WriteStringIndex(nameIndex);
 			mw.WriteBlobIndex(signature);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="8" nfragments="15" Csharpe_files="15" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="955" endline="961">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1515" endline="1521">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.float_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1136" endline="1142">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1766" endline="1772">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.decimal_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1892" endline="1898">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1638" endline="1644">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.double_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="619" endline="625">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.sbyte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="843" endline="849">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.ushort_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8756" endline="8762">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 			type = TypeManager.object_type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="495" endline="501">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.char_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="340" endline="346">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.bool_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1398" endline="1404">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="725" endline="731">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.short_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="412" endline="418">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.byte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="9" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="310" endline="316">
<![CDATA[
 
 		public void BeginFaultBlock()
 		{
 			ExceptionBlock block = BeginFinallyFilterFaultBlock();
 			block.handlerOffset = code.Position;
 			block.exceptionType = FAULT;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="303" endline="309">
<![CDATA[
 
 		public void BeginExceptFilterBlock()
 		{
 			ExceptionBlock block = BeginFinallyFilterFaultBlock();
 			block.filterOffset = code.Position;
 			UpdateStack(1);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="10" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="381" endline="387">
<![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, CallingConventions.Standard, true, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="388" endline="395">
<![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, callingConvention, false, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="11" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="155" endline="161">
<![CDATA[
 
 		public static void DefineCapturedLocal (int scope_id, string name,
 							string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedLocal (scope_id, name, captured_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="162" endline="168">
<![CDATA[
 
 		public static void DefineCapturedParameter (int scope_id, string name,
 							    string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedParameter (scope_id, name, captured_name);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="12" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="835" endline="841">
<![CDATA[
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				// TODO
 				return CurrentTypeParameters.Select (l => l.Type).ToArray ();
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="667" endline="673">
<![CDATA[
 		}
 
 		TypeParameterSpec[] ITypeDefinition.TypeParameters {
 			get {
 				// TODO MemberCache
 				return PartialContainer.type_params.Select (l => l.Type).ToArray ();
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="13" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1508" endline="1514">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 
 			ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1478" endline="1487">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			expr.Emit (ec);
 
 			ec.Emit (OpCodes.Isinst, type);
 
 			if (TypeManager.IsGenericParameter (type) || TypeManager.IsNullableType (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7242" endline="7249">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="14" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="168" endline="174">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="213" endline="219">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="15" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="42" endline="48">
<![CDATA[
 		internal TextSection(PEWriter peWriter, CliHeader cliHeader, ModuleBuilder moduleBuilder, int strongNameSignatureLength)
 		{
 			this.peWriter = peWriter;
 			this.cliHeader = cliHeader;
 			this.moduleBuilder = moduleBuilder;
 			this.strongNameSignatureLength = (uint)strongNameSignatureLength;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="39" endline="46">
<![CDATA[
 		internal ParameterBuilder(ModuleBuilder moduleBuilder, int sequence, ParameterAttributes attribs, string name)
 		{
 			this.moduleBuilder = moduleBuilder;
 			this.flags = (short)attribs;
 			this.sequence = (short)sequence;
 			this.nameIndex = name == null ? 0 
 			this.name = name;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="16" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="211" endline="218">
<![CDATA[
 
 		public int Read ()
 		{
 			if ((pos >= char_count) && !ReadBuffer ())
 				return -1;
 
 			return buffer [pos++];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="203" endline="210">
<![CDATA[
 
 		public int Peek ()
 		{
 			if ((pos >= char_count) && !ReadBuffer ())
 				return -1;
 
 			return buffer [pos];
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="17" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="181" endline="188">
<![CDATA[
 
 		public static void OpenCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.OpenCompilerGeneratedBlock (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="205" endline="212">
<![CDATA[
 
 		public static void EndIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorBody (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="189" endline="196">
<![CDATA[
 
 		public static void CloseCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.CloseCompilerGeneratedBlock (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="197" endline="204">
<![CDATA[
 
 		public static void StartIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorBody (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="213" endline="220">
<![CDATA[
 
 		public static void StartIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorDispatcher (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="221" endline="228">
<![CDATA[
 
 		public static void EndIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorDispatcher (offset);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="18" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="46" endline="53">
<![CDATA[
 
 		static bool IsValidEnumType (TypeSpec t)
 		{
 			return (t == TypeManager.int32_type || t == TypeManager.uint32_type || t == TypeManager.int64_type ||
 				t == TypeManager.byte_type || t == TypeManager.sbyte_type || t == TypeManager.short_type ||
 				t == TypeManager.ushort_type || t == TypeManager.uint64_type || t == TypeManager.char_type ||
 				TypeManager.IsEnumType (t));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2407" endline="2415">
<![CDATA[
 
 		static bool IsUnsigned (TypeSpec t)
 		{
 			if (t.IsPointer)
 				return true;
 
 			return (t == TypeManager.uint32_type || t == TypeManager.uint64_type ||
 				t == TypeManager.ushort_type || t == TypeManager.byte_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="353" endline="364">
<![CDATA[
 
 		static bool IsValidArgumentType (TypeSpec t)
 		{
 			if (t.IsArray)
 				t = TypeManager.GetElementType (t);
 
 			return t == TypeManager.string_type ||
 				TypeManager.IsPrimitiveType (t) ||
 				TypeManager.IsEnumType (t) ||
 				t == TypeManager.object_type ||
 				t == TypeManager.type_type;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="19" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="132" endline="139">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = callingConvention;
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="123" endline="131">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.unmanaged = true;
 			sig.unmanagedCallConv = unmanagedCallConv;
 			return sig;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="20" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1655" endline="1662">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7293" endline="7300">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="159" endline="167">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8786" endline="8795">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (source.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			args.Add (new Argument (new TypeOfMethod (method, loc)));
 			return CreateExpressionFactoryCall (ec, "Convert", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7108" endline="7118">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1033" endline="1045">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (child.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			if (type.IsPointer || child.Type.IsPointer)
 				Error_PointerInsideExpressionTree (ec);
 
 			return CreateExpressionFactoryCall (ec, ec.HasSet (ResolveContext.Options.CheckedScope) ? "ConvertChecked" 
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="21" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="173" endline="180">
<![CDATA[
 
 		public void CloseScope (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="190" endline="197">
<![CDATA[
 
 		public void CloseCompilerGeneratedBlock (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="22" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="968" endline="975">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Explicit conversions
 		/// </summary>
 		static Expression ExplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, false, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="960" endline="967">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Implicit conversions
 		/// </summary>
 		static public Expression ImplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, true, loc);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="23" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2020" endline="2027">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2036" endline="2043">
<![CDATA[
 
 		public void EmitAttribute (PropertyBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2028" endline="2035">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2044" endline="2051">
<![CDATA[
 
 		public void EmitAttribute (TypeBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="24" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="107" endline="114">
<![CDATA[
 
 		public void AddUndefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="99" endline="106">
<![CDATA[
 
 		public void AddDefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="25" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1716" endline="1723">
<![CDATA[
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.CoClass;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1724" endline="1731">
<![CDATA[
 
 		public string GetAttributeDefaultMember ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.DefaultIndexerName;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="26" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1999" endline="2006">
<![CDATA[
 	}
 
 	sealed class PointerType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new PointerType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1757" endline="1766">
<![CDATA[
 	}
 
 	sealed class MultiArrayType 
 	{
 		private readonly int rank;
 
 		internal static Type Make(Type type, int rank, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new MultiArrayType(type, rank, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="27" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="764" endline="771">
<![CDATA[
 
 		public void SetParameter (Parameter parameter)
 		{
 			base.parameters = new ParametersCompiled (parameter);
 			base.parameter_info = new ParameterInfo[] {
 				new ParameterInfo (this, 0)
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="772" endline="780">
<![CDATA[
 
 		public void SetParameters (Parameter first, Parameter second)
 		{
 			base.parameters = new ParametersCompiled (first, second);
 			base.parameter_info = new ParameterInfo[] {
 				new ParameterInfo (this, 0),
 				new ParameterInfo (this, 1)
 			};
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="28" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="118" endline="125">
<![CDATA[
 		}
 
 		internal uint StrongNameSignatureRVA
 		{
 			get
 			{
 				return (ResourcesRVA + ResourcesLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="98" endline="112">
<![CDATA[
 		}
 
 		private uint ResourcesRVA
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 3) & ~3U;
 				}
 				else
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 15) & ~15U;
 				}
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="29" nfragments="8" Csharpe_files="8" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1539" endline="1547">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="865" endline="873">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasConstant()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2209" endline="2217">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1188" endline="1196">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasDeclSecurity()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2103" endline="2111">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1461" endline="1469">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1588" endline="1596">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMethodDef()
 				.WriteHasSemantics()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="30" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1645" endline="1653">
<![CDATA[
 
 		public void Emit (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Ldloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1654" endline="1662">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="31" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="51" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			FieldSignature other = obj as FieldSignature;
 			return other != null
 				&& other.fieldType.Equals(fieldType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="59" endline="67">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			PropertySignature other = obj as PropertySignature;
 			return other != null
 				&& other.propertyType.Equals(propertyType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="49" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			MethodSignature other = obj as MethodSignature;
 			return other != null
 				&& other.callingConvention == callingConvention
 				&& other.genericParamCount == genericParamCount
 				&& other.returnType.Equals(returnType)
 				&& Util.ArrayEquals(other.parameterTypes, parameterTypes)
 				&& Util.ArrayEquals(other.modifiers, modifiers);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="32" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="428" endline="436">
<![CDATA[
 		}
 
 		public int File {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].File;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="419" endline="427">
<![CDATA[
 		}
 
 		public int CompilationUnitIndex {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].CompilationUnit;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="33" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3030" endline="3038">
<![CDATA[
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3039" endline="3047">
<![CDATA[
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="34" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="66" endline="74">
<![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="77" endline="86">
<![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			PatchCallingConvention(mdBuilder);
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="35" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="87" endline="95">
<![CDATA[
 
 		internal void Write(int value)
 		{
 			buffer[0] = (byte)value;
 			buffer[1] = (byte)(value >> 8);
 			buffer[2] = (byte)(value >> 16);
 			buffer[3] = (byte)(value >> 24);
 			stream.Write(buffer, 0, 4);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="101" endline="113">
<![CDATA[
 
 		internal void Write(long value)
 		{
 			buffer[0] = (byte)value;
 			buffer[1] = (byte)(value >> 8);
 			buffer[2] = (byte)(value >> 16);
 			buffer[3] = (byte)(value >> 24);
 			buffer[4] = (byte)(value >> 32);
 			buffer[5] = (byte)(value >> 40);
 			buffer[6] = (byte)(value >> 48);
 			buffer[7] = (byte)(value >> 56);
 			stream.Write(buffer, 0, 8);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="36" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="544" endline="552">
<![CDATA[
 
 		Attribute ResolveModuleAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("module", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="535" endline="543">
<![CDATA[
 
 		public Attribute ResolveAssemblyAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("assembly", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="37" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="210" endline="218">
<![CDATA[
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (this.IsGenericMethodDefinition)
 			{
 				return this;
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="349" endline="357">
<![CDATA[
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (gtpb == null)
 			{
 				throw new InvalidOperationException();
 			}
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="38" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="339" endline="347">
<![CDATA[
 
 		public void SetNestedStoryParent (AnonymousMethodStorey parentStorey)
 		{
 			Parent = parentStorey;
 			type_params = null;
 			spec.IsGeneric = false;
 			spec.DeclaringType = parentStorey.CurrentType;
 			MemberName.TypeArguments = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1068" endline="1084">
<![CDATA[
 
 		private TypeInfo (TypeSpec type)
 		{
 			this.Type = type;
 
 			struct_info = StructInfo.GetStructInfo (type);
 			if (struct_info != null) {
 				Length = struct_info.Length;
 				TotalLength = struct_info.TotalLength;
 				SubStructInfo = struct_info.StructFields;
 				IsStruct = true;
 			} else {
 				Length = 0;
 				TotalLength = 1;
 				IsStruct = false;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="39" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1127" endline="1135">
<![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddContinueOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1100" endline="1108">
<![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddBreakOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="40" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1446" endline="1454">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakePointerType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1409" endline="1417">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakeByRefType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="41" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="196" endline="204">
<![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="221" endline="229">
<![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="42" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="646" endline="654">
<![CDATA[
 
 		private void WriteToken(FieldToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="655" endline="663">
<![CDATA[
 
 		private void WriteToken(MethodToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="43" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3625" endline="3633">
<![CDATA[
 
 		private static bool IsTypeUnsigned (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3612" endline="3624">
<![CDATA[
 
 		private static bool IsTypeIntegral (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.int64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.int32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.short_type ||
 				type == TypeManager.sbyte_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="44" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1469" endline="1477">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeAs", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1301" endline="1309">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeIs", args);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="45" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="591" endline="600">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attribs |= TypeAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="267" endline="276">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attributes |= MethodAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="46" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="124" endline="133">
<![CDATA[
 	
 		internal void Write(int value)
 		{
 			if (pos + 4 > buffer.Length)
 				Grow(4);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 			buffer[pos++] = (byte)(value >> 16);
 			buffer[pos++] = (byte)(value >> 24);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="139" endline="152">
<![CDATA[
 
 		internal void Write(long value)
 		{
 			if (pos + 8 > buffer.Length)
 				Grow(8);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 			buffer[pos++] = (byte)(value >> 16);
 			buffer[pos++] = (byte)(value >> 24);
 			buffer[pos++] = (byte)(value >> 32);
 			buffer[pos++] = (byte)(value >> 40);
 			buffer[pos++] = (byte)(value >> 48);
 			buffer[pos++] = (byte)(value >> 56);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="47" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="747" endline="756">
<![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="48" nfragments="28" Csharpe_files="28" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="79" endline="88">
<![CDATA[
 
 		internal Assembly ToAssembly()
 		{
 			if (imported)
 			{
 				throw new InvalidOperationException();
 			}
 			imported = true;
 			return module.Assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="80" endline="91">
<![CDATA[
 
 		internal int ReadBlobIndex()
 		{
 			if (bigBlobs)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="68" endline="79">
<![CDATA[
 
 		internal int ReadGuidIndex()
 		{
 			if (bigGuids)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="458" endline="469">
<![CDATA[
 
 		internal int ReadMethodDef()
 		{
 			if (bigMethodDef)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="482" endline="493">
<![CDATA[
 
 		internal int ReadProperty()
 		{
 			if (bigProperty)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="446" endline="457">
<![CDATA[
 
 		internal int ReadField()
 		{
 			if (bigField)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="494" endline="505">
<![CDATA[
 
 		internal int ReadEvent()
 		{
 			if (bigEvent)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="470" endline="481">
<![CDATA[
 
 		internal int ReadParam()
 		{
 			if (bigParam)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1450" endline="1464">
<![CDATA[
 		}
 
 		internal virtual Type BindTypeParameters(IGenericBinder binder)
 		{
 			if (IsGenericTypeDefinition)
 			{
 				Type[] args = GetGenericArguments();
 				Type.InplaceBindTypeParameters(binder, args);
 				return GenericTypeInstance.Make(this, args, null, null);
 			}
 			else
 			{
 				return this;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="150" endline="161">
<![CDATA[
 
 		internal void WriteStringIndex(int index)
 		{
 			if (bigStrings)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="199" endline="210">
<![CDATA[
 
 		internal override Type GetGenericMethodArgument(int index)
 		{
 			if (methodArgs == null)
 			{
 				return method.GetGenericMethodArgument(index);
 			}
 			else
 			{
 				return methodArgs[index];
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="299" endline="310">
<![CDATA[
 
 		internal void WriteTypeDef(int index)
 		{
 			if (bigTypeDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="263" endline="274">
<![CDATA[
 
 		internal void WriteField(int index)
 		{
 			if (bigField)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="670" endline="686">
<![CDATA[
 		}
 
 		internal override int ImportTo(ModuleBuilder other)
 		{
 			if (typeBuilder.IsGenericTypeDefinition)
 			{
 				return other.ImportMember(TypeBuilder.GetMethod(typeBuilder, this));
 			}
 			else if (other == typeBuilder.ModuleBuilder)
 			{
 				return pseudoToken;
 			}
 			else
 			{
 				return other.ImportMethodOrField(typeBuilder, name, this.MethodSignature);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="421" endline="432">
<![CDATA[
 		}
 
 		public IList<CustomAttributeTypedArgument> ConstructorArguments
 		{
 			get
 			{
 				if (lazyConstructorArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyConstructorArguments;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="174" endline="185">
<![CDATA[
 
 		internal void WriteBlobIndex(int index)
 		{
 			if (bigBlobs)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="166" endline="182">
<![CDATA[
 		}
 
 		internal override int ImportTo(ModuleBuilder other)
 		{
 			if (typeBuilder.IsGenericTypeDefinition)
 			{
 				return other.ImportMember(TypeBuilder.GetField(typeBuilder, this));
 			}
 			else if (other == typeBuilder.ModuleBuilder)
 			{
 				return pseudoToken;
 			}
 			else
 			{
 				return other.ImportMethodOrField(typeBuilder, name, fieldSig);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="63" endline="77">
<![CDATA[
 		}
 
 		internal uint ImportAddressTableLength
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return 8;
 				}
 				else
 				{
 					return 16;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="162" endline="173">
<![CDATA[
 
 		internal void WriteGuidIndex(int index)
 		{
 			if (bigGuids)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="347" endline="358">
<![CDATA[
 
 		internal void WriteModuleRef(int index)
 		{
 			if (bigModuleRef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="478" endline="490">
<![CDATA[
 		}
 
 		internal CustomAttributeBuilder DecodeBlob(Assembly asm)
 		{
 			if (blob == null)
 			{
 				return this;
 			}
 			else
 			{
 				return ToData(asm).__ToBuilder();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="275" endline="286">
<![CDATA[
 
 		internal void WriteMethodDef(int index)
 		{
 			if (bigMethodDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="323" endline="334">
<![CDATA[
 
 		internal void WriteProperty(int index)
 		{
 			if (bigProperty)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="287" endline="298">
<![CDATA[
 
 		internal void WriteParam(int index)
 		{
 			if (bigParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="311" endline="322">
<![CDATA[
 
 		internal void WriteEvent(int index)
 		{
 			if (bigEvent)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="335" endline="346">
<![CDATA[
 
 		internal void WriteGenericParam(int index)
 		{
 			if (bigGenericParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="214" endline="225">
<![CDATA[
 
 		internal void WriteEncodedTypeDefOrRef(int encodedToken)
 		{
 			if (bigTypeDefOrRef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="49" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1993" endline="2002">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2336" endline="2345">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="50" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="52" endline="61">
<![CDATA[
 
 		public override string ToString()
 		{
 			string str = name.ToString();
 			if (culture != null)
 			{
 				str = str.Replace("Culture=neutral", "Culture=" + culture);
 			}
 			return str;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="148" endline="160">
<![CDATA[
 		}
 
 		public string FullName
 		{
 			get
 			{
 				string str = name.FullName;
 				if (culture != null)
 				{
 					str = str.Replace("Culture=neutral", "Culture=" + culture);
 				}
 				return str;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="51" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1979" endline="1988">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(16)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2150" endline="2159">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="563" endline="574">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.WriteField()
 				.WriteMethodDef()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="52" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="443" endline="452">
<![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="550" endline="559">
<![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="53" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1233" endline="1243">
<![CDATA[
 
 		protected override bool ResolveNamedArguments (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveNamedArguments (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1222" endline="1232">
<![CDATA[
 
 		protected override MethodSpec ResolveConstructor (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveConstructor (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1211" endline="1221">
<![CDATA[
 
 		protected override TypeExpr ResolveAsTypeTerminal (Expression expr, IMemberContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveAsTypeTerminal (expr, ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="54" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="547" endline="557">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (0, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			return new Invocation (GetBinder ("InvokeConstructor", loc), binder_args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="525" endline="536">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			flags |= ec.HasSet (ResolveContext.Options.CheckedScope) ? CSharpBinderFlags.CheckedContext 
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			return new Invocation (GetBinder ("Convert", loc), binder_args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="580" endline="591">
<![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="723" endline="735">
<![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="55" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="659" endline="669">
<![CDATA[
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, modifiers, callingConvention, gtpb == null ? 0 
 				}
 				return methodSignature;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1319" endline="1330">
<![CDATA[
 		}
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, null, callingConvention, 0);
 				}
 				return methodSignature;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="56" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="574" endline="584">
<![CDATA[
 
 		internal int ImportMember(FieldInfo member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="563" endline="573">
<![CDATA[
 
 		internal int ImportMember(MethodBase member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="57" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="979" endline="989">
<![CDATA[
 		{
 			Expression e = Resolve (ec);
 			if (e == null)
 				return null;
 
 			ExpressionStatement es = e as ExpressionStatement;
 			if (es == null)
 				Error_InvalidExpressionStatement (ec);
 
 			return es;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1227" endline="1246">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			unwrap = Unwrap.Create (expr, false);
 			if (unwrap == null)
 				return null;
 
 			underlying = (UnaryMutator) new UnaryMutator (Mode, unwrap, loc).Resolve (ec);
 			if (underlying == null)
 				return null;
 
 
 			eclass = ExprClass.Value;
 			type = expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="58" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="625" endline="635">
<![CDATA[
 
 	public static bool IsBuiltinType (TypeSpec t)
 	{
 		if (t == object_type || t == string_type || t == int32_type || t == uint32_type ||
 		    t == int64_type || t == uint64_type || t == float_type || t == double_type ||
 		    t == char_type || t == short_type || t == decimal_type || t == bool_type ||
 		    t == sbyte_type || t == byte_type || t == ushort_type || t == void_type)
 			return true;
 		else
 			return false;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="636" endline="647">
<![CDATA[
 
 	//
 	// This is like IsBuiltinType, but lacks decimal_type, we should also clean up
 	// the pieces in the code where we use IsBuiltinType and special case decimal_type.
 	// 
 	public static bool IsPrimitiveType (TypeSpec t)
 	{
 		return (t == int32_type || t == uint32_type ||
 		    t == int64_type || t == uint64_type || t == float_type || t == double_type ||
 		    t == char_type || t == short_type || t == bool_type ||
 		    t == sbyte_type || t == byte_type || t == ushort_type);
 	}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="59" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2315" endline="2322">
<![CDATA[
 		}
 
 		public new void VerifyClsCompliance ()
 		{
 			foreach (TypeParameter tp in TypeParameters) {
 				tp.VerifyClsCompliance ();
 			}
 			foreach (TypeParameter tp in TypeParameters) {
 				tp.VerifyClsCompliance ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1480" endline="1495">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			if (type_params != null) {
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="60" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9525" endline="9536">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (base.CreateExpressionTree (ec)));
 			if (!initializers.IsEmpty)
 				args.Add (new Argument (initializers.CreateExpressionTree (ec)));
 
 			return CreateExpressionFactoryCall (ec,
 				initializers.IsCollectionInitializer ? "ListInit" 
 				args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5255" endline="5275">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args;
 			if (IsSingleDimensionalArrayLength ()) {
 				args = new Arguments (1);
 				args.Add (new Argument (InstanceExpression.CreateExpressionTree (ec)));
 				return CreateExpressionFactoryCall (ec, "ArrayLength", args);
 			}
 
 			args = new Arguments (2);
 			if (InstanceExpression == null)
 				args.Add (new Argument (new NullLiteral (loc)));
 			else
 				args.Add (new Argument (InstanceExpression.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOfMethod (Getter, loc)));
 			return CreateExpressionFactoryCall (ec, "Property", args);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="61" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2499" endline="2510">
<![CDATA[
 
 		public override void Emit ()
 		{
 			base.Emit ();
 
 			if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 				Module.PredefinedAttributes.Extension.EmitAttribute (TypeBuilder);
 
 			if (base_type != null && base_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (TypeBuilder, base_type, Location);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="219" endline="241">
<![CDATA[
 		}
 
 		public override void Emit ()
 		{
 			if (member_type == InternalType.Dynamic) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder);
 			} else if (!(Parent is CompilerGeneratedClass) && member_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder, member_type, Location);
 			}
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (FieldBuilder);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			if (((status & Status.HAS_OFFSET) == 0) && (ModFlags & (Modifiers.STATIC | Modifiers.BACKING_FIELD)) == 0 && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (625, Location, "`{0}'
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="62" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
<![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="167" endline="179">
<![CDATA[
 
 		private static Type ReadTypeOrVoid(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.PeekByte() == ELEMENT_TYPE_VOID)
 			{
 				br.ReadByte();
 				return module.universe.System_Void;
 			}
 			else
 			{
 				return ReadType(module, br, context);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="63" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="145" endline="152">
<![CDATA[
 
 		internal void WriteParamTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="64" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="106" endline="117">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ManifestResourceInfo.cs" startline="69" endline="88">
<![CDATA[
 		}
 
 		public string FileName
 		{
 			get
 			{
 				int implementation = module.ManifestResource.records[index].Implementation;
 				if ((implementation >> 24) == FileTable.Index)
 				{
 					if ((implementation & 0xFFFFFF) == 0)
 					{
 						return null;
 					}
 					else
 					{
 						return module.GetString(module.File.records[(implementation & 0xFFFFFF) - 1].Name);
 					}
 				}
 				throw new NotImplementedException();
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="65" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="551" endline="562">
<![CDATA[
 
 		public MethodToken GetConstructorToken(ConstructorInfo constructor)
 		{
 			if (constructor.Module == this && constructor.GetMethodInfo() is MethodBuilder)
 			{
 				return new MethodToken(constructor.MetadataToken);
 			}
 			else
 			{
 				return new MethodToken(ImportMember(constructor));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="462" endline="473">
<![CDATA[
 
 		public TypeToken GetTypeToken(Type type)
 		{
 			if (type.Module == this)
 			{
 				return new TypeToken(type.GetModuleBuilderToken());
 			}
 			else
 			{
 				return new TypeToken(ImportType(type));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="166" endline="186">
<![CDATA[
 		}
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (this.IsGenericMethod)
 			{
 				if (this.IsGenericMethodDefinition)
 				{
 					return this;
 				}
 				else if (declaringType.IsGenericType && !declaringType.IsGenericTypeDefinition)
 				{
 					return new GenericMethodInstance(declaringType, method, null);
 				}
 				else
 				{
 					return method;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="66" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1367" endline="1374">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1799" endline="1806">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1759" endline="1766">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1323" endline="1331">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1894" endline="1902">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="67" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="84" endline="95">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant ()) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="341" endline="357">
<![CDATA[
 		}
 
 		//TODO
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			parameters.VerifyClsCompliance (this);
 
 			if (!ReturnType.Type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="68" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1313" endline="1324">
<![CDATA[
 		
 		/// <summary>
 		///   Returns the MemberCore associated with a given name in the declaration
 		///   space. It doesn't return method based symbols !!
 		/// </summary>
 		/// 
 		public MemberCore GetDefinition (string name)
 		{
 			MemberCore mc = null;
 			defined_names.TryGetValue (name, out mc);
 			return mc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1440" endline="1454">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This kind of cast is used to encapsulate Value Types in objects.
 	///
 	///   The effect of it is to box the value type emitted by the previous
 	///   operation.
 	/// </summary>
 	public class BoxedCast 
 
 		public BoxedCast (Expression expr, TypeSpec target_type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="69" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="433" endline="444">
<![CDATA[
 		}
 
 		public IList<CustomAttributeNamedArgument> NamedArguments
 		{
 			get
 			{
 				if (lazyNamedArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyNamedArguments;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="719" endline="731">
<![CDATA[
 
 		public void Emit(OpCode opc, Type type)
 		{
 			Emit(opc);
 			if (opc == OpCodes.Ldtoken)
 			{
 				code.Write(moduleBuilder.GetTypeToken(type).Token);
 			}
 			else
 			{
 				code.Write(moduleBuilder.GetTypeTokenForMemberRef(type));
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="70" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="392" endline="403">
<![CDATA[
 
 		public override void SetFlags (uint flags, Location loc)
 		{
 			try {
 				if (assembly_flags == null)
 					assembly_flags = typeof (AssemblyBuilder).GetField ("flags", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_flags.SetValue (builder, flags);
 			} catch {
 				base.SetFlags (flags, loc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="404" endline="415">
<![CDATA[
 
 		public override void SetVersion (Version version, Location loc)
 		{
 			try {
 				if (assembly_version == null)
 					assembly_version = typeof (AssemblyBuilder).GetField ("version", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_version.SetValue (builder, version.ToString (4));
 			} catch {
 				base.SetVersion (version, loc);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="71" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="162" endline="173">
<![CDATA[
 	}
 
 	sealed class StringHeap 
 	{
 		private List<string> list = new List<string>();
 		private Dictionary<string, int> strings = new Dictionary<string, int>();
 		private int nextOffset;
 
 		internal StringHeap()
 		{
 			Add("");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="202" endline="213">
<![CDATA[
 	}
 
 	sealed class UserStringHeap 
 	{
 		private List<string> list = new List<string>();
 		private Dictionary<string, int> strings = new Dictionary<string, int>();
 		private int nextOffset;
 
 		internal UserStringHeap()
 		{
 			nextOffset = 1;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="72" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="543" endline="553">
<![CDATA[
 
 		public SourceFileEntry[] Sources {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				SourceFileEntry[] retval = new SourceFileEntry [SourceCount];
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="579" endline="589">
<![CDATA[
 
 		public CompileUnitEntry[] CompileUnits {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				CompileUnitEntry[] retval = new CompileUnitEntry [CompileUnitCount];
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="73" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="593" endline="605">
<![CDATA[
 
 		internal FieldInfo GetFieldAt(TypeDefImpl owner, int index)
 		{
 			if (fields == null)
 			{
 				fields = new FieldInfo[Field.records.Length];
 			}
 			if (fields[index] == null)
 			{
 				fields[index] = new FieldDefImpl(this, owner ?? FindFieldOwner(index), index);
 			}
 			return fields[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1910" endline="1934">
<![CDATA[
 
 		public PropertySpec GetProperty (string name, TypeSpec memberType, Location loc)
 		{
 			PropertySpec spec;
 
 			if (properties != null) {
 				spec = properties.Find (l => l.Name == name);
 			} else {
 				spec = null;
 			}
 
 			if (spec == null) {
 				spec = TypeManager.GetPredefinedProperty (type, name, loc, memberType);
 
 				if (spec != null) {
 					if (properties == null) {
 						properties = new List<PropertySpec> ();
 					}
 
 					properties.Add (spec);
 				}
 			}
 
 			return spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="491" endline="503">
<![CDATA[
 
 		private Assembly ResolveAssemblyRef(int index)
 		{
 			if (assemblyRefs == null)
 			{
 				assemblyRefs = new Assembly[AssemblyRef.RowCount];
 			}
 			if (assemblyRefs[index] == null)
 			{
 				assemblyRefs[index] = ResolveAssemblyRefImpl(ref AssemblyRef.records[index]);
 			}
 			return assemblyRefs[index];
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="74" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1340" endline="1348">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="822" endline="832">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1911" endline="1923">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder, int sdataRVA)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].RVA += sdataRVA;
 				if (moduleBuilder.IsPseudoToken(records[i].Field))
 				{
 					records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].RVA += sdataRVA;
 				if (moduleBuilder.IsPseudoToken(records[i].Field))
 				{
 					records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="75" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="888" endline="900">
<![CDATA[
 		}
 
 		internal void WriteTypeDefRecord(MetadataWriter mw, ref int fieldList, ref int methodList)
 		{
 			mw.Write((int)attribs);
 			mw.WriteStringIndex(typeName);
 			mw.WriteStringIndex(typeNameSpace);
 			mw.WriteTypeDefOrRef(extends);
 			mw.WriteField(fieldList);
 			mw.WriteMethodDef(methodList);
 			methodList += methods.Count;
 			fieldList += fields.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\CliHeader.cs" startline="71" endline="90">
<![CDATA[
 
 		internal void Write(IKVM.Reflection.Writer.MetadataWriter mw)
 		{
 			mw.Write(Cb);
 			mw.Write(MajorRuntimeVersion);
 			mw.Write(MinorRuntimeVersion);
 			mw.Write(MetaDataRVA);
 			mw.Write(MetaDataSize);
 			mw.Write(Flags);
 			mw.Write(EntryPointToken);
 			mw.Write(ResourcesRVA);
 			mw.Write(ResourcesSize);
 			mw.Write(StrongNameSignatureRVA);
 			mw.Write(StrongNameSignatureSize);
 			mw.Write(CodeManagerTable);
 			mw.Write(VTableFixupsRVA);
 			mw.Write(VTableFixupsSize);
 			mw.Write(ExportAddressTableJumps);
 			mw.Write(ManagedNativeHeader);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1963" endline="1978">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2044" endline="2059">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="76" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="100" endline="113">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1025" endline="1038">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="77" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="334" endline="343">
<![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="607" endline="617">
<![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			typeFlags |= TypeFlags.IsGenericTypeDefinition;
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="78" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="457" endline="470">
<![CDATA[
 
 		internal void WriteHasSemantics(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasSemantics)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="550" endline="563">
<![CDATA[
 
 		internal void WriteHasFieldMarshal(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasFieldMarshal)
 			{
 				Write(encodedToken & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="226" endline="239">
<![CDATA[
 
 		internal void WriteHasCustomAttribute(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasCustomAttribute)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="499" endline="512">
<![CDATA[
 
 		internal void WriteTypeOrMethodDef(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigTypeOrMethodDef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="513" endline="526">
<![CDATA[
 
 		internal void WriteHasDeclSecurity(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasDeclSecurity)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="79" nfragments="8" Csharpe_files="8" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="715" endline="723">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1113" endline="1121">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1706" endline="1715">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="855" endline="864">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="789" endline="798">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1529" endline="1538">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2093" endline="2102">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1451" endline="1460">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="80" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1412" endline="1420">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1490" endline="1498">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="81" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="210" endline="223">
<![CDATA[
 
 		public override Module LoadModule(string moduleName, byte[] rawModule)
 		{
 			int index = GetModuleIndex(moduleName);
 			if (index == -1)
 			{
 				throw new ArgumentException();
 			}
 			if (externalModules[index] != null)
 			{
 				return externalModules[index];
 			}
 			return LoadModule(index, rawModule, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="92" endline="112">
<![CDATA[
 
 		public Type GetType(string typeName, bool throwOnError)
 		{
 			TypeNameParser parser = TypeNameParser.Parse(typeName, throwOnError);
 			if (parser.Error)
 			{
 				return null;
 			}
 			if (parser.AssemblyName != null)
 			{
 				if (throwOnError)
 				{
 					throw new ArgumentException("Type names passed to Assembly.GetType() must not specify an assembly.");
 				}
 				else
 				{
 					return null;
 				}
 			}
 			return parser.Expand(GetTypeImpl(parser.FirstNamePart), this, throwOnError, typeName);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="82" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="191" endline="200">
<![CDATA[
 
 		public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="432" endline="441">
<![CDATA[
 
 		public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineNestedType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="83" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2529" endline="2538">
<![CDATA[
 
 		public static OpType? GetType (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="861" endline="876">
<![CDATA[
 
 		private static bool MatchParameterTypes(ParameterInfo[] parameters, Type[] types)
 		{
 			if (parameters.Length == types.Length)
 			{
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (!parameters[i].ParameterType.Equals(types[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (!parameters[i].ParameterType.Equals(types[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2369" endline="2381">
<![CDATA[
 
 		internal int FindFirstByOwner(int token)
 		{
 			// TODO use binary search (if sorted)
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			return -1;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="84" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="82" endline="96">
<![CDATA[
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1039" endline="1056">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Field) {
 				backing_field.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				int errors = Report.Errors;
 				Add.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				if (errors == Report.Errors)
 					Remove.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="85" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="69" endline="79">
<![CDATA[
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = method.GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ConstructorInfo.cs" startline="49" endline="59">
<![CDATA[
 		}
 
 		public sealed override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = GetMethodInfo().GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="86" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="726" endline="740">
<![CDATA[
 		}
 
 		public override string Name
 		{
 			get
 			{
 				if (this.IsNested)
 				{
 					return nameOrFullName;
 				}
 				else
 				{
 					return base.Name;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="743" endline="754">
<![CDATA[
 
 		public virtual Type GetNestedType(string name, BindingFlags bindingAttr)
 		{
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="87" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="636" endline="646">
<![CDATA[
 
 		internal void WriteParamRecords(MetadataWriter mw)
 		{
 			if (parameters != null)
 			{
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.WriteParamRecord(mw);
 				}
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.WriteParamRecord(mw);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="647" endline="658">
<![CDATA[
 
 		internal void FixupToken(int token, ref int parameterToken)
 		{
 			typeBuilder.ModuleBuilder.RegisterTokenFixup(this.pseudoToken, token);
 			if (parameters != null)
 			{
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="88" nfragments="29" Csharpe_files="29" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1354" endline="1366">
<![CDATA[
 	}
 
 	sealed class StandAloneSigTable 
 	{
 		internal const int Index = 0x11;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1786" endline="1798">
<![CDATA[
 	}
 
 	sealed class TypeSpecTable 
 	{
 		internal const int Index = 0x1B;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1746" endline="1758">
<![CDATA[
 	}
 
 	sealed class ModuleRefTable 
 	{
 		internal const int Index = 0x1A;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1392" endline="1411">
<![CDATA[
 	}
 
 	sealed class EventMapTable 
 	{
 		internal const int Index = 0x12;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int EventList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1470" endline="1489">
<![CDATA[
 	}
 
 	sealed class PropertyMapTable 
 	{
 		internal const int Index = 0x15;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int PropertyList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1093" endline="1112">
<![CDATA[
 	}
 
 	sealed class FieldMarshalTable 
 	{
 		internal const int Index = 0x0D;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int NativeType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1303" endline="1322">
<![CDATA[
 	}
 
 	sealed class FieldLayoutTable 
 	{
 		internal const int Index = 0x10;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="575" endline="596">
<![CDATA[
 	}
 
 	sealed class FieldTable 
 	{
 		internal const int Index = 0x04;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2218" endline="2237">
<![CDATA[
 	}
 
 	sealed class NestedClassTable 
 	{
 		internal const int Index = 0x29;
 
 		internal struct Record
 		{
 			internal int NestedClass;
 			internal int EnclosingClass;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2443" endline="2462">
<![CDATA[
 	}
 
 	sealed class GenericParamConstraintTable 
 	{
 		internal const int Index = 0x2C;
 
 		internal struct Record
 		{
 			internal int Owner;
 			internal int Constraint;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1156" endline="1177">
<![CDATA[
 	}
 
 	sealed class DeclSecurityTable 
 	{
 		internal const int Index = 0x0E;
 
 		internal struct Record
 		{
 			internal short Action;
 			internal int Parent;
 			internal int PermissionSet;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1507" endline="1528">
<![CDATA[
 	}
 
 	sealed class PropertyTable 
 	{
 		internal const int Index = 0x17;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Type;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1429" endline="1450">
<![CDATA[
 	}
 
 	sealed class EventTable 
 	{
 		internal const int Index = 0x14;
 
 		internal struct Record
 		{
 			internal short EventFlags;
 			internal int Name;
 			internal int EventType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="767" endline="788">
<![CDATA[
 	}
 
 	sealed class MemberRefTable 
 	{
 		internal const int Index = 0x0A;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1684" endline="1705">
<![CDATA[
 	}
 
 	sealed class MethodImplTable 
 	{
 		internal const int Index = 0x19;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int MethodBody;
 			internal int MethodDeclaration;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2268" endline="2293">
<![CDATA[
 	}
 
 	sealed class GenericParamTable 
 	{
 		internal const int Index = 0x2A;
 
 		internal struct Record
 		{
 			internal short Number;
 			internal short Flags;
 			internal int Owner;
 			internal int Name;
 			// not part of the table, we use it to be able to fixup the GenericParamConstraint table
 			internal int unsortedIndex;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2382" endline="2401">
<![CDATA[
 	}
 
 	sealed class MethodSpecTable 
 	{
 		internal const int Index = 0x2B;
 
 		internal struct Record
 		{
 			internal int Method;
 			internal int Instantiation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2071" endline="2092">
<![CDATA[
 	}
 
 	sealed class FileTable 
 	{
 		internal const int Index = 0x26;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int Name;
 			internal int HashValue;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="660" endline="681">
<![CDATA[
 	}
 
 	sealed class ParamTable 
 	{
 		internal const int Index = 0x08;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal short Sequence;
 			internal int Name;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1874" endline="1893">
<![CDATA[
 	}
 
 	sealed class FieldRVATable 
 	{
 		internal const int Index = 0x1D;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="484" endline="505">
<![CDATA[
 	}
 
 	sealed class TypeRefTable 
 	{
 		internal const int Index = 0x01;
 
 		internal struct Record
 		{
 			internal int ResolutionScope;
 			internal int TypeName;
 			internal int TypeNameSpace;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="965" endline="986">
<![CDATA[
 	}
 
 	sealed class CustomAttributeTable 
 	{
 		internal const int Index = 0x0C;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int Type;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="833" endline="854">
<![CDATA[
 	}
 
 	sealed class ConstantTable 
 	{
 		internal const int Index = 0x0B;
 
 		internal struct Record
 		{
 			internal short Type;
 			internal int Parent;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2174" endline="2197">
<![CDATA[
 	}
 
 	sealed class ManifestResourceTable 
 	{
 		internal const int Index = 0x28;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Flags;
 			internal int Name;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1548" endline="1577">
<![CDATA[
 	}
 
 	sealed class MethodSemanticsTable 
 	{
 		internal const int Index = 0x18;
 
 		// semantics
 		internal const short Setter = 0x0001;
 		internal const short Getter = 0x0002;
 		internal const short Other = 0x0004;
 		internal const short AddOn = 0x0008;
 		internal const short RemoveOn = 0x0010;
 		internal const short Fire = 0x0020;
 
 		internal struct Record
 		{
 			internal short Semantics;
 			internal int Method;
 			internal int Association;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1812" endline="1835">
<![CDATA[
 	}
 
 	sealed class ImplMapTable 
 	{
 		internal const int Index = 0x1C;
 
 		internal struct Record
 		{
 			internal short MappingFlags;
 			internal int MemberForwarded;
 			internal int ImportName;
 			internal int ImportScope;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="611" endline="639">
<![CDATA[
 	}
 
 	sealed class MethodDefTable 
 	{
 		internal const int Index = 0x06;
 		private int baseRVA;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal short ImplFlags;
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 			internal int ParamList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="525" endline="552">
<![CDATA[
 	}
 
 	sealed class TypeDefTable 
 	{
 		internal const int Index = 0x02;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Extends;
 			internal int FieldList;
 			internal int MethodList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="89" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="241" endline="253">
<![CDATA[
 
 		internal static int GetHashCode(Type[][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="254" endline="266">
<![CDATA[
 
 		internal static int GetHashCode(Type[][][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="90" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="431" endline="447">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			expr.Emit (ec);
 
 			ec.Emit (OpCodes.Br, end_label);
 			ec.MarkLabel (is_null_label);
 
 			null_value.Emit (ec);
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="502" endline="524">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			if (user_operator != null) {
 				user_operator.Emit (ec);
 			} else {
 				EmitOperator (ec, NullableInfo.GetUnderlyingType (type));
 			}
 
 			ec.Emit (OpCodes.Newobj, NullableInfo.GetConstructor (type));
 			ec.Emit (OpCodes.Br_S, end_label);
 
 			ec.MarkLabel (is_null_label);
 			LiftedNull.Create (type, loc).Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1247" endline="1268">
<![CDATA[
 
 		void DoEmit (EmitContext ec, bool is_expr)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			if (is_expr) {
 				underlying.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end_label);
 			} else {
 				underlying.EmitStatement (ec);
 			}
 
 			ec.MarkLabel (is_null_label);
 			if (is_expr)
 				LiftedNull.Create (type, loc).Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1164" endline="1198">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label end_label = ec.DefineLabel ();
 
 			if (unwrap != null) {
 				Label is_null_label = ec.DefineLabel ();
 
 				unwrap.EmitCheck (ec);
 				ec.Emit (OpCodes.Brfalse, is_null_label);
 
 				left.Emit (ec);
 				ec.Emit (OpCodes.Br, end_label);
 
 				ec.MarkLabel (is_null_label);
 				right.Emit (ec);
 
 				ec.MarkLabel (end_label);
 				return;
 			}
 
 			left.Emit (ec);
 			ec.Emit (OpCodes.Dup);
 
 			// Only to make verifier happy
 			if (left.Type.IsGenericParameter)
 				ec.Emit (OpCodes.Box, left.Type);
 
 			ec.Emit (OpCodes.Brtrue, end_label);
 
 			ec.Emit (OpCodes.Pop);
 			right.Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="91" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="80" endline="96">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= EventAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="92" endline="108">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= PropertyAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="92" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1230" endline="1246">
<![CDATA[
 
 
 		/// <summary>
 		///   Attempts to apply the `Standard Implicit
 		///   Conversion' rules to the expression `expr' into
 		///   the `target_type'.  It returns a new expression
 		///   that can be used in a context that expects a
 		///   `target_type'.
 		///
 		///   This is different from `ImplicitConversion' in that the
 		///   user defined implicit conversions are excluded.
 		/// </summary>
 		static public Expression ImplicitConversionStandard (ResolveContext ec, Expression expr,
 								     TypeSpec target_type, Location loc)
 		{
 			return ImplicitConversionStandard (ec, expr, target_type, loc, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="175" endline="196">
<![CDATA[
 
 		/// <summary>
 		///   The base class for the classes that host the user generated code
 		/// </summary>
 		/// <remarks>
 		///
 		///   This is the base class that will host the code
 		///   executed by the Evaluator.  By default
 		///   this is the Mono.CSharp.InteractiveBase class
 		///   which is useful for interactive use.
 		///
 		///   By changing this property you can control the
 		///   base class and the static members that are
 		///   available to your evaluated code.
 		/// </remarks>
 		static public TypeSpec InteractiveBaseClass {
 			get {
 				if (interactive_base_class != null)
 					return interactive_base_class;
 
 				return loader.Importer.ImportType (typeof (InteractiveBase));
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="93" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="936" endline="951">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddContinueOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new ContinueOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="920" endline="935">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddBreakOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new BreakOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="94" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="661" endline="676">
<![CDATA[
 
 		static public DSA FromCapiKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			switch (blob [offset]) {
 				case 0x06
 					return FromCapiPublicKeyBlobDSA (blob, offset);
 				case 0x07
 					return FromCapiPrivateKeyBlobDSA (blob, offset);
 			}
 			throw new CryptographicException ("Unknown blob format.");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="633" endline="655">
<![CDATA[
 
 		static public RSA FromCapiKeyBlob (byte[] blob, int offset) 
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			switch (blob [offset]) {
 				case 0x00
 					// this could be a public key inside an header
 					// like "sn -e" would produce
 					if (blob [offset + 12] == 0x06) {
 						return FromCapiPublicKeyBlob (blob, offset + 12);
 					}
 					break;
 				case 0x06
 					return FromCapiPublicKeyBlob (blob, offset);
 				case 0x07
 					return FromCapiPrivateKeyBlob (blob, offset);
 			}
 			throw new CryptographicException ("Unknown blob format.");
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="95" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="299" endline="314">
<![CDATA[
 	}
 
 	public struct LocalVariableEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly int Index;
 		public readonly string Name;
 		public readonly int BlockIndex;
 		#endregion
 
 		public LocalVariableEntry (int index, string name, int block)
 		{
 			this.Index = index;
 			this.Name = name;
 			this.BlockIndex = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="335" endline="358">
<![CDATA[
 	}
 
 	public struct CapturedVariable
 	{
 		#region This is actually written to the symbol file
 		public readonly string Name;
 		public readonly string CapturedName;
 		public readonly CapturedKind Kind;
 		#endregion
 
 		public enum CapturedKind 
 		{
 			Local,
 			Parameter,
 			This
 		}
 
 		public CapturedVariable (string name, string captured_name,
 					 CapturedKind kind)
 		{
 			this.Name = name;
 			this.CapturedName = captured_name;
 			this.Kind = kind;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="233" endline="263">
<![CDATA[
 
 		public override string ToString ()
 		{
 			return String.Format ("[Line {0}
 		}
 	}
 
 	public class CodeBlockEntry
 	{
 		public int Index;
 		#region This is actually written to the symbol file
 		public int Parent;
 		public Type BlockType;
 		public int StartOffset;
 		public int EndOffset;
 		#endregion
 
 		public enum Type {
 			Lexical			= 1,
 			CompilerGenerated	= 2,
 			IteratorBody		= 3,
 			IteratorDispatcher	= 4
 		}
 
 		public CodeBlockEntry (int index, int parent, Type type, int start_offset)
 		{
 			this.Index = index;
 			this.Parent = parent;
 			this.BlockType = type;
 			this.StartOffset = start_offset;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="96" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="151" endline="166">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			BlockContext bc = new BlockContext (ec.MemberContext, Block, ReturnType);
 			Expression args = parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (type, loc)),
 				arguments);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="30" endline="51">
<![CDATA[
 
 		protected override Expression CreateExpressionTree (ResolveContext ec, TypeSpec delegate_type)
 		{
 			if (ec.IsInProbingMode)
 				return this;
 
 			BlockContext bc = new BlockContext (ec.MemberContext, ec.ConstructorBlock, TypeManager.void_type) {
 				CurrentAnonymousMethod = ec.CurrentAnonymousMethod
 			};
 
 			Expression args = Parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (delegate_type, loc)),
 				arguments);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="97" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7935" endline="7950">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, true))
 				Expr = Expr.Resolve (ec);
 			
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7997" endline="8012">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, false))
 				Expr = Expr.Resolve (ec);
 
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="98" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="617" endline="632">
<![CDATA[
 
 		/// <summary>
 		/// Returns custom name of indexer
 		/// </summary>
 		public string GetIndexerAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments [0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="633" endline="648">
<![CDATA[
 
 		/// <summary>
 		/// Returns condition of ConditionalAttribute
 		/// </summary>
 		public string GetConditionalAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments[0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="99" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="294" endline="312">
<![CDATA[
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (4);
 
 			default_references.Add ("System.dll");
 			default_references.Add ("System.Xml.dll");
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core.dll");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp.dll");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="437" endline="461">
<![CDATA[
 		}
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (8);
 
 			default_references.Add ("System");
 			default_references.Add ("System.Xml");
 #if NET_2_1
 			default_references.Add ("System.Net");
 			default_references.Add ("System.Windows");
 			default_references.Add ("System.Windows.Browser");
 #endif
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="100" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="175" endline="186">
<![CDATA[
 
 		private int GetModuleIndex(string name)
 		{
 			for (int i = 0; i < manifestModule.File.records.Length; i++)
 			{
 				if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
 				{
 					return i;
 				}
 			}
 			for (int i = 0; i < manifestModule.File.records.Length; i++)
 			{
 				if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
 				{
 					return i;
 				}
 			}
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="774" endline="787">
<![CDATA[
 
 		protected static Type[][][] BindTypeParameters(IGenericBinder binder, Type[][][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][][] expanded = new Type[types.Length][][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="760" endline="773">
<![CDATA[
 
 		protected static Type[][] BindTypeParameters(IGenericBinder binder, Type[][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][] expanded = new Type[types.Length][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="101" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="212" endline="223">
<![CDATA[
 
 		public ModuleBuilder GetDynamicModule(string name)
 		{
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name == name)
 				{
 					return module;
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name == name)
 				{
 					return module;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="570" endline="588">
<![CDATA[
 
 		public override Module GetModule(string name)
 		{
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="102" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1278" endline="1294">
<![CDATA[
 		}
 
 		public MethodInfo GetConstructor ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var ctor = mb.GetArrayMethod (
 				GetMetaInfo (), Constructor.ConstructorName,
 				CallingConventions.HasThis,
 				null, arg_types);
 
 			return ctor;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1311" endline="1326">
<![CDATA[
 
 		public MethodInfo GetGetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var get = mb.GetArrayMethod (
 				GetMetaInfo (), "Get",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				Element.GetMetaInfo (), arg_types);
 
 			return get;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1295" endline="1310">
<![CDATA[
 
 		public MethodInfo GetAddressMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var address = mb.GetArrayMethod (
 				GetMetaInfo (), "Address",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				ReferenceContainer.MakeType (Element).GetMetaInfo (), arg_types);
 
 			return address;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1327" endline="1344">
<![CDATA[
 
 		public MethodInfo GetSetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank + 1];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			arg_types[rank] = Element.GetMetaInfo ();
 
 			var set = mb.GetArrayMethod (
 				GetMetaInfo (), "Set",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				TypeManager.void_type.GetMetaInfo (), arg_types);
 
 			return set;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="103" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="462" endline="473">
<![CDATA[
 
 		public EventInfo GetEvent(string name, BindingFlags bindingAttr)
 		{
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="909" endline="924">
<![CDATA[
 
 		public Type GetInterface(string name, bool ignoreCase)
 		{
 			if (ignoreCase)
 			{
 				throw new NotImplementedException();
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (type.FullName == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (type.FullName == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="104" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1380" endline="1391">
<![CDATA[
 
 		internal int FindOrAddRecord(int blob)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(blob);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1774" endline="1785">
<![CDATA[
 
 		internal int FindOrAddRecord(int str)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(str);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2419" endline="2431">
<![CDATA[
 
 		internal int FindOrAddRecord(Record record)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(record);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="105" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="550" endline="568">
<![CDATA[
 
 		public Assembly LoadFile(string path)
 		{
 			try
 			{
 				using (RawModule module = OpenRawModule(path))
 				{
 					return LoadAssembly(module);
 				}
 			}
 			catch (IOException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 			catch (UnauthorizedAccessException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="183" endline="207">
<![CDATA[
 
 		public static AssemblyName GetAssemblyName(string path)
 		{
 			try
 			{
 				path = Path.GetFullPath(path);
 				using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
 				{
 					ModuleReader module = new ModuleReader(null, null, fs, path);
 					if (module.Assembly == null)
 					{
 						throw new BadImageFormatException("Module does not contain a manifest");
 					}
 					return module.Assembly.GetName();
 				}
 			}
 			catch (IOException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 			catch (UnauthorizedAccessException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="106" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="228" endline="239">
<![CDATA[
 
 		internal override void GetTypesImpl(List<Type> list)
 		{
 			PopulateTypeDef();
 			foreach (TypeDefImpl type in typeDefs)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (TypeDefImpl type in typeDefs)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="441" endline="451">
<![CDATA[
 
 		internal override void GetTypesImpl(List<Type> list)
 		{
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="56" endline="69">
<![CDATA[
 		}
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="334" endline="346">
<![CDATA[
 
 		public Type[] FindTypes(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="925" endline="937">
<![CDATA[
 
 		public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="107" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="466" endline="483">
<![CDATA[
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			PropertyBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="36" endline="57">
<![CDATA[
 		{
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					builder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2402" endline="2430">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.AttributeUsage) {
 				if (!BaseType.IsAttribute && spec != TypeManager.attribute_type) {
 					Report.Error (641, a.Location, "Attribute `{0}' is only valid on classes derived from System.Attribute", a.GetSignatureForError ());
 				}
 			}
 
 			if (a.Type == pa.Conditional && !BaseType.IsAttribute) {
 				Report.Error (1689, a.Location, "Attribute `System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes");
 				return;
 			}
 
 			if (a.Type == pa.ComImport && !attributes.Contains (pa.Guid)) {
 				a.Error_MissingGuidAttribute ();
 				return;
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			if (a.Type.IsConditionallyExcluded (Location))
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="114" endline="156">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.FieldOffset) {
 				status |= Status.HAS_OFFSET;
 
 				if (!Parent.PartialContainer.HasExplicitLayout) {
 					Report.Error (636, Location, "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)");
 					return;
 				}
 
 				if ((ModFlags & Modifiers.STATIC) != 0 || this is Const) {
 					Report.Error (637, Location, "The FieldOffset attribute is not allowed on static or const fields");
 					return;
 				}
 			}
 
 			if (a.Type == pa.FixedBuffer) {
 				Report.Error (1716, Location, "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead");
 				return;
 			}
 
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					FieldBuilder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="108" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="575" endline="589">
<![CDATA[
 
 		public override void LoadReferences (ModuleContainer module)
 		{
 			Assembly corlib;
 			List<Tuple<RootNamespace, Assembly>> loaded;
 			base.LoadReferencesCore (module, out corlib, out loaded);
 
 			if (corlib == null)
 				return;
 
 			importer.ImportAssembly (corlib, module.GlobalRootNamespace);
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="444" endline="458">
<![CDATA[
 
 		public override void LoadReferences (ModuleContainer module)
 		{
 			List<Tuple<RootNamespace, Assembly>> loaded;
 			base.LoadReferencesCore (module, out corlib, out loaded);
 
 			if (corlib != null) {
 				importer.InitializeBuildinTypes (compiler.BuildinTypes, corlib);
 				importer.ImportAssembly (corlib, module.GlobalRootNamespace);
 			}
 
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="109" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="600" endline="620">
<![CDATA[
 
 		void EmitMoveNext_NoResumePoints (EmitContext ec, Block original_block)
 		{
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.Emit (OpCodes.Ldfld, IteratorHost.PC.Spec);
 
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt ((int) State.After);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			// We only care if the PC is zero (start executing) or non-zero (don't do anything)
 			ec.Emit (OpCodes.Brtrue, move_next_error);
 
 			SymbolWriter.StartIteratorBody (ec);
 			original_block.Emit (ec);
 			SymbolWriter.EndIteratorBody (ec);
 
 			ec.MarkLabel (move_next_error);
 			ec.Emit (OpCodes.Ldc_I4_0);
 			ec.Emit (OpCodes.Ret);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="739" endline="765">
<![CDATA[
 
 		//
 		// Called back from Yield
 		//
 		public void MarkYield (EmitContext ec, Expression expr, int resume_pc, bool unwind_protect, Label resume_point)
 		{
 			// Store the new current
 			ec.Emit (OpCodes.Ldarg_0);
 			expr.Emit (ec);
 			ec.Emit (OpCodes.Stfld, IteratorHost.CurrentField.Spec);
 
 			// store resume program-counter
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt (resume_pc);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			// mark finally blocks as disabled
 			if (unwind_protect && skip_finally != null) {
 				ec.EmitInt (1);
 				ec.Emit (OpCodes.Stloc, skip_finally);
 			}
 
 			// Return ok
 			ec.Emit (unwind_protect ? OpCodes.Leave 
 
 			ec.MarkLabel (resume_point);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="816" endline="838">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Load Iterator storey instance
 			//
 			IteratorHost.Instance.Emit (ec);
 
 			//
 			// Initialize iterator PC when it's unitialized
 			//
 			if (IsEnumerable) {
 				ec.Emit (OpCodes.Dup);
 				ec.EmitInt ((int)State.Uninitialized);
 
 				var field = IteratorHost.PC.Spec;
 				if (Storey.MemberName.IsGeneric) {
 					field = MemberCache.GetMember (Storey.Instance.Type, field);
 				}
 
 				ec.Emit (OpCodes.Stfld, field);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="110" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2262" endline="2282">
<![CDATA[
 		
 		bool pp_unary (ref string s)
 		{
 			s = s.Trim ();
 			int len = s.Length;
 
 			if (len > 0){
 				if (s [0] == '!'){
 					if (len > 1 && s [1] == '='){
 						Error_InvalidDirective ();
 						return false;
 					}
 					s = s.Substring (1);
 					return ! pp_primary (ref s);
 				} else
 					return pp_primary (ref s);
 			} else {
 				Error_InvalidDirective ();
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2283" endline="2309">
<![CDATA[
 		
 		bool pp_eq (ref string s)
 		{
 			bool va = pp_unary (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '='){
 					if (len > 2 && s [1] == '='){
 						s = s.Substring (2);
 						return va == pp_unary (ref s);
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} else if (s [0] == '!' && len > 1 && s [1] == '='){
 					s = s.Substring (2);
 
 					return va != pp_unary (ref s);
 
 				} 
 			}
 
 			return va;
 				
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2310" endline="2329">
<![CDATA[
 		
 		bool pp_and (ref string s)
 		{
 			bool va = pp_eq (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '&'){
 					if (len > 2 && s [1] == '&'){
 						s = s.Substring (2);
 						return (va & pp_and (ref s));
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} 
 			}
 			return va;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2330" endline="2358">
<![CDATA[
 		
 		//
 		// Evaluates an expression for `#if' or `#elif'
 		//
 		bool pp_expr (ref string s, bool isTerm)
 		{
 			bool va = pp_and (ref s);
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				char c = s [0];
 				
 				if (c == '|'){
 					if (len > 2 && s [1] == '|'){
 						s = s.Substring (2);
 						return va | pp_expr (ref s, isTerm);
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				}
 				if (isTerm) {
 					Error_EndLineExpected ();
 					return false;
 				}
 			}
 			
 			return va;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="111" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="437" endline="457">
<![CDATA[
 		}
 
 		// The ISymbolDocumentWriter interface is used by the symbol writer to
 		// describe a single source file - for each source file there's exactly
 		// one corresponding ISymbolDocumentWriter instance.
 		//
 		// This class has an internal hash table mapping source document names
 		// to such ISymbolDocumentWriter instances - so there's exactly one
 		// instance per document.
 		//
 		// This property returns the ISymbolDocumentWriter instance which belongs
 		// to the location's source file.
 		//
 		// If we don't have a symbol writer, this property is always null.
 		public SourceFile SourceFile {
 			get {
 				int index = File;
 				if (index == 0)
 					return null;
 				return (SourceFile) source_list [index - 1];
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="35" endline="59">
<![CDATA[
 
 		/// <summary>
 		///   We already know that the statement is unreachable, but we still
 		///   need to resolve it to catch errors.
 		/// </summary>
 		public virtual bool ResolveUnreachable (BlockContext ec, bool warn)
 		{
 			//
 			// This conflicts with csc's way of doing this, but IMHO it's
 			// the right thing to do.
 			//
 			// If something is unreachable, we still check whether it's
 			// correct.  This means that you cannot use unassigned variables
 			// in unreachable code, for instance.
 			//
 
 			if (warn)
 				ec.Report.Warning (162, 2, loc, "Unreachable code detected");
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Block, loc);
 			bool ok = Resolve (ec);
 			ec.KillFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="322" endline="362">
<![CDATA[
 		}
 
 		protected Options flags;
 
 		//
 		// Whether we are inside an anonymous method.
 		//
 		public AnonymousExpression CurrentAnonymousMethod;
 
 		//
 		// Holds a varible used during collection or object initialization.
 		//
 		public Expression CurrentInitializerVariable;
 
 		public Block CurrentBlock;
 
 		public readonly IMemberContext MemberContext;
 
 		/// <summary>
 		///   If this is non-null, points to the current switch statement
 		/// </summary>
 		public Switch Switch;
 
 		public ResolveContext (IMemberContext mc)
 		{
 			if (mc == null)
 				throw new ArgumentNullException ();
 
 			MemberContext = mc;
 
 			//
 			// The default setting comes from the command line option
 			//
 			if (RootContext.Checked)
 				flags |= Options.CheckedScope;
 
 			//
 			// The constant check state is always set to true
 			//
 			flags |= Options.ConstantCheckState;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="112" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="461" endline="481">
<![CDATA[
 
 		/// <summary>
 		///   Executes the given expression or statement.
 		/// </summary>
 		/// <remarks>
 		///    Executes the provided statement, returns true
 		///    on success, false on parsing errors.  Exceptions
 		///    might be thrown by the called code.
 		/// </remarks>
 		public static bool Run (string statement)
 		{
 			if (!inited)
 				Init ();
 
 			object result;
 			bool result_set;
 
 			bool ok = Evaluate (statement, out result, out result_set) == null;
 			
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="298" endline="330">
<![CDATA[
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   This method can only deal with fully formed input
 		///   strings and does not provide a completion mechanism.
 		///   If you must deal with partial input (for example for
 		///   interactive use) use the other overload. 
 		///
 		///   On success, a delegate is returned that can be used
 		///   to invoke the method.
 		///
 	        /// </remarks>
 		static public CompiledMethod Compile (string input)
 		{
 			CompiledMethod compiled;
 
 			// Ignore partial inputs
 			if (Compile (input, out compiled) != null){
 				// Error, the input was partial.
 				return null;
 			}
 
 			// Either null (on error) or the compiled method.
 			return compiled;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="113" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="445" endline="465">
<![CDATA[
 		}
 
 		private void LazyParseArguments()
 		{
 			ByteReader br = module.GetBlob(module.CustomAttribute.records[index].Value);
 			if (br.Length == 0)
 			{
 				// it's legal to have an empty blob
 				lazyConstructorArguments = Empty<CustomAttributeTypedArgument>.Array;
 				lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
 			}
 			else
 			{
 				if (br.ReadUInt16() != 1)
 				{
 					throw new BadImageFormatException();
 				}
 				lazyConstructorArguments = ReadConstructorArguments(module.Assembly, br, Constructor);
 				lazyNamedArguments = ReadNamedArguments(module.Assembly, br, br.ReadUInt16(), Constructor.DeclaringType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="68" endline="87">
<![CDATA[
 
 		internal CustomAttributeData(Assembly asm, ConstructorInfo constructor, ByteReader br)
 		{
 			this.lazyConstructor = constructor;
 			if (br.Length == 0)
 			{
 				// it's legal to have an empty blob
 				lazyConstructorArguments = Empty<CustomAttributeTypedArgument>.Array;
 				lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
 			}
 			else
 			{
 				if (br.ReadUInt16() != 1)
 				{
 					throw new BadImageFormatException();
 				}
 				lazyConstructorArguments = ReadConstructorArguments(asm, br, constructor);
 				lazyNamedArguments = ReadNamedArguments(asm, br, br.ReadUInt16(), constructor.DeclaringType);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="114" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="135" endline="155">
<![CDATA[
 			}
 		}
 
 		public static readonly string UnderlyingValueField = "value__";
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
 
 		public Enum (NamespaceEntry ns, DeclSpace parent, TypeExpression type,
 			     Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			base_type_expr = type;
 			var accmods = IsTopLevel ? Modifiers.INTERNAL 
 			ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod_flags, accmods, Location, Report);
 			spec = new EnumSpec (null, this, null, null, ModFlags);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2363" endline="2393">
<![CDATA[
 		}
 	}
 
 
 	// TODO
 	public class Class 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.ABSTRACT |
 			Modifiers.SEALED |
 			Modifiers.STATIC |
 			Modifiers.UNSAFE;
 
 		public const TypeAttributes StaticClassAttribute = TypeAttributes.Abstract | TypeAttributes.Sealed;
 
 		public Class (NamespaceEntry ns, DeclSpace parent, MemberName name, Modifiers mod,
 			      Attributes attrs)
 			
 		{
 			var accmods = (Parent == null || Parent.Parent == null) ? Modifiers.INTERNAL 
 			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, Location, Report);
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 
 			if (IsStatic && RootContext.Version == LanguageVersion.ISO_1) {
 				Report.FeatureIsNotAvailable (Location, "static classes");
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="115" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="474" endline="487">
<![CDATA[
 
 		public int Size
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				return 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="488" endline="502">
<![CDATA[
 		}
 
 		public PackingSize PackingSize
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				return PackingSize.Unspecified;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="116" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="114" endline="133">
<![CDATA[
 
 		internal void WriteCompressedInt(int value)
 		{
 			if (value <= 0x7F)
 			{
 				Write((byte)value);
 			}
 			else if (value <= 0x3FFF)
 			{
 				Write((byte)(0x80 | (value >> 8)));
 				Write((byte)value);
 			}
 			else
 			{
 				Write((byte)(0xC0 | (value >> 24)));
 				Write((byte)(value >> 16));
 				Write((byte)(value >> 8));
 				Write((byte)value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="177" endline="196">
<![CDATA[
 
 		internal void WriteCompressedInt(int value)
 		{
 			if (value <= 0x7F)
 			{
 				Write((byte)value);
 			}
 			else if (value <= 0x3FFF)
 			{
 				Write((byte)(0x80 | (value >> 8)));
 				Write((byte)value);
 			}
 			else
 			{
 				Write((byte)(0xC0 | (value >> 24)));
 				Write((byte)(value >> 16));
 				Write((byte)(value >> 8));
 				Write((byte)value);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="117" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1970" endline="1989">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1990" endline="2009">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="118" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="942" endline="964">
<![CDATA[
 		}
 
 		public bool IsPrimitive
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_Boolean
 					|| this == u.System_Byte
 					|| this == u.System_SByte
 					|| this == u.System_Int16
 					|| this == u.System_UInt16
 					|| this == u.System_Int32
 					|| this == u.System_UInt32
 					|| this == u.System_Int64
 					|| this == u.System_UInt64
 					|| this == u.System_IntPtr
 					|| this == u.System_UIntPtr
 					|| this == u.System_Char
 					|| this == u.System_Double
 					|| this == u.System_Single
 					;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1515" endline="1536">
<![CDATA[
 		}
 
 		internal bool IsPseudoCustomAttribute
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_NonSerializedAttribute
 					|| this == u.System_SerializableAttribute
 					|| this == u.System_Runtime_InteropServices_DllImportAttribute
 					|| this == u.System_Runtime_InteropServices_FieldOffsetAttribute
 					|| this == u.System_Runtime_InteropServices_InAttribute
 					|| this == u.System_Runtime_InteropServices_MarshalAsAttribute
 					|| this == u.System_Runtime_InteropServices_OutAttribute
 					|| this == u.System_Runtime_InteropServices_StructLayoutAttribute
 					|| this == u.System_Runtime_InteropServices_OptionalAttribute
 					|| this == u.System_Runtime_InteropServices_PreserveSigAttribute
 					|| this == u.System_Runtime_InteropServices_ComImportAttribute
 					|| this == u.System_Runtime_CompilerServices_SpecialNameAttribute
 					|| this == u.System_Runtime_CompilerServices_MethodImplAttribute
 					;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="119" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="369" endline="384">
<![CDATA[
 
 		private static bool IsEqual(byte[] b1, byte[] b2)
 		{
 			if (b1.Length != b2.Length)
 			{
 				return false;
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="324" endline="351">
<![CDATA[
 
 		internal bool MatchParameterTypes(Type[] types)
 		{
 			if (types == parameterTypes)
 			{
 				return true;
 			}
 			if (types == null)
 			{
 				return parameterTypes.Length == 0;
 			}
 			if (parameterTypes == null)
 			{
 				return types.Length == 0;
 			}
 			if (types.Length == parameterTypes.Length)
 			{
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="120" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8655" endline="8677">
<![CDATA[
 		public static readonly Expression Null = new EmptyExpression ();
 
 		public class OutAccess 
 		{
 			public static readonly OutAccess Instance = new OutAccess ();
 
 			public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 			{
 				rc.Report.Error (206, right_side.Location,
 					"A property, indexer or dynamic member access may not be passed as `ref' or `out' parameter");
 
 				return null;
 			}
 		}
 
 		public static readonly EmptyExpression LValueMemberAccess = new EmptyExpression ();
 		public static readonly EmptyExpression LValueMemberOutAccess = new EmptyExpression ();
 		public static readonly EmptyExpression UnaryAddress = new EmptyExpression ();
 		public static readonly EmptyExpression EventAddition = new EmptyExpression ();
 		public static readonly EmptyExpression EventSubtraction = new EmptyExpression ();
 		public static readonly EmptyExpression MissingValue = new EmptyExpression (InternalType.FakeInternalType);
 
 		static EmptyExpression temp = new EmptyExpression ();
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8660" endline="8683">
<![CDATA[
 
 			public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 			{
 				rc.Report.Error (206, right_side.Location,
 					"A property, indexer or dynamic member access may not be passed as `ref' or `out' parameter");
 
 				return null;
 			}
 		}
 
 		public static readonly EmptyExpression LValueMemberAccess = new EmptyExpression ();
 		public static readonly EmptyExpression LValueMemberOutAccess = new EmptyExpression ();
 		public static readonly EmptyExpression UnaryAddress = new EmptyExpression ();
 		public static readonly EmptyExpression EventAddition = new EmptyExpression ();
 		public static readonly EmptyExpression EventSubtraction = new EmptyExpression ();
 		public static readonly EmptyExpression MissingValue = new EmptyExpression (InternalType.FakeInternalType);
 
 		static EmptyExpression temp = new EmptyExpression ();
 		public static EmptyExpression Grab ()
 		{
 			EmptyExpression retval = temp == null ? new EmptyExpression () 
 			temp = null;
 			return retval;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="121" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="240" endline="262">
<![CDATA[
 
 		internal void WriteCustomAttributeType(int token)
 		{
 			switch (token >> 24)
 			{
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 2;
 					break;
 				case MemberRefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 3;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigCustomAttributeType)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="420" endline="442">
<![CDATA[
 
 		internal void WriteMethodDefOrRef(int token)
 		{
 			switch (token >> 24)
 			{
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 0;
 					break;
 				case MemberRefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 1;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMethodDefOrRef)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="388" endline="419">
<![CDATA[
 
 		internal void WriteMemberRefParent(int token)
 		{
 			switch (token >> 24)
 			{
 				case TypeDefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 0;
 					break;
 				case TypeRefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 1;
 					break;
 				case ModuleRefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 2;
 					break;
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 3;
 					break;
 				case TypeSpecTable.Index
 					token = (token & 0xFFFFFF) << 3 | 4;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMemberRefParent)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="527" endline="549">
<![CDATA[
 
 		internal void WriteMemberForwarded(int token)
 		{
 			switch (token >> 24)
 			{
 				case FieldTable.Index
 					token = (token & 0xFFFFFF) << 1 | 0;
 				    break;
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 1;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMemberForwarded)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="122" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7161" endline="7178">
<![CDATA[
 
 		static bool ContainsDynamicType (TypeSpec type)
 		{
 			if (type == InternalType.Dynamic)
 				return true;
 
 			var element_container = type as ElementTypeSpec;
 			if (element_container != null)
 				return ContainsDynamicType (element_container.Element);
 
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1077" endline="1095">
<![CDATA[
 
 		public bool IsConvertibleToInterface (TypeSpec iface)
 		{
 			if (Interfaces != null) {
 				foreach (var t in Interfaces) {
 					if (t == iface)
 						return true;
 				}
 				foreach (var t in Interfaces) {
 					if (t == iface)
 						return true;
 				}
 			}
 
 			if (TypeArguments != null) {
 				foreach (var t in TypeArguments) {
 					if (((TypeParameterSpec) t).IsConvertibleToInterface (iface))
 						return true;
 				}
 				foreach (var t in TypeArguments) {
 					if (((TypeParameterSpec) t).IsConvertibleToInterface (iface))
 						return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="230" endline="250">
<![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((getter != null && getter.IsPublic) || (setter != null && setter.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="265" endline="283">
<![CDATA[
 		}
 
 		public virtual bool ContainsGenericParameters
 		{
 			get
 			{
 				if (this.IsGenericParameter)
 				{
 					return true;
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="144" endline="165">
<![CDATA[
 		}
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				if (declaringType.ContainsGenericParameters)
 				{
 					return true;
 				}
 				if (methodArgs != null)
 				{
 					foreach (Type type in methodArgs)
 					{
 						if (type.ContainsGenericParameters)
 						{
 							return true;
 						}
 					}
 					foreach (Type type in methodArgs)
 					{
 						if (type.ContainsGenericParameters)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="251" endline="272">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((getter != null && getter.IsStatic) || (setter != null && setter.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="123" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="280" endline="296">
<![CDATA[
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder(this.FullName);
 			string sep = "[";
 			foreach (Type arg in GetGenericArguments())
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			foreach (Type arg in GetGenericArguments())
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			if (sep != "[")
 			{
 				sb.Append(']');
 			}
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2292" endline="2307">
<![CDATA[
 		}
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder(type.FullName);
 			sb.Append('[');
 			string sep = "";
 			foreach (Type arg in args)
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			foreach (Type arg in args)
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			sb.Append(']');
 			return sb.ToString();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="124" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="71" endline="93">
<![CDATA[
 		
 		static bool IList_To_Array(TypeSpec list, ArrayContainer array)
 		{
 			if (array.Rank != 1 || !list.IsGeneric)
 				return false;
 
 			var open_version = list.GetDefinition ();
 			if ((open_version != TypeManager.generic_ilist_type) &&
 				(open_version != TypeManager.generic_icollection_type) &&
 				(open_version != TypeManager.generic_ienumerable_type))
 				return false;
 
 			var arg_type = list.TypeArguments[0];
 			if (array.Element == arg_type)
 				return true;
 			
 			if (MyEmptyExpr == null)
 				MyEmptyExpr = new EmptyExpression (array.Element);
 			else
 				MyEmptyExpr.SetType (array.Element);
 
 			return ImplicitReferenceConversionExists (MyEmptyExpr, arg_type) || ExplicitReferenceConversionExists (array.Element, arg_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="40" endline="70">
<![CDATA[
 		
 		//
 		// From a one-dimensional array-type S[] to System.Collections.IList<T> and base
 		// interfaces of this interface, provided there is an implicit reference conversion
 		// from S to T.
 		//
 		static bool ArrayToIList (ArrayContainer array, TypeSpec list, bool isExplicit)
 		{
 			if (array.Rank != 1 || !list.IsGeneric)
 				return false;
 
 			var open_version = list.GetDefinition ();
 			if ((open_version != TypeManager.generic_ilist_type) &&
 				(open_version != TypeManager.generic_icollection_type) &&
 				(open_version != TypeManager.generic_ienumerable_type))
 				return false;
 
 			var arg_type = list.TypeArguments[0];
 			if (array.Element == arg_type)
 				return true;
 
 			if (isExplicit)
 				return ExplicitReferenceConversionExists (array.Element, arg_type);
 
 			if (MyEmptyExpr == null)
 				MyEmptyExpr = new EmptyExpression (array.Element);
 			else
 				MyEmptyExpr.SetType (array.Element);
 
 			return ImplicitReferenceConversionExists (MyEmptyExpr, arg_type);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="125" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1906" endline="1928">
<![CDATA[
 
 		//
 		// It should be used by expressions which require to
 		// register a statement during resolve process.
 		//
 		public void AddScopeStatement (Statement s)
 		{
 			if (scope_initializers == null)
 				scope_initializers = new List<Statement> ();
 
 			//
 			// Simple recursive helper, when resolve scope initializer another
 			// new scope initializer can be added, this ensures it's initialized
 			// before existing one. For now this can happen with expression trees
 			// in base ctor initializer only
 			//
 			if (resolving_init_idx.HasValue) {
 				scope_initializers.Insert (resolving_init_idx.Value, s);
 				++resolving_init_idx;
 			} else {
 				scope_initializers.Add (s);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="504" endline="544">
<![CDATA[
 
 		//
 		// Creates storey instance expression regardless of currect IP
 		//
 		public Expression GetStoreyInstanceExpression (EmitContext ec)
 		{
 			AnonymousExpression am = ec.CurrentAnonymousMethod;
 
 			//
 			// Access from original block -> storey
 			//
 			if (am == null)
 				return Instance;
 
 			//
 			// Access from anonymous method implemented as a static -> storey
 			//
 			if (am.Storey == null)
 				return Instance;
 
 			Field f = am.Storey.GetReferencedStoreyField (this);
 			if (f == null) {
 				if (am.Storey == this) {
 					//
 					// Access inside of same storey (S -> S)
 					//
 					return new CompilerGeneratedThis (CurrentType, Location);
 				}
 				//
 				// External field access
 				//
 				return Instance;
 			}
 
 			//
 			// Storey was cached to local field
 			//
 			FieldExpr f_ind = new FieldExpr (f, Location);
 			f_ind.InstanceExpression = new CompilerGeneratedThis (CurrentType, Location);
 			return f_ind;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2157" endline="2189">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Creates anonymous method storey in current block
 		//
 		public AnonymousMethodStorey CreateAnonymousMethodStorey (ResolveContext ec)
 		{
 			//
 			// An iterator has only 1 storey block
 			//
 			if (ec.CurrentIterator != null)
 			    return ec.CurrentIterator.Storey;
 
 			//
 			// When referencing a variable in iterator storey from children anonymous method
 			//
 			if (ParametersBlock.am_storey is IteratorStorey) {
 				return ParametersBlock.am_storey;
 			}
 
 			if (am_storey == null) {
 				MemberBase mc = ec.MemberContext as MemberBase;
 
 				//
 				// Creates anonymous method storey for this block
 				//
 				am_storey = new AnonymousMethodStorey (this, ec.CurrentMemberDefinition.Parent.PartialContainer, mc, ec.CurrentTypeParameters, "AnonStorey");
 			}
 
 			return am_storey;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="126" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1004" endline="1026">
<![CDATA[
 
 		void CreatePredefinedOperators ()
 		{
 			//
 			// Predefined ++ and -- operators exist for the following types
 			// sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal
 			//
 			predefined = new TypeSpec[] {
 				TypeManager.int32_type,
 
 				TypeManager.sbyte_type,
 				TypeManager.byte_type,
 				TypeManager.short_type,
 				TypeManager.ushort_type,
 				TypeManager.uint32_type,
 				TypeManager.int64_type,
 				TypeManager.uint64_type,
 				TypeManager.char_type,
 				TypeManager.float_type,
 				TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="368" endline="407">
<![CDATA[
 
 		static void CreatePredefinedOperatorsTable ()
 		{
 			predefined_operators = new TypeSpec [(int) Operator.TOP] [];
 
 			//
 			// 7.6.1 Unary plus operator
 			//
 			predefined_operators [(int) Operator.UnaryPlus] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.2 Unary minus operator
 			//
 			predefined_operators [(int) Operator.UnaryNegation] = new TypeSpec [] {
 				TypeManager.int32_type, 
 				TypeManager.int64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.3 Logical negation operator
 			//
 			predefined_operators [(int) Operator.LogicalNot] = new TypeSpec [] {
 				TypeManager.bool_type
 			};
 
 			//
 			// 7.6.4 Bitwise complement operator
 			//
 			predefined_operators [(int) Operator.OnesComplement] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type
 			};
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="127" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
<![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="386" endline="407">
<![CDATA[
 
 		internal int ReadMemberForwarded()
 		{
 			int codedIndex;
 			if (bigMemberForwarded)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="364" endline="385">
<![CDATA[
 
 		internal int ReadTypeOrMethodDef()
 		{
 			int codedIndex;
 			if (bigTypeOrMethodDef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="296" endline="317">
<![CDATA[
 
 		internal int ReadHasSemantics()
 		{
 			int codedIndex;
 			if (bigHasSemantics)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (EventTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (PropertyTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="250" endline="271">
<![CDATA[
 
 		internal int ReadMethodDefOrRef()
 		{
 			int codedIndex;
 			if (bigMethodDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MemberRefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="318" endline="339">
<![CDATA[
 
 		internal int ReadHasFieldMarshal()
 		{
 			int codedIndex;
 			if (bigHasFieldMarshal)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="128" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="158" endline="172">
<![CDATA[
 
 		public override Type[] __GetDeclaredTypes()
 		{
 			int token = this.MetadataToken;
 			List<Type> list = new List<Type>();
 			// TODO use binary search?
 			for (int i = 0; i < module.NestedClass.records.Length; i++)
 			{
 				if (module.NestedClass.records[i].EnclosingClass == token)
 				{
 					list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
 				}
 			}
 			for (int i = 0; i < module.NestedClass.records.Length; i++)
 			{
 				if (module.NestedClass.records[i].EnclosingClass == token)
 				{
 					list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="344" endline="360">
<![CDATA[
 		}
 
 		public override Type[] GetGenericParameterConstraints()
 		{
 			IGenericContext context = (this.DeclaringMethod as IGenericContext) ?? this.DeclaringType;
 			List<Type> list = new List<Type>();
 			int token = this.MetadataToken;
 			// TODO use binary search
 			for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
 			{
 				if (module.GenericParamConstraint.records[i].Owner == token)
 				{
 					list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
 				}
 			}
 			for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
 			{
 				if (module.GenericParamConstraint.records[i].Owner == token)
 				{
 					list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="297" endline="317">
<![CDATA[
 
 		public override Type DeclaringType
 		{
 			get
 			{
 				// note that we cannot use Type.IsNested for this, because that calls DeclaringType
 				if ((this.Attributes & TypeAttributes.VisibilityMask & ~TypeAttributes.Public) == 0)
 				{
 					return null;
 				}
 				// TODO use binary search (if sorted)
 				int token = this.MetadataToken;
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				throw new InvalidOperationException();
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="129" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1497" endline="1514">
<![CDATA[
 
 		internal bool IsAllowMultipleCustomAttribute
 		{
 			get
 			{
 				IList<CustomAttributeData> cad = GetCustomAttributesData(this.Module.universe.System_AttributeUsageAttribute);
 				if (cad.Count == 1)
 				{
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="594" endline="610">
<![CDATA[
 
 		private static bool IsInheritableAttribute(Type attribute)
 		{
 			Type attributeUsageAttribute = attribute.Module.universe.System_AttributeUsageAttribute;
 			IList<CustomAttributeData> attr = attribute.GetCustomAttributesData(attributeUsageAttribute);
 			if (attr.Count != 0)
 			{
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="130" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="118" endline="141">
<![CDATA[
 
 		internal int ReadTypeDefOrRef()
 		{
 			int codedIndex;
 			if (bigTypeDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (TypeSpecTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="340" endline="363">
<![CDATA[
 
 		internal int ReadHasDeclSecurity()
 		{
 			int codedIndex;
 			if (bigHasDeclSecurity)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="408" endline="431">
<![CDATA[
 
 		internal int ReadImplementation()
 		{
 			int codedIndex;
 			if (bigImplementation)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FileTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (ExportedTypeTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="272" endline="295">
<![CDATA[
 
 		internal int ReadHasConstant()
 		{
 			int codedIndex;
 			if (bigHasConstant)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (PropertyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="92" endline="117">
<![CDATA[
 
 		internal int ReadResolutionScope()
 		{
 			int codedIndex;
 			if (bigResolutionScope)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (ModuleTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ModuleRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 3
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="131" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="340" endline="363">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Fixed buffer implementation
 	/// </summary>
 	public class FixedField 
 	{
 		public const string FixedElementName = "FixedElementField";
 		static int GlobalCounter = 0;
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2785" endline="2812">
<![CDATA[
 
 	}
 
 	/// <summary>
 	///   Interfaces
 	/// </summary>
 	public sealed class Interface 
 
 		/// <summary>
 		///   Modifiers allowed in a class declaration
 		/// </summary>
 		public const Modifiers AllowedModifiers =
 			Modifiers.NEW       |
 			Modifiers.PUBLIC    |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL  |
 		 	Modifiers.UNSAFE    |
 			Modifiers.PRIVATE;
 
 		public Interface (NamespaceEntry ns, DeclSpace parent, MemberName name, Modifiers mod,
 				  Attributes attrs)
 			
 		{
 			var accmods = parent.Parent == null ? Modifiers.INTERNAL 
 
 			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, name.Location, Report);
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="132" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="832" endline="855">
<![CDATA[
 
 		private static bool IsTypeName (string name)
 		{
 			switch (name) {
 			case "bool"
 			case "byte"
 			case "char"
 			case "decimal"
 			case "double"
 			case "float"
 			case "int"
 			case "long"
 			case "object"
 			case "sbyte"
 			case "short"
 			case "string"
 			case "uint"
 			case "ulong"
 			case "ushort"
 			case "void"
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="542" endline="571">
<![CDATA[
 		}
 
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			switch (Name) {
 			case "Int32"
 			case "Int64"
 			case "String"
 			case "Boolean"
 			case "Void"
 			case "Object"
 			case "UInt32"
 			case "Int16"
 			case "UInt16"
 			case "UInt64"
 			case "Single"
 			case "Double"
 			case "Decimal"
 			case "Char"
 			case "Byte"
 			case "SByte"
 			}
 
 			if (ns.Length == 0)
 				return name;
 
 			return FullName;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\OpCodes.cs" startline="716" endline="747">
<![CDATA[
 
 		public static bool TakesSingleByteArgument(OpCode inst)
 		{
 			switch (inst.Value)
 			{
 				case 14
 				case 15
 				case 16
 				case 17
 				case 18
 				case 19
 				case 31
 				case 43
 				case 44
 				case 45
 				case 46
 				case 47
 				case 48
 				case 49
 				case 50
 				case 51
 				case 52
 				case 53
 				case 54
 				case 55
 				case 222
 				case -494
 					return true;
 				default
 					return false;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="133" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="175" endline="197">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="220" endline="242">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="134" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="724" endline="740">
<![CDATA[
 		}
 
 		private TypeDefImpl FindMethodOwner(int methodIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="624" endline="639">
<![CDATA[
 
 		private TypeDefImpl FindFieldOwner(int fieldIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="135" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2689" endline="2714">
<![CDATA[
 
 		protected void DoBestMemberChecks<T> (ResolveContext rc, T member) where T 
 		{
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (rc);
 				CheckProtectedMemberAccess (rc, member);
 			}
 
 			if (member.MemberType.IsPointer && !rc.IsUnsafe) {
 				UnsafeError (rc, loc);
 			}
 
 			var dep = member.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			if (!rc.IsObsolete) {
 				ObsoleteAttribute oa = member.GetAttributeObsolete ();
 				if (oa != null)
 					AttributeTester.Report_ObsoleteMessage (oa, member.GetSignatureForError (), loc, rc.Report);
 			}
 
 			if (!(member is FieldSpec))
 				member.MemberDefinition.SetIsUsed ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5124" endline="5161">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			VariableReference vr;
 			bool vr_locked = false;
 
 			using (ec.Set (ResolveContext.Options.UsingInitializerScope)) {
 				if (decl.Variable == null) {
 					vr = decl.ResolveExpression (ec) as VariableReference;
 					if (vr != null) {
 						vr_locked = vr.IsLockedByStatement;
 						vr.IsLockedByStatement = true;
 					}
 				} else {
 					if (!decl.Resolve (ec))
 						return false;
 
 					if (decl.Declarators != null) {
 						stmt = decl.RewriteForDeclarators (ec, stmt);
 					}
 
 					vr = null;
 				}
 			}
 
 			ec.StartFlowBranching (this);
 
 			stmt.Resolve (ec);
 
 			ec.EndFlowBranching ();
 
 			if (vr != null)
 				vr.IsLockedByStatement = vr_locked;
 
 			base.Resolve (ec);
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="136" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2564" endline="2587">
<![CDATA[
 
 		/// Search for at least one defined condition in ConditionalAttribute of attribute class
 		/// Valid only for attribute classes.
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 
 			if (OptAttributes == null)
 				return null;
 
 			Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 			if (attrs == null)
 				return null;
 
 			string[] conditions = new string[attrs.Length];
 			for (int i = 0; i < conditions.Length; ++i)
 				conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			for (int i = 0; i < conditions.Length; ++i)
 				conditions[i] = attrs[i].GetConditionalAttributeValue ();
 
 			caching_flags |= Flags.Excluded;
 			return conditions;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="676" endline="711">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="137" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1274" endline="1297">
<![CDATA[
 
 		public ScopeVariable[] GetScopeVariables ()
 		{
 			lock (SymbolFile) {
 				if (scope_vars != null)
 					return scope_vars;
 
 				if (ScopeVariableTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = ScopeVariableTableOffset;
 
 				int num_scope_vars = reader.ReadLeb128 ();
 				scope_vars = new ScopeVariable [num_scope_vars];
 
 				for (int i = 0; i < num_scope_vars; i++)
 					scope_vars [i] = new ScopeVariable (reader);
 				for (int i = 0; i < num_scope_vars; i++)
 					scope_vars [i] = new ScopeVariable (reader);
 
 				reader.BaseStream.Position = old_pos;
 				return scope_vars;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1250" endline="1273">
<![CDATA[
 
 		public CodeBlockEntry[] GetCodeBlocks ()
 		{
 			lock (SymbolFile) {
 				if (code_blocks != null)
 					return code_blocks;
 
 				if (CodeBlockTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = CodeBlockTableOffset;
 
 				int num_code_blocks = reader.ReadLeb128 ();
 				code_blocks = new CodeBlockEntry [num_code_blocks];
 
 				for (int i = 0; i < num_code_blocks; i++)
 					code_blocks [i] = new CodeBlockEntry (i, reader);
 				for (int i = 0; i < num_code_blocks; i++)
 					code_blocks [i] = new CodeBlockEntry (i, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return code_blocks;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1226" endline="1249">
<![CDATA[
 
 		public LocalVariableEntry[] GetLocals ()
 		{
 			lock (SymbolFile) {
 				if (locals != null)
 					return locals;
 
 				if (LocalVariableTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = LocalVariableTableOffset;
 
 				int num_locals = reader.ReadLeb128 ();
 				locals = new LocalVariableEntry [num_locals];
 
 				for (int i = 0; i < num_locals; i++)
 					locals [i] = new LocalVariableEntry (SymbolFile, reader);
 				for (int i = 0; i < num_locals; i++)
 					locals [i] = new LocalVariableEntry (SymbolFile, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return locals;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="138" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="858" endline="883">
<![CDATA[
 
 		public int Fatal { get; set; }
 
 		static int NameToCode (string s)
 		{
 			switch (s) {
 			case "black"
 				return 0;
 			case "red"
 				return 1;
 			case "green"
 				return 2;
 			case "yellow"
 				return 3;
 			case "blue"
 				return 4;
 			case "magenta"
 				return 5;
 			case "cyan"
 				return 6;
 			case "grey"
 			case "white"
 				return 7;
 			}
 			return 7;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="512" endline="540">
<![CDATA[
 
 		static string descape (char c)
 		{
 			switch (c){
 			case '\a'
 				return "\\a"; 
 			case '\b'
 				return "\\b"; 
 			case '\n'
 				return "\\n"; 
 			case '\t'
 				return "\\t"; 
 			case '\v'
 				return "\\v"; 
 			case '\r'
 				return "\\r"; 
 			case '\\'
 				return "\\\\";
 			case '\f'
 				return "\\f"; 
 			case '\0'
 				return "\\0"; 
 			case '"'
 				return "\\\""; 
 			case '\''
 				return "\\\'"; 
 			}
 			return c.ToString ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="139" nfragments="11" Csharpe_files="11" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1846" endline="1874">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)Value, loc);
 			if (target_type == TypeManager.byte_type)
 				return new ByteConstant ((byte)Value, loc);
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short)Value, loc);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)Value, loc);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int)Value, loc);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint)Value, loc);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long)Value, loc);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong)Value, loc);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char)Value, loc);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float)Value, loc);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double)Value, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="566" endline="607">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}					
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="896" endline="944">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="672" endline="713">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short) Value, Location);
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			} if (target_type == TypeManager.int32_type)
 				  return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			} if (target_type == TypeManager.int64_type)
 				  return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="778" endline="831">
<![CDATA[
 		}		
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1189" endline="1247">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1008" endline="1069">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1312" endline="1378">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < Int32.MinValue || Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue || Value > UInt32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1676" endline="1749">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (double) char.MinValue || Value > (double) char.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1553" endline="1626">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < byte.MinValue || Value > byte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < sbyte.MinValue || Value > sbyte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (float) char.MinValue || Value > (float) char.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1451" endline="1503">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value > Byte.MaxValue)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context && Value > ((ulong) SByte.MaxValue))
 					throw new OverflowException ();
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context && Value > ((ulong) Int16.MaxValue))
 					throw new OverflowException ();
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value > UInt16.MaxValue)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if  (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context && Value > Int64.MaxValue)
 					throw new OverflowException ();
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value > Char.MaxValue)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="140" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="359" endline="387">
<![CDATA[
 
 		internal void WriteResolutionScope(int token)
 		{
 			switch (token >> 24)
 			{
 				case ModuleTable.Index
 					token = (token & 0xFFFFFF) << 2 | 0;
 					break;
 				case ModuleRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 1;
 					break;
 				case AssemblyRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 2;
 					break;
 				case TypeRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 3;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigResolutionScope)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="732" endline="757">
<![CDATA[
 
 		internal void Fixup()
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1197" endline="1225">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasDeclSecurity encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case MethodDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case AssemblyTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Parent = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasDeclSecurity encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case MethodDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case AssemblyTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Parent = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="141" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="844" endline="860">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, Type[] types)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="887" endline="903">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="827" endline="843">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, Type returnType)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="142" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="229" endline="244">
<![CDATA[
 
 		private void WriteData(ByteBuffer bb)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="209" endline="228">
<![CDATA[
 
 		private void WriteResourceDataEntries(ByteBuffer bb, List<int> linkOffsets, ref int offset)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					linkOffsets.Add(bb.Position);
 					bb.Write(offset);
 					bb.Write(entry.Data.Length);
 					bb.Write(0);	// code page
 					bb.Write(0);	// reserved
 					offset += (entry.Data.Length + 3) & ~3;
 				}
 				else
 				{
 					entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					linkOffsets.Add(bb.Position);
 					bb.Write(offset);
 					bb.Write(entry.Data.Length);
 					bb.Write(0);	// code page
 					bb.Write(0);	// reserved
 					offset += (entry.Data.Length + 3) & ~3;
 				}
 				else
 				{
 					entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="143" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="670" endline="686">
<![CDATA[
 
 		public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
 		{
 			MethodInfo found = null;
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="643" endline="659">
<![CDATA[
 
 		public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
 		{
 			MethodInfo found = null;
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name)
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name)
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="144" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="140" endline="160">
<![CDATA[
 
 		public override Module[] GetModules(bool getResourceModules)
 		{
 			if (externalModules.Length == 0)
 			{
 				return new Module[] { manifestModule };
 			}
 			else
 			{
 				List<Module> list = new List<Module>();
 				list.Add(manifestModule);
 				for (int i = 0; i < manifestModule.File.records.Length; i++)
 				{
 					if (getResourceModules || (manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 					{
 						list.Add(GetModule(i));
 					}
 				}
 				for (int i = 0; i < manifestModule.File.records.Length; i++)
 				{
 					if (getResourceModules || (manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 					{
 						list.Add(GetModule(i));
 					}
 				}
 				return list.ToArray();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="409" endline="433">
<![CDATA[
 
 		internal List<CustomAttributeData> GetCustomAttributes(int metadataToken, Type attributeType)
 		{
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			// TODO use binary search?
 			for (int i = 0; i < CustomAttribute.records.Length; i++)
 			{
 				if (CustomAttribute.records[i].Parent == metadataToken)
 				{
 					if (attributeType == null)
 					{
 						list.Add(new CustomAttributeData(this, i));
 					}
 					else
 					{
 						ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
 						if (attributeType.IsAssignableFrom(constructor.DeclaringType))
 						{
 							list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
 						}
 					}
 				}
 			}
 			for (int i = 0; i < CustomAttribute.records.Length; i++)
 			{
 				if (CustomAttribute.records[i].Parent == metadataToken)
 				{
 					if (attributeType == null)
 					{
 						list.Add(new CustomAttributeData(this, i));
 					}
 					else
 					{
 						ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
 						if (attributeType.IsAssignableFrom(constructor.DeclaringType))
 						{
 							list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
 						}
 					}
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="299" endline="334">
<![CDATA[
 
 		void AddMember (string name, MemberSpec member)
 		{
 			if (member.Kind == MemberKind.Operator) {
 				var dt = member.DeclaringType;
 				if (dt == TypeManager.string_type || dt == TypeManager.delegate_type || dt == TypeManager.multicast_delegate_type) {
 					// Some core types have user operators but they cannot be used as normal
 					// user operators as they are predefined and therefore having different
 					// rules (e.g. binary operators) by not setting the flag we hide them for
 					// user conversions
 					// TODO
 				} else if (name == Operator.GetMetadataName (Operator.OpType.Implicit) || name == Operator.GetMetadataName (Operator.OpType.Explicit)) {
 					state |= StateFlags.HasConversionOperator;
 				} else {
 					state |= StateFlags.HasUserOperator;
 				}
 			}
 
 			IList<MemberSpec> list;
 			if (!member_hash.TryGetValue (name, out list)) {
 				member_hash.Add (name, new MemberSpec[] { member });
 				return;
 			}
 
 			if (member.DeclaringType.IsInterface) {
 				if (AddInterfaceMember (member, ref list))
 					member_hash[name] = list;
 			} else {
 				if (list is MemberSpec[]) {
 					list = new List<MemberSpec> () { list[0] };
 					member_hash[name] = list;
 				}
 
 				list.Add (member);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="145" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="236" endline="266">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.ModuleBuilder.universe;
 			Type type = customBuilder.Constructor.DeclaringType;
 			if (type == u.System_Runtime_InteropServices_DllImportAttribute)
 			{
 				attributes |= MethodAttributes.PinvokeImpl;
 				SetDllImportPseudoCustomAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
 			}
 			else if (type == u.System_Runtime_CompilerServices_MethodImplAttribute)
 			{
 				SetMethodImplAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
 			}
 			else if (type == u.System_Runtime_InteropServices_PreserveSigAttribute)
 			{
 				implFlags |= MethodImplAttributes.PreserveSig;
 			}
 			else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= MethodAttributes.SpecialName;
 			}
 			else
 			{
 				if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
 				{
 					attributes |= MethodAttributes.HasSecurity;
 				}
 				this.ModuleBuilder.SetCustomAttribute(pseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="561" endline="590">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.ModuleBuilder.universe;
 			Type type = customBuilder.Constructor.DeclaringType;
 			if (type == u.System_Runtime_InteropServices_StructLayoutAttribute)
 			{
 				SetStructLayoutPseudoCustomAttribute(customBuilder.DecodeBlob(this.Assembly));
 			}
 			else if (type == u.System_SerializableAttribute)
 			{
 				attribs |= TypeAttributes.Serializable;
 			}
 			else if (type == u.System_Runtime_InteropServices_ComImportAttribute)
 			{
 				attribs |= TypeAttributes.Import;
 			}
 			else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attribs |= TypeAttributes.SpecialName;
 			}
 			else
 			{
 				if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
 				{
 					attribs |= TypeAttributes.HasSecurity;
 				}
 				this.ModuleBuilder.SetCustomAttribute(token, customBuilder);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="146" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="298" endline="328">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			Label loop = ec.DefineLabel ();
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 				
 			ec.MarkLabel (loop);
 			EmbeddedStatement.Emit (ec);
 			ec.MarkLabel (ec.LoopBegin);
 
 			//
 			// Dead code elimination
 			//
 			if (expr is Constant){
 				bool res = !((Constant) expr).IsDefaultValue;
 
 				expr.EmitSideEffect (ec);
 				if (res)
 					ec.Emit (OpCodes.Br, loop); 
 			} else
 				expr.EmitBranchable (ec, loop, true);
 			
 			ec.MarkLabel (ec.LoopEnd);
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="531" endline="581">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (InitStatement != null)
 				InitStatement.Emit (ec);
 
 			if (empty) {
 				Test.EmitSideEffect (ec);
 				return;
 			}
 
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			Label loop = ec.DefineLabel ();
 			Label test = ec.DefineLabel ();
 
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 
 			ec.Emit (OpCodes.Br, test);
 			ec.MarkLabel (loop);
 			Statement.Emit (ec);
 
 			ec.MarkLabel (ec.LoopBegin);
 			Increment.Emit (ec);
 
 			ec.MarkLabel (test);
 			//
 			// If test is null, there is no test, and we are just
 			// an infinite loop
 			//
 			if (Test != null){
 				//
 				// The Resolve code already catches the case for
 				// Test == Constant (false) so we know that
 				// this is true
 				//
 				if (Test is Constant) {
 					Test.EmitSideEffect (ec);
 					ec.Emit (OpCodes.Br, loop);
 				} else {
 					Test.EmitBranchable (ec, loop, true);
 				}
 				
 			} else
 				ec.Emit (OpCodes.Br, loop);
 			ec.MarkLabel (ec.LoopEnd);
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="390" endline="437">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (empty) {
 				expr.EmitSideEffect (ec);
 				return;
 			}
 
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 
 			//
 			// Inform whether we are infinite or not
 			//
 			if (expr is Constant){
 				// expr is 'true', since the 'empty' case above handles the 'false' case
 				ec.MarkLabel (ec.LoopBegin);
 				expr.EmitSideEffect (ec);
 				Statement.Emit (ec);
 				ec.Emit (OpCodes.Br, ec.LoopBegin);
 					
 				//
 				// Inform that we are infinite (ie, `we return'), only
 				// if we do not `break' inside the code.
 				//
 				ec.MarkLabel (ec.LoopEnd);
 			} else {
 				Label while_loop = ec.DefineLabel ();
 
 				ec.Emit (OpCodes.Br, ec.LoopBegin);
 				ec.MarkLabel (while_loop);
 
 				Statement.Emit (ec);
 			
 				ec.MarkLabel (ec.LoopBegin);
 				ec.Mark (loc);
 
 				expr.EmitBranchable (ec, while_loop, true);
 				
 				ec.MarkLabel (ec.LoopEnd);
 			}	
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="147" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="477" endline="507">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2129" endline="2164">
<![CDATA[
 		}
 
 		public abstract ParametersCompiled ParameterInfo { get ; }
 		public abstract TypeSpec ReturnType { get; }
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant || a.Type == pa.Obsolete || a.Type == pa.Conditional) {
 				Report.Error (1667, a.Location,
 					"Attribute `{0}' is not valid on property or event accessors. It is valid on `{1}' declarations only",
 					TypeManager.CSharpName (a.Type), a.GetValidTargets ());
 				return;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				method_data.MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			ApplyToExtraTarget (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="148" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1112" endline="1129">
<![CDATA[
 
 		public void ResolveDefaultValues (MemberCore m)
 		{
 			ResolveContext rc = null;
 			for (int i = 0; i < parameters.Length; ++i) {
 				Parameter p = (Parameter) parameters [i];
 
 				//
 				// Try not to enter default values resolution if there are is not any default value possible
 				//
 				if (p.HasDefaultValue || p.OptAttributes != null) {
 					if (rc == null)
 						rc = new ResolveContext (m);
 
 					p.ResolveDefaultValue (rc);
 				}
 			}
 			for (int i = 0; i < parameters.Length; ++i) {
 				Parameter p = (Parameter) parameters [i];
 
 				//
 				// Try not to enter default values resolution if there are is not any default value possible
 				//
 				if (p.HasDefaultValue || p.OptAttributes != null) {
 					if (rc == null)
 						rc = new ResolveContext (m);
 
 					p.ResolveDefaultValue (rc);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="614" endline="662">
<![CDATA[
 
 		Expression ResolveAddressOf (ResolveContext ec)
 		{
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			Expr = Expr.DoResolveLValue (ec, EmptyExpression.UnaryAddress);
 			if (Expr == null || Expr.eclass != ExprClass.Variable) {
 				ec.Report.Error (211, loc, "Cannot take the address of the given expression");
 				return null;
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, Expr.Type, loc)) {
 				return null;
 			}
 
 			IVariableReference vr = Expr as IVariableReference;
 			bool is_fixed;
 			if (vr != null) {
 				VariableInfo vi = vr.VariableInfo;
 				if (vi != null) {
 					if (vi.LocalInfo != null)
 						vi.LocalInfo.SetIsUsed ();
 
 					//
 					// A variable is considered definitely assigned if you take its address.
 					//
 					vi.SetAssigned (ec);
 				}
 
 				is_fixed = vr.IsFixed;
 				vr.SetHasAddressTaken ();
 
 				if (vr.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, vr, loc);
 				}
 			} else {
 				IFixedExpression fe = Expr as IFixedExpression;
 				is_fixed = fe != null && fe.IsFixed;
 			}
 
 			if (!is_fixed && !ec.HasSet (ResolveContext.Options.FixedInitializerScope)) {
 				ec.Report.Error (212, loc, "You can only take the address of unfixed expression inside of a fixed statement initializer");
 			}
 
 			type = PointerContainer.MakeType (Expr.Type);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="149" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="268" endline="297">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 
 			bool was_unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!EmbeddedStatement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			if (ec.CurrentBranching.CurrentUsageVector.IsUnreachable && !was_unreachable)
 				ec.Report.Warning (162, 2, expr.Location, "Unreachable code detected");
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				ok = false;
 			else if (expr is Constant){
 				bool infinite = !((Constant) expr).IsDefaultValue;
 				if (infinite)
 					ec.CurrentBranching.CurrentUsageVector.Goto ();
 			}
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="350" endline="389">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				ok = false;
 
 			//
 			// Inform whether we are infinite or not
 			//
 			if (expr is Constant){
 				bool value = !((Constant) expr).IsDefaultValue;
 
 				if (value == false){
 					if (!Statement.ResolveUnreachable (ec, true))
 						return false;
 					empty = true;
 					return true;
 				} else
 					infinite = true;
 			}
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 			if (!infinite)
 				ec.CurrentBranching.CreateSibling ();
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!Statement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			// There's no direct control flow from the end of the embedded statement to the end of the loop
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="472" endline="530">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			if (InitStatement != null){
 				if (!InitStatement.Resolve (ec))
 					ok = false;
 			}
 
 			if (Test != null){
 				Test = Test.Resolve (ec);
 				if (Test == null)
 					ok = false;
 				else if (Test is Constant){
 					bool value = !((Constant) Test).IsDefaultValue;
 
 					if (value == false){
 						if (!Statement.ResolveUnreachable (ec, true))
 							return false;
 						if ((Increment != null) &&
 						    !Increment.ResolveUnreachable (ec, false))
 							return false;
 						empty = true;
 						return true;
 					} else
 						infinite = true;
 				}
 			} else
 				infinite = true;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 			if (!infinite)
 				ec.CurrentBranching.CreateSibling ();
 
 			bool was_unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!Statement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			if (Increment != null){
 				if (ec.CurrentBranching.CurrentUsageVector.IsUnreachable) {
 					if (!Increment.ResolveUnreachable (ec, !was_unreachable))
 						ok = false;
 				} else {
 					if (!Increment.Resolve (ec))
 						ok = false;
 				}
 			}
 
 			// There's no direct control flow from the end of the embedded statement to the end of the loop
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="146" endline="201">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			Report.Debug (1, "START IF BLOCK", loc);
 
 			expr = expr.Resolve (ec);
 			if (expr == null) {
 				ok = false;
 			} else {
 				//
 				// Dead code elimination
 				//
 				if (expr is Constant) {
 					bool take = !((Constant) expr).IsDefaultValue;
 
 					if (take) {
 						if (!TrueStatement.Resolve (ec))
 							return false;
 
 						if ((FalseStatement != null) &&
 							!FalseStatement.ResolveUnreachable (ec, true))
 							return false;
 						FalseStatement = null;
 					} else {
 						if (!TrueStatement.ResolveUnreachable (ec, true))
 							return false;
 						TrueStatement = null;
 
 						if ((FalseStatement != null) &&
 							!FalseStatement.Resolve (ec))
 							return false;
 					}
 
 					return true;
 				}
 			}
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Conditional, loc);
 			
 			ok &= TrueStatement.Resolve (ec);
 
 			is_true_ret = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.CurrentBranching.CreateSibling ();
 
 			if (FalseStatement != null)
 				ok &= FalseStatement.Resolve (ec);
 					
 			ec.EndFlowBranching ();
 
 			Report.Debug (1, "END IF BLOCK", loc);
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="150" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="540" endline="569">
<![CDATA[
 
 		//
 		// The stack contains the pointer and the value of type `type'
 		//
 		public void EmitStoreFromPtr (TypeSpec type)
 		{
 			if (type.IsEnum)
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.int32_type || type == TypeManager.uint32_type)
 				ig.Emit (OpCodes.Stind_I4);
 			else if (type == TypeManager.int64_type || type == TypeManager.uint64_type)
 				ig.Emit (OpCodes.Stind_I8);
 			else if (type == TypeManager.char_type || type == TypeManager.short_type ||
 				 type == TypeManager.ushort_type)
 				ig.Emit (OpCodes.Stind_I2);
 			else if (type == TypeManager.float_type)
 				ig.Emit (OpCodes.Stind_R4);
 			else if (type == TypeManager.double_type)
 				ig.Emit (OpCodes.Stind_R8);
 			else if (type == TypeManager.byte_type || type == TypeManager.sbyte_type ||
 				 type == TypeManager.bool_type)
 				ig.Emit (OpCodes.Stind_I1);
 			else if (type == TypeManager.intptr_type)
 				ig.Emit (OpCodes.Stind_I);
 			else if (TypeManager.IsStruct (type) || TypeManager.IsGenericParameter (type))
 				Emit (OpCodes.Stobj, type);
 			else
 				ig.Emit (OpCodes.Stind_Ref);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="385" endline="426">
<![CDATA[
 
 		//
 		// Emits the right opcode to store to an array
 		//
 		public void EmitArrayStore (ArrayContainer ac)
 		{
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetSetMethod ());
 				return;
 			}
 
 			var type = ac.Element;
 
 			if (type.IsEnum)
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.byte_type || type == TypeManager.sbyte_type || type == TypeManager.bool_type)
 				Emit (OpCodes.Stelem_I1);
 			else if (type == TypeManager.short_type || type == TypeManager.ushort_type || type == TypeManager.char_type)
 				Emit (OpCodes.Stelem_I2);
 			else if (type == TypeManager.int32_type || type == TypeManager.uint32_type)
 				Emit (OpCodes.Stelem_I4);
 			else if (type == TypeManager.int64_type || type == TypeManager.uint64_type)
 				Emit (OpCodes.Stelem_I8);
 			else if (type == TypeManager.float_type)
 				Emit (OpCodes.Stelem_R4);
 			else if (type == TypeManager.double_type)
 				Emit (OpCodes.Stelem_R8);
 			else if (type == TypeManager.intptr_type)
 				Emit (OpCodes.Stobj, type);
 			else if (TypeManager.IsStruct (type))
 				Emit (OpCodes.Stobj, type);
 			else if (type.IsGenericParameter)
 				Emit (OpCodes.Stelem, type);
 			else if (type.IsPointer)
 				Emit (OpCodes.Stelem_I);
 			else
 				Emit (OpCodes.Stelem_Ref);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="335" endline="384">
<![CDATA[
 
 		//
 		// Emits the right opcode to load from an array
 		//
 		public void EmitArrayLoad (ArrayContainer ac)
 		{
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetGetMethod ());
 				return;
 			}
 
 			var type = ac.Element;
 			if (TypeManager.IsEnumType (type))
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.byte_type || type == TypeManager.bool_type)
 				Emit (OpCodes.Ldelem_U1);
 			else if (type == TypeManager.sbyte_type)
 				Emit (OpCodes.Ldelem_I1);
 			else if (type == TypeManager.short_type)
 				Emit (OpCodes.Ldelem_I2);
 			else if (type == TypeManager.ushort_type || type == TypeManager.char_type)
 				Emit (OpCodes.Ldelem_U2);
 			else if (type == TypeManager.int32_type)
 				Emit (OpCodes.Ldelem_I4);
 			else if (type == TypeManager.uint32_type)
 				Emit (OpCodes.Ldelem_U4);
 			else if (type == TypeManager.uint64_type)
 				Emit (OpCodes.Ldelem_I8);
 			else if (type == TypeManager.int64_type)
 				Emit (OpCodes.Ldelem_I8);
 			else if (type == TypeManager.float_type)
 				Emit (OpCodes.Ldelem_R4);
 			else if (type == TypeManager.double_type)
 				Emit (OpCodes.Ldelem_R8);
 			else if (type == TypeManager.intptr_type)
 				Emit (OpCodes.Ldelem_I);
 			else if (TypeManager.IsStruct (type)) {
 				Emit (OpCodes.Ldelema, type);
 				Emit (OpCodes.Ldobj, type);
 			} else if (type.IsGenericParameter) {
 				Emit (OpCodes.Ldelem, type);
 			} else if (type.IsPointer)
 				Emit (OpCodes.Ldelem_I);
 			else
 				Emit (OpCodes.Ldelem_Ref);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="151" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4595" endline="4624">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4625" endline="4669">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="152" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="505" endline="531">
<![CDATA[
 
 		struct CustomModifiers
 		{
 			internal Type[] required;
 			internal Type[] optional;
 		}
 
 		private static CustomModifiers ReadCustomModifiers(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			CustomModifiers mods = new CustomModifiers();
 			byte b = br.PeekByte();
 			if (IsCustomModifier(b))
 			{
 				List<Type> required = new List<Type>();
 				List<Type> optional = new List<Type>();
 				while (IsCustomModifier(b))
 				{
 					bool req = br.ReadByte() == ELEMENT_TYPE_CMOD_REQD;
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					(req ? required 
 					b = br.PeekByte();
 				}
 				while (IsCustomModifier(b))
 				{
 					bool req = br.ReadByte() == ELEMENT_TYPE_CMOD_REQD;
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					(req ? required 
 					b = br.PeekByte();
 				}
 				mods.required = required.ToArray();
 				mods.optional = optional.ToArray();
 			}
 			return mods;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="559" endline="589">
<![CDATA[
 
 		protected static void ReadCustomModifiers(ModuleReader module, ByteReader br, IGenericContext context, out Type[] requiredCustomModifiers, out Type[] optionalCustomModifiers)
 		{
 			byte b = br.PeekByte();
 			if (IsCustomModifier(b))
 			{
 				List<Type> required = new List<Type>();
 				List<Type> optional = new List<Type>();
 				while (IsCustomModifier(b))
 				{
 					br.ReadByte();
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					if (b == ELEMENT_TYPE_CMOD_REQD)
 					{
 						required.Add(type);
 					}
 					else
 					{
 						optional.Add(type);
 					}
 					b = br.PeekByte();
 				}
 				while (IsCustomModifier(b))
 				{
 					br.ReadByte();
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					if (b == ELEMENT_TYPE_CMOD_REQD)
 					{
 						required.Add(type);
 					}
 					else
 					{
 						optional.Add(type);
 					}
 					b = br.PeekByte();
 				}
 				requiredCustomModifiers = required.ToArray();
 				optionalCustomModifiers = optional.ToArray();
 			}
 			else
 			{
 				requiredCustomModifiers = null;
 				optionalCustomModifiers = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="200" endline="235">
<![CDATA[
 
 		private void SetMethodImplAttribute(CustomAttributeBuilder customBuilder)
 		{
 			MethodImplOptions opt;
 			switch (customBuilder.Constructor.ParameterCount)
 			{
 				case 0
 					opt = 0;
 					break;
 				case 1
 					{
 						object val = customBuilder.GetConstructorArgument(0);
 						if (val is short)
 						{
 							opt = (MethodImplOptions)(short)val;
 						}
 						else if (val is int)
 						{
 							opt = (MethodImplOptions)(int)val;
 						}
 						else
 						{
 							opt = (MethodImplOptions)val;
 						}
 						break;
 					}
 				default
 					throw new NotSupportedException();
 			}
 			MethodCodeType? type = customBuilder.GetFieldValue<MethodCodeType>("MethodCodeType");
 			implFlags = (MethodImplAttributes)opt;
 			if (type.HasValue)
 			{
 				implFlags |= (MethodImplAttributes)type;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="153" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1642" endline="1663">
<![CDATA[
 
 		private static Type[] BindArray(Type[] array, IGenericBinder binder)
 		{
 			if (array ==null || array.Length == 0)
 			{
 				return array;
 			}
 			Type[] result = array;
 			for (int i = 0; i < array.Length; i++)
 			{
 				Type type = array[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(type, array[i]))
 				{
 					if (result == array)
 					{
 						result = (Type[])array.Clone();
 					}
 					result[i] = type;
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				Type type = array[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(type, array[i]))
 				{
 					if (result == array)
 					{
 						result = (Type[])array.Clone();
 					}
 					result[i] = type;
 				}
 			}
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="461" endline="481">
<![CDATA[
 
 		private static Type[] NormalizeAndCopy(Type[] array)
 		{
 			if (array == null || array.Length == 0)
 			{
 				return null;
 			}
 			Type[] copy = null;
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			return copy;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="154" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="602" endline="635">
<![CDATA[
 
 		internal int ImportType(Type type)
 		{
 			int token;
 			if (!typeTokens.TryGetValue(type, out token))
 			{
 				if (type.HasElementType || (type.IsGenericType && !type.IsGenericTypeDefinition))
 				{
 					ByteBuffer spec = new ByteBuffer(5);
 					Signature.WriteTypeSpec(this, spec, type);
 					token = 0x1B000000 | this.TypeSpec.AddRecord(this.Blobs.Add(spec));
 				}
 				else
 				{
 					TypeRefTable.Record rec = new TypeRefTable.Record();
 					if (type.IsNested)
 					{
 						rec.ResolutionScope = GetTypeToken(type.DeclaringType).Token;
 						rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 						rec.TypeNameSpace = 0;
 					}
 					else
 					{
 						rec.ResolutionScope = ImportAssemblyRef(type.Assembly);
 						rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 						string ns = type.Namespace;
 						rec.TypeNameSpace = ns == null ? 0 
 					}
 					token = 0x01000000 | this.TypeRef.AddRecord(rec);
 				}
 				typeTokens.Add(type, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="678" endline="714">
<![CDATA[
 
 		private int FindOrAddAssemblyRef(AssemblyName name)
 		{
 			AssemblyRefTable.Record rec = new AssemblyRefTable.Record();
 			Version ver = name.Version;
 			rec.MajorVersion = (ushort)ver.Major;
 			rec.MinorVersion = (ushort)ver.Minor;
 			rec.BuildNumber = (ushort)ver.Build;
 			rec.RevisionNumber = (ushort)ver.Revision;
 			rec.Flags = (int)(name.Flags & AssemblyNameFlags.Retargetable);
 			byte[] publicKeyOrToken = null;
 			if (usePublicKeyAssemblyReference)
 			{
 				publicKeyOrToken = name.GetPublicKey();
 			}
 			if (publicKeyOrToken == null || publicKeyOrToken.Length == 0)
 			{
 				publicKeyOrToken = name.GetPublicKeyToken();
 			}
 			else
 			{
 				const int PublicKey = 0x0001;
 				rec.Flags |= PublicKey;
 			}
 			rec.PublicKeyOrToken = this.Blobs.Add(ByteBuffer.Wrap(publicKeyOrToken));
 			rec.Name = this.Strings.Add(name.Name);
 			if (name.CultureInfo != null)
 			{
 				rec.Culture = this.Strings.Add(name.CultureInfo.Name);
 			}
 			else
 			{
 				rec.Culture = 0;
 			}
 			rec.HashValue = 0;
 			return 0x23000000 | this.AssemblyRef.FindOrAddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="882" endline="908">
<![CDATA[
 
 		internal void ExportTypes(Type[] types, int fileToken)
 		{
 			Dictionary<Type, int> declaringTypes = new Dictionary<Type, int>();
 			foreach (Type type in types)
 			{
 				if (!type.IsModulePseudoType && IsVisible(type))
 				{
 					ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
 					rec.Flags = (int)type.Attributes;
 					rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
 					rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 					string ns = type.Namespace;
 					rec.TypeNamespace = ns == null ? 0 
 					if (type.IsNested)
 					{
 						rec.Implementation = declaringTypes[type.DeclaringType];
 					}
 					else
 					{
 						rec.Implementation = fileToken;
 					}
 					int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
 					declaringTypes.Add(type, exportTypeToken);
 				}
 			}
 			foreach (Type type in types)
 			{
 				if (!type.IsModulePseudoType && IsVisible(type))
 				{
 					ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
 					rec.Flags = (int)type.Attributes;
 					rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
 					rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 					string ns = type.Namespace;
 					rec.TypeNamespace = ns == null ? 0 
 					if (type.IsNested)
 					{
 						rec.Implementation = declaringTypes[type.DeclaringType];
 					}
 					else
 					{
 						rec.Implementation = fileToken;
 					}
 					int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
 					declaringTypes.Add(type, exportTypeToken);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="155" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="191" endline="220">
<![CDATA[
 
 		internal void Bake()
 		{
 			PropertyTable.Record rec = new PropertyTable.Record();
 			rec.Flags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.Type = typeBuilder.ModuleBuilder.GetSignatureBlobIndex(sig);
 			int token = 0x17000000 | typeBuilder.ModuleBuilder.Property.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (getter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Getter, getter.MetadataToken, token);
 			}
 			if (setter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Setter, setter.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="161" endline="195">
<![CDATA[
 		}
 
 		internal void Bake()
 		{
 			EventTable.Record rec = new EventTable.Record();
 			rec.EventFlags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.EventType = eventtype;
 			int token = 0x14000000 | typeBuilder.ModuleBuilder.Event.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (addOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.AddOn, addOnMethod.MetadataToken, token);
 			}
 			if (removeOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.RemoveOn, removeOnMethod.MetadataToken, token);
 			}
 			if (fireMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Fire, fireMethod.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="156" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="460" endline="487">
<![CDATA[
 
 		private static void WriteGenericSignature(ModuleBuilder module, ByteBuffer bb, Type type)
 		{
 			Type[] typeArguments = type.GetGenericArguments();
 			Type[][] requiredCustomModifiers = type.__GetGenericArgumentsRequiredCustomModifiers();
 			Type[][] optionalCustomModifiers = type.__GetGenericArgumentsOptionalCustomModifiers();
 			if (!type.IsGenericTypeDefinition)
 			{
 				type = type.GetGenericTypeDefinition();
 			}
 			bb.Write(ELEMENT_TYPE_GENERICINST);
 			if (type.IsValueType)
 			{
 				bb.Write(ELEMENT_TYPE_VALUETYPE);
 			}
 			else
 			{
 				bb.Write(ELEMENT_TYPE_CLASS);
 			}
 			bb.WriteTypeDefOrRefEncoded(module.GetTypeToken(type).Token);
 			bb.WriteCompressedInt(typeArguments.Length);
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="666" endline="704">
<![CDATA[
 
 		internal static void WritePropertySig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			byte flags = PROPERTY;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes == null ? 0 
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, returnTypeRequiredCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, returnTypeOptionalCustomModifiers);
 			WriteType(module, bb, returnType);
 			if (parameterTypes != null)
 			{
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="370" endline="418">
<![CDATA[
 
 		private void WriteSigImpl(ModuleBuilder module, ByteBuffer bb, int parameterCount)
 		{
 			byte first;
 			if ((callingConvention & CallingConventions.Any) == CallingConventions.VarArgs)
 			{
 				Debug.Assert(genericParamCount == 0);
 				first = VARARG;
 			}
 			else if (genericParamCount > 0)
 			{
 				first = GENERIC;
 			}
 			else
 			{
 				first = DEFAULT;
 			}
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				first |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				first |= EXPLICITTHIS;
 			}
 			bb.Write(first);
 			if (genericParamCount > 0)
 			{
 				bb.WriteCompressedInt(genericParamCount);
 			}
 			bb.WriteCompressedInt(parameterCount);
 			// RetType
 			if (modifiers != null && modifiers[0] != null)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[0][0]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[0][1]);
 			}
 			WriteType(module, bb, returnType);
 			// Param
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (modifiers != null && modifiers[i + 1] != null)
 				{
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
 				}
 				WriteType(module, bb, parameterTypes[i]);
 			}
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (modifiers != null && modifiers[i + 1] != null)
 				{
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
 				}
 				WriteType(module, bb, parameterTypes[i]);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="157" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="936" endline="966">
<![CDATA[
 	
 	static int CompareMethodBase (object a, object b)
 	{
 		MethodBase aa = (MethodBase) a, bb = (MethodBase) b;
 		
 		if (aa.IsStatic == bb.IsStatic) {
 			int c = CompareMemberInfo (a, b);
 			if (c != 0)
 				return c;
 			ParameterInfo [] ap, bp;
 
 			//
 			// Sort overloads by the names of their types
 			// put methods with fewer params first.
 			//
 			
 			ap = aa.GetParameters ();
 			bp = bb.GetParameters ();
 			int n = System.Math.Min (ap.Length, bp.Length);
 
 			for (int i = 0; i < n; i ++)
 				if ((c = CompareType (ap [i].ParameterType, bp [i].ParameterType)) != 0)
 					return c;
 			for (int i = 0; i < n; i ++)
 				if ((c = CompareType (ap [i].ParameterType, bp [i].ParameterType)) != 0)
 					return c;
 
 			return ap.Length.CompareTo (bp.Length);
 		}
 		if (aa.IsStatic)
 			return -1;
 		
 		return 1;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1613" endline="1661">
<![CDATA[
 
 		// <summary>
 		//   Performs an `and' operation on the bit vector.  The `new_vector' may have
 		//   a different size than the current one.
 		// </summary>
 		private MyBitVector And (MyBitVector new_vector)
 		{
 			if (Count == 0)
 				return this;
 
 			var o = new_vector.vector != null ? new_vector.vector 
 
 			if (o == null) {
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				return this;
 			}
 
 			if (o.Count == 0) {
 				SetAll (false);
 				return this;
 			}
 
 			if (Count == o.Count) {
 				if (vector == null) {
 					if (shared == null) {
 						shared = new_vector.MakeShared (Count);
 						return this;
 					}
 					initialize_vector ();
 				}
 				vector.And (o);
 				return this;
 			}
 
 			int min = o.Count;
 			if (Count < min)
 				min = Count;
 
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1010" endline="1050">
<![CDATA[
 	
 		bool CreateTypeBuilder ()
 		{
 			//
 			// Sets .size to 1 for structs with no instance fields
 			//
 			int type_size = Kind == MemberKind.Struct && first_nonstatic_field == null ? 1 
 
 			if (IsTopLevel) {
 				// TODO
 				if (Module.GlobalRootNamespace.IsNamespace (Name)) {
 					Report.Error (519, Location, "`{0}' clashes with a predefined namespace", Name);
 				}
 
 				TypeBuilder = Module.CreateBuilder (Name, TypeAttr, type_size);
 			} else {
 				TypeBuilder = Parent.TypeBuilder.DefineNestedType (Basename, TypeAttr, null, type_size);
 			}
 
 			spec.SetMetaInfo (TypeBuilder);
 			spec.MemberCache = new MemberCache (this);
 			spec.DeclaringType = Parent.CurrentType;
 
 			if (!IsTopLevel)
 				Parent.MemberCache.AddMember (spec);
 
 			if (IsGeneric) {
 				string[] param_names = new string[TypeParameters.Length];
 				for (int i = 0; i < TypeParameters.Length; i++)
 					param_names [i] = TypeParameters[i].Name;
 				for (int i = 0; i < TypeParameters.Length; i++)
 					param_names [i] = TypeParameters[i].Name;
 
 				all_tp_builders = TypeBuilder.DefineGenericParameters (param_names);
 
 				int offset = CurrentTypeParametersStartIndex;
 				for (int i = offset; i < all_tp_builders.Length; i++) {
 					CurrentTypeParameters [i - offset].Define (all_tp_builders [i], spec);
 				}
 				for (int i = offset; i < all_tp_builders.Length; i++) {
 					CurrentTypeParameters [i - offset].Define (all_tp_builders [i], spec);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="158" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="154" endline="181">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][] t1, Type[][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="182" endline="209">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][][] t1, Type[][][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="125" endline="153">
<![CDATA[
 
 		// note that an empty array matches a null reference
 		internal static bool ArrayEquals(Type[] t1, Type[] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="159" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3042" endline="3076">
<![CDATA[
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="986" endline="1029">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			if (ec.Switch == null){
 				ec.Report.Error (153, loc, "A goto case is only valid inside a switch statement");
 				return false;
 			}
 
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			Constant c = expr as Constant;
 			if (c == null) {
 				ec.Report.Error (150, expr.Location, "A constant value is expected");
 				return false;
 			}
 
 			TypeSpec type = ec.Switch.SwitchType;
 			Constant res = c.TryReduce (ec, type, c.Location);
 			if (res == null) {
 				c.Error_ValueCannotBeConverted (ec, loc, type, true);
 				return false;
 			}
 
 			if (!Convert.ImplicitStandardConversionExists (c, type))
 				ec.Report.Warning (469, 2, loc,
 					"The `goto case' value is not implicitly convertible to type `{0}'",
 					TypeManager.CSharpName (type));
 
 			object val = res.GetValue ();
 			if (val == null)
 				val = SwitchLabel.NullStringCase;
 					
 			if (!ec.Switch.Elements.TryGetValue (val, out sl)) {
 				FlowBranchingBlock.Error_UnknownLabel (loc, "case " + 
 					(c.GetValue () == null ? "null" 
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="160" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="498" endline="532">
<![CDATA[
 
 	static public void Reset ()
 	{
 //		object_type = null;
 	
 		// TODO
 		system_type_get_type_from_handle =
 		bool_movenext_void =
 		void_dispose_void =
 		void_monitor_enter_object =
 		void_monitor_exit_object =
 		void_initializearray_array_fieldhandle =
 		int_interlocked_compare_exchange =
 		gen_interlocked_compare_exchange =
 		methodbase_get_type_from_handle =
 		methodbase_get_type_from_handle_generic =
 		fieldinfo_get_field_from_handle =
 		fieldinfo_get_field_from_handle_generic =
 		activator_create_instance =
 		delegate_combine_delegate_delegate =
 		delegate_remove_delegate_delegate = null;
 
 		int_get_offset_to_string_data =
 		ienumerator_getcurrent = null;
 
 		void_decimal_ctor_five_args =
 		void_decimal_ctor_int_arg =
 		void_decimal_ctor_long_arg = null;
 
 		string_empty = null;
 
 		typed_reference_type = arg_iterator_type = mbr_type =
 		generic_ilist_type = generic_icollection_type = generic_ienumerator_type =
 		generic_ienumerable_type = generic_nullable_type = expression_type = null;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\rootcontext.cs" startline="200" endline="241">
<![CDATA[
 		
 		public static void Reset (bool full)
 		{
 			if (!full)
 				return;
 			
 			Checked = false;
 			Unsafe = false;
 			StdLib = true;
 			StrongNameKeyFile = null;
 			StrongNameKeyContainer = null;
 			StrongNameDelaySign = false;
 			MainClass = null;
 			OutputFile = null;
 			Target = Target.Exe;
 			SdkVersion = SdkVersion.v2;
 			TargetExt = ".exe";
 			Platform = Platform.AnyCPU;
 			Version = LanguageVersion.Default;
 			VerifyClsCompliance = true;
 			Optimize = true;
 			Encoding = Encoding.Default;
 			Documentation = null;
 			GenerateDebugInfo = false;
 			ParseOnly = false;
 			TokenizeOnly = false;
 			Win32IconFile = null;
 			Win32ResourceFile = null;
 			Resources = null;
 			LoadDefaultReferences = true;
 			AssemblyReferences = new List<string> ();
 			AssemblyReferencesAliases = new List<Tuple<string, string>> ();
 			Modules = new List<string> ();
 			ReferencesLookupPaths = new List<string> ();
 			StdLibRuntimeVersion = RuntimeVersion.v2;
 
 			//
 			// Setup default defines
 			//
 			AllDefines = new List<string> ();
 			AddConditional ("__MonoCS__");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="534" endline="569">
<![CDATA[
 
 		static public byte[] ToCapiPublicKeyBlob (RSA rsa) 
 		{
 			RSAParameters p = rsa.ExportParameters (false);
 			int keyLength = p.Modulus.Length; // in bytes
 			byte[] blob = new byte [20 + keyLength];
 
 			blob [0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x24;	// ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
 			blob [8] = 0x52;	// Magic - RSA1 (ASCII in hex)
 			blob [9] = 0x53;
 			blob [10] = 0x41;
 			blob [11] = 0x31;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];	// bitlen
 			blob [13] = bitlen [1];	
 			blob [14] = bitlen [2];	
 			blob [15] = bitlen [3];
 
 			// public exponent (DWORD)
 			int pos = 16;
 			int n = p.Exponent.Length;
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			// modulus
 			pos = 20;
 			byte[] part = p.Modulus;
 			int len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 			return blob;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="161" nfragments="2" Csharpe_files="1" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1250" endline="6926">
<![CDATA[
 
 	static int[] global_yyStates;
 	static object[] global_yyVals;
 	protected bool use_global_stacks;
 	object[] yyVals;					// value stack
 	object yyVal;						// value stack ptr
 	int yyToken;						// current input
 	int yyTop;
 
   /** the generated parser.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex)
   {
     if (yyMax <= 0) yyMax = 256;		// initial size
     int yyState = 0;                   // state stack ptr
     int [] yyStates;               	// state stack 
     yyVal = null;
     yyToken = -1;
     int yyErrorFlag = 0;				// #tks to shift
 	if (use_global_stacks && global_yyStates != null) {
 		yyVals = global_yyVals;
 		yyStates = global_yyStates;
    } else {
 		yyVals = new object [yyMax];
 		yyStates = new int [yyMax];
 		if (use_global_stacks) {
 			global_yyVals = yyVals;
 			global_yyStates = yyStates;
 		}
 	}
 
     /*yyLoop
       if (yyTop >= yyStates.Length) {			// dynamically increase
         global
         global
       }
       yyStates[yyTop] = yyState;
       yyVals[yyTop] = yyVal;
       if (debug != null) debug.push(yyState, yyVal);
 
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 	| interactive_parsing  { Lexer.CompleteOnEOF = false; } opt_EOF
 	;
 
 opt_EOF
 	
 	  {
 		Lexer.check_incorrect_doc_comment ();
 	  }
 	| EOF
 	  {
 		Lexer.check_incorrect_doc_comment ();
 	  }
 	;
 
 outer_declarations
 	
 	| outer_declarations outer_declaration
 	;
  
 outer_declaration
 	
 	| using_directive 
 	| namespace_member_declaration
 	;
 
 extern_alias_directives
 	
 	| extern_alias_directives extern_alias_directive
 	;
 
 extern_alias_directive
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) $3; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
 	| EXTERN_ALIAS error
 	  {
 	  	syntax_error (GetLocation ($1), "`alias' expected");   // TODO
 	  }
 	;
  
 using_directives
 	
 	| using_directives using_directive
 	;
 
 using_directive
 	
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	| using_namespace_directive
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	;
 
 using_alias_directive
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) $4, GetLocation ($1));
 	  }
 	| USING error
 	 {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 
 using_namespace_directive
 	
 	  {
 		current_namespace.AddUsing ((MemberName) $2, GetLocation ($1));
 	  }
 	;
 
 //
 // Strictly speaking, namespaces don't have attributes but
 // we parse global attributes along with namespace declarations and then
 // detach them
 // 
 namespace_declaration
 	
 	  {
 		MemberName name = (MemberName) $3;
 
 		if ($1 != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  } 
 	  namespace_body opt_semicolon
 	  { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
 	;
 
 qualified_identifier
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, lt.Location);
 	  }
 	| qualified_identifier DOT IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberName ((MemberName) $1, lt.Value, lt.Location);		
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = new MemberName ("<invalid>", lexer.Location);
 	  }
 	;
 
 opt_semicolon
 	
 	| SEMICOLON
 	;
 
 opt_comma
 	
 	| COMMA
 	;
 
 namespace_name
 	
 	 {
 		MemberName name = (MemberName) $1;
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		$$ = name;
 	  }
 	;
 
 namespace_body
 	
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_extern_alias_directives
 	  opt_using_directives
 	  opt_namespace_member_declarations
 	  CLOSE_BRACE
 	;
 
 opt_using_directives
 	
 	| using_directives
 	;
 
 opt_extern_alias_directives
 	
 	| extern_alias_directives
 	;
 
 opt_namespace_member_declarations
 	
 	| namespace_member_declarations
 	;
 
 namespace_member_declarations
 	
 	| namespace_member_declarations namespace_member_declaration
 	;
 
 namespace_member_declaration
 	
 	  {
 		if ($1 != null) {
 			DeclSpace ds = (DeclSpace)$1;
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
 	| namespace_declaration
 	  {
 		current_namespace.DeclarationFound = true;
 	  }
 	| error
 	 {
 		Error_SyntaxError (yyToken);
 	 }
 	;
 
 type_declaration
 	
 	| struct_declaration
 	| interface_declaration
 	| enum_declaration		
 	| delegate_declaration
 //
 // Enable this when we have handled all errors, because this acts as a generic fallback
 //
 //	| error {
 //		Console.WriteLine ("Token=" + yyToken);
 //		Report.Error (1518, GetLocation ($1), "Expected class, struct, interface, enum or delegate");
 //	  }
 	;
 
 //
 // Attributes 17.2
 //
 
 global_attributes
 	
 	  {
 		if ($1 != null) {
 			Attributes attrs = (Attributes)$1;
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		$$ = $1;
 	  }
 	;
 
 opt_attributes
 	
 	  {
 		global_attrs_enabled = false;
 		$$ = null;
       }
 	| attribute_sections
 	  { 
 		global_attrs_enabled = false;
 		$$ = $1;
 	  }
     ;
  
 
 attribute_sections
 	
 	  {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) $1;
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					$$ = null;
 				} else {
 					$$ = new Attributes (sect);
 				}
 				if ($$ == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				$$ = new Attributes (sect);
 			}		
 		}
 		else
 			$$ = null;
 		current_attr_target = null;
 	  }
 	| attribute_sections attribute_section
 	  {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = $1 as Attributes;
 			var sect = (List<Attribute>) $2;
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					$$ = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			$$ = attrs;
 		}
 		else
 			$$ = null;
 		current_attr_target = null;
 	  }
 	;
 
 attribute_section
 	
 	  {
 		$$ = $3;
  	  }
 	| OPEN_BRACKET attribute_list opt_comma CLOSE_BRACKET
 	  {
 		$$ = $2;
 	  }
 	;
  
 attribute_target_specifier
 	
 	  {
 		current_attr_target = (string)$1;
 		$$ = $1;
 	  }
 	;
 
 attribute_target
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
 	| EVENT  { $$ = "event"; }
 	| RETURN { $$ = "return"; }
 	| error
 	  {
 		string name = GetTokenName (yyToken);
 		$$ = CheckAttributeTarget (name, GetLocation ($1));
 	  }
 	;
 
 attribute_list
 	
 	  {
 		$$ = new List<Attribute> (4) { (Attribute) $1 };
 	  }
 	| attribute_list COMMA attribute
 	  {
 		var attrs = (List<Attribute>) $1;
 		attrs.Add ((Attribute) $3);
 
 		$$ = attrs;
 	  }
 	;
 
 attribute
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  opt_attribute_arguments
 	  {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) $1;
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) $3;
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			$$ = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			// FIXME
 			$$ = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			$$ = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
 	;
 
 attribute_name
 	
 	;
 
 opt_attribute_arguments
 	
 	| OPEN_PARENS attribute_arguments CLOSE_PARENS
 	  {
 		$$ = $2;
 	  }
 	;
 
 
 attribute_arguments
 	
 	| positional_or_named_argument
 	  {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) $1);
 		$$ = new Arguments [] { a, null };
 	  }
 	| named_attribute_argument
 	  {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) $1);  
 		$$ = new Arguments [] { null, a };
 	  }
     | attribute_arguments COMMA positional_or_named_argument
 	  {
 		Arguments[] o = (Arguments[]) $1;
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) $3).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !($3 is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) $3);
 	  }
     | attribute_arguments COMMA named_attribute_argument
 	  {
 		Arguments[] o = (Arguments[]) $1;
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) $3);
 	  }
     ;
 
 positional_or_named_argument
 	
 	  {
 	  	$$ = new Argument ((Expression) $1);
 	  }
 	| named_argument
 	;
 
 named_attribute_argument
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  expression
 	  {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4);	  
 	  }
 	;
 	
 named_argument
 	
 	  {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "named argument");
 			
 		// Avoid boxing in common case (no modifier)
 		var arg_mod = $3 == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4, arg_mod);
 	  }
 	;
 	
 opt_named_modifier
 	
 	| REF
 	  { 
 		$$ = Argument.AType.Ref;
 	  }
 	| OUT
 	  { 
 		$$ = Argument.AType.Out;
 	  }
 	;
 		  
 opt_class_member_declarations
 	
 	| class_member_declarations
 	;
 
 class_member_declarations
 	
 	| class_member_declarations 
 	  class_member_declaration
 	;
 
 class_member_declaration
 	
 	| field_declaration			// done
 	| method_declaration			// done
 	| property_declaration			// done
 	| event_declaration			// done
 	| indexer_declaration			// done
 	| operator_declaration			// done
 	| constructor_declaration		// done
 	| destructor_declaration		// done
 	| type_declaration
 	| error
 	  {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		$$ = null;
 		lexer.parsing_generic_declaration = false;
 	  }
 	;
 
 struct_declaration
 	
 	  opt_modifiers
 	  opt_partial
 	  STRUCT
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  type_declaration_name
 	  { 
 		MemberName name = MakeName ((MemberName) $6);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) $2, (Attributes) $1), $3);
 	  }
 	  opt_class_base
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) $9);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation ($4));
 	  }
 	  struct_body
 	  {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_semicolon
 	  {
 		lbag.AppendToMember (current_class, GetLocation ($13));
 		$$ = pop_current_class ();
 	  }
 	| opt_attributes opt_modifiers opt_partial STRUCT error
 	  {
 		Error_SyntaxError (yyToken);
 	  }
 	;
 
 struct_body
 	
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_struct_member_declarations CLOSE_BRACE
 	  {
 		lbag.AppendToMember (current_class, GetLocation ($1), GetLocation ($4));
 	  }
 	;
 
 opt_struct_member_declarations
 	
 	| struct_member_declarations
 	;
 
 struct_member_declarations
 	
 	| struct_member_declarations struct_member_declaration
 	;
 
 struct_member_declaration
 	
 	| field_declaration
 	| method_declaration
 	| property_declaration
 	| event_declaration
 	| indexer_declaration
 	| operator_declaration
 	| constructor_declaration
 	| type_declaration
 
 	/*
 	 * This is only included so we can flag error 575
 	 * destructors only allowed on class types
 	 */
 	| destructor_declaration 
 	;
 	
 constant_declaration
 	
 	  opt_modifiers
 	  CONST type IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $5;
 		var mod = (Modifiers) $2;
 		current_field = new Const (current_class, (FullNamedExpression) $4, mod, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		$$ = current_field;
 	  }
 	  constant_initializer opt_constant_declarators SEMICOLON
 	  {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) $7;
 		lbag.AddMember (current_field, mod_locations, GetLocation ($3), GetLocation ($9));
 		current_field = null;
 	  }
 	;
 	
 opt_constant_declarators
 	
 	| constant_declarators
 	;
 	
 constant_declarators
 	
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| constant_declarators constant_declarator
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 constant_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) $3);
 	  	lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	;		
 
 constant_initializer
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  constant_initializer_expr
 	  {
 		--lexer.parsing_block;
 		$$ = new ConstInitializer (current_field, (Expression) $3, GetLocation ($1));
 	  }
 	| error
 	  {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		$$ = null;
 	  }	  
 	;
 	
 constant_initializer_expr
 	
 	| array_initializer
 	;
 
 field_declaration
 	
 	  opt_modifiers
 	  member_type IDENTIFIER
 	  {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) $3;
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation ($3), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) $4;
 		current_field = new Field (current_class, type, (Modifiers) $2, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 		current_container.AddField (current_field);
 		$$ = current_field;
 	  }
 	  opt_field_initializer
 	  opt_field_declarators
 	  SEMICOLON
 	  { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation ($8));
 		$$ = current_field;
 		current_field = null;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  FIXED simple_type IDENTIFIER
 	  { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($3), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) $5;
 		current_field = new FixedField (current_class, (FullNamedExpression) $4, (Modifiers) $2,
 			new MemberName (lt.Value, lt.Location), (Attributes) $1);
 			
 		current_container.AddField (current_field);
 	  }
 	  fixed_field_size opt_fixed_field_declarators SEMICOLON
 	  {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) $7;	    
 		lbag.AddMember (current_field, mod_locations, GetLocation ($9));
 		$$ = current_field;
 	    current_field = null;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  FIXED simple_type error
 	  SEMICOLON
 	  {
 		Report.Error (1641, GetLocation ($5), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
 	;
 	
 opt_field_initializer
 	
 	| ASSIGN
 	  {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation ($1));
 	  }
 	  variable_initializer
 	  {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) $3;
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
 	;
 	
 opt_field_declarators
 	
 	| field_declarators
 	;
 	
 field_declarators
 	
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| field_declarators field_declarator
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 field_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| COMMA IDENTIFIER ASSIGN
 	  {
 		++lexer.parsing_block;
 	  }
 	  variable_initializer
 	  {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) $2;	  
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) $5);
 	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	;	
 
 opt_fixed_field_declarators
 	
 	| fixed_field_declarators
 	;
 	
 fixed_field_declarators
 	
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| fixed_field_declarators fixed_field_declarator
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 fixed_field_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) $3);
 		lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	;
 
 fixed_field_size
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  expression CLOSE_BRACKET
 	  {
 		--lexer.parsing_block;
 		$$ = new ConstInitializer (current_field, (Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	| OPEN_BRACKET error
 	  {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		$$ = null;
 	  }	  
 	;
 
 variable_initializer
 	
 	| array_initializer
 	| error
 	  {
 		// It has to be here for the parent to safely restore artificial block
 	  	Error_SyntaxError (yyToken);
 	  	$$ = null;
 	  }
 	;
 
 method_declaration
 	
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
 	  method_body
 	  {
 		Method method = (Method) $1;
 		method.Block = (ToplevelBlock) $3;
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	;
 
 method_header
 	
 	  opt_modifiers
 	  member_type
 	  method_declaration_name OPEN_PARENS
 	  {
 		valid_param_mod = ParameterModifierType.All;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) $4;
 		current_local_parameters = (ParametersCompiled) $7;
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) $3, current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) $10);
 		} else if ($10 != null) {
 			Report.Error (80, GetLocation ($10),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) $3, (Modifiers) $2,
 				     name, current_local_parameters, (Attributes) $1);
 				     
 		if ($10 != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation ($5), GetLocation ($8));
 		$$ = method;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  PARTIAL
 	  VOID method_declaration_name
 	  OPEN_PARENS
 	  {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS 
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) $5;
 		current_local_parameters = (ParametersCompiled) $8;
 
 		if ($10 != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation ($4)),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) $11);
 		}
 
 		var modifiers = (Modifiers) $2;
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation ($4)),
 				     modifiers, name, current_local_parameters, (Attributes) $1);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		// TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation ($3));
 		lbag.AddMember (method, mod_locations, GetLocation ($6), GetLocation ($9));
 		$$ = method;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  member_type
 	  modifiers method_declaration_name OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
 	  {
 		MemberName name = (MemberName) $5;
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) $4));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) $3,
 					    0, name, (ParametersCompiled) $7, (Attributes) $1);
 
 		current_local_parameters = (ParametersCompiled) $7;
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		$$ = method;
 	  }
 	;
 
 method_body
 	
 	| SEMICOLON		{ $$ = null; }
 	;
 
 opt_formal_parameter_list
 	
 	| formal_parameter_list
 	;
 	
 formal_parameter_list
 	
 	  {
 		var pars_list = (List<Parameter>) $1;
 	  	$$ = new ParametersCompiled (pars_list.ToArray ());
 	  } 
 	| fixed_parameters COMMA parameter_array
 	  {
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add ((Parameter) $3);
 
 		$$ = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
 	| fixed_parameters COMMA arglist_modifier
 	  {
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add (new ArglistParameter (GetLocation ($3)));
 		$$ = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
 	| parameter_array COMMA error
 	  {
 		if ($1 != null)
 			Report.Error (231, ((Parameter) $1).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );			
 	  }
 	| fixed_parameters COMMA parameter_array COMMA error
 	  {
 		if ($3 != null)
 			Report.Error (231, ((Parameter) $3).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add (new ArglistParameter (GetLocation ($3)));
 
 		$$ = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
 	| arglist_modifier COMMA error
 	  {
 		Report.Error (257, GetLocation ($1), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		$$ = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation ($1)) }, true);
 	  }
 	| fixed_parameters COMMA ARGLIST COMMA error 
 	  {
 		Report.Error (257, GetLocation ($3), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add (new ArglistParameter (GetLocation ($3)));
 
 		$$ = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
 	| parameter_array 
 	  {
 		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );
 	  }
 	| arglist_modifier
 	  {
 		$$ = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation ($1)) }, true);
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
 	;
 
 fixed_parameters
 	
 	  {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) $1;
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		$$ = parameters_bucket;
 	  }
 	| fixed_parameters COMMA fixed_parameter
 	  {
 		var pars = (List<Parameter>) $1;
 		Parameter p = (Parameter) $3;
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation ($2));
 		}
 		
 		$$ = $1;
 	  }
 	;
 
 fixed_parameter
 	
 	  opt_parameter_modifier
 	  parameter_type
 	  IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new Parameter ((FullNamedExpression) $3, lt.Value, (Parameter.Modifier) $2, (Attributes) $1, lt.Location);
 	  }
 	| opt_attributes
 	  opt_parameter_modifier
 	  parameter_type
 	  IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
 	  {
 		var lt = (Tokenizer.LocatedToken) $4;
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		$$ = new Parameter ((FullNamedExpression) $3, lt.Value, (Parameter.Modifier) $2, (Attributes) $1, lt.Location);
 	  }
 	| opt_attributes
 	  opt_parameter_modifier
 	  parameter_type
 	  error
 	  {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation ($4);
 		$$ = new Parameter ((FullNamedExpression) $3, "NeedSomeGeneratorHere", (Parameter.Modifier) $2, (Attributes) $1, l);
 	  }
 	| opt_attributes
 	  opt_parameter_modifier
 	  parameter_type
 	  IDENTIFIER
 	  ASSIGN
 	  {
 	  	++lexer.parsing_block;
 	  }
 	  constant_expression
 	  {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation ($5), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) $2;
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation ($5), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new Parameter ((FullNamedExpression) $3, lt.Value, mod, (Attributes) $1, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($5));
 		
 		if ($7 != null)
 			((Parameter) $$).DefaultValue = new DefaultParameterValueExpression ((Expression) $7);
 	  }
 	;
 
 opt_parameter_modifier
 	
 	| parameter_modifiers
 	;
 
 parameter_modifiers
 	
 	  {
 		$$ = $1;
 	  }
 	| parameter_modifiers parameter_modifier
 	  {
 		Parameter.Modifier p2 = (Parameter.Modifier)$2;
   		Parameter.Modifier mod = (Parameter.Modifier)$1 | p2;
   		if (((Parameter.Modifier)$1 & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		$$ = mod;
 	  }
 	;
 
 parameter_modifier
 	
 	  {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation ($1));
 	  		
 	  	$$ = Parameter.Modifier.REF;
 	  }
 	| OUT
 	  {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation ($1));
 	  
 	  	$$ = Parameter.Modifier.OUT;
 	  }
 	| THIS
 	  {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation ($1));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation ($1), "extension methods");
 	  			
 		$$ = Parameter.Modifier.This;
 	  }
 	;
 
 parameter_array
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new ParamsParameter ((FullNamedExpression) $3, lt.Value, (Attributes) $1, lt.Location);
 	  }
 	| opt_attributes params_modifier type IDENTIFIER ASSIGN constant_expression
 	  {
 		Report.Error (1751, GetLocation ($2), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new ParamsParameter ((FullNamedExpression) $3, lt.Value, (Attributes) $1, lt.Location);		
 	  }
 	| opt_attributes params_modifier type error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 	
 params_modifier
 	
 	  {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation ($1)), "The `params' modifier is not allowed in current context");
 	  }
 	| PARAMS parameter_modifier
 	  {
 		Parameter.Modifier mod = (Parameter.Modifier)$2;
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation ($1), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation ($1), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
 	| PARAMS params_modifier
 	  {
 		Error_DuplicateParameterModifier (GetLocation ($1), Parameter.Modifier.PARAMS);
 	  }
 	;
 	
 arglist_modifier
 	
 	  {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation ($1), "__arglist is not valid in this context");
 	  }
 	;
 	
 property_declaration
 	
 	  opt_modifiers
 	  member_type
 	  member_declaration_name
 	  {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
 	  OPEN_BRACE
 	  {
 		current_property = new Property (current_class, (FullNamedExpression) $3, (Modifiers) $2,
 			(MemberName) $4, (Attributes) $1);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation ($3), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation ($6));
 		
 		lexer.PropertyParsing = true;
 	  }
 	  accessor_declarations 
 	  {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
 	  CLOSE_BRACE
 	  {
 		lbag.AppendToMember (current_property, GetLocation ($10));
 		current_property = null;
 	  }
 	;
 
 
 indexer_declaration
 	
 	  member_type indexer_declaration_name OPEN_BRACKET
 	  {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_BRACKET OPEN_BRACE
 	  {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) $3,
 			(MemberName)$4, (Modifiers) $2, (ParametersCompiled) $7, (Attributes) $1);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation ($5), GetLocation ($8), GetLocation ($9));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation ($3), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation ($5), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
 	  accessor_declarations 
 	  {
 		  lexer.PropertyParsing = false;
 	  }
 	  CLOSE_BRACE
 	  { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation ($12));
 		current_property = null;		
 	  }
 	;
 
 
 accessor_declarations
 	
 	| get_accessor_declaration accessor_declarations
 	| set_accessor_declaration
 	| set_accessor_declaration accessor_declarations
 	| error
 	  {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation ($1), "A get or set accessor expected");
 		}
 	  }
 	;
 
 get_accessor_declaration
 	
 	  {
 		if ($2 != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation ($3), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) $2, ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) $1, GetLocation ($3));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) $2, (Attributes) $1, GetLocation ($3));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
 	  accessor_body
 	  {
 	  	if ($5 != null) {
 	  		current_property.Get.Block = (ToplevelBlock) $5;			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
 	;
 
 set_accessor_declaration
 	
 	  {
 		if ($2 != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation ($3), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) $2,
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation ($3)),
 					null),
 				(Attributes) $1, GetLocation ($3));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) $2, 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation ($3)),
 				(Attributes) $1, GetLocation ($3));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
 	  accessor_body
 	  {
 		if ($5 != null) {		
 			current_property.Set.Block = (ToplevelBlock) $5;
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
 	;
 
 accessor_body
 	
 	| SEMICOLON
 	  {
 		// TODO
 	  	$$ = null;
 	  }
 	| error
 	  {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	$$ = null;
 	  }
 	;
 
 interface_declaration
 	
 	  opt_modifiers
 	  opt_partial
 	  INTERFACE
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  type_declaration_name
 	  {
 		MemberName name = MakeName ((MemberName) $6);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) $2, (Attributes) $1), $3);
 		lbag.AddMember (current_class, mod_locations, GetLocation ($4));		
 	  }
 	  opt_class_base
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) $9);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
 	  OPEN_BRACE opt_interface_member_declarations CLOSE_BRACE
 	  {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_semicolon 
 	  {
 	    lbag.AppendToMember (current_class, GetLocation ($11), GetLocation ($13));
 		$$ = pop_current_class ();
 	  }
 	| opt_attributes opt_modifiers opt_partial INTERFACE error
 	  {
 		Error_SyntaxError (yyToken);	  
 	  }
 	;
 
 opt_interface_member_declarations
 	
 	| interface_member_declarations
 	;
 
 interface_member_declarations
 	
 	| interface_member_declarations interface_member_declaration
 	;
 
 interface_member_declaration
 	
 	  {
 		Report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
 	  }
 	| field_declaration
 	  {
 		Report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
 	  }
 	| method_declaration
 	| property_declaration
 	| event_declaration
 	| indexer_declaration
 	| operator_declaration
 	  {
 	  	Report.Error (567, GetLocation ($1), "Interfaces cannot contain operators");
 	  }
 	| constructor_declaration
 	  {
 	  	Report.Error (526, GetLocation ($1), "Interfaces cannot contain contructors");
 	  }
 	| type_declaration
 	  {
 	  	Report.Error (524, GetLocation ($1), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
 	;
 
 operator_declaration
 	
 	  {
 	  }
 	  operator_body
 	  {
 		OperatorDeclaration decl = (OperatorDeclaration) $3;
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) $2, 
 				current_local_parameters,
 				(ToplevelBlock) $5, (Attributes) $1, decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			// Note again, checking is done in semantic analysis
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
 	;
 
 operator_body 
 	
 	| SEMICOLON { $$ = null; }
 	; 
 
 operator_type
 	
 	| VOID
 	  {
 		Report.Error (590, GetLocation ($1), "User-defined operators cannot return void");
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }
 	;
 
 operator_declarator
 	
 	  {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation ($2);
 		Operator.OpType op = (Operator.OpType) $3;
 		current_local_parameters = (ParametersCompiled)$6;
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		$$ = new OperatorDeclaration (op, (FullNamedExpression) $1, loc);
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3), GetLocation ($4), GetLocation ($7));
 	  }
 	| conversion_operator_declarator
 	;
 
 overloadable_operator
 // Unary operators
 	
         | TILDE  { $$ = Operator.OpType.OnesComplement; }  
         | OP_INC { $$ = Operator.OpType.Increment; }
         | OP_DEC { $$ = Operator.OpType.Decrement; }
         | TRUE   { $$ = Operator.OpType.True; }
         | FALSE  { $$ = Operator.OpType.False; }
 // Unary and binary
         | PLUS { $$ = Operator.OpType.Addition; }
         | MINUS { $$ = Operator.OpType.Subtraction; }
 // Binary
         | STAR { $$ = Operator.OpType.Multiply; }
         | DIV {  $$ = Operator.OpType.Division; }
         | PERCENT { $$ = Operator.OpType.Modulus; }
         | BITWISE_AND { $$ = Operator.OpType.BitwiseAnd; }
         | BITWISE_OR { $$ = Operator.OpType.BitwiseOr; }
         | CARRET { $$ = Operator.OpType.ExclusiveOr; }
         | OP_SHIFT_LEFT { $$ = Operator.OpType.LeftShift; }
         | OP_SHIFT_RIGHT { $$ = Operator.OpType.RightShift; }
         | OP_EQ { $$ = Operator.OpType.Equality; }
         | OP_NE { $$ = Operator.OpType.Inequality; }
         | OP_GT { $$ = Operator.OpType.GreaterThan; }
         | OP_LT { $$ = Operator.OpType.LessThan; }
         | OP_GE { $$ = Operator.OpType.GreaterThanOrEqual; }
         | OP_LE { $$ = Operator.OpType.LessThanOrEqual; }
 	;
 
 conversion_operator_declarator
 	
 	  {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation ($2);
 		current_local_parameters = (ParametersCompiled)$6;  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		$$ = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) $3, loc);
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
 	  }
 	| EXPLICIT OPERATOR type OPEN_PARENS
 	  {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation ($2);
 		current_local_parameters = (ParametersCompiled)$6;  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		$$ = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) $3, loc);
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
 	  }
 	| IMPLICIT error 
 	  {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		$$ = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation ($1));
 	  }
 	| EXPLICIT error 
 	  {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	$$ = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation ($1));
 	  }
 	;
 
 constructor_declaration
 	
 	  constructor_body
 	  { 
 		Constructor c = (Constructor) $1;
 		c.Block = (ToplevelBlock) $2;
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	;
 
 constructor_declarator
 	
 	  opt_modifiers
 	  IDENTIFIER
 	  {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
 	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) $6;  
 		
 		//
 		// start block here, so possible anonymous methods inside
 		// constructor initializer can get correct parent block
 		//
 	  	start_block (lexer.Location);
 	  }
 	  opt_constructor_initializer
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		var mods = (Modifiers) $2;
 		ConstructorInitializer ci = (ConstructorInitializer) $9;
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) $1, current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation ($5), GetLocation ($7));
 		$$ = c;
 	  }
 	;
 
 constructor_body
 	
 	| SEMICOLON 		{ current_block = null; $$ = null; }
 	;
 
 opt_constructor_initializer
 	
 	| constructor_initializer
 	;
 
 constructor_initializer
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  opt_argument_list CLOSE_PARENS
 	  {
 	  	--lexer.parsing_block;
 		$$ = new ConstructorBaseInitializer ((Arguments) $5, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3), GetLocation ($6));
 	  }
 	| COLON THIS OPEN_PARENS
 	  {
 		++lexer.parsing_block;
 	  }
 	  opt_argument_list CLOSE_PARENS
 	  {
 	  	--lexer.parsing_block;
 		$$ = new ConstructorThisInitializer ((Arguments) $5, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3), GetLocation ($6));
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 
 destructor_declaration
 	
 	  {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
 	  IDENTIFIER OPEN_PARENS CLOSE_PARENS method_body
 	  {
 		var lt = (Tokenizer.LocatedToken) $5;
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) $2,
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) $1, lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) $8;
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation ($3), GetLocation ($6), GetLocation ($7));
 
 		current_local_parameters = null;
 	  }
 	;
 
 event_declaration
 	
 	  opt_modifiers
 	  EVENT type member_declaration_name
 	  {
 		current_event_field = new EventField (current_class, (FullNamedExpression) $4, (Modifiers) $2, (MemberName) $5, (Attributes) $1);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		$$ = current_event_field;
 	  }
 	  opt_event_initializer
 	  opt_event_declarators
 	  SEMICOLON
 	  {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation ($3), GetLocation ($9));
 		current_event_field = null;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  EVENT type member_declaration_name
 	  OPEN_BRACE
 	  {
 		current_event = new EventProperty (current_class, (FullNamedExpression) $4, (Modifiers) $2, (MemberName) $5, (Attributes) $1);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation ($3), GetLocation ($6));
 		
 		lexer.EventParsing = true;
 	  }
 	  event_accessor_declarations
 	  {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation ($6), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
 	  CLOSE_BRACE
 	  {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation ($9));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
 	;
 	
 opt_event_initializer
 	
 	| ASSIGN
 	  {
 	  	++lexer.parsing_block;
 	  }
 	  event_variable_initializer
 	  {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) $3;
 	  }
 	;
 	
 opt_event_declarators
 	
 	| event_declarators
 	;
 	
 event_declarators
 	
 	  {
 		current_event_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| event_declarators event_declarator
 	  {
 		current_event_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 event_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| COMMA IDENTIFIER ASSIGN
 	  {
 		++lexer.parsing_block;
 	  }
 	  event_variable_initializer
 	  {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) $2;	  
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) $5);
 	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 	
 event_variable_initializer
 	
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
 	  variable_initializer
 	  {
 		$$ = $2;
 	  }
 	;
 	
 event_accessor_declarations
 	
 	| remove_accessor_declaration add_accessor_declaration
 	| add_accessor_declaration
 	  {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  } 
 	| remove_accessor_declaration
 	  {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }	
 	| error
 	  { 
 		Report.Error (1055, GetLocation ($1), "An add or remove accessor expected");
 		$$ = null;
 	  }
 	;
 
 add_accessor_declaration
 	
 	  {
 	  	if ($2 != ModifierNone) {
 			Report.Error (1609, GetLocation ($2), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) $1, GetLocation ($3));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
 	  event_accessor_block
 	  {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) $5;
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
 	;
 	
 remove_accessor_declaration
 	
 	  {
 	  	if ($2 != ModifierNone) {
 			Report.Error (1609, GetLocation ($2), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) $1, GetLocation ($3));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
 	  event_accessor_block
 	  {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) $5;
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
 	;
 
 event_accessor_block
 	
 	  {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		$$ = null;
 	  }
 	| block;
 	;
 
 enum_declaration
 	
 	  opt_modifiers
 	  ENUM type_declaration_name
 	  opt_enum_base
 	  {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
 	  OPEN_BRACE
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) $4;
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) $5, (Modifiers) $2, MakeName (name), (Attributes) $1), null);
 	  }
 	  opt_enum_member_declarations
 	  {
 	  	// here will be evaluated after CLOSE_BLACE is consumed.
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  CLOSE_BRACE opt_semicolon
 	  {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 //			if (RootContext.Documentation != null)
 //				em.DocComment = ev.DocComment;
 
 		lbag.AddMember (current_class, mod_locations, GetLocation ($3), GetLocation ($7), GetLocation ($11));
 		$$ = pop_current_class ();
 	  }
 	;
 
 opt_enum_base
 	
 	| COLON type
 	 {
 	 	var te = $2 as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation ($2), Report);
 			$$ = null;
 		} else {
 			$$ = $2;
 		}
 	 }
 	| COLON error
 	 {
 	 	Error_TypeExpected (GetLocation ($1));
 		$$ = null;
 	 }
 	;
 
 opt_enum_member_declarations
 	
 	| enum_member_declarations
 	| enum_member_declarations COMMA
 	  {
 	  	lbag.AddLocation ($1, GetLocation ($2));
 	  }
 	;
 
 enum_member_declarations
 	
 	| enum_member_declarations COMMA enum_member_declaration
 	  {
 	  	lbag.AddLocation ($1, GetLocation ($2));
 	  	$$ = $3;
 	  }
 	;
 
 enum_member_declaration
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		$$ = em;
 	  }
 	| opt_attributes IDENTIFIER
 	  {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
 	  ASSIGN constant_expression
 	  { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 	  	em.Initializer = new ConstInitializer (em, (Expression) $5, GetLocation ($4));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		$$ = em;
 	  }
 	;
 
 delegate_declaration
 	
 	  opt_modifiers
 	  DELEGATE
 	  member_type type_declaration_name
 	  OPEN_PARENS
 	  {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) $5);
 		ParametersCompiled p = (ParametersCompiled) $8;
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) $4,
 					     (Modifiers) $2, name, p, (Attributes) $1);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 	  }
 	  SEMICOLON
 	  {
 		current_delegate.SetParameterInfo ((List<Constraints>) $11);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation ($3), GetLocation ($6), GetLocation ($9), GetLocation ($13));
 
 		$$ = current_delegate;
 
 		current_delegate = null;
 	  }
 	;
 
 opt_nullable
 	
 	| INTERR_NULLABLE
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "nullable types");
 	  
 	  	$$ = ComposedTypeSpecifier.CreateNullable (GetLocation ($1));
 	  }
 	;
 
 namespace_or_type_name
 	
 	| qualified_alias_member IDENTIFIER opt_type_argument_list
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 		
 		$$ = new MemberName (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
 	  }
 	;
 
 member_name
 	
 	| namespace_or_type_name DOT IDENTIFIER opt_type_argument_list
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberName ((MemberName) $1, lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));		
 	  }
 	;
 
 type_name
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, (TypeArguments)$2, lt.Location);	  
 	  }
 	;
 	
 //
 // Generics arguments  (any type, without attributes)
 //
 opt_type_argument_list
 	
 	| OP_GENERICS_LT type_arguments OP_GENERICS_GT
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "generics");	  
 	  
 		$$ = $2;
 	  }
 	| OP_GENERICS_LT error
 	  {
 		Error_TypeExpected (lexer.Location);
 		$$ = new TypeArguments ();
 	  }
 	;
 
 type_arguments
 	
 	  {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) $1);
 		$$ = type_args;
 	  }
 	| type_arguments COMMA type
 	  {
 		TypeArguments type_args = (TypeArguments) $1;
 		type_args.Add ((FullNamedExpression) $3);
 		$$ = type_args;
 	  }	  
 	;
 
 //
 // Generics parameters (identifiers only, with attributes), used in type or method declarations
 //
 type_declaration_name
 	
 	  {
 		lexer.parsing_generic_declaration = true;
 	  }
 	  opt_type_parameter_list
 	  {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, (TypeArguments)$3, lt.Location);
 	  }
 	;
 
 member_declaration_name
 	
 	  {
 	  	MemberName mn = (MemberName)$1;
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
 	;
 
 method_declaration_name
 	
 	| explicit_interface IDENTIFIER opt_type_parameter_list
 	  {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new MemberName ((MemberName) $1, lt.Value, (TypeArguments) $3, lt.Location);
 	  }
 	;
 	
 indexer_declaration_name
 	
 	  {
 		lexer.parsing_generic_declaration = false;	  
 		$$ = new MemberName (TypeContainer.DefaultIndexerName, GetLocation ($1));
 	  }
 	| explicit_interface THIS
 	  {
 		lexer.parsing_generic_declaration = false;
 		$$ = new MemberName ((MemberName) $1, TypeContainer.DefaultIndexerName, null, GetLocation ($1));
 	  }
 	;
 
 explicit_interface
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, (TypeArguments) $2, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($3));
 	  }
 	| qualified_alias_member IDENTIFIER opt_type_argument_list DOT
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 		
 		$$ = new MemberName (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	| explicit_interface IDENTIFIER opt_type_argument_list DOT
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new MemberName ((MemberName) $1, lt.Value, (TypeArguments) $3, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	;
 	
 opt_type_parameter_list
 	
 	| OP_GENERICS_LT_DECL type_parameters OP_GENERICS_GT
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "generics");
 	  
 		$$ = $2;
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 
 type_parameters
 	
 	  {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)$1);
 		$$ = type_args;
 	  }
 	| type_parameters COMMA type_parameter
 	  {
 		TypeArguments type_args = (TypeArguments) $1;
 		type_args.Add ((FullNamedExpression)$3);
 		$$ = type_args;
 		lbag.AddLocation ($3, GetLocation ($3));
 	  }	  
 	;
 
 type_parameter
 	
 	  {
 		var lt = (Tokenizer.LocatedToken)$3;
 		$$ = new TypeParameterName (lt.Value, (Attributes)$1, (Variance) $2, lt.Location);
   	  }
   	| error
   	  {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation ($1), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	$$ = new TypeParameterName ("", null, lexer.Location);
   	  }
  	;
 
 //
 // All types where void is allowed
 //
 type_and_void
 	
 	| VOID
 	  {
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }
 	;
 	
 member_type
 	
 	  {
 		lexer.parsing_generic_declaration = true;
 	  }
 	;
 	
 //
 // A type which does not allow `void' to be used
 //
 type
 	
 	| VOID
 	  {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), Report);
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }	
 	;
 	
 simple_type
 	
 	| VOID
 	  {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), Report);
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }	
 	;
 	
 parameter_type
 	
 	| VOID
 	  {
 	  	Report.Error (1536, GetLocation ($1), "Invalid parameter type `void'");
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }	
 	;
 
 type_expression_or_array
 	
 	| type_expression rank_specifiers
 	  {
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	;
 	
 type_expression
 	
 	  {
 		MemberName name = (MemberName) $1;
 
 		if ($2 != null) {
 			$$ = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) $2);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				$$ = new VarExpr (name.Location);
 			else
 				$$ = name.GetTypeExpression ();
 		}
 	  }
 	| namespace_or_type_name pointer_stars
 	  {
 		$$ = new ComposedCast (((MemberName) $1).GetTypeExpression (), (ComposedTypeSpecifier) $2);
 	  }
 	| builtin_types opt_nullable
 	  {
 		if ($2 != null)
 			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| builtin_types pointer_stars
 	  {
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| VOID pointer_stars
 	  {
 		$$ = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation ($1)), (ComposedTypeSpecifier) $2);
 	  }
 	;
 
 type_list
 	
 	  {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) $1);
 		$$ = types;
 	  }
 	| type_list COMMA base_type_name
 	  {
 		var types = (List<FullNamedExpression>) $1;
 		types.Add ((FullNamedExpression) $3);
 		$$ = types;
 	  }
 	;
 
 base_type_name
 	
 	  {
 		if ($1 is ComposedCast) {
 			Report.Error (1521, GetLocation ($1), "Invalid base type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
 		}
 		$$ = $1;
 	  }
 	| error
 	  {
 	  	Error_TypeExpected (lexer.Location);
 		$$ = null;
 	  }
 	;
 	
 /*
  * replaces all the productions for isolating the various
  * simple types, but we need this to reuse it easily in variable_type
  */
 builtin_types
 	
 	| STRING	{ $$ = new TypeExpression (TypeManager.string_type, GetLocation ($1)); }
 	| BOOL		{ $$ = new TypeExpression (TypeManager.bool_type, GetLocation ($1)); }
 	| DECIMAL	{ $$ = new TypeExpression (TypeManager.decimal_type, GetLocation ($1)); }
 	| FLOAT		{ $$ = new TypeExpression (TypeManager.float_type, GetLocation ($1)); }
 	| DOUBLE	{ $$ = new TypeExpression (TypeManager.double_type, GetLocation ($1)); }
 	| integral_type
 	;
 
 integral_type
 	
 	| BYTE		{ $$ = new TypeExpression (TypeManager.byte_type, GetLocation ($1)); }
 	| SHORT		{ $$ = new TypeExpression (TypeManager.short_type, GetLocation ($1)); }
 	| USHORT	{ $$ = new TypeExpression (TypeManager.ushort_type, GetLocation ($1)); }
 	| INT		{ $$ = new TypeExpression (TypeManager.int32_type, GetLocation ($1)); }
 	| UINT		{ $$ = new TypeExpression (TypeManager.uint32_type, GetLocation ($1)); }
 	| LONG		{ $$ = new TypeExpression (TypeManager.int64_type, GetLocation ($1)); }
 	| ULONG		{ $$ = new TypeExpression (TypeManager.uint64_type, GetLocation ($1)); }
 	| CHAR		{ $$ = new TypeExpression (TypeManager.char_type, GetLocation ($1)); }
 	;
 
 //
 // Expressions, section 7.5
 //
 
 
 primary_expression
 	
 	| literal
 	| array_creation_expression
 	| parenthesized_expression
 	| default_value_expression
 	| invocation_expression
 	| element_access
 	| this_access
 	| base_access
 	| post_increment_expression
 	| post_decrement_expression
 	| object_or_delegate_creation_expression
 	| anonymous_type_expression
 	| typeof_expression
 	| sizeof_expression
 	| checked_expression
 	| unchecked_expression
 	| pointer_member_access
 	| anonymous_method_expression
 	;
 
 primary_expression_or_type
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new SimpleName (lt.Value, (TypeArguments)$2, lt.Location);	  
 	  }
 	| IDENTIFIER GENERATE_COMPLETION {
 		var lt = (Tokenizer.LocatedToken) $1;
 	       $$ = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
 	| member_access
 	;
 
 literal
 	
 	| LITERAL
 	| NULL			{ $$ = new NullLiteral (GetLocation ($1)); }
 	;
 
 boolean_literal
 	
 	| FALSE			{ $$ = new BoolLiteral (false, GetLocation ($1)); }
 	;
 
 
 //
 // Here is the trick, tokenizer may think that parens is a special but
 // parser is interested in open parens only, so we merge them.
 // Consider
 //
 open_parens_any
 	
 	| OPEN_PARENS_CAST
 	;
 
 // 
 // Use this production to accept closing parenthesis or 
 // performing completion
 //
 close_parens
 	
 	| COMPLETE_COMPLETION
 	;
 
 
 parenthesized_expression
 	
 	  {
 		$$ = new ParenthesizedExpression ((Expression) $2);
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	| OPEN_PARENS expression COMPLETE_COMPLETION
 	  {
 		$$ = new ParenthesizedExpression ((Expression) $2);
 	  }
 	;
 	
 member_access
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| builtin_types DOT IDENTIFIER opt_type_argument_list
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| BASE DOT IDENTIFIER opt_type_argument_list
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess (new BaseThis (GetLocation ($1)), lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| qualified_alias_member IDENTIFIER opt_type_argument_list
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 
 		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
 	  }
 	| primary_expression DOT GENERATE_COMPLETION {
 		$$ = new CompletionMemberAccess ((Expression) $1, null,GetLocation ($3));
 	  }
 	| primary_expression DOT IDENTIFIER GENERATE_COMPLETION {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
 	  }
 	| builtin_types DOT GENERATE_COMPLETION
 	  {
 		$$ = new CompletionMemberAccess ((Expression) $1, null, lexer.Location);
 	  }
 	| builtin_types DOT IDENTIFIER GENERATE_COMPLETION {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
  	  }
 	;
 
 invocation_expression
 	
 	  {
 		$$ = new Invocation ((Expression) $1, (Arguments) $3);
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 opt_object_or_collection_initializer
 	
 	| object_or_collection_initializer
 	;
 
 object_or_collection_initializer
 	
 	  {
 	  	if ($2 == null) {
 	  		$$ = CollectionOrObjectInitializers.Empty;
 	  		// TODO
 	  	} else {
 	  		$$ = new CollectionOrObjectInitializers ((List<Expression>) $2, GetLocation ($1));
 	  		lbag.AddLocation ($$, GetLocation ($3));
 	  	}
 	  }
 	| OPEN_BRACE member_initializer_list COMMA CLOSE_BRACE
 	  {
 	  	$$ = new CollectionOrObjectInitializers ((List<Expression>) $2, GetLocation ($1));
 	  	lbag.AddLocation ($$, GetLocation ($3), GetLocation ($4));
 	  }
 	;
 
 opt_member_initializer_list
 	
 	| member_initializer_list
 	{
 		$$ = $1;
 	}
 	;
 
 member_initializer_list
 	
 	  {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) $1);
 	  	$$ = a;
 	  }
 	| member_initializer_list COMMA member_initializer
 	  {
 	  	var a = (List<Expression>)$1;
 	  	a.Add ((Expression) $3);
 	  	$$ = a;
 	  }
 	| member_initializer_list error {
 	  	Error_SyntaxError (yyToken);
 		$$ = $1;
 	  }
 	;
 
 member_initializer
 	
 	  {
 	  	var lt = (Tokenizer.LocatedToken) $1;
 	  	$$ = new ElementInitializer (lt.Value, (Expression)$3, lt.Location);
 	  	lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| GENERATE_COMPLETION 
 	  {
 		$$ = new CompletionElementInitializer (null, GetLocation ($1));
 	  }
 	| non_assignment_expression opt_COMPLETE_COMPLETION  {
 		CompletionSimpleName csn = $1 as CompletionSimpleName;
 		if (csn == null)
 			$$ = new CollectionElementInitializer ((Expression)$1);
 		else
 			$$ = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
 	| OPEN_BRACE expression_list CLOSE_BRACE
 	  {
 		if ($2 == null)
 			$$ = null;
 		else
 	  		$$ = new CollectionElementInitializer ((List<Expression>)$2, GetLocation ($1));
 	  }
 	| OPEN_BRACE CLOSE_BRACE
 	  {
 	  	Report.Error (1920, GetLocation ($1), "An element initializer cannot be empty");
 		$$ = null;
 	  }	  
 	;
 
 initializer_value
 	
 	| object_or_collection_initializer
 	;
 
 opt_argument_list
 	
 	| argument_list
 	;
 
 argument_list
 	
 	  { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) $1);
 		$$ = list;
 	  }
 	| argument_list COMMA argument
 	  {
 		Arguments list = (Arguments) $1;
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) $3);
 		$$ = list;
 	  }
 	| argument_list COMMA named_argument
 	  {
 		Arguments list = (Arguments) $1;
 		NamedArgument a = (NamedArgument) $3;
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		$$ = list;
 	  }
 	| argument_list COMMA
 	  {
 	  	Report.Error (839, GetLocation ($2), "An argument is missing");
 	  	$$ = $1;
 	  }
 	| COMMA error
 	  {
 	  	Report.Error (839, GetLocation ($1), "An argument is missing");
 	  	$$ = null;
 	  }
 	;
 
 argument
 	
 	  {
 		$$ = new Argument ((Expression) $1);
 	  }
 	| non_simple_argument
 	;
 
 argument_or_named_argument
 	
 	| named_argument
 	;
 
 non_simple_argument
 	
 	  { 
 		$$ = new Argument ((Expression) $2, Argument.AType.Ref);
 		lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| OUT variable_reference 
 	  { 
 		$$ = new Argument ((Expression) $2, Argument.AType.Out);
 		lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| ARGLIST OPEN_PARENS argument_list CLOSE_PARENS
 	  {
 		$$ = new Argument (new Arglist ((Arguments) $3, GetLocation ($1)));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| ARGLIST OPEN_PARENS CLOSE_PARENS
 	  {
 		$$ = new Argument (new Arglist (GetLocation ($1)));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
 	  }	  
 	;
 
 variable_reference
 	
 	;
 
 element_access
 	
 	  {
 		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	;
 
 expression_list
 	
 	  {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) $1);
 		$$ = list;
 	  }
 	| expression_list COMMA expression
 	  {
 		var list = (List<Expression>) $1;
 		list.Add ((Expression) $3);
 		$$ = list;
 	  }
 	| expression_list error {
 	  	Error_SyntaxError (yyToken);
 		$$ = $1;
 	  }
 	;
 	
 expression_list_arguments
 	
 	  {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) $1);
 		$$ = args;
 	  }
 	| expression_list_arguments COMMA expression_list_argument
 	  {
 		Arguments args = (Arguments) $1;
 		if (args [args.Count - 1] is NamedArgument && !($3 is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) $3);
 		$$ = args;	  
 	  }
 	;
 	
 expression_list_argument
 	
 	  {
 	  	$$ = new Argument ((Expression) $1);
 	  }
 	| named_argument
 	;
 
 this_access
 	
 	  {
 		$$ = new This (GetLocation ($1));
 	  }
 	;
 
 base_access
 	
 	  {
 	  	$$ = new ElementAccess (new BaseThis (GetLocation ($1)), (Arguments) $3, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	| BASE OPEN_BRACKET error
 	  {
 	  	Error_SyntaxError (yyToken);
 		$$ = new ElementAccess (null, null, GetLocation ($2));
 	  }
 	;
 
 post_increment_expression
 	
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) $1, GetLocation ($2));
 	  }
 	;
 
 post_decrement_expression
 	
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) $1, GetLocation ($2));
 	  }
 	;
 	
 object_or_delegate_creation_expression
 	
 	  {
 		if ($6 != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation ($1), "object initializers");
 				
 			$$ = new NewInitialize ((FullNamedExpression) $2, (Arguments) $4, (CollectionOrObjectInitializers) $6, GetLocation ($1));
 		} else {
 			$$ = new New ((FullNamedExpression) $2, (Arguments) $4, GetLocation ($1));
 		}
 		
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	| NEW new_expr_type object_or_collection_initializer
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "collection initializers");
 	  
 		$$ = new NewInitialize ((FullNamedExpression) $2, null, (CollectionOrObjectInitializers) $3, GetLocation ($1));
 	  }
 	;
 
 array_creation_expression
 	
 	  opt_rank_specifier
 	  opt_array_initializer
 	  {
 		$$ = new ArrayCreation ((FullNamedExpression) $2, (List<Expression>) $4,
 				new ComposedTypeSpecifier (((List<Expression>) $4).Count, GetLocation ($3)) {
 	  				Next = (ComposedTypeSpecifier) $6
 			  	}, (ArrayInitializer) $7, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	| NEW new_expr_type rank_specifiers opt_array_initializer
 	  {
 	  	if ($4 == null)
 	  		Report.Error (1586, GetLocation ($1), "Array creation must have array size or array initializer");
 
 		$$ = new ArrayCreation ((FullNamedExpression) $2, (ComposedTypeSpecifier) $3, (ArrayInitializer) $4, GetLocation ($1));
 	  }
 	| NEW rank_specifiers array_initializer
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "implicitly typed arrays");
 	  
 		$$ = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) $2, (ArrayInitializer) $3, GetLocation ($1));
 	  }
 	| NEW new_expr_type OPEN_BRACKET CLOSE_BRACKET OPEN_BRACKET_EXPR error CLOSE_BRACKET
 	  {
 		Report.Error (178, GetLocation ($6), "Invalid rank specifier, expecting `,' or `]'");
 		$$ = new ArrayCreation ((FullNamedExpression) $2, null, GetLocation ($1));
 	  }
 	| NEW new_expr_type error
 	  {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		$$ = new ArrayCreation ((FullNamedExpression) $2, null, GetLocation ($1));
 	  }
 	;
 
 new_expr_type
 	
 		++lexer.parsing_type;
 	  }
 	  simple_type
 	  {
 		--lexer.parsing_type;
 		$$ = $2;
 	  }
 	;
 
 anonymous_type_expression
 	
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation ($1), "anonymous types");
 
 		$$ = new NewAnonymousType ((List<AnonymousTypeParameter>) $3, current_container, GetLocation ($1));
 		
 		// TODO
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 anonymous_type_parameters_opt_comma
 	
 	| anonymous_type_parameters COMMA
 	;
 
 anonymous_type_parameters_opt
 	
 	| anonymous_type_parameters
 	;
 
 anonymous_type_parameters
 	
 	  {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) $1);
 	  	$$ = a;
 	  }
 	| anonymous_type_parameters COMMA anonymous_type_parameter
 	  {
 	  	var a = (List<AnonymousTypeParameter>) $1;
 	  	a.Add ((AnonymousTypeParameter) $3);
 	  	$$ = a;
 	  }
 	;
 
 anonymous_type_parameter
 	
 	  {
 		var lt = (Tokenizer.LocatedToken)$1;
 	  	$$ = new AnonymousTypeParameter ((Expression)$3, lt.Value, lt.Location);
 	  	lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken)$1;
 	  	$$ = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
 	| member_access
 	  {
 	  	MemberAccess ma = (MemberAccess) $1;
 	  	$$ = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
 	| error
 	  {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		$$ = null;
 	  }
 	;
 
 opt_rank_specifier
 	
 	| rank_specifiers
 	;
 
 rank_specifiers
 	
 	| rank_specifier rank_specifiers
 	  {
 	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
 	  	$$ = $1;
 	  }
 	;
 
 rank_specifier
 	
 	  {
 		$$ = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation ($1));
 	  }
 	| OPEN_BRACKET dim_separators CLOSE_BRACKET
 	  {
 		$$ = ComposedTypeSpecifier.CreateArrayDimension ((int)$2, GetLocation ($1));
 	  }
 	;
 
 dim_separators
 	
 	  {
 		$$ = 2;
 	  }
 	| dim_separators COMMA
 	  {
 		$$ = ((int) $1) + 1;
 	  }
 	;
 
 opt_array_initializer
 	
 	  {
 		$$ = null;
 	  }
 	| array_initializer
 	  {
 		$$ = $1;
 	  }
 	;
 
 array_initializer
 	
 	  {
 		var ai = new ArrayInitializer (0, GetLocation ($1));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation ($2));
 		$$ = ai;
 	  }
 	| OPEN_BRACE variable_initializer_list opt_comma CLOSE_BRACE
 	  {
 		var ai = new ArrayInitializer ((List<Expression>) $2, GetLocation ($1));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation ($3));
 		$$ = ai;
 	  }
 	;
 
 variable_initializer_list
 	
 	  {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) $1);
 		$$ = list;
 	  }
 	| variable_initializer_list COMMA variable_initializer
 	  {
 		var list = (List<Expression>) $1;
 		list.Add ((Expression) $3);
 		$$ = list;
 	  }
 	;
 
 typeof_expression
 	
       {
 	  	lexer.TypeOfParsing = true;
 	  }
 	  open_parens_any typeof_type_expression CLOSE_PARENS
 	  {
 	  	lexer.TypeOfParsing = false;
 		$$ = new TypeOf ((FullNamedExpression) $4, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	;
 	
 typeof_type_expression
 	
 	| unbound_type_name
 	| error
 	 {
 	 	Error_TypeExpected (lexer.Location);
 	 	$$ = null;
 	 }
 	;
 	
 unbound_type_name
 	
 	  {  
 		var lt = (Tokenizer.LocatedToken) $1;
 
 		$$ = new SimpleName (lt.Value, (int) $2, lt.Location);
 	  }
 	| qualified_alias_member IDENTIFIER generic_dimension
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 
 		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) $3, lt1.Location);
 	  }
 	| unbound_type_name DOT IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		
 		$$ = new MemberAccess ((Expression) $1, lt.Value, lt.Location);		
 	  }
 	| unbound_type_name DOT IDENTIFIER generic_dimension
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		
 		$$ = new MemberAccess ((Expression) $1, lt.Value, (int) $4, lt.Location);		
 	  }
 	| namespace_or_type_name DOT IDENTIFIER generic_dimension
 	  {
 		var te = ((MemberName) $1).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation ($4));
 
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess (te, lt.Value, (int) $4, lt.Location);		
 	  }
 	;
 
 generic_dimension
 	
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "generics");
 
 		$$ = $1;
 	  }
 	;
 	
 qualified_alias_member
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		$$ = lt;		
 	  }
 	;
 
 sizeof_expression
 	
 	  { 
 		$$ = new SizeOf ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 checked_expression
 	
 	  {
 		$$ = new CheckedExpr ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 unchecked_expression
 	
 	  {
 		$$ = new UnCheckedExpr ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 pointer_member_access 
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess (new Indirection ((Expression) $1, GetLocation ($2)), lt.Value, lt.Location);
 	  }
 	;
 
 anonymous_method_expression
 	
 	  {
 		start_anonymous (false, (ParametersCompiled) $2, GetLocation ($1));
 	  }
 	  block
 	  {
 		$$ = end_anonymous ((ParametersBlock) $4);
 	  }
 	;
 
 opt_anonymous_method_signature
 	
 	  {
 		$$ = ParametersCompiled.Undefined;
 	  } 
 	| anonymous_method_signature
 	;
 
 anonymous_method_signature
 	
 	  {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 	  	$$ = $3;
 	  }
 	;
 
 default_value_expression
 	
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "default value expression");
 
 		$$ = new DefaultValueExpression ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 unary_expression
 	
 	| BANG prefixed_unary_expression
 	  {
 		$$ = new Unary (Unary.Operator.LogicalNot, (Expression) $2, GetLocation ($1));
 	  }
 	| TILDE prefixed_unary_expression
 	  {
 		$$ = new Unary (Unary.Operator.OnesComplement, (Expression) $2, GetLocation ($1));
 	  }
 	| cast_expression
 	;
 
 cast_expression
 	
 	  {
 		$$ = new Cast ((FullNamedExpression) $2, (Expression) $4, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3));
 	  }
 	;
 
 	//
 	// The idea to split this out is from Rhys' grammar
 	// to solve the problem with casts.
 	//
 prefixed_unary_expression
 	
 	| PLUS prefixed_unary_expression
 	  { 
 	  	$$ = new Unary (Unary.Operator.UnaryPlus, (Expression) $2, GetLocation ($1));
 	  } 
 	| MINUS prefixed_unary_expression 
 	  { 
 		$$ = new Unary (Unary.Operator.UnaryNegation, (Expression) $2, GetLocation ($1));
 	  }
 	| OP_INC prefixed_unary_expression 
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) $2, GetLocation ($1));
 	  }
 	| OP_DEC prefixed_unary_expression 
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) $2, GetLocation ($1));
 	  }
 	| STAR prefixed_unary_expression
 	  {
 		$$ = new Indirection ((Expression) $2, GetLocation ($1));
 	  }
 	| BITWISE_AND prefixed_unary_expression
 	  {
 		$$ = new Unary (Unary.Operator.AddressOf, (Expression) $2, GetLocation ($1));
 	  }
 	;
 
 multiplicative_expression
 	
 	| multiplicative_expression STAR prefixed_unary_expression
 	  {
 		$$ = new Binary (Binary.Operator.Multiply, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| multiplicative_expression DIV prefixed_unary_expression
 	  {
 		$$ = new Binary (Binary.Operator.Division, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| multiplicative_expression PERCENT prefixed_unary_expression 
 	  {
 		$$ = new Binary (Binary.Operator.Modulus, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 additive_expression
 	
 	| additive_expression PLUS multiplicative_expression 
 	  {
 		$$ = new Binary (Binary.Operator.Addition, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| additive_expression MINUS multiplicative_expression
 	  {
 		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
   	| parenthesized_expression MINUS multiplicative_expression
 	  {
 	  	// Shift/Reduce conflict
 		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, GetLocation ($2));
   	  }
 	| additive_expression AS type
 	  {
 		$$ = new As ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| additive_expression IS type
 	  {
 		$$ = new Is ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }	  
 	;
 
 shift_expression
 	
 	| shift_expression OP_SHIFT_LEFT additive_expression
 	  {
 		$$ = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| shift_expression OP_SHIFT_RIGHT additive_expression
 	  {
 		$$ = new Binary (Binary.Operator.RightShift, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	; 
 
 relational_expression
 	
 	| relational_expression OP_LT shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.LessThan, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| relational_expression OP_GT shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| relational_expression OP_LE shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| relational_expression OP_GE shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 equality_expression
 	
 	| equality_expression OP_EQ relational_expression
 	  {
 		$$ = new Binary (Binary.Operator.Equality, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| equality_expression OP_NE relational_expression
 	  {
 		$$ = new Binary (Binary.Operator.Inequality, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	; 
 
 and_expression
 	
 	| and_expression BITWISE_AND equality_expression
 	  {
 		$$ = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 exclusive_or_expression
 	
 	| exclusive_or_expression CARRET and_expression
 	  {
 		$$ = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 inclusive_or_expression
 	
 	| inclusive_or_expression BITWISE_OR exclusive_or_expression
 	  {
 		$$ = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 conditional_and_expression
 	
 	| conditional_and_expression OP_AND inclusive_or_expression
 	  {
 		$$ = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 conditional_or_expression
 	
 	| conditional_or_expression OP_OR conditional_and_expression
 	  {
 		$$ = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 	
 null_coalescing_expression
 	
 	| conditional_or_expression OP_COALESCING null_coalescing_expression
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($2), "null coalescing operator");
 			
 		$$ = new Nullable.NullCoalescingOperator ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 conditional_expression
 	
 	| null_coalescing_expression INTERR expression COLON expression 
 	  {
 		$$ = new Conditional (new BooleanExpression ((Expression) $1), (Expression) $3, (Expression) $5, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	;
 
 assignment_expression
 	
 	  {
 		$$ = new SimpleAssign ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_MULT_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_DIV_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Division, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_MOD_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_ADD_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_SUB_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_SHIFT_LEFT_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_SHIFT_RIGHT_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_AND_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_OR_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_XOR_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 lambda_parameter_list
 	
 	  {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) $1);
 
 		$$ = pars;
 	  }
 	| lambda_parameter_list COMMA lambda_parameter
 	  {
 		var pars = (List<Parameter>) $1;
 		Parameter p = (Parameter)$3;
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		$$ = pars;
 	  }
 	;
 
 lambda_parameter
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 
 		$$ = new Parameter ((FullNamedExpression) $2, lt.Value, (Parameter.Modifier) $1, null, lt.Location);
 	  }
 	| parameter_type IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 
 		$$ = new Parameter ((FullNamedExpression) $1, lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
 	| IDENTIFIER
 	  {
 	  	var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
 	;
 
 opt_lambda_parameter_list
 	
 	| lambda_parameter_list		{ 
 		var pars_list = (List<Parameter>) $1;
 		$$ = new ParametersCompiled (pars_list.ToArray ());
 	  }
 	;
 
 lambda_expression_body
 	
 	| block
 	;
 	
 lambda_expression_body_simple
 	
 		start_block (lexer.Location);
 	  }
 	  expression_or_error	// Have to close block when error occurs
 	  {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) $2));
 		$$ = b;
 	  } 
 	;
 	
 expression_or_error
 	
 	| error
 	  {
 		Error_SyntaxError (yyToken);	
 		$$ = EmptyExpression.Null;
 	  }
 	;
 
 lambda_expression
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation ($1));
 	  }
 	  lambda_expression_body
 	  {
 		$$ = end_anonymous ((ParametersBlock) $4);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| OPEN_PARENS_LAMBDA
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
 	  opt_lambda_parameter_list CLOSE_PARENS ARROW 
 	  {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) $3, GetLocation ($1));
 	  }
 	  lambda_expression_body 
 	  {
 		$$ = end_anonymous ((ParametersBlock) $7);
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($4));
 	  }
 	;
 
 expression
 	
 	| non_assignment_expression
 	;
 	
 non_assignment_expression
 	
 	| lambda_expression
 	| query_expression
 	| ARGLIST
 	  {
 		$$ = new ArglistAccess (GetLocation ($1));
 	  }	
 	;
 
 constant_expression
 	
 	;
 
 boolean_expression
 	
 	  {
 		$$ = new BooleanExpression ((Expression) $1);
 	  }
 	;
 
 //
 // 10 classes
 //
 class_declaration
 	
 	  opt_modifiers
 	  opt_partial
 	  CLASS
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  type_declaration_name
 	  {
 		MemberName name = MakeName ((MemberName) $6);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) $2, (Attributes) $1), $3);
 	  }
 	  opt_class_base
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) $9);
 		lbag.AddMember (current_class, mod_locations, GetLocation ($4));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
 	  OPEN_BRACE opt_class_member_declarations CLOSE_BRACE
 	  {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_semicolon 
 	  {
 		lbag.AppendToMember (current_class, GetLocation ($11), GetLocation ($13), GetLocation ($15));
 		$$ = pop_current_class ();
 	  }
 	;	
 
 opt_partial
 	
 	  { $$ = null; }
 	| PARTIAL
 	  { $$ = $1; } // location
 	;
 
 opt_modifiers
 	
 	  {
 	    mod_locations = null;
 		$$ = ModifierNone;
 	  }
 	| modifiers
 	;
 
 modifiers
 	
 	| modifiers modifier
 	  { 
 		var m1 = (Modifiers) $1;
 		var m2 = (Modifiers) $2;
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		$$ = m1 | m2;
 	  }
 	;
 
 modifier
 	
 	  {
 		$$ = Modifiers.NEW;
 		StoreModifierLocation ($$, GetLocation ($1));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation ($1), "Keyword `new' is not allowed on namespace elements");
 	  }
 	| PUBLIC
 	  {
 		$$ = Modifiers.PUBLIC;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| PROTECTED
 	  {
 		$$ = Modifiers.PROTECTED;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| INTERNAL
 	  {
 		$$ = Modifiers.INTERNAL;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| PRIVATE
 	  {
 		$$ = Modifiers.PRIVATE;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| ABSTRACT
 	  {
 		$$ = Modifiers.ABSTRACT;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| SEALED
 	  {
 		$$ = Modifiers.SEALED;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| STATIC
 	  {
 		$$ = Modifiers.STATIC;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| READONLY
 	  {
 		$$ = Modifiers.READONLY;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| VIRTUAL
 	  {
 		$$ = Modifiers.VIRTUAL;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| OVERRIDE
 	  {
 		$$ = Modifiers.OVERRIDE;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| EXTERN
 	  {
 		$$ = Modifiers.EXTERN;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| VOLATILE
 	  {
 		$$ = Modifiers.VOLATILE;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| UNSAFE
 	  {
 		$$ = Modifiers.UNSAFE;
 		StoreModifierLocation ($$, GetLocation ($1));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation ($1));
 	  }
 	| ASYNC
 	  {
 		$$ = Modifiers.ASYNC;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	;
 
 opt_class_base
 	
 	| COLON type_list
 	 {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) $2);
 	 }
 	;
 
 opt_type_parameter_constraints_clauses
 	
 	| type_parameter_constraints_clauses 
 	  {
 		$$ = $1;
 	  }
 	| error
 	 {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	 }
 	;
 
 type_parameter_constraints_clauses
 	
 	  {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) $1);
 		$$ = constraints;
 	  }
 	| type_parameter_constraints_clauses type_parameter_constraints_clause
 	  {
 		var constraints = (List<Constraints>) $1;
 		Constraints new_constraint = (Constraints)$2;
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		$$ = constraints;
 	  }
 	; 
 
 type_parameter_constraints_clause
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) $4, GetLocation ($1));
 	  }
 	; 
 
 type_parameter_constraints
 	
 	  {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) $1);
 		$$ = constraints;
 	  }
 	| type_parameter_constraints COMMA type_parameter_constraint
 	  {
 		var constraints = (List<FullNamedExpression>) $1;
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation ($2), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = $3 as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation ($3), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) $3);
 		$$ = constraints;
 	  }
 	;
 
 type_parameter_constraint
 	
 	  {
 		if ($1 is ComposedCast)
 			Report.Error (706, GetLocation ($1), "Invalid constraint type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
 	  
 	  	$$ = $1;
 	  }
 	| NEW OPEN_PARENS CLOSE_PARENS
 	  {
 		$$ = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
 	  }
 	| CLASS
 	  {
 		$$ = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation ($1));
 	  }
 	| STRUCT
 	  {
 		$$ = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation ($1));
 	  }
 	;
 
 opt_type_parameter_variance
 	
 	  {
 		$$ = Variance.None;
 	  }
 	| type_parameter_variance
 	  {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		$$ = $1;
 	  }
 	;
 
 type_parameter_variance
 	
 	  {
 		$$ = Variance.Covariant;
 	  }
 	| IN
 	  {
 		$$ = Variance.Contravariant;
 	  }
 	;
 
 //
 // Statements (8.2)
 //
 
 //
 // A block is "contained" on the following places
 //	method_body
 //	property_declaration as part of the accessor body (get/set)
 //      operator_declaration
 //	constructor_declaration
 //	destructor_declaration
 //	event_declaration as part of add_accessor_declaration or remove_accessor_declaration
 //      
 block
 	
 	  {
 		++lexer.parsing_block;
 		start_block (GetLocation ($1));
 	  } 
 	  opt_statement_list block_end
 	  {
 		$$ = $4;
 	  }
 	;
 
 block_end 
 	
 	  {
 	 	--lexer.parsing_block;
 		$$ = end_block (GetLocation ($1));
 	  }
 	| COMPLETE_COMPLETION
 	  {
 	 	--lexer.parsing_block;
 		$$ = end_block (lexer.Location);
 	  }
 	;
 
 
 block_prepared
 	
 	  {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation ($1);
 	  }
 	  opt_statement_list CLOSE_BRACE 
 	  {
 		--lexer.parsing_block;
 		$$ = end_block (GetLocation ($4));
 	  }
 	;
 
 opt_statement_list
 	
 	| statement_list 
 	;
 
 statement_list
 	
 	| statement_list statement
 	;
 
 statement
 	
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| valid_declaration_statement
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| labeled_statement
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 
 //
 // The interactive_statement and its derivatives are only 
 // used to provide a special version of `expression_statement'
 // that has a side effect of assigning the expression to
 // $retval
 //
 interactive_statement_list
 	
 	| interactive_statement_list interactive_statement
 	;
 
 interactive_statement
 	
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| interactive_valid_declaration_statement
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| labeled_statement
 	;
 
 valid_declaration_statement
 	
 	| empty_statement
 	| expression_statement
 	| selection_statement
 	| iteration_statement
 	| jump_statement		  
 	| try_statement
 	| checked_statement
 	| unchecked_statement
 	| lock_statement
 	| using_statement
 	| unsafe_statement
 	| fixed_statement
 	;
 
 interactive_valid_declaration_statement
 	
 	| empty_statement
         | interactive_expression_statement
 	| selection_statement
 	| iteration_statement
 	| jump_statement		  
 	| try_statement
 	| checked_statement
 	| unchecked_statement
 	| lock_statement
 	| using_statement
 	| unsafe_statement
 	| fixed_statement
 	;
 
 embedded_statement
 	
 	| block_variable_declaration
 	  {
 		  Report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
 		  $$ = null;
 	  }
 	| labeled_statement
 	  {
 		  Report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
 		  $$ = null;
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = new EmptyStatement (GetLocation ($1));
 	  }
 	;
 
 empty_statement
 	
 	  {
 		// Uses lexer.Location because semicolon location is not kept in quick mode
 		$$ = new EmptyStatement (lexer.Location);
 	  }
 	;
 
 labeled_statement
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
 	  statement
 	;
 
 variable_type
 	
 	| variable_type_simple rank_specifiers
 	  {
 		if ($1 is VarExpr)
 			$1 = new SimpleName ("var", ((VarExpr) $1).Location);
 	  
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	;
 
 /* 
  * The following is from Rhys' grammar
  * > Types in local variable declarations must be recognized as 
  * > expressions to prevent reduce/reduce errors in the grammar.
  * > The expressions are converted into types during semantic analysis.
  */
 variable_type_simple
 	
 	  { 
 		// Ok, the above "primary_expression" is there to get rid of
 		// both reduce/reduce and shift/reduces in the grammar, it should
 		// really just be "type_name".  If you use type_name, a reduce/reduce
 		// creeps up.  If you use namespace_or_type_name (which is all we need
 		// really) two shift/reduces appear.
 		// 
 
 		// So the super-trick is that primary_expression
 		// can only be either a SimpleName or a MemberAccess. 
 		// The MemberAccess case arises when you have a fully qualified type-name like 
 		// Foo.Bar.Blah i;
 		// SimpleName is when you have
 		// Blah i;
 		
 		Expression expr = (Expression) $1;
 		if ($2 == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				$$ = new VarExpr (sn.Location);
 			else
 				$$ = $1;
 		} else if (expr is ATypeNameExpression) {
 			$$ = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) $2);
 		} else {
 			Error_ExpectingTypeName (expr);
 			$$ = null;
 		}
 	  }
 	| primary_expression_or_type pointer_stars
 	  {
 		ATypeNameExpression expr = $1 as ATypeNameExpression;
 
 		if (expr != null) {
 			$$ = new ComposedCast (expr, (ComposedTypeSpecifier) $2);
 		} else {
 			Error_ExpectingTypeName ((Expression)$1);
 			$$ = expr;
 		}
 	  }
 	| builtin_types opt_nullable
 	  {
 		if ($2 == null)
 			$$ = $1;
 		else
 			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| builtin_types pointer_stars
 	  {
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| VOID pointer_stars
 	  {
 		$$ = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation ($1)), (ComposedTypeSpecifier) $2);
 	  }	  
 	| VOID
 	  {
 		Expression.Error_VoidInvalidInTheContext (GetLocation ($1), Report);
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }
 	;
 	
 pointer_stars
 	
 	| pointer_star pointer_stars
 	  {
 	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
 	  	$$ = $1;
 	  }	  
 	;
 
 pointer_star
 	
 	  {
 		$$ = ComposedTypeSpecifier.CreatePointer (GetLocation ($1));
 	  }
 	;
 
 block_variable_declaration
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) $1, li);
 	  }
 	  opt_local_variable_initializer opt_variable_declarators SEMICOLON
 	  {
 		$$ = current_variable;
 		current_variable = null;
 		lbag.AddLocation ($$, GetLocation ($6));
 	  }
 	| CONST variable_type IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) $2, li);
 	  }
 	  const_variable_initializer opt_const_declarators SEMICOLON
 	  {
 		$$ = current_variable;
 		current_variable = null;
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($7));
 	  }
 	;
 
 opt_local_variable_initializer
 	
 	| ASSIGN block_variable_initializer
 	  {
 		current_variable.Initializer = (Expression) $2;
 		// TODO
 	  }
 	| error
 	  {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
 	;
 
 opt_variable_declarators
 	
 	| variable_declarators
 	;
 	
 variable_declarators
 	
 	| variable_declarators variable_declarator
 	;
 	
 variable_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation ($1));
 	  }
 	| COMMA IDENTIFIER ASSIGN block_variable_initializer
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) $4);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 	
 const_variable_initializer
 	
 	  {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
 	| ASSIGN constant_initializer_expr 
 	  {
 		current_variable.Initializer = (Expression) $2;
 	  }
 	;
 	
 opt_const_declarators
 	
 	| const_declarators
 	;
 	
 const_declarators
 	
 	| const_declarators const_declarator
 	;
 	
 const_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) $4);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 	
 block_variable_initializer
 	
 	| STACKALLOC simple_type OPEN_BRACKET_EXPR expression CLOSE_BRACKET
 	  {
 		$$ = new StackAlloc ((Expression) $2, (Expression) $4, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	| STACKALLOC simple_type
 	  {
 		Report.Error (1575, GetLocation ($1), "A stackalloc expression requires [] after type");
 		$$ = new StackAlloc ((Expression) $2, null, GetLocation ($1));		
 	  }
 	;
 
 expression_statement
 	
 	  {
 		$$ = $1;
 		lbag.AddStatement ($$, GetLocation ($2));
 	  }
 	| statement_expression COMPLETE_COMPLETION { $$ = $1; }
 	;
 
 interactive_expression_statement
 	
 	| interactive_statement_expression COMPLETE_COMPLETION { $$ = $1; }
 	;
 
 	//
 	// We have to do the wrapping here and not in the case above,
 	// because statement_expression is used for example in for_statement
 	//
 statement_expression
 	
 	  {
 		ExpressionStatement s = $1 as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation ($1));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		$$ = new StatementExpression (s);
 	  }
 	;
 
 interactive_statement_expression
 	
 	  {
 		Expression expr = (Expression) $1;
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		$$ = new StatementExpression (s);
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = new EmptyStatement (GetLocation ($1));
 	  }
 	;
 	
 selection_statement
 	
 	| switch_statement
 	; 
 
 if_statement
 	
 	  embedded_statement
 	  { 
 		if ($5 is EmptyStatement)
 			Warning_EmptyStatement (GetLocation ($5));
 		
 		$$ = new If ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| IF open_parens_any boolean_expression CLOSE_PARENS
 	  embedded_statement ELSE embedded_statement
 	  {
 		$$ = new If ((BooleanExpression) $3, (Statement) $5, (Statement) $7, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4), GetLocation ($6));
 		
 		if ($5 is EmptyStatement)
 			Warning_EmptyStatement (GetLocation ($5));
 		if ($7 is EmptyStatement)
 			Warning_EmptyStatement (GetLocation ($7));
 	  }
 	;
 
 switch_statement
 	
 	  {
 		start_block (GetLocation ($5));
 	  }
 	  opt_switch_sections CLOSE_BRACE
 	  {
 		$$ = new Switch ((Expression) $3, (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) $7, GetLocation ($1));	
 		end_block (GetLocation ($8));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 opt_switch_sections
 	
       {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		$$ = new List<SwitchSection> ();
 	  }
 	| switch_sections
 	;
 
 switch_sections
 	
 	  {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) $1);
 		$$ = sections;
 	  }
 	| switch_sections switch_section
 	  {
 		var sections = (List<SwitchSection>) $1;
 
 		sections.Add ((SwitchSection) $2);
 		$$ = sections;
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);	  
 		$$ = new List<SwitchSection> ();
 	  } 
 	;
 
 switch_section
 	
 	  {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
  	  statement_list 
 	  {
 		$$ = new SwitchSection ((List<SwitchLabel>) $1, current_block);
 	  }
 	;
 
 switch_labels
 	
 	  {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) $1);
 		$$ = labels;
 	  }
 	| switch_labels switch_label 
 	  {
 		var labels = (List<SwitchLabel>) ($1);
 		labels.Add ((SwitchLabel) $2);
 
 		$$ = labels;
 	  }
 	;
 
 switch_label
 	
 	 {
 	 	$$ = new SwitchLabel ((Expression) $2, GetLocation ($1));
 	 	lbag.AddLocation ($$, GetLocation ($3));
 	 }
 	| DEFAULT_COLON
 	  {
 		$$ = new SwitchLabel (null, GetLocation ($1));
 	  }
 	;
 
 iteration_statement
 	
 	| do_statement
 	| for_statement
 	| foreach_statement
 	;
 
 while_statement
 	
 	  {
 		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($5));
 	  
 		$$ = new While ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 do_statement
 	
 	  WHILE open_parens_any boolean_expression CLOSE_PARENS SEMICOLON
 	  {
 		$$ = new Do ((Statement) $2, (BooleanExpression) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3), GetLocation ($4), GetLocation ($6), GetLocation ($7));
 	  }
 	;
 
 for_statement
 	
 	  {
 		start_block (GetLocation ($2));
 		current_block.IsCompilerGenerated = true;
 	  }
 	  for_statement_cont
 	  {
 		$$ = $4;
 	  }
 	;
 	
 // Has to use be extra rule to recover started block
 for_statement_cont
 	
 	  opt_for_condition SEMICOLON
 	  opt_for_iterator CLOSE_PARENS
 	  embedded_statement
 	  {
 		if ($7 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($7));
 	  
 		For f = new For ((Statement) $1, (BooleanExpression) $3, (Statement) $5, (Statement) $7, GetLocation ($-2));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation ($2), GetLocation ($4), GetLocation ($6));
 
 		$$ = end_block (GetLocation ($2));
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = end_block (current_block.StartLocation);
 	  }
 	;
 
 opt_for_initializer
 	
 	| for_initializer	
 	;
 
 for_initializer
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) $1, li);
 	  }
 	  opt_local_variable_initializer opt_variable_declarators
 	  {
 		$$ = current_variable;
 		current_variable = null;
 	  }
 	| statement_expression_list
 	;
 
 opt_for_condition
 	
 	| boolean_expression
 	;
 
 opt_for_iterator
 	
 	| for_iterator
 	;
 
 for_iterator
 	
 	;
 
 statement_expression_list
 	
 	| statement_expression_list COMMA statement_expression
 	  {
 	  	var sl = $1 as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) $1, (Statement) $3);
 			lbag.AddStatement (sl, GetLocation ($2));
 	  	} else {
 	  		sl.Add ((Statement) $3);
 	  		lbag.AppendTo (sl, GetLocation ($2));
 	  	}
 	  		
 		$$ = sl;
 	  }
 	;
 
 foreach_statement
 	
 	  {
 		Report.Error (230, GetLocation ($1), "Type and identifier are both required in a foreach statement");
 		$$ = null;
 	  }
 	| FOREACH open_parens_any type IDENTIFIER IN expression CLOSE_PARENS 
 	  {
 		start_block (GetLocation ($2));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) $4;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		$$ = li;
 	  } 
 	  embedded_statement
 	  {
 		if ($9 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($9));
 	  
 		Foreach f = new Foreach ((Expression) $3, (LocalVariable) $8, (Expression) $6, (Statement) $9, GetLocation ($1));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation ($2), GetLocation ($5), GetLocation ($7));
 		$$ = end_block (GetLocation ($7));
 	  }
 	;
 
 jump_statement
 	
 	| continue_statement
 	| goto_statement
 	| return_statement
 	| throw_statement
 	| yield_statement
 	;
 
 break_statement
 	
 	  {
 		$$ = new Break (GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2));
 	  }
 	;
 
 continue_statement
 	
 	  {
 		$$ = new Continue (GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2));
 	  }
 	;
 
 goto_statement
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	| GOTO CASE constant_expression SEMICOLON
 	  {
 		$$ = new GotoCase ((Expression) $3, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| GOTO DEFAULT SEMICOLON 
 	  {
 		$$ = new GotoDefault (GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
 	  }
 	; 
 
 return_statement
 	
 	  {
 		$$ = new Return ((Expression) $2, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3));
 	  }
 	;
 
 throw_statement
 	
 	  {
 		$$ = new Throw ((Expression) $2, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3));
 	  }
 	;
 
 yield_statement 
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if ($3 == null) {
 			Report.Error (1627, GetLocation ($4), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		$$ = new Yield ((Expression) $3, lt.Location);
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| IDENTIFIER BREAK SEMICOLON
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		$$ = new YieldBreak (lt.Location);
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
 	  }
 	;
 
 opt_expression
 	
 	| expression
 	;
 
 try_statement
 	
 	  {
 		$$ = new TryCatch ((Block) $2, (List<Catch>) $3, GetLocation ($1), false);
 	  }
 	| TRY block FINALLY block
 	  {
 		$$ = new TryFinally ((Statement) $2, (Block) $4, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3));
 	  }
 	| TRY block catch_clauses FINALLY block
 	  {
 		$$ = new TryFinally (new TryCatch ((Block) $2, (List<Catch>) $3, GetLocation ($1), true), (Block) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($4));
 	  }
 	| TRY block error 
 	  {
 		Report.Error (1524, GetLocation ($1), "Expected catch or finally");
 		$$ = null;
 	  }
 	;
 
 catch_clauses
 	
 	  {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) $1);
 		$$ = l;
 	  }
 	| catch_clauses catch_clause
 	  {
 		var l = (List<Catch>) $1;
 		
 		Catch c = (Catch) $2;
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		$$ = l;
 	  }
 	;
 
 opt_identifier
 	
 	| IDENTIFIER
 	;
 
 catch_clause 
 	
 	  {
 		$$ = new Catch ((Block) $2, GetLocation ($1));
 	  }
 	| CATCH open_parens_any type opt_identifier CLOSE_PARENS
 	  {
 		start_block (GetLocation ($2));
 		var c = new Catch (current_block, GetLocation ($1));
 		c.TypeExpression = (FullNamedExpression) $3;
 
 		if ($4 != null) {
 			var lt = (Tokenizer.LocatedToken) $4;
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation ($2), GetLocation ($5));
 		$$ = c;
 	  }
 	  block_prepared
 	  {
 		$$ = $6;
 	  }
 	| CATCH open_parens_any error
 	  {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		$$ = new Catch (null, GetLocation ($1));
 	  }
 	;
 
 checked_statement
 	
 	  {
 		$$ = new Checked ((Block) $2, GetLocation ($1));
 	  }
 	;
 
 unchecked_statement
 	
 	  {
 		$$ = new Unchecked ((Block) $2, GetLocation ($1));
 	  }
 	;
 
 unsafe_statement
 	
 	  {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation ($1));
 	  } block {
 		$$ = new Unsafe ((Block) $3, GetLocation ($1));
 	  } block {
 		$$ = new Unsafe ((Block) $3, GetLocation ($1));
 	  }
 	;
 
 lock_statement
 	
 	  {
 		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($5));
 	  
 		$$ = new Lock ((Expression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 fixed_statement
 	
 	  {
 	    start_block (GetLocation ($2));
 	    
 		var lt = (Tokenizer.LocatedToken) $4;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) $3, li);
 	  }
 	  using_or_fixed_variable_initializer opt_variable_declarators CLOSE_PARENS
 	  {
 		$$ = current_variable;
 		current_variable = null;
 	  }
 	  embedded_statement
 	  {
 		if ($10 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($10));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) $9, (Statement) $10, GetLocation ($1));
 		current_block.AddStatement (f);
 		$$ = end_block (GetLocation ($8));
 	  }
 	;
 
 using_statement
 	
 	  {
 	    start_block (GetLocation ($2));
 	    
 		var lt = (Tokenizer.LocatedToken) $4;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) $3, li);
 	  }
 	  using_or_fixed_variable_initializer opt_variable_declarators CLOSE_PARENS
 	  {
 		$$ = current_variable;	  
 		current_variable = null;
 	  }
 	  embedded_statement
 	  {
 		if ($10 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($10));
 	  
 		Using u = new Using ((Using.VariableDeclaration) $9, (Statement) $10, GetLocation ($1));
 		current_block.AddStatement (u);
 		$$ = end_block (GetLocation ($8));
 	  }
 	| USING open_parens_any expression CLOSE_PARENS embedded_statement
 	  {
 		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($5));
 	  
 		Using u = new Using ((Expression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement (u, GetLocation ($2), GetLocation ($4));
 		$$ = u;
 	  }
 	;
 	
 using_or_fixed_variable_initializer
 	
 	  {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
 	| ASSIGN variable_initializer
 	  {
 		current_variable.Initializer = (Expression) $2;
 		$$ = current_variable;
 	  }
 	;
 
 
 // LINQ
 
 query_expression
 	
 	  {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = $1 as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)$2;
 		$$ = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	| nested_from_clause query_body
 	  {
 		Linq.AQueryClause from = $1 as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)$2;
 		$$ = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }	
 
 	// Bubble up COMPLETE_COMPLETION productions
 	| first_from_clause COMPLETE_COMPLETION {
 	        lexer.query_parsing = false;
 		$$ = $1;
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	| nested_from_clause COMPLETE_COMPLETION {
 	        $$ = $1;
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	;
 	
 first_from_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
 	  }
 	| FROM_FIRST type IDENTIFIER IN expression
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $3;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
 				IdentifierType = (FullNamedExpression)$2
 			}
 		);
 	  }
 	;
 
 nested_from_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
 	  }
 	| FROM type IDENTIFIER IN expression
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $3;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
 				IdentifierType = (FullNamedExpression)$2
 			}
 		);
 	  }
 	;
 	
 from_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$5, GetLocation ($1));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }	  
 	| FROM type IDENTIFIER IN
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$6, GetLocation ($1)) {
 			IdentifierType = (FullNamedExpression)$2
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
 	;	
 
 query_body
 	
 	  {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)$2;
 		
 		if ($3 != null)
 			head.Next = (Linq.AQueryClause)$3;
 				
 		if ($1 != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)$1;
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		$$ = head;
 	  }
 	| opt_query_body_clauses COMPLETE_COMPLETION
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 	
 select_or_group_clause
 	
 	  {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		$$ = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	| GROUP
 	  {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
 	  expression
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  BY expression
 	  {
 		$$ = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)$3, linq_clause_blocks.Pop (), (Expression)$6, GetLocation ($1));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	;
 	
 opt_query_body_clauses
 	
 	| query_body_clauses
 	;
 	
 query_body_clauses
 	
 	| query_body_clauses query_body_clause
 	  {
 		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$2;
 		$$ = $1;
 	  }
 	;
 	
 query_body_clause
 	
 	| let_clause 
 	| where_clause
 	| join_clause
 	| orderby_clause
 	;
 	
 let_clause
 	
 	  {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	$$ = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)$5, GetLocation ($1));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
 	;
 
 where_clause
 	
 	  {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		$$ = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	;
 	
 join_clause
 	
 	  {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression ON
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression EQUALS
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $8));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression opt_join_into
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $11));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) $2;	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if ($12 == null) {
 			into = sn;
 	  		$$ = new Linq.Join (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1));
 		} else {
 			//
 			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
 			//
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) $12;
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			$$ = new Linq.GroupJoin (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
 	| JOIN type IDENTIFIER IN
 	  {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression ON
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression EQUALS
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $9));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression opt_join_into
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $12));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) $3;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if ($13 == null) {
 			into = sn;		
 	  		$$ = new Linq.Join (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1)) {
 	  			IdentifierType = (FullNamedExpression)$2
 	  		};
 		} else {
 			//
 			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
 			//
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) $13;
 			into = new Linq.RangeVariable (lt.Value, lt.Location); // TODO
 			
 			$$ = new Linq.GroupJoin (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1)) {
 	  			IdentifierType = (FullNamedExpression)$2
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
 	;
 	
 opt_join_into
 	
 	| INTO IDENTIFIER
 	  {
 		$$ = $2;
 	  }
 	;
 	
 orderby_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  orderings
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		$$ = $3;
 	  }
 	;
 	
 orderings
 	
 	| order_by COMMA
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  orderings_then_by
 	  {
 		((Linq.AQueryClause)$1).Next = (Linq.AQueryClause)$4;
 		$$ = $1;
 	  }
 	;
 	
 orderings_then_by
 	
 	| orderings_then_by COMMA
 	 {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
 	 then_by
 	 {
 		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$4;
 		$$ = $1;
 	 }
 	;	
 	
 order_by
 	
 	  {
 		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression ASCENDING
 	  {
 		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression DESCENDING
 	  {
 		$$ = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	;
 
 then_by
 	
 	  {
 		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression ASCENDING
 	  {
 		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression DESCENDING
 	  {
 		$$ = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }	
 	;
 
 
 opt_query_continuation
 	
 	| INTO IDENTIFIER
 	  {
 		// query continuation block is not linked with query block but with block
 		// before. This means each query can use same range variable names for
 		// different identifiers.
 
 		current_block.SetEndLocation (GetLocation ($1));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
 	  query_body
 	  {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		$$ = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation ($1)) {
   			next = (Linq.AQueryClause)$4
   		};
 	  }
 	;
 	
 //
 // Support for using the compiler as an interactive parser
 //
 // The INTERACTIVE_PARSER token is first sent to parse our
 // productions;  If the result is a Statement, the parsing
 // is repeated, this time with INTERACTIVE_PARSE_WITH_BLOCK
 // to setup the blocks in advance.
 //
 // This setup is here so that in the future we can add 
 // support for other constructs (type parsing, namespaces, etc)
 // that do not require a block to be setup in advance
 //
 
 interactive_parsing
 	
 	| EVAL_USING_DECLARATIONS_UNIT_PARSER using_directives opt_COMPLETE_COMPLETION
 	| EVAL_STATEMENT_PARSER { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		// (ref object retval)
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, // generic
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }		
 	  interactive_statement_list opt_COMPLETE_COMPLETION
 	  {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  } 
 	| EVAL_COMPILATION_UNIT_PARSER {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
 	  interactive_compilation_unit
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 case 5
 #line 375 "cs-parser.jay"
   { Lexer.CompleteOnEOF = false; }
   break;
 case 7
 #line 380 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 8
 #line 384 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 16
 #line 407 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop]; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
   break;
 case 17
 #line 420 "cs-parser.jay"
   {
 	  	syntax_error (GetLocation (yyVals[-1+yyTop]), "`alias' expected");   /* TODO
 	  }
   break;
 case 20
 #line 432 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 21
 #line 437 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 22
 #line 445 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 23
 #line 450 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 24
 #line 458 "cs-parser.jay"
   {
 		current_namespace.AddUsing ((MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 25
 #line 470 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (yyVals[-2+yyTop] != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 26
 #line 483 "cs-parser.jay"
   { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 27
 #line 492 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName (lt.Value, lt.Location);
 	  }
   break;
 case 28
 #line 497 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 29
 #line 502 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new MemberName ("<invalid>", lexer.Location);
 	  }
   break;
 case 34
 #line 520 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		yyVal = name;
 	  }
   break;
 case 35
 #line 532 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 45
 #line 564 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			DeclSpace ds = (DeclSpace)yyVals[0+yyTop];
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 46
 #line 576 "cs-parser.jay"
   {
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 47
 #line 580 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	 }
   break;
 case 53
 #line 606 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			Attributes attrs = (Attributes)yyVals[0+yyTop];
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 54
 #line 623 "cs-parser.jay"
   {
 		global_attrs_enabled = false;
 		yyVal = null;
       }
   break;
 case 55
 #line 628 "cs-parser.jay"
   { 
 		global_attrs_enabled = false;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 56
 #line 637 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					yyVal = null;
 				} else {
 					yyVal = new Attributes (sect);
 				}
 				if (yyVal == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				yyVal = new Attributes (sect);
 			}		
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 57
 #line 664 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = yyVals[-1+yyTop] as Attributes;
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					yyVal = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			yyVal = attrs;
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 58
 #line 695 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
  	  }
   break;
 case 59
 #line 699 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 60
 #line 706 "cs-parser.jay"
   {
 		current_attr_target = (string)yyVals[-1+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 61
 #line 714 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
   break;
 case 62
 #line 718 "cs-parser.jay"
   { yyVal = "event"; }
   break;
 case 63
 #line 719 "cs-parser.jay"
   { yyVal = "return"; }
   break;
 case 64
 #line 721 "cs-parser.jay"
   {
 		string name = GetTokenName (yyToken);
 		yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 65
 #line 729 "cs-parser.jay"
   {
 		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
 	  }
   break;
 case 66
 #line 733 "cs-parser.jay"
   {
 		var attrs = (List<Attribute>) yyVals[-2+yyTop];
 		attrs.Add ((Attribute) yyVals[0+yyTop]);
 
 		yyVal = attrs;
 	  }
   break;
 case 67
 #line 743 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 68
 #line 747 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) yyVals[-2+yyTop];
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) yyVals[0+yyTop];
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			yyVal = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			/* FIXME
 			yyVal = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			yyVal = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
   break;
 case 69
 #line 770 "cs-parser.jay"
   { /* reserved attribute name or identifier
   break;
 case 70
 #line 774 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 71
 #line 776 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 72
 #line 783 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 73
 #line 785 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = new Arguments [] { a, null };
 	  }
   break;
 case 74
 #line 791 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);  
 		yyVal = new Arguments [] { null, a };
 	  }
   break;
 case 75
 #line 797 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 76
 #line 811 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 77
 #line 823 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 79
 #line 831 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 80
 #line 835 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
 	  }
   break;
 case 81
 #line 844 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
 			
 		/* Avoid boxing in common case (no modifier)*/
 		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
 	  }
   break;
 case 82
 #line 857 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 83
 #line 859 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Ref;
 	  }
   break;
 case 84
 #line 863 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Out;
 	  }
   break;
 case 99
 #line 891 "cs-parser.jay"
   {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		yyVal = null;
 		lexer.parsing_generic_declaration = false;
 	  }
   break;
 case 100
 #line 904 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 101
 #line 908 "cs-parser.jay"
   { 
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 102
 #line 914 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 103
 #line 925 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 104
 #line 931 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 105
 #line 936 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	  }
   break;
 case 106
 #line 943 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 107
 #line 948 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 122
 #line 985 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var mod = (Modifiers) yyVals[-3+yyTop];
 		current_field = new Const (current_class, (FullNamedExpression) yyVals[-1+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_field;
 	  }
   break;
 case 123
 #line 998 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_field = null;
 	  }
   break;
 case 126
 #line 1017 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 127
 #line 1021 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 128
 #line 1028 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 129
 #line 1037 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 130
 #line 1041 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 131
 #line 1046 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		yyVal = null;
 	  }
   break;
 case 134
 #line 1061 "cs-parser.jay"
   {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) yyVals[-1+yyTop];
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation (yyVals[-1+yyTop]), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new Field (current_class, type, (Modifiers) yyVals[-2+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-3+yyTop]);
 		current_container.AddField (current_field);
 		yyVal = current_field;
 	  }
   break;
 case 135
 #line 1076 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 		current_field = null;
 	  }
   break;
 case 136
 #line 1089 "cs-parser.jay"
   { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new FixedField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop],
 			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 			
 		current_container.AddField (current_field);
 	  }
   break;
 case 137
 #line 1100 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 	    current_field = null;
 	  }
   break;
 case 138
 #line 1115 "cs-parser.jay"
   {
 		Report.Error (1641, GetLocation (yyVals[-1+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
   break;
 case 140
 #line 1123 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 141
 #line 1129 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) yyVals[0+yyTop];
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
   break;
 case 144
 #line 1144 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 145
 #line 1148 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 146
 #line 1155 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 147
 #line 1161 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 148
 #line 1165 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 151
 #line 1180 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 152
 #line 1184 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 153
 #line 1191 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	  
 		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 154
 #line 1200 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 155
 #line 1204 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 156
 #line 1210 "cs-parser.jay"
   {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		yyVal = null;
 	  }
   break;
 case 159
 #line 1220 "cs-parser.jay"
   {
 		/* It has to be here for the parent to safely restore artificial block*/
 	  	Error_SyntaxError (yyToken);
 	  	yyVal = null;
 	  }
   break;
 case 160
 #line 1228 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 161
 #line 1233 "cs-parser.jay"
   {
 		Method method = (Method) yyVals[-2+yyTop];
 		method.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 162
 #line 1254 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 163
 #line 1258 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 164
 #line 1262 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) yyVals[-7+yyTop], current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		} else if (yyVals[0+yyTop] != null) {
 			Report.Error (80, GetLocation (yyVals[0+yyTop]),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) yyVals[-7+yyTop], (Modifiers) yyVals[-8+yyTop],
 				     name, current_local_parameters, (Attributes) yyVals[-9+yyTop]);
 				     
 		if (yyVals[0+yyTop] != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 165
 #line 1299 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 166
 #line 1303 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 167
 #line 1307 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		if (yyVals[-1+yyTop] != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		}
 
 		var modifiers = (Modifiers) yyVals[-9+yyTop];
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				     modifiers, name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		/* TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-8+yyTop]));
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 168
 #line 1362 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-4+yyTop]));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) yyVals[-5+yyTop],
 					    0, name, (ParametersCompiled) yyVals[-1+yyTop], (Attributes) yyVals[-7+yyTop]);
 
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		yyVal = method;
 	  }
   break;
 case 170
 #line 1381 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 171
 #line 1385 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 173
 #line 1391 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 174
 #line 1396 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
   break;
 case 175
 #line 1403 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[0+yyTop])));
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 176
 #line 1409 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
 	  }
   break;
 case 177
 #line 1416 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 178
 #line 1426 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[-2+yyTop])) }, true);
 	  }
   break;
 case 179
 #line 1432 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 180
 #line 1441 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
 	  }
   break;
 case 181
 #line 1445 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[0+yyTop])) }, true);
 	  }
   break;
 case 182
 #line 1449 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 183
 #line 1457 "cs-parser.jay"
   {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		yyVal = parameters_bucket;
 	  }
   break;
 case 184
 #line 1466 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation (yyVals[-1+yyTop]));
 		}
 		
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 185
 #line 1490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 186
 #line 1498 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Parameter.Modifier) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop], lt.Location);
 	  }
   break;
 case 187
 #line 1507 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation (yyVals[0+yyTop]);
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], "NeedSomeGeneratorHere", (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], l);
 	  }
   break;
 case 188
 #line 1517 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 189
 #line 1521 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-5+yyTop];
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-4+yyTop], lt.Value, mod, (Attributes) yyVals[-6+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 		
 		if (yyVals[0+yyTop] != null)
 			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 190
 #line 1560 "cs-parser.jay"
   { yyVal = Parameter.Modifier.NONE; }
   break;
 case 192
 #line 1566 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 193
 #line 1570 "cs-parser.jay"
   {
 		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
   		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
   		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		yyVal = mod;
 	  }
   break;
 case 194
 #line 1594 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
 	  		
 	  	yyVal = Parameter.Modifier.REF;
 	  }
   break;
 case 195
 #line 1601 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
 	  
 	  	yyVal = Parameter.Modifier.OUT;
 	  }
   break;
 case 196
 #line 1608 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
 	  			
 		yyVal = Parameter.Modifier.This;
 	  }
   break;
 case 197
 #line 1621 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 198
 #line 1626 "cs-parser.jay"
   {
 		Report.Error (1751, GetLocation (yyVals[-4+yyTop]), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Attributes) yyVals[-5+yyTop], lt.Location);		
 	  }
   break;
 case 199
 #line 1633 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 200
 #line 1641 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation (yyVals[0+yyTop])), "The `params' modifier is not allowed in current context");
 	  }
   break;
 case 201
 #line 1646 "cs-parser.jay"
   {
 		Parameter.Modifier mod = (Parameter.Modifier)yyVals[0+yyTop];
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation (yyVals[-1+yyTop]), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation (yyVals[-1+yyTop]), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
   break;
 case 202
 #line 1655 "cs-parser.jay"
   {
 		Error_DuplicateParameterModifier (GetLocation (yyVals[-1+yyTop]), Parameter.Modifier.PARAMS);
 	  }
   break;
 case 203
 #line 1662 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation (yyVals[0+yyTop]), "__arglist is not valid in this context");
 	  }
   break;
 case 204
 #line 1673 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 205
 #line 1678 "cs-parser.jay"
   {
 		current_property = new Property (current_class, (FullNamedExpression) yyVals[-3+yyTop], (Modifiers) yyVals[-4+yyTop],
 			(MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation (yyVals[-3+yyTop]), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[0+yyTop]));
 		
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 206
 #line 1691 "cs-parser.jay"
   {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
   break;
 case 207
 #line 1698 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
 		current_property = null;
 	  }
   break;
 case 208
 #line 1708 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 209
 #line 1712 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) yyVals[-6+yyTop],
 			(MemberName)yyVals[-5+yyTop], (Modifiers) yyVals[-7+yyTop], (ParametersCompiled) yyVals[-2+yyTop], (Attributes) yyVals[-8+yyTop]);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation (yyVals[-6+yyTop]), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation (yyVals[-4+yyTop]), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 210
 #line 1738 "cs-parser.jay"
   {
 		  lexer.PropertyParsing = false;
 	  }
   break;
 case 211
 #line 1742 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation (yyVals[-1+yyTop]));
 		current_property = null;		
 	  }
   break;
 case 216
 #line 1758 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
 		}
 	  }
   break;
 case 217
 #line 1772 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 218
 #line 1794 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] != null) {
 	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 219
 #line 1815 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
 					null),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 220
 #line 1842 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {		
 			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 222
 #line 1864 "cs-parser.jay"
   {
 		/* TODO
 	  	yyVal = null;
 	  }
   break;
 case 223
 #line 1869 "cs-parser.jay"
   {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	yyVal = null;
 	  }
   break;
 case 224
 #line 1880 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 225
 #line 1884 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 226
 #line 1891 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 227
 #line 1902 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 228
 #line 1908 "cs-parser.jay"
   {
 	    lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 229
 #line 1913 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  }
   break;
 case 234
 #line 1930 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 235
 #line 1934 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 240
 #line 1942 "cs-parser.jay"
   {
 	  	Report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
 	  }
   break;
 case 241
 #line 1946 "cs-parser.jay"
   {
 	  	Report.Error (526, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain contructors");
 	  }
   break;
 case 242
 #line 1950 "cs-parser.jay"
   {
 	  	Report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
   break;
 case 243
 #line 1957 "cs-parser.jay"
   {
 	  }
   break;
 case 244
 #line 1960 "cs-parser.jay"
   {
 		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) yyVals[-3+yyTop], 
 				current_local_parameters,
 				(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			/* Note again, checking is done in semantic analysis*/
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 246
 #line 1985 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 248
 #line 1991 "cs-parser.jay"
   {
 		Report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 249
 #line 1999 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 250
 #line 2003 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		Operator.OpType op = (Operator.OpType) yyVals[-4+yyTop];
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[-6+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 252
 #line 2047 "cs-parser.jay"
   { yyVal = Operator.OpType.LogicalNot; }
   break;
 case 253
 #line 2048 "cs-parser.jay"
   { yyVal = Operator.OpType.OnesComplement; }
   break;
 case 254
 #line 2049 "cs-parser.jay"
   { yyVal = Operator.OpType.Increment; }
   break;
 case 255
 #line 2050 "cs-parser.jay"
   { yyVal = Operator.OpType.Decrement; }
   break;
 case 256
 #line 2051 "cs-parser.jay"
   { yyVal = Operator.OpType.True; }
   break;
 case 257
 #line 2052 "cs-parser.jay"
   { yyVal = Operator.OpType.False; }
   break;
 case 258
 #line 2054 "cs-parser.jay"
   { yyVal = Operator.OpType.Addition; }
   break;
 case 259
 #line 2055 "cs-parser.jay"
   { yyVal = Operator.OpType.Subtraction; }
   break;
 case 260
 #line 2057 "cs-parser.jay"
   { yyVal = Operator.OpType.Multiply; }
   break;
 case 261
 #line 2058 "cs-parser.jay"
   {  yyVal = Operator.OpType.Division; }
   break;
 case 262
 #line 2059 "cs-parser.jay"
   { yyVal = Operator.OpType.Modulus; }
   break;
 case 263
 #line 2060 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseAnd; }
   break;
 case 264
 #line 2061 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseOr; }
   break;
 case 265
 #line 2062 "cs-parser.jay"
   { yyVal = Operator.OpType.ExclusiveOr; }
   break;
 case 266
 #line 2063 "cs-parser.jay"
   { yyVal = Operator.OpType.LeftShift; }
   break;
 case 267
 #line 2064 "cs-parser.jay"
   { yyVal = Operator.OpType.RightShift; }
   break;
 case 268
 #line 2065 "cs-parser.jay"
   { yyVal = Operator.OpType.Equality; }
   break;
 case 269
 #line 2066 "cs-parser.jay"
   { yyVal = Operator.OpType.Inequality; }
   break;
 case 270
 #line 2067 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThan; }
   break;
 case 271
 #line 2068 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThan; }
   break;
 case 272
 #line 2069 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThanOrEqual; }
   break;
 case 273
 #line 2070 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThanOrEqual; }
   break;
 case 274
 #line 2075 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 275
 #line 2079 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 276
 #line 2094 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 277
 #line 2098 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 278
 #line 2113 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 279
 #line 2119 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 280
 #line 2129 "cs-parser.jay"
   { 
 		Constructor c = (Constructor) yyVals[-1+yyTop];
 		c.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 281
 #line 2148 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 282
 #line 2157 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];  
 		
 		/**/
 		/* start block here, so possible anonymous methods inside*/
 		/* constructor initializer can get correct parent block*/
 		/**/
 	  	start_block (lexer.Location);
 	  }
   break;
 case 283
 #line 2168 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-6+yyTop];
 		var mods = (Modifiers) yyVals[-7+yyTop];
 		ConstructorInitializer ci = (ConstructorInitializer) yyVals[0+yyTop];
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) yyVals[-8+yyTop], current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 285
 #line 2199 "cs-parser.jay"
   { current_block = null; yyVal = null; }
   break;
 case 288
 #line 2209 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 289
 #line 2213 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 290
 #line 2219 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 291
 #line 2223 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorThisInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 292
 #line 2229 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 293
 #line 2237 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 294
 #line 2246 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) yyVals[-6+yyTop],
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-7+yyTop], lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		current_local_parameters = null;
 	  }
   break;
 case 295
 #line 2271 "cs-parser.jay"
   {
 		current_event_field = new EventField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop], (MemberName) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop]);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_event_field;
 	  }
   break;
 case 296
 #line 2285 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_event_field = null;
 	  }
   break;
 case 297
 #line 2298 "cs-parser.jay"
   {
 		current_event = new EventProperty (current_class, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-1+yyTop], (Attributes) yyVals[-5+yyTop]);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		
 		lexer.EventParsing = true;
 	  }
   break;
 case 298
 #line 2306 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
   break;
 case 299
 #line 2313 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
   break;
 case 301
 #line 2328 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 302
 #line 2332 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 305
 #line 2345 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 306
 #line 2349 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 307
 #line 2356 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 308
 #line 2362 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 309
 #line 2366 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 310
 #line 2375 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
   break;
 case 311
 #line 2387 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 314
 #line 2396 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 315
 #line 2401 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 316
 #line 2406 "cs-parser.jay"
   { 
 		Report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
 		yyVal = null;
 	  }
   break;
 case 317
 #line 2414 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 318
 #line 2426 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 319
 #line 2442 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 320
 #line 2454 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 321
 #line 2470 "cs-parser.jay"
   {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		yyVal = null;
 	  }
   break;
 case 323
 #line 2482 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 324
 #line 2487 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], MakeName (name), (Attributes) yyVals[-6+yyTop]), null);
 	  }
   break;
 case 325
 #line 2499 "cs-parser.jay"
   {
 	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 326
 #line 2505 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 /*			if (RootContext.Documentation != null)*/
 /*				em.DocComment = ev.DocComment;*/
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 328
 #line 2522 "cs-parser.jay"
   {
 	 	var te = yyVals[0+yyTop] as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), Report);
 			yyVal = null;
 		} else {
 			yyVal = yyVals[0+yyTop];
 		}
 	 }
   break;
 case 329
 #line 2536 "cs-parser.jay"
   {
 	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
 		yyVal = null;
 	 }
   break;
 case 332
 #line 2546 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 334
 #line 2554 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 335
 #line 2562 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		yyVal = em;
 	  }
   break;
 case 336
 #line 2575 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
   break;
 case 337
 #line 2583 "cs-parser.jay"
   { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		yyVal = em;
 	  }
   break;
 case 338
 #line 2604 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 339
 #line 2608 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) yyVals[-4+yyTop]);
 		ParametersCompiled p = (ParametersCompiled) yyVals[-1+yyTop];
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) yyVals[-5+yyTop],
 					     (Modifiers) yyVals[-7+yyTop], name, p, (Attributes) yyVals[-8+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 340
 #line 2627 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 	  }
   break;
 case 341
 #line 2631 "cs-parser.jay"
   {
 		current_delegate.SetParameterInfo ((List<Constraints>) yyVals[-2+yyTop]);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation (yyVals[-10+yyTop]), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
 
 		yyVal = current_delegate;
 
 		current_delegate = null;
 	  }
   break;
 case 343
 #line 2644 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
 	  
 	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 345
 #line 2655 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 347
 #line 2666 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 348
 #line 2675 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 350
 #line 2687 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
 	  
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 351
 #line 2694 "cs-parser.jay"
   {
 		Error_TypeExpected (lexer.Location);
 		yyVal = new TypeArguments ();
 	  }
   break;
 case 352
 #line 2702 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 353
 #line 2708 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 354
 #line 2720 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 355
 #line 2724 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 356
 #line 2733 "cs-parser.jay"
   {
 	  	MemberName mn = (MemberName)yyVals[0+yyTop];
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
   break;
 case 358
 #line 2744 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 359
 #line 2753 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		yyVal = new MemberName (TypeContainer.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 360
 #line 2758 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		yyVal = new MemberName ((MemberName) yyVals[-1+yyTop], TypeContainer.DefaultIndexerName, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 361
 #line 2766 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 362
 #line 2772 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[-1+yyTop], lt1.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 363
 #line 2780 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 365
 #line 2790 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
 	  
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 366
 #line 2801 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 367
 #line 2807 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 368
 #line 2817 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 		yyVal = new TypeParameterName (lt.Value, (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop], lt.Location);
   	  }
   break;
 case 369
 #line 2822 "cs-parser.jay"
   {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	yyVal = new TypeParameterName ("", null, lexer.Location);
   	  }
   break;
 case 371
 #line 2838 "cs-parser.jay"
   {
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 372
 #line 2845 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 374
 #line 2856 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 376
 #line 2865 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 378
 #line 2874 "cs-parser.jay"
   {
 	  	Report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 380
 #line 2883 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 381
 #line 2890 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-1+yyTop];
 
 		if (yyVals[0+yyTop] != null) {
 			yyVal = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				yyVal = new VarExpr (name.Location);
 			else
 				yyVal = name.GetTypeExpression ();
 		}
 	  }
   break;
 case 382
 #line 2903 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (((MemberName) yyVals[-1+yyTop]).GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 383
 #line 2907 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null)
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 384
 #line 2912 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 385
 #line 2916 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 386
 #line 2923 "cs-parser.jay"
   {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 387
 #line 2929 "cs-parser.jay"
   {
 		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 388
 #line 2938 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast) {
 			Report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 389
 #line 2945 "cs-parser.jay"
   {
 	  	Error_TypeExpected (lexer.Location);
 		yyVal = null;
 	  }
   break;
 case 390
 #line 2956 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.object_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 391
 #line 2957 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.string_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 392
 #line 2958 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.bool_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 393
 #line 2959 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.decimal_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 394
 #line 2960 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.float_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 395
 #line 2961 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.double_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 397
 #line 2966 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.sbyte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 398
 #line 2967 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.byte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 399
 #line 2968 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.short_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 400
 #line 2969 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.ushort_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 401
 #line 2970 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 402
 #line 2971 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 403
 #line 2972 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 404
 #line 2973 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 405
 #line 2974 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.char_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 425
 #line 3006 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 426
 #line 3010 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
   break;
 case 430
 #line 3020 "cs-parser.jay"
   { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
   break;
 case 431
 #line 3024 "cs-parser.jay"
   { yyVal = new BoolLiteral (true, GetLocation (yyVals[0+yyTop])); }
   break;
 case 432
 #line 3025 "cs-parser.jay"
   { yyVal = new BoolLiteral (false, GetLocation (yyVals[0+yyTop])); }
   break;
 case 437
 #line 3051 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 438
 #line 3056 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 	  }
   break;
 case 439
 #line 3063 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 440
 #line 3069 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 441
 #line 3075 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 442
 #line 3081 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 443
 #line 3087 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 444
 #line 3090 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
 	  }
   break;
 case 445
 #line 3095 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
 	  }
   break;
 case 446
 #line 3098 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
  	  }
   break;
 case 447
 #line 3106 "cs-parser.jay"
   {
 		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 448
 #line 3113 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 450
 #line 3119 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] == null) {
 	  		yyVal = CollectionOrObjectInitializers.Empty;
 	  		/* TODO
 	  	} else {
 	  		yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  	}
 	  }
   break;
 case 451
 #line 3129 "cs-parser.jay"
   {
 	  	yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 452
 #line 3136 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 453
 #line 3138 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	}
   break;
 case 454
 #line 3145 "cs-parser.jay"
   {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 455
 #line 3151 "cs-parser.jay"
   {
 	  	var a = (List<Expression>)yyVals[-2+yyTop];
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 456
 #line 3156 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 457
 #line 3164 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 458
 #line 3170 "cs-parser.jay"
   {
 		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 459
 #line 3173 "cs-parser.jay"
   {
 		CompletionSimpleName csn = yyVals[-1+yyTop] as CompletionSimpleName;
 		if (csn == null)
 			yyVal = new CollectionElementInitializer ((Expression)yyVals[-1+yyTop]);
 		else
 			yyVal = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
   break;
 case 460
 #line 3181 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] == null)
 			yyVal = null;
 		else
 	  		yyVal = new CollectionElementInitializer ((List<Expression>)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 461
 #line 3188 "cs-parser.jay"
   {
 	  	Report.Error (1920, GetLocation (yyVals[-1+yyTop]), "An element initializer cannot be empty");
 		yyVal = null;
 	  }
   break;
 case 464
 #line 3200 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 466
 #line 3206 "cs-parser.jay"
   { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 467
 #line 3212 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 468
 #line 3221 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		yyVal = list;
 	  }
   break;
 case 469
 #line 3235 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[0+yyTop]), "An argument is missing");
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 470
 #line 3240 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
 	  	yyVal = null;
 	  }
   break;
 case 471
 #line 3248 "cs-parser.jay"
   {
 		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 475
 #line 3261 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 476
 #line 3266 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 477
 #line 3271 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 478
 #line 3276 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist (GetLocation (yyVals[-2+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 480
 #line 3288 "cs-parser.jay"
   {
 		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 481
 #line 3296 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 482
 #line 3302 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 483
 #line 3307 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 484
 #line 3315 "cs-parser.jay"
   {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;
 	  }
   break;
 case 485
 #line 3321 "cs-parser.jay"
   {
 		Arguments args = (Arguments) yyVals[-2+yyTop];
 		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;	  
 	  }
   break;
 case 486
 #line 3333 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 488
 #line 3341 "cs-parser.jay"
   {
 		yyVal = new This (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 489
 #line 3348 "cs-parser.jay"
   {
 	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 490
 #line 3353 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 491
 #line 3361 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 492
 #line 3368 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 493
 #line 3375 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation (yyVals[-5+yyTop]), "object initializers");
 				
 			yyVal = new NewInitialize ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		} else {
 			yyVal = new New ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], GetLocation (yyVals[-5+yyTop]));
 		}
 		
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 494
 #line 3388 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "collection initializers");
 	  
 		yyVal = new NewInitialize ((FullNamedExpression) yyVals[-1+yyTop], null, (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 495
 #line 3400 "cs-parser.jay"
   {
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], (List<Expression>) yyVals[-3+yyTop],
 				new ComposedTypeSpecifier (((List<Expression>) yyVals[-3+yyTop]).Count, GetLocation (yyVals[-4+yyTop])) {
 	  				Next = (ComposedTypeSpecifier) yyVals[-1+yyTop]
 			  	}, (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 496
 #line 3408 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] == null)
 	  		Report.Error (1586, GetLocation (yyVals[-3+yyTop]), "Array creation must have array size or array initializer");
 
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-2+yyTop], (ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 497
 #line 3415 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "implicitly typed arrays");
 	  
 		yyVal = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 498
 #line 3422 "cs-parser.jay"
   {
 		Report.Error (178, GetLocation (yyVals[-1+yyTop]), "Invalid rank specifier, expecting `,' or `]'");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], null, GetLocation (yyVals[-6+yyTop]));
 	  }
   break;
 case 499
 #line 3427 "cs-parser.jay"
   {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 500
 #line 3434 "cs-parser.jay"
   {
 		++lexer.parsing_type;
 	  }
   break;
 case 501
 #line 3438 "cs-parser.jay"
   {
 		--lexer.parsing_type;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 502
 #line 3446 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "anonymous types");
 
 		yyVal = new NewAnonymousType ((List<AnonymousTypeParameter>) yyVals[-1+yyTop], current_container, GetLocation (yyVals[-3+yyTop]));
 		
 		/* TODO
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 505
 #line 3463 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 507
 #line 3469 "cs-parser.jay"
   {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 508
 #line 3475 "cs-parser.jay"
   {
 	  	var a = (List<AnonymousTypeParameter>) yyVals[-2+yyTop];
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 509
 #line 3484 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[-2+yyTop];
 	  	yyVal = new AnonymousTypeParameter ((Expression)yyVals[0+yyTop], lt.Value, lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 510
 #line 3490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
   break;
 case 511
 #line 3496 "cs-parser.jay"
   {
 	  	MemberAccess ma = (MemberAccess) yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
   break;
 case 512
 #line 3501 "cs-parser.jay"
   {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		yyVal = null;
 	  }
   break;
 case 516
 #line 3516 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 517
 #line 3524 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 518
 #line 3528 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 519
 #line 3535 "cs-parser.jay"
   {
 		yyVal = 2;
 	  }
   break;
 case 520
 #line 3539 "cs-parser.jay"
   {
 		yyVal = ((int) yyVals[-1+yyTop]) + 1;
 	  }
   break;
 case 521
 #line 3546 "cs-parser.jay"
   {
 		yyVal = null;
 	  }
   break;
 case 522
 #line 3550 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 523
 #line 3557 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 524
 #line 3564 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 525
 #line 3574 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 526
 #line 3580 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 527
 #line 3589 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = true;
 	  }
   break;
 case 528
 #line 3593 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = false;
 		yyVal = new TypeOf ((FullNamedExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 531
 #line 3604 "cs-parser.jay"
   {
 	 	Error_TypeExpected (lexer.Location);
 	 	yyVal = null;
 	 }
   break;
 case 532
 #line 3612 "cs-parser.jay"
   {  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 533
 #line 3618 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 534
 #line 3625 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 535
 #line 3631 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 536
 #line 3637 "cs-parser.jay"
   {
 		var te = ((MemberName) yyVals[-3+yyTop]).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (te, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 537
 #line 3649 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 538
 #line 3659 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		yyVal = lt;		
 	  }
   break;
 case 539
 #line 3670 "cs-parser.jay"
   { 
 		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 540
 #line 3678 "cs-parser.jay"
   {
 		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 541
 #line 3686 "cs-parser.jay"
   {
 		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 542
 #line 3694 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberAccess (new Indirection ((Expression) yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop])), lt.Value, lt.Location);
 	  }
   break;
 case 543
 #line 3702 "cs-parser.jay"
   {
 		start_anonymous (false, (ParametersCompiled) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 544
 #line 3706 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 	  }
   break;
 case 545
 #line 3713 "cs-parser.jay"
   {
 		yyVal = ParametersCompiled.Undefined;
 	  }
   break;
 case 547
 #line 3721 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 548
 #line 3725 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 549
 #line 3733 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
 
 		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 551
 #line 3745 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 552
 #line 3749 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 554
 #line 3757 "cs-parser.jay"
   {
 		yyVal = new Cast ((FullNamedExpression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 556
 #line 3770 "cs-parser.jay"
   { 
 	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 557
 #line 3774 "cs-parser.jay"
   { 
 		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 558
 #line 3778 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 559
 #line 3782 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 560
 #line 3786 "cs-parser.jay"
   {
 		yyVal = new Indirection ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 561
 #line 3790 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 563
 #line 3798 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Multiply, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 564
 #line 3803 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Division, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 565
 #line 3808 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Modulus, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 567
 #line 3817 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Addition, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 568
 #line 3822 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 569
 #line 3826 "cs-parser.jay"
   {
 	  	/* Shift/Reduce conflict*/
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
   	  }
   break;
 case 570
 #line 3831 "cs-parser.jay"
   {
 		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 571
 #line 3835 "cs-parser.jay"
   {
 		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 573
 #line 3843 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 574
 #line 3848 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.RightShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 576
 #line 3857 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 577
 #line 3862 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 578
 #line 3867 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 579
 #line 3872 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 581
 #line 3881 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Equality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 582
 #line 3886 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Inequality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 584
 #line 3895 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 586
 #line 3904 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 588
 #line 3913 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 590
 #line 3922 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 592
 #line 3931 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 594
 #line 3940 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
 			
 		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 596
 #line 3951 "cs-parser.jay"
   {
 		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 597
 #line 3959 "cs-parser.jay"
   {
 		yyVal = new SimpleAssign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 598
 #line 3963 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 599
 #line 3968 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 600
 #line 3973 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 601
 #line 3978 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 602
 #line 3983 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 603
 #line 3988 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 604
 #line 3993 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 605
 #line 3998 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 606
 #line 4003 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 607
 #line 4008 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 608
 #line 4016 "cs-parser.jay"
   {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = pars;
 	  }
   break;
 case 609
 #line 4023 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter)yyVals[0+yyTop];
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		yyVal = pars;
 	  }
   break;
 case 610
 #line 4037 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
 	  }
   break;
 case 611
 #line 4043 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
   break;
 case 612
 #line 4049 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
   break;
 case 613
 #line 4056 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 614
 #line 4057 "cs-parser.jay"
   { 
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 		yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 617
 #line 4069 "cs-parser.jay"
   {
 		start_block (lexer.Location);
 	  }
   break;
 case 618
 #line 4073 "cs-parser.jay"
   {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
 		yyVal = b;
 	  }
   break;
 case 620
 #line 4083 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	
 		yyVal = EmptyExpression.Null;
 	  }
   break;
 case 621
 #line 4091 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 622
 #line 4097 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 623
 #line 4102 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 624
 #line 4109 "cs-parser.jay"
   {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 625
 #line 4114 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 631
 #line 4130 "cs-parser.jay"
   {
 		yyVal = new ArglistAccess (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 633
 #line 4141 "cs-parser.jay"
   {
 		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 634
 #line 4154 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 635
 #line 4158 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 636
 #line 4164 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 637
 #line 4176 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 638
 #line 4182 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 639
 #line 4190 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 640
 #line 4192 "cs-parser.jay"
   { yyVal = yyVals[0+yyTop]; }
   break;
 case 641
 #line 4197 "cs-parser.jay"
   {
 	    mod_locations = null;
 		yyVal = ModifierNone;
 	  }
   break;
 case 644
 #line 4207 "cs-parser.jay"
   { 
 		var m1 = (Modifiers) yyVals[-1+yyTop];
 		var m2 = (Modifiers) yyVals[0+yyTop];
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		yyVal = m1 | m2;
 	  }
   break;
 case 645
 #line 4226 "cs-parser.jay"
   {
 		yyVal = Modifiers.NEW;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
 	  }
   break;
 case 646
 #line 4234 "cs-parser.jay"
   {
 		yyVal = Modifiers.PUBLIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 647
 #line 4239 "cs-parser.jay"
   {
 		yyVal = Modifiers.PROTECTED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 648
 #line 4244 "cs-parser.jay"
   {
 		yyVal = Modifiers.INTERNAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 649
 #line 4249 "cs-parser.jay"
   {
 		yyVal = Modifiers.PRIVATE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 650
 #line 4254 "cs-parser.jay"
   {
 		yyVal = Modifiers.ABSTRACT;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 651
 #line 4259 "cs-parser.jay"
   {
 		yyVal = Modifiers.SEALED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 652
 #line 4264 "cs-parser.jay"
   {
 		yyVal = Modifiers.STATIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 653
 #line 4269 "cs-parser.jay"
   {
 		yyVal = Modifiers.READONLY;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 654
 #line 4274 "cs-parser.jay"
   {
 		yyVal = Modifiers.VIRTUAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 655
 #line 4279 "cs-parser.jay"
   {
 		yyVal = Modifiers.OVERRIDE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 656
 #line 4284 "cs-parser.jay"
   {
 		yyVal = Modifiers.EXTERN;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 657
 #line 4289 "cs-parser.jay"
   {
 		yyVal = Modifiers.VOLATILE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 658
 #line 4294 "cs-parser.jay"
   {
 		yyVal = Modifiers.UNSAFE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 659
 #line 4301 "cs-parser.jay"
   {
 		yyVal = Modifiers.ASYNC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 661
 #line 4310 "cs-parser.jay"
   {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) yyVals[0+yyTop]);
 	 }
   break;
 case 663
 #line 4318 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 664
 #line 4322 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	 }
   break;
 case 665
 #line 4330 "cs-parser.jay"
   {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 666
 #line 4336 "cs-parser.jay"
   {
 		var constraints = (List<Constraints>) yyVals[-1+yyTop];
 		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		yyVal = constraints;
 	  }
   break;
 case 667
 #line 4355 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 668
 #line 4363 "cs-parser.jay"
   {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 669
 #line 4369 "cs-parser.jay"
   {
 		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = yyVals[0+yyTop] as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 670
 #line 4395 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast)
 			Report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 	  
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 671
 #line 4402 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 672
 #line 4407 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 673
 #line 4411 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 674
 #line 4418 "cs-parser.jay"
   {
 		yyVal = Variance.None;
 	  }
   break;
 case 675
 #line 4422 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 676
 #line 4432 "cs-parser.jay"
   {
 		yyVal = Variance.Covariant;
 	  }
   break;
 case 677
 #line 4436 "cs-parser.jay"
   {
 		yyVal = Variance.Contravariant;
 	  }
   break;
 case 678
 #line 4456 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 679
 #line 4461 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 680
 #line 4468 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 681
 #line 4473 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (lexer.Location);
 	  }
   break;
 case 682
 #line 4482 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
 	  }
   break;
 case 683
 #line 4487 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 688
 #line 4505 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 689
 #line 4509 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 691
 #line 4514 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 694
 #line 4533 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 695
 #line 4537 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 724
 #line 4578 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 725
 #line 4583 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 726
 #line 4588 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 727
 #line 4596 "cs-parser.jay"
   {
 		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
 		yyVal = new EmptyStatement (lexer.Location);
 	  }
   break;
 case 728
 #line 4604 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
   break;
 case 731
 #line 4617 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] is VarExpr)
 			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
 	  
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 732
 #line 4633 "cs-parser.jay"
   { 
 		/* Ok, the above "primary_expression" is there to get rid of*/
 		/* both reduce/reduce and shift/reduces in the grammar, it should*/
 		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
 		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
 		/* really) two shift/reduces appear.*/
 		/* */
 
 		/* So the super-trick is that primary_expression*/
 		/* can only be either a SimpleName or a MemberAccess. */
 		/* The MemberAccess case arises when you have a fully qualified type-name like 
 		/* Foo.Bar.Blah i;*/
 		/* SimpleName is when you have*/
 		/* Blah i;*/
 		
 		Expression expr = (Expression) yyVals[-1+yyTop];
 		if (yyVals[0+yyTop] == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				yyVal = new VarExpr (sn.Location);
 			else
 				yyVal = yyVals[-1+yyTop];
 		} else if (expr is ATypeNameExpression) {
 			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName (expr);
 			yyVal = null;
 		}
 	  }
   break;
 case 733
 #line 4663 "cs-parser.jay"
   {
 		ATypeNameExpression expr = yyVals[-1+yyTop] as ATypeNameExpression;
 
 		if (expr != null) {
 			yyVal = new ComposedCast (expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName ((Expression)yyVals[-1+yyTop]);
 			yyVal = expr;
 		}
 	  }
   break;
 case 734
 #line 4674 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] == null)
 			yyVal = yyVals[-1+yyTop];
 		else
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 735
 #line 4681 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 736
 #line 4685 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 737
 #line 4689 "cs-parser.jay"
   {
 		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 739
 #line 4698 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 740
 #line 4706 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreatePointer (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 741
 #line 4713 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 742
 #line 4720 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 743
 #line 4726 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 744
 #line 4733 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 746
 #line 4743 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		/* TODO
 	  }
   break;
 case 747
 #line 4748 "cs-parser.jay"
   {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
   break;
 case 752
 #line 4770 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 753
 #line 4779 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 754
 #line 4791 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
   break;
 case 755
 #line 4795 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 760
 #line 4812 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 762
 #line 4825 "cs-parser.jay"
   {
 		yyVal = new StackAlloc ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 763
 #line 4830 "cs-parser.jay"
   {
 		Report.Error (1575, GetLocation (yyVals[-1+yyTop]), "A stackalloc expression requires [] after type");
 		yyVal = new StackAlloc ((Expression) yyVals[0+yyTop], null, GetLocation (yyVals[-1+yyTop]));		
 	  }
   break;
 case 764
 #line 4838 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 765
 #line 4842 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 766
 #line 4846 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 767
 #line 4847 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 768
 #line 4856 "cs-parser.jay"
   {
 		ExpressionStatement s = yyVals[0+yyTop] as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation (yyVals[0+yyTop]));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 769
 #line 4869 "cs-parser.jay"
   {
 		Expression expr = (Expression) yyVals[0+yyTop];
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 770
 #line 4877 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 773
 #line 4891 "cs-parser.jay"
   { 
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 		
 		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 774
 #line 4900 "cs-parser.jay"
   {
 		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		
 		if (yyVals[-2+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 775
 #line 4913 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 776
 #line 4917 "cs-parser.jay"
   {
 		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
 		end_block (GetLocation (yyVals[0+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 777
 #line 4926 "cs-parser.jay"
   {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 779
 #line 4935 "cs-parser.jay"
   {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 780
 #line 4942 "cs-parser.jay"
   {
 		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 781
 #line 4949 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 782
 #line 4957 "cs-parser.jay"
   {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
   break;
 case 783
 #line 4961 "cs-parser.jay"
   {
 		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
 	  }
   break;
 case 784
 #line 4968 "cs-parser.jay"
   {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 		yyVal = labels;
 	  }
   break;
 case 785
 #line 4975 "cs-parser.jay"
   {
 		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 
 		yyVal = labels;
 	  }
   break;
 case 786
 #line 4985 "cs-parser.jay"
   {
 	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	 }
   break;
 case 787
 #line 4990 "cs-parser.jay"
   {
 		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 792
 #line 5004 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 793
 #line 5016 "cs-parser.jay"
   {
 		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 794
 #line 5024 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 		current_block.IsCompilerGenerated = true;
 	  }
   break;
 case 795
 #line 5029 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 796
 #line 5040 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		For f = new For ((Statement) yyVals[-6+yyTop], (BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		yyVal = end_block (GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 797
 #line 5052 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = end_block (current_block.StartLocation);
 	  }
   break;
 case 798
 #line 5059 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 800
 #line 5065 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 801
 #line 5072 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 803
 #line 5080 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 805
 #line 5085 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 809
 #line 5096 "cs-parser.jay"
   {
 	  	var sl = yyVals[-2+yyTop] as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
 			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
 	  	} else {
 	  		sl.Add ((Statement) yyVals[0+yyTop]);
 	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
 	  	}
 	  		
 		yyVal = sl;
 	  }
   break;
 case 810
 #line 5112 "cs-parser.jay"
   {
 		Report.Error (230, GetLocation (yyVals[-5+yyTop]), "Type and identifier are both required in a foreach statement");
 		yyVal = null;
 	  }
   break;
 case 811
 #line 5117 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-5+yyTop]));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		yyVal = li;
 	  }
   break;
 case 812
 #line 5127 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Foreach f = new Foreach ((Expression) yyVals[-6+yyTop], (LocalVariable) yyVals[-1+yyTop], (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 819
 #line 5150 "cs-parser.jay"
   {
 		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 820
 #line 5158 "cs-parser.jay"
   {
 		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 821
 #line 5166 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 822
 #line 5172 "cs-parser.jay"
   {
 		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 823
 #line 5177 "cs-parser.jay"
   {
 		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 824
 #line 5185 "cs-parser.jay"
   {
 		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 825
 #line 5193 "cs-parser.jay"
   {
 		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 826
 #line 5201 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (yyVals[-1+yyTop] == null) {
 			Report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 827
 #line 5217 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new YieldBreak (lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 830
 #line 5239 "cs-parser.jay"
   {
 		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
 	  }
   break;
 case 831
 #line 5243 "cs-parser.jay"
   {
 		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 832
 #line 5248 "cs-parser.jay"
   {
 		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]), true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 833
 #line 5253 "cs-parser.jay"
   {
 		Report.Error (1524, GetLocation (yyVals[-2+yyTop]), "Expected catch or finally");
 		yyVal = null;
 	  }
   break;
 case 834
 #line 5261 "cs-parser.jay"
   {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) yyVals[0+yyTop]);
 		yyVal = l;
 	  }
   break;
 case 835
 #line 5268 "cs-parser.jay"
   {
 		var l = (List<Catch>) yyVals[-1+yyTop];
 		
 		Catch c = (Catch) yyVals[0+yyTop];
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		yyVal = l;
 	  }
   break;
 case 838
 #line 5292 "cs-parser.jay"
   {
 		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 839
 #line 5296 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-3+yyTop]));
 		var c = new Catch (current_block, GetLocation (yyVals[-4+yyTop]));
 		c.TypeExpression = (FullNamedExpression) yyVals[-2+yyTop];
 
 		if (yyVals[-1+yyTop] != null) {
 			var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 840
 #line 5311 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 841
 #line 5315 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 842
 #line 5329 "cs-parser.jay"
   {
 		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 843
 #line 5336 "cs-parser.jay"
   {
 		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 844
 #line 5343 "cs-parser.jay"
   {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 845
 #line 5346 "cs-parser.jay"
   {
 		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 846
 #line 5353 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 847
 #line 5364 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 848
 #line 5373 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 849
 #line 5378 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 850
 #line 5390 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 851
 #line 5399 "cs-parser.jay"
   {
 		yyVal = current_variable;	  
 		current_variable = null;
 	  }
   break;
 case 852
 #line 5404 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (u);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 853
 #line 5413 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (u, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = u;
 	  }
   break;
 case 854
 #line 5425 "cs-parser.jay"
   {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
   break;
 case 855
 #line 5429 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		yyVal = current_variable;
 	  }
   break;
 case 856
 #line 5440 "cs-parser.jay"
   {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 857
 #line 5452 "cs-parser.jay"
   {
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 858
 #line 5463 "cs-parser.jay"
   {
 	        lexer.query_parsing = false;
 		yyVal = yyVals[-1+yyTop];
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 859
 #line 5470 "cs-parser.jay"
   {
 	        yyVal = yyVals[-1+yyTop];
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 860
 #line 5479 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 861
 #line 5487 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 862
 #line 5502 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 863
 #line 5510 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 864
 #line 5525 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 865
 #line 5529 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 866
 #line 5540 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 867
 #line 5544 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
 			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 868
 #line 5561 "cs-parser.jay"
   {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
 		
 		if (yyVals[0+yyTop] != null)
 			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 				
 		if (yyVals[-2+yyTop] != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		yyVal = head;
 	  }
   break;
 case 870
 #line 5577 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 871
 #line 5585 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 872
 #line 5589 "cs-parser.jay"
   {
 		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 873
 #line 5596 "cs-parser.jay"
   {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
   break;
 case 874
 #line 5604 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 875
 #line 5611 "cs-parser.jay"
   {
 		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 879
 #line 5627 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 885
 #line 5643 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 886
 #line 5647 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 887
 #line 5661 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 888
 #line 5665 "cs-parser.jay"
   {
 		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 889
 #line 5675 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 890
 #line 5683 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 891
 #line 5691 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 892
 #line 5699 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
   break;
 case 893
 #line 5735 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 894
 #line 5743 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 895
 #line 5751 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 896
 #line 5759 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;		
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO
 			
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
   break;
 case 898
 #line 5803 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 899
 #line 5810 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 900
 #line 5814 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 902
 #line 5825 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 903
 #line 5832 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	  }
   break;
 case 905
 #line 5841 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
   break;
 case 906
 #line 5848 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	 }
   break;
 case 907
 #line 5856 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 908
 #line 5860 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 909
 #line 5864 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 910
 #line 5871 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 911
 #line 5875 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 912
 #line 5879 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 914
 #line 5888 "cs-parser.jay"
   {
 		/* query continuation block is not linked with query block but with block*/
 		/* before. This means each query can use same range variable names for*/
 		/* different identifiers.*/
 
 		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
   break;
 case 915
 #line 5904 "cs-parser.jay"
   {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
   			next = (Linq.AQueryClause)yyVals[0+yyTop]
   		};
 	  }
   break;
 case 918
 #line 5930 "cs-parser.jay"
   { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		/* (ref object retval)*/
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, /* generic*/
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }
   break;
 case 919
 #line 5960 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  }
   break;
 case 920
 #line 5971 "cs-parser.jay"
   {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
   break;
 #line default
         }
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
     continue_yyLoop
     }
     /*yyLoop
       if (yyTop >= yyStates.Length) {			// dynamically increase
         global
         global
       }
       yyStates[yyTop] = yyState;
       yyVals[yyTop] = yyVal;
       if (debug != null) debug.push(yyState, yyVal);
 
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 case 5
 #line 375 "cs-parser.jay"
   { Lexer.CompleteOnEOF = false; }
   break;
 case 7
 #line 380 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 8
 #line 384 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 16
 #line 407 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop]; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
   break;
 case 17
 #line 420 "cs-parser.jay"
   {
 	  	syntax_error (GetLocation (yyVals[-1+yyTop]), "`alias' expected");   /* TODO
 	  }
   break;
 case 20
 #line 432 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 21
 #line 437 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 22
 #line 445 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 23
 #line 450 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 24
 #line 458 "cs-parser.jay"
   {
 		current_namespace.AddUsing ((MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 25
 #line 470 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (yyVals[-2+yyTop] != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 26
 #line 483 "cs-parser.jay"
   { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 27
 #line 492 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName (lt.Value, lt.Location);
 	  }
   break;
 case 28
 #line 497 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 29
 #line 502 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new MemberName ("<invalid>", lexer.Location);
 	  }
   break;
 case 34
 #line 520 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		yyVal = name;
 	  }
   break;
 case 35
 #line 532 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 45
 #line 564 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			DeclSpace ds = (DeclSpace)yyVals[0+yyTop];
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 46
 #line 576 "cs-parser.jay"
   {
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 47
 #line 580 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	 }
   break;
 case 53
 #line 606 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			Attributes attrs = (Attributes)yyVals[0+yyTop];
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 54
 #line 623 "cs-parser.jay"
   {
 		global_attrs_enabled = false;
 		yyVal = null;
       }
   break;
 case 55
 #line 628 "cs-parser.jay"
   { 
 		global_attrs_enabled = false;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 56
 #line 637 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					yyVal = null;
 				} else {
 					yyVal = new Attributes (sect);
 				}
 				if (yyVal == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				yyVal = new Attributes (sect);
 			}		
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 57
 #line 664 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = yyVals[-1+yyTop] as Attributes;
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					yyVal = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			yyVal = attrs;
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 58
 #line 695 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
  	  }
   break;
 case 59
 #line 699 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 60
 #line 706 "cs-parser.jay"
   {
 		current_attr_target = (string)yyVals[-1+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 61
 #line 714 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
   break;
 case 62
 #line 718 "cs-parser.jay"
   { yyVal = "event"; }
   break;
 case 63
 #line 719 "cs-parser.jay"
   { yyVal = "return"; }
   break;
 case 64
 #line 721 "cs-parser.jay"
   {
 		string name = GetTokenName (yyToken);
 		yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 65
 #line 729 "cs-parser.jay"
   {
 		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
 	  }
   break;
 case 66
 #line 733 "cs-parser.jay"
   {
 		var attrs = (List<Attribute>) yyVals[-2+yyTop];
 		attrs.Add ((Attribute) yyVals[0+yyTop]);
 
 		yyVal = attrs;
 	  }
   break;
 case 67
 #line 743 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 68
 #line 747 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) yyVals[-2+yyTop];
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) yyVals[0+yyTop];
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			yyVal = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			/* FIXME
 			yyVal = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			yyVal = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
   break;
 case 69
 #line 770 "cs-parser.jay"
   { /* reserved attribute name or identifier
   break;
 case 70
 #line 774 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 71
 #line 776 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 72
 #line 783 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 73
 #line 785 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = new Arguments [] { a, null };
 	  }
   break;
 case 74
 #line 791 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);  
 		yyVal = new Arguments [] { null, a };
 	  }
   break;
 case 75
 #line 797 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 76
 #line 811 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 77
 #line 823 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 79
 #line 831 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 80
 #line 835 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
 	  }
   break;
 case 81
 #line 844 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
 			
 		/* Avoid boxing in common case (no modifier)*/
 		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
 	  }
   break;
 case 82
 #line 857 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 83
 #line 859 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Ref;
 	  }
   break;
 case 84
 #line 863 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Out;
 	  }
   break;
 case 99
 #line 891 "cs-parser.jay"
   {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		yyVal = null;
 		lexer.parsing_generic_declaration = false;
 	  }
   break;
 case 100
 #line 904 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 101
 #line 908 "cs-parser.jay"
   { 
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 102
 #line 914 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 103
 #line 925 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 104
 #line 931 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 105
 #line 936 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	  }
   break;
 case 106
 #line 943 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 107
 #line 948 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 122
 #line 985 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var mod = (Modifiers) yyVals[-3+yyTop];
 		current_field = new Const (current_class, (FullNamedExpression) yyVals[-1+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_field;
 	  }
   break;
 case 123
 #line 998 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_field = null;
 	  }
   break;
 case 126
 #line 1017 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 127
 #line 1021 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 128
 #line 1028 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 129
 #line 1037 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 130
 #line 1041 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 131
 #line 1046 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		yyVal = null;
 	  }
   break;
 case 134
 #line 1061 "cs-parser.jay"
   {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) yyVals[-1+yyTop];
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation (yyVals[-1+yyTop]), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new Field (current_class, type, (Modifiers) yyVals[-2+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-3+yyTop]);
 		current_container.AddField (current_field);
 		yyVal = current_field;
 	  }
   break;
 case 135
 #line 1076 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 		current_field = null;
 	  }
   break;
 case 136
 #line 1089 "cs-parser.jay"
   { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new FixedField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop],
 			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 			
 		current_container.AddField (current_field);
 	  }
   break;
 case 137
 #line 1100 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 	    current_field = null;
 	  }
   break;
 case 138
 #line 1115 "cs-parser.jay"
   {
 		Report.Error (1641, GetLocation (yyVals[-1+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
   break;
 case 140
 #line 1123 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 141
 #line 1129 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) yyVals[0+yyTop];
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
   break;
 case 144
 #line 1144 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 145
 #line 1148 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 146
 #line 1155 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 147
 #line 1161 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 148
 #line 1165 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 151
 #line 1180 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 152
 #line 1184 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 153
 #line 1191 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	  
 		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 154
 #line 1200 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 155
 #line 1204 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 156
 #line 1210 "cs-parser.jay"
   {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		yyVal = null;
 	  }
   break;
 case 159
 #line 1220 "cs-parser.jay"
   {
 		/* It has to be here for the parent to safely restore artificial block*/
 	  	Error_SyntaxError (yyToken);
 	  	yyVal = null;
 	  }
   break;
 case 160
 #line 1228 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 161
 #line 1233 "cs-parser.jay"
   {
 		Method method = (Method) yyVals[-2+yyTop];
 		method.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 162
 #line 1254 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 163
 #line 1258 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 164
 #line 1262 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) yyVals[-7+yyTop], current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		} else if (yyVals[0+yyTop] != null) {
 			Report.Error (80, GetLocation (yyVals[0+yyTop]),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) yyVals[-7+yyTop], (Modifiers) yyVals[-8+yyTop],
 				     name, current_local_parameters, (Attributes) yyVals[-9+yyTop]);
 				     
 		if (yyVals[0+yyTop] != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 165
 #line 1299 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 166
 #line 1303 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 167
 #line 1307 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		if (yyVals[-1+yyTop] != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		}
 
 		var modifiers = (Modifiers) yyVals[-9+yyTop];
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				     modifiers, name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		/* TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-8+yyTop]));
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 168
 #line 1362 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-4+yyTop]));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) yyVals[-5+yyTop],
 					    0, name, (ParametersCompiled) yyVals[-1+yyTop], (Attributes) yyVals[-7+yyTop]);
 
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		yyVal = method;
 	  }
   break;
 case 170
 #line 1381 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 171
 #line 1385 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 173
 #line 1391 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 174
 #line 1396 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
   break;
 case 175
 #line 1403 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[0+yyTop])));
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 176
 #line 1409 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
 	  }
   break;
 case 177
 #line 1416 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 178
 #line 1426 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[-2+yyTop])) }, true);
 	  }
   break;
 case 179
 #line 1432 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 180
 #line 1441 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
 	  }
   break;
 case 181
 #line 1445 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[0+yyTop])) }, true);
 	  }
   break;
 case 182
 #line 1449 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 183
 #line 1457 "cs-parser.jay"
   {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		yyVal = parameters_bucket;
 	  }
   break;
 case 184
 #line 1466 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation (yyVals[-1+yyTop]));
 		}
 		
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 185
 #line 1490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 186
 #line 1498 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Parameter.Modifier) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop], lt.Location);
 	  }
   break;
 case 187
 #line 1507 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation (yyVals[0+yyTop]);
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], "NeedSomeGeneratorHere", (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], l);
 	  }
   break;
 case 188
 #line 1517 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 189
 #line 1521 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-5+yyTop];
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-4+yyTop], lt.Value, mod, (Attributes) yyVals[-6+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 		
 		if (yyVals[0+yyTop] != null)
 			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 190
 #line 1560 "cs-parser.jay"
   { yyVal = Parameter.Modifier.NONE; }
   break;
 case 192
 #line 1566 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 193
 #line 1570 "cs-parser.jay"
   {
 		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
   		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
   		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		yyVal = mod;
 	  }
   break;
 case 194
 #line 1594 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
 	  		
 	  	yyVal = Parameter.Modifier.REF;
 	  }
   break;
 case 195
 #line 1601 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
 	  
 	  	yyVal = Parameter.Modifier.OUT;
 	  }
   break;
 case 196
 #line 1608 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
 	  			
 		yyVal = Parameter.Modifier.This;
 	  }
   break;
 case 197
 #line 1621 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 198
 #line 1626 "cs-parser.jay"
   {
 		Report.Error (1751, GetLocation (yyVals[-4+yyTop]), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Attributes) yyVals[-5+yyTop], lt.Location);		
 	  }
   break;
 case 199
 #line 1633 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 200
 #line 1641 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation (yyVals[0+yyTop])), "The `params' modifier is not allowed in current context");
 	  }
   break;
 case 201
 #line 1646 "cs-parser.jay"
   {
 		Parameter.Modifier mod = (Parameter.Modifier)yyVals[0+yyTop];
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation (yyVals[-1+yyTop]), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation (yyVals[-1+yyTop]), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
   break;
 case 202
 #line 1655 "cs-parser.jay"
   {
 		Error_DuplicateParameterModifier (GetLocation (yyVals[-1+yyTop]), Parameter.Modifier.PARAMS);
 	  }
   break;
 case 203
 #line 1662 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation (yyVals[0+yyTop]), "__arglist is not valid in this context");
 	  }
   break;
 case 204
 #line 1673 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 205
 #line 1678 "cs-parser.jay"
   {
 		current_property = new Property (current_class, (FullNamedExpression) yyVals[-3+yyTop], (Modifiers) yyVals[-4+yyTop],
 			(MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation (yyVals[-3+yyTop]), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[0+yyTop]));
 		
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 206
 #line 1691 "cs-parser.jay"
   {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
   break;
 case 207
 #line 1698 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
 		current_property = null;
 	  }
   break;
 case 208
 #line 1708 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 209
 #line 1712 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) yyVals[-6+yyTop],
 			(MemberName)yyVals[-5+yyTop], (Modifiers) yyVals[-7+yyTop], (ParametersCompiled) yyVals[-2+yyTop], (Attributes) yyVals[-8+yyTop]);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation (yyVals[-6+yyTop]), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation (yyVals[-4+yyTop]), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 210
 #line 1738 "cs-parser.jay"
   {
 		  lexer.PropertyParsing = false;
 	  }
   break;
 case 211
 #line 1742 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation (yyVals[-1+yyTop]));
 		current_property = null;		
 	  }
   break;
 case 216
 #line 1758 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
 		}
 	  }
   break;
 case 217
 #line 1772 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 218
 #line 1794 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] != null) {
 	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 219
 #line 1815 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
 					null),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 220
 #line 1842 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {		
 			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 222
 #line 1864 "cs-parser.jay"
   {
 		/* TODO
 	  	yyVal = null;
 	  }
   break;
 case 223
 #line 1869 "cs-parser.jay"
   {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	yyVal = null;
 	  }
   break;
 case 224
 #line 1880 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 225
 #line 1884 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 226
 #line 1891 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 227
 #line 1902 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 228
 #line 1908 "cs-parser.jay"
   {
 	    lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 229
 #line 1913 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  }
   break;
 case 234
 #line 1930 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 235
 #line 1934 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 240
 #line 1942 "cs-parser.jay"
   {
 	  	Report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
 	  }
   break;
 case 241
 #line 1946 "cs-parser.jay"
   {
 	  	Report.Error (526, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain contructors");
 	  }
   break;
 case 242
 #line 1950 "cs-parser.jay"
   {
 	  	Report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
   break;
 case 243
 #line 1957 "cs-parser.jay"
   {
 	  }
   break;
 case 244
 #line 1960 "cs-parser.jay"
   {
 		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) yyVals[-3+yyTop], 
 				current_local_parameters,
 				(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			/* Note again, checking is done in semantic analysis*/
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 246
 #line 1985 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 248
 #line 1991 "cs-parser.jay"
   {
 		Report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 249
 #line 1999 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 250
 #line 2003 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		Operator.OpType op = (Operator.OpType) yyVals[-4+yyTop];
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[-6+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 252
 #line 2047 "cs-parser.jay"
   { yyVal = Operator.OpType.LogicalNot; }
   break;
 case 253
 #line 2048 "cs-parser.jay"
   { yyVal = Operator.OpType.OnesComplement; }
   break;
 case 254
 #line 2049 "cs-parser.jay"
   { yyVal = Operator.OpType.Increment; }
   break;
 case 255
 #line 2050 "cs-parser.jay"
   { yyVal = Operator.OpType.Decrement; }
   break;
 case 256
 #line 2051 "cs-parser.jay"
   { yyVal = Operator.OpType.True; }
   break;
 case 257
 #line 2052 "cs-parser.jay"
   { yyVal = Operator.OpType.False; }
   break;
 case 258
 #line 2054 "cs-parser.jay"
   { yyVal = Operator.OpType.Addition; }
   break;
 case 259
 #line 2055 "cs-parser.jay"
   { yyVal = Operator.OpType.Subtraction; }
   break;
 case 260
 #line 2057 "cs-parser.jay"
   { yyVal = Operator.OpType.Multiply; }
   break;
 case 261
 #line 2058 "cs-parser.jay"
   {  yyVal = Operator.OpType.Division; }
   break;
 case 262
 #line 2059 "cs-parser.jay"
   { yyVal = Operator.OpType.Modulus; }
   break;
 case 263
 #line 2060 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseAnd; }
   break;
 case 264
 #line 2061 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseOr; }
   break;
 case 265
 #line 2062 "cs-parser.jay"
   { yyVal = Operator.OpType.ExclusiveOr; }
   break;
 case 266
 #line 2063 "cs-parser.jay"
   { yyVal = Operator.OpType.LeftShift; }
   break;
 case 267
 #line 2064 "cs-parser.jay"
   { yyVal = Operator.OpType.RightShift; }
   break;
 case 268
 #line 2065 "cs-parser.jay"
   { yyVal = Operator.OpType.Equality; }
   break;
 case 269
 #line 2066 "cs-parser.jay"
   { yyVal = Operator.OpType.Inequality; }
   break;
 case 270
 #line 2067 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThan; }
   break;
 case 271
 #line 2068 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThan; }
   break;
 case 272
 #line 2069 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThanOrEqual; }
   break;
 case 273
 #line 2070 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThanOrEqual; }
   break;
 case 274
 #line 2075 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 275
 #line 2079 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 276
 #line 2094 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 277
 #line 2098 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 278
 #line 2113 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 279
 #line 2119 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 280
 #line 2129 "cs-parser.jay"
   { 
 		Constructor c = (Constructor) yyVals[-1+yyTop];
 		c.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 281
 #line 2148 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 282
 #line 2157 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];  
 		
 		/**/
 		/* start block here, so possible anonymous methods inside*/
 		/* constructor initializer can get correct parent block*/
 		/**/
 	  	start_block (lexer.Location);
 	  }
   break;
 case 283
 #line 2168 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-6+yyTop];
 		var mods = (Modifiers) yyVals[-7+yyTop];
 		ConstructorInitializer ci = (ConstructorInitializer) yyVals[0+yyTop];
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) yyVals[-8+yyTop], current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 285
 #line 2199 "cs-parser.jay"
   { current_block = null; yyVal = null; }
   break;
 case 288
 #line 2209 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 289
 #line 2213 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 290
 #line 2219 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 291
 #line 2223 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorThisInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 292
 #line 2229 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 293
 #line 2237 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 294
 #line 2246 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) yyVals[-6+yyTop],
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-7+yyTop], lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		current_local_parameters = null;
 	  }
   break;
 case 295
 #line 2271 "cs-parser.jay"
   {
 		current_event_field = new EventField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop], (MemberName) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop]);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_event_field;
 	  }
   break;
 case 296
 #line 2285 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_event_field = null;
 	  }
   break;
 case 297
 #line 2298 "cs-parser.jay"
   {
 		current_event = new EventProperty (current_class, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-1+yyTop], (Attributes) yyVals[-5+yyTop]);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		
 		lexer.EventParsing = true;
 	  }
   break;
 case 298
 #line 2306 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
   break;
 case 299
 #line 2313 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
   break;
 case 301
 #line 2328 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 302
 #line 2332 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 305
 #line 2345 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 306
 #line 2349 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 307
 #line 2356 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 308
 #line 2362 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 309
 #line 2366 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 310
 #line 2375 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
   break;
 case 311
 #line 2387 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 314
 #line 2396 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 315
 #line 2401 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 316
 #line 2406 "cs-parser.jay"
   { 
 		Report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
 		yyVal = null;
 	  }
   break;
 case 317
 #line 2414 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 318
 #line 2426 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 319
 #line 2442 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 320
 #line 2454 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 321
 #line 2470 "cs-parser.jay"
   {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		yyVal = null;
 	  }
   break;
 case 323
 #line 2482 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 324
 #line 2487 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], MakeName (name), (Attributes) yyVals[-6+yyTop]), null);
 	  }
   break;
 case 325
 #line 2499 "cs-parser.jay"
   {
 	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 326
 #line 2505 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 /*			if (RootContext.Documentation != null)*/
 /*				em.DocComment = ev.DocComment;*/
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 328
 #line 2522 "cs-parser.jay"
   {
 	 	var te = yyVals[0+yyTop] as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), Report);
 			yyVal = null;
 		} else {
 			yyVal = yyVals[0+yyTop];
 		}
 	 }
   break;
 case 329
 #line 2536 "cs-parser.jay"
   {
 	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
 		yyVal = null;
 	 }
   break;
 case 332
 #line 2546 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 334
 #line 2554 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 335
 #line 2562 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		yyVal = em;
 	  }
   break;
 case 336
 #line 2575 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
   break;
 case 337
 #line 2583 "cs-parser.jay"
   { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		yyVal = em;
 	  }
   break;
 case 338
 #line 2604 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 339
 #line 2608 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) yyVals[-4+yyTop]);
 		ParametersCompiled p = (ParametersCompiled) yyVals[-1+yyTop];
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) yyVals[-5+yyTop],
 					     (Modifiers) yyVals[-7+yyTop], name, p, (Attributes) yyVals[-8+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 340
 #line 2627 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 	  }
   break;
 case 341
 #line 2631 "cs-parser.jay"
   {
 		current_delegate.SetParameterInfo ((List<Constraints>) yyVals[-2+yyTop]);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation (yyVals[-10+yyTop]), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
 
 		yyVal = current_delegate;
 
 		current_delegate = null;
 	  }
   break;
 case 343
 #line 2644 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
 	  
 	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 345
 #line 2655 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 347
 #line 2666 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 348
 #line 2675 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 350
 #line 2687 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
 	  
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 351
 #line 2694 "cs-parser.jay"
   {
 		Error_TypeExpected (lexer.Location);
 		yyVal = new TypeArguments ();
 	  }
   break;
 case 352
 #line 2702 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 353
 #line 2708 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 354
 #line 2720 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 355
 #line 2724 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 356
 #line 2733 "cs-parser.jay"
   {
 	  	MemberName mn = (MemberName)yyVals[0+yyTop];
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
   break;
 case 358
 #line 2744 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 359
 #line 2753 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		yyVal = new MemberName (TypeContainer.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 360
 #line 2758 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		yyVal = new MemberName ((MemberName) yyVals[-1+yyTop], TypeContainer.DefaultIndexerName, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 361
 #line 2766 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 362
 #line 2772 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[-1+yyTop], lt1.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 363
 #line 2780 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 365
 #line 2790 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
 	  
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 366
 #line 2801 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 367
 #line 2807 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 368
 #line 2817 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 		yyVal = new TypeParameterName (lt.Value, (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop], lt.Location);
   	  }
   break;
 case 369
 #line 2822 "cs-parser.jay"
   {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	yyVal = new TypeParameterName ("", null, lexer.Location);
   	  }
   break;
 case 371
 #line 2838 "cs-parser.jay"
   {
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 372
 #line 2845 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 374
 #line 2856 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 376
 #line 2865 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 378
 #line 2874 "cs-parser.jay"
   {
 	  	Report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 380
 #line 2883 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 381
 #line 2890 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-1+yyTop];
 
 		if (yyVals[0+yyTop] != null) {
 			yyVal = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				yyVal = new VarExpr (name.Location);
 			else
 				yyVal = name.GetTypeExpression ();
 		}
 	  }
   break;
 case 382
 #line 2903 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (((MemberName) yyVals[-1+yyTop]).GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 383
 #line 2907 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null)
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 384
 #line 2912 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 385
 #line 2916 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 386
 #line 2923 "cs-parser.jay"
   {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 387
 #line 2929 "cs-parser.jay"
   {
 		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 388
 #line 2938 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast) {
 			Report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 389
 #line 2945 "cs-parser.jay"
   {
 	  	Error_TypeExpected (lexer.Location);
 		yyVal = null;
 	  }
   break;
 case 390
 #line 2956 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.object_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 391
 #line 2957 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.string_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 392
 #line 2958 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.bool_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 393
 #line 2959 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.decimal_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 394
 #line 2960 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.float_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 395
 #line 2961 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.double_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 397
 #line 2966 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.sbyte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 398
 #line 2967 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.byte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 399
 #line 2968 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.short_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 400
 #line 2969 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.ushort_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 401
 #line 2970 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 402
 #line 2971 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 403
 #line 2972 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 404
 #line 2973 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 405
 #line 2974 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.char_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 425
 #line 3006 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 426
 #line 3010 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
   break;
 case 430
 #line 3020 "cs-parser.jay"
   { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
   break;
 case 431
 #line 3024 "cs-parser.jay"
   { yyVal = new BoolLiteral (true, GetLocation (yyVals[0+yyTop])); }
   break;
 case 432
 #line 3025 "cs-parser.jay"
   { yyVal = new BoolLiteral (false, GetLocation (yyVals[0+yyTop])); }
   break;
 case 437
 #line 3051 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 438
 #line 3056 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 	  }
   break;
 case 439
 #line 3063 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 440
 #line 3069 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 441
 #line 3075 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 442
 #line 3081 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 443
 #line 3087 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 444
 #line 3090 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
 	  }
   break;
 case 445
 #line 3095 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
 	  }
   break;
 case 446
 #line 3098 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
  	  }
   break;
 case 447
 #line 3106 "cs-parser.jay"
   {
 		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 448
 #line 3113 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 450
 #line 3119 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] == null) {
 	  		yyVal = CollectionOrObjectInitializers.Empty;
 	  		/* TODO
 	  	} else {
 	  		yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  	}
 	  }
   break;
 case 451
 #line 3129 "cs-parser.jay"
   {
 	  	yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 452
 #line 3136 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 453
 #line 3138 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	}
   break;
 case 454
 #line 3145 "cs-parser.jay"
   {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 455
 #line 3151 "cs-parser.jay"
   {
 	  	var a = (List<Expression>)yyVals[-2+yyTop];
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 456
 #line 3156 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 457
 #line 3164 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 458
 #line 3170 "cs-parser.jay"
   {
 		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 459
 #line 3173 "cs-parser.jay"
   {
 		CompletionSimpleName csn = yyVals[-1+yyTop] as CompletionSimpleName;
 		if (csn == null)
 			yyVal = new CollectionElementInitializer ((Expression)yyVals[-1+yyTop]);
 		else
 			yyVal = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
   break;
 case 460
 #line 3181 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] == null)
 			yyVal = null;
 		else
 	  		yyVal = new CollectionElementInitializer ((List<Expression>)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 461
 #line 3188 "cs-parser.jay"
   {
 	  	Report.Error (1920, GetLocation (yyVals[-1+yyTop]), "An element initializer cannot be empty");
 		yyVal = null;
 	  }
   break;
 case 464
 #line 3200 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 466
 #line 3206 "cs-parser.jay"
   { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 467
 #line 3212 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 468
 #line 3221 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		yyVal = list;
 	  }
   break;
 case 469
 #line 3235 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[0+yyTop]), "An argument is missing");
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 470
 #line 3240 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
 	  	yyVal = null;
 	  }
   break;
 case 471
 #line 3248 "cs-parser.jay"
   {
 		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 475
 #line 3261 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 476
 #line 3266 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 477
 #line 3271 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 478
 #line 3276 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist (GetLocation (yyVals[-2+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 480
 #line 3288 "cs-parser.jay"
   {
 		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 481
 #line 3296 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 482
 #line 3302 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 483
 #line 3307 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 484
 #line 3315 "cs-parser.jay"
   {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;
 	  }
   break;
 case 485
 #line 3321 "cs-parser.jay"
   {
 		Arguments args = (Arguments) yyVals[-2+yyTop];
 		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;	  
 	  }
   break;
 case 486
 #line 3333 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 488
 #line 3341 "cs-parser.jay"
   {
 		yyVal = new This (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 489
 #line 3348 "cs-parser.jay"
   {
 	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 490
 #line 3353 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 491
 #line 3361 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 492
 #line 3368 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 493
 #line 3375 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation (yyVals[-5+yyTop]), "object initializers");
 				
 			yyVal = new NewInitialize ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		} else {
 			yyVal = new New ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], GetLocation (yyVals[-5+yyTop]));
 		}
 		
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 494
 #line 3388 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "collection initializers");
 	  
 		yyVal = new NewInitialize ((FullNamedExpression) yyVals[-1+yyTop], null, (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 495
 #line 3400 "cs-parser.jay"
   {
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], (List<Expression>) yyVals[-3+yyTop],
 				new ComposedTypeSpecifier (((List<Expression>) yyVals[-3+yyTop]).Count, GetLocation (yyVals[-4+yyTop])) {
 	  				Next = (ComposedTypeSpecifier) yyVals[-1+yyTop]
 			  	}, (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 496
 #line 3408 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] == null)
 	  		Report.Error (1586, GetLocation (yyVals[-3+yyTop]), "Array creation must have array size or array initializer");
 
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-2+yyTop], (ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 497
 #line 3415 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "implicitly typed arrays");
 	  
 		yyVal = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 498
 #line 3422 "cs-parser.jay"
   {
 		Report.Error (178, GetLocation (yyVals[-1+yyTop]), "Invalid rank specifier, expecting `,' or `]'");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], null, GetLocation (yyVals[-6+yyTop]));
 	  }
   break;
 case 499
 #line 3427 "cs-parser.jay"
   {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 500
 #line 3434 "cs-parser.jay"
   {
 		++lexer.parsing_type;
 	  }
   break;
 case 501
 #line 3438 "cs-parser.jay"
   {
 		--lexer.parsing_type;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 502
 #line 3446 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "anonymous types");
 
 		yyVal = new NewAnonymousType ((List<AnonymousTypeParameter>) yyVals[-1+yyTop], current_container, GetLocation (yyVals[-3+yyTop]));
 		
 		/* TODO
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 505
 #line 3463 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 507
 #line 3469 "cs-parser.jay"
   {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 508
 #line 3475 "cs-parser.jay"
   {
 	  	var a = (List<AnonymousTypeParameter>) yyVals[-2+yyTop];
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 509
 #line 3484 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[-2+yyTop];
 	  	yyVal = new AnonymousTypeParameter ((Expression)yyVals[0+yyTop], lt.Value, lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 510
 #line 3490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
   break;
 case 511
 #line 3496 "cs-parser.jay"
   {
 	  	MemberAccess ma = (MemberAccess) yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
   break;
 case 512
 #line 3501 "cs-parser.jay"
   {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		yyVal = null;
 	  }
   break;
 case 516
 #line 3516 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 517
 #line 3524 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 518
 #line 3528 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 519
 #line 3535 "cs-parser.jay"
   {
 		yyVal = 2;
 	  }
   break;
 case 520
 #line 3539 "cs-parser.jay"
   {
 		yyVal = ((int) yyVals[-1+yyTop]) + 1;
 	  }
   break;
 case 521
 #line 3546 "cs-parser.jay"
   {
 		yyVal = null;
 	  }
   break;
 case 522
 #line 3550 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 523
 #line 3557 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 524
 #line 3564 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 525
 #line 3574 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 526
 #line 3580 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 527
 #line 3589 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = true;
 	  }
   break;
 case 528
 #line 3593 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = false;
 		yyVal = new TypeOf ((FullNamedExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 531
 #line 3604 "cs-parser.jay"
   {
 	 	Error_TypeExpected (lexer.Location);
 	 	yyVal = null;
 	 }
   break;
 case 532
 #line 3612 "cs-parser.jay"
   {  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 533
 #line 3618 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 534
 #line 3625 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 535
 #line 3631 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 536
 #line 3637 "cs-parser.jay"
   {
 		var te = ((MemberName) yyVals[-3+yyTop]).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (te, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 537
 #line 3649 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 538
 #line 3659 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		yyVal = lt;		
 	  }
   break;
 case 539
 #line 3670 "cs-parser.jay"
   { 
 		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 540
 #line 3678 "cs-parser.jay"
   {
 		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 541
 #line 3686 "cs-parser.jay"
   {
 		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 542
 #line 3694 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberAccess (new Indirection ((Expression) yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop])), lt.Value, lt.Location);
 	  }
   break;
 case 543
 #line 3702 "cs-parser.jay"
   {
 		start_anonymous (false, (ParametersCompiled) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 544
 #line 3706 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 	  }
   break;
 case 545
 #line 3713 "cs-parser.jay"
   {
 		yyVal = ParametersCompiled.Undefined;
 	  }
   break;
 case 547
 #line 3721 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 548
 #line 3725 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 549
 #line 3733 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
 
 		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 551
 #line 3745 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 552
 #line 3749 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 554
 #line 3757 "cs-parser.jay"
   {
 		yyVal = new Cast ((FullNamedExpression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 556
 #line 3770 "cs-parser.jay"
   { 
 	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 557
 #line 3774 "cs-parser.jay"
   { 
 		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 558
 #line 3778 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 559
 #line 3782 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 560
 #line 3786 "cs-parser.jay"
   {
 		yyVal = new Indirection ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 561
 #line 3790 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 563
 #line 3798 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Multiply, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 564
 #line 3803 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Division, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 565
 #line 3808 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Modulus, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 567
 #line 3817 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Addition, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 568
 #line 3822 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 569
 #line 3826 "cs-parser.jay"
   {
 	  	/* Shift/Reduce conflict*/
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
   	  }
   break;
 case 570
 #line 3831 "cs-parser.jay"
   {
 		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 571
 #line 3835 "cs-parser.jay"
   {
 		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 573
 #line 3843 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 574
 #line 3848 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.RightShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 576
 #line 3857 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 577
 #line 3862 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 578
 #line 3867 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 579
 #line 3872 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 581
 #line 3881 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Equality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 582
 #line 3886 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Inequality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 584
 #line 3895 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 586
 #line 3904 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 588
 #line 3913 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 590
 #line 3922 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 592
 #line 3931 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 594
 #line 3940 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
 			
 		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 596
 #line 3951 "cs-parser.jay"
   {
 		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 597
 #line 3959 "cs-parser.jay"
   {
 		yyVal = new SimpleAssign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 598
 #line 3963 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 599
 #line 3968 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 600
 #line 3973 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 601
 #line 3978 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 602
 #line 3983 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 603
 #line 3988 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 604
 #line 3993 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 605
 #line 3998 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 606
 #line 4003 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 607
 #line 4008 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 608
 #line 4016 "cs-parser.jay"
   {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = pars;
 	  }
   break;
 case 609
 #line 4023 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter)yyVals[0+yyTop];
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		yyVal = pars;
 	  }
   break;
 case 610
 #line 4037 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
 	  }
   break;
 case 611
 #line 4043 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
   break;
 case 612
 #line 4049 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
   break;
 case 613
 #line 4056 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 614
 #line 4057 "cs-parser.jay"
   { 
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 		yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 617
 #line 4069 "cs-parser.jay"
   {
 		start_block (lexer.Location);
 	  }
   break;
 case 618
 #line 4073 "cs-parser.jay"
   {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
 		yyVal = b;
 	  }
   break;
 case 620
 #line 4083 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	
 		yyVal = EmptyExpression.Null;
 	  }
   break;
 case 621
 #line 4091 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 622
 #line 4097 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 623
 #line 4102 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 624
 #line 4109 "cs-parser.jay"
   {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 625
 #line 4114 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 631
 #line 4130 "cs-parser.jay"
   {
 		yyVal = new ArglistAccess (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 633
 #line 4141 "cs-parser.jay"
   {
 		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 634
 #line 4154 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 635
 #line 4158 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 636
 #line 4164 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 637
 #line 4176 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 638
 #line 4182 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 639
 #line 4190 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 640
 #line 4192 "cs-parser.jay"
   { yyVal = yyVals[0+yyTop]; }
   break;
 case 641
 #line 4197 "cs-parser.jay"
   {
 	    mod_locations = null;
 		yyVal = ModifierNone;
 	  }
   break;
 case 644
 #line 4207 "cs-parser.jay"
   { 
 		var m1 = (Modifiers) yyVals[-1+yyTop];
 		var m2 = (Modifiers) yyVals[0+yyTop];
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		yyVal = m1 | m2;
 	  }
   break;
 case 645
 #line 4226 "cs-parser.jay"
   {
 		yyVal = Modifiers.NEW;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
 	  }
   break;
 case 646
 #line 4234 "cs-parser.jay"
   {
 		yyVal = Modifiers.PUBLIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 647
 #line 4239 "cs-parser.jay"
   {
 		yyVal = Modifiers.PROTECTED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 648
 #line 4244 "cs-parser.jay"
   {
 		yyVal = Modifiers.INTERNAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 649
 #line 4249 "cs-parser.jay"
   {
 		yyVal = Modifiers.PRIVATE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 650
 #line 4254 "cs-parser.jay"
   {
 		yyVal = Modifiers.ABSTRACT;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 651
 #line 4259 "cs-parser.jay"
   {
 		yyVal = Modifiers.SEALED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 652
 #line 4264 "cs-parser.jay"
   {
 		yyVal = Modifiers.STATIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 653
 #line 4269 "cs-parser.jay"
   {
 		yyVal = Modifiers.READONLY;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 654
 #line 4274 "cs-parser.jay"
   {
 		yyVal = Modifiers.VIRTUAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 655
 #line 4279 "cs-parser.jay"
   {
 		yyVal = Modifiers.OVERRIDE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 656
 #line 4284 "cs-parser.jay"
   {
 		yyVal = Modifiers.EXTERN;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 657
 #line 4289 "cs-parser.jay"
   {
 		yyVal = Modifiers.VOLATILE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 658
 #line 4294 "cs-parser.jay"
   {
 		yyVal = Modifiers.UNSAFE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 659
 #line 4301 "cs-parser.jay"
   {
 		yyVal = Modifiers.ASYNC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 661
 #line 4310 "cs-parser.jay"
   {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) yyVals[0+yyTop]);
 	 }
   break;
 case 663
 #line 4318 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 664
 #line 4322 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	 }
   break;
 case 665
 #line 4330 "cs-parser.jay"
   {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 666
 #line 4336 "cs-parser.jay"
   {
 		var constraints = (List<Constraints>) yyVals[-1+yyTop];
 		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		yyVal = constraints;
 	  }
   break;
 case 667
 #line 4355 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 668
 #line 4363 "cs-parser.jay"
   {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 669
 #line 4369 "cs-parser.jay"
   {
 		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = yyVals[0+yyTop] as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 670
 #line 4395 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast)
 			Report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 	  
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 671
 #line 4402 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 672
 #line 4407 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 673
 #line 4411 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 674
 #line 4418 "cs-parser.jay"
   {
 		yyVal = Variance.None;
 	  }
   break;
 case 675
 #line 4422 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 676
 #line 4432 "cs-parser.jay"
   {
 		yyVal = Variance.Covariant;
 	  }
   break;
 case 677
 #line 4436 "cs-parser.jay"
   {
 		yyVal = Variance.Contravariant;
 	  }
   break;
 case 678
 #line 4456 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 679
 #line 4461 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 680
 #line 4468 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 681
 #line 4473 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (lexer.Location);
 	  }
   break;
 case 682
 #line 4482 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
 	  }
   break;
 case 683
 #line 4487 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 688
 #line 4505 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 689
 #line 4509 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 691
 #line 4514 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 694
 #line 4533 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 695
 #line 4537 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 724
 #line 4578 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 725
 #line 4583 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 726
 #line 4588 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 727
 #line 4596 "cs-parser.jay"
   {
 		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
 		yyVal = new EmptyStatement (lexer.Location);
 	  }
   break;
 case 728
 #line 4604 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
   break;
 case 731
 #line 4617 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] is VarExpr)
 			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
 	  
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 732
 #line 4633 "cs-parser.jay"
   { 
 		/* Ok, the above "primary_expression" is there to get rid of*/
 		/* both reduce/reduce and shift/reduces in the grammar, it should*/
 		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
 		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
 		/* really) two shift/reduces appear.*/
 		/* */
 
 		/* So the super-trick is that primary_expression*/
 		/* can only be either a SimpleName or a MemberAccess. */
 		/* The MemberAccess case arises when you have a fully qualified type-name like 
 		/* Foo.Bar.Blah i;*/
 		/* SimpleName is when you have*/
 		/* Blah i;*/
 		
 		Expression expr = (Expression) yyVals[-1+yyTop];
 		if (yyVals[0+yyTop] == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				yyVal = new VarExpr (sn.Location);
 			else
 				yyVal = yyVals[-1+yyTop];
 		} else if (expr is ATypeNameExpression) {
 			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName (expr);
 			yyVal = null;
 		}
 	  }
   break;
 case 733
 #line 4663 "cs-parser.jay"
   {
 		ATypeNameExpression expr = yyVals[-1+yyTop] as ATypeNameExpression;
 
 		if (expr != null) {
 			yyVal = new ComposedCast (expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName ((Expression)yyVals[-1+yyTop]);
 			yyVal = expr;
 		}
 	  }
   break;
 case 734
 #line 4674 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] == null)
 			yyVal = yyVals[-1+yyTop];
 		else
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 735
 #line 4681 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 736
 #line 4685 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 737
 #line 4689 "cs-parser.jay"
   {
 		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 739
 #line 4698 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 740
 #line 4706 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreatePointer (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 741
 #line 4713 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 742
 #line 4720 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 743
 #line 4726 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 744
 #line 4733 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 746
 #line 4743 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		/* TODO
 	  }
   break;
 case 747
 #line 4748 "cs-parser.jay"
   {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
   break;
 case 752
 #line 4770 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 753
 #line 4779 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 754
 #line 4791 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
   break;
 case 755
 #line 4795 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 760
 #line 4812 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 762
 #line 4825 "cs-parser.jay"
   {
 		yyVal = new StackAlloc ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 763
 #line 4830 "cs-parser.jay"
   {
 		Report.Error (1575, GetLocation (yyVals[-1+yyTop]), "A stackalloc expression requires [] after type");
 		yyVal = new StackAlloc ((Expression) yyVals[0+yyTop], null, GetLocation (yyVals[-1+yyTop]));		
 	  }
   break;
 case 764
 #line 4838 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 765
 #line 4842 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 766
 #line 4846 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 767
 #line 4847 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 768
 #line 4856 "cs-parser.jay"
   {
 		ExpressionStatement s = yyVals[0+yyTop] as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation (yyVals[0+yyTop]));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 769
 #line 4869 "cs-parser.jay"
   {
 		Expression expr = (Expression) yyVals[0+yyTop];
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 770
 #line 4877 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 773
 #line 4891 "cs-parser.jay"
   { 
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 		
 		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 774
 #line 4900 "cs-parser.jay"
   {
 		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		
 		if (yyVals[-2+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 775
 #line 4913 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 776
 #line 4917 "cs-parser.jay"
   {
 		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
 		end_block (GetLocation (yyVals[0+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 777
 #line 4926 "cs-parser.jay"
   {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 779
 #line 4935 "cs-parser.jay"
   {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 780
 #line 4942 "cs-parser.jay"
   {
 		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 781
 #line 4949 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 782
 #line 4957 "cs-parser.jay"
   {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
   break;
 case 783
 #line 4961 "cs-parser.jay"
   {
 		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
 	  }
   break;
 case 784
 #line 4968 "cs-parser.jay"
   {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 		yyVal = labels;
 	  }
   break;
 case 785
 #line 4975 "cs-parser.jay"
   {
 		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 
 		yyVal = labels;
 	  }
   break;
 case 786
 #line 4985 "cs-parser.jay"
   {
 	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	 }
   break;
 case 787
 #line 4990 "cs-parser.jay"
   {
 		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 792
 #line 5004 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 793
 #line 5016 "cs-parser.jay"
   {
 		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 794
 #line 5024 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 		current_block.IsCompilerGenerated = true;
 	  }
   break;
 case 795
 #line 5029 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 796
 #line 5040 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		For f = new For ((Statement) yyVals[-6+yyTop], (BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		yyVal = end_block (GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 797
 #line 5052 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = end_block (current_block.StartLocation);
 	  }
   break;
 case 798
 #line 5059 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 800
 #line 5065 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 801
 #line 5072 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 803
 #line 5080 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 805
 #line 5085 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 809
 #line 5096 "cs-parser.jay"
   {
 	  	var sl = yyVals[-2+yyTop] as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
 			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
 	  	} else {
 	  		sl.Add ((Statement) yyVals[0+yyTop]);
 	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
 	  	}
 	  		
 		yyVal = sl;
 	  }
   break;
 case 810
 #line 5112 "cs-parser.jay"
   {
 		Report.Error (230, GetLocation (yyVals[-5+yyTop]), "Type and identifier are both required in a foreach statement");
 		yyVal = null;
 	  }
   break;
 case 811
 #line 5117 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-5+yyTop]));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		yyVal = li;
 	  }
   break;
 case 812
 #line 5127 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Foreach f = new Foreach ((Expression) yyVals[-6+yyTop], (LocalVariable) yyVals[-1+yyTop], (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 819
 #line 5150 "cs-parser.jay"
   {
 		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 820
 #line 5158 "cs-parser.jay"
   {
 		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 821
 #line 5166 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 822
 #line 5172 "cs-parser.jay"
   {
 		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 823
 #line 5177 "cs-parser.jay"
   {
 		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 824
 #line 5185 "cs-parser.jay"
   {
 		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 825
 #line 5193 "cs-parser.jay"
   {
 		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 826
 #line 5201 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (yyVals[-1+yyTop] == null) {
 			Report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 827
 #line 5217 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new YieldBreak (lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 830
 #line 5239 "cs-parser.jay"
   {
 		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
 	  }
   break;
 case 831
 #line 5243 "cs-parser.jay"
   {
 		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 832
 #line 5248 "cs-parser.jay"
   {
 		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]), true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 833
 #line 5253 "cs-parser.jay"
   {
 		Report.Error (1524, GetLocation (yyVals[-2+yyTop]), "Expected catch or finally");
 		yyVal = null;
 	  }
   break;
 case 834
 #line 5261 "cs-parser.jay"
   {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) yyVals[0+yyTop]);
 		yyVal = l;
 	  }
   break;
 case 835
 #line 5268 "cs-parser.jay"
   {
 		var l = (List<Catch>) yyVals[-1+yyTop];
 		
 		Catch c = (Catch) yyVals[0+yyTop];
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		yyVal = l;
 	  }
   break;
 case 838
 #line 5292 "cs-parser.jay"
   {
 		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 839
 #line 5296 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-3+yyTop]));
 		var c = new Catch (current_block, GetLocation (yyVals[-4+yyTop]));
 		c.TypeExpression = (FullNamedExpression) yyVals[-2+yyTop];
 
 		if (yyVals[-1+yyTop] != null) {
 			var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 840
 #line 5311 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 841
 #line 5315 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 842
 #line 5329 "cs-parser.jay"
   {
 		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 843
 #line 5336 "cs-parser.jay"
   {
 		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 844
 #line 5343 "cs-parser.jay"
   {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 845
 #line 5346 "cs-parser.jay"
   {
 		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 846
 #line 5353 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 847
 #line 5364 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 848
 #line 5373 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 849
 #line 5378 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 850
 #line 5390 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 851
 #line 5399 "cs-parser.jay"
   {
 		yyVal = current_variable;	  
 		current_variable = null;
 	  }
   break;
 case 852
 #line 5404 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (u);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 853
 #line 5413 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (u, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = u;
 	  }
   break;
 case 854
 #line 5425 "cs-parser.jay"
   {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
   break;
 case 855
 #line 5429 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		yyVal = current_variable;
 	  }
   break;
 case 856
 #line 5440 "cs-parser.jay"
   {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 857
 #line 5452 "cs-parser.jay"
   {
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 858
 #line 5463 "cs-parser.jay"
   {
 	        lexer.query_parsing = false;
 		yyVal = yyVals[-1+yyTop];
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 859
 #line 5470 "cs-parser.jay"
   {
 	        yyVal = yyVals[-1+yyTop];
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 860
 #line 5479 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 861
 #line 5487 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 862
 #line 5502 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 863
 #line 5510 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 864
 #line 5525 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 865
 #line 5529 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 866
 #line 5540 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 867
 #line 5544 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
 			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 868
 #line 5561 "cs-parser.jay"
   {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
 		
 		if (yyVals[0+yyTop] != null)
 			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 				
 		if (yyVals[-2+yyTop] != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		yyVal = head;
 	  }
   break;
 case 870
 #line 5577 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 871
 #line 5585 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 872
 #line 5589 "cs-parser.jay"
   {
 		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 873
 #line 5596 "cs-parser.jay"
   {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
   break;
 case 874
 #line 5604 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 875
 #line 5611 "cs-parser.jay"
   {
 		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 879
 #line 5627 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 885
 #line 5643 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 886
 #line 5647 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 887
 #line 5661 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 888
 #line 5665 "cs-parser.jay"
   {
 		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 889
 #line 5675 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 890
 #line 5683 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 891
 #line 5691 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 892
 #line 5699 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
   break;
 case 893
 #line 5735 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 894
 #line 5743 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 895
 #line 5751 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 896
 #line 5759 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;		
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO
 			
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
   break;
 case 898
 #line 5803 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 899
 #line 5810 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 900
 #line 5814 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 902
 #line 5825 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 903
 #line 5832 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	  }
   break;
 case 905
 #line 5841 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
   break;
 case 906
 #line 5848 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	 }
   break;
 case 907
 #line 5856 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 908
 #line 5860 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 909
 #line 5864 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 910
 #line 5871 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 911
 #line 5875 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 912
 #line 5879 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 914
 #line 5888 "cs-parser.jay"
   {
 		/* query continuation block is not linked with query block but with block*/
 		/* before. This means each query can use same range variable names for*/
 		/* different identifiers.*/
 
 		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
   break;
 case 915
 #line 5904 "cs-parser.jay"
   {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
   			next = (Linq.AQueryClause)yyVals[0+yyTop]
   		};
 	  }
   break;
 case 918
 #line 5930 "cs-parser.jay"
   { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		/* (ref object retval)*/
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, /* generic*/
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }
   break;
 case 919
 #line 5960 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  }
   break;
 case 920
 #line 5971 "cs-parser.jay"
   {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
   break;
 #line default
         }
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
     continue_yyLoop
     }
   }
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="45" endline="6154">
<![CDATA[
 		static readonly object ModifierNone = 0;
 	
 		NamespaceEntry  current_namespace;
 		TypeContainer   current_container;
 		DeclSpace	current_class;
 		PropertyBase current_property;
 		EventProperty current_event;
 		EventField current_event_field;
 		FieldBase current_field;
 	
 		/// <summary>
 		///   Current block is used to add statements as we find
 		///   them.  
 		/// </summary>
 		Block      current_block;
 		
 		BlockVariableDeclaration current_variable;
 
 		Delegate   current_delegate;
 		
 		AnonymousMethodExpression current_anonymous_method;
 
 		/// <summary>
 		///   This is used by the unary_expression code to resolve
 		///   a name against a parameter.  
 		/// </summary>
 		
 		// FIXME
 		// on all places, especially when some parameters are autogenerated.
 		ParametersCompiled current_local_parameters;
 
 		bool parsing_anonymous_method;
 
 		///
 		/// An out-of-band stack.
 		///
 		static Stack<object> oob_stack;
 
 		///
 		/// Controls the verbosity of the errors produced by the parser
 		///
 		static public int yacc_verbose_flag;
 
 		/// 
 		/// Used by the interactive shell, flags whether EOF was reached
 		/// and an error was produced
 		///
 		public bool UnexpectedEOF;
 
 		///
 		/// The current file.
 		///
 		CompilationUnit file;
 
 		///
 		/// Temporary Xml documentation cache.
 		/// For enum types, we need one more temporary store.
 		///
 		string tmpComment;
 		string enumTypeComment;
 	       		
 		/// Current attribute target
 		string current_attr_target;
 		
 		/// assembly and module attribute definitions are enabled
 		bool global_attrs_enabled = true;
 		
 		ParameterModifierType valid_param_mod;
 		
 		bool default_parameter_used;
 
 		/// When using the interactive parser, this holds the
 		/// resulting expression
 		public object InteractiveResult;
 
 		//
 		// Keeps track of global data changes to undo on parser error
 		//
 		public Undo undo;
 		
 		Stack<Linq.QueryBlock> linq_clause_blocks;
 
 		// A counter to create new class names in interactive mode
 		static int class_count;
 		
 		ModuleContainer module;
 		
 		CompilerContext compiler;
 		
 		//
 		// Instead of allocating carrier array everytime we
 		// share the bucket for very common constructs which can never
 		// be recursive
 		//
 		static List<Parameter> parameters_bucket = new List<Parameter> (6);
   protected static  int yyFinal = 9;
  // Put this array into a separate class so it is only initialized if debugging is actually used
  // Use MarshalByRefObject to disable inlining
  class YYRules 
   public static  string [] yyRule = {
     "$accept 
     "compilation_unit 
     "compilation_unit 
     "compilation_unit 
     "compilation_unit 
     "$$1 
     "compilation_unit 
     "opt_EOF 
     "opt_EOF 
     "outer_declarations 
     "outer_declarations 
     "outer_declaration 
     "outer_declaration 
     "outer_declaration 
     "extern_alias_directives 
     "extern_alias_directives 
     "extern_alias_directive 
     "extern_alias_directive 
     "using_directives 
     "using_directives 
     "using_directive 
     "using_directive 
     "using_alias_directive 
     "using_alias_directive 
     "using_namespace_directive 
     "$$2 
     "namespace_declaration 
     "qualified_identifier 
     "qualified_identifier 
     "qualified_identifier 
     "opt_semicolon 
     "opt_semicolon 
     "opt_comma 
     "opt_comma 
     "namespace_name 
     "$$3 
     "namespace_body 
     "opt_using_directives 
     "opt_using_directives 
     "opt_extern_alias_directives 
     "opt_extern_alias_directives 
     "opt_namespace_member_declarations 
     "opt_namespace_member_declarations 
     "namespace_member_declarations 
     "namespace_member_declarations 
     "namespace_member_declaration 
     "namespace_member_declaration 
     "namespace_member_declaration 
     "type_declaration 
     "type_declaration 
     "type_declaration 
     "type_declaration 
     "type_declaration 
     "global_attributes 
     "opt_attributes 
     "opt_attributes 
     "attribute_sections 
     "attribute_sections 
     "attribute_section 
     "attribute_section 
     "attribute_target_specifier 
     "attribute_target 
     "attribute_target 
     "attribute_target 
     "attribute_target 
     "attribute_list 
     "attribute_list 
     "$$4 
     "attribute 
     "attribute_name 
     "opt_attribute_arguments 
     "opt_attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "positional_or_named_argument 
     "positional_or_named_argument 
     "$$5 
     "named_attribute_argument 
     "named_argument 
     "opt_named_modifier 
     "opt_named_modifier 
     "opt_named_modifier 
     "opt_class_member_declarations 
     "opt_class_member_declarations 
     "class_member_declarations 
     "class_member_declarations 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "$$6 
     "$$7 
     "$$8 
     "$$9 
     "struct_declaration 
     "struct_declaration 
     "$$10 
     "struct_body 
     "opt_struct_member_declarations 
     "opt_struct_member_declarations 
     "struct_member_declarations 
     "struct_member_declarations 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "$$11 
     "constant_declaration 
     "opt_constant_declarators 
     "opt_constant_declarators 
     "constant_declarators 
     "constant_declarators 
     "constant_declarator 
     "$$12 
     "constant_initializer 
     "constant_initializer 
     "constant_initializer_expr 
     "constant_initializer_expr 
     "$$13 
     "field_declaration 
     "$$14 
     "field_declaration 
     "field_declaration 
     "opt_field_initializer 
     "$$15 
     "opt_field_initializer 
     "opt_field_declarators 
     "opt_field_declarators 
     "field_declarators 
     "field_declarators 
     "field_declarator 
     "$$16 
     "field_declarator 
     "opt_fixed_field_declarators 
     "opt_fixed_field_declarators 
     "fixed_field_declarators 
     "fixed_field_declarators 
     "fixed_field_declarator 
     "$$17 
     "fixed_field_size 
     "fixed_field_size 
     "variable_initializer 
     "variable_initializer 
     "variable_initializer 
     "$$18 
     "method_declaration 
     "$$19 
     "$$20 
     "method_header 
     "$$21 
     "$$22 
     "method_header 
     "method_header 
     "method_body 
     "method_body 
     "opt_formal_parameter_list 
     "opt_formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "fixed_parameters 
     "fixed_parameters 
     "fixed_parameter 
     "fixed_parameter 
     "fixed_parameter 
     "$$23 
     "fixed_parameter 
     "opt_parameter_modifier 
     "opt_parameter_modifier 
     "parameter_modifiers 
     "parameter_modifiers 
     "parameter_modifier 
     "parameter_modifier 
     "parameter_modifier 
     "parameter_array 
     "parameter_array 
     "parameter_array 
     "params_modifier 
     "params_modifier 
     "params_modifier 
     "arglist_modifier 
     "$$24 
     "$$25 
     "$$26 
     "property_declaration 
     "$$27 
     "$$28 
     "$$29 
     "indexer_declaration 
     "accessor_declarations 
     "accessor_declarations 
     "accessor_declarations 
     "accessor_declarations 
     "accessor_declarations 
     "$$30 
     "get_accessor_declaration 
     "$$31 
     "set_accessor_declaration 
     "accessor_body 
     "accessor_body 
     "accessor_body 
     "$$32 
     "$$33 
     "$$34 
     "$$35 
     "interface_declaration 
     "interface_declaration 
     "opt_interface_member_declarations 
     "opt_interface_member_declarations 
     "interface_member_declarations 
     "interface_member_declarations 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "$$36 
     "operator_declaration 
     "operator_body 
     "operator_body 
     "operator_type 
     "operator_type 
     "$$37 
     "operator_declarator 
     "operator_declarator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "$$38 
     "conversion_operator_declarator 
     "$$39 
     "conversion_operator_declarator 
     "conversion_operator_declarator 
     "conversion_operator_declarator 
     "constructor_declaration 
     "$$40 
     "$$41 
     "constructor_declarator 
     "constructor_body 
     "constructor_body 
     "opt_constructor_initializer 
     "opt_constructor_initializer 
     "$$42 
     "constructor_initializer 
     "$$43 
     "constructor_initializer 
     "constructor_initializer 
     "$$44 
     "destructor_declaration 
     "$$45 
     "event_declaration 
     "$$46 
     "$$47 
     "event_declaration 
     "opt_event_initializer 
     "$$48 
     "opt_event_initializer 
     "opt_event_declarators 
     "opt_event_declarators 
     "event_declarators 
     "event_declarators 
     "event_declarator 
     "$$49 
     "event_declarator 
     "$$50 
     "event_variable_initializer 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "$$51 
     "add_accessor_declaration 
     "$$52 
     "remove_accessor_declaration 
     "event_accessor_block 
     "event_accessor_block 
     "$$53 
     "$$54 
     "$$55 
     "enum_declaration 
     "opt_enum_base 
     "opt_enum_base 
     "opt_enum_base 
     "opt_enum_member_declarations 
     "opt_enum_member_declarations 
     "opt_enum_member_declarations 
     "enum_member_declarations 
     "enum_member_declarations 
     "enum_member_declaration 
     "$$56 
     "enum_member_declaration 
     "$$57 
     "$$58 
     "$$59 
     "delegate_declaration 
     "opt_nullable 
     "opt_nullable 
     "namespace_or_type_name 
     "namespace_or_type_name 
     "member_name 
     "member_name 
     "type_name 
     "opt_type_argument_list 
     "opt_type_argument_list 
     "opt_type_argument_list 
     "type_arguments 
     "type_arguments 
     "$$60 
     "type_declaration_name 
     "member_declaration_name 
     "method_declaration_name 
     "method_declaration_name 
     "indexer_declaration_name 
     "indexer_declaration_name 
     "explicit_interface 
     "explicit_interface 
     "explicit_interface 
     "opt_type_parameter_list 
     "opt_type_parameter_list 
     "type_parameters 
     "type_parameters 
     "type_parameter 
     "type_parameter 
     "type_and_void 
     "type_and_void 
     "member_type 
     "type 
     "type 
     "simple_type 
     "simple_type 
     "parameter_type 
     "parameter_type 
     "type_expression_or_array 
     "type_expression_or_array 
     "type_expression 
     "type_expression 
     "type_expression 
     "type_expression 
     "type_expression 
     "type_list 
     "type_list 
     "base_type_name 
     "base_type_name 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression_or_type 
     "primary_expression_or_type 
     "primary_expression_or_type 
     "literal 
     "literal 
     "literal 
     "boolean_literal 
     "boolean_literal 
     "open_parens_any 
     "open_parens_any 
     "close_parens 
     "close_parens 
     "parenthesized_expression 
     "parenthesized_expression 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "invocation_expression 
     "opt_object_or_collection_initializer 
     "opt_object_or_collection_initializer 
     "object_or_collection_initializer 
     "object_or_collection_initializer 
     "opt_member_initializer_list 
     "opt_member_initializer_list 
     "member_initializer_list 
     "member_initializer_list 
     "member_initializer_list 
     "member_initializer 
     "member_initializer 
     "member_initializer 
     "member_initializer 
     "member_initializer 
     "initializer_value 
     "initializer_value 
     "opt_argument_list 
     "opt_argument_list 
     "argument_list 
     "argument_list 
     "argument_list 
     "argument_list 
     "argument_list 
     "argument 
     "argument 
     "argument_or_named_argument 
     "argument_or_named_argument 
     "non_simple_argument 
     "non_simple_argument 
     "non_simple_argument 
     "non_simple_argument 
     "variable_reference 
     "element_access 
     "expression_list 
     "expression_list 
     "expression_list 
     "expression_list_arguments 
     "expression_list_arguments 
     "expression_list_argument 
     "expression_list_argument 
     "this_access 
     "base_access 
     "base_access 
     "post_increment_expression 
     "post_decrement_expression 
     "object_or_delegate_creation_expression 
     "object_or_delegate_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "$$61 
     "new_expr_type 
     "anonymous_type_expression 
     "anonymous_type_parameters_opt_comma 
     "anonymous_type_parameters_opt_comma 
     "anonymous_type_parameters_opt 
     "anonymous_type_parameters_opt 
     "anonymous_type_parameters 
     "anonymous_type_parameters 
     "anonymous_type_parameter 
     "anonymous_type_parameter 
     "anonymous_type_parameter 
     "anonymous_type_parameter 
     "opt_rank_specifier 
     "opt_rank_specifier 
     "rank_specifiers 
     "rank_specifiers 
     "rank_specifier 
     "rank_specifier 
     "dim_separators 
     "dim_separators 
     "opt_array_initializer 
     "opt_array_initializer 
     "array_initializer 
     "array_initializer 
     "variable_initializer_list 
     "variable_initializer_list 
     "$$62 
     "typeof_expression 
     "typeof_type_expression 
     "typeof_type_expression 
     "typeof_type_expression 
     "unbound_type_name 
     "unbound_type_name 
     "unbound_type_name 
     "unbound_type_name 
     "unbound_type_name 
     "generic_dimension 
     "qualified_alias_member 
     "sizeof_expression 
     "checked_expression 
     "unchecked_expression 
     "pointer_member_access 
     "$$63 
     "anonymous_method_expression 
     "opt_anonymous_method_signature 
     "opt_anonymous_method_signature 
     "$$64 
     "anonymous_method_signature 
     "default_value_expression 
     "unary_expression 
     "unary_expression 
     "unary_expression 
     "unary_expression 
     "cast_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "multiplicative_expression 
     "multiplicative_expression 
     "multiplicative_expression 
     "multiplicative_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "shift_expression 
     "shift_expression 
     "shift_expression 
     "relational_expression 
     "relational_expression 
     "relational_expression 
     "relational_expression 
     "relational_expression 
     "equality_expression 
     "equality_expression 
     "equality_expression 
     "and_expression 
     "and_expression 
     "exclusive_or_expression 
     "exclusive_or_expression 
     "inclusive_or_expression 
     "inclusive_or_expression 
     "conditional_and_expression 
     "conditional_and_expression 
     "conditional_or_expression 
     "conditional_or_expression 
     "null_coalescing_expression 
     "null_coalescing_expression 
     "conditional_expression 
     "conditional_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "lambda_parameter_list 
     "lambda_parameter_list 
     "lambda_parameter 
     "lambda_parameter 
     "lambda_parameter 
     "opt_lambda_parameter_list 
     "opt_lambda_parameter_list 
     "lambda_expression_body 
     "lambda_expression_body 
     "$$65 
     "lambda_expression_body_simple 
     "expression_or_error 
     "expression_or_error 
     "$$66 
     "lambda_expression 
     "$$67 
     "$$68 
     "lambda_expression 
     "expression 
     "expression 
     "non_assignment_expression 
     "non_assignment_expression 
     "non_assignment_expression 
     "non_assignment_expression 
     "constant_expression 
     "boolean_expression 
     "$$69 
     "$$70 
     "$$71 
     "$$72 
     "class_declaration 
     "opt_partial 
     "opt_partial 
     "opt_modifiers 
     "opt_modifiers 
     "modifiers 
     "modifiers 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "opt_class_base 
     "opt_class_base 
     "opt_type_parameter_constraints_clauses 
     "opt_type_parameter_constraints_clauses 
     "opt_type_parameter_constraints_clauses 
     "type_parameter_constraints_clauses 
     "type_parameter_constraints_clauses 
     "type_parameter_constraints_clause 
     "type_parameter_constraints 
     "type_parameter_constraints 
     "type_parameter_constraint 
     "type_parameter_constraint 
     "type_parameter_constraint 
     "type_parameter_constraint 
     "opt_type_parameter_variance 
     "opt_type_parameter_variance 
     "type_parameter_variance 
     "type_parameter_variance 
     "$$73 
     "block 
     "block_end 
     "block_end 
     "$$74 
     "block_prepared 
     "opt_statement_list 
     "opt_statement_list 
     "statement_list 
     "statement_list 
     "statement 
     "statement 
     "statement 
     "statement 
     "interactive_statement_list 
     "interactive_statement_list 
     "interactive_statement 
     "interactive_statement 
     "interactive_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "embedded_statement 
     "embedded_statement 
     "embedded_statement 
     "embedded_statement 
     "empty_statement 
     "$$75 
     "labeled_statement 
     "variable_type 
     "variable_type 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "pointer_stars 
     "pointer_stars 
     "pointer_star 
     "$$76 
     "block_variable_declaration 
     "$$77 
     "block_variable_declaration 
     "opt_local_variable_initializer 
     "opt_local_variable_initializer 
     "opt_local_variable_initializer 
     "opt_variable_declarators 
     "opt_variable_declarators 
     "variable_declarators 
     "variable_declarators 
     "variable_declarator 
     "variable_declarator 
     "const_variable_initializer 
     "const_variable_initializer 
     "opt_const_declarators 
     "opt_const_declarators 
     "const_declarators 
     "const_declarators 
     "const_declarator 
     "block_variable_initializer 
     "block_variable_initializer 
     "block_variable_initializer 
     "expression_statement 
     "expression_statement 
     "interactive_expression_statement 
     "interactive_expression_statement 
     "statement_expression 
     "interactive_statement_expression 
     "interactive_statement_expression 
     "selection_statement 
     "selection_statement 
     "if_statement 
     "if_statement 
     "$$78 
     "switch_statement 
     "opt_switch_sections 
     "opt_switch_sections 
     "switch_sections 
     "switch_sections 
     "switch_sections 
     "$$79 
     "switch_section 
     "switch_labels 
     "switch_labels 
     "switch_label 
     "switch_label 
     "iteration_statement 
     "iteration_statement 
     "iteration_statement 
     "iteration_statement 
     "while_statement 
     "do_statement 
     "$$80 
     "for_statement 
     "for_statement_cont 
     "for_statement_cont 
     "opt_for_initializer 
     "opt_for_initializer 
     "$$81 
     "for_initializer 
     "for_initializer 
     "opt_for_condition 
     "opt_for_condition 
     "opt_for_iterator 
     "opt_for_iterator 
     "for_iterator 
     "statement_expression_list 
     "statement_expression_list 
     "foreach_statement 
     "$$82 
     "foreach_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "break_statement 
     "continue_statement 
     "goto_statement 
     "goto_statement 
     "goto_statement 
     "return_statement 
     "throw_statement 
     "yield_statement 
     "yield_statement 
     "opt_expression 
     "opt_expression 
     "try_statement 
     "try_statement 
     "try_statement 
     "try_statement 
     "catch_clauses 
     "catch_clauses 
     "opt_identifier 
     "opt_identifier 
     "catch_clause 
     "$$83 
     "catch_clause 
     "catch_clause 
     "checked_statement 
     "unchecked_statement 
     "$$84 
     "unsafe_statement 
     "lock_statement 
     "$$85 
     "$$86 
     "fixed_statement 
     "$$87 
     "$$88 
     "using_statement 
     "using_statement 
     "using_or_fixed_variable_initializer 
     "using_or_fixed_variable_initializer 
     "query_expression 
     "query_expression 
     "query_expression 
     "query_expression 
     "first_from_clause 
     "first_from_clause 
     "nested_from_clause 
     "nested_from_clause 
     "$$89 
     "from_clause 
     "$$90 
     "from_clause 
     "query_body 
     "query_body 
     "query_body 
     "$$91 
     "select_or_group_clause 
     "$$92 
     "$$93 
     "select_or_group_clause 
     "opt_query_body_clauses 
     "opt_query_body_clauses 
     "query_body_clauses 
     "query_body_clauses 
     "query_body_clause 
     "query_body_clause 
     "query_body_clause 
     "query_body_clause 
     "query_body_clause 
     "$$94 
     "let_clause 
     "$$95 
     "where_clause 
     "$$96 
     "$$97 
     "$$98 
     "join_clause 
     "$$99 
     "$$100 
     "$$101 
     "join_clause 
     "opt_join_into 
     "opt_join_into 
     "$$102 
     "orderby_clause 
     "orderings 
     "$$103 
     "orderings 
     "orderings_then_by 
     "$$104 
     "orderings_then_by 
     "order_by 
     "order_by 
     "order_by 
     "then_by 
     "then_by 
     "then_by 
     "opt_query_continuation 
     "$$105 
     "opt_query_continuation 
     "interactive_parsing 
     "interactive_parsing 
     "$$106 
     "interactive_parsing 
     "$$107 
     "interactive_parsing 
     "interactive_compilation_unit 
     "interactive_compilation_unit 
     "interactive_compilation_unit 
     "interactive_compilation_unit 
     "opt_COMPLETE_COMPLETION 
     "opt_COMPLETE_COMPLETION 
     "close_brace_or_complete_completion 
     "close_brace_or_complete_completion 
   };
  public static string getRule (int index) {
     return yyRule [index];
  }
 }
   protected static  string [] yyNames = {    
     "end-of-file",null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,"EOF","NONE","ERROR",
     "FIRST_KEYWORD","ABSTRACT","AS","ADD","BASE","BOOL","BREAK","BYTE",
     "CASE","CATCH","CHAR","CHECKED","CLASS","CONST","CONTINUE","DECIMAL",
     "DEFAULT","DELEGATE","DO","DOUBLE","ELSE","ENUM","EVENT","EXPLICIT",
     "EXTERN","FALSE","FINALLY","FIXED","FLOAT","FOR","FOREACH","GOTO",
     "IF","IMPLICIT","IN","INT","INTERFACE","INTERNAL","IS","LOCK","LONG",
     "NAMESPACE","NEW","NULL","OBJECT","OPERATOR","OUT","OVERRIDE",
     "PARAMS","PRIVATE","PROTECTED","PUBLIC","READONLY","REF","RETURN",
     "REMOVE","SBYTE","SEALED","SHORT","SIZEOF","STACKALLOC","STATIC",
     "STRING","STRUCT","SWITCH","THIS","THROW","TRUE","TRY","TYPEOF",
     "UINT","ULONG","UNCHECKED","UNSAFE","USHORT","USING","VIRTUAL","VOID",
     "VOLATILE","WHERE","WHILE","ARGLIST","PARTIAL","ARROW","FROM",
     "FROM_FIRST","JOIN","ON","EQUALS","SELECT","GROUP","BY","LET",
     "ORDERBY","ASCENDING","DESCENDING","INTO","INTERR_NULLABLE",
     "EXTERN_ALIAS","ASYNC","GET","SET","LAST_KEYWORD","OPEN_BRACE",
     "CLOSE_BRACE","OPEN_BRACKET","CLOSE_BRACKET","OPEN_PARENS",
     "CLOSE_PARENS","DOT","COMMA","COLON","SEMICOLON","TILDE","PLUS",
     "MINUS","BANG","ASSIGN","OP_LT","OP_GT","BITWISE_AND","BITWISE_OR",
     "STAR","PERCENT","DIV","CARRET","INTERR","DOUBLE_COLON","OP_INC",
     "OP_DEC","OP_SHIFT_LEFT","OP_SHIFT_RIGHT","OP_LE","OP_GE","OP_EQ",
     "OP_NE","OP_AND","OP_OR","OP_MULT_ASSIGN","OP_DIV_ASSIGN",
     "OP_MOD_ASSIGN","OP_ADD_ASSIGN","OP_SUB_ASSIGN",
     "OP_SHIFT_LEFT_ASSIGN","OP_SHIFT_RIGHT_ASSIGN","OP_AND_ASSIGN",
     "OP_XOR_ASSIGN","OP_OR_ASSIGN","OP_PTR","OP_COALESCING",
     "OP_GENERICS_LT","OP_GENERICS_LT_DECL","OP_GENERICS_GT","LITERAL",
     "IDENTIFIER","OPEN_PARENS_LAMBDA","OPEN_PARENS_CAST",
     "GENERIC_DIMENSION","DEFAULT_COLON","OPEN_BRACKET_EXPR",
     "EVAL_STATEMENT_PARSER","EVAL_COMPILATION_UNIT_PARSER",
     "EVAL_USING_DECLARATIONS_UNIT_PARSER","GENERATE_COMPLETION",
     "COMPLETE_COMPLETION","UMINUS",
   };
 
   /** index-checked interface to yyNames[].
       @param token single character or %token value.
       @return token name or [illegal] or [unknown].
     */
   public static string yyname (int token) {
     if ((token < 0) || (token > yyNames.Length)) return "[illegal]";
     string name;
     if ((name = yyNames[token]) != null) return name;
     return "[unknown]";
   }
 
   int yyExpectingState;
   /** computes list of expected tokens on error by tracing the tables.
       @param state for which to compute the list.
       @return list of token names.
     */
   protected int [] yyExpectingTokens (int state){
     int token, n, len = 0;
     bool[] ok = new bool[yyNames.Length];
     if ((n = yySindex[state]) != 0)
       for (token = n < 0 ? -n 
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
     if ((n = yyRindex[state]) != 0)
       for (token = n < 0 ? -n 
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
     int [] result = new int [len];
     for (n = token = 0; n < len;  ++ token)
       if (ok[token]) result[n++] = token;
     return result;
   }
   protected string[] yyExpecting (int state) {
     int [] tokens = yyExpectingTokens (state);
     string [] result = new string[tokens.Length];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n]];
     return result;
   }
 
   /** the generated parser, with debugging messages.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @param yydebug debug message writer implementing yyDebug, or null.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
 				 {
     this.debug = (yydebug.yyDebug)yyd;
     return yyparse(yyLex);
   }
 
   /** initial size and increment of the state/value stack [default 256].
       This is not final so that it can be overwritten outside of invocations
       of yyparse().
     */
   protected int yyMax;
 
   /** executed at the beginning of a reduce action.
       Used as $$ = yyDefault($1), prior to the user-specified action, if any.
       Can be overwritten to provide deep copy, etc.
       @param first value for $1, or null.
       @return first.
     */
   protected Object yyDefault (Object first) {
     return first;
   }
 
 	static int[] global_yyStates;
 	static object[] global_yyVals;
 	protected bool use_global_stacks;
 	object[] yyVals;					// value stack
 	object yyVal;						// value stack ptr
 	int yyToken;						// current input
 	int yyTop;
 
   /** the generated parser.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex)
   {
     if (yyMax <= 0) yyMax = 256;		// initial size
     int yyState = 0;                   // state stack ptr
     int [] yyStates;               	// state stack 
     yyVal = null;
     yyToken = -1;
     int yyErrorFlag = 0;				// #tks to shift
 	if (use_global_stacks && global_yyStates != null) {
 		yyVals = global_yyVals;
 		yyStates = global_yyStates;
    } else {
 		yyVals = new object [yyMax];
 		yyStates = new int [yyMax];
 		if (use_global_stacks) {
 			global_yyVals = yyVals;
 			global_yyStates = yyStates;
 		}
 	}
 
     /*yyLoop
       if (yyTop >= yyStates.Length) {			// dynamically increase
         global
         global
       }
       yyStates[yyTop] = yyState;
       yyVals[yyTop] = yyVal;
       if (debug != null) debug.push(yyState, yyVal);
 
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 case 5
 #line 375 "cs-parser.jay"
   { Lexer.CompleteOnEOF = false; }
   break;
 case 7
 #line 380 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 8
 #line 384 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 16
 #line 407 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop]; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
   break;
 case 17
 #line 420 "cs-parser.jay"
   {
 	  	syntax_error (GetLocation (yyVals[-1+yyTop]), "`alias' expected");   /* TODO
 	  }
   break;
 case 20
 #line 432 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 21
 #line 437 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 22
 #line 445 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 23
 #line 450 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 24
 #line 458 "cs-parser.jay"
   {
 		current_namespace.AddUsing ((MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 25
 #line 470 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (yyVals[-2+yyTop] != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 26
 #line 483 "cs-parser.jay"
   { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 27
 #line 492 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName (lt.Value, lt.Location);
 	  }
   break;
 case 28
 #line 497 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 29
 #line 502 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new MemberName ("<invalid>", lexer.Location);
 	  }
   break;
 case 34
 #line 520 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		yyVal = name;
 	  }
   break;
 case 35
 #line 532 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 45
 #line 564 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			DeclSpace ds = (DeclSpace)yyVals[0+yyTop];
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 46
 #line 576 "cs-parser.jay"
   {
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 47
 #line 580 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	 }
   break;
 case 53
 #line 606 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			Attributes attrs = (Attributes)yyVals[0+yyTop];
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 54
 #line 623 "cs-parser.jay"
   {
 		global_attrs_enabled = false;
 		yyVal = null;
       }
   break;
 case 55
 #line 628 "cs-parser.jay"
   { 
 		global_attrs_enabled = false;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 56
 #line 637 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					yyVal = null;
 				} else {
 					yyVal = new Attributes (sect);
 				}
 				if (yyVal == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				yyVal = new Attributes (sect);
 			}		
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 57
 #line 664 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = yyVals[-1+yyTop] as Attributes;
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					yyVal = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			yyVal = attrs;
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 58
 #line 695 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
  	  }
   break;
 case 59
 #line 699 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 60
 #line 706 "cs-parser.jay"
   {
 		current_attr_target = (string)yyVals[-1+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 61
 #line 714 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
   break;
 case 62
 #line 718 "cs-parser.jay"
   { yyVal = "event"; }
   break;
 case 63
 #line 719 "cs-parser.jay"
   { yyVal = "return"; }
   break;
 case 64
 #line 721 "cs-parser.jay"
   {
 		string name = GetTokenName (yyToken);
 		yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 65
 #line 729 "cs-parser.jay"
   {
 		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
 	  }
   break;
 case 66
 #line 733 "cs-parser.jay"
   {
 		var attrs = (List<Attribute>) yyVals[-2+yyTop];
 		attrs.Add ((Attribute) yyVals[0+yyTop]);
 
 		yyVal = attrs;
 	  }
   break;
 case 67
 #line 743 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 68
 #line 747 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) yyVals[-2+yyTop];
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) yyVals[0+yyTop];
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			yyVal = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			/* FIXME
 			yyVal = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			yyVal = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
   break;
 case 69
 #line 770 "cs-parser.jay"
   { /* reserved attribute name or identifier
   break;
 case 70
 #line 774 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 71
 #line 776 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 72
 #line 783 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 73
 #line 785 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = new Arguments [] { a, null };
 	  }
   break;
 case 74
 #line 791 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);  
 		yyVal = new Arguments [] { null, a };
 	  }
   break;
 case 75
 #line 797 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 76
 #line 811 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 77
 #line 823 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 79
 #line 831 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 80
 #line 835 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
 	  }
   break;
 case 81
 #line 844 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
 			
 		/* Avoid boxing in common case (no modifier)*/
 		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
 	  }
   break;
 case 82
 #line 857 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 83
 #line 859 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Ref;
 	  }
   break;
 case 84
 #line 863 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Out;
 	  }
   break;
 case 99
 #line 891 "cs-parser.jay"
   {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		yyVal = null;
 		lexer.parsing_generic_declaration = false;
 	  }
   break;
 case 100
 #line 904 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 101
 #line 908 "cs-parser.jay"
   { 
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 102
 #line 914 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 103
 #line 925 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 104
 #line 931 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 105
 #line 936 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	  }
   break;
 case 106
 #line 943 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 107
 #line 948 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 122
 #line 985 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var mod = (Modifiers) yyVals[-3+yyTop];
 		current_field = new Const (current_class, (FullNamedExpression) yyVals[-1+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_field;
 	  }
   break;
 case 123
 #line 998 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_field = null;
 	  }
   break;
 case 126
 #line 1017 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 127
 #line 1021 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 128
 #line 1028 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 129
 #line 1037 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 130
 #line 1041 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 131
 #line 1046 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		yyVal = null;
 	  }
   break;
 case 134
 #line 1061 "cs-parser.jay"
   {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) yyVals[-1+yyTop];
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation (yyVals[-1+yyTop]), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new Field (current_class, type, (Modifiers) yyVals[-2+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-3+yyTop]);
 		current_container.AddField (current_field);
 		yyVal = current_field;
 	  }
   break;
 case 135
 #line 1076 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 		current_field = null;
 	  }
   break;
 case 136
 #line 1089 "cs-parser.jay"
   { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new FixedField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop],
 			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 			
 		current_container.AddField (current_field);
 	  }
   break;
 case 137
 #line 1100 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 	    current_field = null;
 	  }
   break;
 case 138
 #line 1115 "cs-parser.jay"
   {
 		Report.Error (1641, GetLocation (yyVals[-1+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
   break;
 case 140
 #line 1123 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 141
 #line 1129 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) yyVals[0+yyTop];
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
   break;
 case 144
 #line 1144 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 145
 #line 1148 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 146
 #line 1155 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 147
 #line 1161 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 148
 #line 1165 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 151
 #line 1180 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 152
 #line 1184 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 153
 #line 1191 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	  
 		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 154
 #line 1200 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 155
 #line 1204 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 156
 #line 1210 "cs-parser.jay"
   {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		yyVal = null;
 	  }
   break;
 case 159
 #line 1220 "cs-parser.jay"
   {
 		/* It has to be here for the parent to safely restore artificial block*/
 	  	Error_SyntaxError (yyToken);
 	  	yyVal = null;
 	  }
   break;
 case 160
 #line 1228 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 161
 #line 1233 "cs-parser.jay"
   {
 		Method method = (Method) yyVals[-2+yyTop];
 		method.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 162
 #line 1254 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 163
 #line 1258 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 164
 #line 1262 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) yyVals[-7+yyTop], current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		} else if (yyVals[0+yyTop] != null) {
 			Report.Error (80, GetLocation (yyVals[0+yyTop]),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) yyVals[-7+yyTop], (Modifiers) yyVals[-8+yyTop],
 				     name, current_local_parameters, (Attributes) yyVals[-9+yyTop]);
 				     
 		if (yyVals[0+yyTop] != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 165
 #line 1299 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 166
 #line 1303 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 167
 #line 1307 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		if (yyVals[-1+yyTop] != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		}
 
 		var modifiers = (Modifiers) yyVals[-9+yyTop];
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				     modifiers, name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		/* TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-8+yyTop]));
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 168
 #line 1362 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-4+yyTop]));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) yyVals[-5+yyTop],
 					    0, name, (ParametersCompiled) yyVals[-1+yyTop], (Attributes) yyVals[-7+yyTop]);
 
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		yyVal = method;
 	  }
   break;
 case 170
 #line 1381 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 171
 #line 1385 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 173
 #line 1391 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 174
 #line 1396 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
   break;
 case 175
 #line 1403 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[0+yyTop])));
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 176
 #line 1409 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
 	  }
   break;
 case 177
 #line 1416 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 178
 #line 1426 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[-2+yyTop])) }, true);
 	  }
   break;
 case 179
 #line 1432 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 180
 #line 1441 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
 	  }
   break;
 case 181
 #line 1445 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[0+yyTop])) }, true);
 	  }
   break;
 case 182
 #line 1449 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 183
 #line 1457 "cs-parser.jay"
   {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		yyVal = parameters_bucket;
 	  }
   break;
 case 184
 #line 1466 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation (yyVals[-1+yyTop]));
 		}
 		
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 185
 #line 1490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 186
 #line 1498 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Parameter.Modifier) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop], lt.Location);
 	  }
   break;
 case 187
 #line 1507 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation (yyVals[0+yyTop]);
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], "NeedSomeGeneratorHere", (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], l);
 	  }
   break;
 case 188
 #line 1517 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 189
 #line 1521 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-5+yyTop];
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-4+yyTop], lt.Value, mod, (Attributes) yyVals[-6+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 		
 		if (yyVals[0+yyTop] != null)
 			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 190
 #line 1560 "cs-parser.jay"
   { yyVal = Parameter.Modifier.NONE; }
   break;
 case 192
 #line 1566 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 193
 #line 1570 "cs-parser.jay"
   {
 		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
   		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
   		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		yyVal = mod;
 	  }
   break;
 case 194
 #line 1594 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
 	  		
 	  	yyVal = Parameter.Modifier.REF;
 	  }
   break;
 case 195
 #line 1601 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
 	  
 	  	yyVal = Parameter.Modifier.OUT;
 	  }
   break;
 case 196
 #line 1608 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
 	  			
 		yyVal = Parameter.Modifier.This;
 	  }
   break;
 case 197
 #line 1621 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 198
 #line 1626 "cs-parser.jay"
   {
 		Report.Error (1751, GetLocation (yyVals[-4+yyTop]), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Attributes) yyVals[-5+yyTop], lt.Location);		
 	  }
   break;
 case 199
 #line 1633 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 200
 #line 1641 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation (yyVals[0+yyTop])), "The `params' modifier is not allowed in current context");
 	  }
   break;
 case 201
 #line 1646 "cs-parser.jay"
   {
 		Parameter.Modifier mod = (Parameter.Modifier)yyVals[0+yyTop];
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation (yyVals[-1+yyTop]), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation (yyVals[-1+yyTop]), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
   break;
 case 202
 #line 1655 "cs-parser.jay"
   {
 		Error_DuplicateParameterModifier (GetLocation (yyVals[-1+yyTop]), Parameter.Modifier.PARAMS);
 	  }
   break;
 case 203
 #line 1662 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation (yyVals[0+yyTop]), "__arglist is not valid in this context");
 	  }
   break;
 case 204
 #line 1673 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 205
 #line 1678 "cs-parser.jay"
   {
 		current_property = new Property (current_class, (FullNamedExpression) yyVals[-3+yyTop], (Modifiers) yyVals[-4+yyTop],
 			(MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation (yyVals[-3+yyTop]), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[0+yyTop]));
 		
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 206
 #line 1691 "cs-parser.jay"
   {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
   break;
 case 207
 #line 1698 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
 		current_property = null;
 	  }
   break;
 case 208
 #line 1708 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 209
 #line 1712 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) yyVals[-6+yyTop],
 			(MemberName)yyVals[-5+yyTop], (Modifiers) yyVals[-7+yyTop], (ParametersCompiled) yyVals[-2+yyTop], (Attributes) yyVals[-8+yyTop]);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation (yyVals[-6+yyTop]), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation (yyVals[-4+yyTop]), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 210
 #line 1738 "cs-parser.jay"
   {
 		  lexer.PropertyParsing = false;
 	  }
   break;
 case 211
 #line 1742 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation (yyVals[-1+yyTop]));
 		current_property = null;		
 	  }
   break;
 case 216
 #line 1758 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
 		}
 	  }
   break;
 case 217
 #line 1772 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 218
 #line 1794 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] != null) {
 	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 219
 #line 1815 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
 					null),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 220
 #line 1842 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {		
 			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 222
 #line 1864 "cs-parser.jay"
   {
 		/* TODO
 	  	yyVal = null;
 	  }
   break;
 case 223
 #line 1869 "cs-parser.jay"
   {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	yyVal = null;
 	  }
   break;
 case 224
 #line 1880 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 225
 #line 1884 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 226
 #line 1891 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 227
 #line 1902 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 228
 #line 1908 "cs-parser.jay"
   {
 	    lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 229
 #line 1913 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  }
   break;
 case 234
 #line 1930 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 235
 #line 1934 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 240
 #line 1942 "cs-parser.jay"
   {
 	  	Report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
 	  }
   break;
 case 241
 #line 1946 "cs-parser.jay"
   {
 	  	Report.Error (526, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain contructors");
 	  }
   break;
 case 242
 #line 1950 "cs-parser.jay"
   {
 	  	Report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
   break;
 case 243
 #line 1957 "cs-parser.jay"
   {
 	  }
   break;
 case 244
 #line 1960 "cs-parser.jay"
   {
 		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) yyVals[-3+yyTop], 
 				current_local_parameters,
 				(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			/* Note again, checking is done in semantic analysis*/
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 246
 #line 1985 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 248
 #line 1991 "cs-parser.jay"
   {
 		Report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 249
 #line 1999 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 250
 #line 2003 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		Operator.OpType op = (Operator.OpType) yyVals[-4+yyTop];
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[-6+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 252
 #line 2047 "cs-parser.jay"
   { yyVal = Operator.OpType.LogicalNot; }
   break;
 case 253
 #line 2048 "cs-parser.jay"
   { yyVal = Operator.OpType.OnesComplement; }
   break;
 case 254
 #line 2049 "cs-parser.jay"
   { yyVal = Operator.OpType.Increment; }
   break;
 case 255
 #line 2050 "cs-parser.jay"
   { yyVal = Operator.OpType.Decrement; }
   break;
 case 256
 #line 2051 "cs-parser.jay"
   { yyVal = Operator.OpType.True; }
   break;
 case 257
 #line 2052 "cs-parser.jay"
   { yyVal = Operator.OpType.False; }
   break;
 case 258
 #line 2054 "cs-parser.jay"
   { yyVal = Operator.OpType.Addition; }
   break;
 case 259
 #line 2055 "cs-parser.jay"
   { yyVal = Operator.OpType.Subtraction; }
   break;
 case 260
 #line 2057 "cs-parser.jay"
   { yyVal = Operator.OpType.Multiply; }
   break;
 case 261
 #line 2058 "cs-parser.jay"
   {  yyVal = Operator.OpType.Division; }
   break;
 case 262
 #line 2059 "cs-parser.jay"
   { yyVal = Operator.OpType.Modulus; }
   break;
 case 263
 #line 2060 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseAnd; }
   break;
 case 264
 #line 2061 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseOr; }
   break;
 case 265
 #line 2062 "cs-parser.jay"
   { yyVal = Operator.OpType.ExclusiveOr; }
   break;
 case 266
 #line 2063 "cs-parser.jay"
   { yyVal = Operator.OpType.LeftShift; }
   break;
 case 267
 #line 2064 "cs-parser.jay"
   { yyVal = Operator.OpType.RightShift; }
   break;
 case 268
 #line 2065 "cs-parser.jay"
   { yyVal = Operator.OpType.Equality; }
   break;
 case 269
 #line 2066 "cs-parser.jay"
   { yyVal = Operator.OpType.Inequality; }
   break;
 case 270
 #line 2067 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThan; }
   break;
 case 271
 #line 2068 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThan; }
   break;
 case 272
 #line 2069 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThanOrEqual; }
   break;
 case 273
 #line 2070 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThanOrEqual; }
   break;
 case 274
 #line 2075 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 275
 #line 2079 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 276
 #line 2094 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 277
 #line 2098 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 278
 #line 2113 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 279
 #line 2119 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 280
 #line 2129 "cs-parser.jay"
   { 
 		Constructor c = (Constructor) yyVals[-1+yyTop];
 		c.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 281
 #line 2148 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 282
 #line 2157 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];  
 		
 		/**/
 		/* start block here, so possible anonymous methods inside*/
 		/* constructor initializer can get correct parent block*/
 		/**/
 	  	start_block (lexer.Location);
 	  }
   break;
 case 283
 #line 2168 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-6+yyTop];
 		var mods = (Modifiers) yyVals[-7+yyTop];
 		ConstructorInitializer ci = (ConstructorInitializer) yyVals[0+yyTop];
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) yyVals[-8+yyTop], current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 285
 #line 2199 "cs-parser.jay"
   { current_block = null; yyVal = null; }
   break;
 case 288
 #line 2209 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 289
 #line 2213 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 290
 #line 2219 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 291
 #line 2223 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorThisInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 292
 #line 2229 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 293
 #line 2237 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 294
 #line 2246 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) yyVals[-6+yyTop],
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-7+yyTop], lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		current_local_parameters = null;
 	  }
   break;
 case 295
 #line 2271 "cs-parser.jay"
   {
 		current_event_field = new EventField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop], (MemberName) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop]);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_event_field;
 	  }
   break;
 case 296
 #line 2285 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_event_field = null;
 	  }
   break;
 case 297
 #line 2298 "cs-parser.jay"
   {
 		current_event = new EventProperty (current_class, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-1+yyTop], (Attributes) yyVals[-5+yyTop]);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		
 		lexer.EventParsing = true;
 	  }
   break;
 case 298
 #line 2306 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
   break;
 case 299
 #line 2313 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
   break;
 case 301
 #line 2328 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 302
 #line 2332 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 305
 #line 2345 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 306
 #line 2349 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 307
 #line 2356 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 308
 #line 2362 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 309
 #line 2366 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 310
 #line 2375 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
   break;
 case 311
 #line 2387 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 314
 #line 2396 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 315
 #line 2401 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 316
 #line 2406 "cs-parser.jay"
   { 
 		Report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
 		yyVal = null;
 	  }
   break;
 case 317
 #line 2414 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 318
 #line 2426 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 319
 #line 2442 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 320
 #line 2454 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 321
 #line 2470 "cs-parser.jay"
   {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		yyVal = null;
 	  }
   break;
 case 323
 #line 2482 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 324
 #line 2487 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], MakeName (name), (Attributes) yyVals[-6+yyTop]), null);
 	  }
   break;
 case 325
 #line 2499 "cs-parser.jay"
   {
 	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 326
 #line 2505 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 /*			if (RootContext.Documentation != null)*/
 /*				em.DocComment = ev.DocComment;*/
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 328
 #line 2522 "cs-parser.jay"
   {
 	 	var te = yyVals[0+yyTop] as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), Report);
 			yyVal = null;
 		} else {
 			yyVal = yyVals[0+yyTop];
 		}
 	 }
   break;
 case 329
 #line 2536 "cs-parser.jay"
   {
 	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
 		yyVal = null;
 	 }
   break;
 case 332
 #line 2546 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 334
 #line 2554 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 335
 #line 2562 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		yyVal = em;
 	  }
   break;
 case 336
 #line 2575 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
   break;
 case 337
 #line 2583 "cs-parser.jay"
   { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		yyVal = em;
 	  }
   break;
 case 338
 #line 2604 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 339
 #line 2608 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) yyVals[-4+yyTop]);
 		ParametersCompiled p = (ParametersCompiled) yyVals[-1+yyTop];
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) yyVals[-5+yyTop],
 					     (Modifiers) yyVals[-7+yyTop], name, p, (Attributes) yyVals[-8+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 340
 #line 2627 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 	  }
   break;
 case 341
 #line 2631 "cs-parser.jay"
   {
 		current_delegate.SetParameterInfo ((List<Constraints>) yyVals[-2+yyTop]);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation (yyVals[-10+yyTop]), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
 
 		yyVal = current_delegate;
 
 		current_delegate = null;
 	  }
   break;
 case 343
 #line 2644 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
 	  
 	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 345
 #line 2655 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 347
 #line 2666 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 348
 #line 2675 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 350
 #line 2687 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
 	  
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 351
 #line 2694 "cs-parser.jay"
   {
 		Error_TypeExpected (lexer.Location);
 		yyVal = new TypeArguments ();
 	  }
   break;
 case 352
 #line 2702 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 353
 #line 2708 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 354
 #line 2720 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 355
 #line 2724 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 356
 #line 2733 "cs-parser.jay"
   {
 	  	MemberName mn = (MemberName)yyVals[0+yyTop];
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
   break;
 case 358
 #line 2744 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 359
 #line 2753 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		yyVal = new MemberName (TypeContainer.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 360
 #line 2758 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		yyVal = new MemberName ((MemberName) yyVals[-1+yyTop], TypeContainer.DefaultIndexerName, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 361
 #line 2766 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 362
 #line 2772 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[-1+yyTop], lt1.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 363
 #line 2780 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 365
 #line 2790 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
 	  
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 366
 #line 2801 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 367
 #line 2807 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 368
 #line 2817 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 		yyVal = new TypeParameterName (lt.Value, (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop], lt.Location);
   	  }
   break;
 case 369
 #line 2822 "cs-parser.jay"
   {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	yyVal = new TypeParameterName ("", null, lexer.Location);
   	  }
   break;
 case 371
 #line 2838 "cs-parser.jay"
   {
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 372
 #line 2845 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 374
 #line 2856 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 376
 #line 2865 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 378
 #line 2874 "cs-parser.jay"
   {
 	  	Report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 380
 #line 2883 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 381
 #line 2890 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-1+yyTop];
 
 		if (yyVals[0+yyTop] != null) {
 			yyVal = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				yyVal = new VarExpr (name.Location);
 			else
 				yyVal = name.GetTypeExpression ();
 		}
 	  }
   break;
 case 382
 #line 2903 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (((MemberName) yyVals[-1+yyTop]).GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 383
 #line 2907 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null)
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 384
 #line 2912 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 385
 #line 2916 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 386
 #line 2923 "cs-parser.jay"
   {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 387
 #line 2929 "cs-parser.jay"
   {
 		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 388
 #line 2938 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast) {
 			Report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 389
 #line 2945 "cs-parser.jay"
   {
 	  	Error_TypeExpected (lexer.Location);
 		yyVal = null;
 	  }
   break;
 case 390
 #line 2956 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.object_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 391
 #line 2957 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.string_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 392
 #line 2958 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.bool_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 393
 #line 2959 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.decimal_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 394
 #line 2960 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.float_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 395
 #line 2961 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.double_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 397
 #line 2966 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.sbyte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 398
 #line 2967 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.byte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 399
 #line 2968 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.short_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 400
 #line 2969 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.ushort_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 401
 #line 2970 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 402
 #line 2971 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 403
 #line 2972 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 404
 #line 2973 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 405
 #line 2974 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.char_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 425
 #line 3006 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 426
 #line 3010 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
   break;
 case 430
 #line 3020 "cs-parser.jay"
   { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
   break;
 case 431
 #line 3024 "cs-parser.jay"
   { yyVal = new BoolLiteral (true, GetLocation (yyVals[0+yyTop])); }
   break;
 case 432
 #line 3025 "cs-parser.jay"
   { yyVal = new BoolLiteral (false, GetLocation (yyVals[0+yyTop])); }
   break;
 case 437
 #line 3051 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 438
 #line 3056 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 	  }
   break;
 case 439
 #line 3063 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 440
 #line 3069 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 441
 #line 3075 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 442
 #line 3081 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 443
 #line 3087 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 444
 #line 3090 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
 	  }
   break;
 case 445
 #line 3095 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
 	  }
   break;
 case 446
 #line 3098 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
  	  }
   break;
 case 447
 #line 3106 "cs-parser.jay"
   {
 		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 448
 #line 3113 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 450
 #line 3119 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] == null) {
 	  		yyVal = CollectionOrObjectInitializers.Empty;
 	  		/* TODO
 	  	} else {
 	  		yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  	}
 	  }
   break;
 case 451
 #line 3129 "cs-parser.jay"
   {
 	  	yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 452
 #line 3136 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 453
 #line 3138 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	}
   break;
 case 454
 #line 3145 "cs-parser.jay"
   {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 455
 #line 3151 "cs-parser.jay"
   {
 	  	var a = (List<Expression>)yyVals[-2+yyTop];
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 456
 #line 3156 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 457
 #line 3164 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 458
 #line 3170 "cs-parser.jay"
   {
 		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 459
 #line 3173 "cs-parser.jay"
   {
 		CompletionSimpleName csn = yyVals[-1+yyTop] as CompletionSimpleName;
 		if (csn == null)
 			yyVal = new CollectionElementInitializer ((Expression)yyVals[-1+yyTop]);
 		else
 			yyVal = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
   break;
 case 460
 #line 3181 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] == null)
 			yyVal = null;
 		else
 	  		yyVal = new CollectionElementInitializer ((List<Expression>)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 461
 #line 3188 "cs-parser.jay"
   {
 	  	Report.Error (1920, GetLocation (yyVals[-1+yyTop]), "An element initializer cannot be empty");
 		yyVal = null;
 	  }
   break;
 case 464
 #line 3200 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 466
 #line 3206 "cs-parser.jay"
   { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 467
 #line 3212 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 468
 #line 3221 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		yyVal = list;
 	  }
   break;
 case 469
 #line 3235 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[0+yyTop]), "An argument is missing");
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 470
 #line 3240 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
 	  	yyVal = null;
 	  }
   break;
 case 471
 #line 3248 "cs-parser.jay"
   {
 		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 475
 #line 3261 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 476
 #line 3266 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 477
 #line 3271 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 478
 #line 3276 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist (GetLocation (yyVals[-2+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 480
 #line 3288 "cs-parser.jay"
   {
 		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 481
 #line 3296 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 482
 #line 3302 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 483
 #line 3307 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 484
 #line 3315 "cs-parser.jay"
   {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;
 	  }
   break;
 case 485
 #line 3321 "cs-parser.jay"
   {
 		Arguments args = (Arguments) yyVals[-2+yyTop];
 		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;	  
 	  }
   break;
 case 486
 #line 3333 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 488
 #line 3341 "cs-parser.jay"
   {
 		yyVal = new This (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 489
 #line 3348 "cs-parser.jay"
   {
 	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 490
 #line 3353 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 491
 #line 3361 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 492
 #line 3368 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 493
 #line 3375 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation (yyVals[-5+yyTop]), "object initializers");
 				
 			yyVal = new NewInitialize ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		} else {
 			yyVal = new New ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], GetLocation (yyVals[-5+yyTop]));
 		}
 		
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 494
 #line 3388 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "collection initializers");
 	  
 		yyVal = new NewInitialize ((FullNamedExpression) yyVals[-1+yyTop], null, (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 495
 #line 3400 "cs-parser.jay"
   {
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], (List<Expression>) yyVals[-3+yyTop],
 				new ComposedTypeSpecifier (((List<Expression>) yyVals[-3+yyTop]).Count, GetLocation (yyVals[-4+yyTop])) {
 	  				Next = (ComposedTypeSpecifier) yyVals[-1+yyTop]
 			  	}, (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 496
 #line 3408 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] == null)
 	  		Report.Error (1586, GetLocation (yyVals[-3+yyTop]), "Array creation must have array size or array initializer");
 
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-2+yyTop], (ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 497
 #line 3415 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "implicitly typed arrays");
 	  
 		yyVal = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 498
 #line 3422 "cs-parser.jay"
   {
 		Report.Error (178, GetLocation (yyVals[-1+yyTop]), "Invalid rank specifier, expecting `,' or `]'");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], null, GetLocation (yyVals[-6+yyTop]));
 	  }
   break;
 case 499
 #line 3427 "cs-parser.jay"
   {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 500
 #line 3434 "cs-parser.jay"
   {
 		++lexer.parsing_type;
 	  }
   break;
 case 501
 #line 3438 "cs-parser.jay"
   {
 		--lexer.parsing_type;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 502
 #line 3446 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "anonymous types");
 
 		yyVal = new NewAnonymousType ((List<AnonymousTypeParameter>) yyVals[-1+yyTop], current_container, GetLocation (yyVals[-3+yyTop]));
 		
 		/* TODO
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 505
 #line 3463 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 507
 #line 3469 "cs-parser.jay"
   {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 508
 #line 3475 "cs-parser.jay"
   {
 	  	var a = (List<AnonymousTypeParameter>) yyVals[-2+yyTop];
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 509
 #line 3484 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[-2+yyTop];
 	  	yyVal = new AnonymousTypeParameter ((Expression)yyVals[0+yyTop], lt.Value, lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 510
 #line 3490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
   break;
 case 511
 #line 3496 "cs-parser.jay"
   {
 	  	MemberAccess ma = (MemberAccess) yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
   break;
 case 512
 #line 3501 "cs-parser.jay"
   {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		yyVal = null;
 	  }
   break;
 case 516
 #line 3516 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 517
 #line 3524 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 518
 #line 3528 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 519
 #line 3535 "cs-parser.jay"
   {
 		yyVal = 2;
 	  }
   break;
 case 520
 #line 3539 "cs-parser.jay"
   {
 		yyVal = ((int) yyVals[-1+yyTop]) + 1;
 	  }
   break;
 case 521
 #line 3546 "cs-parser.jay"
   {
 		yyVal = null;
 	  }
   break;
 case 522
 #line 3550 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 523
 #line 3557 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 524
 #line 3564 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 525
 #line 3574 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 526
 #line 3580 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 527
 #line 3589 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = true;
 	  }
   break;
 case 528
 #line 3593 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = false;
 		yyVal = new TypeOf ((FullNamedExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 531
 #line 3604 "cs-parser.jay"
   {
 	 	Error_TypeExpected (lexer.Location);
 	 	yyVal = null;
 	 }
   break;
 case 532
 #line 3612 "cs-parser.jay"
   {  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 533
 #line 3618 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 534
 #line 3625 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 535
 #line 3631 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 536
 #line 3637 "cs-parser.jay"
   {
 		var te = ((MemberName) yyVals[-3+yyTop]).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (te, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 537
 #line 3649 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 538
 #line 3659 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		yyVal = lt;		
 	  }
   break;
 case 539
 #line 3670 "cs-parser.jay"
   { 
 		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 540
 #line 3678 "cs-parser.jay"
   {
 		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 541
 #line 3686 "cs-parser.jay"
   {
 		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 542
 #line 3694 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberAccess (new Indirection ((Expression) yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop])), lt.Value, lt.Location);
 	  }
   break;
 case 543
 #line 3702 "cs-parser.jay"
   {
 		start_anonymous (false, (ParametersCompiled) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 544
 #line 3706 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 	  }
   break;
 case 545
 #line 3713 "cs-parser.jay"
   {
 		yyVal = ParametersCompiled.Undefined;
 	  }
   break;
 case 547
 #line 3721 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 548
 #line 3725 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 549
 #line 3733 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
 
 		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 551
 #line 3745 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 552
 #line 3749 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 554
 #line 3757 "cs-parser.jay"
   {
 		yyVal = new Cast ((FullNamedExpression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 556
 #line 3770 "cs-parser.jay"
   { 
 	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 557
 #line 3774 "cs-parser.jay"
   { 
 		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 558
 #line 3778 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 559
 #line 3782 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 560
 #line 3786 "cs-parser.jay"
   {
 		yyVal = new Indirection ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 561
 #line 3790 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 563
 #line 3798 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Multiply, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 564
 #line 3803 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Division, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 565
 #line 3808 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Modulus, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 567
 #line 3817 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Addition, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 568
 #line 3822 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 569
 #line 3826 "cs-parser.jay"
   {
 	  	/* Shift/Reduce conflict*/
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
   	  }
   break;
 case 570
 #line 3831 "cs-parser.jay"
   {
 		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 571
 #line 3835 "cs-parser.jay"
   {
 		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 573
 #line 3843 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 574
 #line 3848 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.RightShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 576
 #line 3857 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 577
 #line 3862 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 578
 #line 3867 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 579
 #line 3872 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 581
 #line 3881 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Equality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 582
 #line 3886 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Inequality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 584
 #line 3895 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 586
 #line 3904 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 588
 #line 3913 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 590
 #line 3922 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 592
 #line 3931 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 594
 #line 3940 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
 			
 		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 596
 #line 3951 "cs-parser.jay"
   {
 		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 597
 #line 3959 "cs-parser.jay"
   {
 		yyVal = new SimpleAssign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 598
 #line 3963 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 599
 #line 3968 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 600
 #line 3973 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 601
 #line 3978 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 602
 #line 3983 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 603
 #line 3988 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 604
 #line 3993 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 605
 #line 3998 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 606
 #line 4003 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 607
 #line 4008 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 608
 #line 4016 "cs-parser.jay"
   {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = pars;
 	  }
   break;
 case 609
 #line 4023 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter)yyVals[0+yyTop];
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		yyVal = pars;
 	  }
   break;
 case 610
 #line 4037 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
 	  }
   break;
 case 611
 #line 4043 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
   break;
 case 612
 #line 4049 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
   break;
 case 613
 #line 4056 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 614
 #line 4057 "cs-parser.jay"
   { 
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 		yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 617
 #line 4069 "cs-parser.jay"
   {
 		start_block (lexer.Location);
 	  }
   break;
 case 618
 #line 4073 "cs-parser.jay"
   {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
 		yyVal = b;
 	  }
   break;
 case 620
 #line 4083 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	
 		yyVal = EmptyExpression.Null;
 	  }
   break;
 case 621
 #line 4091 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 622
 #line 4097 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 623
 #line 4102 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 624
 #line 4109 "cs-parser.jay"
   {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 625
 #line 4114 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 631
 #line 4130 "cs-parser.jay"
   {
 		yyVal = new ArglistAccess (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 633
 #line 4141 "cs-parser.jay"
   {
 		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 634
 #line 4154 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 635
 #line 4158 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 636
 #line 4164 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 637
 #line 4176 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 638
 #line 4182 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 639
 #line 4190 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 640
 #line 4192 "cs-parser.jay"
   { yyVal = yyVals[0+yyTop]; }
   break;
 case 641
 #line 4197 "cs-parser.jay"
   {
 	    mod_locations = null;
 		yyVal = ModifierNone;
 	  }
   break;
 case 644
 #line 4207 "cs-parser.jay"
   { 
 		var m1 = (Modifiers) yyVals[-1+yyTop];
 		var m2 = (Modifiers) yyVals[0+yyTop];
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		yyVal = m1 | m2;
 	  }
   break;
 case 645
 #line 4226 "cs-parser.jay"
   {
 		yyVal = Modifiers.NEW;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
 	  }
   break;
 case 646
 #line 4234 "cs-parser.jay"
   {
 		yyVal = Modifiers.PUBLIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 647
 #line 4239 "cs-parser.jay"
   {
 		yyVal = Modifiers.PROTECTED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 648
 #line 4244 "cs-parser.jay"
   {
 		yyVal = Modifiers.INTERNAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 649
 #line 4249 "cs-parser.jay"
   {
 		yyVal = Modifiers.PRIVATE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 650
 #line 4254 "cs-parser.jay"
   {
 		yyVal = Modifiers.ABSTRACT;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 651
 #line 4259 "cs-parser.jay"
   {
 		yyVal = Modifiers.SEALED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 652
 #line 4264 "cs-parser.jay"
   {
 		yyVal = Modifiers.STATIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 653
 #line 4269 "cs-parser.jay"
   {
 		yyVal = Modifiers.READONLY;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 654
 #line 4274 "cs-parser.jay"
   {
 		yyVal = Modifiers.VIRTUAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 655
 #line 4279 "cs-parser.jay"
   {
 		yyVal = Modifiers.OVERRIDE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 656
 #line 4284 "cs-parser.jay"
   {
 		yyVal = Modifiers.EXTERN;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 657
 #line 4289 "cs-parser.jay"
   {
 		yyVal = Modifiers.VOLATILE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 658
 #line 4294 "cs-parser.jay"
   {
 		yyVal = Modifiers.UNSAFE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 659
 #line 4301 "cs-parser.jay"
   {
 		yyVal = Modifiers.ASYNC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 661
 #line 4310 "cs-parser.jay"
   {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) yyVals[0+yyTop]);
 	 }
   break;
 case 663
 #line 4318 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 664
 #line 4322 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	 }
   break;
 case 665
 #line 4330 "cs-parser.jay"
   {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 666
 #line 4336 "cs-parser.jay"
   {
 		var constraints = (List<Constraints>) yyVals[-1+yyTop];
 		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		yyVal = constraints;
 	  }
   break;
 case 667
 #line 4355 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 668
 #line 4363 "cs-parser.jay"
   {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 669
 #line 4369 "cs-parser.jay"
   {
 		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = yyVals[0+yyTop] as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 670
 #line 4395 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast)
 			Report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 	  
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 671
 #line 4402 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 672
 #line 4407 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 673
 #line 4411 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 674
 #line 4418 "cs-parser.jay"
   {
 		yyVal = Variance.None;
 	  }
   break;
 case 675
 #line 4422 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 676
 #line 4432 "cs-parser.jay"
   {
 		yyVal = Variance.Covariant;
 	  }
   break;
 case 677
 #line 4436 "cs-parser.jay"
   {
 		yyVal = Variance.Contravariant;
 	  }
   break;
 case 678
 #line 4456 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 679
 #line 4461 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 680
 #line 4468 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 681
 #line 4473 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (lexer.Location);
 	  }
   break;
 case 682
 #line 4482 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
 	  }
   break;
 case 683
 #line 4487 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 688
 #line 4505 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 689
 #line 4509 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 691
 #line 4514 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 694
 #line 4533 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 695
 #line 4537 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 724
 #line 4578 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 725
 #line 4583 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 726
 #line 4588 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 727
 #line 4596 "cs-parser.jay"
   {
 		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
 		yyVal = new EmptyStatement (lexer.Location);
 	  }
   break;
 case 728
 #line 4604 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
   break;
 case 731
 #line 4617 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] is VarExpr)
 			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
 	  
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 732
 #line 4633 "cs-parser.jay"
   { 
 		/* Ok, the above "primary_expression" is there to get rid of*/
 		/* both reduce/reduce and shift/reduces in the grammar, it should*/
 		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
 		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
 		/* really) two shift/reduces appear.*/
 		/* */
 
 		/* So the super-trick is that primary_expression*/
 		/* can only be either a SimpleName or a MemberAccess. */
 		/* The MemberAccess case arises when you have a fully qualified type-name like 
 		/* Foo.Bar.Blah i;*/
 		/* SimpleName is when you have*/
 		/* Blah i;*/
 		
 		Expression expr = (Expression) yyVals[-1+yyTop];
 		if (yyVals[0+yyTop] == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				yyVal = new VarExpr (sn.Location);
 			else
 				yyVal = yyVals[-1+yyTop];
 		} else if (expr is ATypeNameExpression) {
 			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName (expr);
 			yyVal = null;
 		}
 	  }
   break;
 case 733
 #line 4663 "cs-parser.jay"
   {
 		ATypeNameExpression expr = yyVals[-1+yyTop] as ATypeNameExpression;
 
 		if (expr != null) {
 			yyVal = new ComposedCast (expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName ((Expression)yyVals[-1+yyTop]);
 			yyVal = expr;
 		}
 	  }
   break;
 case 734
 #line 4674 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] == null)
 			yyVal = yyVals[-1+yyTop];
 		else
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 735
 #line 4681 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 736
 #line 4685 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 737
 #line 4689 "cs-parser.jay"
   {
 		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 739
 #line 4698 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 740
 #line 4706 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreatePointer (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 741
 #line 4713 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 742
 #line 4720 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 743
 #line 4726 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 744
 #line 4733 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 746
 #line 4743 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		/* TODO
 	  }
   break;
 case 747
 #line 4748 "cs-parser.jay"
   {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
   break;
 case 752
 #line 4770 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 753
 #line 4779 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 754
 #line 4791 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
   break;
 case 755
 #line 4795 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 760
 #line 4812 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 762
 #line 4825 "cs-parser.jay"
   {
 		yyVal = new StackAlloc ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 763
 #line 4830 "cs-parser.jay"
   {
 		Report.Error (1575, GetLocation (yyVals[-1+yyTop]), "A stackalloc expression requires [] after type");
 		yyVal = new StackAlloc ((Expression) yyVals[0+yyTop], null, GetLocation (yyVals[-1+yyTop]));		
 	  }
   break;
 case 764
 #line 4838 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 765
 #line 4842 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 766
 #line 4846 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 767
 #line 4847 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 768
 #line 4856 "cs-parser.jay"
   {
 		ExpressionStatement s = yyVals[0+yyTop] as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation (yyVals[0+yyTop]));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 769
 #line 4869 "cs-parser.jay"
   {
 		Expression expr = (Expression) yyVals[0+yyTop];
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 770
 #line 4877 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 773
 #line 4891 "cs-parser.jay"
   { 
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 		
 		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 774
 #line 4900 "cs-parser.jay"
   {
 		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		
 		if (yyVals[-2+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 775
 #line 4913 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 776
 #line 4917 "cs-parser.jay"
   {
 		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
 		end_block (GetLocation (yyVals[0+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 777
 #line 4926 "cs-parser.jay"
   {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 779
 #line 4935 "cs-parser.jay"
   {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 780
 #line 4942 "cs-parser.jay"
   {
 		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 781
 #line 4949 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 782
 #line 4957 "cs-parser.jay"
   {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
   break;
 case 783
 #line 4961 "cs-parser.jay"
   {
 		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
 	  }
   break;
 case 784
 #line 4968 "cs-parser.jay"
   {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 		yyVal = labels;
 	  }
   break;
 case 785
 #line 4975 "cs-parser.jay"
   {
 		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 
 		yyVal = labels;
 	  }
   break;
 case 786
 #line 4985 "cs-parser.jay"
   {
 	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	 }
   break;
 case 787
 #line 4990 "cs-parser.jay"
   {
 		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 792
 #line 5004 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 793
 #line 5016 "cs-parser.jay"
   {
 		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 794
 #line 5024 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 		current_block.IsCompilerGenerated = true;
 	  }
   break;
 case 795
 #line 5029 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 796
 #line 5040 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		For f = new For ((Statement) yyVals[-6+yyTop], (BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		yyVal = end_block (GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 797
 #line 5052 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = end_block (current_block.StartLocation);
 	  }
   break;
 case 798
 #line 5059 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 800
 #line 5065 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 801
 #line 5072 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 803
 #line 5080 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 805
 #line 5085 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 809
 #line 5096 "cs-parser.jay"
   {
 	  	var sl = yyVals[-2+yyTop] as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
 			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
 	  	} else {
 	  		sl.Add ((Statement) yyVals[0+yyTop]);
 	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
 	  	}
 	  		
 		yyVal = sl;
 	  }
   break;
 case 810
 #line 5112 "cs-parser.jay"
   {
 		Report.Error (230, GetLocation (yyVals[-5+yyTop]), "Type and identifier are both required in a foreach statement");
 		yyVal = null;
 	  }
   break;
 case 811
 #line 5117 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-5+yyTop]));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		yyVal = li;
 	  }
   break;
 case 812
 #line 5127 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Foreach f = new Foreach ((Expression) yyVals[-6+yyTop], (LocalVariable) yyVals[-1+yyTop], (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 819
 #line 5150 "cs-parser.jay"
   {
 		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 820
 #line 5158 "cs-parser.jay"
   {
 		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 821
 #line 5166 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 822
 #line 5172 "cs-parser.jay"
   {
 		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 823
 #line 5177 "cs-parser.jay"
   {
 		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 824
 #line 5185 "cs-parser.jay"
   {
 		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 825
 #line 5193 "cs-parser.jay"
   {
 		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 826
 #line 5201 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (yyVals[-1+yyTop] == null) {
 			Report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 827
 #line 5217 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new YieldBreak (lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 830
 #line 5239 "cs-parser.jay"
   {
 		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
 	  }
   break;
 case 831
 #line 5243 "cs-parser.jay"
   {
 		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 832
 #line 5248 "cs-parser.jay"
   {
 		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]), true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 833
 #line 5253 "cs-parser.jay"
   {
 		Report.Error (1524, GetLocation (yyVals[-2+yyTop]), "Expected catch or finally");
 		yyVal = null;
 	  }
   break;
 case 834
 #line 5261 "cs-parser.jay"
   {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) yyVals[0+yyTop]);
 		yyVal = l;
 	  }
   break;
 case 835
 #line 5268 "cs-parser.jay"
   {
 		var l = (List<Catch>) yyVals[-1+yyTop];
 		
 		Catch c = (Catch) yyVals[0+yyTop];
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		yyVal = l;
 	  }
   break;
 case 838
 #line 5292 "cs-parser.jay"
   {
 		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 839
 #line 5296 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-3+yyTop]));
 		var c = new Catch (current_block, GetLocation (yyVals[-4+yyTop]));
 		c.TypeExpression = (FullNamedExpression) yyVals[-2+yyTop];
 
 		if (yyVals[-1+yyTop] != null) {
 			var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 840
 #line 5311 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 841
 #line 5315 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 842
 #line 5329 "cs-parser.jay"
   {
 		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 843
 #line 5336 "cs-parser.jay"
   {
 		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 844
 #line 5343 "cs-parser.jay"
   {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 845
 #line 5346 "cs-parser.jay"
   {
 		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 846
 #line 5353 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 847
 #line 5364 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 848
 #line 5373 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 849
 #line 5378 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 850
 #line 5390 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 851
 #line 5399 "cs-parser.jay"
   {
 		yyVal = current_variable;	  
 		current_variable = null;
 	  }
   break;
 case 852
 #line 5404 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (u);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 853
 #line 5413 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (u, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = u;
 	  }
   break;
 case 854
 #line 5425 "cs-parser.jay"
   {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
   break;
 case 855
 #line 5429 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		yyVal = current_variable;
 	  }
   break;
 case 856
 #line 5440 "cs-parser.jay"
   {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 857
 #line 5452 "cs-parser.jay"
   {
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 858
 #line 5463 "cs-parser.jay"
   {
 	        lexer.query_parsing = false;
 		yyVal = yyVals[-1+yyTop];
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 859
 #line 5470 "cs-parser.jay"
   {
 	        yyVal = yyVals[-1+yyTop];
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 860
 #line 5479 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 861
 #line 5487 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 862
 #line 5502 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 863
 #line 5510 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 864
 #line 5525 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 865
 #line 5529 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 866
 #line 5540 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 867
 #line 5544 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
 			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 868
 #line 5561 "cs-parser.jay"
   {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
 		
 		if (yyVals[0+yyTop] != null)
 			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 				
 		if (yyVals[-2+yyTop] != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		yyVal = head;
 	  }
   break;
 case 870
 #line 5577 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 871
 #line 5585 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 872
 #line 5589 "cs-parser.jay"
   {
 		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 873
 #line 5596 "cs-parser.jay"
   {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
   break;
 case 874
 #line 5604 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 875
 #line 5611 "cs-parser.jay"
   {
 		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 879
 #line 5627 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 885
 #line 5643 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 886
 #line 5647 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 887
 #line 5661 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 888
 #line 5665 "cs-parser.jay"
   {
 		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 889
 #line 5675 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 890
 #line 5683 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 891
 #line 5691 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 892
 #line 5699 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
   break;
 case 893
 #line 5735 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 894
 #line 5743 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 895
 #line 5751 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 896
 #line 5759 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;		
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO
 			
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
   break;
 case 898
 #line 5803 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 899
 #line 5810 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 900
 #line 5814 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 902
 #line 5825 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 903
 #line 5832 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	  }
   break;
 case 905
 #line 5841 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
   break;
 case 906
 #line 5848 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	 }
   break;
 case 907
 #line 5856 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 908
 #line 5860 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 909
 #line 5864 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 910
 #line 5871 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 911
 #line 5875 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 912
 #line 5879 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 914
 #line 5888 "cs-parser.jay"
   {
 		/* query continuation block is not linked with query block but with block*/
 		/* before. This means each query can use same range variable names for*/
 		/* different identifiers.*/
 
 		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
   break;
 case 915
 #line 5904 "cs-parser.jay"
   {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
   			next = (Linq.AQueryClause)yyVals[0+yyTop]
   		};
 	  }
   break;
 case 918
 #line 5930 "cs-parser.jay"
   { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		/* (ref object retval)*/
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, /* generic*/
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }
   break;
 case 919
 #line 5960 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  }
   break;
 case 920
 #line 5971 "cs-parser.jay"
   {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
   break;
 #line default
         }
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
     continue_yyLoop
     }
   }
 
    static  short [] yyLhs  = {              -1,
     0,    0,    0,    0,    5,    0,    2,    2,    1,    1,
     6,    6,    6,   10,   10,    7,    7,   11,   11,    8,
     8,   12,   12,   13,   20,   16,   18,   18,   18,   21,
    21,   22,   22,   15,   24,   19,   25,   25,   23,   23,
    26,   26,   27,   27,    9,    9,    9,   28,   28,   28,
    28,   28,    3,   17,   17,   34,   34,   35,   35,   36,
    38,   38,   38,   38,   37,   37,   42,   39,   40,   41,
    41,   43,   43,   43,   43,   43,   44,   44,   48,   45,
    47,   49,   49,   49,   50,   50,   51,   51,   52,   52,
    52,   52,   52,   52,   52,   52,   52,   52,   52,   65,
    67,   70,   71,   30,   30,   73,   69,   72,   72,   74,
    74,   75,   75,   75,   75,   75,   75,   75,   75,   75,
    75,   78,   53,   79,   79,   80,   80,   81,   83,   77,
    77,   82,   82,   88,   54,   92,   54,   54,   87,   95,
    87,   89,   89,   96,   96,   97,   98,   97,   93,   93,
    99,   99,  100,  101,   91,   91,   94,   94,   94,  104,
    55,  107,  108,  102,  109,  110,  102,  102,  103,  103,
   106,  106,  113,  113,  113,  113,  113,  113,  113,  113,
   113,  113,  114,  114,  117,  117,  117,  120,  117,  118,
   118,  121,  121,  122,  122,  122,  115,  115,  115,  123,
   123,  123,  116,  125,  127,  128,   56,  130,  131,  132,
    58,  126,  126,  126,  126,  126,  136,  133,  137,  134,
   135,  135,  135,  138,  139,  140,  142,   31,   31,  141,
   141,  143,  143,  144,  144,  144,  144,  144,  144,  144,
   144,  144,  147,   59,  146,  146,  148,  148,  151,  145,
   145,  150,  150,  150,  150,  150,  150,  150,  150,  150,
   150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
   150,  150,  150,  153,  152,  154,  152,  152,  152,   60,
   157,  159,  155,  156,  156,  158,  158,  163,  161,  164,
   161,  161,  165,   61,  167,   57,  170,  171,   57,  166,
   173,  166,  168,  168,  174,  174,  175,  176,  175,  177,
   172,  169,  169,  169,  169,  169,  181,  178,  182,  179,
   180,  180,  184,  186,  187,   32,  183,  183,  183,  185,
   185,  185,  188,  188,  189,  190,  189,  191,  192,  193,
    33,  194,  194,   14,   14,  195,  195,  198,  197,  197,
   197,  199,  199,  201,   64,  124,  105,  105,  129,  129,
   202,  202,  202,  200,  200,  203,  203,  204,  204,  206,
   206,   86,   76,   76,   90,   90,  119,  119,  149,  149,
   207,  207,  207,  207,  207,  211,  211,  212,  212,  210,
   210,  210,  210,  210,  210,  210,  213,  213,  213,  213,
   213,  213,  213,  213,  213,  214,  214,  214,  214,  214,
   214,  214,  214,  214,  214,  214,  214,  214,  214,  214,
   214,  214,  214,  214,  215,  215,  215,  216,  216,  216,
   235,  235,  236,  236,  237,  237,  218,  218,  234,  234,
   234,  234,  234,  234,  234,  234,  220,  238,  238,  239,
   239,  240,  240,  242,  242,  242,  243,  243,  243,  243,
   243,  244,  244,  162,  162,  248,  248,  248,  248,  248,
   250,  250,  249,  249,  251,  251,  251,  251,  252,  221,
   247,  247,  247,  253,  253,  254,  254,  222,  223,  223,
   224,  225,  226,  226,  217,  217,  217,  217,  217,  258,
   255,  227,  259,  259,  260,  260,  261,  261,  262,  262,
   262,  262,  256,  256,  208,  208,  263,  263,  264,  264,
   257,  257,   85,   85,  265,  265,  266,  228,  267,  267,
   267,  268,  268,  268,  268,  268,  269,  196,  229,  230,
   231,  232,  271,  233,  270,  270,  273,  272,  219,  274,
   274,  274,  274,  276,  275,  275,  275,  275,  275,  275,
   275,  277,  277,  277,  277,  278,  278,  278,  278,  278,
   278,  279,  279,  279,  280,  280,  280,  280,  280,  281,
   281,  281,  282,  282,  283,  283,  284,  284,  285,  285,
   286,  286,  287,  287,  288,  288,  289,  289,  289,  289,
   289,  289,  289,  289,  289,  289,  289,  290,  290,  291,
   291,  291,  292,  292,  293,  293,  296,  294,  295,  295,
   298,  297,  299,  300,  297,   46,   46,  245,  245,  245,
   245,   84,  302,  303,  304,  305,  306,   29,   63,   63,
    62,   62,  111,  111,  307,  307,  307,  307,  307,  307,
   307,  307,  307,  307,  307,  307,  307,  307,  307,   66,
    66,   68,   68,   68,  308,  308,  309,  310,  310,  311,
   311,  311,  311,  205,  205,  312,  312,  314,  112,  315,
   315,  316,  160,  313,  313,  317,  317,  318,  318,  318,
   318,  322,  322,  323,  323,  323,  320,  320,  320,  320,
   320,  320,  320,  320,  320,  320,  320,  320,  320,  324,
   324,  324,  324,  324,  324,  324,  324,  324,  324,  324,
   324,  324,  338,  338,  338,  338,  325,  339,  321,  340,
   340,  341,  341,  341,  341,  341,  341,  209,  209,  342,
   344,  319,  347,  319,  343,  343,  343,  345,  345,  350,
   350,  351,  351,  346,  346,  348,  348,  352,  352,  353,
   349,  349,  349,  326,  326,  337,  337,  354,  355,  355,
   327,  327,  356,  356,  359,  357,  358,  358,  360,  360,
   360,  363,  361,  362,  362,  364,  364,  328,  328,  328,
   328,  365,  366,  370,  367,  369,  369,  371,  371,  375,
   374,  374,  372,  372,  373,  373,  377,  376,  376,  368,
   378,  368,  329,  329,  329,  329,  329,  329,  379,  380,
   381,  381,  381,  382,  383,  384,  384,  385,  385,  330,
   330,  330,  330,  386,  386,  388,  388,  387,  389,  387,
   387,  331,  332,  390,  335,  333,  392,  393,  336,  394,
   395,  334,  334,  391,  391,  301,  301,  301,  301,  396,
   396,  398,  398,  400,  399,  401,  399,  397,  397,  397,
   405,  403,  406,  407,  403,  402,  402,  408,  408,  409,
   409,  409,  409,  409,  414,  410,  415,  411,  416,  417,
   418,  412,  420,  421,  422,  412,  419,  419,  424,  413,
   423,  427,  423,  426,  429,  426,  425,  425,  425,  428,
   428,  428,  404,  430,  404,    4,    4,  431,    4,  433,
     4,  432,  432,  432,  432,  246,  246,  241,  241,
   };
    static  short [] yyLen = {           2,
     2,    3,    2,    1,    0,    3,    0,    1,    1,    2,
     1,    1,    1,    1,    2,    4,    2,    1,    2,    1,
     1,    5,    2,    3,    0,    6,    1,    3,    1,    0,
     1,    0,    1,    1,    0,    6,    0,    1,    0,    1,
     0,    1,    1,    2,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    0,    1,    1,    2,    5,    4,    2,
     1,    1,    1,    1,    1,    3,    0,    3,    1,    0,
     3,    0,    1,    1,    3,    3,    1,    1,    0,    4,
     4,    0,    1,    1,    0,    1,    1,    2,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    0,
     0,    0,    0,   13,    5,    0,    4,    0,    1,    1,
     2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    0,    9,    0,    1,    1,    2,    3,    0,    3,
     1,    1,    1,    0,    8,    0,    9,    6,    0,    0,
     3,    0,    1,    1,    2,    2,    0,    5,    0,    1,
     1,    2,    3,    0,    4,    2,    1,    1,    1,    0,
     3,    0,    0,   10,    0,    0,   11,    8,    1,    1,
     0,    1,    1,    3,    3,    3,    5,    3,    5,    1,
     1,    1,    1,    3,    4,    6,    4,    0,    7,    0,
     1,    1,    2,    1,    1,    1,    4,    6,    4,    1,
     2,    2,    1,    0,    0,    0,   10,    0,    0,    0,
    13,    1,    2,    1,    2,    1,    0,    5,    0,    5,
     1,    1,    1,    0,    0,    0,    0,   15,    5,    0,
     1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    0,    5,    1,    1,    1,    1,    0,    7,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    0,    7,    0,    7,    2,    2,    2,
     0,    0,    9,    1,    1,    0,    1,    0,    6,    0,
     6,    1,    0,    8,    0,    9,    0,    0,   10,    0,
     0,    3,    0,    1,    1,    2,    2,    0,    5,    0,
     2,    2,    2,    1,    1,    1,    0,    5,    0,    5,
     1,    1,    0,    0,    0,   12,    0,    2,    2,    0,
     1,    2,    1,    3,    2,    0,    5,    0,    0,    0,
    13,    0,    1,    1,    3,    1,    4,    2,    0,    3,
     2,    1,    3,    0,    3,    1,    1,    3,    1,    2,
     3,    4,    4,    0,    3,    1,    3,    3,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
     2,    2,    2,    2,    2,    1,    3,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    2,    2,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    3,    3,    4,    4,
     4,    3,    3,    4,    3,    4,    4,    0,    1,    3,
     4,    0,    1,    1,    3,    2,    3,    1,    2,    3,
     2,    1,    1,    0,    1,    1,    3,    3,    2,    2,
     1,    1,    1,    1,    2,    2,    4,    3,    1,    4,
     1,    3,    2,    1,    3,    1,    1,    1,    4,    3,
     2,    2,    6,    3,    7,    4,    3,    7,    3,    0,
     2,    4,    1,    2,    0,    1,    1,    3,    3,    1,
     1,    1,    0,    1,    1,    2,    2,    3,    1,    2,
     0,    1,    2,    4,    1,    3,    0,    5,    1,    1,
     1,    2,    3,    3,    4,    4,    1,    2,    4,    4,
     4,    3,    0,    4,    0,    1,    0,    4,    4,    1,
     2,    2,    1,    4,    1,    2,    2,    2,    2,    2,
     2,    1,    3,    3,    3,    1,    3,    3,    3,    3,
     3,    1,    3,    3,    1,    3,    3,    3,    3,    1,
     3,    3,    1,    3,    1,    3,    1,    3,    1,    3,
     1,    3,    1,    3,    1,    5,    3,    3,    3,    3,
     3,    3,    3,    3,    3,    3,    3,    1,    3,    3,
     2,    1,    0,    1,    1,    1,    0,    2,    1,    1,
     0,    4,    0,    0,    7,    1,    1,    1,    1,    1,
     1,    1,    1,    0,    0,    0,    0,   15,    0,    1,
     0,    1,    1,    2,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    0,
     2,    0,    1,    1,    1,    2,    4,    1,    3,    1,
     3,    1,    1,    0,    1,    1,    1,    0,    4,    1,
     1,    0,    4,    0,    1,    1,    2,    1,    1,    1,
     1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    0,    4,    1,
     2,    2,    2,    2,    2,    2,    1,    1,    2,    1,
     0,    6,    0,    7,    0,    2,    1,    0,    1,    1,
     2,    2,    4,    0,    2,    0,    1,    1,    2,    4,
     1,    5,    2,    2,    2,    2,    2,    1,    1,    1,
     1,    1,    5,    7,    0,    8,    0,    1,    1,    2,
     1,    0,    3,    1,    2,    3,    1,    1,    1,    1,
     1,    5,    7,    0,    4,    7,    1,    0,    1,    0,
     5,    1,    0,    1,    0,    1,    1,    1,    3,    6,
     0,    9,    1,    1,    1,    1,    1,    1,    2,    2,
     3,    4,    3,    3,    3,    4,    3,    0,    1,    3,
     4,    5,    3,    1,    2,    0,    1,    2,    0,    7,
     3,    2,    2,    0,    3,    5,    0,    0,   10,    0,
     0,   10,    5,    0,    2,    2,    2,    2,    2,    4,
     5,    4,    5,    0,    5,    0,    6,    3,    2,    1,
     0,    3,    0,    0,    6,    0,    1,    1,    2,    1,
     1,    1,    1,    1,    0,    5,    0,    3,    0,    0,
     0,   12,    0,    0,    0,   13,    0,    2,    0,    3,
     1,    0,    4,    1,    0,    4,    1,    2,    2,    1,
     2,    2,    0,    0,    4,    2,    3,    0,    4,    0,
     3,    1,    2,    1,    0,    0,    1,    1,    1,
   };
    static  short [] yyDefRed = {            0,
    47,    8,    0,    0,    0,    0,  920,    0,    0,    0,
     4,    0,    5,    9,   11,   12,   13,   20,   21,   46,
     0,   45,   48,   49,   50,   51,   52,    0,   56,   23,
     0,    0,    0,  344,    0,  346,   17,    0,   64,   62,
    63,    0,    0,    0,    0,    0,   65,   67,  916,    0,
     0,   18,    0,    1,    0,   10,    3,    0,  650,  656,
   648,    0,  645,  655,  649,  647,  646,  653,  651,  652,
   658,  654,  657,  659,    0,    0,  643,   57,    0,  538,
     0,  348,    0,   24,    0,    0,    0,    0,    0,    0,
    60,    0,  770,    0,  392,    0,  398,  405,    0,    0,
     0,  393,    0,    0,    0,  395,  432,    0,  394,    0,
     0,    0,    0,  401,    0,  403,    0,  430,  390,    0,
   397,  399,    0,  391,    0,  488,    0,  431,    0,  527,
   402,  404,    0,  844,  400,    0,    0,    0,  631,    0,
     0,  678,    0,  727,    0,    0,    0,    0,    0,    0,
     0,    0,  429,    0,  623,    0,  769,  710,    0,    0,
   396,    0,    0,  407,  408,    0,  410,  411,  412,  413,
   414,  415,  416,  417,  418,  419,  420,  421,  422,  423,
   424,  427,  428,  627,  555,    0,  553,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  628,  626,
   629,  630,  694,  696,    0,  692,  695,  711,  713,  714,
   715,  716,  717,  718,  719,  720,  721,  722,  712,    0,
     0,    0,  771,  772,  788,  789,  790,  791,  813,  814,
   815,  816,  817,  818,    0,    0,    0,  924,  921,  927,
    19,  917,    2,    6,   29,   27,    0,    0,    0,  640,
     0,  644,    0,  351,    0,    0,  352,  373,    0,    0,
     0,    0,  345,   16,    0,   66,   59,    0,   68,    0,
     0,    0,  819,  433,  434,  842,    0,    0,    0,    0,
     0,  409,    0,  820,    0,  547,  543,  546,  726,  768,
   697,  724,  723,  725,  698,  699,  700,  701,  702,  703,
   704,  705,  706,  707,  708,  709,    0,    0,    0,  794,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  829,    0,  406,    0,    0,    0,    0,
     0,    0,  843,    0,    0,    0,  740,  736,    0,    0,
     0,    0,    0,    0,    0,    0,  552,  556,  557,  551,
   561,  560,  558,  559,    0,    0,  621,  728,  426,  425,
     0,    0,    0,  343,    0,  734,  735,    0,  491,  492,
     0,    0,    0,  732,  733,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  919,
   693,  741,  731,  766,  767,  870,  887,    0,    0,    0,
   899,  858,  856,  880,    0,    0,  878,  881,  882,  883,
   884,  859,  857,  923,    0,    0,    0,    0,  370,  372,
   354,    0,  634,    0,    0,   22,  385,  381,  382,    0,
   350,  380,  383,  384,  347,   58,    0,    0,   73,   74,
    77,   78,  490,    0,    0,  486,  487,    0,  484,    0,
   743,    0,    0,    0,    0,  764,  765,    0,    0,    0,
   632,    0,  823,  821,  633,    0,    0,  512,    0,    0,
     0,  503,    0,  507,  517,  519,    0,    0,  497,  499,
     0,    0,    0,    0,    0,  494,    0,  501,  375,  516,
   824,    0,    0,  825,  833,    0,    0,    0,  834,    0,
     0,  845,    0,    0,  739,    0,    0,    0,    0,    0,
   691,    0,    0,  686,  688,  689,  690,  437,  438,  827,
     0,    0,    0,  195,  194,  196,    0,    0,    0,    0,
   377,    0,  608,    0,    0,  442,    0,  445,    0,  443,
   542,    0,    0,    0,    0,    0,  471,  474,    0,    0,
   466,  473,  472,  562,    0,  597,  598,  599,  600,  601,
   602,  603,  604,  605,  607,  606,  563,  565,  564,  570,
   571,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  594,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  871,  873,  869,    0,
   879,   28,   35,    0,    0,    0,    0,  323,    0,  229,
     0,  105,    0,  353,    0,   79,   71,    0,  441,  489,
     0,  540,    0,  549,  182,  203,    0,    0,    0,  172,
     0,    0,    0,  183,  544,    0,  847,  797,    0,  808,
   795,    0,  799,    0,    0,    0,  822,    0,    0,    0,
   502,    0,  518,  520,  159,  523,  157,  158,  525,    0,
     0,    0,  458,    0,    0,  454,    0,    0,  481,    0,
   522,  496,    0,  539,    0,  838,    0,  831,    0,  835,
   531,    0,    0,    0,  529,    0,    0,  541,    0,  850,
     0,  862,    0,  860,    0,  680,  681,  679,  687,  826,
   616,  622,  615,    0,  729,  611,    0,    0,    0,  554,
   446,  440,  444,  439,  480,  479,  476,  475,    0,  470,
   435,  436,  447,    0,    0,  747,    0,    0,  888,  864,
     0,  889,    0,  885,    0,  900,    0,    0,    0,    0,
   868,    0,   31,   26,  338,    0,  355,  329,  328,    0,
   635,  225,  101,   84,   83,    0,    0,   75,   76,  485,
     0,    0,    0,    0,    0,  192,    0,  548,    0,    0,
     0,    0,    0,  800,    0,    0,    0,    0,    0,  846,
   509,  508,    0,    0,  461,    0,    0,  928,  929,  450,
   456,    0,  459,    0,  483,    0,    0,    0,  775,  841,
     0,  832,  537,  532,    0,    0,  528,    0,  853,    0,
   792,  863,  861,  620,  619,  618,  610,  609,  624,  478,
     0,  468,  467,  596,    0,  761,  746,    0,    0,    0,
   750,    0,  866,    0,  893,    0,  908,  909,  902,  872,
   874,  914,   14,    0,    0,    0,  369,    0,    0,  366,
   324,    0,    0,    0,   81,   80,  755,  132,  133,    0,
     0,    0,  758,  201,  202,    0,  193,    0,    0,    0,
   175,  184,  176,  178,    0,    0,    0,    0,  804,    0,
   809,  810,    0,    0,  526,  524,  460,  462,  463,  457,
   451,  455,    0,  514,    0,  482,  493,  449,    0,  837,
     0,    0,  533,    0,    0,    0,  477,    0,    0,  742,
   751,  865,    0,    0,    0,  886,    0,    0,    0,   15,
     0,    0,    0,  677,  676,    0,  675,    0,  365,    0,
     0,    0,    0,    0,    0,  744,  759,  187,    0,  199,
     0,    0,    0,  793,  855,    0,    0,    0,  811,  774,
   498,  495,  781,    0,  787,    0,    0,  779,    0,  784,
   839,  536,  535,    0,  625,    0,    0,  867,  890,    0,
     0,    0,  904,    0,  915,   43,    0,    0,  339,  368,
   367,    0,  325,    0,  333,  389,  388,    0,  386,  664,
     0,  636,    0,  665,  226,  102,    0,    0,  188,    0,
   179,  177,  848,  801,    0,    0,  806,    0,    0,  776,
   780,    0,  785,    0,  851,    0,  753,    0,  894,  911,
   912,  905,  875,   36,   44,    0,    0,    0,    0,    0,
     0,    0,  666,    0,    0,  760,  186,    0,  198,    0,
     0,  812,  786,    0,  682,  840,    0,  762,    0,    0,
     0,  340,    0,    0,  334,  387,    0,    0,    0,  106,
   103,  189,  849,  796,    0,  852,  891,    0,  906,    0,
     0,  326,  672,    0,  673,  670,    0,  668,   99,    0,
    98,    0,    0,   87,   89,   90,   91,   92,   93,   94,
    95,   96,   97,  160,    0,    0,  242,  234,  235,  236,
   237,  238,  239,  240,  241,    0,    0,  232,    0,    0,
     0,    0,  895,  341,  337,    0,    0,    0,  637,   88,
     0,  285,  280,  284,    0,  227,  233,  120,  112,  113,
   114,  115,  116,  117,  118,  119,  121,    0,    0,  110,
   104,  683,    0,    0,  671,  669,    0,    0,    0,    0,
     0,    0,    0,  293,    0,    0,  243,    0,    0,  251,
     0,  170,  161,  169,    0,  107,  111,    0,  892,    0,
     0,    0,  279,    0,    0,  278,    0,    0,    0,    0,
   359,    0,  357,    0,    0,  204,    0,    0,    0,    0,
     0,  638,  228,  898,  896,  122,    0,  356,    0,    0,
     0,    0,  136,    0,    0,    0,    0,    0,    0,  162,
     0,    0,  208,    0,  360,    0,  246,  245,  244,  257,
   256,  253,  258,  259,  252,  271,  270,  263,  264,  260,
   262,  261,  265,  254,  255,  266,  267,  273,  272,  268,
   269,    0,    0,  297,    0,  276,  138,    0,  274,  165,
     0,    0,  140,    0,  361,    0,    0,  205,    0,    0,
     0,  358,  249,  131,  129,    0,    0,  301,    0,    0,
     0,    0,    0,    0,    0,  282,    0,    0,    0,    0,
   144,    0,    0,    0,    0,  362,  363,    0,    0,    0,
     0,    0,  126,  316,    0,  298,    0,    0,  310,    0,
     0,    0,  305,    0,  156,    0,    0,    0,    0,  151,
     0,    0,  294,    0,  141,    0,  135,  145,  163,  168,
   216,    0,  206,    0,    0,    0,    0,  130,    0,  123,
   127,    0,    0,    0,  312,    0,  313,  302,    0,    0,
   296,  306,  277,    0,    0,  137,  152,  275,  166,  292,
     0,  283,  287,  147,    0,    0,    0,  213,  215,  209,
   250,  128,  317,  319,  299,    0,    0,  311,  308,  155,
   153,    0,    0,    0,    0,  164,  217,  219,  207,    0,
     0,    0,  310,  167,  288,  290,  148,    0,    0,  210,
   321,  322,  318,  320,  309,    0,    0,  223,  222,  221,
   218,  220,    0,    0,    0,  211,  289,  291,
   };
   protected static  short [] yyDgoto  = {             9,
    10,   11,   12,   13,   58,   14,   15,   16,   17,  864,
    53,   18,   19,  256,   33,   20,  647,  247,  624,  436,
  1411,   90,  865,  762,  942,  997,  998,   22,   23,   24,
    25,   26,   27,  648,   29,   44,   45,   46,   47,   48,
   269,   92,  458,  459,  460,  290,  568,  777,  776, 1102,
  1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112,
  1113,   75,  251, 1203,  633,  952,  874, 1012, 1081, 1055,
  1130, 1158, 1129, 1159, 1160, 1007, 1286, 1263, 1311, 1312,
  1313,  877, 1309,  878,  678, 1176, 1274, 1228, 1299,  508,
  1292, 1268, 1328,  846, 1297, 1300, 1301, 1395, 1329, 1330,
  1326, 1114, 1183, 1141, 1204,  649, 1276, 1375, 1294, 1392,
    76,  291,  650,  651,  652,  653,  654,  784,  549, 1058,
   785,  550,  787, 1206, 1232, 1343, 1304, 1377, 1207, 1279,
  1400, 1423, 1344, 1345, 1421, 1408, 1409,  631,  873, 1054,
  1126, 1185, 1127, 1128, 1177, 1239, 1210, 1178,  258, 1262,
  1308, 1180, 1293, 1290, 1115, 1143, 1200, 1372, 1334, 1066,
  1373,  569, 1416, 1417, 1199, 1289, 1265, 1321, 1316, 1287,
  1353, 1358, 1319, 1322, 1323, 1403, 1359, 1317, 1318, 1413,
  1401, 1402,  628,  770, 1003,  950, 1048, 1004, 1005, 1073,
   866, 1046, 1090,  448,   34,  159,   82,   36,  259,  767,
   626, 1220,  869,  870,  946,  440,  260,  319,  447,  325,
  1008, 1009,  161,  162,  326,  164,  165,  166,  167,  168,
   169,  170,  171,  172,  173,  174,  175,  176,  177,  178,
   179,  180,  181,  182,  183,  277,  743,  917,  506,  684,
   810,  685,  686,  910,  184,  242,  690,  570,  571,  572,
   573,  737,  468,  469,  320,  915,  692,  321,  491,  492,
   493,  494,  322,  497,  680,  332,  706,  707,  824,  287,
   474,  288,  473,  185,  186,  187,  188,  189,  190,  191,
   192,  193,  194,  195,  196,  197,  198,  199,  200,  552,
   553,  554,  722,  723,  836,  724,  201,  542,  361,  926,
   202,  486,  629,  872, 1052, 1181,   77, 1013, 1014, 1097,
  1098,  947,  532,  345,  718, 1085,  533,  534,  292,  293,
   294,  205,  206,  207,  295,  296,  297,  298,  299,  300,
   301,  302,  303,  304,  305,  306,  219,  307,  543,  220,
   221,  339,  748,  609,  849,  782,  643,  881,  847,  850,
   851,  882,  883,  308,  222,  223,  224,  976,  919,  977,
   978,  979, 1032,  980,  225,  226,  227,  228,  661,  479,
   662,  900, 1025,  663,  898,  664, 1027, 1028,  229,  230,
   231,  232,  233,  234,  327,  518,  519,  921, 1034,  335,
   897,  793, 1060,  830, 1067,  235,  423,  236,  424,  852,
   933,  425,  620,  761,  758,  759,  938,  426,  427,  428,
   429,  430,  431,  856,  610,  854, 1038, 1132, 1189,  935,
  1070, 1164,  756,  616,  757,  992,  937,  993, 1071,  939,
    50,  239,   51,
   };
   protected static  short [] yySindex = {         -105,
     0,    0, -211, -200, -208,   37,    0,   30,    0,   96,
     0,  131,    0,    0,    0,    0,    0,    0,    0,    0,
 11915,    0,    0,    0,    0,    0,    0,   63,    0,    0,
   336,   54,  130,    0,   94,    0,    0,  169,    0,    0,
     0,  339,   54,  177,  235,   93,    0,    0,    0, 6023,
   112,    0, -248,    0,  131,    0,    0,  131,    0,    0,
     0, -197,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,   90, 9038,    0,    0,  177,    0,
   959,    0,  281,    0,  209,  340,  339,  235,  177,  382,
     0,  404,    0,  306,    0,  413,    0,    0,  208,10545,
   488,    0, -245,  527, 6176,    0,    0, -245,    0, -245,
  -245, -102, -245,    0, -245,    0, -210,    0,    0, 9672,
     0,    0, -245,    0, -245,    0, 9672,    0,  509,    0,
     0,    0,  208,    0,    0, -245,  519, -245,    0, 6805,
  7264,    0, 9672,    0,10332,10332,10332,10332,10332,10332,
 10332,10332,    0, -139,    0, 7417,    0,    0,  494,  352,
     0,  391, -219,    0,    0,  544,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  781,    0,  694,   66,  260,
   539,  489,  568,  540,  572,  586, -250,  633,    0,    0,
     0,    0,    0,    0, 2339,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  621,
   688,  -32,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0, -203, -174,  112,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  689, 7570,  647,    0,
  -156,    0,  467,    0,  519,  394,    0,    0,   99,  688,
  -219,  209,    0,    0,  705,    0,    0, 9804,    0,  830,
   677, 9936,    0,    0,    0,    0, 9672, -245, -245,  100,
   391,    0,  684,    0, 7417,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  768,  173,10545,    0,
  7417, 9672,  739,  759, 9672, 9672, 7971,  398,  780,   44,
 11061,  688,  236,    0,  793,    0,  802, 7417, 9672,  806,
   436, -245,    0, 9672,  509, 9144,    0,    0,  519, 9672,
  -205,  782,  -29,  790, 6329, -251,    0,    0,    0,    0,
     0,    0,    0,    0,  839, 9672,    0,    0,    0,    0,
 10990,  850,  209,    0,  493,    0,    0,  501,    0,    0,
   811, 9936, 8880,    0,    0,10332, 9672, 9672, 9672, 9672,
  9672, 9672, 9672, 9672, 9672, 9672, 9672,10332,10332,10332,
  7417, 7417,10332,10332,10332,10332,10332,10332,10332,10332,
 10332,10332,10332,10332,10332,10332,10332,10332, 9672,    0,
     0,    0,    0,    0,    0,    0,    0,11115,11132,  823,
     0,    0,    0,    0,    6,  771,    0,    0,    0,    0,
     0,    0,    0,    0,  826,  860,  519,  647,    0,    0,
     0,  868,    0,  985,  988,    0,    0,    0,    0, 7417,
     0,    0,    0,    0,    0,    0,  317,  590,    0,    0,
     0,    0,    0,  209,  297,    0,    0,  435,    0,  878,
     0,  880, -152,  509, -245,    0,    0,  841, 7094, -229,
     0,  881,    0,    0,    0,  884,  888,    0,  469,    0,
   893,    0,  890,    0,    0,    0,  445, 6788,    0,    0,
  7817,  487, 9672,  780, 8880,    0,  519,    0,    0,    0,
     0,  894,  896,    0,    0,  208,  509,  384,    0, 3051,
   897,    0,  898,  854,    0,  902, 9672,  964, 9672,  977,
     0,   13, 6329,    0,    0,    0,    0,    0,    0,    0,
   904,  509, 6329,    0,    0,    0,  519,  339,  865,11186,
     0,  912,    0,  906,10332,    0,  -25,    0,  377,    0,
     0,  648, 9672, 9672,  917, 1029,    0,    0,  -46,  916,
     0,    0,    0,    0,  694,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  694,  694,   66,   66,  260,  260,  260,  260,  539,
   539,  489,  568,  540,  572,  586,    0,  920, -190, 9672,
    17,  873,   32,  883,  915, 9672,    0,    0,    0,  938,
     0,    0,    0,  923,  931,  889, 3206,    0,  647,    0,
   647,    0,  647,    0,   74,    0,    0, 9804,    0,    0,
  9936,    0,  922,    0,    0,    0,  565,   63,  933,    0,
   932,  934,  936,    0,    0, 9672,    0,    0,  895,    0,
     0,  935,    0,  940, 9672, 1009,    0, 6176, 6176, 7247,
     0, 7971,    0,    0,    0,    0,    0,    0,    0,  942,
  9276,  321,    0,   25, -170,    0,  891,  901,    0,  -22,
     0,    0,  945,    0,  951,    0, 3361,    0,  509,    0,
     0,  365,  495,  903,    0,  948,  939,    0, 6176,    0,
  6176,    0, 9672,    0, 9672,    0,    0,    0,    0,    0,
     0,    0,    0, 7400,    0,    0,  907,10990,  979,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 8748,    0,
     0,    0,    0, 9012, 9672,    0, 6941,  953,    0,    0,
  1032,    0, 1033,    0,  -34,    0,  958, 9672, 9672,  918,
     0,  971,    0,    0,    0, -128,    0,    0,    0,  967,
     0,    0,    0,    0,    0, 9672, 9672,    0,    0,    0,
  9408,  961,  565,11186,  464,    0, 7417,    0,  244, 1077,
  1078,  968,  960,    0, 9672, 9672,  970, 9672, 1055,    0,
     0,    0, 7247,  975,    0, -145, 9540,    0,    0,    0,
     0, 7685,    0, 1084,    0,  688, 9672,  978,    0,    0,
   928,    0,    0,    0,  929,  120,    0,  930,    0,  960,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   676,    0,    0,    0,11061,    0,    0,  937,  976,  953,
     0, 9672,    0, 9672,    0, 9672,    0,    0,    0,    0,
     0,    0,    0,  971,   30, -152,    0,  515,  226,    0,
     0,  981,  981,  981,    0,    0,    0,    0,    0,  941,
   986,  961,    0,    0,    0, -187,    0, -186,  980,  989,
     0,    0,    0,    0,  990, 7247,  953, -190,    0,  994,
     0,    0,  992, 6176,    0,    0,    0,    0,    0,    0,
     0,    0,  983,    0,  780,    0,    0,    0, -192,    0,
   993,  120,    0,  954,  953,  509,    0,  955,  995,    0,
     0,    0, 9672, 1023, 9672,    0, 9672, 1024,  303,    0,
    30, -125, 1008,    0,    0,  963,    0, -128,    0,   63,
  3516, -162, -162, -162, 1001,    0,    0,    0,  505,    0,
  1002, 1124, 1125,    0,    0, 1014,  953, 9672,    0,    0,
     0,    0,    0, 9672,    0, 1019, -155,    0, -155,    0,
     0,    0,    0, 1017,    0, 9672, 6941,    0,    0, 1039,
   641, 1018,    0, 9672,    0,    0, 1025, -125,    0,    0,
     0,  973,    0, 1020,    0,    0,    0, 1022,    0,    0,
   982,    0, 1052,    0,    0,    0, 9408, 1027,    0, 9672,
     0,    0,    0,    0, 1026,  940,    0, 6176, 1028,    0,
     0, 6329,    0, 1035,    0, 1034,    0, 9672,    0,    0,
     0,    0,    0,    0,    0, -162,    0, 1031,   63, 3516,
  1036, 1040,    0, 1041, 1042,    0,    0, 9672,    0, 6176,
  6176,    0,    0, 6329,    0,    0, 6176,    0, 1054, 9672,
  9672,    0, 1053,  923,    0,    0,11044,   35,   63,    0,
     0,    0,    0,    0, 6329,    0,    0, 1058,    0, 1059,
  9672,    0,    0, 1045,    0,    0, 1038,    0,    0, 9038,
     0, 1049,   35,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  601, 9038,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1068,   63,    0,   63,  923,
  1069, 9672,    0,    0,    0, 1066,11044,10763,    0,    0,
   631,    0,    0,    0,10795,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0, 1071,   63,    0,
     0,    0, 1080, 9672,    0,    0, 7417, 7417, -121,11061,
   -87,  519, 1100,    0,  339, 6967,    0, 1133,    0,    0,
   923,    0,    0,    0,  923,    0,    0, 1030,    0, 1080,
  1037, 1043,    0, 7417, -181,    0, 7417, 1043, 1044, 1072,
     0,  339,    0, 1074,  481,    0, 1081, 1046,  -19,  634,
 10294,    0,    0,    0,    0,    0,  339,    0, 1079, 1050,
  1082, 1073,    0, 1085, 1086, 1087, -152, 1070, 1090,    0,
  1088, 1093,    0,  209,    0,  602,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0, 1096, -179,    0, 1089,    0,    0, 1083,    0,    0,
  1097, 1099,    0, 1098,    0, -152, -152,    0, -152, 1105,
  1108,    0,    0,    0,    0, 1116,   48,    0, 1117, -152,
  1232, 1119, -152, -152,  631,    0, 7247, 1092, 1126, 1098,
     0, 1123, 1131,   57, 1136,    0,    0, -152, 9408, 1101,
  1138, 1116,    0,    0, 9038,    0,   63,   63,    0, 1102,
  1139, 1117,    0, 1135,    0, 9672, 1103, 1140, 1119,    0,
  1145, 1146,    0, -163,    0, 1141,    0,    0,    0,    0,
     0, 9038,    0,   57,   57, 1157, 1158,    0, -179,    0,
     0,  313, 1161, 9038,    0, 9038,    0,    0, 7247, 1151,
     0,    0,    0, 1175, 1083,    0,    0,    0,    0,    0,
    85,    0,    0,    0, -162,  766, 1179,    0,    0,    0,
     0,    0,    0,    0,    0, 1229, 1284,    0,    0,    0,
     0, -162, 1181, 1184, 7247,    0,    0,    0,    0,   57,
   637,  637,    0,    0,    0,    0,    0,  -54,  -54,    0,
     0,    0,    0,    0,    0, 8880, 8880,    0,    0,    0,
     0,    0, 1188, 1185, 1186,    0,    0,    0,
   };
   protected static  short [] yyRindex = {         1956,
     0,    0,    0,    0,    0, 6482,    0,    0,    0, 1956,
     0, 1555,    0,    0,    0,    0,    0,    0,    0,    0,
   663,    0,    0,    0,    0,    0,    0, 1450,    0,    0,
   658, 1187,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  685,  609,    0, 1190,    0,    0,    0,    0,    0,
  1844,    0,   42,    0, 1555,    0,    0, 1555,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  443,10477,    0,    0,    0,    0,
     0,    0,    0,    0, 2178,    0, 3822, 1190, 1191,    0,
     0,  679,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 1195,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,11203,    0,    0, 1189,
     0,    0,    0,    0,    0,    0, 1189,    0,    0,    0,
     0,    0,    0,    0,    0,    0,   -8,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 5700,    0,    0,    0,    0,    0,  247,
     0, 3670, 5753,    0,    0, 3515,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 4004,    0, 4068, 4354, 4546,
  4920, 5112, 5240, 5368, 5496,  479, 3757, 3634,    0,    0,
     0,    0,    0,    0,   42,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  1148,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  797,  797, 1913,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 1200,    0,    0,    0,
     0,    0,    0,    0, 3901, 2439,    0,    0,    0, 2816,
  2439, 2178,    0,    0,    0,    0,    0,  735,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0, 2660,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 1201,    0,    0,    0,
     0, 2019, 2660,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 2581,    0,
   212,    0,  212,    0,   27,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1189,    0,    0,    0,    0,
  1196,    0, 2660,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  146,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,   24,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,   -9,    0,    0,    0,
     0, 1203,    0, 1153, 1156,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 7951,    0,    0,    0,
     0,    0,    0, 2660, 5867,    0,    0,    0,    0,    0,
     0,    0,10845,    0,    0,    0,    0,    0, 1199,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  693,  725,
     0,    0, 1209,    0,    0,    0,    0,    0,    0,    0,
   137,    0,    0, 3205, 1206,    0,  188,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0, 1205,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  139,    0,    0,    0,    0,    0,    0,    0,
     0, 7553,    0,    0,    0,    0, -173,  498,    0,    0,
     0, 1207,    0,    0,    0,    0, 2660,    0, 2660,    0,
     0,    0,    0,    0, -256,    0,    0,    0,    0,  205,
     0,    0,    0,    0, 4147,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0, 4211, 4290, 4418, 4482, 4610, 4674, 4738, 4802, 4984,
  5048, 5176, 5304, 5432, 5560, 5624,    0,    0,  750,    0,
   212,    0,  212,    0,    0,    0,    0,    0,    0, 5688,
     0,    0,    0, 1354,    0,  264,    0,    0,    0,    0,
     0,    0,    0,    0,10068,    0,    0,    0,    0,    0,
     0,    0,  762,    0,    0,    0,11257, 8116,    0,    0,
   783,  795,  809,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 1210,    0,    0,    0,    0,    0,    0,
     0, 1219,    0,    0,    0,    0,    0,    0,    0, 1220,
     0, 4839,    0,    0,  142,    0,    2, 2895,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  545,  702,    0,    0,    0, 1218,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, -244,    0,    0,    0, 1216,    0,    0,
     0,    0,    0,    0,  197,    0,  182,    0,    0,    0,
     0,11380,    0,    0,    0, -169,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0, 1217,11274,    0,11328,    0,    0,    0,10958,    0,
     0,    0,  769,    0, 1223,    0,    0,    0, 1590,    0,
     0,    0, 1227,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 3050,    0, 3360,    0,    0,
  1224,    0,    0,    0,    0,  545,    0,    0,    0,  769,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  696,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,11451,11522,10845,    0, 1182,    0,    0,
     0,  123,  123,  123,    0,    0,    0,    0,    0,    0,
     0, 1225,    0,    0,    0,    0,    0,    0,  825,  829,
     0,    0,    0,    0,    0,    0, 1230,  750,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0, 3205,    0,    0,    0, 1235,    0,
     0,  545,    0,  853, 1230, 7553,    0,  668,  715,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  133,    0,
 11593,11717,    0,    0,    0,    0,    0, -169,    0, -268,
     0, 1237, 1237, 1237,    0,    0,    0,    0,  772,    0,
   824,    0,    0,    0,    0,    0, 1216, 1233,    0,    0,
     0,    0,    0,    0,    0,    0, 1238,    0, 6635,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   333,  547,    0,    0,    0,    0,    0,11786,    0,    0,
     0,    0,    0, 1239,    0,    0,    0,  141,    0,    0,
     0,    0,  639,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1236,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1234,  610,    0,   11,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, -206,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 1754,    0,    0,    0, 8225, 8521,    0,
     0,    0,    0,    0, 1241,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  318,    0,    0,10613,
     0,    0, 8299,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,10695,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 8595,    0, 8373, 1754,
     0,    0,    0,    0,    0,    0,    0,  443,    0,    0,
     0,    0,    0,    0,  443,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 8447,    0,
     0,    0,  584,    0,    0,    0,    0,    0,    0,    0,
     0,  645,  458,    0, 8639,    0,    0,    0, 2786,    0,
  1754,    0,    0,    0, 1754,    0,    0,    0,    0,  584,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  662,    0, 1245,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  787,    0,  591,    0,
     0,    0,    0,    0,    0,    0,10845,  837,    0,    0,
     0,    0,    0, 1240,    0,  730,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  838,    0,    0,    0,    0,    0,
     0,    0,    0, 1242,    0,10845,10845,    0,10885,    0,
     0,    0,    0,    0,    0, 1244,11875,    0, 1250,10845,
 10200, 1252,10845,10845,    0,    0,    0,    0,    0, 1253,
     0,    0,    0, 8669,    0,    0,    0,10845,    0,    0,
     0, 1255,    0,    0,  329,    0,11845, 8906,    0,    0,
     0, 1256,    0,    0,    0,    0,    0,    0, 1258,    0,
     0,    0,    0,  644,    0,  844,    0,    0,    0,    0,
     0,  867,    0, 5879, 8774,    0,    0,    0,    0,    0,
     0,    0,    0, 1297,    0, 1350,    0,    0,    0,  847,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  652,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  652,    0,    0,    0,    0,    0,    0,    0, 8669,
 11652, 7843,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1206, 1206,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,
   };
   protected static  short [] yyGindex = {            0,
  1566,  608,   58,    0,    0,   40, -681,    4, -355,    0,
   767,    0,    0,   19,    0,    0,    1,    0,    0,    0,
  -601,  -70,    0,    0,    0,    0,    0, -514,    0,    0,
     0,    0,    0,   39,  -11,    0, 1589,    0, 1545,    0,
     0,    0,    0,  998,  999,  -48, -239,    0,    0,    0,
     0,  536, -605, -587, -497, -440, -386, -343, -305, -285,
  -735,-1049,    0, -215,    0,  357,    0, -917,    0,    0,
     0,    0,    0,    0,  482,  -49,  291,    0,    0,    0,
   330, -982,    0, -296, -316, 1395,    0,    0,    0, -807,
   279,    0,    0, -484,    0,    0,  345,    0,    0,  319,
     0,    0,  351,    0, -207, -781,    0,    0,    0,    0,
   471,  -45,    0,    0,  863,  864,  869,    0, -509,    0,
     0, -576,  866,  462,    0, -826,    0,    0,    0,    0,
     0,    0,    0,    0,  248,    0,    0,    0,    0,    0,
     0,    0,    0,  532,    0,    0,    0,    0, -240,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  552,
     0, -495,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  257,    0,    0,  346,    0,    0,  344,  353,  267,
     0,    0,    0,    0,    0,    0,    0,    0,  623,    0,
     0,    0,    0,  230,    0,   75,  -81,    0,    0,  437,
     0,  500,    0,  726,    0, 1159, -312, -202, -117,  656,
     0,  628,    0,  -74,    5,    0,    0,   45,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, -290,    0,  136,    0,    0, -138,    0,
     0,    0,  870,    0, -461, -180, 1000,  944,    0,  947,
     0, 1121, 1308, 1056,    0,    0,  778,    0,    0,    0,
     0, 1057,    0,    0,    0,    0,    0,    0, -479,    0,
     0,    0,    0,    0, 1021,    0,  444,  840,  803,  831,
  1283, 1290, 1293, 1289, 1292,    0, 1294,    0,    0,    0,
   972,    0,  775,    0,    0,    0,    0,    0,    0,    0,
     0, -310,    0,    0,    0,    0,  -76,    0,  690,    0,
   567,    0,  620,    0,    0,    0,  678, -512,  -44, -332,
   -43,    0, 1503,    0,   47,    0,   49,   50,   52,   65,
    73,   80,   82,   84,   92,   98,    0, -608,    0,  -53,
     0,    0,  816,    0, -309,    0,    0,    0,  722,    0,
   871,    0,  833, -451,    0,    0,    0,    0,    0,    0,
   747,    0,    0,  746,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  758,    0,    0,    0,    0,
     0,    0,    0,    0,  -83,    0, 1212,    0,    0,    0,
   905,    0,    0,    0,    0,    0, -221,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 1302,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  542,    0,
     0,    0,    0,    0,    0,    0,    0,  665,    0,    0,
     0,    0,    0,
   };
   protected static  short [] yyTable = {           252,
    21,  157,  499,  263,  158,  203,  204,  439,  509,  693,
    21,   52,  536,  679,  433,  482,   78,  265,  413,  338,
   719,   32,  764,   43,  410,  281,  490,  660,  462,  526,
   725,  257,  467,  442, 1056, 1015, 1016,  928,   28,  687,
   727,  926,  367,  330,   30,  375,  283,   39,   28,   56,
  1138,   21,  416,  276,  163,   37,  241,  452,  245,  799,
   800,  783,   43,  973,  665,  746, 1145,   55,  958,  960,
   786,  324,  360,   40, 1222,  974, 1284,   35,  324,   35,
   863,  416,  378,  331,  943,  811,    3,  333,  527,   28,
   342,  344, 1370, 1010,  346,  330,  208,  253,  209,  210,
   829,  211,  831,  645,  163,   41,  362,   43,  238,  163,
   815,  631,  974,  631,  212,  443,  538,  504,   35,  510,
   551,  274,  213,  469,   54,  469,  355,  867, 1072,  214,
     1,  215,  467,  216, 1193,  417,   54,  364,  449,  444,
   418,  217,  419,  454,  282,   54,  407,  218,  420,  421,
     1,    2,  317,   35,  318,   35,  157,  783,  408,  158,
   203,  204,  337,   35,  417,  312,  445,  631, 1196,  418,
   275,  419,  539,  313,  356,  240, 1011,  420,  421,  469,
   455,   80,  940, 1194,  666,  801,  747,  691,  646,  282,
   282,  282,  282,  282,  282,  282,  282, 1285,  360,  812,
   536, 1418,   31,  357,   81,   42,  884, 1371,  887,  163,
   536,  783,    5,   38,   35,   35,  246, 1197,  907,  461,
   422,  525,  625,  466,  817,  975,  959,  961,  470,    3,
    35,  358, 1223,  815,  281,  472,    5,   21,  285,    5,
   378,  360,  281,  309,   54,  310,  311,   80,  315,  432,
   316,  208,    4,  209,  210,  478,  211,  926,  328,    5,
   329,  480,  975,  481,  529, 1352,  485,  487,  334,  212,
    81,  336,  541,  340,  886,   28,   56,  213,  512,  439,
   513,  556,  524,  359,  214,  521,  215,  523,  216,  522,
  1099,  485, 1376,   49,  434,  970,  217,  373,  926,  500,
   535,  537,  218, 1314, 1386, 1235, 1387,  324,  142,  551,
   750,  314, 1341,  163,    6,    7,    8, 1419,  905,  857,
   858,  741,   35,  466,  567,  752, 1348,  391,  576,  577,
   578,  579,  580,  581,  582,  583,  584,  585,  586,  414,
   163,  590,  591,  816,  901,  792,  923,  817, 1393,  163,
   687,    1,    2,  282,  617,  618,  737,   80,  371,   35,
   608,  282, 1195,  392,    3,  926,  248,    1,  612,  614,
   249,  926,  877,  877,  332,  360,  716,  742,  660,  774,
    81,  490,  639,  360,   81,   35,  775,    2,  808,  366,
   684,  415,  374, 1157, 1236,   35,  661,  731,  462,    5,
   634,  467,   35,   80,  371,  737,  501,  360,  502, 1394,
   274,  965,    5,  771,  334,  772,  373,  773,   80, 1062,
   282,    5,   83, 1157,   54,  659,   81,    5,  655,  619,
     3,  250,  282,  282,  282,   35,  717,  282,  282,  393,
   394,   81,  982,  376,  983, 1272,    3,  877,  809,  677,
   684, 1083, 1084,    4,  689,  505,  567, 1396, 1086,  275,
     5,  660,  503,   91,  879,   35,   35,  520,  450,    4,
   696,  698, 1092, 1118, 1404,  732,    5,  734,  712,  661,
   714,  876,  876,  163,  899,  660,   80,  551,  535,  537,
   453, 1119,   35,   35, 1302, 1303,  721, 1305,  535,  537,
   452,   84,  685,  661,  842,  453,  813,   85, 1324,   81,
   451, 1331, 1332,  464,  736,  736,  660, 1378, 1379,  364,
   901, 1118,  359, 1149,   35,  901, 1347,  901, 1161,   81,
   901,  901,  509,  901,  901,  907,  823,  163,  703, 1119,
   907, 1150,  907,  551,  476,  907,  907,  163,  907,  907,
   376,  719,  376, 1149,  376,  376,  876,  376,  416,  376,
   452,  749,  685, 1101, 1117,  453,  907,  755,  349,  464,
   142, 1150,  465, 1410,  274, 1383,  349,  769,  357, 1212,
   349, 1120,   86, 1213,  889,  449,  996,  966, 1101,  461,
    87,  641,  466,  349,  704,  948,  477,  281,  691,  282,
   360,  376,  364,  376,   89,  901,  376,  485,    5,  804,
   656,  342, 1117,  914, 1148,  984,  797,   54,   81,   57,
   907,  677,   80,  275,   35,  349,  364, 1384,  465, 1120,
   364, 1151,  689,  364,  364,  364,   78,  949, 1121,  357,
   364,  417, 1045,  641, 1148,   81,  418,  821,  419,  395,
   396,  697,  516,  822,  420,  421,  667, 1024,  359,  357,
   342, 1151,  243,  357,  832,  244,  833,  635,  909,  699,
   270,  910,  163,  163,  271,  835,  910, 1029,  910,  918,
   667,  910,  910,   80,  910,  910, 1121,  635, 1152,  667,
   567,  515, 1122,  636,  262,  567,  844,  807,  677,  536,
   879,   35,  910,   80,  516,  160,   81,   80,  364,  860,
   861,  264,   79,  163,  639,  163,  282,  995, 1152,  359,
   365,  517,   80, 1059,  272,   80,   81,  875,  876,  640,
    81,  536,  481,  337,  591, 1123,  261,  888,  639,  359,
  1122,   59, 1153,  359,  263,   81,  485,  267,   81,  903,
   364,   80,  536,  640,  677,  160,  910,  274,  908,  368,
   160, 1082,   83,  495,   60,  639,  868,  496,  916,  544,
   268,   35, 1153, 1124,   81,  337,  545,   61,  369,  370,
   640,  823,   63, 1123,  273, 1154,   81,   64,  546,   65,
    66,   67,   68, 1125, 1135,  261,  261,   69,  371,  733,
   640,   70,   35,  932,  641,  934,  275,  936,  944,  372,
   673,  261, 1335,   71,  674, 1154,   72,  591,   73,  575,
   945, 1124,  591, 1155,  591,  591,  591,  591,  591,  591,
   591,  591,  591,  591,  591,   83,  592,  593,  446,   74,
   455, 1125,  591, 1156,  591,  670,  591,  677,  591,  591,
   591,  364,  688, 1155,  349,   80,  496,  509,   35,  284,
   160,   35,  349,  825,  591,  612,  349,  612,   52, 1018,
   544,  142,  783, 1156, 1388,  591,  337,  545,   81,  349,
   721, 1019,  401,  402,  988,  903,  990,  591,  991,  546,
   903,  359,  903,  286, 1217,  903,  903, 1179,  903,  903,
   337,  349,  591,  261, 1179,  371,  557,  363,  163,  349,
  1407,  349,  349,  349,  559,  558,  397,  398,  376,   35,
  1424, 1425,  897,  560,  404,  481,  349,  897,  371,  897,
   399,  400,  897,  897,  641,  897,  897, 1036,  677,  641,
   261,  371,   21,  641,  241, 1043,  371,  403,  868,  248,
  1002,  371,  405,  371,  371,  371,  371,  637,  641,  638,
   295,  371,  295, 1065,  160,  371,  261,  295,  481,  371,
   903,  481, 1142,  335,   69,   69,  261,  371,   69,  335,
   371,  406,  371,  261, 1218,  641,  336,  535,  537, 1069,
  1225,  160,  879,  142, 1040, 1041,  142, 1231,   21,  142,
   160,  663, 1182,  371,  641, 1237,  286,  897,  763,  481,
   663,   81,  766,  735,  662,  286,  261,  641,  409,  535,
   537, 1088,  991,  662,  354,   35,  349, 1096,  354,  349,
   349,  134,  163,  134,  412,  763,  163,  763,  134,  763,
   535,  537,  481,  927,   70,  744,  261,  261,   70, 1002,
   349,  349,  318,  349,  349,   61,  510,  435,  371,  349,
   441,  349,  510,  749,  163,  163,  342,  749,  163,  342,
   456,  163,  354,  261,  261,  388,  389,  390, 1100, 1116,
   349,  349,  752, 1163,  752,  463,  752, 1096,  511,  163,
   464,  427,  364,  427,  511, 1184,  364,  471,  349,  364,
   349,  364,   72, 1100,   72,  261,  364,  475,  349,  417,
   483,  349,  427,  427,  418, 1190,  419, 1191, 1192,  745,
  1229,  745,  420,  421,   35, 1397, 1398, 1116,  252, 1100,
   484,  754,  427,  754,  160, 1229,  854,  185,  854,  185,
   427,  185,  498,  427, 1221,  876,  876, 1224,  173,  354,
   173,   35, 1280,  354, 1281,  349,  354,  377,  354, 1100,
   180,  365,  180,  354, 1238,  347,  348,  349,  350,  351,
   352,  353,  354,  511,  181,  261,  181,  514,  378,  379,
   380,  381,  382,  383,  384,  385,  386,  387,  160,  197,
   203,  197,  203,  197,  174,  528,  174,  354,  160,  596,
   597,  598,  599,  530,  830,  261,  139,  300,  139,  300,
   540,   35,   35,  146,  254,  146,  307,  555,  307,   35,
   534,  534,  623,   95,  561,   97,  641,  641,   98,  953,
   954,  600,  601,  102,  594,  595,  615,  106,  627,  622,
   630,   35,   35,  632,   35,  642,  109,  644,  677, 1184,
  1208,  668,  667,  114,  657,  669,  671,  713,  116,  672,
   481,  694,  119,  695,  708,  709, 1208,  710,   35,  711,
   715,   35, 1208,  729,  121,  720,  122, 1364,  726, 1208,
   124,  728,  261,  739,  740,  744,  751, 1315,  131,  132,
   745,  754,  135,  760,  763,  255,  753,  765,  781,  766,
   788,  789,  798,  790, 1342,  791,  795,  828,  794,  796,
   677,  803,  818,  819,  240,  827,  826, 1354, 1356,  814,
   837,  839,  848,  160,  160,  853,  855,  859,    4,  871,
   880,  862,  893,  894,  904,  895,  896,  902,  906,  913,
   501,  920,  922,  924, 1342, 1342,  677,  930,  971,  962,
   929,  951,  261,   30,  955, 1412, 1412,  956,  963,  969,
   981,  964, 1420, 1420,  160,  968,  160,  567,  567,  989,
   823,  987,   87,  986,  994,  999, 1000, 1017, 1020, 1021,
  1022, 1023, 1030,  261, 1035, 1039, 1047, 1042, 1044, 1049,
  1011, 1050, 1057, 1061, 1074, 1051,  574, 1065, 1063, 1068,
  1342, 1087, 1078, 1079, 1080, 1133, 1077, 1137,  587,  588,
   589, 1136, 1139,  574,  574,  574,  574,  574,  574,  574,
   574,  574,  574,  574,  574,  574,  574,  574,  574, 1091,
  1134, 1146, 1162, 1165, 1186, 1188, 1198, 1211, 1227,  261,
  1230, 1264,  261, 1214, 1267, 1233, 1273, 1291, 1266,   53,
  1216, 1269, 1270, 1271, 1277, 1278, 1217, 1226, 1275, 1234,
   830,  830, 1283, 1236, 1295, 1288, 1296, 1298,  830,  830,
   830,  830,  830, 1306,  830,  830, 1307,  830,  830,  830,
   830,  830,  830,  830,  830, 1310, 1320, 1325, 1327,  830,
  1339,  830,  830,  830,  830,  830,  830, 1337, 1340,  830,
   261, 1346, 1363,  830,  830, 1336,  830,  830,  830, 1350,
  1361, 1366, 1368, 1369, 1349, 1360, 1365, 1374,  830, 1380,
   830,  574,  830,  830, 1385, 1381,  830, 1389,  830,  830,
   830,  830,  830,  830,  830,  830,  830,  830,  830,  830,
  1390,  830, 1399, 1384,  830,  830, 1383, 1405,  830,  830,
  1406, 1426, 1427, 1428,    7,   32,   33,  545,   34,  160,
   828,  730,   25,  613,  505,  327,  224,  830,  830,  100,
   798,  830,  506,  464,  614,  730,  830,  830,  830,  830,
   830,  802,  504,   32,  830,  530,  830,  748,  756,  773,
    33,  836,  830,  830,  803,  674,  757,  748,  777,  662,
   805,  778,  331,  807,  684,  662,  261,  356,  349,   30,
    30,  641,  641,  142,   30,  124,  237,  830,  830,  830,
   830,  303,  830,  149,  143,   30,  125,  304,  830,  150,
    30,  941,   88,  266,   30,  778,  779,   30, 1140, 1382,
  1187, 1351,  438, 1391, 1338, 1333, 1205, 1367,  885,   30,
    30,  890,  891, 1219,   30,   30, 1422,  892, 1147, 1415,
    30, 1357,   30,   30,   30,   30, 1144, 1362, 1414, 1355,
    30, 1075, 1282, 1001,   30, 1209,   30, 1076,  705,  562,
   806,  912,  841,  160,  738,  602,   30,  160,   30,   30,
   843,   30,  972,  603,  605,   30,  780,  604,  606,  838,
   985,  607, 1053, 1166, 1131,  261,   53,  411, 1037, 1064,
    55,   30,   30,  967,  957,  160,  160,   30,   30,  160,
   931,   55,  160, 1031, 1033, 1026,   55,  621,  802,  700,
    55, 1215,  261,   55,  925, 1089,    0,    0,    0,    0,
   160,    0,    0,    0,    0,   55,   55,    0,    0,    0,
    55,   55,    0,   30,    0,    0,   55,    0,   55,   55,
    55,   55,    0,    0,    0,    0,   55,    0,    0,    0,
    55,    0,   55,    0,    0,    0,    0,    0,    0,    0,
     0,    0,   55,    0,    0,   55,    0,   55,    0,    0,
     0,   55,  261,  261,    0,    0,    0,    0,    0,    0,
   261,    0,    0,    0,    0,    0,    0,    0,   55,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  261,  261,    0,  261,    0,    0,    0,    0,
     0,    0,  574,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  925,    0,  773,  773,    0,    0,  261,
     0,    0,  261,  773,  773,  773,  773,  773,    0,  773,
   773,    0,  773,  773,  773,  773,  773,  773,  773,    0,
     0,    0,    0,    0,  773,    0,  773,  773,  773,  773,
   773,  773,    0,    0,  773,    0,    0,    0,  773,  773,
     0,  773,  773,  773,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  773,    0,  773,    0,  773,  773,    0,
     0,  773,  922,  773,  773,  773,  773,  773,  773,  773,
   773,  773,  773,  773,  773,    0,  773,    0,    0,  773,
   773,    0,    0,  773,  773,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  773,  773,    0,    7,  773,    0,    0,    0,
     0,  773,  773,  773,  773,  773,    0,    0,    0,  773,
     0,  773,    0,    0,    0,    0,    0,  773,  773,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  773,  773,  773,  773,    0,  773,    0,   30,
    30,    0,    0,  773,   30,    0,    0,    0,   30,    0,
    30,    0,    0,   30,    0,   30,   30,    0,   30,    0,
    30,    0,   30,    0,   30,   30,   30,   30,    0,    0,
    30,   30,    0,    0,    0,    0,   30,    0,   30,   30,
    30,    0,    0,   30,   30,   30,    0,   30,    0,    0,
    30,    0,   30,   30,   30,   30,    0,    0,    0,   30,
    30,   30,    0,    0,   30,   30,   30,    0,    0,    0,
     0,    0,    0,   30,   30,    0,   30,   30,   30,   30,
    30,   30,    0,    0,    0,   30,    0,    0,    0,    0,
   925,    0,    0,    0,   54,    0,    0,    0,    0,    0,
     0,   30,   30,    0,    0,   54,    0,   30,   30,    0,
    54,    0,    0,    0,   54,    0,   30,   54,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,   54,
    54,    0,    0,    0,   54,   54,    0,    0,    0,    0,
    54,    0,   54,   54,   54,   54,    0,    0,    0,    0,
    54,    0,    0,    0,   54,    0,   54,   30,    0,  922,
     0,    0,    0,   54,    0,    0,   54,    0,    0,   54,
     0,   54,    0,    0,   54,   54,    0,    0,    0,   54,
     0,    0,    0,   54,    0,    0,   54,    0,    0,    0,
     0,    0,   54,    0,    0,    0,    0,    0,   54,   54,
     0,    0,    0,   54,   54,    0,   54,    0,    0,   54,
     0,   54,   54,   54,   54,    0,    0,   54,    0,   54,
     0,    0,   54,   54,    0,   54,   54,    0,    0,   54,
     0,    0,    0,    0,    0,   54,    0,    0,   54,    0,
    54,   54,   54,    0,   54,    0,   54,   54,    0,    0,
     0,    0,   54,    0,   54,   54,   54,   54,    0,    0,
     0,   54,   54,    0,  515,    0,   54,    0,   54,  515,
   515,    0,    0,    0,    0,    0,    0,    0,   54,    0,
     0,   54,    0,   54,    0,    0,    0,   54,    0,    0,
     0,    0,  515,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  515,    0,   54,  515,  515,    0,    0,    0,
   515,    0,    0,  515,    0,  515,    0,  515,  515,  515,
   515,    0,    0,    0,    0,  515,    0,    0,    0,  515,
     0,    0,    0,  515,    0,    0,    0,    0,    0,    0,
     0,  515,    0,    0,  515,    0,  515,  515,    0,    0,
     0,    0,  515,    0,  515,  515,  515,  515,  515,  515,
   515,  515,  515,  515,  515,    0,    0,  515,    0,    0,
     0,  515,  515,    0,  515,  515,  515,  515,  515,  515,
   515,    0,  515,  515,    0,  515,  515,  515,  515,  515,
   515,  515,  515,  515,  515,    0,  515,  515,  515,  515,
   515,  515,  515,  515,  515,  515,  515,  515,  515,  515,
   515,  515,  515,  515,  515,  515,  515,  515,    0,    0,
   515,    0,  515,  349,  515,    0,    0,  515,  349,  349,
     0,    0,  515,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  349,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  349,    0,    0,  349,  349,    0,    0,    0,  349,
     0,    0,  349,    0,  349,    0,  349,  349,  349,  349,
     0,    0,    0,    0,  349,    0,    0,    0,  349,    0,
     0,    0,  349,    0,    0,    0,    0,    0,    0,    0,
   349,    0,    0,  349,    0,  349,  349,    0,    0,    0,
     0,  349,    0,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,    0,  349,    0,    0,    0,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
     0,  349,  349,    0,    0,  349,  349,  349,  349,  349,
     0,    0,  349,  349,    0,    0,    0,  349,  349,  349,
   349,  349,  349,  349,  349,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  349,    0,    0,  349,
     0,  349,    0,  349,   93,    0,  349,    0,    0,    0,
     0,  349,   94,   95,   96,   97,    0,    0,   98,   99,
     0,  100,  101,  102,  103,  104,  105,  106,    0,    0,
     0,    0,    0,  107,    0,  108,  109,  110,  111,  112,
   113,    0,    0,  114,    0,    0,    0,  115,  116,    0,
   117,  118,  119,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  120,    0,  121,    0,  122,  123,    0,    0,
   124,    0,  125,  126,  127,  128,  129,  130,  131,  132,
   133,  134,  135,  136,    0,  137,    0,    0,  138,  139,
     0,    0,  140,  141,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  342,    0,    0,    0,    0,  342,
   342,  142,    0,    0,    0,  143,    0,    0,    0,    0,
   144,  145,  146,  147,  148,    0,    0,    0,  149,    0,
   150,    0,  342,    0,    0,    0,  151,  152,    0,    0,
     0,    0,  342,    0,    0,  342,  342,    0,    0,    0,
   342,    0,    0,  342,    0,  342,    0,  342,  342,  342,
   342,  153,  154,  155,  156,  342,    0,    0,    0,  342,
     0,    0,  240,  342,    0,    0,    0,    0,    0,    0,
     0,  342,    0,    0,  342,    0,  342,  342,    0,    0,
     0,    0,  342,    0,  342,  342,  342,  342,  342,  342,
   342,  342,  342,  342,  342,    0,    0,  342,    0,    0,
     0,  342,  342,  342,  342,  342,  342,    0,  342,  342,
   342,    0,  342,  342,    0,    0,  342,  342,  342,  342,
     0,    0,    0,  342,  342,    0,    0,    0,  342,  342,
   342,  342,  342,  342,  342,  342,  738,    0,    0,    0,
     0,  738,  738,    0,    0,    0,    0,  342,    0,    0,
   342,    0,  342,    0,  342,    0,    0,  342,    0,    0,
     0,    0,  342,    0,  738,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  738,    0,    0,  738,  738,    0,
     0,    0,  738,    0,    0,  738,    0,  738,    0,  738,
   738,  738,  738,    0,    0,    0,    0,  738,    0,    0,
     0,  738,    0,    0,    0,  738,    0,    0,    0,    0,
     0,    0,    0,  738,    0,  349,  738,    0,  738,  738,
     0,  349,    0,    0,  738,    0,  738,  738,  738,  738,
   738,  738,  738,  738,  738,  738,  738,    0,    0,  738,
     0,    0,    0,  738,  738,  738,  738,  738,  738,    0,
   738,  738,  738,    0,  738,  738,    0,  349,  738,  738,
   738,  738,    0,    0,    0,  738,  738,    0,    0,    0,
   738,  738,  738,  738,  738,  738,  738,  738,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  738,
     0,    0,  738,    0,  738,    0,  738,    0,  349,  738,
     0,    0,    0,  349,  738,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,    0,    0,    0,
     0,    0,    0,  349,  349,  349,  349,  349,  349,  349,
   349,  349,    0,  349,  349,    0,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  370,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  370,
     0,  379,    0,  349,    0,  349,  379,  379,  349,    0,
     0,    0,  370,  349,    0,    0,    0,  370,    0,    0,
   247,    0,  370,    0,  370,  370,  370,  370,    0,  379,
     0,    0,  370,    0,    0,    0,  370,    0,    0,  379,
   370,    0,  379,  379,    0,    0,    0,  379,  370,    0,
   379,  370,  379,  370,  379,  379,  379,  379,    0,    0,
     0,    0,  379,    0,    0,    0,  379,    0,    0,    0,
   379,    0,    0,    0,  370,    0,    0,    0,  379,    0,
   517,  379,    0,  379,  379,    0,  517,    0,    0,  379,
     0,  379,  379,  379,  379,  379,  379,  379,  379,  379,
   379,  379,    0,    0,  379,    0,    0,    0,  379,  379,
     0,  379,  379,  379,    0,  379,  379,  379,    0,  379,
   379,    0,  517,  379,  379,  379,  379,    0,    0,  370,
   379,  379,    0,    0,    0,  379,  379,  379,  379,  379,
   379,  379,  379,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  379,    0,    0,  379,    0,  379,
     0,    0,    0,  517,    0,    0,    0,    0,  517,  379,
   517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
   517,    0,    0,    0,    0,    0,    0,  517,  517,  517,
   517,  517,  517,  517,  517,  517,  517,    0,  517,  517,
     0,  517,  517,  517,  517,  517,  517,  517,  517,  517,
   517,    0,  517,  517,  517,  517,  517,  517,  517,  517,
   517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
   517,  517,  517,  517,    0,  513,  701,    0,    0,    0,
   517,  513,    0,    0,    0,   95,    0,   97,  517,    0,
    98,    0,    0,    0,    0,  102,    0,    0,    0,  106,
     0,    0,    0,    0,    0,    0,    0,    0,  109,    0,
     0,    0,    0,    0,    0,  114,    0,  513,    0,    0,
   116,    0,    0,    0,  119,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  121,    0,  122,    0,
     0,    0,  124,    0,    0,    0,    0,    0,    0,    0,
   131,  132,    0,    0,  135,    0,    0,  437,  513,    0,
     0,    0,    0,  513,    0,  513,  513,  513,  513,  513,
   513,  513,  513,  513,  513,  513,    0,    0,    0,    0,
     0,    0,  513,  513,    0,  513,  513,  513,  513,  513,
   513,  513,    0,  513,  513,    0,  513,  513,  513,  513,
   513,  513,  513,  513,  513,  513,    0,  513,  513,  513,
   513,  513,  513,  513,  513,  513,  513,  513,  513,  513,
   513,  513,  513,  513,  513,  513,  513,  513,  513,    0,
   521,  768,    0,    0,  702,  513,  521,    0,  513,    0,
    95,    0,   97,  513,    0,   98,    0,    0,    0,    0,
   102,    0,    0,    0,  106,    0,    0,    0,    0,    0,
     0,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,  521,    0,    0,  116,    0,    0,    0,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,    0,    0,    0,  124,    0,    0,
     0,    0,    0,    0,    0,  131,  132,    0,    0,  135,
     0,    0,  255,  521,    0,    0,    0,    0,  521,    0,
   521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
   521,    0,    0,    0,    0,    0,    0,    0,  521,    0,
   521,  521,  521,  521,  521,  521,  521,    0,  521,  521,
     0,  521,  521,  521,  521,  521,  521,  521,  521,  521,
   521,    0,  521,  521,  521,  521,  521,  521,  521,  521,
   521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
   521,  521,  521,  521,    0,  448,  820,    0,    0,   87,
   521,  448,    0,  521,    0,   95,    0,   97,  521,    0,
    98,    0,    0,    0,    0,  102,    0,    0,    0,  106,
     0,    0,    0,    0,    0,    0,    0,    0,  109,    0,
     0,    0,    0,    0,    0,  114,    0,  448,    0,    0,
   116,    0,    0,    0,  119,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  121,    0,  122,    0,
     0,    0,  124,    0,    0,    0,    0,    0,    0,    0,
   131,  132,    0,    0,  135,    0,    0,  255,  448,    0,
     0,    0,    0,  448,    0,  448,  448,  448,  448,  448,
   448,  448,  448,  448,  448,  448,    0,    0,    0,    0,
     0,    0,    0,  448,    0,  448,  448,  448,  448,  448,
   448,  448,    0,  448,  448,    0,  448,  448,  448,  448,
   448,  448,  448,  448,  448,  448,    0,  448,  448,  448,
   448,  448,  448,  448,  448,  448,  448,  448,  448,  448,
   448,  448,  448,  448,  448,  448,  448,  448,  448,    0,
   409, 1006,    0,    0,   87,  448,  409,    0,  448,    0,
    95,    0,   97,  448,    0,   98,    0,    0,    0,    0,
   102,    0,    0,    0,  106,    0,    0,    0,    0,    0,
     0,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,  409,    0,    0,  116,    0,    0,    0,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,    0,    0,    0,  124,    0,    0,
     0,    0,    0,    0,    0,  131,  132,    0,    0,  135,
     0,    0,  255,  409,    0,    0,    0,    0,  409,    0,
   409,  409,  409,  409,  409,  409,  409,  409,  409,  409,
   409,    0,    0,    0,    0,    0,    0,    0,  409,    0,
   409,  409,  409,  409,  409,  409,  409,    0,  409,  595,
     0,  409,  409,  409,  409,  409,  409,  409,  409,  409,
   409,    0,  409,  409,  409,  409,  409,  409,  409,  409,
   409,  409,  409,  409,  409,  409,  409,  409,  409,  409,
   409,  409,  409,  409,    0,  550,    0,    0,    0,   87,
   409,  550,    0,  409,    0,    0,    0,    0,  409,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  550,    0,    0,
     0,    0,  595,    0,    0,    0,    0,  595,    0,  595,
   595,  595,  595,  595,  595,  595,  595,  595,  595,  595,
     0,    0,    0,    0,    0,    0,    0,  595,    0,  595,
     0,  595,    0,  595,  595,  595,    0,    0,  550,    0,
     0,    0,  593,  550,    0,  550,  550,  550,  550,  550,
   550,  550,  550,  550,  550,  550,    0,    0,    0,    0,
     0,    0,    0,  550,    0,  550,    0,  550,    0,  550,
   550,  550,    0,  550,  550,    0,  550,  550,  550,  550,
   550,  550,  550,  550,  550,  550,    0,  595,    0,  550,
   550,  550,  550,  550,  550,  550,  550,  550,  550,  550,
   550,  550,  550,  550,  550,  550,  550,  349,  550,    0,
     0,    0,    0,  349,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  550,    0,  593,    0,    0,    0,    0,
   593,    0,  593,  593,  593,  593,  593,  593,  593,  593,
   593,  593,  593,    0,    0,  349,    0,    0,    0,  349,
   593,    0,  593,    0,  593,    0,  593,  593,  593,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  593,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  374,    0,    0,    0,
   349,    0,  374,    0,    0,  349,    0,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,    0,
   593,    0,    0,    0,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  374,  349,  349,    0,  374,  349,
   349,  349,  349,  349,    0,    0,  349,  349,    0,    0,
     0,  349,  349,  349,  349,  349,  349,  349,  349,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   349,    0,    0,  349,    0,  349,    0,  349,    0,  374,
   349,    0,    0,    0,  374,  349,  374,  374,  374,  374,
   374,  374,  374,  374,  374,  374,  374,    0,    0,  562,
     0,    0,    0,  374,  374,  562,  374,  374,  374,    0,
   374,  374,  374,    0,  374,  374,    0,    0,  374,  374,
   374,  374,    0,    0,    0,  374,  374,    0,    0,    0,
   374,  374,  374,  374,  374,  374,  374,  374,    0,    0,
     0,  562,    0,    0,    0,    0,    0,    0,    0,  374,
     0,    0,  374,    0,  374,    0,    0,    0,    0,    0,
     0,    0,    0,  566,  374,    0,    0,    0,    0,  566,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  562,    0,    0,    0,    0,  562,    0,  562,
   562,  562,  562,  562,  562,  562,  562,  562,  562,  562,
     0,    0,    0,    0,    0,  566,    0,  562,    0,  562,
     0,  562,    0,  562,  562,  562,    0,  562,  562,    0,
     0,  562,  562,  562,  562,  562,  562,  562,  562,  562,
     0,    0,    0,  562,  562,  562,  562,  562,  562,  562,
   562,    0,  569,    0,    0,    0,  566,    0,  569,    0,
     0,  566,  562,  566,  566,  566,  566,  566,  566,  566,
   566,  566,  566,  566,    0,    0,    0,  562,    0,    0,
     0,  566,    0,  566,    0,  566,    0,  566,  566,  566,
     0,  566,  566,    0,  569,  566,  566,  566,  566,    0,
     0,    0,  566,  566,    0,    0,    0,  566,  566,  566,
   566,  566,  566,  566,  566,    0,  567,    0,    0,    0,
     0,    0,  567,    0,    0,    0,  566,    0,    0,    0,
     0,    0,    0,    0,    0,  569,    0,    0,    0,    0,
   569,  566,  569,  569,  569,  569,  569,  569,  569,  569,
   569,  569,  569,    0,    0,    0,    0,    0,  567,    0,
   569,    0,  569,    0,  569,    0,  569,  569,  569,    0,
   569,  569,    0,    0,  569,  569,  569,  569,    0,    0,
     0,  569,  569,    0,    0,    0,  569,  569,  569,  569,
   569,  569,  569,  569,    0,  568,    0,    0,    0,  567,
     0,  568,    0,    0,  567,  569,  567,  567,  567,  567,
   567,  567,  567,  567,  567,  567,  567,    0,    0,    0,
   569,    0,    0,    0,  567,    0,  567,    0,  567,    0,
   567,  567,  567,    0,  567,  567,    0,  568,  567,  567,
   567,  567,    0,    0,    0,  567,  567,    0,    0,    0,
   567,  567,  567,  567,  567,  567,  567,  567,    0,  572,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  567,
     0,    0,    0,    0,    0,    0,    0,    0,  568,    0,
     0,    0,    0,  568,  567,  568,  568,  568,  568,  568,
   568,  568,  568,  568,  568,  568,    0,    0,    0,    0,
     0,    0,    0,  568,    0,  568,    0,  568,    0,  568,
   568,  568,    0,  568,  568,    0,    0,  568,  568,  568,
   568,    0,    0,  573,  568,  568,    0,    0,    0,  568,
   568,  568,  568,  568,  568,  568,  568,    0,    0,    0,
     0,    0,  572,    0,    0,    0,    0,  572,  568,  572,
   572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
     0,    0,    0,  568,    0,    0,    0,  572,    0,  572,
     0,  572,    0,  572,  572,  572,    0,    0,    0,    0,
     0,  572,  572,  572,  572,    0,    0,  574,  572,  572,
     0,    0,    0,  572,  572,  572,  572,  572,  572,  572,
   572,    0,    0,    0,    0,    0,  573,    0,    0,    0,
     0,  573,  572,  573,  573,  573,  573,  573,  573,  573,
   573,  573,  573,  573,    0,    0,    0,  572,    0,    0,
     0,  573,    0,  573,    0,  573,    0,  573,  573,  573,
     0,    0,    0,    0,    0,  573,  573,  573,  573,    0,
     0,  575,  573,  573,    0,    0,    0,  573,  573,  573,
   573,  573,  573,  573,  573,    0,    0,    0,    0,    0,
   574,    0,    0,    0,    0,  574,  573,  574,  574,  574,
   574,  574,  574,  574,  574,  574,  574,  574,    0,    0,
     0,  573,    0,    0,    0,  574,    0,  574,    0,  574,
     0,  574,  574,  574,    0,    0,    0,    0,    0,  574,
   574,  574,  574,    0,    0,  576,  574,  574,    0,    0,
     0,  574,  574,  574,  574,  574,  574,  574,  574,    0,
     0,    0,    0,    0,  575,    0,    0,    0,    0,  575,
   574,  575,  575,  575,  575,  575,  575,  575,  575,  575,
   575,  575,    0,    0,    0,  574,    0,    0,    0,  575,
     0,  575,    0,  575,    0,  575,  575,  575,    0,    0,
     0,    0,    0,  575,  575,  575,  575,    0,    0,  577,
   575,  575,    0,    0,    0,    0,    0,  575,  575,  575,
   575,  575,  575,    0,    0,    0,    0,    0,  576,    0,
     0,    0,    0,  576,  575,  576,  576,  576,  576,  576,
   576,  576,  576,  576,  576,  576,    0,    0,    0,  575,
     0,    0,    0,  576,    0,  576,    0,  576,    0,  576,
   576,  576,    0,    0,    0,    0,    0,  576,  576,  576,
   576,    0,    0,  578,  576,  576,    0,    0,    0,    0,
     0,  576,  576,  576,  576,  576,  576,    0,    0,    0,
     0,    0,  577,    0,    0,    0,    0,  577,  576,  577,
   577,  577,  577,  577,  577,  577,  577,  577,  577,  577,
     0,    0,    0,  576,    0,    0,    0,  577,    0,  577,
     0,  577,    0,  577,  577,  577,    0,    0,    0,    0,
     0,  577,  577,  577,  577,    0,    0,  579,  577,  577,
     0,    0,    0,    0,    0,  577,  577,  577,  577,  577,
   577,    0,    0,    0,    0,    0,  578,    0,    0,    0,
     0,  578,  577,  578,  578,  578,  578,  578,  578,  578,
   578,  578,  578,  578,  349,    0,    0,  577,    0,    0,
   349,  578,    0,  578,    0,  578,    0,  578,  578,  578,
     0,    0,    0,    0,    0,  578,  578,  578,  578,    0,
     0,    0,  578,  578,    0,    0,    0,    0,    0,  578,
   578,  578,  578,  578,  578,    0,  349,    0,    0,    0,
   579,    0,    0,    0,    0,  579,  578,  579,  579,  579,
   579,  579,  579,  579,  579,  579,  579,  579,    0,    0,
     0,  578,    0,    0,    0,  579,    0,  579,    0,  579,
     0,  579,  579,  579,    0,  580,    0,    0,    0,  579,
   579,  579,  579,    0,    0,    0,  579,  579,    0,    0,
     0,    0,    0,  579,  579,  579,  579,  579,  579,    0,
     0,    0,  349,    0,    0,  349,    0,  349,  349,    0,
   579,    0,  349,  349,    0,    0,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  579,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,    0,    0,    0,  581,
     0,    0,    0,    0,    0,    0,  349,  349,    0,    0,
     0,    0,    0,    0,  349,    0,    0,  349,  580,    0,
     0,    0,  349,  580,    0,  580,  580,  580,  580,  580,
   580,  580,  580,  580,  580,  580,    0,    0,    0,    0,
     0,    0,    0,  580,    0,  580,    0,  580,    0,  580,
   580,  580,    0,    0,    0,    0,    0,    0,    0,  580,
   580,    0,    0,  582,  580,  580,    0,    0,    0,    0,
     0,    0,    0,  580,  580,  580,  580,    0,    0,    0,
     0,    0,  581,    0,    0,    0,    0,  581,  580,  581,
   581,  581,  581,  581,  581,  581,  581,  581,  581,  581,
     0,    0,    0,  580,    0,    0,    0,  581,    0,  581,
     0,  581,    0,  581,  581,  581,    0,    0,    0,    0,
     0,    0,    0,  581,  581,    0,    0,  583,  581,  581,
     0,    0,    0,    0,    0,    0,    0,  581,  581,  581,
   581,    0,    0,    0,    0,    0,  582,    0,    0,    0,
     0,  582,  581,  582,  582,  582,  582,  582,  582,  582,
   582,  582,  582,  582,    0,    0,    0,  581,    0,    0,
     0,  582,    0,  582,    0,  582,    0,  582,  582,  582,
     0,    0,    0,    0,    0,    0,    0,  582,  582,    0,
     0,  584,  582,  582,    0,    0,    0,    0,    0,    0,
     0,  582,  582,  582,  582,    0,    0,    0,    0,    0,
   583,    0,    0,    0,    0,  583,  582,  583,  583,  583,
   583,  583,  583,  583,  583,  583,  583,  583,    0,    0,
     0,  582,    0,    0,    0,  583,    0,  583,    0,  583,
     0,  583,  583,  583,    0,    0,    0,    0,    0,    0,
     0,  583,  583,    0,    0,  585,  583,  583,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  583,  583,    0,
     0,    0,    0,    0,  584,    0,    0,    0,    0,  584,
   583,  584,  584,  584,  584,  584,  584,  584,  584,  584,
   584,  584,    0,    0,    0,  583,    0,    0,    0,  584,
     0,  584,    0,  584,    0,  584,  584,  584,    0,    0,
     0,    0,    0,    0,    0,  584,  584,    0,    0,  586,
   584,  584,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  584,  584,    0,    0,    0,    0,    0,  585,    0,
     0,    0,    0,  585,  584,  585,  585,  585,  585,  585,
   585,  585,  585,  585,  585,  585,    0,    0,    0,  584,
     0,    0,    0,  585,    0,  585,    0,  585,    0,  585,
   585,  585,    0,    0,    0,    0,    0,    0,    0,    0,
   585,    0,    0,  587,  585,  585,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  585,  585,    0,    0,    0,
     0,    0,  586,    0,    0,    0,    0,  586,  585,  586,
   586,  586,  586,  586,  586,  586,  586,  586,  586,  586,
     0,    0,    0,  585,    0,    0,    0,  586,    0,  586,
     0,  586,    0,  586,  586,  586,    0,    0,    0,    0,
     0,    0,    0,    0,  586,    0,    0,  588,  586,  586,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  586,
   586,    0,    0,    0,    0,    0,  587,    0,    0,    0,
     0,  587,  586,  587,  587,  587,  587,  587,  587,  587,
   587,  587,  587,  587,    0,    0,    0,  586,    0,    0,
     0,  587,    0,  587,    0,  587,    0,  587,  587,  587,
     0,    0,    0,    0,    0,    0,    0,    0,  587,    0,
     0,  589,    0,  587,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  587,  587,    0,    0,    0,    0,    0,
   588,    0,    0,    0,    0,  588,  587,  588,  588,  588,
   588,  588,  588,  588,  588,  588,  588,  588,    0,    0,
     0,  587,    0,    0,    0,  588,    0,  588,    0,  588,
     0,  588,  588,  588,    0,    0,    0,    0,    0,    0,
     0,    0,  588,    0,    0,  590,    0,  588,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  588,  588,    0,
     0,    0,    0,    0,  589,    0,    0,    0,    0,  589,
   588,  589,  589,  589,  589,  589,  589,  589,  589,  589,
   589,  589,    0,    0,    0,  588,    0,    0,    0,  589,
     0,  589,    0,  589,    0,  589,  589,  589,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  592,
     0,  589,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  589,  589,    0,    0,    0,    0,    0,  590,    0,
     0,    0,    0,  590,  589,  590,  590,  590,  590,  590,
   590,  590,  590,  590,  590,  590,    0,    0,    0,  589,
     0,    0,    0,  590,    0,  590,    0,  590,    0,  590,
   590,  590,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  913,    0,  590,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  590,  590,    0,    0,    0,
     0,  349,  592,    0,    0,    0,    0,  592,  590,  592,
   592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
     0,    0,    0,  590,    0,    0,    0,  592,    0,  592,
     0,  592,    0,  592,  592,  592,    0,  349,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  592,
     0,    0,    0,    0,  406,    0,    0,    0,    0,    0,
   592,    0,    0,    0,    0,    0,  913,    0,    0,    0,
     0,  913,  592,  913,  913,  913,  913,  913,  913,  913,
   913,  913,  913,    0,    0,    0,    0,  592,    0,    0,
   406,  913,    0,  913,    0,  913,  349,  913,  913,  913,
     0,    0,    0,    0,  349,    0,  349,    0,  349,    0,
     0,  349,    0,  349,  349,    0,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,    0,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,    0,
     0,  913,    0,  349,    0,  349,    0,  342,  349,  406,
   406,  406,  406,  349,  406,    0,  406,  406,  349,  406,
   406,  406,  406,  406,    0,  406,  406,  406,  406,   54,
   406,  406,  406,  406,  406,  406,  406,  406,  406,  406,
   406,  406,  406,  406,  406,  406,  406,  406,  406,  406,
   406,  406,   54,    0,  349,    0,  342,    0,  406,    0,
     0,  406,    0,    0,    0,   54,  406,    0,    0,    0,
    54,    0,    0,    0,    0,   54,    0,   54,   54,   54,
    54,    0,    0,    0,    0,   54,    0,    0,    0,   54,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,   54,    0,    0,   54,    0,   54,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  349,  349,  349,  349,  349,   54,   54,   54,
   349,  349,  212,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,    0,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,    0,    0,   93,    0,
     0,    0,  349,    0,    0,  349,   94,   95,   96,   97,
   349,    0,   98,   99,    0,  100,  101,  102,  103,  104,
   105,  106,    0,    0,    0,    0,    0,  107,    0,  108,
   109,  110,  111,  112,  113,    0,    0,  114,    0,    0,
     0,  115,  116,    0,  117,  118,  119,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  120,    0,  121,    0,
   122,  123,    0,    0,  124,    0,  125,  126,  127,  128,
   129,  130,  131,  132,  133,  134,  135,  136,    0,  137,
     0,    0,  138,  139,    0,    0,  140,  141,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  142,    0,    0,    0,  143,
     0,    0,    0,    0,  144,  145,  146,  147,  148,    0,
     0,    0,  149,    0,  150,    0,    0,    0,    0,    0,
   151,  152,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  289,    0,    0,    0,  153,  154,  155,  156,   94,
    95,   96,   97,    0,    0,   98,   99,    0,  100,  101,
   102,  103,  104,  105,  106,    0,    0,    0,    0,    0,
   107,    0,  108,  109,  110,  111,  112,  113,    0,    0,
   114,    0,    0,    0,  115,  116,    0,  117,  118,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  120,
     0,  121,    0,  122,  123,    0,    0,  124,    0,  125,
   126,  127,  128,  129,  130,  131,  132,  133,  134,  135,
   136,    0,  137,    0,    0,  138,  139,    0,    0,  140,
   141,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  142,    0,
     0,    0,  143,    0,    0,    0,    0,  144,  145,  146,
   147,  148,    0,    0,    0,  149,    0,  150,    0,    0,
     0,    0,    0,  151,  152,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  531,    0,    0,    0,  153,  154,
   155,  156,   94,   95,   96,   97,    0,    0,   98,   99,
     0,  100,  101,  102,  103,  104,  105,  106,    0,    0,
     0,    0,    0,  107,    0,  108,  109,  110,  111,  112,
   113,    0,    0,  114,    0,    0,    0,  115,  116,    0,
   117,  118,  119,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  120,    0,  121,    0,  122,  123,    0,    0,
   124,    0,  125,  126,  127,  128,  129,  130,  131,  132,
   133,  134,  135,  136,    0,  137,    0,    0,  138,  139,
     0,    0,  140,  141,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  142,    0,    0,    0,  143,    0,    0,    0,    0,
   144,  145,  146,  147,  148,    0,    0,    0,  149,    0,
   150,    0,    0,    0,    0,    0,  151,  152,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  918,    0,    0,
     0,  153,  154,  155,  156,  918,  918,  918,  918,    0,
     0,  918,  918,    0,  918,  918,  918,  918,  918,  918,
   918,    0,    0,    0,    0,    0,  918,    0,  918,  918,
   918,  918,  918,  918,    0,    0,  918,    0,    0,    0,
   918,  918,    0,  918,  918,  918,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  918,    0,  918,    0,  918,
   918,    0,    0,  918,    0,  918,  918,  918,  918,  918,
   918,  918,  918,  918,  918,  918,  918,    0,  918,    0,
     0,  918,  918,    0,    0,  918,  918,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  918,    0,    0,    0,  918,    0,
     0,    0,    0,  918,  918,  918,  918,  918,    0,    0,
     0,  918,    0,  918,    0,    0,    0,    0,    0,  918,
   918,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   782,    0,    0,    0,  918,  918,  918,  918,  782,  782,
   782,  782,    0,    0,  782,  782,    0,  782,  782,  782,
   782,  782,  782,  782,    0,    0,    0,    0,    0,  782,
     0,  782,  782,  782,  782,  782,  782,    0,    0,  782,
     0,    0,    0,  782,  782,    0,  782,  782,  782,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  782,    0,
   782,    0,  782,  782,    0,    0,  782,    0,  782,  782,
   782,  782,  782,  782,  782,  782,  782,  782,  782,  782,
     0,  782,    0,    0,  782,  782,    0,    0,  782,  782,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  782,    0,    0,
     0,  782,    0,    0,    0,    0,  782,  782,  782,  782,
   782,    0,    0,    0,  782,    0,  782,    0,    0,    0,
     0,    0,  782,  782,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  675,    0,    0,    0,  782,  782,  782,
   782,   94,   95,    0,   97,    0,    0,   98,  278,    0,
     0,    0,  102,  103,  104,    0,  106,    0,    0,   95,
     0,   97,  107,    0,   98,  109,    0,    0,    0,  102,
     0,    0,  114,  106,    0,    0,    0,  116,    0,  117,
   118,  119,  109,    0,    0,    0,    0,    0,    0,  114,
     0,    0,    0,  121,  116,  122,  123,    0,  119,  124,
     0,    0,  126,    0,  128,    0,  130,  131,  132,  279,
   121,  135,  122,    0,    0,    0,  124,    0,  139,    0,
     0,  140,  141,    0,  131,  132,    0,    0,  135,    0,
     0,  255,    0,    0,    0,    0,    0,    0,    0,    0,
   498,  676,    0,    0,  143,    0,    0,    0,    0,    0,
   145,  146,  147,  148,    0,    0,    0,  149,    0,  150,
     0,    0,    0,    0,    0,  151,  152,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  675,    0,    0,    0,
   153,  323,  155,  156,   94,   95,    0,   97,    0,    0,
    98,  278,    0,    0,    0,  102,  103,  104,  341,  106,
     0,    0,    0,    0,    0,  107,    0,   59,  109,    0,
     0,    0,    0,    0,    0,  114,    0,    0,    0,    0,
   116,    0,  117,  118,  119,    0,    0,    0,    0,    0,
    60,    0,    0,    0,    0,    0,  121,    0,  122,  123,
   845,    0,  124,   61,    0,  126,    0,  128,   63,  130,
   131,  132,  279,   64,  135,   65,   66,   67,   68,    0,
     0,  139,    0,   69,  140,  141,    0,   70,    0,    0,
     0, 1201,    0,    0,    0,    0,    0,    0,    0,   71,
     0,    0,   72,  498,   73,    0,    0,  143,    0,    0,
     0,    0,    0,  145,  146,  147,  148,    0,    0,    0,
   149,    0,  150,    0,    0,   74,    0,    0,  151,  152,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  658,
     0,    0,    0,  153,  323,  155,  156,   94,   95,    0,
    97,    0,    0,   98,  278,    0,    0,    0,  102,  103,
   104,    0,  106,    0,    0,    0,    0,    0,  107,    0,
  1202,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,    0,  116,    0,  117,  118,  119,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  121,
     0,  122,  123,    0,    0,  124,    0,    0,  126,    0,
   128,    0,  130,  131,  132,  279,    0,  135,    0,    0,
   137,    0,    0,    0,  139,    0,    0,  140,  141,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   143,    0,    0,    0,    0,    0,  145,  146,  147,  148,
     0,    0,    0,  149,    0,  150,    0,    0,    0,    0,
     0,  151,  152,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  675,    0,    0,    0,  153,  323,  155,  156,
    94,   95,    0,   97,    0,    0,   98,  278,    0,    0,
     0,  102,  103,  104,    0,  106,    0,    0,   95,    0,
    97,  107,    0,   98,  109,    0,    0,    0,  102,    0,
     0,  114,  106,    0,    0,    0,  116,    0,  117,  118,
   119,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,  121,  116,  122,  123,    0,  119,  124,    0,
     0,  126,    0,  128,    0,  130,  131,  132,  279,  121,
   135,  122,    0,    0,    0,  124,    0,  139,    0,    0,
   140,  141,    0,  131,  132,    0,    0,  135,    0,    0,
   255,    0,    0,    0,    0,    0,    0,    0,    0,  498,
     0,    0,    0,  143,    0,    0,    0,    0,    0,  145,
   146,  147,  148,    0,    0,    0,  149,    0,  150,    0,
     0,    0,    0,    0,  151,  152,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  834,    0,    0,    0,  153,
   323,  155,  156,   94,   95,    0,   97,    0,    0,   98,
   278,    0,    0,    0,  102,  103,  104,  343,  106,    0,
     0,   95,    0,   97,  107,    0,   98,  109,    0,    0,
     0,  102,    0,    0,  114,  106,    0,    0,    0,  116,
     0,  117,  118,  119,  109,    0,    0,    0,    0,    0,
     0,  114,    0,    0,    0,  121,  116,  122,  123,    0,
   119,  124,    0,    0,  126,    0,  128,    0,  130,  131,
   132,  279,  121,  135,  122,    0,    0,    0,  124,    0,
   139,    0,    0,  140,  141,    0,  131,  132,    0,    0,
   135,    0,    0,  255,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  143,    0,    0,    0,
     0,    0,  145,  146,  147,  148,    0,    0,    0,  149,
     0,  150,    0,    0,    0,    0,    0,  151,  152,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  617,    0,
     0,    0,  153,  323,  155,  156,  617,  617,    0,  617,
     0,    0,  617,  617,    0,    0,    0,  617,  617,  617,
    87,  617,    0,    0,   95,    0,   97,  617,    0,   98,
   617,    0,    0,    0,  102,    0,    0,  617,  106,    0,
     0,    0,  617,    0,  617,  617,  617,  109,    0,    0,
     0,    0,    0,    0,  114,    0,    0,    0,  617,  116,
   617,  617,    0,  119,  617,    0,    0,  617,    0,  617,
     0,  617,  617,  617,  617,  121,  617,  122,    0,    0,
     0,  124,    0,  617,    0,    0,  617,  617,    0,  131,
   132,    0,    0,  135,    0,    0,  437,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  617,
     0,    0,    0,    0,    0,  617,  617,  617,  617,    0,
     0,    0,  617,    0,  617,    0,    0,    0,    0,    0,
   617,  617,    0,    0,    0,    0,    0,    0,   94,   95,
     0,   97,    0,    0,   98,  278,    0,    0,    0,  102,
   103,  104,    0,  106,    0,  617,  617,  617,  617,  107,
     0,    0,  109,    0,    0,    0,    0,    0,    0,  114,
     0,    0,    0,   87,  116,    0,  117,  118,  119,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   121,    0,  122,  123,    0,    0,  124,    0,    0,  126,
     0,  128,    0,  130,  131,  132,  279,    0,  135,    0,
     0,    0,    0,    0,    0,  139,    0,    0,  140,  141,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  681,  911,    0,
     0,  143,    0,    0,    0,    0,    0,  145,  146,  147,
   148,    0,    0,    0,  149,    0,  150,    0,    0,    0,
     0,    0,  151,  152,    0,    0,    0,    0,    0,    0,
    94,   95,    0,   97,    0,    0,   98,  278,    0,    0,
     0,  102,  103,  104,    0,  106,    0,  153,  682,  155,
   156,  107,    0,   30,  109,   30,    0,  683,    0,    0,
     0,  114,    0,    0,    0,    0,  116,    0,  117,  118,
   119,    0,    0,    0,    0,    0,   30,    0,    0,    0,
     0,    0,  121,    0,  122,  123,    0,    0,  124,   30,
     0,  126,    0,  128,   30,  130,  131,  132,  279,   30,
   135,   30,   30,   30,   30,    0,    0,  139,    0,   30,
   140,  141,    0,   30,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,   30,    0,    0,   30,  681,
    30,    0,    0,  143,    0,    0,    0,    0,    0,  145,
   146,  147,  148,    0,    0,    0,  149,    0,  150,    0,
     0,   30,    0,    0,  151,  152,   30,   30,    0,    0,
     0,    0,  349,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  488,    0,    0,  153,
   682,  155,  156,    0,   94,   95,    0,   97,    0,  683,
    98,  278,    0,    0,    0,  102,  103,  104,  349,  106,
     0,    0,    0,    0,    0,  107,    0,    0,  109,    0,
     0,    0,    0,    0,    0,  114,    0,    0,    0,    0,
   116,    0,  117,  118,  119,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  121,    0,  122,  123,
     0,    0,  124,    0,    0,  126,    0,  128,    0,  130,
   131,  132,  279,    0,  135,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  349,  349,  349,
   349,    0,    0,    0,  349,  349,    0,    0,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  143,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
     0,    0,    0,    0,    0,    0,  349,    0,    0,  349,
     0,    0,    0,    0,    0,    0,   55,    0,   55,    0,
    55,    0,   55,  153,  489,   55,    0,   55,   55,    0,
    55,    0,   55,    0,   55,    0,   55,   55,   55,   55,
     0,    0,   55,   55,    0,    0,    0,    0,   55,   55,
    55,   55,   55,    0,    0,   55,   55,   55,    0,   55,
     0,   55,   55,   55,   55,   55,   55,   55,   55,    0,
    55,   55,   55,   55,    0,    0,   55,   55,   55,    0,
    55,    0,    0,    0,    0,   55,   55,    0,   55,   55,
     0,   55,   55,   55,    0,    0,    0,   55,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,   55,   55,   55,    0,    0,    0,
     0,    0,    0,    0,    0,   54,    0,    0,   55,   54,
     0,   54,    0,    0,   54,    0,   54,   54,    0,   54,
     0,   54,    0,   54,    0,   54,   54,   54,   54,    0,
     0,   54,   54,    0,    0,    0,    0,   54,    0,   54,
    54,   54,    0,    0,   54,    0,   54,    0,   54,   55,
     0,   54,    0,   54,   54,   54,   54,    0,    0,    0,
    54,   54,   54,    0,    0,   54,   54,   54,    0,    0,
     0,    0,    0,    0,   54,   54,    0,   54,   54,   54,
    54,   54,   54,   54,    0,   54,   54,    0,   54,    0,
    54,   54,    0,   54,    0,   54,    0,   54,    0,   54,
    54,   54,   54,   54,    0,   54,   54,    0,   85,    0,
     0,   54,    0,   54,   54,   54,    0,   54,   54,    0,
    54,    0,   54,    0,    0,   54,    0,   54,   54,   54,
    54,    0,    0,    0,   54,   54,   54,    0,    0,   54,
    54,   54,    0,    0,    0,    0,    0,    0,   54,   54,
     0,   54,   54,   54,   54,   54,   54,   54,   54,   54,
    54,    0,   54,    0,   54,   54,    0,   54,    0,   54,
     0,   54,    0,   54,   54,   54,   54,   54,    0,   54,
    54,    0,   86,    0,    0,   54,    0,   54,   54,   54,
     0,   54,   54,    0,   54,    0,   54,    0,    0,   54,
     0,   54,   54,   54,   54,    0,    0,    0,   54,   54,
    54,    0,    0,   54,   54,   54,    0,    0,    0,    0,
     0,    0,   54,   54,    0,   54,   54,   54,   54,   54,
    54,   54,   54,   54,   54,    0,   54,    0,   54,   54,
     0,   54,    0,   54,    0,   54,    0,   54,   54,   54,
    54,   54,    0,   54,   54,    0,  108,    0,    0,   54,
     0,   54,   54,   54,    0,   54,   54,    0,   54,    0,
    54,    0,    0,   54,    0,   54,   54,   54,   54,    0,
     0,    0,   54,   54,   54,    0,    0,   54,   54,   54,
     0,    0,    0,    0,    0,    0,   54,   54,    0,   54,
    54,   54,   54,   54,   54,   54,   54,   54,   54,    0,
    54,    0,   54,   54,    0,   54,    0,   54,    0,   54,
     0,   54,   54,   54,   54,   54,    0,   54,   54,    0,
   109,    0,    0,   54,    0,   54,   54,   54,    0,   54,
    54,    0,   54,    0,   54,    0,    0,   54,    0,   54,
    54,   54,   54,    0,    0,    0,   54,   54,   54,    0,
     0,   54,   54,   54,    0,    0,    0,    0,    0,    0,
    54,   54,    0,   54,   54,   54,   54,   54,   54,   54,
    54,   54,   54,    0,   54,    0,   54,   54,    0,   54,
     0,   54,    0,   54,    0,   54,   54,   54,   54,   54,
     0,   54,   54,    0,  230,    0,    0,   54,    0,   54,
    54,   54,    0,    0,   54,    0,   54,    0,   54,  349,
     0,   54,    0,   54,   54,   54,   54,    0,    0,    0,
    54,   54,   54,    0,    0,   54,   54,   54,    0,    0,
     0,    0,  349,    0,   54,   54,    0,   54,   54,   54,
    54,   54,   54,    0,   54,  349,   54,    0,    0,    0,
   349,    0,    0,  349,    0,  349,    0,  349,  349,  349,
   349,    0,   54,   54,    0,  349,    0,    0,  231,  349,
     0,    0,    0,  349,    0,   54,    0,    0,    0,    0,
    54,  349,    0,    0,  349,   54,  349,   54,   54,   54,
    54,    0,    0,    0,    0,   54,    0,    0,    0,   54,
     0,    0,    0,    0,    0,  349,    0,  349,    0,    0,
     0,   54,    0,  349,   54,  281,   54,  349,   54,    0,
     0,   94,   95,    0,   97,    0,    0,   98,  278,    0,
   349,    0,  102,  103,  104,    0,  106,   54,   54,   54,
     0,    0,  107,    0,   54,  109,    0,    0,    0,    0,
     0,    0,  114,    0,    0,    0,    0,  116,    0,  117,
   118,  119,  349,  563,    0,    0,    0,   54,    0,    0,
   564,    0,    0,  121,    0,  122,  123,    0,    0,  124,
    54,    0,  126,    0,  128,   54,  130,  131,  132,  279,
    54,  135,   54,   54,   54,   54,    0,    0,  565,    0,
    54,  140,  141,    0,   54,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,   54,    0,    0,   54,
     0,   54,    0,    0,  143,  840,    0,  566,    0,    0,
   145,  146,  147,  148,    0,    0,    0,  149,    0,  150,
     0,    0,   54,   54,   54,  151,  152,  214,    0,    0,
     0,    0,    0,   94,   95,    0,   97,    0,    0,   98,
   278,    0,    0,    0,  102,  103,  104,    0,  106,    0,
   153,  465,  155,  156,  107,    0,   54,  109,   54,    0,
     0,    0,    0,    0,  114,    0,    0,    0,    0,  116,
     0,  117,  118,  119,    0,  563,    0,    0,    0,   54,
     0,    0,  564,    0,    0,  121,    0,  122,  123,    0,
     0,  124,   54,    0,  126,    0,  128,   54,  130,  131,
   132,  279,   54,  135,   54,   54,   54,   54,    0,    0,
   565,    0,   54,  140,  141,    0,   54,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,   54,    0,
     0,   54,    0,   54,    0,    0,  143,    0,    0,  566,
     0,    0,  145,  146,  147,  148,    0,    0,    0,  149,
     0,  150,    0,    0,   54,    0,    0,  151,  152,  315,
     0,    0,    0,    0,    0,   94,   95,    0,   97,    0,
     0,   98,  278,    0,    0,    0,  102,  103,  104,    0,
   106,    0,  153,  465,  155,  156,  107,    0,   59,  109,
     0,    0,    0,    0,    0,    0,  114,    0,    0,    0,
     0,  116,    0,  117,  118,  119,    0,  563,    0,    0,
     0,   60,    0,    0,  564,    0,    0,  121,    0,  122,
   123,    0,    0,  124,   61,    0,  126,    0,  128,   63,
   130,  131,  132,  279,   64,  135,   65,   66,   67,   68,
     0,    0,  565,    0,   69,  140,  141,    0,   70,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    71,    0,    0,   72,    0,   73,    0,    0,  143,    0,
     0,    0,    0,    0,  145,  146,  147,  148,    0,    0,
     0,  149,    0,  150,    0,    0,   74,    0,    0,  151,
   152,    0,    0,    0,    0,    0,    0,   94,   95,    0,
    97,    0,    0,   98,  278,    0,    0,    0,  102,  103,
   104,    0,  106,    0,  153,  465,  155,  156,  107,    0,
     0,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,    0,  116,    0,  117,  118,  119,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  121,
     0,  122,  123,    0,    0,  124,    0,    0,  126,    0,
   128,    0,  130,  131,  132,  279,    0,  135,    0,    0,
   137,    0,    0,    0,  139,    0,    0,  140,  141,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   143,    0,    0,    0,    0,    0,  145,  146,  147,  148,
     0,    0,    0,  149,    0,  150,    0,    0,    0,    0,
     0,  151,  152,    0,    0,    0,    0,    0,    0,   94,
    95,    0,   97,    0,    0,   98,  278,    0,    0,    0,
   102,  103,  104,    0,  106,    0,  153,  323,  155,  156,
   107,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,    0,    0,    0,  116,    0,  117,  118,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,  123,    0,    0,  124,    0,    0,
   126,    0,  128,    0,  130,  131,  132,  279,    0,  135,
     0,    0,    0,    0,    0,    0,  139,    0,    0,  140,
   141,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  805,
     0,    0,  143,    0,    0,    0,    0,    0,  145,  146,
   147,  148,    0,    0,    0,  149,    0,  150,    0,    0,
     0,    0,    0,  151,  152,    0,    0,    0,    0,    0,
     0,   94,   95,    0,   97,    0,    0,   98,  278,    0,
     0,    0,  102,  103,  104,    0,  106,    0,  153,  323,
   155,  156,  107,    0,    0,  109,    0,    0,    0,    0,
     0,    0,  114,    0,    0,    0,    0,  116,    0,  117,
   118,  119,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  121,    0,  122,  123,    0,    0,  124,
     0,    0,  126,    0,  128,    0,  130,  131,  132,  279,
     0,  135,    0,    0,    0,    0,    0,    0,  139,    0,
     0,  140,  141,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   498,    0,    0,    0,  143,    0,    0,    0,    0,    0,
   145,  146,  147,  148,    0,    0,    0,  149,    0,  150,
     0,    0,    0,    0,    0,  151,  152,    0,    0,    0,
     0,    0,    0,   94,   95,    0,   97,    0,    0,   98,
   278,    0,    0,    0,  102,  103,  104,    0,  106,    0,
   153,  323,  155,  156,  107,    0,    0,  109,    0,    0,
     0,    0,    0,    0,  114,    0,    0,    0,    0,  116,
     0,  117,  118,  119,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  121,    0,  122,  123,    0,
     0,  124,    0,    0,  126,    0,  128,    0,  130,  131,
   132,  279,    0,  135,    0,    0,    0,    0,    0,    0,
   139,    0,    0,  140,  141,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  501,    0,    0,    0,  143,    0,    0,    0,
     0,    0,  145,  146,  147,  148,    0,    0,    0,  149,
     0,  150,    0,    0,    0,    0,    0,  151,  152,    0,
     0,    0,    0,    0,    0,   94,   95,    0,   97,    0,
     0,   98,  278,    0,    0,    0,  102,  103,  104,    0,
   106,    0,  153,  323,  155,  156,  107,    0,    0,  109,
     0,    0,    0,    0,    0,    0,  114,    0,    0,    0,
     0,  116,    0,  117,  118,  119,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  121,    0,  122,
   123,    0,    0,  124,    0,    0,  126,    0,  128,    0,
   130,  131,  132,  279,    0,  135,    0,    0,    0,    0,
     0,    0,  139,    0,    0,  140,  141,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  143,    0,
     0,    0,    0,    0,  145,  146,  147,  148,    0,    0,
     0,  149,    0,  150,    0,    0,    0,    0,    0,  151,
   152,    0,    0,    0,    0,    0,    0,   94,   95,    0,
    97,    0,    0,   98,  278,    0,    0,    0,  102,  103,
   104,    0,  106,    0,  153,  323,  155,  156,  107,    0,
     0,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,    0,  116,    0,  117,  118,  119,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  121,
     0,  122,  123,    0,    0,  124,    0,    0,  126,    0,
   128,    0,  130,  131,  132,  279,    0,  135,    0,    0,
     0,    0,    0,    0,  139,    0,    0,  140,  141,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   143,    0,    0,    0,    0,    0,  145,  146,  147,  148,
     0,    0,    0,  149,    0,  150,    0,    0,    0,    0,
     0,  151,  152,    0,    0,    0,    0,    0,    0,   94,
    95,    0,   97,    0,    0,   98,  278,    0,    0,    0,
   102,  103,  104,    0,  106,    0,  153,  457,  155,  156,
   107,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,    0,    0,    0,  116,    0,  117,  118,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,  123,    0,    0,  124,    0,    0,
   126,    0,  128,    0,  130,  131,  132,  279,    0,  135,
     0,    0,    0,    0,    0,    0,  139,    0,    0,  140,
   141,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  143,    0,    0,    0,    0,    0,  145,  146,
   147,  148,    0,    0,    0,  149,    0,  150,    0,    0,
     0,    0,    0,  151,  152,    0,    0,    0,    0,    0,
     0,   82,   82,    0,   82,    0,    0,   82,   82,    0,
     0,    0,   82,   82,   82,    0,   82,    0,  153,  465,
   155,  156,   82,    0,    0,   82,    0,    0,    0,    0,
     0,    0,   82,    0,    0,    0,    0,   82,    0,   82,
    82,   82,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,   82,    0,   82,   82,    0,    0,   82,
     0,    0,   82,    0,   82,    0,   82,   82,   82,   82,
     0,   82,    0,    0,    0,    0,    0,    0,   82,    0,
     0,   82,   82,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,   82,    0,    0,    0,    0,    0,
    82,   82,   82,   82,    0,    0,    0,   82,    0,   82,
     0,    0,    0,    0,    0,   82,   82,    0,    0,    0,
     0,    0,    0,  154,  154,    0,  154,    0,    0,  154,
   154,    0,    0,    0,  154,  154,  154,    0,  154,    0,
    82,   82,   82,   82,  154,    0,    0,  154,    0,    0,
     0,    0,    0,    0,  154,    0,    0,    0,    0,  154,
     0,  154,  154,  154,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  154,    0,  154,  154,    0,
     0,  154,    0,    0,  154,    0,  154,    0,  154,  154,
   154,  154,    0,  154,    0,    0,    0,    0,    0,    0,
   154,    0,    0,  154,  154,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  154,    0,    0,    0,
     0,    0,  154,  154,  154,  154,    0,    0, 1240,  154,
     0,  154,    0,    0,    0,    0,    0,  154,  154,    0,
     0,    0,    0,    0,    0,   94,   95,    0,   97,    0,
     0,   98,  278,    0,    0,    0,  102,  103,  104,    0,
   106,    0,  154,  154,  154,  154,  107,    0,    0,  109,
  1241,    0,    0,    0,    0,    0,  114,    0,    0,    0,
     0,  116,    0,  117,  118,  119,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  121,    0,  122,
   123,    0,    0,  124,    0,    0,  126,    0,  128,    0,
   130,  131,  132,  279,    0,  135, 1242, 1243, 1244, 1245,
     0, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253,    0,
     0, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  143,    0,
     0,    0,    0,    0,  145,  146,  147,  148,    0,    0,
     0,  149,    0,  150,    0,    0,    0,    0,    0,  151,
   152,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  642,
     0,  642,    0,  642,  153,  280,  642,  156,  642,  642,
     0,  642,    0,  642,    0,  642,    0,  642,  642,  642,
     0,    0,    0,  642,  642,    0,    0,    0,    0,  642,
     0,  642,  642,    0,    0,    0,  642,    0,    0,    0,
   642,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  642,  642,    0,  642,    0,    0,    0,  642,  642,
     0,    0,    0,    0,    0,    0,  642,  642,   94,   95,
   642,   97,    0,  642,   98,  278,    0,    0,  642,  102,
   103,  104,    0,  106,    0,    0,    0,    0,    0,  107,
     0,    0,  109,    0,    0,    0,  642,  642,    0,  114,
     0,    0,    0,    0,  116,    0,  117,  118,  119,  642,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   121,    0,  122,  123,    0,    0,  124,    0,    0,  126,
     0,  128,    0,  130,  131,  132,  279,  641,  135,  641,
     0,  137,  641,    0,  641,  641,    0,  641,    0,  641,
   642,  641,    0,  641,  641,  641,    0,    0,    0,  641,
   641,    0,    0,    0,    0,  641,    0,  641,  641,    0,
     0,  143,  641,    0,    0,    0,  641,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  641,    0,
   641,    0,    0,    0,  641,  641,    0,    0,    0,    0,
     0,    0,  641,  641,    0,    0,  641,    0,    0,  641,
     0,    0,    0,    0,  641,    0,    0,  153,  280,  641,
     0,  641,    0,    0,  641,    0,  641,  641,    0,  641,
     0,  641,    0,  641,    0,  641,  641,  641,    0,    0,
     0,  641,  641,    0,    0,  641,    0,  641,    0,  641,
   641,    0,    0,    0,  641,    0,    0,    0,  641,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   641,    0,  641,    0,    0,    0,  641,  641,    0,    0,
     0,    0,    0,    0,  641,  641,  641,   95,  641,   97,
     0,  641,   98,    0,    0, 1167,  641,  102,    0,  248,
     0,  106,    0,  249, 1168, 1169,    0,    0,    0, 1170,
   109,    0,    0,    0,    0, 1171,    0,  114,    0,   95,
     0,   97,  116,    0,   98,    0,  119, 1167,    0,  102,
     0,  248,    0,  106,    0,  249, 1168, 1169,  121,    0,
   122, 1170,  109,    0,  124,    0,    0, 1171,    0,  114,
     0,    0,  131,  132,  116,    0,  135,    0,  119, 1172,
     0,    0,    0,    0, 1173,    0,    0,    0,  641,   54,
   121,   54,  122,    0,   54,    0,  124,    0,    0,   54,
     0,    0,    0,   54,  131,  132,    0,    0,  135,    0,
     0, 1172,   54,    0,    0, 1174, 1173,    0,    0,   54,
     0,    0,    0,    0,   54,    0,    0,    0,   54,   54,
    54,   54,   54,    0,   54,    0,    0,   54,    0,   54,
    54,    0,   54,   54,    0,    0,   54,    0,    0,   54,
     0,    0,   54,    0,   54,   54, 1175,    0,   54,   54,
     0,   54,    0,    0,   54,    0,    0,    0,   54,    0,
    54,    0,   54,    0,    0,    0,    0,   54,    0,    0,
    54,    0,   54,    0,    0,    0,   54,    0, 1175,   54,
     0,    0,  171,    0,   54,   54,    0,    0,   54,    0,
     0,   54,   54,    0,   54,    0,    0,   54,    0,    0,
     0,    0,   54,    0,    0,    0,   54,    0,    0,    0,
     0,    0,    0,    0,    0,   54,    0,    0,    0,    0,
   171,    0,   54,    0,   95,    0,   97,   54,   54,   98,
     0,   54,    0,   54,  102,   54,    0,    0,  106,    0,
    54,    0,    0,   54,    0,   54,    0,  109,    0,   54,
     0,    0,   54,    0,  114,    0,    0,   54,   54,  116,
     0,   54,    0,  119,   54,  544,    0,    0,   54,    0,
     0,    0,  545,    0,    0,  121,    0,  122,   95,    0,
    97,  124,    0,   98,  546, 1093,    0,    0,  102,  131,
   132,    0,  106,  135,    0,   95,  547,   97,    0,    0,
    98,  109,    0,    0,    0,  102,    0,    0,  114,  106,
     0,    0,    0,  116,    0, 1094,    0,  119,  109,    0,
     0,    0,    0,    0,    0,  114,    0,    0,    0,  121,
   116,  122,    0,    0,  119,  124, 1095,    0,    0,    0,
     0,   54,    0,  131,  132,    0,  121,  135,  122,   95,
   255,   97,  124,    0,   98,    0,    0,    0,    0,  102,
   131,  132,    0,  106,  135,    0,   95,  507,   97,    0,
     0,   98,  109,  548,    0,    0,  102,    0,    0,  114,
   106,    0,    0,    0,  116,    0,    0,    0,  119,  109,
     0,    0,    0,    0,    0,    0,  114,    0,    0,    0,
   121,  116,  122,    0,    0,  119,  124,    0,    0,    0,
     0,    0,    0,    0,  131,  132,    0,  121,  135,  122,
    95,  255,   97,  124,    0,   98,    0,   87,    0,    0,
   102,  131,  132,    0,  106,  135,    0,  500,  255,  500,
     0,    0,  500,  109,   87,    0,    0,  500,    0,    0,
   114,  500,    0,    0,    0,  116,    0,    0,    0,  119,
   500,    0,    0,    0,    0,    0,    0,  500,    0,    0,
     0,  121,  500,  122,    0,    0,  500,  124,    0,    0,
     0,    0,    0,    0,    0,  131,  132,    0,  500,  135,
   500,  190,  547,  190,  500,    0,  190,    0,  611,    0,
     0,  190,  500,  500,    0,  190,  500,    0,  200,  500,
   200,    0,    0,  200,  190,  613,    0,    0,  200,    0,
     0,  190,  200,    0,    0,    0,  190,    0,    0,    0,
   190,  200,    0,    0,    0,    0,    0,    0,  200,    0,
     0,    0,  190,  200,  190,    0,    0,  200,  190,    0,
     0,    0,    0,    0,    0,    0,  190,  190,    0,  200,
   190,  200,  191,  190,  191,  200,    0,  191,    0,   87,
     0,    0,  191,  200,  200,    0,  191,  200,    0,    0,
   200,    0,    0,    0,    0,  191,  500,    0,    0,    0,
     0,    0,  191,    0,    0,    0,    0,  191,    0,    0,
     0,  191,    0,    0,    0,   39,    0,    0,    0,    0,
    39,    0,    0,  191,    0,  191,    0,    0,    0,  191,
     0,   39,    0,    0,    0,    0,   39,  191,  191,    0,
    39,  191,    0,   39,  191,    0,    0,    0,    0,    0,
   190,    0,    0,    0,    0,   39,   39,    0,    0,    0,
    39,   39,    0,    0,    0,    0,   39,  200,   39,   39,
    39,   39,    0,    0,    0,    0,   39,    0,    0,    0,
    39,    0,   39,    0,    0,    0,   40,    0,    0,    0,
     0,   40,   39,    0,   39,   39,    0,   39,    0,    0,
     0,   39,   40,    0,    0,    0,    0,   40,    0,    0,
     0,   40,    0,    0,   40,    0,    0,    0,   39,    0,
     0,  191,    0,   39,   39,    0,   40,   40,    0,    0,
     0,   40,   40,    0,    0,    0,    0,   40,    0,   40,
    40,   40,   40,    0,    0,    0,    0,   40,    0,    0,
     0,   40,    0,   40,    0,    0,    0,   37,    0,    0,
     0,    0,   37,   40,    0,   40,   40,    0,   40,    0,
     0,    0,   40,   37,    0,    0,    0,    0,   37,    0,
     0,    0,   37,    0,    0,   37,    0,    0,    0,   40,
     0,    0,    0,    0,   40,   40,    0,   37,   37,    0,
     0,    0,   37,   37,    0,    0,    0,    0,   37,    0,
    37,   37,   37,   37,    0,    0,    0,    0,   37,    0,
     0,    0,   37,    0,   37,    0,    0,    0,   38,    0,
     0,    0,    0,   38,   37,    0,    0,   37,    0,   37,
     0,    0,    0,   37,   38,    0,    0,    0,    0,   38,
     0,    0,    0,   38,    0,    0,   38,    0,    0,    0,
    37,    0,    0,    0,    0,   37,   37,    0,   38,   38,
     0,    0,    0,   38,   38,    0,    0,    0,    0,   38,
     0,   38,   38,   38,   38,    0,    0,    0,    0,   38,
     0,    0,   30,   38,    0,   38,    0,    0,    0,    0,
     0,    0,    0,    0,    0,   38,    0,    0,   38,    0,
    38,    0,    0,    0,   38,   30,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,   30,    0,
     0,   38,    0,   30,    0,    0,   38,   38,   30,    0,
    30,   30,   30,   30,    0,    0,   30,    0,   30,    0,
     0,    0,   30,    0,    0,    0,    0,   54,    0,    0,
     0,    0,    0,    0,   30,    0,    0,   30,   54,   30,
     0,    0,    0,   54,    0,    0,    0,   54,    0,    0,
    54,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    30,    0,   54,   54,    0,   30,   30,   54,   54,    0,
     0,    0,    0,   54,    0,   54,   54,   54,   54,    0,
     0,    0,    0,   54,    0,    0,    0,   54,    0,   54,
     0,    0,    0,    0,    0,    0,   54,    0,    0,   54,
     0,    0,   54,    0,   54,    0,    0,   54,   54,    0,
     0,    0,   54,    0,    0,    0,   54,    0,    0,   54,
     0,    0,    0,    0,    0,   54,    0,    0,    0,    0,
    41,   54,   54,    0,    0,    0,   54,   54,    0,    0,
     0,    0,   54,    0,   54,   54,   54,   54,    0,    0,
     0,    0,   54,    0,    0,   54,   54,    0,   54,    0,
     0,    0,    0,    0,    0,    0,    0,    0,   54,    0,
     0,   54,    0,   54,    0,    0,    0,   54,   54,    0,
     0,    0,    0,    0,    0,   54,    0,   54,    0,    0,
     0,   54,    0,    0,   54,    0,   54,    0,    0,   42,
     0,   54,    0,   54,   54,   54,   54,    0,   54,   54,
     0,   54,    0,    0,    0,   54,    0,    0,    0,    0,
     0,   54,    0,    0,    0,   59,   54,   54,    0,    0,
    54,   54,   54,   54,   54,   54,   54,    0,    0,   54,
     0,   54,    0,    0,    0,   54,    0,    0,   60,    0,
     0,    0,    0,   54,    0,    0,    0,   54,  314,    0,
    54,   61,   54,    0,    0,   62,   63,    0,    0,    0,
     0,   64,    0,   65,   66,   67,   68,    0,    0,    0,
     0,   69,    0,   54,    0,   70,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,   71,    0,    0,
    72,    0,   73,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,   74,
   };
   protected static  short [] yyCheck = {            76,
 {
 	oob_stack = new Stack<object> ();
 }
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="162" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1385" endline="1408">
<![CDATA[
 
 		protected virtual bool DoResolveTypeParameters ()
 		{
 			if (CurrentTypeParameters == null)
 				return true;
 
 			if (PartialContainer != this)
 				throw new InternalErrorException ();
 
 			var base_context = new BaseContext (this);
 			foreach (TypeParameter type_param in CurrentTypeParameters) {
 				if (!type_param.ResolveConstraints (base_context)) {
 					error = true;
 					return false;
 				}
 			}
 			foreach (TypeParameter type_param in CurrentTypeParameters) {
 				if (!type_param.ResolveConstraints (base_context)) {
 					error = true;
 					return false;
 				}
 			}
 
 			if (partial_parts != null) {
 				foreach (TypeContainer part in partial_parts)
 					UpdateTypeParameterConstraints (part);
 				foreach (TypeContainer part in partial_parts)
 					UpdateTypeParameterConstraints (part);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1020" endline="1052">
<![CDATA[
 
 		public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if (genericTypeArguments != null || genericMethodArguments != null)
 			{
 				throw new NotImplementedException();
 			}
 			// this method is inefficient, but since it isn't used we don't care
 			if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				foreach (KeyValuePair<MemberInfo, int> kv in importedMembers)
 				{
 					if (kv.Value == metadataToken)
 					{
 						return (MethodBase)kv.Key;
 					}
 				}
 				foreach (KeyValuePair<MemberInfo, int> kv in importedMembers)
 				{
 					if (kv.Value == metadataToken)
 					{
 						return (MethodBase)kv.Key;
 					}
 				}
 			}
 			// HACK if we're given a SymbolToken, we need to convert back
 			if ((metadataToken & 0xFF000000) == 0x06000000)
 			{
 				metadataToken = -(metadataToken & 0x00FFFFFF);
 			}
 			foreach (Type type in types)
 			{
 				MethodBase method = ((TypeBuilder)type).LookupMethod(metadataToken);
 				if (method != null)
 				{
 					return method;
 				}
 			}
 			foreach (Type type in types)
 			{
 				MethodBase method = ((TypeBuilder)type).LookupMethod(metadataToken);
 				if (method != null)
 				{
 					return method;
 				}
 			}
 			return ((TypeBuilder)moduleType).LookupMethod(metadataToken);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="653" endline="691">
<![CDATA[
 
 		private Assembly DefaultResolver(string refname, bool throwOnError)
 		{
 			Assembly asm = GetDynamicAssembly(refname);
 			if (asm != null)
 			{
 				return asm;
 			}
 			string fileName;
 			if (throwOnError)
 			{
 				try
 				{
 					fileName = System.Reflection.Assembly.ReflectionOnlyLoad(refname).Location;
 				}
 				catch (System.BadImageFormatException x)
 				{
 					throw new BadImageFormatException(x.Message, x);
 				}
 			}
 			else
 			{
 				try
 				{
 					fileName = System.Reflection.Assembly.ReflectionOnlyLoad(refname).Location;
 				}
 				catch (System.BadImageFormatException x)
 				{
 					throw new BadImageFormatException(x.Message, x);
 				}
 				catch (FileNotFoundException)
 				{
 					// we intentionally only swallow the FileNotFoundException, if the file exists but isn't a valid assembly,
 					// we should throw an exception
 					return null;
 				}
 			}
 			return LoadFile(fileName);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="163" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2328" endline="2356">
<![CDATA[
 		{
 			var tp = t as TypeParameterSpec;
 			if (tp != null) {
 				Variance v = tp.Variance;
 				if (expected == Variance.None && v != expected ||
 					expected == Variance.Covariant && v == Variance.Contravariant ||
 					expected == Variance.Contravariant && v == Variance.Covariant) {
 					((TypeParameter)tp.MemberDefinition).ErrorInvalidVariance (member, expected);
 				}
 
 				return expected;
 			}
 
 			if (t.TypeArguments.Length > 0) {
 				var targs_definition = t.MemberDefinition.TypeParameters;
 				TypeSpec[] targs = GetTypeArguments (t);
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 
 				return expected;
 			}
 
 			if (t.IsArray)
 				return CheckTypeVariance (GetElementType (t), expected, member);
 
 			return Variance.None;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2323" endline="2376">
<![CDATA[
 	}
 
 	public partial class TypeManager
 	{
 		public static Variance CheckTypeVariance (TypeSpec t, Variance expected, IMemberContext member)
 		{
 			var tp = t as TypeParameterSpec;
 			if (tp != null) {
 				Variance v = tp.Variance;
 				if (expected == Variance.None && v != expected ||
 					expected == Variance.Covariant && v == Variance.Contravariant ||
 					expected == Variance.Contravariant && v == Variance.Covariant) {
 					((TypeParameter)tp.MemberDefinition).ErrorInvalidVariance (member, expected);
 				}
 
 				return expected;
 			}
 
 			if (t.TypeArguments.Length > 0) {
 				var targs_definition = t.MemberDefinition.TypeParameters;
 				TypeSpec[] targs = GetTypeArguments (t);
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 
 				return expected;
 			}
 
 			if (t.IsArray)
 				return CheckTypeVariance (GetElementType (t), expected, member);
 
 			return Variance.None;
 		}
 	}
 
 	//
 	// Implements C# type inference
 	//
 	class TypeInference
 	{
 		//
 		// Tracks successful rate of type inference
 		//
 		int score = int.MaxValue;
 		readonly Arguments arguments;
 		readonly int arg_count;
 
 		public TypeInference (Arguments arguments)
 		{
 			this.arguments = arguments;
 			if (arguments != null)
 				arg_count = arguments.Count;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="164" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="78" endline="115">
<![CDATA[
 
 		static public string Name (Modifiers i)
 		{
 			string s = "";
 			
 			switch (i) {
 			case Modifiers.NEW
 				s = "new"; break;
 			case Modifiers.PUBLIC
 				s = "public"; break;
 			case Modifiers.PROTECTED
 				s = "protected"; break;
 			case Modifiers.INTERNAL
 				s = "internal"; break;
 			case Modifiers.PRIVATE
 				s = "private"; break;
 			case Modifiers.ABSTRACT
 				s = "abstract"; break;
 			case Modifiers.SEALED
 				s = "sealed"; break;
 			case Modifiers.STATIC
 				s = "static"; break;
 			case Modifiers.READONLY
 				s = "readonly"; break;
 			case Modifiers.VIRTUAL
 				s = "virtual"; break;
 			case Modifiers.OVERRIDE
 				s = "override"; break;
 			case Modifiers.EXTERN
 				s = "extern"; break;
 			case Modifiers.VOLATILE
 				s = "volatile"; break;
 			case Modifiers.UNSAFE
 				s = "unsafe"; break;
 			}
 
 			return s;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2091" endline="2165">
<![CDATA[
 		}
 
 		#endregion
 
 		/// <summary>
 		///   Returns a stringified representation of the Operator
 		/// </summary>
 		string OperName (Operator oper)
 		{
 			string s;
 			switch (oper){
 			case Operator.Multiply
 				s = "*";
 				break;
 			case Operator.Division
 				s = "/";
 				break;
 			case Operator.Modulus
 				s = "%";
 				break;
 			case Operator.Addition
 				s = "+";
 				break;
 			case Operator.Subtraction
 				s = "-";
 				break;
 			case Operator.LeftShift
 				s = "<<";
 				break;
 			case Operator.RightShift
 				s = ">>";
 				break;
 			case Operator.LessThan
 				s = "<";
 				break;
 			case Operator.GreaterThan
 				s = ">";
 				break;
 			case Operator.LessThanOrEqual
 				s = "<=";
 				break;
 			case Operator.GreaterThanOrEqual
 				s = ">=";
 				break;
 			case Operator.Equality
 				s = "==";
 				break;
 			case Operator.Inequality
 				s = "!=";
 				break;
 			case Operator.BitwiseAnd
 				s = "&";
 				break;
 			case Operator.BitwiseOr
 				s = "|";
 				break;
 			case Operator.ExclusiveOr
 				s = "^";
 				break;
 			case Operator.LogicalOr
 				s = "||";
 				break;
 			case Operator.LogicalAnd
 				s = "&&";
 				break;
 			default
 				s = oper.ToString ();
 				break;
 			}
 
 			if (IsCompound)
 				return s + "=";
 
 			return s;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="165" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="323" endline="360">
<![CDATA[
 
 		private ExceptionBlock BeginFinallyFilterFaultBlock()
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				Emit(OpCodes.Leave, block.labelEnd);
 			}
 			if (block.handlerOffset == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				Label labelEnd;
 				if (exceptionBlockAssistanceMode != EBAM_COMPAT)
 				{
 					labelEnd = block.labelEnd;
 				}
 				else
 				{
 					MarkLabel(block.labelEnd);
 					labelEnd = DefineLabel();
 					Emit(OpCodes.Leave, labelEnd);
 				}
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = code.Position - block.tryOffset;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			stackHeight = 0;
 			return block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="255" endline="291">
<![CDATA[
 		}
 
 		public void BeginCatchBlock(Type exceptionType)
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				if (exceptionType == null)
 				{
 					Emit(OpCodes.Endfilter);
 				}
 				else
 				{
 					Emit(OpCodes.Leave, block.labelEnd);
 				}
 			}
 			stackHeight = 0;
 			UpdateStack(1);
 			if (block.tryLength == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else if (exceptionType != null)
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = block.labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = block.tryLength;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			block.handlerOffset = code.Position;
 			block.exceptionType = exceptionType;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="166" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="106" endline="116">
<![CDATA[
 		public int LineNumberTable_LineBase = LineNumberTable.Default_LineBase;
 		public int LineNumberTable_LineRange = LineNumberTable.Default_LineRange;
 		public int LineNumberTable_OpcodeBase = LineNumberTable.Default_OpcodeBase;
 		#endregion
 
 		internal OffsetTable ()
 		{
 			int platform = (int) Environment.OSVersion.Platform;
 			if ((platform != 4) && (platform != 128))
 				FileFlags |= Flags.WindowsFileNames;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1033" endline="1069">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Flags
 		{
 			LocalNamesAmbiguous	= 1
 		}
 
 		public const int Size = 12;
 
 		internal MethodEntry (MonoSymbolFile file, MyBinaryReader reader, int index)
 		{
 			this.SymbolFile = file;
 			this.index = index;
 
 			Token = reader.ReadInt32 ();
 			DataOffset = reader.ReadInt32 ();
 			LineNumberTableOffset = reader.ReadInt32 ();
 
 			long old_pos = reader.BaseStream.Position;
 			reader.BaseStream.Position = DataOffset;
 
 			CompileUnitIndex = reader.ReadLeb128 ();
 			LocalVariableTableOffset = reader.ReadLeb128 ();
 			NamespaceID = reader.ReadLeb128 ();
 
 			CodeBlockTableOffset = reader.ReadLeb128 ();
 			ScopeVariableTableOffset = reader.ReadLeb128 ();
 
 			RealNameOffset = reader.ReadLeb128 ();
 
 			flags = (Flags) reader.ReadLeb128 ();
 
 			reader.BaseStream.Position = old_pos;
 
 			CompileUnit = file.GetCompileUnit (CompileUnitIndex);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="167" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="350" endline="379">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (RootContext.Unsafe) {
 				var pa = PredefinedAttributes.UnverifiableCode;
 				if (pa.IsDefined)
 					pa.EmitAttribute (builder);
 			}
 
 			foreach (var tc in types)
 				tc.DefineConstants ();
 			foreach (var tc in types)
 				tc.DefineConstants ();
 
 			HackCorlib ();
 
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 
 			if (Compiler.Report.Errors > 0)
 				return;
 
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 
 			if (compiler_generated != null)
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="319" endline="349">
<![CDATA[
 
 		public new void Define ()
 		{
 			builder = assembly.CreateModuleBuilder ();
 
 			// FIXME
 			static_data = null;
 
 			// TODO
 			// but that require DefineType clean-up
 			ResolveGlobalAttributes ();
 
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 
 			InitializePredefinedTypes ();
 
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="168" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2487" endline="2525">
<![CDATA[
 
 		// at least one of 'left' or 'right' is an enumeration constant (EnumConstant or SideEffectConstant or ...)
 		// if 'left' is not an enumeration constant, create one from the type of 'right'
 		Constant EnumLiftUp (ResolveContext ec, Constant left, Constant right, Location loc)
 		{
 			switch (oper) {
 			case Operator.BitwiseOr
 			case Operator.BitwiseAnd
 			case Operator.ExclusiveOr
 			case Operator.Equality
 			case Operator.Inequality
 			case Operator.LessThan
 			case Operator.LessThanOrEqual
 			case Operator.GreaterThan
 			case Operator.GreaterThanOrEqual
 				if (TypeManager.IsEnumType (left.Type))
 					return left;
 				
 				if (left.IsZeroInteger)
 					return left.TryReduce (ec, right.Type, loc);
 				
 				break;
 				
 			case Operator.Addition
 			case Operator.Subtraction
 				return left;
 				
 			case Operator.Multiply
 			case Operator.Division
 			case Operator.Modulus
 			case Operator.LeftShift
 			case Operator.RightShift
 				if (TypeManager.IsEnumType (right.Type) || TypeManager.IsEnumType (left.Type))
 					break;
 				return left;
 			}
 			Error_OperatorCannotBeApplied (ec, this.left, this.right);
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2186" endline="2232">
<![CDATA[
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (oper) {
 			case Operator.Addition
 				return IsCompound ? "AddAssign" 
 			case Operator.BitwiseAnd
 				return IsCompound ? "AndAssign" 
 			case Operator.BitwiseOr
 				return IsCompound ? "OrAssign" 
 			case Operator.Division
 				return IsCompound ? "DivideAssign" 
 			case Operator.ExclusiveOr
 				return IsCompound ? "ExclusiveOrAssign" 
 			case Operator.Equality
 				return "Equal";
 			case Operator.GreaterThan
 				return "GreaterThan";
 			case Operator.GreaterThanOrEqual
 				return "GreaterThanOrEqual";
 			case Operator.Inequality
 				return "NotEqual";
 			case Operator.LeftShift
 				return IsCompound ? "LeftShiftAssign" 
 			case Operator.LessThan
 				return "LessThan";
 			case Operator.LessThanOrEqual
 				return "LessThanOrEqual";
 			case Operator.LogicalAnd
 				return "And";
 			case Operator.LogicalOr
 				return "Or";
 			case Operator.Modulus
 				return IsCompound ? "ModuloAssign" 
 			case Operator.Multiply
 				return IsCompound ? "MultiplyAssign" 
 			case Operator.RightShift
 				return IsCompound ? "RightShiftAssign" 
 			case Operator.Subtraction
 				return IsCompound ? "SubtractAssign" 
 			default
 				throw new NotImplementedException ("Unknown expression type operator " + oper.ToString ());
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="169" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2372" endline="2391">
<![CDATA[
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			for (int i = 0; i < args.Length; i++)
 			{
 				Type xarg = args[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(xarg, args[i]))
 				{
 					Type[] xargs = new Type[args.Length];
 					Array.Copy(args, xargs, i);
 					xargs[i++] = xarg;
 					for (; i < args.Length; i++)
 					{
 						xargs[i] = args[i].BindTypeParameters(binder);
 					}
 					for (; i < args.Length; i++)
 					{
 						xargs[i] = args[i].BindTypeParameters(binder);
 					}
 					return Make(type, xargs, null, null);
 				}
 			}
 			for (int i = 0; i < args.Length; i++)
 			{
 				Type xarg = args[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(xarg, args[i]))
 				{
 					Type[] xargs = new Type[args.Length];
 					Array.Copy(args, xargs, i);
 					xargs[i++] = xarg;
 					for (; i < args.Length; i++)
 					{
 						xargs[i] = args[i].BindTypeParameters(binder);
 					}
 					return Make(type, xargs, null, null);
 				}
 			}
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="240" endline="270">
<![CDATA[
 
 		private void PopulateTypeDef()
 		{
 			if (typeDefs == null)
 			{
 				typeDefs = new TypeDefImpl[TypeDef.records.Length];
 				for (int i = 0; i < typeDefs.Length; i++)
 				{
 					TypeDefImpl type = new TypeDefImpl(this, i);
 					typeDefs[i] = type;
 					if (type.IsModulePseudoType)
 					{
 						moduleType = type;
 					}
 					else
 					{
 						types.Add(type.FullName, type);
 					}
 				}
 				for (int i = 0; i < typeDefs.Length; i++)
 				{
 					TypeDefImpl type = new TypeDefImpl(this, i);
 					typeDefs[i] = type;
 					if (type.IsModulePseudoType)
 					{
 						moduleType = type;
 					}
 					else
 					{
 						types.Add(type.FullName, type);
 					}
 				}
 				// add forwarded types to forwardedTypes dictionary (because Module.GetType(string) should return them)
 				for (int i = 0; i < ExportedType.records.Length; i++)
 				{
 					int implementation = ExportedType.records[i].Implementation;
 					if (implementation >> 24 == AssemblyRefTable.Index)
 					{
 						string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
 						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
 					}
 				}
 				for (int i = 0; i < ExportedType.records.Length; i++)
 				{
 					int implementation = ExportedType.records[i].Implementation;
 					if (implementation >> 24 == AssemblyRefTable.Index)
 					{
 						string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
 						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2550" endline="2577">
<![CDATA[
 
 			#endregion
 		}
 
 		readonly TypeSpec[] tp_args;
 		readonly TypeSpec[] fixed_types;
 		readonly List<BoundInfo>[] bounds;
 		bool failed;
 
 		// TODO MemberCache
 		public TypeInferenceContext (TypeSpec[] typeArguments)
 		{
 			if (typeArguments.Length == 0)
 				throw new ArgumentException ("Empty generic arguments");
 
 			fixed_types = new TypeSpec [typeArguments.Length];
 			for (int i = 0; i < typeArguments.Length; ++i) {
 				if (typeArguments [i].IsGenericParameter) {
 					if (bounds == null) {
 						bounds = new List<BoundInfo> [typeArguments.Length];
 						tp_args = new TypeSpec [typeArguments.Length];
 					}
 					tp_args [i] = typeArguments [i];
 				} else {
 					fixed_types [i] = typeArguments [i];
 				}
 			}
 			for (int i = 0; i < typeArguments.Length; ++i) {
 				if (typeArguments [i].IsGenericParameter) {
 					if (bounds == null) {
 						bounds = new List<BoundInfo> [typeArguments.Length];
 						tp_args = new TypeSpec [typeArguments.Length];
 					}
 					tp_args [i] = typeArguments [i];
 				} else {
 					fixed_types [i] = typeArguments [i];
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="170" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="666" endline="702">
<![CDATA[
 	}
 
 	//
 	// Default message recorder, it uses two types of message groups.
 	// Common messages
 	// Merged messages
 	//
 	// Used by the Lambda expressions to compile the code with various
 	// parameter values, or by attribute resolver
 	//
 	class SessionReportPrinter 
 	{
 		List<AbstractMessage> session_messages;
 		//
 		// A collection of exactly same messages reported in all sessions
 		//
 		List<AbstractMessage> common_messages;
 
 		//
 		// A collection of unique messages reported in all sessions
 		//
 		List<AbstractMessage> merged_messages;
 
 		public override void Print (AbstractMessage msg)
 		{
 			//
 			// This line is useful when debugging recorded messages
 			//
 			// Console.WriteLine ("RECORDING
 
 			if (session_messages == null)
 				session_messages = new List<AbstractMessage> ();
 
 			session_messages.Add (msg);
 
 			base.Print (msg);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\rootcontext.cs" startline="120" endline="170">
<![CDATA[
 		}
 
 
 		// 
 		// The default compiler checked state
 		//
 		static public bool Checked;
 
 		//
 		// If true, it means that the compiler is executing as
 		// in eval mode so unresolved variables are resolved in
 		// static classes maintained by the eval engine.
 		//
 		static public bool EvalMode;
 
 		//
 		// If true, the compiler is operating in statement mode,
 		// this currently turns local variable declaration into
 		// static variables of a class
 		//
 		static public bool StatementMode;
 		
 		//
 		// Whether to allow Unsafe code
 		//
 		static public bool Unsafe;
 
 		static public string Win32ResourceFile;
 		static public string Win32IconFile;
 
 		//
 		// A list of resource files for embedding
 		//
 		static public  List<AssemblyResource> Resources;
 
 		static public bool GenerateDebugInfo;
 
 		// Compiler debug flags only
 		public static bool ParseOnly, TokenizeOnly;
 
 		//
 		// Whether we are being linked against the standard libraries.
 		// This is only used to tell whether `System.Object' should
 		// have a base class or not.
 		//
 		public static bool StdLib;
 
 		public static RuntimeVersion StdLibRuntimeVersion;
 
 		public static bool NeedsEntryPoint {
 			get { return Target == Target.Exe || Target == Target.WinExe; }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5748" endline="5807">
<![CDATA[
 
 		//
 		// This Emit can be invoked in two contexts
 		//    * As a mechanism that will leave a value on the stack (new object)
 		//    * As one that wont (init struct)
 		//
 		// If we are dealing with a ValueType, we have a few
 		// situations to deal with
 		//
 		//    * The target is a ValueType, and we have been provided
 		//      the instance (this is easy, we are being assigned).
 		//
 		//    * The target of New is being passed as an argument,
 		//      to a boxing operation or a function that takes a
 		//      ValueType.
 		//
 		//      In this case, we need to create a temporary variable
 		//      that is the argument of New.
 		//
 		// Returns whether a value is left on the stack
 		//
 		// *** Implementation note ***
 		//
 		// To benefit from this optimization, each assignable expression
 		// has to manually cast to New and call this Emit.
 		//
 		// TODO
 		//
 		public virtual bool Emit (EmitContext ec, IMemoryLocation target)
 		{
 			bool is_value_type = TypeManager.IsValueType (type);
 			VariableReference vr = target as VariableReference;
 
 			if (target != null && is_value_type && (vr != null || method == null)) {
 				target.AddressOf (ec, AddressOp.Store);
 			} else if (vr != null && vr.IsRef) {
 				vr.EmitLoad (ec);
 			}
 			
 			if (arguments != null)
 				arguments.Emit (ec);
 
 			if (is_value_type) {
 				if (method == null) {
 					ec.Emit (OpCodes.Initobj, type);
 					return false;
 				}
 
 				if (vr != null) {
 					ec.Emit (OpCodes.Call, method);
 					return false;
 				}
 			}
 			
 			if (type is TypeParameterSpec)
 				return DoEmitTypeParameter (ec);			
 
 			ec.Emit (OpCodes.Newobj, method);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1544" endline="1618">
<![CDATA[
 
 		protected override void InitializeMemberCache (bool onlyTypes)
 		{
 			if (cache == null)
 				cache = new MemberCache (onlyTypes ? open_type.MemberCacheTypes 
 
 			var inflator = CreateLocalInflator ();
 
 			//
 			// Two stage inflate due to possible nested types recursive
 			// references
 			//
 			// class A<T> {
 			//    B b;
 			//    class B {
 			//      T Value;
 			//    }
 			// }
 			//
 			// When resolving type of `b' members of `B' cannot be 
 			// inflated because are not yet available in membercache
 			//
 			if ((state & StateFlags.PendingMemberCacheMembers) == 0) {
 				open_type.MemberCacheTypes.InflateTypes (cache, inflator);
 
 				//
 				// Inflate any implemented interfaces
 				//
 				if (open_type.Interfaces != null) {
 					ifaces = new List<TypeSpec> (open_type.Interfaces.Count);
 					foreach (var iface in open_type.Interfaces) {
 						var iface_inflated = inflator.Inflate (iface);
 						AddInterface (iface_inflated);
 					}
 					foreach (var iface in open_type.Interfaces) {
 						var iface_inflated = inflator.Inflate (iface);
 						AddInterface (iface_inflated);
 					}
 				}
 
 				//
 				// Handles the tricky case of recursive nested base generic type
 				//
 				// class A<T> 
 				//    class Nested {}
 				// }
 				//
 				// When inflating A<T>. base type is not yet known, secondary
 				// inflation is required (not common case) once base scope
 				// is known
 				//
 				if (open_type.BaseType == null) {
 					if (IsClass)
 						state |= StateFlags.PendingBaseTypeInflate;
 				} else {
 					BaseType = inflator.Inflate (open_type.BaseType);
 				}
 			} else if ((state & StateFlags.PendingBaseTypeInflate) != 0) {
 				BaseType = inflator.Inflate (open_type.BaseType);
 				state &= ~StateFlags.PendingBaseTypeInflate;
 			}
 
 			if (onlyTypes) {
 				state |= StateFlags.PendingMemberCacheMembers;
 				return;
 			}
 
 			var tc = open_type.MemberDefinition as TypeContainer;
 			if (tc != null && !tc.HasMembersDefined)
 				throw new InternalErrorException ("Inflating MemberCache with undefined members");
 
 			if ((state & StateFlags.PendingBaseTypeInflate) != 0) {
 				BaseType = inflator.Inflate (open_type.BaseType);
 				state &= ~StateFlags.PendingBaseTypeInflate;
 			}
 
 			state &= ~StateFlags.PendingMemberCacheMembers;
 			open_type.MemberCache.InflateMembers (cache, open_type, inflator);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="171" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="49" endline="90">
<![CDATA[
 
 		internal void Read(BinaryReader br)
 		{
 			Signature = br.ReadUInt32();
 			if (Signature != IMAGE_NT_HEADERS.MAGIC_SIGNATURE)
 			{
 				throw new BadImageFormatException();
 			}
 			FileHeader.Read(br);
 			OptionalHeader.Read(br);
 		}
 	}
 
 	sealed class IMAGE_FILE_HEADER
 	{
 		public const WORD IMAGE_FILE_MACHINE_I386 = 0x014c;
 		public const WORD IMAGE_FILE_MACHINE_IA64 = 0x0200;
 		public const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;
 
 		public const WORD IMAGE_FILE_32BIT_MACHINE = 0x0100;
 		public const WORD IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
 		public const WORD IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020;
 		public const WORD IMAGE_FILE_DLL = 0x2000;
 
 		public WORD Machine;
 		public WORD NumberOfSections;
 		public DWORD TimeDateStamp;
 		public DWORD PointerToSymbolTable;
 		public DWORD NumberOfSymbols;
 		public WORD SizeOfOptionalHeader;
 		public WORD Characteristics;
 
 		internal void Read(BinaryReader br)
 		{
 			Machine = br.ReadUInt16();
 			NumberOfSections = br.ReadUInt16();
 			TimeDateStamp = br.ReadUInt32();
 			PointerToSymbolTable = br.ReadUInt32();
 			NumberOfSymbols = br.ReadUInt32();
 			SizeOfOptionalHeader = br.ReadUInt16();
 			Characteristics = br.ReadUInt16();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="210" endline="255">
<![CDATA[
 	}
 
 	class SectionHeader
 	{
 		public const DWORD IMAGE_SCN_CNT_CODE = 0x00000020;
 		public const DWORD IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040;
 		public const DWORD IMAGE_SCN_MEM_DISCARDABLE = 0x02000000;
 		public const DWORD IMAGE_SCN_MEM_EXECUTE = 0x20000000;
 		public const DWORD IMAGE_SCN_MEM_READ = 0x40000000;
 		public const DWORD IMAGE_SCN_MEM_WRITE = 0x80000000;
 
 		public string Name;		// 8 byte UTF8 encoded 0-padded
 		public DWORD VirtualSize;
 		public DWORD VirtualAddress;
 		public DWORD SizeOfRawData;
 		public DWORD PointerToRawData;
 		public DWORD PointerToRelocations;
 		public DWORD PointerToLinenumbers;
 		public WORD NumberOfRelocations;
 		public WORD NumberOfLinenumbers;
 		public DWORD Characteristics;
 
 		internal void Read(BinaryReader br)
 		{
 			char[] name = new char[8];
 			int len = 8;
 			for (int i = 0; i < 8; i++)
 			{
 				byte b = br.ReadByte();
 				name[i] = (char)b;
 				if (b == 0 && len == 8)
 				{
 					len = i;
 				}
 			}
 			for (int i = 0; i < 8; i++)
 			{
 				byte b = br.ReadByte();
 				name[i] = (char)b;
 				if (b == 0 && len == 8)
 				{
 					len = i;
 				}
 			}
 			Name = new String(name, 0, len);
 			VirtualSize = br.ReadUInt32();
 			VirtualAddress = br.ReadUInt32();
 			SizeOfRawData = br.ReadUInt32();
 			PointerToRawData = br.ReadUInt32();
 			PointerToRelocations = br.ReadUInt32();
 			PointerToLinenumbers = br.ReadUInt32();
 			NumberOfRelocations = br.ReadUInt16();
 			NumberOfLinenumbers = br.ReadUInt16();
 			Characteristics = br.ReadUInt32();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="172" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5535" endline="5576">
<![CDATA[
 		}
 
 		#endregion
 
 		/// <summary>
 		/// Converts complex core type syntax like 'new int ()' to simple constant
 		/// </summary>
 		public static Constant Constantify (TypeSpec t, Location loc)
 		{
 			if (t == TypeManager.int32_type)
 				return new IntConstant (0, loc);
 			if (t == TypeManager.uint32_type)
 				return new UIntConstant (0, loc);
 			if (t == TypeManager.int64_type)
 				return new LongConstant (0, loc);
 			if (t == TypeManager.uint64_type)
 				return new ULongConstant (0, loc);
 			if (t == TypeManager.float_type)
 				return new FloatConstant (0, loc);
 			if (t == TypeManager.double_type)
 				return new DoubleConstant (0, loc);
 			if (t == TypeManager.short_type)
 				return new ShortConstant (0, loc);
 			if (t == TypeManager.ushort_type)
 				return new UShortConstant (0, loc);
 			if (t == TypeManager.sbyte_type)
 				return new SByteConstant (0, loc);
 			if (t == TypeManager.byte_type)
 				return new ByteConstant (0, loc);
 			if (t == TypeManager.char_type)
 				return new CharConstant ('\0', loc);
 			if (t == TypeManager.bool_type)
 				return new BoolConstant (false, loc);
 			if (t == TypeManager.decimal_type)
 				return new DecimalConstant (0, loc);
 			if (TypeManager.IsEnumType (t))
 				return new EnumConstant (Constantify (EnumSpec.GetUnderlyingType (t), loc), t);
 			if (TypeManager.IsNullableType (t))
 				return Nullable.LiftedNull.Create (t, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="113" endline="158">
<![CDATA[
 
 		public static Constant CreateConstantFromValue (TypeSpec t, object v, Location loc)
 		{
 			if (t == TypeManager.int32_type)
 				return new IntConstant ((int) v, loc);
 			if (t == TypeManager.string_type)
 				return new StringConstant ((string) v, loc);
 			if (t == TypeManager.uint32_type)
 				return new UIntConstant ((uint) v, loc);
 			if (t == TypeManager.int64_type)
 				return new LongConstant ((long) v, loc);
 			if (t == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) v, loc);
 			if (t == TypeManager.float_type)
 				return new FloatConstant ((float) v, loc);
 			if (t == TypeManager.double_type)
 				return new DoubleConstant ((double) v, loc);
 			if (t == TypeManager.short_type)
 				return new ShortConstant ((short)v, loc);
 			if (t == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)v, loc);
 			if (t == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)v, loc);
 			if (t == TypeManager.byte_type)
 				return new ByteConstant ((byte)v, loc);
 			if (t == TypeManager.char_type)
 				return new CharConstant ((char)v, loc);
 			if (t == TypeManager.bool_type)
 				return new BoolConstant ((bool) v, loc);
 			if (t == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) v, loc);
 			if (TypeManager.IsEnumType (t)) {
 				var real_type = EnumSpec.GetUnderlyingType (t);
 				return new EnumConstant (CreateConstantFromValue (real_type, v, loc).Resolve (null), t);
 			}
 			if (v == null) {
 				if (TypeManager.IsNullableType (t))
 					return Nullable.LiftedNull.Create (t, loc);
 
 				if (TypeManager.IsReferenceType (t))
 					return new NullConstant (t, loc);
 			}
 
 			throw new InternalErrorException ("Constant value `{0}' has unexpected underlying type `{1}'",
 				v, TypeManager.CSharpName (t));
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="173" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="528" endline="559">
<![CDATA[
 
 		Module LoadModuleFile (AssemblyDefinitionDynamic assembly, string module)
 		{
 			string total_log = "";
 
 			try {
 				try {
 					return assembly.IncludeModule (module);
 				} catch (FileNotFoundException) {
 					bool err = true;
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, module);
 						if (!module.EndsWith (".netmodule"))
 							full_path += ".netmodule";
 
 						try {
 							return assembly.IncludeModule (full_path);
 						} catch (FileNotFoundException ff) {
 							total_log += ff.FusionLog;
 						}
 					}
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, module);
 						if (!module.EndsWith (".netmodule"))
 							full_path += ".netmodule";
 
 						try {
 							return assembly.IncludeModule (full_path);
 						} catch (FileNotFoundException ff) {
 							total_log += ff.FusionLog;
 						}
 					}
 					if (err) {
 						Error_FileNotFound (module);
 						return null;
 					}
 				}
 			} catch (BadImageFormatException) {
 				Error_FileCorrupted (module);
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="480" endline="522">
<![CDATA[
 
 		Assembly LoadAssemblyFile (string assembly, bool soft)
 		{
 			Assembly a = null;
 
 			try {
 				try {
 					char[] path_chars = { '/', '\\' };
 
 					if (assembly.IndexOfAny (path_chars) != -1) {
 						a = Assembly.LoadFrom (assembly);
 					} else {
 						string ass = assembly;
 						if (ass.EndsWith (".dll") || ass.EndsWith (".exe"))
 							ass = assembly.Substring (0, assembly.Length - 4);
 						a = Assembly.Load (ass);
 					}
 				} catch (FileNotFoundException) {
 					bool err = !soft;
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, assembly);
 						if (!assembly.EndsWith (".dll") && !assembly.EndsWith (".exe"))
 							full_path += ".dll";
 
 						try {
 							a = Assembly.LoadFrom (full_path);
 							err = false;
 							break;
 						} catch (FileNotFoundException) {
 						}
 					}
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, assembly);
 						if (!assembly.EndsWith (".dll") && !assembly.EndsWith (".exe"))
 							full_path += ".dll";
 
 						try {
 							a = Assembly.LoadFrom (full_path);
 							err = false;
 							break;
 						} catch (FileNotFoundException) {
 						}
 					}
 
 					if (err) {
 						Error_FileNotFound (assembly);
 						return a;
 					}
 				}
 			} catch (BadImageFormatException) {
 				Error_FileCorrupted (assembly);
 			}
 
 			return a;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="174" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2175" endline="2208">
<![CDATA[
 		}
 
 		public virtual void Emit (DeclSpace parent)
 		{
 			method_data.Emit (parent);
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (method_data.MethodBuilder);
 			if (((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0))
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (method_data.MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			block = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="601" endline="637">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="175" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="301" endline="344">
<![CDATA[
 
 		public MethodBase GetMetaInfo ()
 		{
 			//
 			// inflatedMetaInfo is extra field needed for cases where we
 			// inflate method but another nested type can later inflate
 			// again (the cache would be build with inflated metaInfo) and
 			// TypeBuilder can work with method definitions only
 			//
 			if (inflatedMetaInfo == null) {
 				if ((state & StateFlags.PendingMetaInflate) != 0) {
 					var dt_meta = DeclaringType.GetMetaInfo ();
 
 					if (DeclaringType.IsTypeBuilder) {
 						if (IsConstructor)
 							inflatedMetaInfo = TypeBuilder.GetConstructor (dt_meta, (ConstructorInfo) metaInfo);
 						else
 							inflatedMetaInfo = TypeBuilder.GetMethod (dt_meta, (MethodInfo) metaInfo);
 					} else {
 #if STATIC
 						// it should not be reached
 						throw new NotImplementedException ();
 #else
 						inflatedMetaInfo = MethodInfo.GetMethodFromHandle (metaInfo.MethodHandle, dt_meta.TypeHandle);
 #endif
 					}
 
 					state &= ~StateFlags.PendingMetaInflate;
 				} else {
 					inflatedMetaInfo = metaInfo;
 				}
 			}
 
 			if ((state & StateFlags.PendingMakeMethod) != 0) {
 				var sre_targs = new MetaType[targs.Length];
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 
 				inflatedMetaInfo = ((MethodInfo) inflatedMetaInfo).MakeGenericMethod (sre_targs);
 				state &= ~StateFlags.PendingMakeMethod;
 			}
 
 			return inflatedMetaInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2052" endline="2110">
<![CDATA[
 
 		//
 		// When any element of the type is a dynamic type
 		//
 		// This method builds a transformation array for dynamic types
 		// used in places where DynamicAttribute cannot be applied to.
 		// It uses bool flag when type is of dynamic type and each
 		// section always starts with "false" for some reason.
 		//
 		// LAMESPEC
 		// 
 		// Example
 		// Transformation
 		//
 		static bool[] GetTransformationFlags (TypeSpec t)
 		{
 			bool[] element;
 			var ac = t as ArrayContainer;
 			if (ac != null) {
 				element = GetTransformationFlags (ac.Element);
 				if (element == null)
 					return null;
 
 				bool[] res = new bool[element.Length + 1];
 				res[0] = false;
 				Array.Copy (element, 0, res, 1, element.Length);
 				return res;
 			}
 
 			if (t == null)
 				return null;
 
 			if (t.IsGeneric) {
 				List<bool> transform = null;
 				var targs = t.TypeArguments;
 				for (int i = 0; i < targs.Length; ++i) {
 					element = GetTransformationFlags (targs[i]);
 					if (element != null) {
 						if (transform == null) {
 							transform = new List<bool> ();
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 						}
 
 						transform.AddRange (element);
 					} else if (transform != null) {
 						transform.Add (false);
 					}
 				}
 				for (int i = 0; i < targs.Length; ++i) {
 					element = GetTransformationFlags (targs[i]);
 					if (element != null) {
 						if (transform == null) {
 							transform = new List<bool> ();
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 						}
 
 						transform.AddRange (element);
 					} else if (transform != null) {
 						transform.Add (false);
 					}
 				}
 
 				if (transform != null)
 					return transform.ToArray ();
 			}
 
 			if (t == InternalType.Dynamic)
 				return new bool[] { true };
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="176" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1750" endline="1779">
<![CDATA[
 
 		int TokenizePreprocessorIdentifier (out int c)
 		{
 			// skip over white space
 			do {
 				c = get_char ();
 			} while (c == '\r' || c == ' ' || c == '\t');
 
 
 			int pos = 0;
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 
 			return pos;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1780" endline="1835">
<![CDATA[
 
 		PreprocessorDirective get_cmd_arg (out string arg)
 		{
 			int c;		
 
 			tokens_seen = false;
 			arg = "";
 
 			var cmd = GetPreprocessorDirective (id_builder, TokenizePreprocessorIdentifier (out c));
 
 			if ((cmd & PreprocessorDirective.CustomArgumentsParsing) != 0)
 				return cmd;
 
 			// skip over white space
 			while (c == '\r' || c == ' ' || c == '\t')
 				c = get_char ();
 			while (c == '\r' || c == ' ' || c == '\t')
 				c = get_char ();
 
 			static_cmd_arg.Length = 0;
 			int has_identifier_argument = (int)(cmd & PreprocessorDirective.RequiresArgument);
 
 			while (c != -1 && c != '\n' && c != '\r') {
 				if (c == '\\' && has_identifier_argument >= 0) {
 					if (has_identifier_argument != 0) {
 						has_identifier_argument = 1;
 
 						int peek = peek_char ();
 						if (peek == 'U' || peek == 'u') {
 							int surrogate;
 							c = EscapeUnicode (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									static_cmd_arg.Append ((char) c);
 								c = surrogate;
 							}
 						}
 					} else {
 						has_identifier_argument = -1;
 					}
 				}
 				static_cmd_arg.Append ((char) c);
 				c = get_char ();
 			}
 			while (c != -1 && c != '\n' && c != '\r') {
 				if (c == '\\' && has_identifier_argument >= 0) {
 					if (has_identifier_argument != 0) {
 						has_identifier_argument = 1;
 
 						int peek = peek_char ();
 						if (peek == 'U' || peek == 'u') {
 							int surrogate;
 							c = EscapeUnicode (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									static_cmd_arg.Append ((char) c);
 								c = surrogate;
 							}
 						}
 					} else {
 						has_identifier_argument = -1;
 					}
 				}
 				static_cmd_arg.Append ((char) c);
 				c = get_char ();
 			}
 
 			if (static_cmd_arg.Length != 0) {
 				arg = static_cmd_arg.ToString ();
 
 				// Eat any trailing whitespaces and single-line comments
 				if (arg.IndexOf ("//") != -1) {
 					arg = arg.Substring (0, arg.IndexOf ("//"));
 				}
 
 				arg = arg.Trim (simple_whitespaces);
 			}
 
 			return cmd;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="177" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="221" endline="268">
<![CDATA[
 	}
 
 	public sealed class TypeBuilder 
 	{
 		public const int UnspecifiedTypeSize = 0;
 		private readonly ITypeOwner owner;
 		private readonly int token;
 		private int extends;
 		private Type baseType;
 		private readonly int typeName;
 		private readonly int typeNameSpace;
 		private readonly string nameOrFullName;
 		private readonly List<MethodBuilder> methods = new List<MethodBuilder>();
 		private readonly List<FieldBuilder> fields = new List<FieldBuilder>();
 		private List<PropertyBuilder> properties;
 		private List<EventBuilder> events;
 		private TypeAttributes attribs;
 		private TypeFlags typeFlags;
 		private GenericTypeParameterBuilder[] gtpb;
 		private List<CustomAttributeBuilder> declarativeSecurity;
 		private List<Type> interfaces;
 
 		[Flags]
 		private enum TypeFlags
 		{
 			IsGenericTypeDefinition = 1,
 			HasNestedTypes = 2,
 			Baked = 4,
 		}
 
 		internal TypeBuilder(ITypeOwner owner, string name, Type baseType, TypeAttributes attribs)
 		{
 			this.owner = owner;
 			this.token = this.ModuleBuilder.TypeDef.AllocToken();
 			this.nameOrFullName = TypeNameParser.Escape(name);
 			SetParent(baseType);
 			this.attribs = attribs;
 			if (!this.IsNested)
 			{
 				int lastdot = name.LastIndexOf('.');
 				if (lastdot > 0)
 				{
 					this.typeNameSpace = this.ModuleBuilder.Strings.Add(name.Substring(0, lastdot));
 					name = name.Substring(lastdot + 1);
 				}
 			}
 			this.typeName = this.ModuleBuilder.Strings.Add(name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="60" endline="112">
<![CDATA[
 		private readonly PEReader peFile = new PEReader();
 		private readonly CliHeader cliHeader = new CliHeader();
 		private string imageRuntimeVersion;
 		private int metadataStreamVersion;
 		private byte[] stringHeap;
 		private byte[] blobHeap;
 		private byte[] userStringHeap;
 		private byte[] guidHeap;
 		private TypeDefImpl[] typeDefs;
 		private TypeDefImpl moduleType;
 		private Assembly[] assemblyRefs;
 		private Type[] typeRefs;
 		private Type[] typeSpecs;
 		private FieldInfo[] fields;
 		private MethodBase[] methods;
 		private MemberInfo[] memberRefs;
 		private Dictionary<int, string> strings = new Dictionary<int, string>();
 		private Dictionary<string, Type> types = new Dictionary<string, Type>();
 		private Dictionary<string, LazyForwardedType> forwardedTypes = new Dictionary<string, LazyForwardedType>();
 
 		private sealed class LazyForwardedType
 		{
 			private readonly int assemblyRef;
 			private Type type;
 
 			internal LazyForwardedType(int assemblyRef)
 			{
 				this.assemblyRef = assemblyRef;
 			}
 
 			internal Type GetType(ModuleReader module, string typeName)
 			{
 				if (type == null)
 				{
 					Assembly asm = module.ResolveAssemblyRef(assemblyRef);
 					type = asm.GetType(typeName, true);
 				}
 				return type;
 			}
 		}
 
 		internal ModuleReader(AssemblyReader assembly, Universe universe, Stream stream, string location)
 			
 		{
 			this.stream = stream;
 			this.location = location;
 			Read();
 			if (assembly == null && AssemblyTable.records.Length != 0)
 			{
 				assembly = new AssemblyReader(location, this);
 			}
 			this.assembly = assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="54" endline="115">
<![CDATA[
 		private PEFileKinds fileKind = PEFileKinds.Dll;
 		private MethodInfo entryPoint;
 		private VersionInfo versionInfo;
 		private ResourceSection unmanagedResources;
 		private string imageRuntimeVersion;
 		internal int mdStreamVersion = 0x20000;
 		private Module pseudoManifestModule;
 		private readonly List<ResourceFile> resourceFiles = new List<ResourceFile>();
 		private readonly List<ModuleBuilder> modules = new List<ModuleBuilder>();
 		private readonly List<Module> addedModules = new List<Module>();
 		private readonly List<CustomAttributeBuilder> customAttributes = new List<CustomAttributeBuilder>();
 		private readonly List<CustomAttributeBuilder> declarativeSecurity = new List<CustomAttributeBuilder>();
 		private readonly List<Type> typeForwarders = new List<Type>();
 
 		private struct ResourceFile
 		{
 			internal string Name;
 			internal string FileName;
 			internal ResourceAttributes Attributes;
 		}
 
 		internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 			
 		{
 			this.name = name.Name;
 			SetVersionHelper(name.Version);
 			if (name.CultureInfo != null && !string.IsNullOrEmpty(name.CultureInfo.Name))
 			{
 				this.culture = name.CultureInfo.Name;
 			}
 			this.flags = name.Flags;
 			this.hashAlgorithm = name.HashAlgorithm;
 			if (this.hashAlgorithm == AssemblyHashAlgorithm.None)
 			{
 				this.hashAlgorithm = AssemblyHashAlgorithm.SHA1;
 			}
 			this.keyPair = name.KeyPair;
 			if (this.keyPair != null)
 			{
 				this.publicKey = this.keyPair.PublicKey;
 			}
 			else
 			{
 				byte[] publicKey = name.GetPublicKey();
 				if (publicKey != null && publicKey.Length != 0)
 				{
 					this.publicKey = (byte[])publicKey.Clone();
 				}
 			}
 			this.dir = dir ?? ".";
 			this.requiredPermissions = requiredPermissions;
 			this.optionalPermissions = optionalPermissions;
 			this.refusedPermissions = refusedPermissions;
 			if (universe.HasMscorlib && universe.Mscorlib.ImageRuntimeVersion != null)
 			{
 				this.imageRuntimeVersion = universe.Mscorlib.ImageRuntimeVersion;
 			}
 			else
 			{
 				this.imageRuntimeVersion = typeof(object).Assembly.ImageRuntimeVersion;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="178" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="353" endline="406">
<![CDATA[
 
 		static public byte[] ToCapiPrivateKeyBlob (DSA dsa)
 		{
 			DSAParameters p = dsa.ExportParameters (true);
 			int keyLength = p.P.Length; // in bytes
 
 			// header + P + Q + G + X + count + seed
 			byte[] blob = new byte [16 + keyLength + 20 + keyLength + 20 + 4 + 20];
 
 			blob [0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x22;	// ALGID
 			blob [8] = 0x44;	// Magic
 			blob [9] = 0x53;
 			blob [10] = 0x53;
 			blob [11] = 0x32;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];
 			blob [13] = bitlen [1];
 			blob [14] = bitlen [2];
 			blob [15] = bitlen [3];
 
 			int pos = 16;
 			byte[] part = p.P;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Q;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			part = p.G;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.X;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
 			pos += 4;
 
 			part = p.Seed;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 
 			return blob;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="570" endline="625">
<![CDATA[
 
 		static public byte[] ToCapiPublicKeyBlob (DSA dsa)
 		{
 			DSAParameters p = dsa.ExportParameters (false);
 			int keyLength = p.P.Length; // in bytes
 
 			// header + P + Q + G + Y + count + seed
 			byte[] blob = new byte [16 + keyLength + 20 + keyLength + keyLength + 4 + 20];
 
 			blob [0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x22;	// ALGID
 			blob [8] = 0x44;	// Magic
 			blob [9] = 0x53;
 			blob [10] = 0x53;
 			blob [11] = 0x31;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];
 			blob [13] = bitlen [1];
 			blob [14] = bitlen [2];
 			blob [15] = bitlen [3];
 
 			int pos = 16;
 			byte[] part;
 
 			part = p.P;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Q;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			part = p.G;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Y;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
 			pos += 4;
 
 			part = p.Seed;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 
 			return blob;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="281" endline="352">
<![CDATA[
 
 		static public byte[] ToCapiPrivateKeyBlob (RSA rsa) 
 		{
 			RSAParameters p = rsa.ExportParameters (true);
 			int keyLength = p.Modulus.Length; // in bytes
 			byte[] blob = new byte [20 + (keyLength << 2) + (keyLength >> 1)];
 
 			blob [0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x24;	// ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
 			blob [8] = 0x52;	// Magic - RSA2 (ASCII in hex)
 			blob [9] = 0x53;
 			blob [10] = 0x41;
 			blob [11] = 0x32;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];	// bitlen
 			blob [13] = bitlen [1];	
 			blob [14] = bitlen [2];	
 			blob [15] = bitlen [3];
 
 			// public exponent (DWORD)
 			int pos = 16;
 			int n = p.Exponent.Length;
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			// modulus
 			pos = 20;
 			byte[] part = p.Modulus;
 			int len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 			// private key
 			part = p.P;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.Q;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.DP;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.DQ;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.InverseQ;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.D;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 
 			return blob;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="179" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="789" endline="823">
<![CDATA[
 
 		/// <summary>
 		///  Finds "most encompassed type" according to the spec (13.4.2)
 		///  amongst the methods in the MethodGroupExpr
 		/// </summary>
 		public static TypeSpec FindMostEncompassedType (IEnumerable<TypeSpec> types)
 		{
 			TypeSpec best = null;
 			EmptyExpression expr = EmptyExpression.Grab ();
 
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (t);
 				if (ImplicitStandardConversionExists (expr, best))
 					best = t;
 			}
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (t);
 				if (ImplicitStandardConversionExists (expr, best))
 					best = t;
 			}
 
 			expr.SetType (best);
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				if (!ImplicitStandardConversionExists (expr, t)) {
 					best = null;
 					break;
 				}
 			}
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				if (!ImplicitStandardConversionExists (expr, t)) {
 					best = null;
 					break;
 				}
 			}
 
 			EmptyExpression.Release (expr);
 
 			return best;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="824" endline="865">
<![CDATA[
 
 		/// <summary>
 		///  Finds "most encompassing type" according to the spec (13.4.2)
 		///  amongst the types in the given set
 		/// </summary>
 		static TypeSpec FindMostEncompassingType (IList<TypeSpec> types)
 		{
 			TypeSpec best = null;
 
 			if (types.Count == 0)
 				return null;
 
 			if (types.Count == 1)
 				return types [0];
 
 			EmptyExpression expr = EmptyExpression.Grab ();
 
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (best);
 				if (ImplicitStandardConversionExists (expr, t))
 					best = t;
 			}
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (best);
 				if (ImplicitStandardConversionExists (expr, t))
 					best = t;
 			}
 
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				expr.SetType (t);
 				if (!ImplicitStandardConversionExists (expr, best)) {
 					best = null;
 					break;
 				}
 			}
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				expr.SetType (t);
 				if (!ImplicitStandardConversionExists (expr, best)) {
 					best = null;
 					break;
 				}
 			}
 
 			EmptyExpression.Release (expr);
 
 			return best;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="180" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3827" endline="3885">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			//
 			// Needed to emit anonymous storey initialization
 			// Otherwise it does not contain any statements for now
 			//
 			block.Emit (ec);
 
 			default_target = ec.DefineLabel ();
 			null_target = ec.DefineLabel ();
 
 			// Store variable for comparission purposes
 			// TODO
 			LocalTemporary value;
 			if (HaveUnwrap) {
 				value = new LocalTemporary (SwitchType);
 				unwrap.EmitCheck (ec);
 				ec.Emit (OpCodes.Brfalse, null_target);
 				new_expr.Emit (ec);
 				value.Store (ec);
 			} else if (!is_constant) {
 				value = new LocalTemporary (SwitchType);
 				new_expr.Emit (ec);
 				value.Store (ec);
 			} else
 				value = null;
 
 			//
 			// Setup the codegen context
 			//
 			Label old_end = ec.LoopEnd;
 			Switch old_switch = ec.Switch;
 			
 			ec.LoopEnd = ec.DefineLabel ();
 			ec.Switch = this;
 
 			// Emit Code.
 			if (is_constant) {
 				if (constant_section != null)
 					constant_section.Block.Emit (ec);
 			} else if (string_dictionary != null) {
 				DoEmitStringSwitch (value, ec);
 			} else {
 				TableSwitchEmit (ec, value);
 			}
 
 			if (value != null)
 				value.Release (ec);
 
 			// Restore context state. 
 			ec.MarkLabel (ec.LoopEnd);
 
 			//
 			// Restore the previous context
 			//
 			ec.LoopEnd = old_end;
 			ec.Switch = old_switch;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1275" endline="1332">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 
 			// FIXME
 			var caller_builder = (Constructor) ec.MemberContext;
 
 			//
 			// Spec mandates that constructor initializer will not have `this' access
 			//
 			using (ec.Set (ResolveContext.Options.BaseInitializer)) {
 				if (argument_list != null) {
 					bool dynamic;
 					argument_list.Resolve (ec, out dynamic);
 
 					if (dynamic) {
 						ec.Report.Error (1975, loc,
 							"The constructor call cannot be dynamically dispatched within constructor initializer");
 
 						return null;
 					}
 				}
 
 				type = ec.CurrentType;
 				if (this is ConstructorBaseInitializer) {
 					if (ec.CurrentType.BaseType == null)
 						return this;
 
 					type = ec.CurrentType.BaseType;
 					if (ec.CurrentType.IsStruct) {
 						ec.Report.Error (522, loc,
 							"`{0}'
 						return this;
 					}
 				} else {
 					//
 					// It is legal to have "this" initializers that take no arguments
 					// in structs, they are just no-ops.
 					//
 					// struct D { public D (int a) 
 					//
 					if (TypeManager.IsStruct (ec.CurrentType) && argument_list == null)
 						return this;
 				}
 
 				base_ctor = ConstructorLookup (ec, type, ref argument_list, loc);
 			}
 	
 			// TODO MemberCache
 			if (base_ctor == caller_builder.Spec){
 				ec.Report.Error (516, loc, "Constructor `{0}' cannot call itself",
 					caller_builder.GetSignatureForError ());
 			}
 						
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="181" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="532" endline="561">
<![CDATA[
 
 		public FieldInfo[] GetFields(BindingFlags bindingAttr)
 		{
 			List<FieldInfo> list = new List<FieldInfo>();
 			CheckBaked();
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(field);
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(field);
 				}
 			}
 			if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 			{
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 				}
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="585" endline="620">
<![CDATA[
 
 		public MethodInfo[] GetMethods(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<MethodInfo> list = new List<MethodInfo>();
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				MethodInfo mi = mb as MethodInfo;
 				if (mi != null
 					&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(mi);
 				}
 			}
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				MethodInfo mi = mb as MethodInfo;
 				if (mi != null
 					&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(mi);
 				}
 			}
 			if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 			{
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 				}
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="182" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="477" endline="533">
<![CDATA[
 
 		static public DSA FromCapiPublicKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			try {
 				if ((blob [offset] != 0x06) ||				// PUBLICKEYBLOB (0x06)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x31535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				DSAParameters dsap = new DSAParameters ();
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.Y = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.Y, 0, bytelen);
 				Array.Reverse (dsap.Y);
 				pos += bytelen;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 
 				DSA dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 				return dsa;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="201" endline="280">
<![CDATA[
 
 		static public DSA FromCapiPrivateKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			DSAParameters dsap = new DSAParameters ();
 			try {
 				if ((blob [offset] != 0x07) ||				// PRIVATEKEYBLOB (0x07)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x32535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.X = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.X, 0, 20);
 				Array.Reverse (dsap.X);
 				pos += 20;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 
 #if NET_2_1
 			DSA dsa = (DSA)DSA.Create ();
 			dsa.ImportParameters (dsap);
 #else
 			DSA dsa = null;
 			try {
 				dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 			}
 			catch (CryptographicException ce) {
 				// this may cause problem when this code is run under
 				// the SYSTEM identity on Windows (e.g. ASP.NET). See
 				// http
 				try {
 					CspParameters csp = new CspParameters ();
 					csp.Flags = CspProviderFlags.UseMachineKeyStore;
 					dsa = new DSACryptoServiceProvider (csp);
 					dsa.ImportParameters (dsap);
 				}
 				catch {
 					// rethrow original, not the later, exception if this fails
 					throw ce;
 				}
 			}
 #endif
 			return dsa;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="183" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="779" endline="809">
<![CDATA[
 
 		public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
 		{
 			List<PropertyInfo> list = new List<PropertyInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="479" endline="509">
<![CDATA[
 
 		public EventInfo[] GetEvents(BindingFlags bindingAttr)
 		{
 			List<EventInfo> list = new List<EventInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="184" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="209" endline="242">
<![CDATA[
 
 		//
 		// For cases where we need to union cache members
 		//
 		public void AddBaseType (TypeSpec baseType)
 		{
 			var cache = baseType.MemberCache;
 
 			IList<MemberSpec> list;
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 			}
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="243" endline="280">
<![CDATA[
 
 		//
 		// Member-cache does not contain base members but it does
 		// contain all base interface members, so the Lookup code
 		// can use simple inheritance rules.
 		//
 		public void AddInterface (TypeSpec iface)
 		{
 			var cache = iface.MemberCache;
 
 			IList<MemberSpec> list;
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 			}
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 			}
 
 			// Add also all base interfaces
 			if (iface.Interfaces != null) {
 				foreach (var base_iface in iface.Interfaces)
 					AddInterface (base_iface);
 				foreach (var base_iface in iface.Interfaces)
 					AddInterface (base_iface);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="185" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7220" endline="7292">
<![CDATA[
 	}
 
 	class TypeOfMethod 
 	{
 		public TypeOfMethod (MethodSpec method, Location loc)
 			
 		{
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (member.IsConstructor) {
 				type = ec.Module.PredefinedTypes.ConstructorInfo.Resolve (loc);
 			} else {
 				type = ec.Module.PredefinedTypes.MethodInfo.Resolve (loc);
 			}
 
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
 
 		protected override string GetMethodName {
 			get { return "GetMethodFromHandle"; }
 		}
 
 		protected override PredefinedType GetDeclaringType (PredefinedTypes types)
 		{
 			return types.MethodBase;
 		}
 
 		protected override PredefinedType GetRuntimeHandle (PredefinedTypes types)
 		{
 			return types.RuntimeMethodHandle;
 		}
 
 		protected override MethodSpec TypeFromHandle {
 			get {
 				return TypeManager.methodbase_get_type_from_handle;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle = value;
 			}
 		}
 
 		protected override MethodSpec TypeFromHandleGeneric {
 			get {
 				return TypeManager.methodbase_get_type_from_handle_generic;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle_generic = value;
 			}
 		}
 	}
 
 	abstract class TypeOfMember<T> 
 	{
 		protected readonly T member;
 
 		protected TypeOfMember (T member, Location loc)
 		{
 			this.member = member;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1886" endline="1958">
<![CDATA[
 		}
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodInfo method;
 			private readonly Type type;
 			private readonly int pos;
 
 			internal ParameterInfoImpl(MethodInfo method, Type type, int pos)
 			{
 				this.method = method;
 				this.type = type;
 				this.pos = pos;
 			}
 
 			public override Type ParameterType
 			{
 				get { return type; }
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return pos; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { return null; }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method.IsConstructor ? (MethodBase)new ConstructorInfoImpl(method) 
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x8000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 	}
 
 	sealed class ByRefType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ByRefType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertyInfo.cs" startline="33" endline="116">
<![CDATA[
 		}
 
 		public abstract PropertyAttributes Attributes { get; }
 		public abstract bool CanRead { get; }
 		public abstract bool CanWrite { get; }
 		public abstract MethodInfo GetGetMethod(bool nonPublic);
 		public abstract MethodInfo GetSetMethod(bool nonPublic);
 		public abstract MethodInfo[] GetAccessors(bool nonPublic);
 		public abstract object GetRawConstantValue();
 		internal abstract bool IsPublic { get; }
 		internal abstract bool IsStatic { get; }
 		internal abstract PropertySignature PropertySignature { get; }
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly PropertyInfo property;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(PropertyInfo property, int parameter)
 			{
 				this.property = property;
 				this.parameter = parameter;
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override Type ParameterType
 			{
 				get { return property.PropertySignature.GetParameter(parameter); }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return property.PropertySignature.GetOptionalCustomModifiers(parameter);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return property.PropertySignature.GetRequiredCustomModifiers(parameter);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return property; }
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x08000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return property.Module; }
 			}
 		}
 
 		public ParameterInfo[] GetIndexParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[this.PropertySignature.ParameterCount];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="186" nfragments="77" Csharpe_files="77" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="44" endline="1638">
<![CDATA[
 
 		private Driver (CompilerContext ctx)
 		{
 			this.ctx = ctx;
 		}
 
 		public static Driver Create (string[] args, bool require_files, Func<string [], int, int> unknown_option_parser, ReportPrinter printer)
 		{
 			Driver d = new Driver (new CompilerContext (new Report (printer)));
 
 			if (!d.ParseArguments (args, require_files, unknown_option_parser))
 				return null;
 
 			return d;
 		}
 
 		Report Report {
 			get { return ctx.Report; }
 		}
 
 		void ShowTime (string msg)
 		{
 			if (!timestamps)
 				return;
 
 			stopwatch.Stop ();
 
 			Console.WriteLine ("{0,5}ms {1}", stopwatch.ElapsedMilliseconds, msg);
 
 			stopwatch = Stopwatch.StartNew ();
 		}
 
 		void ShowTotalTime (string msg)
 		{
 			if (!timestamps)
 				return;
 
 			DateTime now = DateTime.Now;
 			TimeSpan span = now - first_time;
 
 			Console.WriteLine (
 				"[{0
 				(int) span.TotalSeconds, span.Milliseconds, msg);
 		}	       
 	       
 		void tokenize_file (CompilationUnit file, CompilerContext ctx)
 		{
 			Stream input;
 
 			try {
 				input = File.OpenRead (file.Name);
 			} catch {
 				Report.Error (2001, "Source file `" + file.Name + "' could not be found");
 				return;
 			}
 
 			using (input){
 				SeekableStreamReader reader = new SeekableStreamReader (input, RootContext.Encoding);
 				Tokenizer lexer = new Tokenizer (reader, file, ctx);
 				int token, tokens = 0, errors = 0;
 
 				while ((token = lexer.token ()) != Token.EOF){
 					tokens++;
 					if (token == Token.ERROR)
 						errors++;
 				}
 				Console.WriteLine ("Tokenized
 			}
 			
 			return;
 		}
 
 		void Parse (CompilationUnit file, ModuleContainer module)
 		{
 			Stream input;
 
 			try {
 				input = File.OpenRead (file.Name);
 			} catch {
 				Report.Error (2001, "Source file `{0}' could not be found", file.Name);
 				return;
 			}
 
 			// Check 'MZ' header
 			if (input.ReadByte () == 77 && input.ReadByte () == 90) {
 				Report.Error (2015, "Source file `{0}' is a binary file and not a text file", file.Name);
 				input.Close ();
 				return;
 			}
 
 			input.Position = 0;
 			SeekableStreamReader reader = new SeekableStreamReader (input, RootContext.Encoding);
 
 			Parse (reader, file, module);
 			reader.Dispose ();
 			input.Close ();
 		}	
 		
 		void Parse (SeekableStreamReader reader, CompilationUnit file, ModuleContainer module)
 		{
 			CSharpParser parser = new CSharpParser (reader, file, module);
 			parser.parse ();
 		}
 
 		static void OtherFlags ()
 		{
 			Console.WriteLine (
 				"Other flags in the compiler\n" +
 				"   --fatal[=COUNT]    Makes errors after COUNT fatal\n" +
 				"   --lint             Enhanced warnings\n" +
 				"   --parse            Only parses the source file\n" +
 				"   --runtime
 				"   --stacktrace       Shows stack trace at error location\n" +
 				"   --timestamp        Displays time stamps of various compiler events\n" +
 				"   -v                 Verbose parsing (for debugging the parser)\n" + 
 				"   --mcs-debug X      Sets MCS debugging level to X\n");
 		}
 		
 		static void Usage ()
 		{
 			Console.WriteLine (
 				"Mono C# compiler, Copyright 2001 - 2011 Novell, Inc.\n" +
 				"mcs [options] source-files\n" +
 				"   --about              About the Mono C# compiler\n" +
 				"   -addmodule
 				"   -checked[+|-]        Sets default aritmetic overflow context\n" +
 				"   -clscheck[+|-]       Disables CLS Compliance verifications\n" +
 				"   -codepage
 				"   -define
 				"   -debug[+|-], -g      Generate debugging information\n" + 
 				"   -delaysign[+|-]      Only insert the public key into the assembly (no signing)\n" +
 				"   -doc
 				"   -help                Lists all compiler options (short
 				"   -keycontainer
 				"   -keyfile
 				"   -langversion
 				"   -lib
 				"   -main
 				"   -noconfig            Disables implicitly referenced assemblies\n" +
 				"   -nostdlib[+|-]       Does not reference mscorlib.dll library\n" +
 				"   -nowarn
 				"   -optimize[+|-]       Enables advanced compiler optimizations (short
 				"   -out
 #if !SMCS_SOURCE
 				"   -pkg
 #endif
 				"   -platform
 				"                        ARCH can be one of
 				"   -recurse
 				"   -reference
 				"   -reference
 				"   -sdk
 				"                        VERSION can be one of
 				"   -target
 				"                        KIND can be one of
 				"   -unsafe[+|-]         Allows to compile code which uses unsafe keyword\n" +
 				"   -warnaserror[+|-]    Treats all warnings as errors\n" +
 				"   -warnaserror[+|-]
 				"   -warn
 				"   -helpinternal        Shows internal and advanced compiler options\n" + 
 				"\n" +
 				"Resources
 				"   -linkresource
 				"   -resource
 				"   -win32res
 				"   -win32icon
                                 "   @file                   Read response file for more options\n\n" +
 				"Options can be of the form -option or /option");
 		}
 
 		void TargetUsage ()
 		{
 			Report.Error (2019, "Invalid target type for -target. Valid options are `exe', `winexe', `library' or `module'");
 		}
 		
 		static void About ()
 		{
 			Console.WriteLine (
 				"The Mono C# compiler is Copyright 2001-2011, Novell, Inc.\n\n" +
 				"The compiler source code is released under the terms of the \n"+
 				"MIT X11 or GNU GPL licenses\n\n" +
 
 				"For more information on Mono, visit the project Web site\n" +
 				"   http
 
 				"The compiler was written by Miguel de Icaza, Ravi Pratap, Martin Baulig, Marek Safar, Raja R Harinath, Atushi Enomoto");
 			Environment.Exit (0);
 		}
 
 		public static int Main (string[] args)
 		{
 			Location.InEmacs = Environment.GetEnvironmentVariable ("EMACS") == "t";
 			var crp = new ConsoleReportPrinter ();
 			Driver d = Driver.Create (args, true, null, crp);
 			if (d == null)
 				return 1;
 
 			crp.Fatal = d.fatal_errors;
 
 			if (d.Compile () && d.Report.Errors == 0) {
 				if (d.Report.Warnings > 0) {
 					Console.WriteLine ("Compilation succeeded - {0} warning(s)", d.Report.Warnings);
 				}
 				Environment.Exit (0);
 				return 0;
 			}
 			
 			
 			Console.WriteLine("Compilation failed
 				d.Report.Errors, d.Report.Warnings);
 			Environment.Exit (1);
 			return 1;
 		}
 
 		static string [] LoadArgs (string file)
 		{
 			StreamReader f;
 			var args = new List<string> ();
 			string line;
 			try {
 				f = new StreamReader (file);
 			} catch {
 				return null;
 			}
 
 			StringBuilder sb = new StringBuilder ();
 			
 			while ((line = f.ReadLine ()) != null){
 				int t = line.Length;
 
 				for (int i = 0; i < t; i++){
 					char c = line [i];
 					
 					if (c == '"' || c == '\''){
 						char end = c;
 						
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 					} else if (c == ' '){
 						if (sb.Length > 0){
 							args.Add (sb.ToString ());
 							sb.Length = 0;
 						}
 					} else
 						sb.Append (c);
 				}
 				if (sb.Length > 0){
 					args.Add (sb.ToString ());
 					sb.Length = 0;
 				}
 			}
 
 			return args.ToArray ();
 		}
 
 		//
 		// Given a path specification, splits the path from the file/pattern
 		//
 		static void SplitPathAndPattern (string spec, out string path, out string pattern)
 		{
 			int p = spec.LastIndexOf ('/');
 			if (p != -1){
 				//
 				// Windows does not like /file.cs, switch that to
 				// "\", "file.cs"
 				//
 				if (p == 0){
 					path = "\\";
 					pattern = spec.Substring (1);
 				} else {
 					path = spec.Substring (0, p);
 					pattern = spec.Substring (p + 1);
 				}
 				return;
 			}
 
 			p = spec.LastIndexOf ('\\');
 			if (p != -1){
 				path = spec.Substring (0, p);
 				pattern = spec.Substring (p + 1);
 				return;
 			}
 
 			path = ".";
 			pattern = spec;
 		}
 
 		void AddSourceFile (string f)
 		{
 			if (first_source == null)
 				first_source = f;
 
 			Location.AddFile (Report, f);
 		}
 
 		bool ParseArguments (string[] args, bool require_files, Func<string [], int, int> unknown_option_parser)
 		{
 			List<string> response_file_list = null;
 			bool parsing_options = true;
 
 			for (int i = 0; i < args.Length; i++) {
 				string arg = args [i];
 				if (arg.Length == 0)
 					continue;
 
 				if (arg [0] == '@') {
 					string [] extra_args;
 					string response_file = arg.Substring (1);
 
 					if (response_file_list == null)
 						response_file_list = new List<string> ();
 
 					if (response_file_list.Contains (response_file)) {
 						Report.Error (
 							1515, "Response file `" + response_file +
 							"' specified multiple times");
 						return false;
 					}
 
 					response_file_list.Add (response_file);
 
 					extra_args = LoadArgs (response_file);
 					if (extra_args == null) {
 						Report.Error (2011, "Unable to open response file
 								  response_file);
 						return false;
 					}
 
 					args = AddArgs (args, extra_args);
 					continue;
 				}
 
 				if (parsing_options) {
 					if (arg == "--") {
 						parsing_options = false;
 						continue;
 					}
 
 					if (arg [0] == '-') {
 						if (UnixParseOption (arg, ref args, ref i))
 							continue;
 
 						// Try a -CSCOPTION
 						string csc_opt = "/" + arg.Substring (1);
 						if (CSCParseOption (csc_opt, ref args))
 							continue;
 
 						if (unknown_option_parser != null){
 							var ret = unknown_option_parser (args, i);
 							if (ret != -1){
 								i = ret;
 								return true;
 							}
 						}
 						
 						Error_WrongOption (arg);
 						return false;
 					}
 					if (arg [0] == '/') {
 						if (CSCParseOption (arg, ref args))
 							continue;
 
 						// Need to skip `/home/test.cs' however /test.cs is considered as error
 						if (arg.Length < 2 || arg.IndexOf ('/', 2) == -1) {
 							Error_WrongOption (arg);
 							return false;
 						}
 					}
 				}
 
 				ProcessSourceFiles (arg, false);
 			}
 
 			if (require_files == false)
 				return true;
 					
 			//
 			// If we are an exe, require a source file for the entry point
 			//
 			if (RootContext.Target == Target.Exe || RootContext.Target == Target.WinExe || RootContext.Target == Target.Module) {
 				if (first_source == null) {
 					Report.Error (2008, "No files to compile were specified");
 					return false;
 				}
 
 			}
 
 			//
 			// If there is nothing to put in the assembly, and we are not a library
 			//
 			if (first_source == null && RootContext.Resources == null) {
 				Report.Error (2008, "No files to compile were specified");
 				return false;
 			}
 
 			return true;
 		}
 
 		public void Parse (ModuleContainer module)
 		{
 			Location.Initialize ();
 
 			var cu = Location.SourceFiles;
 			for (int i = 0; i < cu.Count; ++i) {
 				if (RootContext.TokenizeOnly) {
 					tokenize_file (cu [i], ctx);
 				} else {
 					Parse (cu [i], module);
 				}
 			}
 		}
 
 		void ProcessSourceFiles (string spec, bool recurse)
 		{
 			string path, pattern;
 
 			SplitPathAndPattern (spec, out path, out pattern);
 			if (pattern.IndexOf ('*') == -1){
 				AddSourceFile (spec);
 				return;
 			}
 
 			string [] files = null;
 			try {
 				files = Directory.GetFiles (path, pattern);
 			} catch (System.IO.DirectoryNotFoundException) {
 				Report.Error (2001, "Source file `" + spec + "' could not be found");
 				return;
 			} catch (System.IO.IOException){
 				Report.Error (2001, "Source file `" + spec + "' could not be found");
 				return;
 			}
 			foreach (string f in files) {
 				AddSourceFile (f);
 			}
 
 			if (!recurse)
 				return;
 			
 			string [] dirs = null;
 
 			try {
 				dirs = Directory.GetDirectories (path);
 			} catch {
 			}
 			
 			foreach (string d in dirs) {
 					
 				// Don't include path in this string, as each
 				// directory entry already does
 				ProcessSourceFiles (d + "/" + pattern, true);
 			}
 		}
 
 		void SetWarningLevel (string s)
 		{
 			int level = -1;
 
 			try {
 				level = Int32.Parse (s);
 			} catch {
 			}
 			if (level < 0 || level > 4){
 				Report.Error (1900, "Warning level must be in the range 0-4");
 				return;
 			}
 			Report.WarningLevel = level;
 		}
 
 		static void Version ()
 		{
 			string version = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString ();
 			Console.WriteLine ("Mono C# compiler version {0}", version);
 			Environment.Exit (0);
 		}
 		
 		//
 		// Currently handles the Unix-like command line options, but will be
 		// deprecated in favor of the CSCParseOption, which will also handle the
 		// options that start with a dash in the future.
 		//
 		bool UnixParseOption (string arg, ref string [] args, ref int i)
 		{
 			switch (arg){
 			case "-v"
 				CSharpParser.yacc_verbose_flag++;
 				return true;
 
 			case "--version"
 				Version ();
 				return true;
 				
 			case "--parse"
 				RootContext.ParseOnly = true;
 				return true;
 				
 			case "--main"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.MainClass = args [++i];
 				return true;
 				
 			case "--unsafe"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Unsafe = true;
 				return true;
 				
 			case "/?"
 			case "--help"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "--define"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.AddConditional (args [++i]);
 				return true;
 
 			case "--tokenize"
 				RootContext.TokenizeOnly = true;
 				return true;
 				
 			case "-o"
 			case "--output"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.OutputFile = args [++i];
 				return true;
 
 			case "--checked"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Checked = true;
 				return true;
 				
 			case "--stacktrace"
 				Report.Printer.Stacktrace = true;
 				return true;
 				
 			case "--linkresource"
 			case "--linkres"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --linkres"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i]));
 				return true;
 				
 			case "--resource"
 			case "--res"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --resource"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i], true));
 				return true;
 				
 			case "--target"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Environment.Exit (1);
 					return true;
 				}
 				
 				string type = args [++i];
 				switch (type){
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 					
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 					
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 					
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".dll";
 					break;
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 				
 			case "-r"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				
 				string val = args [++i];
 				int idx = val.IndexOf ('=');
 				if (idx > -1) {
 					string alias = val.Substring (0, idx);
 					string assembly = val.Substring (idx + 1);
 					AddAssemblyReference (alias, assembly);
 					return true;
 				}
 
 				AddAssemblyReference (val);
 				return true;
 				
 			case "-L"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();	
 					Environment.Exit (1);
 				}
 				RootContext.ReferencesLookupPaths.Add (args [++i]);
 				return true;
 
 			case "--lint"
 				RootContext.EnhancedWarnings = true;
 				return true;
 				
 			case "--nostdlib"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.StdLib = false;
 				return true;
 				
 			case "--nowarn"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				int warn = 0;
 				
 				try {
 					warn = Int32.Parse (args [++i]);
 				} catch {
 					Usage ();
 					Environment.Exit (1);
 				}
 				Report.SetIgnoreWarning (warn);
 				return true;
 
 			case "--wlevel"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (
 						1900,
 						"--wlevel requires a value from 0 to 4");
 					Environment.Exit (1);
 				}
 
 				SetWarningLevel (args [++i]);
 				return true;
 
 			case "--mcs-debug"
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--mcs-debug requires an argument");
 					Environment.Exit (1);
 				}
 
 				try {
 					Report.DebugFlags = Int32.Parse (args [++i]);
 				} catch {
 					Report.Error (5, "Invalid argument to --mcs-debug");
 					Environment.Exit (1);
 				}
 				return true;
 				
 			case "--about"
 				About ();
 				return true;
 				
 			case "--recurse"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--recurse requires an argument");
 					Environment.Exit (1);
 				}
 				ProcessSourceFiles (args [++i], true); 
 				return true;
 				
 			case "--timestamp"
 				timestamps = true;
 				return true;
 
 			case "--debug"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.GenerateDebugInfo = true;
 				return true;
 				
 			case "--noconfig"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			default
 				if (arg.StartsWith ("--fatal")){
 					if (arg.StartsWith ("--fatal=")){
 						if (!Int32.TryParse (arg.Substring (8), out fatal_errors))
 							fatal_errors = 1;
 					} else
 						fatal_errors = 1;
 					return true;
 				}
 				if (arg.StartsWith ("--runtime
 					string version = arg.Substring (10);
 
 					switch (version) {
 					case "v1"
 					case "V1"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v1;
 						break;
 					case "v2"
 					case "V2"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v2;
 						return true;
 					case "v4"
 					case "V4"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v4;
 						return true;
 					}
 					return true;
 				}
 
 				break;
 			}
 
 			return false;
 		}
 
 #if !SMCS_SOURCE
 		public static string GetPackageFlags (string packages, bool fatal, Report report)
 		{
 			ProcessStartInfo pi = new ProcessStartInfo ();
 			pi.FileName = "pkg-config";
 			pi.RedirectStandardOutput = true;
 			pi.UseShellExecute = false;
 			pi.Arguments = "--libs " + packages;
 			Process p = null;
 			try {
 				p = Process.Start (pi);
 			} catch (Exception e) {
 				report.Error (-27, "Couldn't run pkg-config
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			
 			if (p.StandardOutput == null){
 				report.Warning (-27, 1, "Specified package did not return any information");
 				p.Close ();
 				return null;
 			}
 			string pkgout = p.StandardOutput.ReadToEnd ();
 			p.WaitForExit ();
 			if (p.ExitCode != 0) {
 				report.Error (-27, "Error running pkg-config. Check the above output.");
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			p.Close ();
 
 			return pkgout;
 		}
 #endif
 
 		//
 		// This parses the -arg and /arg options to the compiler, even if the strings
 		// in the following text use "/arg" on the strings.
 		//
 		bool CSCParseOption (string option, ref string [] args)
 		{
 			int idx = option.IndexOf ('
 			string arg, value;
 
 			if (idx == -1){
 				arg = option;
 				value = "";
 			} else {
 				arg = option.Substring (0, idx);
 
 				value = option.Substring (idx + 1);
 			}
 
 			switch (arg.ToLowerInvariant ()){
 			case "/nologo"
 				return true;
 
 			case "/t"
 			case "/target"
 				switch (value){
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".netmodule";
 					break;
 
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 
 			case "/out"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				RootContext.OutputFile = value;
 				return true;
 
 			case "/o"
 			case "/o+"
 			case "/optimize"
 			case "/optimize+"
 				RootContext.Optimize = true;
 				return true;
 
 			case "/o-"
 			case "/optimize-"
 				RootContext.Optimize = false;
 				return true;
 
 			// TODO
 			case "/incremental"
 			case "/incremental+"
 			case "/incremental-"
 				// nothing.
 				return true;
 
 			case "/d"
 			case "/define"
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 
 				foreach (string d in value.Split (argument_value_separator)) {
 					string conditional = d.Trim ();
 					if (!Tokenizer.IsValidIdentifier (conditional)) {
 						Report.Warning (2029, 1, "Invalid conditional define symbol `{0}'", conditional);
 						continue;
 					}
 					RootContext.AddConditional (conditional);
 				}
 				return true;
 			}
 
 			case "/bugreport"
 				//
 				// We should collect data, runtime, etc and store in the file specified
 				//
 				Console.WriteLine ("To file bug reports, please visit
 				return true;
 #if !SMCS_SOURCE
 			case "/pkg"
 				string packages;
 
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 				packages = String.Join (" ", value.Split (new Char [] { ';', ',', '\n', '\r'}));
 				string pkgout = GetPackageFlags (packages, true, Report);
 				
 				if (pkgout != null){
 					string [] xargs = pkgout.Trim (new Char [] {' ', '\n', '\r', '\t'}).
 						Split (new Char [] { ' ', '\t'});
 					args = AddArgs (args, xargs);
 				}
 				
 				return true;
 			}
 #endif
 			case "/linkres"
 			case "/linkresource"
 			case "/res"
 			case "/resource"
 				AssemblyResource res = null;			
 				string[] s = value.Split (argument_value_separator, StringSplitOptions.RemoveEmptyEntries);
 				switch (s.Length) {
 				case 1
 					if (s[0].Length == 0)
 						goto default;
 					res = new AssemblyResource (s [0], Path.GetFileName (s[0]));
 					break;
 				case 2
 					res = new AssemblyResource (s [0], s [1]);
 					break;
 				case 3
 					if (s [2] != "public" && s [2] != "private") {
 						Report.Error (1906, "Invalid resource visibility option `{0}'. Use either `public' or `private' instead", s [2]);
 						return true;
 					}
 					res = new AssemblyResource (s[0], s[1], s[2] == "private");
 					break;
 				default
 					Report.Error (-2005, "Wrong number of arguments for option `{0}'", option);
 					break;
 				}
 
 				if (res != null) {
 					res.IsEmbeded = arg [1] == 'r' || arg [1] == 'R';
 					AddResource (res);
 				}
 
 				return true;
 				
 			case "/recurse"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				ProcessSourceFiles (value, true); 
 				return true;
 
 			case "/r"
 			case "/reference"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					if (r.Length == 0)
 						continue;
 
 					string val = r;
 					int index = val.IndexOf ('=');
 					if (index > -1) {
 						string alias = r.Substring (0, index);
 						string assembly = r.Substring (index + 1);
 						AddAssemblyReference (alias, assembly);
 						if (refs.Length != 1) {
 							Report.Error (2034, "Cannot specify multiple aliases using single /reference option");
 							break;
 						}
 					} else {
 						AddAssemblyReference (val);
 					}
 				}
 				return true;
 			}
 			case "/addmodule"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					RootContext.Modules.Add (r);
 				}
 				return true;
 			}
 			case "/win32res"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				
 				if (RootContext.Win32IconFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32ResourceFile = value;
 				return true;
 			}
 			case "/win32icon"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				if (RootContext.Win32ResourceFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32IconFile = value;
 				return true;
 			}
 			case "/doc"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.Documentation = new Documentation (value);
 				return true;
 			}
 			case "/lib"
 				string [] libdirs;
 				
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				libdirs = value.Split (argument_value_separator);
 				foreach (string dir in libdirs)
 					RootContext.ReferencesLookupPaths.Add (dir);
 				return true;
 			}
 
 			case "/debug-"
 				RootContext.GenerateDebugInfo = false;
 				return true;
 				
 			case "/debug"
 				if (value == "full" || value == "")
 					RootContext.GenerateDebugInfo = true;
 
 				return true;
 				
 			case "/debug+"
 				RootContext.GenerateDebugInfo = true;
 				return true;
 
 			case "/checked"
 			case "/checked+"
 				RootContext.Checked = true;
 				return true;
 
 			case "/checked-"
 				RootContext.Checked = false;
 				return true;
 
 			case "/clscheck"
 			case "/clscheck+"
 				RootContext.VerifyClsCompliance = true;
 				return true;
 
 			case "/clscheck-"
 				RootContext.VerifyClsCompliance = false;
 				return true;
 
 			case "/unsafe"
 			case "/unsafe+"
 				RootContext.Unsafe = true;
 				return true;
 
 			case "/unsafe-"
 				RootContext.Unsafe = false;
 				return true;
 
 			case "/warnaserror"
 			case "/warnaserror+"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = true;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.AddWarningAsError (wid);
 				}
 				return true;
 
 			case "/warnaserror-"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = false;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.RemoveWarningAsError (wid);
 				}
 				return true;
 
 			case "/warn"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				SetWarningLevel (value);
 				return true;
 
 			case "/nowarn"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				var warns = value.Split (argument_value_separator);
 				foreach (string wc in warns){
 					try {
 						if (wc.Trim ().Length == 0)
 							continue;
 
 						int warn = Int32.Parse (wc);
 						if (warn < 1) {
 							throw new ArgumentOutOfRangeException("warn");
 						}
 						Report.SetIgnoreWarning (warn);
 					} catch {
 						Report.Error (1904, "`{0}' is not a valid warning number", wc);
 					}
 				}
 				return true;
 			}
 
 			case "/noconfig"
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			case "/platform"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLower (CultureInfo.InvariantCulture)) {
 				case "anycpu"
 					RootContext.Platform = Platform.AnyCPU;
 					break;
 				case "x86"
 					RootContext.Platform = Platform.X86;
 					break;
 				case "x64"
 					RootContext.Platform = Platform.X64;
 					break;
 				case "itanium"
 					RootContext.Platform = Platform.IA64;
 					break;
 				default
 					Report.Error (1672, "Invalid platform type for -platform. Valid options are `anycpu', `x86', `x64' or `itanium'");
 					break;
 				}
 
 				return true;
 
 			case "/sdk"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 					case "2"
 						RootContext.SdkVersion = SdkVersion.v2;
 						break;
 					case "4"
 						RootContext.SdkVersion = SdkVersion.v4;
 						break;
 					default
 						Report.Error (-26, "Invalid sdk version name");
 						break;
 				}
 
 				return true;
 
 				// We just ignore this.
 			case "/errorreport"
 			case "/filealign"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				return true;
 				
 			case "/helpinternal"
 				OtherFlags ();
 				Environment.Exit(0);
 				return true;
 				
 			case "/help"
 			case "/?"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "/main"
 			case "/m"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 				RootContext.MainClass = value;
 				return true;
 
 			case "/nostdlib"
 			case "/nostdlib+"
 				RootContext.StdLib = false;
 				return true;
 
 			case "/nostdlib-"
 				RootContext.StdLib = true;
 				return true;
 
 			case "/fullpaths"
 				return true;
 
 			case "/keyfile"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyFile = value;
 				return true;
 
 			case "/keycontainer"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyContainer = value;
 				return true;
 			case "/delaysign+"
 			case "/delaysign"
 				RootContext.StrongNameDelaySign = true;
 				return true;
 			case "/delaysign-"
 				RootContext.StrongNameDelaySign = false;
 				return true;
 
 			case "/langversion"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 				case "iso-1"
 					RootContext.Version = LanguageVersion.ISO_1;
 					return true;	
 				case "default"
 					RootContext.Version = LanguageVersion.Default;
 					RootContext.AddConditional ("__V2__");
 					return true;
 				case "iso-2"
 					RootContext.Version = LanguageVersion.ISO_2;
 					return true;
 				case "3"
 					RootContext.Version = LanguageVersion.V_3;
 					return true;
 				case "future"
 					RootContext.Version = LanguageVersion.Future;
 					return true;
 				}
 
 				Report.Error (1617, "Invalid -langversion option `{0}'. It must be `ISO-1', `ISO-2', `3' or `Default'", value);
 				return true;
 
 			case "/codepage"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value) {
 				case "utf8"
 					RootContext.Encoding = new UTF8Encoding();
 					break;
 				case "reset"
 					RootContext.Encoding = Encoding.Default;
 					break;
 				default
 					try {
 						RootContext.Encoding = Encoding.GetEncoding (Int32.Parse (value));
 					} catch {
 						Report.Error (2016, "Code page `{0}' is invalid or not installed", value);
 					}
 					break;
 				}
 				return true;
 
 			default
 				return false;
 			}
 
 			return true;
 		}
 
 		void Error_WrongOption (string option)
 		{
 			Report.Error (2007, "Unrecognized command-line option
 		}
 
 		void Error_RequiresFileName (string option)
 		{
 			Report.Error (2005, "Missing file specification for `{0}' option", option);
 		}
 
 		void Error_RequiresArgument (string option)
 		{
 			Report.Error (2006, "Missing argument for `{0}' option", option);
 		}
 
 		static string [] AddArgs (string [] args, string [] extra_args)
 		{
 			string [] new_args;
 			new_args = new string [extra_args.Length + args.Length];
 
 			// if args contains '--' we have to take that into account
 			// split args into first half and second half based on '--'
 			// and add the extra_args before --
 			int split_position = Array.IndexOf (args, "--");
 			if (split_position != -1)
 			{
 				Array.Copy (args, new_args, split_position);
 				extra_args.CopyTo (new_args, split_position);
 				Array.Copy (args, split_position, new_args, split_position + extra_args.Length, args.Length - split_position);
 			}
 			else
 			{
 				args.CopyTo (new_args, 0);
 				extra_args.CopyTo (new_args, args.Length);
 			}
 
 			return new_args;
 		}
 
 		void AddAssemblyReference (string assembly)
 		{
 			RootContext.AssemblyReferences.Add (assembly);
 		}
 
 		void AddAssemblyReference (string alias, string assembly)
 		{
 			if (assembly.Length == 0) {
 				Report.Error (1680, "Invalid reference alias `{0}='. Missing filename", alias);
 				return;
 			}
 
 			if (!IsExternAliasValid (alias)) {
 				Report.Error (1679, "Invalid extern alias for -reference. Alias `{0}' is not a valid identifier", alias);
 				return;
 			}
 
 			RootContext.AssemblyReferencesAliases.Add (Tuple.Create (alias, assembly));
 		}
 
 		void AddResource (AssemblyResource res)
 		{
 			if (RootContext.Resources == null) {
 				RootContext.Resources = new List<AssemblyResource> ();
 				RootContext.Resources.Add (res);
 				return;
 			}
 
 			if (RootContext.Resources.Contains (res)) {
 				ctx.Report.Error (1508, "The resource identifier `{0}' has already been used in this assembly", res.Name);
 				return;
 			}
 
 			RootContext.Resources.Add (res);
 		}
 		
 		static bool IsExternAliasValid (string identifier)
 		{
 			if (identifier.Length == 0)
 				return false;
 			if (identifier [0] != '_' && !Char.IsLetter (identifier [0]))
 				return false;
 
 			for (int i = 1; i < identifier.Length; i++) {
 				char c = identifier [i];
 				if (Char.IsLetter (c) || Char.IsDigit (c))
 					continue;
 
 				UnicodeCategory category = Char.GetUnicodeCategory (c);
 				if (category != UnicodeCategory.Format || category != UnicodeCategory.NonSpacingMark ||
 						category != UnicodeCategory.SpacingCombiningMark ||
 						category != UnicodeCategory.ConnectorPunctuation)
 					return false;
 			}
 			
 			return true;
 		}
 
 		//
 		// Main compilation method
 		//
 		public bool Compile ()
 		{
 			var module = new ModuleContainer (ctx);
 			RootContext.ToplevelTypes = module;
 
 			if (timestamps) {
 				stopwatch = Stopwatch.StartNew ();
 				first_time = DateTime.Now;
 			}
 
 			Parse (module);
 			ShowTime ("Parsing source files");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (RootContext.TokenizeOnly || RootContext.ParseOnly)
 				return true;
 
 			if (RootContext.ToplevelTypes.NamespaceEntry != null)
 				throw new InternalErrorException ("who set it?");
 
 			//
 			// Quick hack
 			//
 			var output_file = RootContext.OutputFile;
 			string output_file_name;
 			if (output_file == null) {
 				if (first_source == null) {
 					Report.Error (1562, "If no source files are specified you must specify the output file with -out
 					return false;
 				}
 
 				int pos = first_source.LastIndexOf ('.');
 
 				if (pos > 0)
 					output_file = first_source.Substring (0, pos) + RootContext.TargetExt;
 				else
 					output_file = first_source + RootContext.TargetExt;
 
 				output_file_name = output_file;
 			} else {
 				output_file_name = Path.GetFileName (output_file);
 			}
 
 			//
 			// Load assemblies required
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 #if STATIC
 			var assembly = new AssemblyDefinitionStatic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new StaticImporter ();
 			assembly.Importer = importer;
 
 			var loader = new StaticLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (loader))
 				return false;
 
 			// System.Object was not loaded, use compiled assembly as corlib
 			if (loader.Corlib == null)
 				loader.Corlib = assembly.Builder;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #else
 			var assembly = new AssemblyDefinitionDynamic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new ReflectionImporter (ctx.BuildinTypes);
 			assembly.Importer = importer;
 
 			var loader = new DynamicLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Save))
 				return false;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #endif
 			module.Define ();
 
 			ShowTime ("Types definition");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (Report.Errors == 0 &&
 				RootContext.Documentation != null &&
 				!RootContext.Documentation.OutputDocComment (
 					output_file, Report))
 				return false;
 
 			//
 			// Verify using aliases now
 			//
 			NamespaceEntry.VerifyAllUsing ();
 			
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			assembly.Resolve ();
 			
 			if (Report.Errors > 0)
 				return false;
 			
 			//
 			// The code generator
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.Emit ();
 
 			ShowTime ("Resolving and emitting members blocks");
 
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			module.CloseType ();
 
 			ShowTime ("Closing types");
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.EmbedResources ();
 			ShowTime ("Embedding resources");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 			
 			assembly.Save ();
 
 #if STATIC
 			loader.Dispose ();
 #endif
 
 			ShowTime ("Saving output assembly");
 
 			ShowTotalTime ("Total");
 
 			Timer.ShowTimers ();
 
 			return (Report.Errors == 0);
 		}
 	}
 
 	//
 	// This is the only public entry point
 	//
 	public class CompilerCallableEntryPoint 
 		public static bool InvokeCompiler (string [] args, TextWriter error)
 		{
 			try {
 				StreamReportPrinter srp = new StreamReportPrinter (error);
 				Driver d = Driver.Create (args, true, null, srp);
 				if (d == null)
 					return false;
 
 				return d.Compile () && srp.ErrorsCount == 0;
 			} finally {
 				Reset ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="610" endline="709">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			MemberAccess ma = target as MemberAccess;
 			using (ec.Set (ResolveContext.Options.CompoundAssignmentScope)) {
 				target = target.Resolve (ec);
 			}
 			
 			if (target == null)
 				return null;
 
 			if (target is MethodGroupExpr){
 				ec.Report.Error (1656, loc,
 					"Cannot assign to `{0}' because it is a `{1}'",
 					((MethodGroupExpr)target).Name, target.ExprClassName);
 				return null;
 			}
 
 			var event_expr = target as EventExpr;
 			if (event_expr != null) {
 				source = Convert.ImplicitConversionRequired (ec, right, target.Type, loc);
 				if (source == null)
 					return null;
 
 				Expression rside;
 				if (op == Binary.Operator.Addition)
 					rside = EmptyExpression.EventAddition;
 				else if (op == Binary.Operator.Subtraction)
 					rside = EmptyExpression.EventSubtraction;
 				else
 					rside = null;
 
 				target = target.ResolveLValue (ec, rside);
 				if (target == null)
 					return null;
 
 				eclass = ExprClass.Value;
 				type = event_expr.Operator.ReturnType;
 				return this;
 			}
 
 			//
 			// Only now we can decouple the original source/target
 			// into a tree, to guarantee that we do not have side
 			// effects.
 			//
 			if (left == null)
 				left = new TargetExpression (target);
 
 			source = new Binary (op, left, right, true, loc);
 
 			if (target is DynamicMemberAssignable) {
 				Arguments targs = ((DynamicMemberAssignable) target).Arguments;
 				source = source.Resolve (ec);
 
 				Arguments args = new Arguments (targs.Count + 1);
 				args.AddRange (targs);
 				args.Add (new Argument (source));
 
 				var binder_flags = CSharpBinderFlags.ValueFromCompoundAssignment;
 
 				//
 				// Compound assignment does target conversion using additional method
 				// call, set checked context as the binary operation can overflow
 				//
 				if (ec.HasSet (ResolveContext.Options.CheckedScope))
 					binder_flags |= CSharpBinderFlags.CheckedContext;
 
 				if (target is DynamicMemberBinder) {
 					source = new DynamicMemberBinder (ma.Name, binder_flags, args, loc).Resolve (ec);
 
 					// Handles possible event addition/subtraction
 					if (op == Binary.Operator.Addition || op == Binary.Operator.Subtraction) {
 						args = new Arguments (targs.Count + 1);
 						args.AddRange (targs);
 						args.Add (new Argument (right));
 						string method_prefix = op == Binary.Operator.Addition ?
 							Event.AEventAccessor.AddPrefix 
 
 						var invoke = DynamicInvocation.CreateSpecialNameInvoke (
 							new MemberAccess (right, method_prefix + ma.Name, loc), args, loc).Resolve (ec);
 
 						args = new Arguments (targs.Count);
 						args.AddRange (targs);
 						source = new DynamicEventCompoundAssign (ma.Name, args,
 							(ExpressionStatement) source, (ExpressionStatement) invoke, loc).Resolve (ec);
 					}
 				} else {
 					source = new DynamicIndexBinder (binder_flags, args, loc).Resolve (ec);
 				}
 
 				return source;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1116" endline="1215">
<![CDATA[
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="976" endline="1049">
<![CDATA[
 
 		static void FindApplicableUserDefinedConversionOperators (IList<MemberSpec> operators, Expression source, TypeSpec target, bool implicitOnly, ref List<MethodSpec> candidates)
 		{
 			//
 			// LAMESPEC
 			// IntPtr -> uint uses int
 			// UIntPtr -> long uses ulong
 			//
 			if (source.Type == TypeManager.intptr_type) {
 				if (target == TypeManager.uint32_type)
 					target = TypeManager.int32_type;
 			} else if (source.Type == TypeManager.uintptr_type) {
 				if (target == TypeManager.int64_type)
 					target = TypeManager.uint64_type;
 			}
 
 			// Neither A nor B are interface-types
 			if (source.Type.IsInterface)
 				return;
 
 			// For a conversion operator to be applicable, it must be possible
 			// to perform a standard conversion from the source type to
 			// the operand type of the operator, and it must be possible
 			// to perform a standard conversion from the result type of
 			// the operator to the target type.
 
 			Expression texpr = null;
 
 			foreach (MethodSpec op in operators) {
 				
 				// Can be null because MemberCache.GetUserOperator does not resize the array
 				if (op == null)
 					continue;
 
 				var t = op.Parameters.Types[0];
 				if (source.Type != t && !ImplicitStandardConversionExists (source, t)) {
 					if (implicitOnly)
 						continue;
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), source.Type))
 						continue;
 				}
 
 				t = op.ReturnType;
 
 				// LAMESPEC
 				if (t == TypeManager.uint32_type && source.Type == TypeManager.uintptr_type)
 					continue;
 
 				if (t.IsInterface)
 					continue;
 
 				if (target != t) {
 					if (TypeManager.IsNullableType (t))
 						t = Nullable.NullableInfo.GetUnderlyingType (t);
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), target)) {
 						if (implicitOnly)
 							continue;
 
 						if (texpr == null)
 							texpr = new EmptyExpression (target);
 
 						if (!ImplicitStandardConversionExists (texpr, t))
 							continue;
 					}
 				}
 
 				if (candidates == null)
 					candidates = new List<MethodSpec> ();
 
 				candidates.Add (op);
 			}
 			foreach (MethodSpec op in operators) {
 				
 				// Can be null because MemberCache.GetUserOperator does not resize the array
 				if (op == null)
 					continue;
 
 				var t = op.Parameters.Types[0];
 				if (source.Type != t && !ImplicitStandardConversionExists (source, t)) {
 					if (implicitOnly)
 						continue;
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), source.Type))
 						continue;
 				}
 
 				t = op.ReturnType;
 
 				// LAMESPEC
 				if (t == TypeManager.uint32_type && source.Type == TypeManager.uintptr_type)
 					continue;
 
 				if (t.IsInterface)
 					continue;
 
 				if (target != t) {
 					if (TypeManager.IsNullableType (t))
 						t = Nullable.NullableInfo.GetUnderlyingType (t);
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), target)) {
 						if (implicitOnly)
 							continue;
 
 						if (texpr == null)
 							texpr = new EmptyExpression (target);
 
 						if (!ImplicitStandardConversionExists (texpr, t))
 							continue;
 					}
 				}
 
 				if (candidates == null)
 					candidates = new List<MethodSpec> ();
 
 				candidates.Add (op);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="122" endline="244">
<![CDATA[
 
 			#endregion
 		}
 
 		[Flags]
 		enum CachedMethods
 		{
 			Equals				= 1,
 			GetHashCode			= 1 << 1,
 			HasStaticFieldInitializer	= 1 << 2
 		}
 
 
 		// Whether this is a struct, class or interface
 		public readonly MemberKind Kind;
 
 		// Holds a list of classes and structures
 		protected List<TypeContainer> types;
 
 		List<MemberCore> ordered_explicit_member_list;
 		List<MemberCore> ordered_member_list;
 
 		// Holds the list of properties
 		List<MemberCore> properties;
 
 		// Holds the list of constructors
 		protected List<Constructor> instance_constructors;
 
 		// Holds the list of fields
 		protected List<FieldBase> fields;
 
 		// Holds a list of fields that have initializers
 		protected List<FieldInitializer> initialized_fields;
 
 		// Holds a list of static fields that have initializers
 		protected List<FieldInitializer> initialized_static_fields;
 
 		// Holds the list of constants
 		protected List<MemberCore> constants;
 
 		// Holds the methods.
 		List<MemberCore> methods;
 
 		// Holds the events
 		protected List<MemberCore> events;
 
 		// Holds the indexers
 		List<MemberCore> indexers;
 
 		// Holds the operators
 		List<MemberCore> operators;
 
 		// Holds the compiler generated classes
 		protected List<CompilerGeneratedClass> compiler_generated;
 
 		Dictionary<MethodSpec, Method> hoisted_base_call_proxies;
 
 		Dictionary<string, FullNamedExpression> Cache = new Dictionary<string, FullNamedExpression> ();
 
 		//
 		// Pointers to the default constructor and the default static constructor
 		//
 		protected Constructor default_constructor;
 		protected Constructor default_static_constructor;
 
 		//
 		// Points to the first non-static field added to the container.
 		//
 		// This is an arbitrary choice.  We are interested in looking at _some_ non-static field,
 		// and the first one's as good as any.
 		//
 		FieldBase first_nonstatic_field;
 
 		//
 		// This one is computed after we can distinguish interfaces
 		// from classes from the arraylist `type_bases' 
 		//
 		protected TypeSpec base_type;
 		protected TypeExpr base_type_expr;
 		protected TypeExpr[] iface_exprs;
 
 		protected List<FullNamedExpression> type_bases;
 
 		bool members_defined;
 		bool members_defined_ok;
 		bool type_defined;
 
 		TypeContainer InTransit;
 
 		GenericTypeParameterBuilder[] all_tp_builders;
 
 		public const string DefaultIndexerName = "Item";
 
 		private bool seen_normal_indexers = false;
 		private string indexer_name = DefaultIndexerName;
 		protected bool requires_delayed_unmanagedtype_check;
 		bool error;
 
 		private CachedMethods cached_method;
 
 		protected TypeSpec spec;
 		TypeSpec current_type;
 
 		List<TypeContainer> partial_parts;
 
 		public int DynamicSitesCounter;
 
 		/// <remarks>
 		///  The pending methods that need to be implemented
 		//   (interfaces or abstract methods)
 		/// </remarks>
 		PendingImplementation pending;
 
 		public TypeContainer (NamespaceEntry ns, DeclSpace parent, MemberName name,
 				      Attributes attrs, MemberKind kind)
 			
 		{
 			if (parent != null && parent.NamespaceEntry != ns)
 				throw new InternalErrorException ("A nested type should be in the same NamespaceEntry as its enclosing class");
 
 			this.Kind = kind;
 			this.PartialContainer = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="220" endline="339">
<![CDATA[
 
 		//
 		// 6.1.6 Implicit reference conversions
 		//
 		public static bool ImplicitReferenceConversionExists (Expression expr, TypeSpec target_type)
 		{
 			if (TypeManager.IsStruct (target_type))
 				return false;
 
 			TypeSpec expr_type = expr.Type;
 
 			// from the null type to any reference-type.
 			if (expr_type == InternalType.Null)
 				return target_type != InternalType.AnonymousMethod;
 
 			if (TypeManager.IsGenericParameter (expr_type))
 				return ImplicitTypeParameterConversion (expr, target_type) != null;
 
 			// This code is kind of mirrored inside ImplicitStandardConversionExists
 			// with the small distinction that we only probe there
 			//
 			// Always ensure that the code here and there is in sync
 
 			// from any class-type S to any interface-type T.
 			if (target_type.IsInterface) {
 				if (expr_type.ImplementsInterface (target_type, true)){
 					return !TypeManager.IsValueType (expr_type);
 				}
 			}
 
 			//
 			// Implicit reference conversions (no-boxing) to object or dynamic
 			//
 			if (target_type == TypeManager.object_type || target_type == InternalType.Dynamic) {
 				switch (expr_type.Kind) {
 				case MemberKind.Class
 				case MemberKind.Interface
 				case MemberKind.Delegate
 				case MemberKind.ArrayType
 					return true;
 				}
 
 				return expr_type == InternalType.Dynamic;
 			}
 
 			if (target_type == TypeManager.value_type) {
 				return expr_type == TypeManager.enum_type;
 			} else if (expr_type == target_type || TypeSpec.IsBaseClass (expr_type, target_type, true)) {
 				//
 				// Special case
 				// System.Enum is not a value type, it is a class, so we need
 				// a boxing conversion
 				//
 				if (target_type == TypeManager.enum_type || TypeManager.IsGenericParameter (expr_type))
 					return false;
 
 				if (TypeManager.IsValueType (expr_type))
 					return false;
 
 				// Array type variance conversion
 				//if (target_type.IsArray != expr_type.IsArray)
 				//	return false;
 
 				return true;
 			}
 
 			var expr_type_array = expr_type as ArrayContainer;
 			if (expr_type_array != null) {
 				var target_type_array = target_type as ArrayContainer;
 				// from an array-type S to an array-type of type T
 				if (target_type_array != null && expr_type_array.Rank == target_type_array.Rank) {
 
 					//
 					// Both SE and TE are reference-types
 					//
 					TypeSpec expr_element_type = expr_type_array.Element;
 					if (!TypeManager.IsReferenceType (expr_element_type))
 						return false;
 
 					TypeSpec target_element_type = target_type_array.Element;
 					if (!TypeManager.IsReferenceType (target_element_type))
 						return false;
 
 					if (MyEmptyExpr == null)
 						MyEmptyExpr = new EmptyExpression (expr_element_type);
 					else
 						MyEmptyExpr.SetType (expr_element_type);
 
 					return ImplicitStandardConversionExists (MyEmptyExpr, target_element_type);
 				}
 
 				// from an array-type to System.Array
 				if (target_type == TypeManager.array_type)
 					return true;
 
 				// from an array-type of type T to IList<T>
 				if (ArrayToIList (expr_type_array, target_type, false))
 					return true;
 
 				return false;
 			}
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type))
 				return true;
 
 			if (TypeSpecComparer.Variant.IsEqual (expr_type, target_type))
 				return true;
 
 			// from any interface type S to interface-type T.
 			if (expr_type.IsInterface && target_type.IsInterface) {
 				return expr_type.ImplementsInterface (target_type, true);
 			}
 
 			// from any delegate type to System.Delegate
 			if (target_type == TypeManager.delegate_type &&
 				(expr_type == TypeManager.delegate_type || expr_type.IsDelegate))
 				return true;
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="139" endline="267">
<![CDATA[
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
 
 		public Enum (NamespaceEntry ns, DeclSpace parent, TypeExpression type,
 			     Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			base_type_expr = type;
 			var accmods = IsTopLevel ? Modifiers.INTERNAL 
 			ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod_flags, accmods, Location, Report);
 			spec = new EnumSpec (null, this, null, null, ModFlags);
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Enum;
 			}
 		}
 
 		public TypeExpr BaseTypeExpression {
 			get {
 				return base_type_expr;
 			}
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
 		}
 
 		public TypeSpec UnderlyingType {
 			get {
 				return ((EnumSpec) spec).UnderlyingType;
 			}
 		}
 
 		#endregion
 
 		public void AddEnumMember (EnumMember em)
 		{
 			if (em.Name == UnderlyingValueField) {
 				Report.Error (76, em.Location, "An item in an enumeration cannot have an identifier `{0}'",
 					UnderlyingValueField);
 				return;
 			}
 
 			AddConstant (em);
 		}
 
 		public static void Error_1008 (Location loc, Report Report)
 		{
 			Report.Error (1008, loc,
 				"Type byte, sbyte, short, ushort, int, uint, long or ulong expected");
 		}
 
 		protected override bool DefineNestedTypes ()
 		{
 			((EnumSpec) spec).UnderlyingType = base_type_expr == null ? TypeManager.int32_type 
 
 			TypeBuilder.DefineField (UnderlyingValueField, UnderlyingType.GetMetaInfo (),
 				FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
 
 			if (!RootContext.StdLib)
 				Module.hack_corlib_enums.Add (this);
 
 			return true;
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			if (constants != null) {
 				for (int i = 0; i < constants.Count; ++i) {
 					EnumMember em = (EnumMember) constants [i];
 					if (em.Initializer == null) {
 						em.Initializer = new ImplicitInitializer (em, i == 0 ? null 
 					}
 
 					em.Define ();
 				}
 			}
 
 			return true;
 		}
 
 		public override bool IsUnmanagedType ()
 		{
 			return true;
 		}
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.enum_type;
 			base_class = base_type_expr;
 			return null;
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (UnderlyingType == TypeManager.uint32_type ||
 				UnderlyingType == TypeManager.uint64_type ||
 				UnderlyingType == TypeManager.ushort_type) {
 				Report.Warning (3009, 1, Location, "`{0}'
 			}
 
 			return true;
 		}	
 	}
 
 	class EnumSpec 
 	{
 		TypeSpec underlying;
 
 		public EnumSpec (TypeSpec declaringType, ITypeDefinition definition, TypeSpec underlyingType, MetaType info, Modifiers modifiers)
 			
 		{
 			this.underlying = underlyingType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2878" endline="3005">
<![CDATA[
 
 		public abstract void SetTypeArguments (ResolveContext ec, TypeArguments ta);
 	}
 
 	// 
 	// Represents a group of extension method candidates for whole namespace
 	// 
 	class ExtensionMethodGroupExpr 
 	{
 		NamespaceEntry namespace_entry;
 		public readonly Expression ExtensionExpression;
 
 		public ExtensionMethodGroupExpr (IList<MethodSpec> list, NamespaceEntry n, Expression extensionExpr, Location l)
 			
 		{
 			this.namespace_entry = n;
 			this.ExtensionExpression = extensionExpr;
 		}
 
 		public override bool IsStatic {
 			get { return true; }
 		}
 
 		public override IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			if (namespace_entry == null)
 				return null;
 
 			//
 			// For extension methodgroup we are not looking for base members but parent
 			// namespace extension methods
 			//
 			int arity = type_arguments == null ? 0 
 			var found = namespace_entry.LookupExtensionMethod (DeclaringType, Name, arity, ref namespace_entry);
 			if (found == null)
 				return null;
 
 			return found.Cast<MemberSpec> ().ToList ();
 		}
 
 		public override MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			// We are already here
 			return null;
 		}
 
 		public override MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments arguments, OverloadResolver.IErrorHandler ehandler, OverloadResolver.Restrictions restr)
 		{
 			if (arguments == null)
 				arguments = new Arguments (1);
 
 			arguments.Insert (0, new Argument (ExtensionExpression, Argument.AType.ExtensionType));
 			var res = base.OverloadResolve (ec, ref arguments, ehandler ?? this, restr);
 
 			// Store resolved argument and restore original arguments
 			if (res == null) {
 				// Clean-up modified arguments for error reporting
 				arguments.RemoveAt (0);
 				return null;
 			}
 
 			var me = ExtensionExpression as MemberExpr;
 			if (me != null)
 				me.ResolveInstanceExpression (ec, null);
 
 			InstanceExpression = null;
 			return this;
 		}
 
 		#region IErrorHandler Members
 
 		bool OverloadResolver.IErrorHandler.AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument arg, int index)
 		{
 			rc.Report.SymbolRelatedToPreviousError (best);
 			rc.Report.Error (1928, loc,
 				"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' has some invalid arguments",
 				queried_type.GetSignatureForError (), Name, best.GetSignatureForError ());
 
 			if (index == 0) {
 				rc.Report.Error (1929, loc,
 					"Extension method instance type `{0}' cannot be converted to `{1}'",
 					arg.Type.GetSignatureForError (), ((MethodSpec)best).Parameters.ExtensionMethodType.GetSignatureForError ());
 			}
 
 			return true;
 		}
 
 		bool OverloadResolver.IErrorHandler.NoArgumentMatch (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.TypeInferenceFailed (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1247" endline="1381">
<![CDATA[
 
 		static Expression ImplicitConversionStandard (ResolveContext ec, Expression expr, TypeSpec target_type, Location loc, bool explicit_cast)
 		{
 			if (expr.eclass == ExprClass.MethodGroup){
 				if (!TypeManager.IsDelegateType (target_type)){
 					return null;
 				}
 
 				//
 				// Only allow anonymous method conversions on post ISO_1
 				//
 				if (RootContext.Version != LanguageVersion.ISO_1){
 					MethodGroupExpr mg = expr as MethodGroupExpr;
 					if (mg != null)
 						return ImplicitDelegateCreation.Create (
 							ec, mg, target_type, loc);
 				}
 			}
 
 			TypeSpec expr_type = expr.Type;
 			Expression e;
 
 			if (expr_type == target_type) {
 				if (expr_type != InternalType.Null && expr_type != InternalType.AnonymousMethod)
 					return expr;
 				return null;
 			}
 
 			if (expr_type == InternalType.Dynamic) {
 				switch (target_type.Kind) {
 				case MemberKind.ArrayType
 				case MemberKind.Class
 					if (target_type == TypeManager.object_type)
 						return EmptyCast.Create (expr, target_type);
 
 					goto case MemberKind.Struct;
 				case MemberKind.Struct
 					// TODO
 					if (target_type == TypeManager.void_type)
 						return null;
 
 					goto case MemberKind.Enum;
 				case MemberKind.Delegate
 				case MemberKind.Enum
 				case MemberKind.Interface
 				case MemberKind.TypeParameter
 					Arguments args = new Arguments (1);
 					args.Add (new Argument (expr));
 					return new DynamicConversion (target_type, explicit_cast ? CSharpBinderFlags.ConvertExplicit 
 				}
 
 				return null;
 			}
 
 			if (TypeManager.IsNullableType (target_type))
 				return ImplicitNulableConversion (ec, expr, target_type);
 
 			//
 			// Attempt to do the implicit constant expression conversions
 			//
 			Constant c = expr as Constant;
 			if (c != null) {
 				try {
 					c = c.ConvertImplicitly (ec, target_type);
 				} catch {
 					Console.WriteLine ("Conversion error happened in line {0}", loc);
 					throw;
 				}
 				if (c != null)
 					return c;
 			}
 
 			e = ImplicitNumericConversion (expr, expr_type, target_type);
 			if (e != null)
 				return e;
 
 			e = ImplicitReferenceConversion (expr, target_type, explicit_cast);
 			if (e != null)
 				return e;
 
 			if (expr is IntegralConstant && TypeManager.IsEnumType (target_type)){
 				var i = (IntegralConstant) expr;
 				//
 				// LAMESPEC
 				//
 				// An implicit enumeration conversion permits the decimal-integer-literal 0
 				// to be converted to any enum-type and to any nullable-type whose underlying
 				// type is an enum-type
 				//
 				if (i.IsZeroInteger) {
 					// Recreate 0 literal to remove any collected conversions
 					return new EnumConstant (new IntLiteral (0, i.Location), target_type).Resolve (ec);
 				}
 			}
 
 			if (ec.IsUnsafe) {
 				var target_pc = target_type as PointerContainer;
 				if (target_pc != null) {
 					if (expr_type.IsPointer) {
 						//
 						// Pointer types are same when they have same element types
 						//
 						if (expr_type == target_pc)
 							return expr;
 
 						if (target_pc.Element.BuildinType == BuildinTypeSpec.Type.Void)
 							return EmptyCast.Create (expr, target_type);
 
 						//return null;
 					}
 
 					if (expr_type == InternalType.Null)
 						return EmptyCast.Create (new NullPointer (loc), target_type);
 				}
 			}
 
 			if (expr_type == InternalType.AnonymousMethod){
 				AnonymousMethodExpression ame = (AnonymousMethodExpression) expr;
 				Expression am = ame.Compatible (ec, target_type);
 				if (am != null)
 					return am.Resolve (ec);
 			}
 
 			if (expr_type == InternalType.Arglist && target_type == TypeManager.arg_iterator_type)
 				return expr;
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type)) {
 				if (expr_type == target_type)
 					return expr;
 
 				return EmptyCast.Create (expr, target_type);
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2728" endline="2880">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (left == null)
 				return null;
 
 			if ((oper == Operator.Subtraction) && (left is ParenthesizedExpression)) {
 				left = ((ParenthesizedExpression) left).Expr;
 				left = left.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 				if (left == null)
 					return null;
 
 				if (left.eclass == ExprClass.Type) {
 					ec.Report.Error (75, loc, "To cast a negative value, you must enclose the value in parentheses");
 					return null;
 				}
 			} else
 				left = left.Resolve (ec);
 
 			if (left == null)
 				return null;
 
 			Constant lc = left as Constant;
 
 			if (lc != null && lc.Type == TypeManager.bool_type &&
 				((oper == Operator.LogicalAnd && lc.IsDefaultValue) ||
 				 (oper == Operator.LogicalOr && !lc.IsDefaultValue))) {
 
 				// FIXME
 				// right.Resolve (ec);
 
 				ec.Report.Warning (429, 4, loc, "Unreachable expression code detected");
 				return left;
 			}
 
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			Constant rc = right as Constant;
 
 			// The conversion rules are ignored in enum context but why
 			if (!ec.HasSet (ResolveContext.Options.EnumScope) && lc != null && rc != null && (TypeManager.IsEnumType (left.Type) || TypeManager.IsEnumType (right.Type))) {
 				lc = EnumLiftUp (ec, lc, rc, loc);
 				if (lc != null)
 					rc = EnumLiftUp (ec, rc, lc, loc);
 			}
 
 			if (rc != null && lc != null) {
 				int prev_e = ec.Report.Errors;
 				Expression e = ConstantFold.BinaryFold (ec, oper, lc, rc, loc);
 				if (e != null)
 					e = e.Resolve (ec);
 
 				if (e != null || ec.Report.Errors != prev_e)
 					return e;
 			}
 
 			// Comparison warnings
 			if ((oper & Operator.ComparisonMask) != 0) {
 				if (left.Equals (right)) {
 					ec.Report.Warning (1718, 3, loc, "A comparison made to same variable. Did you mean to compare something else?");
 				}
 				CheckUselessComparison (ec, lc, right.Type);
 				CheckUselessComparison (ec, rc, left.Type);
 			}
 
 			if (left.Type == InternalType.Dynamic || right.Type == InternalType.Dynamic) {
 				var lt = left.Type;
 				var rt = right.Type;
 				if (lt == TypeManager.void_type || lt == InternalType.MethodGroup || lt == InternalType.AnonymousMethod ||
 					rt == TypeManager.void_type || rt == InternalType.MethodGroup || rt == InternalType.AnonymousMethod) {
 					Error_OperatorCannotBeApplied (ec, left, right);
 					return null;
 				}
 
 				Arguments args;
 
 				//
 				// Special handling for logical boolean operators which require rhs not to be
 				// evaluated based on lhs value
 				//
 				if ((oper & Operator.LogicalMask) != 0) {
 					Expression cond_left, cond_right, expr;
 
 					args = new Arguments (2);
 
 					if (lt == InternalType.Dynamic) {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (lt, ec.CurrentBlock, loc);
 
 						var cond_args = new Arguments (1);
 						cond_args.Add (new Argument (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left).Resolve (ec)));
 
 						//
 						// dynamic && bool => IsFalse (temp = left) ? temp 
 						// dynamic || bool => IsTrue (temp = left) ? temp 
 						//
 						left = temp.CreateReferenceExpression (ec, loc);
 						if (oper == Operator.LogicalAnd) {
 							expr = DynamicUnaryConversion.CreateIsFalse (cond_args, loc);
 							cond_left = left;
 						} else {
 							expr = DynamicUnaryConversion.CreateIsTrue (cond_args, loc);
 							cond_left = left;
 						}
 
 						args.Add (new Argument (left));
 						args.Add (new Argument (right));
 						cond_right = new DynamicExpressionStatement (this, args, loc);
 					} else {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (TypeManager.bool_type, ec.CurrentBlock, loc);
 
 						args.Add (new Argument (temp.CreateReferenceExpression (ec, loc).Resolve (ec)));
 						args.Add (new Argument (right));
 						right = new DynamicExpressionStatement (this, args, loc);
 
 						//
 						// bool && dynamic => (temp = left) ? temp && right 
 						// bool || dynamic => (temp = left) ? temp 
 						//
 						if (oper == Operator.LogicalAnd) {
 							cond_left = right;
 							cond_right = temp.CreateReferenceExpression (ec, loc);
 						} else {
 							cond_left = temp.CreateReferenceExpression (ec, loc);
 							cond_right = right;
 						}
 
 						expr = new BooleanExpression (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left));
 					}
 
 					return new Conditional (expr, cond_left, cond_right, loc).Resolve (ec);
 				}
 
 				args = new Arguments (2);
 				args.Add (new Argument (left));
 				args.Add (new Argument (right));
 				return new DynamicExpressionStatement (this, args, loc).Resolve (ec);
 			}
 
 			if (RootContext.Version >= LanguageVersion.ISO_2 &&
 				((TypeManager.IsNullableType (left.Type) && (right is NullLiteral || TypeManager.IsNullableType (right.Type) || TypeManager.IsValueType (right.Type))) ||
 				(TypeManager.IsValueType (left.Type) && right is NullLiteral) ||
 				(TypeManager.IsNullableType (right.Type) && (left is NullLiteral || TypeManager.IsNullableType (left.Type) || TypeManager.IsValueType (left.Type))) ||
 				(TypeManager.IsValueType (right.Type) && left is NullLiteral))) {
 				var lifted = new Nullable.LiftedBinaryOperator (oper, left, right, loc);
 				lifted.state = state;
 				return lifted.Resolve (ec);
 			}
 
 			return DoResolveCore (ec, left, right);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="978" endline="1123">
<![CDATA[
 
 		readonly string name;
 
 		InternalType (string name, MemberCache cache)
 			
 		{
 			this.cache = cache;
 		}
 
 		InternalType (string name)
 			
 		{
 			this.name = name;
 			this.definition = this;
 			cache = MemberCache.Empty;
 
 			// Make all internal types CLS-compliant, non-obsolete
 			state = (state & ~(StateFlags.CLSCompliant_Undetected | StateFlags.Obsolete_Undetected)) | StateFlags.CLSCompliant;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return 0;
 			}
 		}
 
 		IAssemblyDefinition ITypeDefinition.DeclaringAssembly {
 			get {
 				throw new NotImplementedException ();
 			}
 		}
 
 		bool IMemberDefinition.IsImported {
 			get {
 				return false;
 			}
 		}
 
 		public override string Name {
 			get {
 				return name;
 			}
 		}
 
 		string ITypeDefinition.Namespace {
 			get {
 				return null;
 			}
 		}
 
 		int ITypeDefinition.TypeParametersCount {
 			get {
 				return 0;
 			}
 		}
 
 		TypeParameterSpec[] ITypeDefinition.TypeParameters {
 			get {
 				return null;
 			}
 		}
 
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			return name;
 		}
 
 		#region ITypeDefinition Members
 
 		TypeSpec ITypeDefinition.GetAttributeCoClass ()
 		{
 			return null;
 		}
 
 		string ITypeDefinition.GetAttributeDefaultMember ()
 		{
 			return null;
 		}
 
 		AttributeUsageAttribute ITypeDefinition.GetAttributeUsage (PredefinedAttribute pa)
 		{
 			return null;
 		}
 
 		bool ITypeDefinition.IsInternalAsPublic (IAssemblyDefinition assembly)
 		{
 			throw new NotImplementedException ();
 		}
 
 		void ITypeDefinition.LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			throw new NotImplementedException ();
 		}
 
 		string[] IMemberDefinition.ConditionalConditions ()
 		{
 			return null;
 		}
 
 		ObsoleteAttribute IMemberDefinition.GetAttributeObsolete ()
 		{
 			return null;
 		}
 
 		bool IMemberDefinition.IsNotCLSCompliant ()
 		{
 			return false;
 		}
 
 		void IMemberDefinition.SetIsAssigned ()
 		{
 		}
 
 		void IMemberDefinition.SetIsUsed ()
 		{
 		}
 
 		#endregion
 	}
 
 	public abstract class ElementTypeSpec 
 	{
 		protected ElementTypeSpec (MemberKind kind, TypeSpec element, MetaType info)
 			
 		{
 			this.Element = element;
 
 			// Some flags can be copied directly from the element
 			const StateFlags shared_flags = StateFlags.CLSCompliant | StateFlags.CLSCompliant_Undetected
 				| StateFlags.Obsolete | StateFlags.Obsolete_Undetected | StateFlags.HasDynamicElement;
 			state &= ~shared_flags;
 			state |= (element.state & shared_flags);
 
 			if (element == InternalType.Dynamic)
 				state |= StateFlags.HasDynamicElement;
 
 			// Has to use its own type definition instead of just element definition to
 			// correctly identify itself for cases like x.MemberDefininition == predefined.MemberDefinition
 			this.definition = this;
 
 			cache = MemberCache.Empty;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1469" endline="1573">
<![CDATA[
 
 		protected virtual bool DoDefineMembers ()
 		{
 			if (iface_exprs != null) {
 				foreach (TypeExpr iface in iface_exprs) {
 					if (iface == null)
 						continue;
 
 					var iface_type = iface.Type;
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null)
 						compiled_iface.Define ();
 
 					if (Kind == MemberKind.Interface)
 						MemberCache.AddInterface (iface_type);
 
 					ObsoleteAttribute oa = iface_type.GetAttributeObsolete ();
 					if (oa != null && !IsObsolete)
 						AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 
 					GenericTypeExpr ct = iface as GenericTypeExpr;
 					if (ct != null) {
 						// TODO
 						TypeManager.CheckTypeVariance (ct.Type, Variance.Covariant, this);
 
 						ct.CheckConstraints (this);
 
 						if (ct.HasDynamicArguments () && !IsCompilerGenerated) {
 							Report.Error (1966, iface.Location,
 								"`{0}'
 								GetSignatureForError (), iface.GetSignatureForError ());
 							return false;
 						}
 					}
 				}
 				foreach (TypeExpr iface in iface_exprs) {
 					if (iface == null)
 						continue;
 
 					var iface_type = iface.Type;
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null)
 						compiled_iface.Define ();
 
 					if (Kind == MemberKind.Interface)
 						MemberCache.AddInterface (iface_type);
 
 					ObsoleteAttribute oa = iface_type.GetAttributeObsolete ();
 					if (oa != null && !IsObsolete)
 						AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 
 					GenericTypeExpr ct = iface as GenericTypeExpr;
 					if (ct != null) {
 						// TODO
 						TypeManager.CheckTypeVariance (ct.Type, Variance.Covariant, this);
 
 						ct.CheckConstraints (this);
 
 						if (ct.HasDynamicArguments () && !IsCompilerGenerated) {
 							Report.Error (1966, iface.Location,
 								"`{0}'
 								GetSignatureForError (), iface.GetSignatureForError ());
 							return false;
 						}
 					}
 				}
 			}
 
 			if (base_type != null) {
 				ObsoleteAttribute obsolete_attr = base_type.GetAttributeObsolete ();
 				if (obsolete_attr != null && !IsObsolete)
 					AttributeTester.Report_ObsoleteMessage (obsolete_attr, base_type.GetSignatureForError (), Location, Report);
 
 				var ct = base_type_expr as GenericTypeExpr;
 				if (ct != null)
 					ct.CheckConstraints (this);
 
 				if (base_type.Interfaces != null) {
 					foreach (var iface in base_type.Interfaces)
 						spec.AddInterface (iface);
 					foreach (var iface in base_type.Interfaces)
 						spec.AddInterface (iface);
 				}
 
 				var baseContainer = base_type.MemberDefinition as ClassOrStruct;
 				if (baseContainer != null) {
 					baseContainer.Define ();
 
 					//
 					// It can trigger define of this type (for generic types only)
 					//
 					if (HasMembersDefined)
 						return true;
 				}
 			}
 
 			if (type_params != null) {
 				foreach (var tp in type_params) {
 					tp.CheckGenericConstraints ();
 				}
 				foreach (var tp in type_params) {
 					tp.CheckGenericConstraints ();
 				}
 			}
 
 			DefineContainerMembers (constants);
 			DefineContainerMembers (fields);
 
 			if (Kind == MemberKind.Struct || Kind == MemberKind.Class) {
 				pending = PendingImplementation.GetPendingImplementations (this);
 
 				if (requires_delayed_unmanagedtype_check) {
 					requires_delayed_unmanagedtype_check = false;
 					foreach (FieldBase f in fields) {
 						if (f.MemberType != null && f.MemberType.IsPointer)
 							TypeManager.VerifyUnmanaged (Compiler, f.MemberType, f.Location);
 					}
 					foreach (FieldBase f in fields) {
 						if (f.MemberType != null && f.MemberType.IsPointer)
 							TypeManager.VerifyUnmanaged (Compiler, f.MemberType, f.Location);
 					}
 				}
 			}
 		
 			//
 			// Constructors are not in the defined_names array
 			//
 			DefineContainerMembers (instance_constructors);
 		
 			DefineContainerMembers (events);
 			DefineContainerMembers (ordered_explicit_member_list);
 			DefineContainerMembers (ordered_member_list);
 
 			if (operators != null) {
 				DefineContainerMembers (operators);
 				CheckPairedOperators ();
 			}
 
 			ComputeIndexerName();
 			CheckEqualsAndGetHashCode();
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="349" endline="519">
<![CDATA[
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		//
 		// Explicit struct layout set by parent
 		//
 		public CharSet? CharSet {
 			get; set;
 		}		
 
 		#endregion
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ImplicitConversionRequired (rc, TypeManager.int32_type, Location);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsPrimitiveType (MemberType)) {
 				Report.Error (1663, Location,
 					"`{0}'
 					GetSignatureForError ());
 			} else if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Fields.IndexOf (this);
 				foreach (var d in declarators) {
 					var f = new FixedField (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					f.initializer = d.Initializer;
 					((ConstInitializer) f.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 			}
 			
 			// Create nested fixed buffer container
 			string name = String.Format ("<{0}>__FixedBuffer{1}", Name, GlobalCounter++);
 			fixed_buffer_type = Parent.TypeBuilder.DefineNestedType (name, Parent.Module.DefaultCharSetType |
 				TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit, TypeManager.value_type.GetMetaInfo ());
 
 			fixed_buffer_type.DefineField (FixedElementName, MemberType.GetMetaInfo (), FieldAttributes.Public);
 			
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, fixed_buffer_type, ModifiersExtensions.FieldAttr (ModFlags));
 			var element_spec = new FieldSpec (null, this, MemberType, FieldBuilder, ModFlags);
 			spec = new FixedFieldSpec (Parent.Definition, this, FieldBuilder, element_spec, ModFlags);
 
 			Parent.MemberCache.AddMember (spec);
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			if (!IsUnsafe)
 				Expression.UnsafeError (Report, Location);
 
 			if (Parent.PartialContainer.Kind != MemberKind.Struct) {
 				Report.Error (1642, Location, "`{0}'
 					GetSignatureForError ());
 			}
 		}
 
 		public override void Emit()
 		{
 			ResolveContext rc = new ResolveContext (this);
 			IntConstant buffer_size_const = initializer.Resolve (rc) as IntConstant;
 			if (buffer_size_const == null)
 				return;
 
 			int buffer_size = buffer_size_const.Value;
 
 			if (buffer_size <= 0) {
 				Report.Error (1665, Location, "`{0}'
 				return;
 			}
 
 			int type_size = Expression.GetTypeSize (MemberType);
 
 			if (buffer_size > int.MaxValue / type_size) {
 				Report.Error (1664, Location, "Fixed size buffer `{0}' of length `{1}' and type `{2}' exceeded 2^31 limit",
 					GetSignatureForError (), buffer_size.ToString (), TypeManager.CSharpName (MemberType));
 				return;
 			}
 
 			EmitFieldSize (buffer_size);
 
 			Module.PredefinedAttributes.UnsafeValueType.EmitAttribute (fixed_buffer_type);
 			Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (fixed_buffer_type);
 			fixed_buffer_type.CreateType ();
 
 			base.Emit ();
 		}
 
 		void EmitFieldSize (int buffer_size)
 		{
 			PredefinedAttribute pa;
 			AttributeEncoder encoder;
 
 			pa = Module.PredefinedAttributes.StructLayout;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.short_type))
 				return;
 
 			var char_set_type = Module.PredefinedTypes.CharSet.Resolve (Location);
 			if (char_set_type == null)
 				return;
 
 			var field_size = pa.GetField ("Size", TypeManager.int32_type, Location);
 			var field_charset = pa.GetField ("CharSet", char_set_type, Location);
 			if (field_size == null || field_charset == null)
 				return;
 
 			var char_set = CharSet ?? Module.DefaultCharSet;
 
 			encoder = new AttributeEncoder ();
 			encoder.Encode ((short)LayoutKind.Sequential);
 			encoder.EncodeNamedArguments (
 				new [] { field_size, field_charset },
 				new Constant [] { new IntConstant (buffer_size, Location), new IntConstant ((int) char_set, Location) }
 			);
 
 			pa.EmitAttribute (fixed_buffer_type, encoder);
 
 			//
 			// Don't emit FixedBufferAttribute attribute for private types
 			//
 			if ((ModFlags & Modifiers.PRIVATE) != 0)
 				return;
 
 			pa = Module.PredefinedAttributes.FixedBuffer;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.type_type, TypeManager.int32_type))
 				return;
 
 			encoder = new AttributeEncoder ();
 			encoder.EncodeTypeName (MemberType);
 			encoder.Encode (buffer_size);
 			encoder.EncodeEmptyNamedArguments ();
 
 			pa.EmitAttribute (FieldBuilder, encoder);
 		}
 	}
 
 	class FixedFieldSpec 
 	{
 		readonly FieldSpec element;
 
 		public FixedFieldSpec (TypeSpec declaringType, IMemberDefinition definition, FieldInfo info, FieldSpec element, Modifiers modifiers)
 			
 		{
 			this.element = element;
 
 			// It's never CLS-Compliant
 			state &= ~StateFlags.CLSCompliant_Undetected;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="242" endline="414">
<![CDATA[
 
 			internal const string Prefix = "set_";
 
 			protected ParametersCompiled parameters;
 
 			public SetMethod (PropertyBase method, Modifiers modifiers, ParametersCompiled parameters, Attributes attrs, Location loc)
 				
 			{
 				this.parameters = parameters;
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override ParametersCompiled ParameterInfo {
 			    get {
 			        return parameters;
 			    }
 			}
 
 			public override MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 				
 				base.Define (parent);
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, null, ParameterInfo, ModFlags);
 
 				method_data = new MethodData (method, ModFlags, flags, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				Spec.SetMetaInfo (method_data.MethodBuilder);
 
 				return method_data.MethodBuilder;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 		}
 
 		static string[] attribute_targets = new string [] { "property" };
 
 		public abstract class PropertyMethod 
 		{
 			public const Modifiers AllowedModifiers =
 				Modifiers.PUBLIC |
 				Modifiers.PROTECTED |
 				Modifiers.INTERNAL |
 				Modifiers.PRIVATE;
 		
 			protected readonly PropertyBase method;
 			protected MethodAttributes flags;
 
 			public PropertyMethod (PropertyBase method, string prefix, Modifiers modifiers, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = modifiers | (method.ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE));
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				TypeContainer container = parent.PartialContainer;
 
 				//
 				// Check for custom access modifier
 				//
 				if ((ModFlags & Modifiers.AccessibilityMask) == 0) {
 					ModFlags |= method.ModFlags;
 					flags = method.flags;
 				} else {
 					if (container.Kind == MemberKind.Interface)
 						Report.Error (275, Location, "`{0}'
 							GetSignatureForError ());
 
 					if ((method.ModFlags & Modifiers.ABSTRACT) != 0 && (ModFlags & Modifiers.PRIVATE) != 0) {
 						Report.Error (442, Location, "`{0}'
 					}
 
 					CheckModifiers (ModFlags);
 					ModFlags |= (method.ModFlags & (~Modifiers.AccessibilityMask));
 					ModFlags |= Modifiers.PROPERTY_CUSTOM;
 					flags = ModifiersExtensions.MethodAttr (ModFlags);
 					flags |= (method.flags & (~MethodAttributes.MemberAccessMask));
 				}
 
 				CheckAbstractAndExtern (block != null);
 				CheckProtectedModifier ();
 
 				if (block != null && block.IsIterator)
 					Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 
 				return null;
 			}
 
 			public bool HasCustomAccessModifier {
 				get {
 					return (ModFlags & Modifiers.PROPERTY_CUSTOM) != 0;
 				}
 			}
 
 			public PropertyBase Property {
 				get {
 					return method;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string GetSignatureForError()
 			{
 				return method.GetSignatureForError () + "." + prefix.Substring (0, 3);
 			}
 
 			void CheckModifiers (Modifiers modflags)
 			{
 				if (!ModifiersExtensions.IsRestrictedModifier (modflags & Modifiers.AccessibilityMask, method.ModFlags & Modifiers.AccessibilityMask)) {
 					Report.Error (273, Location,
 						"The accessibility modifier of the `{0}' accessor must be more restrictive than the modifier of the property or indexer `{1}'",
 						GetSignatureForError (), method.GetSignatureForError ());
 				}
 			}
 		}
 
 		PropertyMethod get, set, first;
 		PropertyBuilder PropertyBuilder;
 
 		public PropertyBase (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags,
 				     Modifiers allowed_mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="1447" endline="1619">
<![CDATA[
 
 		//
 		// Main compilation method
 		//
 		public bool Compile ()
 		{
 			var module = new ModuleContainer (ctx);
 			RootContext.ToplevelTypes = module;
 
 			if (timestamps) {
 				stopwatch = Stopwatch.StartNew ();
 				first_time = DateTime.Now;
 			}
 
 			Parse (module);
 			ShowTime ("Parsing source files");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (RootContext.TokenizeOnly || RootContext.ParseOnly)
 				return true;
 
 			if (RootContext.ToplevelTypes.NamespaceEntry != null)
 				throw new InternalErrorException ("who set it?");
 
 			//
 			// Quick hack
 			//
 			var output_file = RootContext.OutputFile;
 			string output_file_name;
 			if (output_file == null) {
 				if (first_source == null) {
 					Report.Error (1562, "If no source files are specified you must specify the output file with -out
 					return false;
 				}
 
 				int pos = first_source.LastIndexOf ('.');
 
 				if (pos > 0)
 					output_file = first_source.Substring (0, pos) + RootContext.TargetExt;
 				else
 					output_file = first_source + RootContext.TargetExt;
 
 				output_file_name = output_file;
 			} else {
 				output_file_name = Path.GetFileName (output_file);
 			}
 
 			//
 			// Load assemblies required
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 #if STATIC
 			var assembly = new AssemblyDefinitionStatic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new StaticImporter ();
 			assembly.Importer = importer;
 
 			var loader = new StaticLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (loader))
 				return false;
 
 			// System.Object was not loaded, use compiled assembly as corlib
 			if (loader.Corlib == null)
 				loader.Corlib = assembly.Builder;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #else
 			var assembly = new AssemblyDefinitionDynamic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new ReflectionImporter (ctx.BuildinTypes);
 			assembly.Importer = importer;
 
 			var loader = new DynamicLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Save))
 				return false;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #endif
 			module.Define ();
 
 			ShowTime ("Types definition");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (Report.Errors == 0 &&
 				RootContext.Documentation != null &&
 				!RootContext.Documentation.OutputDocComment (
 					output_file, Report))
 				return false;
 
 			//
 			// Verify using aliases now
 			//
 			NamespaceEntry.VerifyAllUsing ();
 			
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			assembly.Resolve ();
 			
 			if (Report.Errors > 0)
 				return false;
 			
 			//
 			// The code generator
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.Emit ();
 
 			ShowTime ("Resolving and emitting members blocks");
 
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			module.CloseType ();
 
 			ShowTime ("Closing types");
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.EmbedResources ();
 			ShowTime ("Embedding resources");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 			
 			assembly.Save ();
 
 #if STATIC
 			loader.Dispose ();
 #endif
 
 			ShowTime ("Saving output assembly");
 
 			ShowTotalTime ("Total");
 
 			Timer.ShowTimers ();
 
 			return (Report.Errors == 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="69" endline="246">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Class for applying custom attributes on the return type
 	/// </summary>
 	public class ReturnParameter 
 	{
 		MemberCore method;
 
 		// TODO
 		public ReturnParameter (MemberCore method, MethodBuilder mb, Location location)
 		{
 			this.method = method;
 			try {
 				builder = mb.DefineParameter (0, ParameterAttributes.None, "");			
 			}
 			catch (ArgumentOutOfRangeException) {
 				method.Compiler.Report.RuntimeMissingSupport (location, "custom attributes on the return type");
 			}
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant) {
 				method.Compiler.Report.Warning (3023, 1, a.Location,
 					"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead");
 			}
 
 			// This occurs after Warning -28
 			if (builder == null)
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.ReturnValue;
 			}
 		}
 
 		/// <summary>
 		/// Is never called
 		/// </summary>
 		public override string[] ValidAttributeTargets {
 			get {
 				return null;
 			}
 		}
 	}
 
 	public class ImplicitLambdaParameter 
 	{
 		public ImplicitLambdaParameter (string name, Location loc)
 			
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
 
 		public void SetParameterType (TypeSpec type)
 		{
 			parameter_type = type;
 		}
 	}
 
 	public class ParamsParameter 
 		public ParamsParameter (FullNamedExpression type, string name, Attributes attrs, Location loc)
 			base (type, name, Parameter.Modifier.PARAMS, attrs, loc)
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (base.Resolve (ec, index) == null)
 				return null;
 
 			var ac = parameter_type as ArrayContainer;
 			if (ac == null || ac.Rank != 1) {
 				ec.Compiler.Report.Error (225, Location, "The params parameter must be a single dimensional array");
 				return null;
 			}
 
 			return parameter_type;
 		}
 
 		public override void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			base.ApplyAttributes (mb, cb, index, pa);
 			pa.ParamArray.EmitAttribute (builder);
 		}
 	}
 
 	public class ArglistParameter 
 		// Doesn't have proper type because it's never chosen for better conversion
 		public ArglistParameter (Location loc) 
 			base (null, String.Empty, Parameter.Modifier.NONE, null, loc)
 		{
 			parameter_type = InternalType.Arglist;
 		}
 
 		public override void  ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			// Nothing to do
 		}
 
 		public override bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			return true;
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			return parameter_type;
 		}
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4689" endline="4867">
<![CDATA[
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return local_info.VariableInfo; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return local_info.HoistedVariant;
 		}
 
 		#region Properties
 
 		//		
 		// A local variable is always fixed
 		//
 		public override bool IsFixed {
 			get {
 				return true;
 			}
 		}
 
 		public override bool IsLockedByStatement {
 			get {
 				return local_info.IsLocked;
 			}
 			set {
 				local_info.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return false; }
 		}
 
 		public override string Name {
 			get { return local_info.Name; }
 		}
 
 		#endregion
 
 		public bool VerifyAssigned (ResolveContext ec)
 		{
 			VariableInfo variable_info = local_info.VariableInfo;
 			return variable_info == null || variable_info.IsAssigned (ec, loc);
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			local_info.AddressTaken = true;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			Arguments arg = new Arguments (1);
 			arg.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", arg);
 		}
 
 		void DoResolveBase (ResolveContext ec)
 		{
 			VerifyAssigned (ec);
 
 			//
 			// If we are referencing a variable from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (local_info)) {
 				if (local_info.AddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (ec.IsVariableCapturingRequired) {
 					AnonymousMethodStorey storey = local_info.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureLocalVariable (ec, local_info);
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			type = local_info.Type;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			// is out param
 			if (right_side == EmptyExpression.OutAccess.Instance)
 				local_info.SetIsUsed ();
 
 			if (local_info.IsReadonly && !ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.UsingInitializerScope)) {
 				int code;
 				string msg;
 				if (right_side == EmptyExpression.OutAccess.Instance) {
 					code = 1657; msg = "Cannot pass `{0}' as a ref or out argument because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberAccess) {
 					code = 1654; msg = "Cannot assign to members of `{0}' because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberOutAccess) {
 					code = 1655; msg = "Cannot pass members of `{0}' as ref or out arguments because it is a `{1}'";
 				} else if (right_side == EmptyExpression.UnaryAddress) {
 					code = 459; msg = "Cannot take the address of {1} `{0}'";
 				} else {
 					code = 1656; msg = "Cannot assign to `{0}' because it is a `{1}'";
 				}
 				ec.Report.Error (code, loc, msg, Name, local_info.GetReadOnlyContext ());
 			} else if (VariableInfo != null) {
 				VariableInfo.SetAssigned (ec);
 			}
 
 			DoResolveBase (ec);
 
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		public override int GetHashCode ()
 		{
 			return local_info.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			LocalVariableReference lvr = obj as LocalVariableReference;
 			if (lvr == null)
 				return false;
 
 			return local_info == lvr.local_info;
 		}
 
 		protected override ILocalVariable Variable {
 			get { return local_info; }
 		}
 
 		public override string ToString ()
 		{
 			return String.Format ("{0} ({1}
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing
 		}
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4527" endline="4703">
<![CDATA[
 	}
 
 	public abstract class VariableReference 
 		LocalTemporary temp;
 
 		#region Abstract
 		public abstract HoistedVariable GetHoistedVariable (AnonymousExpression ae);
 
 		public abstract bool IsLockedByStatement { get; set; }
 
 		public abstract bool IsFixed { get; }
 		public abstract bool IsRef { get; }
 		public abstract string Name { get; }
 		public abstract void SetHasAddressTaken ();
 
 		//
 		// Variable IL data, it has to be protected to encapsulate hoisted variables
 		//
 		protected abstract ILocalVariable Variable { get; }
 		
 		//
 		// Variable flow-analysis data
 		//
 		public abstract VariableInfo VariableInfo { get; }
 		#endregion
 
 		public virtual void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (IsLockedByStatement) {
 				rc.Report.Warning (728, 2, loc,
 					"Possibly incorrect assignment to `{0}' which is the argument to a using or lock statement",
 					Name);
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			// do nothing
 		}
 
 		//
 		// This method is used by parameters that are references, that are
 		// being passed as references
 		// is already stored in the parameter, not the address of the pointer,
 		// and not the value of the variable).
 		//
 		public void EmitLoad (EmitContext ec)
 		{
 			Variable.Emit (ec);
 		}
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
 
 
 		public HoistedVariable GetHoistedVariable (ResolveContext rc)
 		{
 			return GetHoistedVariable (rc.CurrentAnonymousMethod);
 		}
 
 		public HoistedVariable GetHoistedVariable (EmitContext ec)
 		{
 			return GetHoistedVariable (ec.CurrentAnonymousMethod);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Name;
 		}
 
 		public bool IsHoisted {
 			get { return GetHoistedVariable ((AnonymousExpression) null) != null; }
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="558" endline="750">
<![CDATA[
 	}
 
 	class DynamicIndexBinder 
 	{
 		bool can_be_mutator;
 
 		public DynamicIndexBinder (Arguments args, Location loc)
 			
 		{
 		}
 
 		public DynamicIndexBinder (CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			can_be_mutator = true;
 			return base.DoResolve (ec);
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
 
 		protected override Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			//
 			// Indexer has arguments which complicates things as the setter and getter
 			// are called in two steps when unary mutator is used. We have to make a
 			// copy of all variable arguments to not duplicate any side effect.
 			//
 			// ++d[++arg, Foo ()]
 			//
 
 			if (!can_be_mutator)
 				return base.CreateSetterArguments (rc, rhs);
 
 			var setter_args = new Arguments (Arguments.Count + 1);
 			for (int i = 0; i < Arguments.Count; ++i) {
 				var expr = Arguments[i].Expr;
 
 				if (expr is Constant || expr is VariableReference || expr is This) {
 					setter_args.Add (Arguments [i]);
 					continue;
 				}
 
 				LocalVariable temp = LocalVariable.CreateCompilerGenerated (expr.Type, rc.CurrentBlock, loc);
 				expr = new SimpleAssign (temp.CreateReferenceExpression (rc, expr.Location), expr).Resolve (rc);
 				Arguments[i].Expr = temp.CreateReferenceExpression (rc, expr.Location).Resolve (rc);
 				setter_args.Add (Arguments [i].Clone (expr));
 			}
 
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
 	}
 
 	class DynamicInvocation 
 	{
 		ATypeNameExpression member;
 
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 			this.member = member;
 		}
 
 		//
 		// When a return type is known not to be dynamic
 		//
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 		}
 
 		public static DynamicInvocation CreateSpecialNameInvoke (ATypeNameExpression member, Arguments args, Location loc)
 		{
 			return new DynamicInvocation (member, args, loc) {
 				flags = CSharpBinderFlags.InvokeSpecialName
 			};
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (member != null ? 5 
 			bool is_member_access = member is MemberAccess;
 
 			CSharpBinderFlags call_flags;
 			if (!is_member_access && member is SimpleName) {
 				call_flags = CSharpBinderFlags.InvokeSimpleName;
 				is_member_access = true;
 			} else {
 				call_flags = 0;
 			}
 
 			binder_args.Add (new Argument (new BinderFlags (call_flags, this)));
 
 			if (is_member_access)
 				binder_args.Add (new Argument (new StringLiteral (member.Name, member.Location)));
 
 			if (member != null && member.HasTypeArguments) {
 				TypeArguments ta = member.TypeArguments;
 				if (ta.Resolve (ec)) {
 					var targs = new ArrayInitializer (ta.Count, loc);
 					foreach (TypeSpec t in ta.Arguments)
 						targs.Add (new TypeOf (new TypeExpression (t, loc), loc));
 
 					binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (targs, loc)));
 				}
 			} else if (is_member_access) {
 				binder_args.Add (new Argument (new NullLiteral (loc)));
 			}
 
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 
 			Expression real_args;
 			if (args == null) {
 				// Cannot be null because .NET trips over
 				real_args = new ArrayCreation (
 					new MemberAccess (GetBinderNamespace (loc), "CSharpArgumentInfo", loc),
 					new ArrayInitializer (0, loc), loc);
 			} else {
 				real_args = new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc);
 			}
 
 			binder_args.Add (new Argument (real_args));
 
 			return new Invocation (GetBinder (is_member_access ? "InvokeMember" 
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			flags |= CSharpBinderFlags.ResultDiscarded;
 			base.EmitStatement (ec);
 		}
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
 
 		public DynamicMemberBinder (string name, CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
 	}
 
 	//
 	// Any member binder which can be source and target of assignment
 	//
 	abstract class DynamicMemberAssignable 
 	{
 		Expression setter;
 		Arguments setter_args;
 
 		protected DynamicMemberAssignable (Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2979" endline="4697">
<![CDATA[
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
 
 		public MethodGroupExpr (MethodSpec m, TypeSpec type, Location loc)
 			
 		{
 		}
 
 		#region Properties
 
 		public MethodSpec BestCandidate {
 			get {
 				return best_candidate;
 			}
 		}
 
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return;
 			}
 		}
 
 		protected override TypeSpec DeclaringType {
 			get {
 				return queried_type;
 			}
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override string Name {
 			get {
 				if (best_candidate != null)
 					return best_candidate.Name;
 
 				// TODO
 				return Methods.First ().Name;
 			}
 		}
 
 		#endregion
 
 		//
 		// When best candidate is already know this factory can be used
 		// to avoid expensive overload resolution to be called
 		//
 		// NOTE
 		//
 		public static MethodGroupExpr CreatePredefined (MethodSpec best, TypeSpec queriedType, Location loc)
 		{
 			return new MethodGroupExpr (best, queriedType, loc) {
 				best_candidate = best,
 				best_candidate_return = best.ReturnType
 			};
 		}
 
 		public override string GetSignatureForError ()
 		{
 			if (best_candidate != null)
 				return best_candidate.GetSignatureForError ();
 
 			return Methods.First ().GetSignatureForError ();
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (best_candidate == null) {
 				ec.Report.Error (1953, loc, "An expression tree cannot contain an expression with method group");
 				return null;
 			}
 
 			if (best_candidate.IsConditionallyExcluded (loc))
 				ec.Report.Error (765, loc,
 					"Partial methods with only a defining declaration or removed conditional methods cannot be used in an expression tree");
 			
 			return new TypeOfMethod (best_candidate, loc);
 		}
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			this.eclass = ExprClass.MethodGroup;
 
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (ec);
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotSupportedException ();
 		}
 		
 		public void EmitCall (EmitContext ec, Arguments arguments)
 		{
 			Invocation.EmitCall (ec, InstanceExpression, best_candidate, arguments, loc);			
 		}
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			ec.Report.Error (428, loc, "Cannot convert method group `{0}' to non-delegate type `{1}'. Consider using parentheses to invoke the method",
 				Name, TypeManager.CSharpName (target));
 		}
 
 		public static bool IsExtensionMethodArgument (Expression expr)
 		{
 			//
 			// LAMESPEC
 			//
 			return !(expr is TypeExpr) && !(expr is BaseThis);
 		}
 
 		/// <summary>
 		///   Find the Applicable Function Members (7.4.2.1)
 		///
 		///   me
 		///       it might contain constructors or methods (or anything
 		///       that maps to a method).
 		///
 		///   Arguments
 		///
 		///   loc
 		///        location for "probing" purposes.
 		///
 		///   Returns
 		///            that is the best match of me on Arguments.
 		///
 		/// </summary>
 		public virtual MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments args, OverloadResolver.IErrorHandler cerrors, OverloadResolver.Restrictions restr)
 		{
 			// TODO
 			if (best_candidate != null && best_candidate.Kind == MemberKind.Destructor)
 				return this;
 
 			var r = new OverloadResolver (Methods, type_arguments, restr, loc);
 			if ((restr & OverloadResolver.Restrictions.NoBaseMembers) == 0) {
 				r.BaseMembersProvider = this;
 			}
 
 			if (cerrors != null)
 				r.CustomErrors = cerrors;
 
 			// TODO
 			best_candidate = r.ResolveMember<MethodSpec> (ec, ref args);
 			if (best_candidate == null)
 				return r.BestCandidateIsDynamic ? this 
 
 			// Overload resolver had to create a new method group, all checks bellow have already been executed
 			if (r.BestCandidateNewMethodGroup != null)
 				return r.BestCandidateNewMethodGroup;
 
 			if (best_candidate.Kind == MemberKind.Method && (restr & OverloadResolver.Restrictions.ProbingOnly) == 0) {
 				if (InstanceExpression != null) {
 					if (best_candidate.IsExtensionMethod && args[0].Expr == InstanceExpression) {
 						InstanceExpression = null;
 					} else {
 						if (best_candidate.IsStatic && simple_name != null) {
 							InstanceExpression = ProbeIdenticalTypeName (ec, InstanceExpression, simple_name);
 						}
 
 						InstanceExpression.Resolve (ec);
 					}
 				}
 
 				ResolveInstanceExpression (ec, null);
 				if (InstanceExpression != null)
 					CheckProtectedMemberAccess (ec, best_candidate);
 			}
 
 			var base_override = CandidateToBaseOverride (ec, best_candidate);
 			if (base_override == best_candidate) {
 				best_candidate_return = r.BestCandidateReturnType;
 			} else {
 				best_candidate = base_override;
 				best_candidate_return = best_candidate.ReturnType;
 			}
 
 			return this;
 		}
 
 		public override MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			simple_name = original;
 			return base.ResolveMemberAccess (ec, left, original);
 		}
 
 		public override void SetTypeArguments (ResolveContext ec, TypeArguments ta)
 		{
 			type_arguments = ta;
 		}
 
 		#region IBaseMembersProvider Members
 
 		public virtual IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
 
 		public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			return MemberCache.FindMember (queried_type, new MemberFilter ((MethodSpec) member),
 				BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
 
 		//
 		// Extension methods lookup after ordinary methods candidates failed to apply
 		//
 		public virtual MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			if (InstanceExpression == null)
 				return null;
 
 			InstanceExpression = InstanceExpression.Resolve (rc);
 			if (!IsExtensionMethodArgument (InstanceExpression))
 				return null;
 
 			int arity = type_arguments == null ? 0 
 			NamespaceEntry methods_scope = null;
 			var methods = rc.LookupExtensionMethod (InstanceExpression.Type, Methods[0].Name, arity, ref methods_scope);
 			if (methods == null)
 				return null;
 
 			var emg = new ExtensionMethodGroupExpr (methods, methods_scope, InstanceExpression, loc);
 			emg.SetTypeArguments (rc, type_arguments);
 			return emg;
 		}
 
 		#endregion
 	}
 
 	public struct OverloadResolver
 	{
 		[Flags]
 		public enum Restrictions
 		{
 			None = 0,
 			DelegateInvoke = 1,
 			ProbingOnly	= 1 << 1,
 			CovariantDelegate = 1 << 2,
 			NoBaseMembers = 1 << 3,
 			BaseMembersIncluded = 1 << 4
 		}
 
 		public interface IBaseMembersProvider
 		{
 			IList<MemberSpec> GetBaseMembers (TypeSpec baseType);
 			IParametersMember GetOverrideMemberParameters (MemberSpec member);
 			MethodGroupExpr LookupExtensionMethod (ResolveContext rc);
 		}
 
 		public interface IErrorHandler
 		{
 			bool AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous);
 			bool ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument a, int index);
 			bool NoArgumentMatch (ResolveContext rc, MemberSpec best);
 			bool TypeInferenceFailed (ResolveContext rc, MemberSpec best);
 		}
 
 		sealed class NoBaseMembers 
 		{
 			public static readonly IBaseMembersProvider Instance = new NoBaseMembers ();
 
 			public IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 			{
 				return null;
 			}
 
 			public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 			{
 				return null;
 			}
 
 			public MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 			{
 				return null;
 			}
 		}
 
 		struct AmbiguousCandidate
 		{
 			public readonly MemberSpec Member;
 			public readonly bool Expanded;
 			public readonly AParametersCollection Parameters;
 
 			public AmbiguousCandidate (MemberSpec member, AParametersCollection parameters, bool expanded)
 			{
 				Member = member;
 				Parameters = parameters;
 				Expanded = expanded;
 			}
 		}
 
 		Location loc;
 		IList<MemberSpec> members;
 		TypeArguments type_arguments;
 		IBaseMembersProvider base_provider;
 		IErrorHandler custom_errors;
 		Restrictions restrictions;
 		MethodGroupExpr best_candidate_extension_group;
 		TypeSpec best_candidate_return_type;
 
 		SessionReportPrinter lambda_conv_msgs;
 		ReportPrinter prev_recorder;
 
 		public OverloadResolver (IList<MemberSpec> members, Restrictions restrictions, Location loc)
 			
 		{
 		}
 
 		public OverloadResolver (IList<MemberSpec> members, TypeArguments targs, Restrictions restrictions, Location loc)
 			
 		{
 			if (members == null || members.Count == 0)
 				throw new ArgumentException ("empty members set");
 
 			this.members = members;
 			this.loc = loc;
 			type_arguments = targs;
 			this.restrictions = restrictions;
 			if (IsDelegateInvoke)
 				this.restrictions |= Restrictions.NoBaseMembers;
 
 			base_provider = NoBaseMembers.Instance;
 		}
 
 		#region Properties
 
 		public IBaseMembersProvider BaseMembersProvider {
 			get {
 				return base_provider;
 			}
 			set {
 				base_provider = value;
 			}
 		}
 
 		public bool BestCandidateIsDynamic { get; set; }
 
 		//
 		// Best candidate was found in newly created MethodGroupExpr, used by extension methods
 		//
 		public MethodGroupExpr BestCandidateNewMethodGroup {
 			get {
 				return best_candidate_extension_group;
 			}
 		}
 
 		//
 		// Return type can be different between best candidate and closest override
 		//
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return_type;
 			}
 		}
 
 		public IErrorHandler CustomErrors {
 			get {
 				return custom_errors;
 			}
 			set {
 				custom_errors = value;
 			}
 		}
 
 		TypeSpec DelegateType {
 			get {
 				if ((restrictions & Restrictions.DelegateInvoke) == 0)
 					throw new InternalErrorException ("Not running in delegate mode", loc);
 
 				return members [0].DeclaringType;
 			}
 		}
 
 		bool IsProbingOnly {
 			get {
 				return (restrictions & Restrictions.ProbingOnly) != 0;
 			}
 		}
 
 		bool IsDelegateInvoke {
 			get {
 				return (restrictions & Restrictions.DelegateInvoke) != 0;
 			}
 		}
 
 		#endregion
 
 		//
 		//  7.4.3.3  Better conversion from expression
 		//  Returns 
 		//              2    if a->q is better,
 		//              0 if neither is better
 		//
 		static int BetterExpressionConversion (ResolveContext ec, Argument a, TypeSpec p, TypeSpec q)
 		{
 			TypeSpec argument_type = a.Type;
 
 			//
 			// If argument is an anonymous function
 			//
 			if (argument_type == InternalType.AnonymousMethod && RootContext.Version > LanguageVersion.ISO_2) {
 				//
 				// p and q are delegate types or expression tree types
 				//
 				if (p.GetDefinition () == TypeManager.expression_type || q.GetDefinition () == TypeManager.expression_type) {
 					if (q.MemberDefinition != p.MemberDefinition) {
 						return 0;
 					}
 
 					//
 					// Uwrap delegate from Expression<T>
 					//
 					q = TypeManager.GetTypeArguments (q)[0];
 					p = TypeManager.GetTypeArguments (p)[0];
 				}
 
 				var p_m = Delegate.GetInvokeMethod (ec.Compiler, p);
 				var q_m = Delegate.GetInvokeMethod (ec.Compiler, q);
 
 				//
 				// With identical parameter lists
 				//
 				if (!TypeSpecComparer.Equals (p_m.Parameters.Types,q_m.Parameters.Types))
 					return 0;
 
 				p = p_m.ReturnType;
 				q = q_m.ReturnType;
 
 				//
 				// if p is void returning, and q has a return type Y, then C2 is the better conversion.
 				//
 				if (p == TypeManager.void_type) {
 					return q != TypeManager.void_type ? 2 
 				}
 
 				//
 				// if p has a return type Y, and q is void returning, then C1 is the better conversion.
 				//
 				if (q == TypeManager.void_type) {
 					return p != TypeManager.void_type ? 1
 				}
 			} else {
 				if (argument_type == p)
 					return 1;
 
 				if (argument_type == q)
 					return 2;
 			}
 
 			return BetterTypeConversion (ec, p, q);
 		}
 
 		//
 		// 7.4.3.4  Better conversion from type
 		//
 		public static int BetterTypeConversion (ResolveContext ec, TypeSpec p, TypeSpec q)
 		{
 			if (p == null || q == null)
 				throw new InternalErrorException ("BetterTypeConversion got a null conversion");
 
 			if (p == TypeManager.int32_type) {
 				if (q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.int64_type) {
 				if (q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.sbyte_type) {
 				if (q == TypeManager.byte_type || q == TypeManager.ushort_type ||
 					q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.short_type) {
 				if (q == TypeManager.ushort_type || q == TypeManager.uint32_type ||
 					q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 2;
 			}
 
 			if (q == TypeManager.int32_type) {
 				if (p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.int64_type) {
 				if (p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == TypeManager.sbyte_type) {
 				if (p == TypeManager.byte_type || p == TypeManager.ushort_type ||
 					p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.short_type) {
 				if (p == TypeManager.ushort_type || p == TypeManager.uint32_type ||
 					p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 1;
 			}
 
 			// FIXME
 
 			// TODO
 			Expression p_tmp = new EmptyExpression (p);
 			Expression q_tmp = new EmptyExpression (q);
 
 			bool p_to_q = Convert.ImplicitConversionExists (ec, p_tmp, q);
 			bool q_to_p = Convert.ImplicitConversionExists (ec, q_tmp, p);
 
 			if (p_to_q && !q_to_p)
 				return 1;
 
 			if (q_to_p && !p_to_q)
 				return 2;
 
 			return 0;
 		}
 
 		/// <summary>
 		///   Determines "Better function" between candidate
 		///   and the current best match
 		/// </summary>
 		/// <remarks>
 		///    Returns a boolean indicating 
 		///     false if candidate ain't better
 		///     true  if candidate is better than the current best match
 		/// </remarks>
 		static bool BetterFunction (ResolveContext ec, Arguments args, MemberSpec candidate, AParametersCollection cparam, bool candidate_params,
 			MemberSpec best, AParametersCollection bparam, bool best_params)
 		{
 			AParametersCollection candidate_pd = ((IParametersMember) candidate).Parameters;
 			AParametersCollection best_pd = ((IParametersMember) best).Parameters;
 
 			bool better_at_least_one = false;
 			bool same = true;
 			int args_count = args == null ? 0 
 			int j = 0;
 			Argument a = null;
 			TypeSpec ct, bt;
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 
 			if (better_at_least_one)
 				return true;
 
 			//
 			// This handles the case
 			//
 			//   Add (float f1, float f2, float f3);
 			//   Add (params decimal [] foo);
 			//
 			// The call Add (3, 4, 5) should be ambiguous.  Without this check, the
 			// first candidate would've chosen as better.
 			//
 			if (!same && !a.IsDefaultArgument)
 				return false;
 
 			//
 			// The two methods have equal non-optional parameter types, apply tie-breaking rules
 			//
 
 			//
 			// This handles the following cases
 			//
 			//  Foo (int i) is better than Foo (int i, long l = 0)
 			//  Foo (params int[] args) is better than Foo (int i = 0, params int[] args)
 			//
 			// Prefer non-optional version
 			//
 			// LAMESPEC
 			//
 			if (candidate_params == best_params && candidate_pd.Count != best_pd.Count) {
 				if (candidate_pd.Count >= best_pd.Count)
 					return false;
 
 				if (j < candidate_pd.Count && candidate_pd.FixedParameters[j].HasDefaultValue)
 					return false;
 
 				return true;
 			}
 
 			//
 			// One is a non-generic method and second is a generic method, then non-generic is better
 			//
 			if (best.IsGeneric != candidate.IsGeneric)
 				return best.IsGeneric;
 
 			//
 			// This handles the following cases
 			//
 			//   Trim () is better than Trim (params char[] chars)
 			//   Concat (string s1, string s2, string s3) is better than
 			//     Concat (string s1, params string [] srest)
 			//   Foo (int, params int [] rest) is better than Foo (params int [] rest)
 			//
 			// Prefer non-expanded version
 			//
 			if (candidate_params != best_params)
 				return best_params;
 
 			int candidate_param_count = candidate_pd.Count;
 			int best_param_count = best_pd.Count;
 
 			if (candidate_param_count != best_param_count)
 				// can only happen if (candidate_params && best_params)
 				return candidate_param_count > best_param_count && best_pd.HasParams;
 
 			//
 			// Both methods have the same number of parameters, and the parameters have equal types
 			// Pick the "more specific" signature using rules over original (non-inflated) types
 			//
 			var candidate_def_pd = ((IParametersMember) candidate.MemberDefinition).Parameters;
 			var best_def_pd = ((IParametersMember) best.MemberDefinition).Parameters;
 
 			bool specific_at_least_once = false;
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 
 			if (specific_at_least_once)
 				return true;
 
 			return false;
 		}
 
 		public static void Error_ConstructorMismatch (ResolveContext rc, TypeSpec type, int argCount, Location loc)
 		{
 			rc.Report.Error (1729, loc,
 				"The type `{0}' does not contain a constructor that takes `{1}' arguments",
 				type.GetSignatureForError (), argCount.ToString ());
 		}
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
 
 		//
 		// Tests argument compatibility with the parameter
 		// The possible return values are
 		// 0 - success
 		// 1 - modifier mismatch
 		// 2 - type mismatch
 		// -1 - dynamic binding required
 		//
 		int IsArgumentCompatible (ResolveContext ec, Argument argument, Parameter.Modifier param_mod, TypeSpec parameter)
 		{
 			//
 			// Types have to be identical when ref or out modifer
 			// is used and argument is not of dynamic type
 			//
 			if ((argument.Modifier | param_mod) != 0) {
 				if (argument.Type != parameter) {
 					//
 					// Do full equality check after quick path
 					//
 					if (!TypeSpecComparer.IsEqual (argument.Type, parameter)) {
 						//
 						// Using dynamic for ref/out parameter can still succeed at runtime
 						//
 						if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 							return -1;
 
 						return 2;
 					}
 				}
 
 				if (argument.Modifier != param_mod) {
 					//
 					// Using dynamic for ref/out parameter can still succeed at runtime
 					//
 					if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 						return -1;
 
 					return 1;
 				}
 
 			} else {
 				if (argument.Type == InternalType.Dynamic && (restrictions & Restrictions.CovariantDelegate) == 0)
 					return -1;
 
 				//
 				// Deploy custom error reporting for lambda methods. When probing lambda methods
 				// keep all errors reported in separate set and once we are done and no best
 				// candidate found, this set is used to report more details about what was wrong
 				// with lambda body
 				//
 				if (argument.Expr.Type == InternalType.AnonymousMethod) {
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 				}
 
 				if (!Convert.ImplicitConversionExists (ec, argument.Expr, parameter)) {
 					if (lambda_conv_msgs != null) {
 						lambda_conv_msgs.EndSession ();
 					}
 
 					return 2;
 				}
 			}
 
 			return 0;
 		}
 
 		static TypeSpec MoreSpecific (TypeSpec p, TypeSpec q)
 		{
 			if (TypeManager.IsGenericParameter (p) && !TypeManager.IsGenericParameter (q))
 				return q;
 			if (!TypeManager.IsGenericParameter (p) && TypeManager.IsGenericParameter (q))
 				return p;
 
 			var ac_p = p as ArrayContainer;
 			if (ac_p != null) {
 				var ac_q = ((ArrayContainer) q);
 				TypeSpec specific = MoreSpecific (ac_p.Element, ac_q.Element);
 				if (specific == ac_p.Element)
 					return p;
 				if (specific == ac_q.Element)
 					return q;
 			} else if (TypeManager.IsGenericType (p)) {
 				var pargs = TypeManager.GetTypeArguments (p);
 				var qargs = TypeManager.GetTypeArguments (q);
 
 				bool p_specific_at_least_once = false;
 				bool q_specific_at_least_once = false;
 
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 
 				if (p_specific_at_least_once && !q_specific_at_least_once)
 					return p;
 				if (!p_specific_at_least_once && q_specific_at_least_once)
 					return q;
 			}
 
 			return null;
 		}
 
 		//
 		// Find the best method from candidate list
 		//
 		public T ResolveMember<T> (ResolveContext rc, ref Arguments args) where T 
 		{
 			List<AmbiguousCandidate> ambiguous_candidates = null;
 
 			MemberSpec best_candidate;
 			Arguments best_candidate_args = null;
 			bool best_candidate_params = false;
 			bool best_candidate_dynamic = false;
 			int best_candidate_rate;
 			IParametersMember best_parameter_member = null;
 
 			int args_count = args != null ? args.Count 
 
 			Arguments candidate_args = args;
 			bool error_mode = false;
 			var current_type = rc.CurrentType;
 			MemberSpec invocable_member = null;
 
 			// Be careful, cannot return until error reporter is restored
 			while (true) {
 				best_candidate = null;
 				best_candidate_rate = int.MaxValue;
 
 				var type_members = members;
 				try {
 
 					do {
 						for (int i = 0; i < type_members.Count; ++i) {
 							var member = type_members[i];
 
 							//
 							// Methods in a base class are not candidates if any method in a derived
 							// class is applicable
 							//
 							if ((member.Modifiers & Modifiers.OVERRIDE) != 0)
 								continue;
 
 							if (!error_mode) {
 								if (!member.IsAccessible (current_type))
 									continue;
 
 								if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (current_type))
 									continue;
 							}
 
 							IParametersMember pm = member as IParametersMember;
 							if (pm == null) {
 								//
 								// Will use it later to report ambiguity between best method and invocable member
 								//
 								if (Invocation.IsMemberInvocable (member))
 									invocable_member = member;
 
 								continue;
 							}
 
 							//
 							// Overload resolution is looking for base member but using parameter names
 							// and default values from the closest member. That means to do expensive lookup
 							// for the closest override for virtual or abstract members
 							//
 							if ((member.Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 								var override_params = base_provider.GetOverrideMemberParameters (member);
 								if (override_params != null)
 									pm = override_params;
 							}
 
 							//
 							// Check if the member candidate is applicable
 							//
 							bool params_expanded_form = false;
 							bool dynamic_argument = false;
 							TypeSpec rt = pm.MemberType;
 							int candidate_rate = IsApplicable (rc, ref candidate_args, args_count, ref member, pm, ref params_expanded_form, ref dynamic_argument, ref rt);
 
 							//
 							// How does it score compare to others
 							//
 							if (candidate_rate < best_candidate_rate) {
 								best_candidate_rate = candidate_rate;
 								best_candidate = member;
 								best_candidate_args = candidate_args;
 								best_candidate_params = params_expanded_form;
 								best_candidate_dynamic = dynamic_argument;
 								best_parameter_member = pm;
 								best_candidate_return_type = rt;
 							} else if (candidate_rate == 0) {
 								//
 								// The member look is done per type for most operations but sometimes
 								// it's not possible like for binary operators overload because they
 								// are unioned between 2 sides
 								//
 								if ((restrictions & Restrictions.BaseMembersIncluded) != 0) {
 									if (TypeSpec.IsBaseClass (best_candidate.DeclaringType, member.DeclaringType, true))
 										continue;
 								}
 
 								bool is_better;
 								if (best_candidate.DeclaringType.IsInterface && member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 									//
 									// We pack all interface members into top level type which makes the overload resolution
 									// more complicated for interfaces. We accomodate for this by removing methods with same
 									// signature when building the cache hence this path should not really be hit often
 									//
 									// Example
 									// interface IA { void Foo (int arg); }
 									// interface IB 
 									//
 									// IB
 									//
 									is_better = true;
 									if (ambiguous_candidates != null) {
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										}
 
 										if (is_better)
 											ambiguous_candidates = null;
 									}
 								} else {
 									// Is the new candidate better
 									is_better = BetterFunction (rc, candidate_args, member, pm.Parameters, params_expanded_form, best_candidate, best_parameter_member.Parameters, best_candidate_params);
 								}
 
 								if (is_better) {
 									best_candidate = member;
 									best_candidate_args = candidate_args;
 									best_candidate_params = params_expanded_form;
 									best_candidate_dynamic = dynamic_argument;
 									best_parameter_member = pm;
 									best_candidate_return_type = rt;
 								} else {
 									// It's not better but any other found later could be but we are not sure yet
 									if (ambiguous_candidates == null)
 										ambiguous_candidates = new List<AmbiguousCandidate> ();
 
 									ambiguous_candidates.Add (new AmbiguousCandidate (member, pm.Parameters, params_expanded_form));
 								}
 							}
 
 							// Restore expanded arguments
 							if (candidate_args != args)
 								candidate_args = args;
 						}
 					} while (best_candidate_rate != 0 && (type_members = base_provider.GetBaseMembers (type_members[0].DeclaringType.BaseType)) != null);
 				} finally {
 					if (prev_recorder != null)
 						rc.Report.SetPrinter (prev_recorder);
 				}
 
 				//
 				// We've found exact match
 				//
 				if (best_candidate_rate == 0)
 					break;
 
 				//
 				// Try extension methods lookup when no ordinary method match was found and provider enables it
 				//
 				if (!error_mode) {
 					var emg = base_provider.LookupExtensionMethod (rc);
 					if (emg != null) {
 						emg = emg.OverloadResolve (rc, ref args, null, restrictions);
 						if (emg != null) {
 							best_candidate_extension_group = emg;
 							return (T) (MemberSpec) emg.BestCandidate;
 						}
 					}
 				}
 
 				// Don't run expensive error reporting mode for probing
 				if (IsProbingOnly)
 					return null;
 
 				if (error_mode)
 					break;
 
 				lambda_conv_msgs = null;
 				error_mode = true;
 			}
 
 			//
 			// No best member match found, report an error
 			//
 			if (best_candidate_rate != 0 || error_mode) {
 				ReportOverloadError (rc, best_candidate, best_parameter_member, best_candidate_args, best_candidate_params);
 				return null;
 			}
 
 			if (best_candidate_dynamic) {
 				if (args[0].ArgType == Argument.AType.ExtensionType) {
 					rc.Report.Error (1973, loc,
 						"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' cannot be dynamically dispatched. Consider calling the method without the extension method syntax",
 						args [0].Type.GetSignatureForError (), best_candidate.Name, best_candidate.GetSignatureForError ());
 				}
 
 				BestCandidateIsDynamic = true;
 				return null;
 			}
 
 			if (ambiguous_candidates != null) {
 				//
 				// Now check that there are no ambiguities i.e the selected method
 				// should be better than all the others
 				//
 				for (int ix = 0; ix < ambiguous_candidates.Count; ix++) {
 					var candidate = ambiguous_candidates [ix];
 
 					if (!BetterFunction (rc, best_candidate_args, best_candidate, best_parameter_member.Parameters, best_candidate_params, candidate.Member, candidate.Parameters, candidate.Expanded)) {
 						var ambiguous = candidate.Member;
 						if (custom_errors == null || !custom_errors.AmbiguousCandidates (rc, best_candidate, ambiguous)) {
 							rc.Report.SymbolRelatedToPreviousError (best_candidate);
 							rc.Report.SymbolRelatedToPreviousError (ambiguous);
 							rc.Report.Error (121, loc, "The call is ambiguous between the following methods or properties
 								best_candidate.GetSignatureForError (), ambiguous.GetSignatureForError ());
 						}
 
 						return (T) best_candidate;
 					}
 				}
 			}
 
 			if (invocable_member != null) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.SymbolRelatedToPreviousError (invocable_member);
 				rc.Report.Warning (467, 2, loc, "Ambiguity between method `{0}' and invocable non-method `{1}'. Using method group",
 					best_candidate.GetSignatureForError (), invocable_member.GetSignatureForError ());
 			}
 
 			//
 			// And now check if the arguments are all
 			// compatible, perform conversions if
 			// necessary etc. and return if everything is
 			// all right
 			//
 			if (!VerifyArguments (rc, ref best_candidate_args, best_candidate, best_parameter_member, best_candidate_params))
 				return null;
 
 			if (best_candidate == null)
 				return null;
 
 			//
 			// Check ObsoleteAttribute on the best method
 			//
 			ObsoleteAttribute oa = best_candidate.GetAttributeObsolete ();
 			if (oa != null && !rc.IsObsolete)
 				AttributeTester.Report_ObsoleteMessage (oa, best_candidate.GetSignatureForError (), loc, rc.Report);
 
 			var dep = best_candidate.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			best_candidate.MemberDefinition.SetIsUsed ();
 
 			args = best_candidate_args;
 			return (T) best_candidate;
 		}
 
 		public MethodSpec ResolveOperator (ResolveContext rc, ref Arguments args)
 		{
 			return ResolveMember<MethodSpec> (rc, ref args);
 		}
 
 		void ReportArgumentMismatch (ResolveContext ec, int idx, MemberSpec method,
 													Argument a, AParametersCollection expected_par, TypeSpec paramType)
 		{
 			if (custom_errors != null && custom_errors.ArgumentMismatch (ec, method, a, idx))
 				return;
 
 			if (a is CollectionElementInitializer.ElementInitializerArgument) {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				if ((expected_par.FixedParameters[idx].ModFlags & Parameter.Modifier.ISBYREF) != 0) {
 					ec.Report.Error (1954, loc, "The best overloaded collection initalizer method `{0}' cannot have 'ref', or `out' modifier",
 						TypeManager.CSharpSignature (method));
 					return;
 				}
 				ec.Report.Error (1950, loc, "The best overloaded collection initalizer method `{0}' has some invalid arguments",
 					  TypeManager.CSharpSignature (method));
 			} else if (IsDelegateInvoke) {
 				ec.Report.Error (1594, loc, "Delegate `{0}' has some invalid arguments",
 					DelegateType.GetSignatureForError ());
 			} else {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				ec.Report.Error (1502, loc, "The best overloaded method match for `{0}' has some invalid arguments",
 					method.GetSignatureForError ());
 			}
 
 			Parameter.Modifier mod = idx >= expected_par.Count ? 0 
 
 			string index = (idx + 1).ToString ();
 			if (((mod & (Parameter.Modifier.REF | Parameter.Modifier.OUT)) ^
 				(a.Modifier & (Parameter.Modifier.REF | Parameter.Modifier.OUT))) != 0) {
 				if ((mod & Parameter.Modifier.ISBYREF) == 0)
 					ec.Report.Error (1615, loc, "Argument `#{0}' does not require `{1}' modifier. Consider removing `{1}' modifier",
 						index, Parameter.GetModifierSignature (a.Modifier));
 				else
 					ec.Report.Error (1620, loc, "Argument `#{0}' is missing `{1}' modifier",
 						index, Parameter.GetModifierSignature (mod));
 			} else {
 				string p1 = a.GetSignatureForError ();
 				string p2 = TypeManager.CSharpName (paramType);
 
 				if (p1 == p2) {
 					ec.Report.ExtraInformation (loc, "(equally named types possibly from different assemblies in previous ");
 					ec.Report.SymbolRelatedToPreviousError (a.Expr.Type);
 					ec.Report.SymbolRelatedToPreviousError (paramType);
 				}
 
 				ec.Report.Error (1503, loc,
 					"Argument `#{0}' cannot convert `{1}' expression to type `{2}'", index, p1, p2);
 			}
 		}
 
 		//
 		// We have failed to find exact match so we return error info about the closest match
 		//
 		void ReportOverloadError (ResolveContext rc, MemberSpec best_candidate, IParametersMember pm, Arguments args, bool params_expanded)
 		{
 			int ta_count = type_arguments == null ? 0 
 			int arg_count = args == null ? 0 
 
 			if (ta_count != best_candidate.Arity && (ta_count > 0 || ((IParametersMember) best_candidate).Parameters.IsEmpty)) {
 				var mg = new MethodGroupExpr (new [] { best_candidate }, best_candidate.DeclaringType, loc);
 				mg.Error_TypeArgumentsCannotBeUsed (rc.Report, loc, best_candidate, ta_count);
 				return;
 			}
 
 			if (lambda_conv_msgs != null) {
 				if (lambda_conv_msgs.Merge (rc.Report.Printer))
 					return;
 			}
 
 			//
 			// For candidates which match on parameters count report more details about incorrect arguments
 			//
 			if (pm != null) {
 				int unexpanded_count = ((IParametersMember) best_candidate).Parameters.HasParams ? pm.Parameters.Count - 1 
 				if (pm.Parameters.Count == arg_count || params_expanded || unexpanded_count == arg_count) {
 					// Reject any inaccessible member
 					if (!best_candidate.IsAccessible (rc.CurrentType) || !best_candidate.DeclaringType.IsAccessible (rc.CurrentType)) {
 						rc.Report.SymbolRelatedToPreviousError (best_candidate);
 						Expression.ErrorIsInaccesible (rc, best_candidate.GetSignatureForError (), loc);
 						return;
 					}
 
 					var ms = best_candidate as MethodSpec;
 					if (ms != null && ms.IsGeneric) {
 						bool constr_ok = true;
 						if (ms.TypeArguments != null)
 							constr_ok = new ConstraintChecker (rc.MemberContext).CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc);
 
 						if (ta_count == 0) {
 							if (custom_errors != null && custom_errors.TypeInferenceFailed (rc, best_candidate))
 								return;
 
 							if (constr_ok) {
 								rc.Report.Error (411, loc,
 									"The type arguments for method `{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly",
 									ms.GetGenericMethodDefinition ().GetSignatureForError ());
 							}
 
 							return;
 						}
 					}
 
 					VerifyArguments (rc, ref args, best_candidate, pm, params_expanded);
 					return;
 				}
 			}
 
 			//
 			// We failed to find any method with correct argument count, report best candidate
 			//
 			if (custom_errors != null && custom_errors.NoArgumentMatch (rc, best_candidate))
 				return;
 
 			if (best_candidate.Kind == MemberKind.Constructor) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				Error_ConstructorMismatch (rc, best_candidate.DeclaringType, arg_count, loc);
 			} else if (IsDelegateInvoke) {
 				rc.Report.SymbolRelatedToPreviousError (DelegateType);
 				rc.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					DelegateType.GetSignatureForError (), arg_count.ToString ());
 			} else {
 				string name = best_candidate.Kind == MemberKind.Indexer ? "this" 
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.Error (1501, loc, "No overload for method `{0}' takes `{1}' arguments",
 					name, arg_count.ToString ());
 			}
 		}
 
 		bool VerifyArguments (ResolveContext ec, ref Arguments args, MemberSpec member, IParametersMember pm, bool chose_params_expanded)
 		{
 			var pd = pm.Parameters;
 			TypeSpec[] ptypes = ((IParametersMember) member).Parameters.Types;
 
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 			int a_idx = 0, a_pos = 0;
 			Argument a = null;
 			ArrayInitializer params_initializers = null;
 			bool has_unsafe_arg = pm.MemberType.IsPointer;
 			int arg_count = args == null ? 0 
 
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 
 			if (a_idx != arg_count) {
 				ReportArgumentMismatch (ec, a_pos, member, a, pd, pt);
 				return false;
 			}
 
 			//
 			// Fill not provided arguments required by params modifier
 			//
 			if (params_initializers == null && pd.HasParams && arg_count + 1 == pd.Count) {
 				if (args == null)
 					args = new Arguments (1);
 
 				pt = ptypes[pd.Count - 1];
 				pt = TypeManager.GetElementType (pt);
 				has_unsafe_arg |= pt.IsPointer;
 				params_initializers = new ArrayInitializer (0, loc);
 			}
 
 			//
 			// Append an array argument with all params arguments
 			//
 			if (params_initializers != null) {
 				args.Add (new Argument (
 					new ArrayCreation (new TypeExpression (pt, loc), params_initializers, loc).Resolve (ec)));
 				arg_count++;
 			}
 
 			if (has_unsafe_arg && !ec.IsUnsafe) {
 				Expression.UnsafeError (ec, loc);
 			}
 
 			//
 			// We could infer inaccesible type arguments
 			//
 			if (type_arguments == null && member.IsGeneric) {
 				var ms = (MethodSpec) member;
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 			}
 
 			return true;
 		}
 	}
 
 	public class ConstantExpr 
 	{
 		ConstSpec constant;
 
 		public ConstantExpr (ConstSpec constant, Location loc)
 		{
 			this.constant = constant;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="63" endline="276">
<![CDATA[
 
 		protected FieldBase (DeclSpace parent, FullNamedExpression type, Modifiers mod,
 				     Modifiers allowed_mod, MemberName name, Attributes attrs)
 			
 				name, attrs)
 		{
 			if ((mod & Modifiers.ABSTRACT) != 0)
 				Report.Error (681, Location, "The modifier 'abstract' is not valid on fields. Try using a property instead");
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Field;
 			}
 		}
 
 		public Expression Initializer {
 			get {
 				return initializer;
 			}
 			set {
 				this.initializer = value;
 			}
 		}
 
 		public FieldSpec Spec {
 			get {
 				return spec;
 			}
 		}
 
 		public override string[] ValidAttributeTargets  {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.FieldOffset) {
 				status |= Status.HAS_OFFSET;
 
 				if (!Parent.PartialContainer.HasExplicitLayout) {
 					Report.Error (636, Location, "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)");
 					return;
 				}
 
 				if ((ModFlags & Modifiers.STATIC) != 0 || this is Const) {
 					Report.Error (637, Location, "The FieldOffset attribute is not allowed on static or const fields");
 					return;
 				}
 			}
 
 			if (a.Type == pa.FixedBuffer) {
 				Report.Error (1716, Location, "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead");
 				return;
 			}
 
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					FieldBuilder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public void SetCustomAttribute (MethodSpec ctor, byte[] data)
 		{
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), data);
 		}
 
  		protected override bool CheckBase ()
 		{
  			if (!base.CheckBase ())
  				return false;
 
 			MemberSpec candidate;
 			var conflict_symbol = MemberCache.FindBaseMember (this, out candidate);
 			if (conflict_symbol == null)
 				conflict_symbol = candidate;
 
  			if (conflict_symbol == null) {
  				if ((ModFlags & Modifiers.NEW) != 0) {
  					Report.Warning (109, 4, Location, "The member `{0}' does not hide an inherited member. The new keyword is not required",
 						GetSignatureForError ());
  				}
  			} else {
 				if ((ModFlags & (Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.BACKING_FIELD)) == 0) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Warning (108, 2, Location, "`{0}' hides inherited member `{1}'. Use the new keyword if hiding was intended",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 
 				if (conflict_symbol.IsAbstract) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Error (533, Location, "`{0}' hides inherited abstract member `{1}'",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 			}
  
  			return true;
  		}
 
 		public virtual Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ConvertImplicitly (rc, MemberType);
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsGenericParameter)
 				return;
 
 			if (MemberType.IsStatic)
 				Error_VariableOfStaticClass (Location, GetSignatureForError (), MemberType, Report);
 
 			CheckBase ();
 			IsTypePermitted ();
 		}
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { return "F
 		}
 
 		public override void Emit ()
 		{
 			if (member_type == InternalType.Dynamic) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder);
 			} else if (!(Parent is CompilerGeneratedClass) && member_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder, member_type, Location);
 			}
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (FieldBuilder);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			if (((status & Status.HAS_OFFSET) == 0) && (ModFlags & (Modifiers.STATIC | Modifiers.BACKING_FIELD)) == 0 && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (625, Location, "`{0}'
 			}
 
 			base.Emit ();
 		}
 
 		public static void Error_VariableOfStaticClass (Location loc, string variable_name, TypeSpec static_class, Report Report)
 		{
 			Report.SymbolRelatedToPreviousError (static_class);
 			Report.Error (723, loc, "`{0}'
 				variable_name);
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant () || this is FixedField) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
 	}
 
 	//
 	// Field specification
 	//
 	public class FieldSpec 
 	{
 		FieldInfo metaInfo;
 		TypeSpec memberType;
 
 		public FieldSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, FieldInfo info, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.memberType = memberType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="44" endline="253">
<![CDATA[
 
 		bool is_double_colon;
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    TypeArguments args, Location loc)
 			
 		{
 			if (args != null && args.Count > 0)
 				this.TypeArguments = args;
 		}
 
 		public MemberName (string name)
 			
 		{ }
 
 		public MemberName (string name, Location loc)
 			
 		{ }
 
 		public MemberName (string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (string alias, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right, Location loc)
 			
 		{
 			if (right.is_double_colon)
 				throw new InternalErrorException ("Cannot append double_colon member name");
 			this.Left = (right.Left == null) ? left 
 		}
 
 		// TODO
 		public string GetName ()
 		{
 			return GetName (false);
 		}
 
 		public int Arity {
 			get {
 				return TypeArguments == null ? 0 
 			}
 		}
 
 		public bool IsGeneric {
 			get {
 				if (TypeArguments != null)
 					return true;
 				else if (Left != null)
 					return Left.IsGeneric;
 				else
 					return false;
 			}
 		}
 
 		public string GetName (bool is_generic)
 		{
 			string name = is_generic ? Basename 
 			if (Left != null)
 				return Left.GetName (is_generic) + (is_double_colon ? "
 
 			return name;
 		}
 
 		public ATypeNameExpression GetTypeExpression ()
 		{
 			if (Left == null) {
 				if (TypeArguments != null)
 					return new SimpleName (Name, TypeArguments, Location);
 				
 				return new SimpleName (Name, Location);
 			}
 
 			if (is_double_colon) {
 				if (Left.Left != null)
 					throw new InternalErrorException ("The left side of a 
 				return new QualifiedAliasMember (Left.Name, Name, TypeArguments, Location);
 			}
 
 			Expression lexpr = Left.GetTypeExpression ();
 			return new MemberAccess (lexpr, Name, TypeArguments, Location);
 		}
 
 		public MemberName Clone ()
 		{
 			MemberName left_clone = Left == null ? null 
 			return new MemberName (left_clone, Name, is_double_colon, TypeArguments, Location);
 		}
 
 		public string Basename {
 			get {
 				if (TypeArguments != null)
 					return MakeName (Name, TypeArguments);
 				return Name;
 			}
 		}
 
 		public string GetSignatureForError ()
 		{
 			string append = TypeArguments == null ? "" 
 			if (Left == null)
 				return Name + append;
 			string connect = is_double_colon ? "
 			return Left.GetSignatureForError () + connect + Name + append;
 		}
 
 		public override bool Equals (object other)
 		{
 			return Equals (other as MemberName);
 		}
 
 		public bool Equals (MemberName other)
 		{
 			if (this == other)
 				return true;
 			if (other == null || Name != other.Name)
 				return false;
 			if (is_double_colon != other.is_double_colon)
 				return false;
 
 			if ((TypeArguments != null) &&
 			    (other.TypeArguments == null || TypeArguments.Count != other.TypeArguments.Count))
 				return false;
 
 			if ((TypeArguments == null) && (other.TypeArguments != null))
 				return false;
 
 			if (Left == null)
 				return other.Left == null;
 
 			return Left.Equals (other.Left);
 		}
 
 		public override int GetHashCode ()
 		{
 			int hash = Name.GetHashCode ();
 			for (MemberName n = Left; n != null; n = n.Left)
 				hash ^= n.Name.GetHashCode ();
 			if (is_double_colon)
 				hash ^= 0xbadc01d;
 
 			if (TypeArguments != null)
 				hash ^= TypeArguments.Count << 5;
 
 			return hash & 0x7FFFFFFF;
 		}
 
 		public int CountTypeArguments {
 			get {
 				if (TypeArguments != null)
 					return TypeArguments.Count;
 				else if (Left != null)
 					return Left.CountTypeArguments; 
 				else
 					return 0;
 			}
 		}
 
 		public static string MakeName (string name, TypeArguments args)
 		{
 			if (args == null)
 				return name;
 
 			return name + "`" + args.Count;
 		}
 
 		public static string MakeName (string name, int count)
 		{
 			return name + "`" + count;
 		}
 	}
 
 	public class SimpleMemberName
 	{
 		public string Value;
 		public Location Location;
 
 		public SimpleMemberName (string name, Location loc)
 		{
 			this.Value = name;
 			this.Location = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7619" endline="7794">
<![CDATA[
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			var sn = expr as SimpleName;
 			const ResolveFlags flags = ResolveFlags.VariableOrValue | ResolveFlags.Type;
 
 			//
 			// Resolve the expression with flow analysis turned off, we'll do the definite
 			// assignment checks later.  This is because we don't know yet what the expression
 			// will resolve to - it may resolve to a FieldExpr and in this case we must do the
 			// definite assignment check on the actual field and not on the whole struct.
 			//
 			using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 				if (sn != null) {
 					expr = sn.LookupNameExpression (rc, MemberLookupRestrictions.ReadAccess | MemberLookupRestrictions.ExactArity);
 
 					// Call resolve on expression which does have type set as we need expression type
 					// TODO
 					if (expr is VariableReference || expr is ConstantExpr || expr is Linq.TransparentMemberAccess) {
 						using (rc.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 							expr = expr.Resolve (rc);
 						}
 					} else if (expr is TypeParameterExpr) {
 						expr.Error_UnexpectedKind (rc, flags, sn.Location);
 						expr = null;
 					}
 				} else {
 					expr = expr.Resolve (rc, flags);
 				}
 			}
 
 			if (expr == null)
 				return null;
 
 			Namespace ns = expr as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 					return null;
 				}
 
 				if (HasTypeArguments)
 					return new GenericTypeExpr (retval.Type, targs, loc);
 
 				return retval;
 			}
 
 			MemberExpr me;
 			TypeSpec expr_type = expr.Type;
 			if (expr_type == InternalType.Dynamic) {
 				me = expr as MemberExpr;
 				if (me != null)
 					me.ResolveInstanceExpression (rc, null);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new DynamicMemberBinder (Name, args, loc);
 			}
 
 			const MemberKind dot_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.Delegate | MemberKind.Enum |
 				MemberKind.Interface | MemberKind.TypeParameter | MemberKind.ArrayType;
 
 			if ((expr_type.Kind & dot_kinds) == 0 || expr_type == TypeManager.void_type) {
 				if (expr_type == InternalType.Null && rc.Compiler.IsRuntimeBinder)
 					rc.Report.Error (Report.RuntimeErrorId, loc, "Cannot perform member binding on `null' value");
 				else
 					Unary.Error_OperatorCannotBeApplied (rc, loc, ".", expr_type);
 				return null;
 			}
 
 			var current_type = rc.CurrentType;
 			var lookup_arity = Arity;
 			bool errorMode = false;
 			Expression member_lookup;
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 
 			TypeExpr texpr = member_lookup as TypeExpr;
 			if (texpr != null) {
 				if (!(expr is TypeExpr)) {
 					me = expr as MemberExpr;
 					if (me == null || me.ProbeIdenticalTypeName (rc, expr, sn) == expr) {
 						rc.Report.Error (572, loc, "`{0}'
 							Name, member_lookup.GetSignatureForError ());
 						return null;
 					}
 				}
 
 				if (!texpr.Type.IsAccessible (rc.CurrentType)) {
 					rc.Report.SymbolRelatedToPreviousError (member_lookup.Type);
 					ErrorIsInaccesible (rc, member_lookup.Type.GetSignatureForError (), loc);
 					return null;
 				}
 
 				if (HasTypeArguments) {
 					return new GenericTypeExpr (member_lookup.Type, targs, loc);
 				}
 
 				return member_lookup;
 			}
 
 			me = member_lookup as MemberExpr;
 
 			if (sn != null && me.IsStatic)
 				expr = me.ProbeIdenticalTypeName (rc, expr, sn);
 
 			me = me.ResolveMemberAccess (rc, expr, sn);
 
 			if (Arity > 0) {
 				if (!targs.Resolve (rc))
 					return null;
 
 				me.SetTypeArguments (rc, targs);
 			}
 
 			if (sn != null && (!TypeManager.IsValueType (expr_type) || me is PropertyExpr)) {
 				if (me.IsInstance) {
 					LocalVariableReference var = expr as LocalVariableReference;
 					if (var != null && !var.VerifyAssigned (rc))
 						return null;
 				}
 			}
 
 			return me;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="459" endline="736">
<![CDATA[
 	}
 
 	public abstract class MethodOrOperator 
 	{
 		public MethodBuilder MethodBuilder;
 		ReturnParameter return_attributes;
 		SecurityType declarative_security;
 		protected MethodData MethodData;
 
 		static string[] attribute_targets = new string [] { "method", "return" };
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Method; 
 			}
 		}
 
 		protected override bool CheckForDuplications ()
 		{
 			return Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 		}
 
 		public virtual EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, MemberType);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
 
 		public bool IsPartialDefinition {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block == null;
 			}
 		}
 
 		public bool IsPartialImplementation {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block != null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#region IMethodData Members
 
 		public TypeSpec ReturnType {
 			get {
 				return MemberType;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return GenericMethod;
 			}
 		}
 
 		public virtual void EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 
 		#endregion
 
 	}
 
 	public class SourceMethod 
 	{
 		MethodBase method;
 		SourceMethodBuilder builder;
 
 		protected SourceMethod (DeclSpace parent, MethodBase method, ICompileUnit file)
 		{
 			this.method = method;
 			
 			builder = SymbolWriter.OpenMethod (file, parent.NamespaceEntry.SymbolFileID, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="96" endline="381">
<![CDATA[
 
 		// <summary>
 		//   The type of this flow branching.
 		// </summary>
 		public readonly BranchingType Type;
 
 		// <summary>
 		//   The block this branching is contained in.  This may be null if it's not
 		//   a top-level block and it doesn't declare any local variables.
 		// </summary>
 		public readonly Block Block;
 
 		// <summary>
 		//   The parent of this branching or null if this is the top-block.
 		// </summary>
 		public readonly FlowBranching Parent;
 
 		// <summary>
 		//   Start-Location of this flow branching.
 		// </summary>
 		public readonly Location Location;
 
 		static int next_id = 0;
 		int id;
 
 		// <summary>
 		//   The vector contains a BitArray with information about which local variables
 		//   and parameters are already initialized at the current code position.
 		// </summary>
 		public class UsageVector {
 			// <summary>
 			//   The type of this branching.
 			// </summary>
 			public readonly SiblingType Type;
 
 			// <summary>
 			//   Start location of this branching.
 			// </summary>
 			public Location Location;
 
 			// <summary>
 			//   This is only valid for SwitchSection, Try, Catch and Finally.
 			// </summary>
 			public readonly Block Block;
 
 			// <summary>
 			//   The number of locals in this block.
 			// </summary>
 			public readonly int CountLocals;
 
 			// <summary>
 			//   If not null, then we inherit our state from this vector and do a
 			//   copy-on-write.  If null, then we're the first sibling in a top-level
 			//   block and inherit from the empty vector.
 			// </summary>
 			public readonly UsageVector InheritsFrom;
 
 			// <summary>
 			//   This is used to construct a list of UsageVector's.
 			// </summary>
 			public UsageVector Next;
 
 			//
 			// Private.
 			//
 			MyBitVector locals;
 			bool is_unreachable;
 
 			static int next_id = 0;
 			int id;
 
 			//
 			// Normally, you should not use any of these constructors.
 			//
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc, int num_locals)
 			{
 				this.Type = type;
 				this.Block = block;
 				this.Location = loc;
 				this.InheritsFrom = parent;
 				this.CountLocals = num_locals;
 
 				locals = num_locals == 0 
 					? MyBitVector.Empty
 					
 
 				if (parent != null)
 					is_unreachable = parent.is_unreachable;
 
 				id = ++next_id;
 
 			}
 
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc)
 				
 			{ }
 
 			private UsageVector (MyBitVector locals, bool is_unreachable, Block block, Location loc)
 			{
 				this.Type = SiblingType.Block;
 				this.Location = loc;
 				this.Block = block;
 
 				this.is_unreachable = is_unreachable;
 
 				this.locals = locals;
 
 				id = ++next_id;
 
 			}
 
 			// <summary>
 			//   This does a deep copy of the usage vector.
 			// </summary>
 			public UsageVector Clone ()
 			{
 				UsageVector retval = new UsageVector (Type, null, Block, Location, CountLocals);
 
 				retval.locals = locals.Clone ();
 				retval.is_unreachable = is_unreachable;
 
 				return retval;
 			}
 
 			public bool IsAssigned (VariableInfo var, bool ignoreReachability)
 			{
 				if (!ignoreReachability && !var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsAssigned (locals);
 			}
 
 			public void SetAssigned (VariableInfo var)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetAssigned (locals);
 			}
 
 			public bool IsFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsFieldAssigned (locals, name);
 			}
 
 			public void SetFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetFieldAssigned (locals, name);
 			}
 
 			public bool IsUnreachable {
 				get { return is_unreachable; }
 			}
 
 			public void ResetBarrier ()
 			{
 				is_unreachable = false;
 			}
 
 			public void Goto ()
 			{
 				is_unreachable = true;
 			}
 
 			public static UsageVector MergeSiblings (UsageVector sibling_list, Location loc)
 			{
 				if (sibling_list.Next == null)
 					return sibling_list;
 
 				MyBitVector locals = null;
 				bool is_unreachable = sibling_list.is_unreachable;
 
 				if (!sibling_list.IsUnreachable)
 					locals &= sibling_list.locals;
 
 				for (UsageVector child = sibling_list.Next; child != null; child = child.Next) {
 					is_unreachable &= child.is_unreachable;
 
 					if (!child.IsUnreachable)
 						locals &= child.locals;
 				}
 
 				return new UsageVector (locals, is_unreachable, null, loc);
 			}
 
 			// <summary>
 			//   Merges a child branching.
 			// </summary>
 			public UsageVector MergeChild (UsageVector child, bool overwrite)
 			{
 				Report.Debug (2, "    MERGING CHILD EFFECTS", this, child, Type);
 
 				bool new_isunr = child.is_unreachable;
 
 				//
 				// We've now either reached the point after the branching or we will
 				// never get there since we always return or always throw an exception.
 				//
 				// If we can reach the point after the branching, mark all locals and
 				// parameters as initialized which have been initialized in all branches
 				// we need to look at (see above).
 				//
 
 				if ((Type == SiblingType.SwitchSection) && !new_isunr) {
 					Report.Error (163, Location,
 						      "Control cannot fall through from one " +
 						      "case label to another");
 					return child;
 				}
 
 				locals |= child.locals;
 
 				// throw away un-necessary information about variables in child blocks
 				if (locals.Count != CountLocals)
 					locals = new MyBitVector (locals, CountLocals);
 
 				if (overwrite)
 					is_unreachable = new_isunr;
 				else
 					is_unreachable |= new_isunr;
 
 				return child;
 			}
 
 			public void MergeOrigins (UsageVector o_vectors)
 			{
 				Report.Debug (1, "  MERGING BREAK ORIGINS", this);
 
 				if (o_vectors == null)
 					return;
 
 				if (IsUnreachable && locals != null)
 					locals.SetAll (true);
 
 				for (UsageVector vector = o_vectors; vector != null; vector = vector.Next) {
 					Report.Debug (1, "    MERGING BREAK ORIGIN", vector);
 					if (vector.IsUnreachable)
 						continue;
 					locals &= vector.locals;
 					is_unreachable &= vector.is_unreachable;
 				}
 
 				Report.Debug (1, "  MERGING BREAK ORIGINS DONE", this);
 			}
 
 			//
 			// Debugging stuff.
 			//
 
 			public override string ToString ()
 			{
 				return String.Format ("Vector ({0},{1},{2}-{3})", Type, id, is_unreachable, locals);
 			}
 		}
 
 		// <summary>
 		//   Creates a new flow branching which is contained in `parent'.
 		//   You should only pass non-null for the `block' argument if this block
 		//   introduces any new variables - in this case, we need to create a new
 		//   usage vector with a different size than our parent's one.
 		// </summary>
 		protected FlowBranching (FlowBranching parent, BranchingType type, SiblingType stype,
 					 Block block, Location loc)
 		{
 			Parent = parent;
 			Block = block;
 			Location = loc;
 			Type = type;
 			id = ++next_id;
 
 			UsageVector vector;
 			if (Block != null) {
 				UsageVector parent_vector = parent != null ? parent.CurrentUsageVector 
 				vector = new UsageVector (stype, parent_vector, Block, loc, Block.AssignableSlots);
 			} else {
 				vector = new UsageVector (stype, Parent.CurrentUsageVector, null, loc);
 			}
 
 			AddSibling (vector);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="186" endline="476">
<![CDATA[
 	}
 
 	public interface IGenericMethodDefinition 
 	{
 		TypeParameterSpec[] TypeParameters { get; }
 		int TypeParametersCount { get; }
 
 //		MethodInfo MakeGenericMethod (TypeSpec[] targs);
 	}
 
 	public sealed class MethodSpec 
 	{
 		MethodBase metaInfo, inflatedMetaInfo;
 		AParametersCollection parameters;
 		TypeSpec returnType;
 
 		TypeSpec[] targs;
 		TypeParameterSpec[] constraints;
 
 		public MethodSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition details, TypeSpec returnType,
 			MethodBase info, AParametersCollection parameters, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.parameters = parameters;
 			this.returnType = returnType;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return IsGeneric ? GenericDefinition.TypeParametersCount 
 			}
 		}
 
 		public TypeParameterSpec[] Constraints {
 			get {
 				if (constraints == null && IsGeneric)
 					constraints = GenericDefinition.TypeParameters;
 
 				return constraints;
 			}
 		}
 
 		public bool IsConstructor {
 			get {
 				return Kind == MemberKind.Constructor;
 			}
 		}
 
 		public IGenericMethodDefinition GenericDefinition {
 			get {
 				return (IGenericMethodDefinition) definition;
 			}
 		}
 
 		public bool IsExtensionMethod {
 			get {
 				return IsStatic && parameters.HasExtensionMethodType;
 			}
 		}
 
 		public bool IsSealed {
 			get {
 				return (Modifiers & Modifiers.SEALED) != 0;
 			}
 		}
 
 		// When is virtual or abstract
 		public bool IsVirtual {
 			get {
 				return (Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE)) != 0;
 			}
 		}
 
 		public bool IsReservedMethod {
 			get {
 				return Kind == MemberKind.Operator || IsAccessor;
 			}
 		}
 
 		TypeSpec IInterfaceMemberSpec.MemberType {
 			get {
 				return returnType;
 			}
 		}
 
 		public AParametersCollection Parameters {
 			get { 
 				return parameters;
 			}
 		}
 
 		public TypeSpec ReturnType {
 			get {
 				return returnType;
 			}
 		}
 
 		public TypeSpec[] TypeArguments {
 			get {
 				return targs;
 			}
 		}
 
 		#endregion
 
 		public MethodSpec GetGenericMethodDefinition ()
 		{
 			if (!IsGeneric && !DeclaringType.IsGeneric)
 				return this;
 
 			return MemberCache.GetMember (declaringType, this);
 		}
 
 		public MethodBase GetMetaInfo ()
 		{
 			//
 			// inflatedMetaInfo is extra field needed for cases where we
 			// inflate method but another nested type can later inflate
 			// again (the cache would be build with inflated metaInfo) and
 			// TypeBuilder can work with method definitions only
 			//
 			if (inflatedMetaInfo == null) {
 				if ((state & StateFlags.PendingMetaInflate) != 0) {
 					var dt_meta = DeclaringType.GetMetaInfo ();
 
 					if (DeclaringType.IsTypeBuilder) {
 						if (IsConstructor)
 							inflatedMetaInfo = TypeBuilder.GetConstructor (dt_meta, (ConstructorInfo) metaInfo);
 						else
 							inflatedMetaInfo = TypeBuilder.GetMethod (dt_meta, (MethodInfo) metaInfo);
 					} else {
 #if STATIC
 						// it should not be reached
 						throw new NotImplementedException ();
 #else
 						inflatedMetaInfo = MethodInfo.GetMethodFromHandle (metaInfo.MethodHandle, dt_meta.TypeHandle);
 #endif
 					}
 
 					state &= ~StateFlags.PendingMetaInflate;
 				} else {
 					inflatedMetaInfo = metaInfo;
 				}
 			}
 
 			if ((state & StateFlags.PendingMakeMethod) != 0) {
 				var sre_targs = new MetaType[targs.Length];
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 
 				inflatedMetaInfo = ((MethodInfo) inflatedMetaInfo).MakeGenericMethod (sre_targs);
 				state &= ~StateFlags.PendingMakeMethod;
 			}
 
 			return inflatedMetaInfo;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name;
 			if (IsConstructor) {
 				name = DeclaringType.GetSignatureForError () + "." + DeclaringType.Name;
 			} else if (Kind == MemberKind.Operator) {
 				var op = Operator.GetType (Name).Value;
 				if (op == Operator.OpType.Implicit || op == Operator.OpType.Explicit) {
 					name = DeclaringType.GetSignatureForError () + "." + Operator.GetName (op) + " operator " + returnType.GetSignatureForError ();
 				} else {
 					name = DeclaringType.GetSignatureForError () + ".operator " + Operator.GetName (op);
 				}
 			} else if (IsAccessor) {
 				int split = Name.IndexOf ('_');
 				name = Name.Substring (split + 1);
 				var postfix = Name.Substring (0, split);
 				if (split == 3) {
 					var pc = parameters.Count;
 					if (pc > 0 && postfix == "get") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc);
 					} else if (pc > 1 && postfix == "set") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc - 1);
 					}
 				}
 
 				return DeclaringType.GetSignatureForError () + "." + name + "." + postfix;
 			} else {
 				name = base.GetSignatureForError ();
 				if (targs != null)
 					name += "<" + TypeManager.CSharpName (targs) + ">";
 				else if (IsGeneric)
 					name += "<" + TypeManager.CSharpName (GenericDefinition.TypeParameters) + ">";
 			}
 
 			return name + parameters.GetSignatureForError ();
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var ms = (MethodSpec) base.InflateMember (inflator);
 			ms.inflatedMetaInfo = null;
 			ms.returnType = inflator.Inflate (returnType);
 			ms.parameters = parameters.Inflate (inflator);
 			if (IsGeneric)
 				ms.constraints = TypeParameterSpec.InflateConstraints (inflator, Constraints);
 
 			return ms;
 		}
 
 		public MethodSpec MakeGenericMethod (params TypeSpec[] targs)
 		{
 			if (targs == null)
 				throw new ArgumentNullException ();
 // TODO MemberCache
 //			if (generic_intances != null && generic_intances.TryGetValue (targs, out ginstance))
 //				return ginstance;
 
 			//if (generic_intances == null)
 			//    generic_intances = new Dictionary<TypeSpec[], Method> (TypeSpecArrayComparer.Default);
 
 			var inflator = new TypeParameterInflator (DeclaringType, GenericDefinition.TypeParameters, targs);
 
 			var inflated = (MethodSpec) MemberwiseClone ();
 			inflated.declaringType = inflator.TypeInstance;
 			inflated.returnType = inflator.Inflate (returnType);
 			inflated.parameters = parameters.Inflate (inflator);
 			inflated.targs = targs;
 			inflated.constraints = TypeParameterSpec.InflateConstraints (inflator, constraints ?? GenericDefinition.TypeParameters);
 			inflated.state |= StateFlags.PendingMakeMethod;
 
 			//			if (inflated.parent == null)
 			//				inflated.parent = parent;
 
 			//generic_intances.Add (targs, inflated);
 			return inflated;
 		}
 
 		public MethodSpec Mutate (TypeParameterMutator mutator)
 		{
 			var targs = TypeArguments;
 			if (targs != null)
 				targs = mutator.Mutate (targs);
 
 			var decl = DeclaringType;
 			if (DeclaringType.IsGenericOrParentIsGeneric) {
 				decl = mutator.Mutate (decl);
 			}
 
 			if (targs == TypeArguments && decl == DeclaringType)
 				return this;
 
 			var ms = (MethodSpec) MemberwiseClone ();
 			if (decl != DeclaringType) {
 				ms.inflatedMetaInfo = null;
 				ms.declaringType = decl;
 				ms.state |= StateFlags.PendingMetaInflate;
 			}
 
 			if (targs != null) {
 				ms.targs = targs;
 				ms.state |= StateFlags.PendingMakeMethod;
 			}
 
 			return ms;
 		}
 
 		public void SetMetaInfo (MethodInfo info)
 		{
 			if (this.metaInfo != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.metaInfo = info;
 		}
 	}
 
 	public abstract class MethodOrOperator 
 	{
 		public MethodBuilder MethodBuilder;
 		ReturnParameter return_attributes;
 		SecurityType declarative_security;
 		protected MethodData MethodData;
 
 		static string[] attribute_targets = new string [] { "method", "return" };
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="327" endline="629">
<![CDATA[
 		
 		Constraints constraints;
 		GenericTypeParameterBuilder builder;
 		TypeParameterSpec spec;
 
 		public TypeParameter (DeclSpace parent, int index, MemberName name, Constraints constraints, Attributes attrs, Variance variance)
 			
 		{
 			this.constraints = constraints;
 			this.spec = new TypeParameterSpec (null, index, this, SpecialConstraint.None, variance, null);
 		}
 
 		public TypeParameter (TypeParameterSpec spec, DeclSpace parent, TypeSpec parentSpec, MemberName name, Attributes attrs)
 			
 		{
 			this.spec = new TypeParameterSpec (parentSpec, spec.DeclaredPosition, spec.MemberDefinition, spec.SpecialConstraint, spec.Variance, null) {
 				BaseType = spec.BaseType,
 				InterfacesDefined = spec.InterfacesDefined,
 				TypeArguments = spec.TypeArguments
 			};
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.GenericParameter;
 			}
 		}
 
 		public IAssemblyDefinition DeclaringAssembly {
 			get	{
 				return Module.DeclaringAssembly;
 			}
 		}
 
 		public override string DocCommentHeader {
 			get {
 				throw new InvalidOperationException (
 					"Unexpected attempt to get doc comment from " + this.GetType ());
 			}
 		}
 
 		public bool IsMethodTypeParameter {
 			get {
 				return spec.IsMethodOwned;
 			}
 		}
 
 		public string Namespace {
 			get {
 				return null;
 			}
 		}
 
 		public TypeParameterSpec Type {
 			get {
 				return spec;
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return 0;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				return null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_target;
 			}
 		}
 
 		public Variance Variance {
 			get {
 				return spec.Variance;
 			}
 		}
 
 		#endregion
 
 		//
 		// This is called for each part of a partial generic type definition.
 		//
 		// If partial type parameters constraints are not null and we don't
 		// already have constraints they become our constraints. If we already
 		// have constraints, we must check that they're the same.
 		//
 		public bool AddPartialConstraints (TypeContainer part, TypeParameter tp)
 		{
 			if (builder == null)
 				throw new InvalidOperationException ();
 
 			var new_constraints = tp.constraints;
 			if (new_constraints == null)
 				return true;
 
 			// TODO
 			//tp.Define (null, -1, part.Definition);
 			tp.spec.DeclaringType = part.Definition;
 			if (!tp.ResolveConstraints (part))
 				return false;
 
 			if (constraints != null)
 				return spec.HasSameConstraintsDefinition (tp.Type);
 
 			// Copy constraint from resolved part to partial container
 			spec.SpecialConstraint = tp.spec.SpecialConstraint;
 			spec.InterfacesDefined = tp.spec.InterfacesDefined;
 			spec.TypeArguments = tp.spec.TypeArguments;
 			spec.BaseType = tp.spec.BaseType;
 			
 			return true;
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public void CheckGenericConstraints ()
 		{
 			if (constraints != null)
 				constraints.CheckGenericConstraints (this);
 		}
 
 		public TypeParameter CreateHoistedCopy (TypeContainer declaringType, TypeSpec declaringSpec)
 		{
 			return new TypeParameter (spec, declaringType, declaringSpec, MemberName, null);
 		}
 
 		public override bool Define ()
 		{
 			return true;
 		}
 
 		//
 		// This is the first method which is called during the resolving
 		// process; we're called immediately after creating the type parameters
 		// with SRE (by calling `DefineGenericParameters()' on the TypeBuilder /
 		// MethodBuilder).
 		//
 		public void Define (GenericTypeParameterBuilder type, TypeSpec declaringType)
 		{
 			if (builder != null)
 				throw new InternalErrorException ();
 
 			this.builder = type;
 			spec.DeclaringType = declaringType;
 			spec.SetMetaInfo (type);
 		}
 
 		public void EmitConstraints (GenericTypeParameterBuilder builder)
 		{
 			var attr = GenericParameterAttributes.None;
 			if (spec.Variance == Variance.Contravariant)
 				attr |= GenericParameterAttributes.Contravariant;
 			else if (spec.Variance == Variance.Covariant)
 				attr |= GenericParameterAttributes.Covariant;
 
 			if (spec.HasSpecialClass)
 				attr |= GenericParameterAttributes.ReferenceTypeConstraint;
 			else if (spec.HasSpecialStruct)
 				attr |= GenericParameterAttributes.NotNullableValueTypeConstraint | GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.HasSpecialConstructor)
 				attr |= GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.BaseType != TypeManager.object_type)
 				builder.SetBaseTypeConstraint (spec.BaseType.GetMetaInfo ());
 
 			if (spec.InterfacesDefined != null)
 				builder.SetInterfaceConstraints (spec.InterfacesDefined.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			if (spec.TypeArguments != null)
 				builder.SetInterfaceConstraints (spec.TypeArguments.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			builder.SetGenericParameterAttributes (attr);
 		}
 
 		public override void Emit ()
 		{
 			EmitConstraints (builder);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			base.Emit ();
 		}
 
 		public void ErrorInvalidVariance (IMemberContext mc, Variance expected)
 		{
 			Report.SymbolRelatedToPreviousError (mc.CurrentMemberDefinition);
 			string input_variance = Variance == Variance.Contravariant ? "contravariant" 
 			string gtype_variance;
 			switch (expected) {
 			case Variance.Contravariant
 			case Variance.Covariant
 			default
 			}
 
 			Delegate d = mc as Delegate;
 			string parameters = d != null ? d.Parameters.GetSignatureForError () 
 
 			Report.Error (1961, Location,
 				"The {2} type parameter `{0}' must be {3} valid on `{1}{4}'",
 					GetSignatureForError (), mc.GetSignatureForError (), input_variance, gtype_variance, parameters);
 		}
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			return null;
 		}
 
 		public string GetAttributeDefaultMember ()
 		{
 			throw new NotSupportedException ();
 		}
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			throw new NotSupportedException ();
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return MemberName.Name;
 		}
 
 		bool ITypeDefinition.IsInternalAsPublic (IAssemblyDefinition assembly)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public void LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			throw new NotSupportedException ("Not supported for compiled definition");
 		}
 
 		//
 		// Resolves all type parameter constraints
 		//
 		public bool ResolveConstraints (IMemberContext context)
 		{
 			if (constraints != null)
 				return constraints.Resolve (context, this);
 
 			if (spec.BaseType == null)
 				spec.BaseType = TypeManager.object_type;
 
 			return true;
 		}
 
 		public static TypeParameter FindTypeParameter (TypeParameter[] tparams, string name)
 		{
 			foreach (var tp in tparams) {
 				if (tp.Name == name)
 					return tp;
 			}
 
 			return null;
 		}
 
 		public override bool IsClsComplianceRequired ()
 		{
 			return false;
 		}
 
 		public new void VerifyClsCompliance ()
 		{
 			if (constraints != null)
 				constraints.VerifyClsCompliance (Report);
 		}
 	}
 
 	[System.Diagnostics.DebuggerDisplay ("{DisplayDebugInfo()}")]
 	public class TypeParameterSpec 
 	{
 		public static readonly new TypeParameterSpec[] EmptyTypes = new TypeParameterSpec[0];
 
 		Variance variance;
 		SpecialConstraint spec;
 		readonly int tp_pos;
 		TypeSpec[] targs;
 		TypeSpec[] ifaces_defined;
 
 		//
 		// Creates type owned type parameter
 		//
 		public TypeParameterSpec (TypeSpec declaringType, int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 			this.variance = variance;
 			this.spec = spec;
 			state &= ~StateFlags.Obsolete_Undetected;
 			tp_pos = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1985" endline="2325">
<![CDATA[
 
 		public Destructor (DeclSpace parent, Modifiers mod, ParametersCompiled parameters, Attributes attrs, Location l)
 			
 				new MemberName (MetadataName, l), attrs, parameters)
 		{
 			ModFlags &= ~Modifiers.PRIVATE;
 			ModFlags |= Modifiers.PROTECTED | Modifiers.OVERRIDE;
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		protected override bool CheckBase ()
 		{
 			// Don't check base, destructors have special syntax
 			return true;
 		}
 
 		public override void Emit()
 		{
 			var base_type = Parent.PartialContainer.BaseType;
 			if (base_type != null && Block != null) {
 				var base_dtor = MemberCache.FindMember (base_type,
 					new MemberFilter (MetadataName, 0, MemberKind.Destructor, null, null), BindingRestriction.InstanceOnly) as MethodSpec;
 
 				if (base_dtor == null)
 					throw new NotImplementedException ();
 
 				MethodGroupExpr method_expr = MethodGroupExpr.CreatePredefined (base_dtor, base_type, Location);
 				method_expr.InstanceExpression = new BaseThis (base_type, Location);
 
 				var try_block = new ExplicitBlock (block, block.StartLocation, block.EndLocation);
 				var finaly_block = new ExplicitBlock (block, Location, Location);
 
 				//
 				// 0-size arguments to avoid CS0250 error
 				// TODO
 				// debugger scope
 				//
 				finaly_block.AddStatement (new StatementExpression (new Invocation (method_expr, new Arguments (0))));
 
 				var tf = new TryFinally (try_block, finaly_block, Location);
 				block.WrapIntoDestructor (tf, try_block);
 			}
 
 			base.Emit ();
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Parent.GetSignatureForError () + ".~" + Parent.MemberName.Name + "()";
 		}
 
 		protected override bool ResolveMemberType ()
 		{
 			member_type = TypeManager.void_type;
 			return true;
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 	}
 
 	// Ooouh Martin, templates are missing here.
 	// When it will be possible move here a lot of child code and template method type.
 	public abstract class AbstractPropertyEventMethod 
 		protected MethodData method_data;
 		protected ToplevelBlock block;
 		protected SecurityType declarative_security;
 
 		protected readonly string prefix;
 
 		ReturnParameter return_attributes;
 
 		public AbstractPropertyEventMethod (InterfaceMemberBase member, string prefix, Attributes attrs, Location loc)
 			
 		{
 			this.prefix = prefix;
 		}
 
 		static MemberName SetupName (string prefix, InterfaceMemberBase member, Location loc)
 		{
 			return new MemberName (member.MemberName.Left, prefix + member.ShortName, loc);
 		}
 
 		public void UpdateName (InterfaceMemberBase member)
 		{
 			SetMemberName (SetupName (prefix, member, Location));
 		}
 
 		#region IMethodData Members
 
 		public ToplevelBlock Block {
 			get {
 				return block;
 			}
 
 			set {
 				block = value;
 			}
 		}
 
 		public CallingConventions CallingConventions {
 			get {
 				return CallingConventions.Standard;
 			}
 		}
 
 		public EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, ReturnType);
 		}
 
 		public bool IsExcluded ()
 		{
 			return false;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return null;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		public TypeSpec[] ParameterTypes { 
 			get {
 				return ParameterInfo.Types;
 			}
 		}
 
 		public abstract ParametersCompiled ParameterInfo { get ; }
 		public abstract TypeSpec ReturnType { get; }
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant || a.Type == pa.Obsolete || a.Type == pa.Conditional) {
 				Report.Error (1667, a.Location,
 					"Attribute `{0}' is not valid on property or event accessors. It is valid on `{1}' declarations only",
 					TypeManager.CSharpName (a.Type), a.GetValidTargets ());
 				return;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				method_data.MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			ApplyToExtraTarget (a, ctor, cdata, pa);
 		}
 
 		protected virtual void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			throw new NotSupportedException ("You forgot to define special attribute target handling");
 		}
 
 		// It is not supported for the accessors
 		public sealed override bool Define()
 		{
 			throw new NotSupportedException ();
 		}
 
 		public virtual void Emit (DeclSpace parent)
 		{
 			method_data.Emit (parent);
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (method_data.MethodBuilder);
 			if (((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0))
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (method_data.MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			block = null;
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is MethodCore) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			// This can only happen with indexers and it will
 			// be catched as indexer difference
 			if (overload is AbstractPropertyEventMethod)
 				return true;
 
 			return false;
 		}
 
 		public override bool IsClsComplianceRequired()
 		{
 			return false;
 		}
 
 		public MethodSpec Spec { get; protected set; }
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { throw new InvalidOperationException ("Unexpected attempt to get doc comment from " + this.GetType () + "."); }
 		}
 
 		void IMethodData.EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 	}
 
 	public class Operator 
 
 		const Modifiers AllowedModifiers =
 			Modifiers.PUBLIC |
 			Modifiers.UNSAFE |
 			Modifiers.EXTERN |
 			Modifiers.STATIC;
 
 		public enum OpType 
 
 			// Unary operators
 			LogicalNot,
 			OnesComplement,
 			Increment,
 			Decrement,
 			True,
 			False,
 
 			// Unary and Binary operators
 			Addition,
 			Subtraction,
 
 			UnaryPlus,
 			UnaryNegation,
 			
 			// Binary operators
 			Multiply,
 			Division,
 			Modulus,
 			BitwiseAnd,
 			BitwiseOr,
 			ExclusiveOr,
 			LeftShift,
 			RightShift,
 			Equality,
 			Inequality,
 			GreaterThan,
 			LessThan,
 			GreaterThanOrEqual,
 			LessThanOrEqual,
 
 			// Implicit and Explicit
 			Implicit,
 			Explicit,
 
 			// Just because of enum
 			TOP
 		};
 
 		public readonly OpType OperatorType;
 
 		static readonly string [] [] names;
 
 		static Operator ()
 		{
 			names = new string[(int)OpType.TOP][];
 			names [(int) OpType.LogicalNot] = new string [] { "!", "op_LogicalNot" };
 			names [(int) OpType.OnesComplement] = new string [] { "~", "op_OnesComplement" };
 			names [(int) OpType.Increment] = new string [] { "++", "op_Increment" };
 			names [(int) OpType.Decrement] = new string [] { "--", "op_Decrement" };
 			names [(int) OpType.True] = new string [] { "true", "op_True" };
 			names [(int) OpType.False] = new string [] { "false", "op_False" };
 			names [(int) OpType.Addition] = new string [] { "+", "op_Addition" };
 			names [(int) OpType.Subtraction] = new string [] { "-", "op_Subtraction" };
 			names [(int) OpType.UnaryPlus] = new string [] { "+", "op_UnaryPlus" };
 			names [(int) OpType.UnaryNegation] = new string [] { "-", "op_UnaryNegation" };
 			names [(int) OpType.Multiply] = new string [] { "*", "op_Multiply" };
 			names [(int) OpType.Division] = new string [] { "/", "op_Division" };
 			names [(int) OpType.Modulus] = new string [] { "%", "op_Modulus" };
 			names [(int) OpType.BitwiseAnd] = new string [] { "&", "op_BitwiseAnd" };
 			names [(int) OpType.BitwiseOr] = new string [] { "|", "op_BitwiseOr" };
 			names [(int) OpType.ExclusiveOr] = new string [] { "^", "op_ExclusiveOr" };
 			names [(int) OpType.LeftShift] = new string [] { "<<", "op_LeftShift" };
 			names [(int) OpType.RightShift] = new string [] { ">>", "op_RightShift" };
 			names [(int) OpType.Equality] = new string [] { "==", "op_Equality" };
 			names [(int) OpType.Inequality] = new string [] { "!=", "op_Inequality" };
 			names [(int) OpType.GreaterThan] = new string [] { ">", "op_GreaterThan" };
 			names [(int) OpType.LessThan] = new string [] { "<", "op_LessThan" };
 			names [(int) OpType.GreaterThanOrEqual] = new string [] { ">=", "op_GreaterThanOrEqual" };
 			names [(int) OpType.LessThanOrEqual] = new string [] { "<=", "op_LessThanOrEqual" };
 			names [(int) OpType.Implicit] = new string [] { "implicit", "op_Implicit" };
 			names [(int) OpType.Explicit] = new string [] { "explicit", "op_Explicit" };
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="992" endline="1338">
<![CDATA[
 
 		Expression initializer;
 		Field backing_field;
 		List<FieldDeclarator> declarators;
 
 		public EventField (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			Add = new AddDelegateMethod (this);
 			Remove = new RemoveDelegateMethod (this);
 		}
 
 		#region Properties
 
 		bool HasBackingField {
 			get {
 				return !IsInterface && (ModFlags & Modifiers.ABSTRACT) == 0;
 			}
 		}
 
 		public Expression Initializer {
 			get {
 				return initializer;
 			}
 			set {
 				initializer = value;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return HasBackingField ? attribute_targets 
 			}
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Field) {
 				backing_field.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				int errors = Report.Errors;
 				Add.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				if (errors == Report.Errors)
 					Remove.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override bool Define()
 		{
 			var mod_flags_src = ModFlags;
 
 			if (!base.Define ())
 				return false;
 
 			if (declarators != null) {
 				if ((mod_flags_src & Modifiers.DEFAULT_ACCESS_MODIFER) != 0)
 					mod_flags_src &= ~(Modifiers.AccessibilityMask | Modifiers.DEFAULT_ACCESS_MODIFER);
 
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Events.IndexOf (this);
 				foreach (var d in declarators) {
 					var ef = new EventField (Parent, t, mod_flags_src, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 
 					if (d.Initializer != null)
 						ef.initializer = d.Initializer;
 
 					Parent.PartialContainer.Events.Insert (++index, ef);
 				}
 			}
 
 			if (!HasBackingField) {
 				SetIsUsed ();
 				return true;
 			}
 
 			if (Add.IsInterfaceImplementation)
 				SetIsUsed ();
 
 			backing_field = new Field (Parent,
 				new TypeExpression (MemberType, Location),
 				Modifiers.BACKING_FIELD | Modifiers.COMPILER_GENERATED | Modifiers.PRIVATE | (ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE)),
 				MemberName, null);
 
 			Parent.PartialContainer.AddField (backing_field);
 			backing_field.Initializer = Initializer;
 			backing_field.ModFlags &= ~Modifiers.COMPILER_GENERATED;
 
 			// Call define because we passed fields definition
 			backing_field.Define ();
 
 			// Set backing field for event fields
 			spec.BackingField = backing_field.Spec;
 
 			return true;
 		}
 	}
 
 	public abstract class Event 
 	{
 		public abstract class AEventAccessor 
 		{
 			protected readonly Event method;
 			ParametersCompiled parameters;
 
 			static readonly string[] attribute_targets = new string [] { "method", "param", "return" };
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Event;
 			}
 		}
 
 		public AEventAccessor Add {
 			get {
 				return this.add;
 			}
 			set {
 				add = value;
 				Parent.AddMember (value);
 			}
 		}
 
 		public AEventAccessor Remove {
 			get {
 				return this.remove;
 			}
 			set {
 				remove = value;
 				Parent.AddMember (value);
 			}
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			EventBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsDelegateType (MemberType)) {
 				Report.Error (66, Location, "`{0}'
 			}
 
 			if (!CheckBase ())
 				return false;
 
 			//
 			// Now define the accessors
 			//
 			var AddBuilder = Add.Define (Parent);
 			if (AddBuilder == null)
 				return false;
 
 			var RemoveBuilder = remove.Define (Parent);
 			if (RemoveBuilder == null)
 				return false;
 
 			EventBuilder = Parent.TypeBuilder.DefineEvent (GetFullName (MemberName), EventAttributes.None, MemberType.GetMetaInfo ());
 			EventBuilder.SetAddOnMethod (AddBuilder);
 			EventBuilder.SetRemoveOnMethod (RemoveBuilder);
 
 			spec = new EventSpec (Parent.Definition, this, MemberType, ModFlags, Add.Spec, remove.Spec);
 
 			Parent.MemberCache.AddMember (this, Name, spec);
 			Parent.MemberCache.AddMember (this, AddBuilder.Name, Add.Spec);
 			Parent.MemberCache.AddMember (this, RemoveBuilder.Name, remove.Spec);
 
 			return true;
 		}
 
 		public override void Emit ()
 		{
 			CheckReservedNameConflict (null, add.Spec);
 			CheckReservedNameConflict (null, remove.Spec);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			Add.Emit (Parent);
 			Remove.Emit (Parent);
 
 			base.Emit ();
 		}
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { return "E
 		}
 	}
 
 	public class EventSpec 
 	{
 		MethodSpec add, remove;
 		FieldSpec backing_field;
 
 		public EventSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec eventType, Modifiers modifiers, MethodSpec add, MethodSpec remove)
 			
 		{
 			this.AccessorAdd = add;
 			this.AccessorRemove = remove;
 			this.MemberType = eventType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1746" endline="1943">
<![CDATA[
 
 		public void LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			//
 			// Not interested in members of nested private types unless the importer needs them
 			//
 			if (declaringType.IsPrivate && importer.IgnorePrivateMembers) {
 				cache = MemberCache.Empty;
 				return;
 			}
 
 			var loading_type = (MetaType) provider;
 			const BindingFlags all_members = BindingFlags.DeclaredOnly |
 				BindingFlags.Static | BindingFlags.Instance |
 				BindingFlags.Public | BindingFlags.NonPublic;
 
 			const MethodAttributes explicit_impl = MethodAttributes.NewSlot |
 					MethodAttributes.Virtual | MethodAttributes.HideBySig |
 					MethodAttributes.Final;
 
 			Dictionary<MethodBase, MethodSpec> possible_accessors = null;
 			List<EventSpec> imported_events = null;
 			EventSpec event_spec;
 			MemberSpec imported;
 			MethodInfo m;
 			MemberInfo[] all;
 			try {
 				all = loading_type.GetMembers (all_members);
 			} catch (Exception e) {
 				throw new InternalErrorException (e, "Could not import type `{0}' from `{1}'",
 					declaringType.GetSignatureForError (), declaringType.MemberDefinition.DeclaringAssembly.FullName);
 			}
 
 			if (cache == null) {
 				cache = new MemberCache (all.Length);
 
 				//
 				// Do the types first as they can be referenced by the members before
 				// they are found or inflated
 				//
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					// Ignore compiler generated types, mostly lambda containers
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					imported = importer.CreateNestedType (t, declaringType);
 					cache.AddMember (imported);
 				}
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					// Ignore compiler generated types, mostly lambda containers
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					imported = importer.CreateNestedType (t, declaringType);
 					cache.AddMember (imported);
 				}
 
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					importer.ImportTypeBase (t);
 				}
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					importer.ImportTypeBase (t);
 				}
 			}
 
 			if (!onlyTypes) {
 				//
 				// The logic here requires methods to be returned first which seems to work for both Mono and .NET
 				//
 				foreach (var member in all) {
 					switch (member.MemberType) {
 					case MemberTypes.Constructor
 					case MemberTypes.Method
 						MethodBase mb = (MethodBase) member;
 						var attrs = mb.Attributes;
 
 						if ((attrs & MethodAttributes.MemberAccessMask) == MethodAttributes.Private) {
 							if (importer.IgnorePrivateMembers)
 								continue;
 
 							// Ignore explicitly implemented members
 							if ((attrs & explicit_impl) == explicit_impl)
 								continue;
 
 							// Ignore compiler generated methods
 							if (importer.HasAttribute (CustomAttributeData.GetCustomAttributes (mb), "CompilerGeneratedAttribute", MetadataImporter.CompilerServicesNamespace))
 								continue;
 						}
 
 						imported = importer.CreateMethod (mb, declaringType);
 						if (imported.Kind == MemberKind.Method && !imported.IsGeneric) {
 							if (possible_accessors == null)
 								possible_accessors = new Dictionary<MethodBase, MethodSpec> (ReferenceEquality<MethodBase>.Default);
 
 							// There are no metadata rules for accessors, we have to consider any method as possible candidate
 							possible_accessors.Add (mb, (MethodSpec) imported);
 						}
 
 						break;
 					case MemberTypes.Property
 						if (possible_accessors == null)
 							continue;
 
 						var p = (PropertyInfo) member;
 						//
 						// Links possible accessors with property
 						//
 						MethodSpec get, set;
 						m = p.GetGetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out get))
 							get = null;
 
 						m = p.GetSetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out set))
 							set = null;
 
 						// No accessors registered (e.g. explicit implementation)
 						if (get == null && set == null)
 							continue;
 
 						imported = importer.CreateProperty (p, declaringType, get, set);
 						if (imported == null)
 							continue;
 
 						break;
 					case MemberTypes.Event
 						if (possible_accessors == null)
 							continue;
 
 						var e = (EventInfo) member;
 						//
 						// Links accessors with event
 						//
 						MethodSpec add, remove;
 						m = e.GetAddMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out add))
 							add = null;
 
 						m = e.GetRemoveMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out remove))
 							remove = null;
 
 						// Both accessors are required
 						if (add == null || remove == null)
 							continue;
 
 						event_spec = importer.CreateEvent (e, declaringType, add, remove);
 						if (!importer.IgnorePrivateMembers) {
 							if (imported_events == null)
 								imported_events = new List<EventSpec> ();
 
 							imported_events.Add (event_spec);
 						}
 
 						imported = event_spec;
 						break;
 					case MemberTypes.Field
 						var fi = (FieldInfo) member;
 
 						imported = importer.CreateField (fi, declaringType);
 						if (imported == null)
 							continue;
 
 						//
 						// For dynamic binder event has to be fully restored to allow operations
 						// within the type container to work correctly
 						//
 						if (imported_events != null) {
 							// The backing event field should be private but it may not
 							int index = imported_events.FindIndex (l => l.Name == fi.Name);
 							if (index >= 0) {
 								event_spec = imported_events[index];
 								event_spec.BackingField = (FieldSpec) imported;
 								imported_events.RemoveAt (index);
 								continue;
 							}
 						}
 
 						break;
 					case MemberTypes.NestedType
 						// Already in the cache from the first pass
 						continue;
 					default
 						throw new NotImplementedException (member.ToString ());
 					}
 
 					cache.AddMember (imported);
 				}
 				foreach (var member in all) {
 					switch (member.MemberType) {
 					case MemberTypes.Constructor
 					case MemberTypes.Method
 						MethodBase mb = (MethodBase) member;
 						var attrs = mb.Attributes;
 
 						if ((attrs & MethodAttributes.MemberAccessMask) == MethodAttributes.Private) {
 							if (importer.IgnorePrivateMembers)
 								continue;
 
 							// Ignore explicitly implemented members
 							if ((attrs & explicit_impl) == explicit_impl)
 								continue;
 
 							// Ignore compiler generated methods
 							if (importer.HasAttribute (CustomAttributeData.GetCustomAttributes (mb), "CompilerGeneratedAttribute", MetadataImporter.CompilerServicesNamespace))
 								continue;
 						}
 
 						imported = importer.CreateMethod (mb, declaringType);
 						if (imported.Kind == MemberKind.Method && !imported.IsGeneric) {
 							if (possible_accessors == null)
 								possible_accessors = new Dictionary<MethodBase, MethodSpec> (ReferenceEquality<MethodBase>.Default);
 
 							// There are no metadata rules for accessors, we have to consider any method as possible candidate
 							possible_accessors.Add (mb, (MethodSpec) imported);
 						}
 
 						break;
 					case MemberTypes.Property
 						if (possible_accessors == null)
 							continue;
 
 						var p = (PropertyInfo) member;
 						//
 						// Links possible accessors with property
 						//
 						MethodSpec get, set;
 						m = p.GetGetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out get))
 							get = null;
 
 						m = p.GetSetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out set))
 							set = null;
 
 						// No accessors registered (e.g. explicit implementation)
 						if (get == null && set == null)
 							continue;
 
 						imported = importer.CreateProperty (p, declaringType, get, set);
 						if (imported == null)
 							continue;
 
 						break;
 					case MemberTypes.Event
 						if (possible_accessors == null)
 							continue;
 
 						var e = (EventInfo) member;
 						//
 						// Links accessors with event
 						//
 						MethodSpec add, remove;
 						m = e.GetAddMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out add))
 							add = null;
 
 						m = e.GetRemoveMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out remove))
 							remove = null;
 
 						// Both accessors are required
 						if (add == null || remove == null)
 							continue;
 
 						event_spec = importer.CreateEvent (e, declaringType, add, remove);
 						if (!importer.IgnorePrivateMembers) {
 							if (imported_events == null)
 								imported_events = new List<EventSpec> ();
 
 							imported_events.Add (event_spec);
 						}
 
 						imported = event_spec;
 						break;
 					case MemberTypes.Field
 						var fi = (FieldInfo) member;
 
 						imported = importer.CreateField (fi, declaringType);
 						if (imported == null)
 							continue;
 
 						//
 						// For dynamic binder event has to be fully restored to allow operations
 						// within the type container to work correctly
 						//
 						if (imported_events != null) {
 							// The backing event field should be private but it may not
 							int index = imported_events.FindIndex (l => l.Name == fi.Name);
 							if (index >= 0) {
 								event_spec = imported_events[index];
 								event_spec.BackingField = (FieldSpec) imported;
 								imported_events.RemoveAt (index);
 								continue;
 							}
 						}
 
 						break;
 					case MemberTypes.NestedType
 						// Already in the cache from the first pass
 						continue;
 					default
 						throw new NotImplementedException (member.ToString ());
 					}
 
 					cache.AddMember (imported);
 				}
 			}
 
 			if (declaringType.IsInterface && declaringType.Interfaces != null) {
 				foreach (var iface in declaringType.Interfaces) {
 					cache.AddInterface (iface);
 				}
 				foreach (var iface in declaringType.Interfaces) {
 					cache.AddInterface (iface);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="469" endline="801">
<![CDATA[
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Method; 
 			}
 		}
 
 		protected override bool CheckForDuplications ()
 		{
 			return Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 		}
 
 		public virtual EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, MemberType);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
 
 		public bool IsPartialDefinition {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block == null;
 			}
 		}
 
 		public bool IsPartialImplementation {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block != null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#region IMethodData Members
 
 		public TypeSpec ReturnType {
 			get {
 				return MemberType;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return GenericMethod;
 			}
 		}
 
 		public virtual void EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 
 		#endregion
 
 	}
 
 	public class SourceMethod 
 	{
 		MethodBase method;
 		SourceMethodBuilder builder;
 
 		protected SourceMethod (DeclSpace parent, MethodBase method, ICompileUnit file)
 		{
 			this.method = method;
 			
 			builder = SymbolWriter.OpenMethod (file, parent.NamespaceEntry.SymbolFileID, this);
 		}
 
 		public string Name {
 			get { return method.Name; }
 		}
 
 		public int Token {
 			get {
 				MethodToken token;
 				var mb = method as MethodBuilder;
 				if (mb != null)
 					token = mb.GetToken ();
 				else
 					token = ((ConstructorBuilder) method).GetToken ();
 #if STATIC
 				if (token.IsPseudoToken)
 					return ((ModuleBuilder) method.Module).ResolvePseudoToken (token.Token);
 #endif
 				return token.Token;
 			}
 		}
 
 		public void CloseMethod ()
 		{
 			SymbolWriter.CloseMethod ();
 		}
 
 		public void SetRealMethodName (string name)
 		{
 			if (builder != null)
 				builder.SetRealMethodName (name);
 		}
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="156" endline="423">
<![CDATA[
 		List<MethodEntry> methods = new List<MethodEntry> ();
 		List<SourceFileEntry> sources = new List<SourceFileEntry> ();
 		List<CompileUnitEntry> comp_units = new List<CompileUnitEntry> ();
 		Dictionary<Type, int> type_hash = new Dictionary<Type, int> ();
 		Dictionary<int, AnonymousScopeEntry> anonymous_scopes;
 
 		OffsetTable ot;
 		int last_type_index;
 		int last_method_index;
 		int last_namespace_index;
 
 		public readonly string FileName = "<dynamic>";
 		public readonly int MajorVersion = OffsetTable.MajorVersion;
 		public readonly int MinorVersion = OffsetTable.MinorVersion;
 
 		public int NumLineNumbers;
 
 		internal MonoSymbolFile ()
 		{
 			ot = new OffsetTable ();
 		}
 
 		internal int AddSource (SourceFileEntry source)
 		{
 			sources.Add (source);
 			return sources.Count;
 		}
 
 		internal int AddCompileUnit (CompileUnitEntry entry)
 		{
 			comp_units.Add (entry);
 			return comp_units.Count;
 		}
 
 		internal int DefineType (Type type)
 		{
 			int index;
 			if (type_hash.TryGetValue (type, out index))
 				return index;
 
 			index = ++last_type_index;
 			type_hash.Add (type, index);
 			return index;
 		}
 
 		internal void AddMethod (MethodEntry entry)
 		{
 			methods.Add (entry);
 		}
 
 		public MethodEntry DefineMethod (CompileUnitEntry comp_unit, int token,
 						 ScopeVariable[] scope_vars, LocalVariableEntry[] locals,
 						 LineNumberEntry[] lines, CodeBlockEntry[] code_blocks,
 						 string real_name, MethodEntry.Flags flags,
 						 int namespace_id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			MethodEntry method = new MethodEntry (
 				this, comp_unit, token, scope_vars, locals, lines, code_blocks, 
 				real_name, flags, namespace_id);
 			AddMethod (method);
 			return method;
 		}
 
 		internal void DefineAnonymousScope (int id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			if (anonymous_scopes == null)
 				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>  ();
 
 			anonymous_scopes.Add (id, new AnonymousScopeEntry (id));
 		}
 
 		internal void DefineCapturedVariable (int scope_id, string name, string captured_name,
 						      CapturedVariable.CapturedKind kind)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedVariable (name, captured_name, kind);
 		}
 
 		internal void DefineCapturedScope (int scope_id, int id, string captured_name)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedScope (id, captured_name);
 		}
 
 		internal int GetNextTypeIndex ()
 		{
 			return ++last_type_index;
 		}
 
 		internal int GetNextMethodIndex ()
 		{
 			return ++last_method_index;
 		}
 
 		internal int GetNextNamespaceIndex ()
 		{
 			return ++last_namespace_index;
 		}
 		
 		void Write (MyBinaryWriter bw, Guid guid)
 		{
 			// Magic number and file version.
 			bw.Write (OffsetTable.Magic);
 			bw.Write (MajorVersion);
 			bw.Write (MinorVersion);
 
 			bw.Write (guid.ToByteArray ());
 
 			//
 			// Offsets of file sections; we must write this after we're done
 			// writing the whole file, so we just reserve the space for it here.
 			//
 			long offset_table_offset = bw.BaseStream.Position;
 			ot.Write (bw, MajorVersion, MinorVersion);
 
 			//
 			// Sort the methods according to their tokens and update their index.
 			//
 			methods.Sort ();
 			for (int i = 0; i < methods.Count; i++)
 				((MethodEntry) methods [i]).Index = i + 1;
 
 			//
 			// Write data sections.
 			//
 			ot.DataSectionOffset = (int) bw.BaseStream.Position;
 			foreach (SourceFileEntry source in sources)
 				source.WriteData (bw);
 			foreach (CompileUnitEntry comp_unit in comp_units)
 				comp_unit.WriteData (bw);
 			foreach (MethodEntry method in methods)
 				method.WriteData (this, bw);
 			ot.DataSectionSize = (int) bw.BaseStream.Position - ot.DataSectionOffset;
 
 			//
 			// Write the method index table.
 			//
 			ot.MethodTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < methods.Count; i++) {
 				MethodEntry entry = (MethodEntry) methods [i];
 				entry.Write (bw);
 			}
 			ot.MethodTableSize = (int) bw.BaseStream.Position - ot.MethodTableOffset;
 
 			//
 			// Write source table.
 			//
 			ot.SourceTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < sources.Count; i++) {
 				SourceFileEntry source = (SourceFileEntry) sources [i];
 				source.Write (bw);
 			}
 			ot.SourceTableSize = (int) bw.BaseStream.Position - ot.SourceTableOffset;
 
 			//
 			// Write compilation unit table.
 			//
 			ot.CompileUnitTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < comp_units.Count; i++) {
 				CompileUnitEntry unit = (CompileUnitEntry) comp_units [i];
 				unit.Write (bw);
 			}
 			ot.CompileUnitTableSize = (int) bw.BaseStream.Position - ot.CompileUnitTableOffset;
 
 			//
 			// Write anonymous scope table.
 			//
 			ot.AnonymousScopeCount = anonymous_scopes != null ? anonymous_scopes.Count 
 			ot.AnonymousScopeTableOffset = (int) bw.BaseStream.Position;
 			if (anonymous_scopes != null) {
 				foreach (AnonymousScopeEntry scope in anonymous_scopes.Values)
 					scope.Write (bw);
 			}
 			ot.AnonymousScopeTableSize = (int) bw.BaseStream.Position - ot.AnonymousScopeTableOffset;
 
 			//
 			// Fixup offset table.
 			//
 			ot.TypeCount = last_type_index;
 			ot.MethodCount = methods.Count;
 			ot.SourceCount = sources.Count;
 			ot.CompileUnitCount = comp_units.Count;
 
 			//
 			// Write offset table.
 			//
 			ot.TotalFileSize = (int) bw.BaseStream.Position;
 			bw.Seek ((int) offset_table_offset, SeekOrigin.Begin);
 			ot.Write (bw, MajorVersion, MinorVersion);
 			bw.Seek (0, SeekOrigin.End);
 
 #if false
 			Console.WriteLine ("TOTAL
 					   "{3} methods.", NumLineNumbers, LineNumberSize,
 					   ExtendedLineNumberSize, methods.Count);
 #endif
 		}
 
 		public void CreateSymbolFile (Guid guid, FileStream fs)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			Write (new MyBinaryWriter (fs), guid);
 		}
 
 		MyBinaryReader reader;
 		Dictionary<int, SourceFileEntry> source_file_hash;
 		Dictionary<int, CompileUnitEntry> compile_unit_hash;
 
 		List<MethodEntry> method_list;
 		Dictionary<int, MethodEntry> method_token_hash;
 		Dictionary<string, int> source_name_hash;
 
 		Guid guid;
 
 		MonoSymbolFile (string filename)
 		{
 			this.FileName = filename;
 			FileStream stream = new FileStream (filename, FileMode.Open, FileAccess.Read);
 			reader = new MyBinaryReader (stream);
 
 			try {
 				long magic = reader.ReadInt64 ();
 				int major_version = reader.ReadInt32 ();
 				int minor_version = reader.ReadInt32 ();
 
 				if (magic != OffsetTable.Magic)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' is not a valid " +
 						"Mono symbol file", filename);
 				if (major_version != OffsetTable.MajorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}, " +
 						"but expected {2}", filename, major_version,
 						OffsetTable.MajorVersion);
 				if (minor_version != OffsetTable.MinorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}.{2}, " +
 						"but expected {3}.{4}", filename, major_version,
 						minor_version, OffsetTable.MajorVersion,
 						OffsetTable.MinorVersion);
 
 				MajorVersion = major_version;
 				MinorVersion = minor_version;
 				guid = new Guid (reader.ReadBytes (16));
 
 				ot = new OffsetTable (reader, major_version, minor_version);
 			} catch {
 				throw new MonoSymbolFileException (
 					"Cannot read symbol file `{0}'", filename);
 			}
 
 			source_file_hash = new Dictionary<int, SourceFileEntry> ();
 			compile_unit_hash = new Dictionary<int, CompileUnitEntry> ();
 		}
 
 		void CheckGuidMatch (Guid other, string filename, string assembly)
 		{
 			if (other == guid)
 				return;
 
 			throw new MonoSymbolFileException (
 				"Symbol file `{0}' does not match assembly `{1}'",
 				filename, assembly);
 		}
 
 #if CECIL
 		protected MonoSymbolFile (string filename, Mono.Cecil.ModuleDefinition module)
 			
 		{
 			CheckGuidMatch (module.Mvid, filename, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module)
 		{
 			return ReadSymbolFile (module, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module, string filename)
 		{
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, module);
 		}
 #else
 		protected MonoSymbolFile (string filename, Assembly assembly) 
 		{
 			// Check that the MDB file matches the assembly, if we have been
 			// passed an assembly.
 			if (assembly == null)
 				return;
 			
 			Module[] modules = assembly.GetModules ();
 			Guid assembly_guid = MonoDebuggerSupport.GetGuid (modules [0]);
 
 			CheckGuidMatch (assembly_guid, filename, assembly.Location);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Assembly assembly)
 		{
 			string filename = assembly.Location;
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, assembly);
 		}
 #endif
 
 		public static MonoSymbolFile ReadSymbolFile (string mdbFilename)
 		{
 			return new MonoSymbolFile (mdbFilename, null);
 		}
 
 		public int CompileUnitCount {
 			get { return ot.CompileUnitCount; }
 		}
 
 		public int SourceCount {
 			get { return ot.SourceCount; }
 		}
 
 		public int MethodCount {
 			get { return ot.MethodCount; }
 		}
 
 		public int TypeCount {
 			get { return ot.TypeCount; }
 		}
 
 		public int AnonymousScopeCount {
 			get { return ot.AnonymousScopeCount; }
 		}
 
 		public int NamespaceCount {
 			get { return last_namespace_index; }
 		}
 
 		public Guid Guid {
 			get { return guid; }
 		}
 
 		public OffsetTable OffsetTable {
 			get { return ot; }
 		}
 
 		internal int LineNumberCount = 0;
 		internal int LocalCount = 0;
 		internal int StringSize = 0;
 
 		internal int LineNumberSize = 0;
 		internal int ExtendedLineNumberSize = 0;
 		MonoSymbolFile (string filename)
 		{
 			this.FileName = filename;
 			FileStream stream = new FileStream (filename, FileMode.Open, FileAccess.Read);
 			reader = new MyBinaryReader (stream);
 
 			try {
 				long magic = reader.ReadInt64 ();
 				int major_version = reader.ReadInt32 ();
 				int minor_version = reader.ReadInt32 ();
 
 				if (magic != OffsetTable.Magic)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' is not a valid " +
 						"Mono symbol file", filename);
 				if (major_version != OffsetTable.MajorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}, " +
 						"but expected {2}", filename, major_version,
 						OffsetTable.MajorVersion);
 				if (minor_version != OffsetTable.MinorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}.{2}, " +
 						"but expected {3}.{4}", filename, major_version,
 						minor_version, OffsetTable.MajorVersion,
 						OffsetTable.MinorVersion);
 
 				MajorVersion = major_version;
 				MinorVersion = minor_version;
 				guid = new Guid (reader.ReadBytes (16));
 
 				ot = new OffsetTable (reader, major_version, minor_version);
 			} catch {
 				throw new MonoSymbolFileException (
 					"Cannot read symbol file `{0}'", filename);
 			}
 
 			source_file_hash = new Dictionary<int, SourceFileEntry> ();
 			compile_unit_hash = new Dictionary<int, CompileUnitEntry> ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="119" endline="508">
<![CDATA[
 		int id;
 
 		// <summary>
 		//   The vector contains a BitArray with information about which local variables
 		//   and parameters are already initialized at the current code position.
 		// </summary>
 		public class UsageVector {
 			// <summary>
 			//   The type of this branching.
 			// </summary>
 			public readonly SiblingType Type;
 
 			// <summary>
 			//   Start location of this branching.
 			// </summary>
 			public Location Location;
 
 			// <summary>
 			//   This is only valid for SwitchSection, Try, Catch and Finally.
 			// </summary>
 			public readonly Block Block;
 
 			// <summary>
 			//   The number of locals in this block.
 			// </summary>
 			public readonly int CountLocals;
 
 			// <summary>
 			//   If not null, then we inherit our state from this vector and do a
 			//   copy-on-write.  If null, then we're the first sibling in a top-level
 			//   block and inherit from the empty vector.
 			// </summary>
 			public readonly UsageVector InheritsFrom;
 
 			// <summary>
 			//   This is used to construct a list of UsageVector's.
 			// </summary>
 			public UsageVector Next;
 
 			//
 			// Private.
 			//
 			MyBitVector locals;
 			bool is_unreachable;
 
 			static int next_id = 0;
 			int id;
 
 			//
 			// Normally, you should not use any of these constructors.
 			//
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc, int num_locals)
 			{
 				this.Type = type;
 				this.Block = block;
 				this.Location = loc;
 				this.InheritsFrom = parent;
 				this.CountLocals = num_locals;
 
 				locals = num_locals == 0 
 					? MyBitVector.Empty
 					
 
 				if (parent != null)
 					is_unreachable = parent.is_unreachable;
 
 				id = ++next_id;
 
 			}
 
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc)
 				
 			{ }
 
 			private UsageVector (MyBitVector locals, bool is_unreachable, Block block, Location loc)
 			{
 				this.Type = SiblingType.Block;
 				this.Location = loc;
 				this.Block = block;
 
 				this.is_unreachable = is_unreachable;
 
 				this.locals = locals;
 
 				id = ++next_id;
 
 			}
 
 			// <summary>
 			//   This does a deep copy of the usage vector.
 			// </summary>
 			public UsageVector Clone ()
 			{
 				UsageVector retval = new UsageVector (Type, null, Block, Location, CountLocals);
 
 				retval.locals = locals.Clone ();
 				retval.is_unreachable = is_unreachable;
 
 				return retval;
 			}
 
 			public bool IsAssigned (VariableInfo var, bool ignoreReachability)
 			{
 				if (!ignoreReachability && !var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsAssigned (locals);
 			}
 
 			public void SetAssigned (VariableInfo var)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetAssigned (locals);
 			}
 
 			public bool IsFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsFieldAssigned (locals, name);
 			}
 
 			public void SetFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetFieldAssigned (locals, name);
 			}
 
 			public bool IsUnreachable {
 				get { return is_unreachable; }
 			}
 
 			public void ResetBarrier ()
 			{
 				is_unreachable = false;
 			}
 
 			public void Goto ()
 			{
 				is_unreachable = true;
 			}
 
 			public static UsageVector MergeSiblings (UsageVector sibling_list, Location loc)
 			{
 				if (sibling_list.Next == null)
 					return sibling_list;
 
 				MyBitVector locals = null;
 				bool is_unreachable = sibling_list.is_unreachable;
 
 				if (!sibling_list.IsUnreachable)
 					locals &= sibling_list.locals;
 
 				for (UsageVector child = sibling_list.Next; child != null; child = child.Next) {
 					is_unreachable &= child.is_unreachable;
 
 					if (!child.IsUnreachable)
 						locals &= child.locals;
 				}
 
 				return new UsageVector (locals, is_unreachable, null, loc);
 			}
 
 			// <summary>
 			//   Merges a child branching.
 			// </summary>
 			public UsageVector MergeChild (UsageVector child, bool overwrite)
 			{
 				Report.Debug (2, "    MERGING CHILD EFFECTS", this, child, Type);
 
 				bool new_isunr = child.is_unreachable;
 
 				//
 				// We've now either reached the point after the branching or we will
 				// never get there since we always return or always throw an exception.
 				//
 				// If we can reach the point after the branching, mark all locals and
 				// parameters as initialized which have been initialized in all branches
 				// we need to look at (see above).
 				//
 
 				if ((Type == SiblingType.SwitchSection) && !new_isunr) {
 					Report.Error (163, Location,
 						      "Control cannot fall through from one " +
 						      "case label to another");
 					return child;
 				}
 
 				locals |= child.locals;
 
 				// throw away un-necessary information about variables in child blocks
 				if (locals.Count != CountLocals)
 					locals = new MyBitVector (locals, CountLocals);
 
 				if (overwrite)
 					is_unreachable = new_isunr;
 				else
 					is_unreachable |= new_isunr;
 
 				return child;
 			}
 
 			public void MergeOrigins (UsageVector o_vectors)
 			{
 				Report.Debug (1, "  MERGING BREAK ORIGINS", this);
 
 				if (o_vectors == null)
 					return;
 
 				if (IsUnreachable && locals != null)
 					locals.SetAll (true);
 
 				for (UsageVector vector = o_vectors; vector != null; vector = vector.Next) {
 					Report.Debug (1, "    MERGING BREAK ORIGIN", vector);
 					if (vector.IsUnreachable)
 						continue;
 					locals &= vector.locals;
 					is_unreachable &= vector.is_unreachable;
 				}
 
 				Report.Debug (1, "  MERGING BREAK ORIGINS DONE", this);
 			}
 
 			//
 			// Debugging stuff.
 			//
 
 			public override string ToString ()
 			{
 				return String.Format ("Vector ({0},{1},{2}-{3})", Type, id, is_unreachable, locals);
 			}
 		}
 
 		// <summary>
 		//   Creates a new flow branching which is contained in `parent'.
 		//   You should only pass non-null for the `block' argument if this block
 		//   introduces any new variables - in this case, we need to create a new
 		//   usage vector with a different size than our parent's one.
 		// </summary>
 		protected FlowBranching (FlowBranching parent, BranchingType type, SiblingType stype,
 					 Block block, Location loc)
 		{
 			Parent = parent;
 			Block = block;
 			Location = loc;
 			Type = type;
 			id = ++next_id;
 
 			UsageVector vector;
 			if (Block != null) {
 				UsageVector parent_vector = parent != null ? parent.CurrentUsageVector 
 				vector = new UsageVector (stype, parent_vector, Block, loc, Block.AssignableSlots);
 			} else {
 				vector = new UsageVector (stype, Parent.CurrentUsageVector, null, loc);
 			}
 
 			AddSibling (vector);
 		}
 
 		public abstract UsageVector CurrentUsageVector {
 			get;
 		}				
 
 		// <summary>
 		//   Creates a sibling of the current usage vector.
 		// </summary>
 		public virtual void CreateSibling (Block block, SiblingType type)
 		{
 			UsageVector vector = new UsageVector (
 				type, Parent.CurrentUsageVector, block, Location);
 			AddSibling (vector);
 
 			Report.Debug (1, "  CREATED SIBLING", CurrentUsageVector);
 		}
 
 		public void CreateSibling ()
 		{
 			CreateSibling (null, SiblingType.Conditional);
 		}
 
 		protected abstract void AddSibling (UsageVector uv);
 
 		protected abstract UsageVector Merge ();
 
 		public UsageVector MergeChild (FlowBranching child)
 		{
 			return CurrentUsageVector.MergeChild (child.Merge (), true);
  		}
 
 		public virtual bool CheckRethrow (Location loc)
 		{
 			return Parent.CheckRethrow (loc);
 		}
 
 		public virtual bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			return Parent.AddResumePoint (stmt, loc, out pc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			return Parent.AddBreakOrigin (vector, loc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			return Parent.AddContinueOrigin (vector, loc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddReturnOrigin (UsageVector vector, ExitStatement stmt)
 		{
 			return Parent.AddReturnOrigin (vector, stmt);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			return Parent.AddGotoOrigin (vector, goto_stmt);
 		}
 
 		public bool IsAssigned (VariableInfo vi)
 		{
 			return CurrentUsageVector.IsAssigned (vi, false);
 		}
 
 		public bool IsFieldAssigned (VariableInfo vi, string field_name)
 		{
 			return CurrentUsageVector.IsAssigned (vi, false) || CurrentUsageVector.IsFieldAssigned (vi, field_name);
 		}
 
 		protected static Report Report {
 			get { return RootContext.ToplevelTypes.Compiler.Report; }
 		}
 
 		public void SetAssigned (VariableInfo vi)
 		{
 			CurrentUsageVector.SetAssigned (vi);
 		}
 
 		public void SetFieldAssigned (VariableInfo vi, string name)
 		{
 			CurrentUsageVector.SetFieldAssigned (vi, name);
 		}
 
 #if DEBUG
 		public override string ToString ()
 		{
 			StringBuilder sb = new StringBuilder ();
 			sb.Append (GetType ());
 			sb.Append (" (");
 
 			sb.Append (id);
 			sb.Append (",");
 			sb.Append (Type);
 			if (Block != null) {
 				sb.Append (" - ");
 				sb.Append (Block.ID);
 				sb.Append (" - ");
 				sb.Append (Block.StartLocation);
 			}
 			sb.Append (" - ");
 			// sb.Append (Siblings.Length);
 			// sb.Append (" - ");
 			sb.Append (CurrentUsageVector);
 			sb.Append (")");
 			return sb.ToString ();
 		}
 #endif
 
 		public string Name {
 			get { return String.Format ("{0} ({1}
 		}
 	}
 
 	public class FlowBranchingBlock 
 	{
 		UsageVector sibling_list = null;
 
 		public FlowBranchingBlock (FlowBranching parent, BranchingType type,
 					   SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="136" endline="566">
<![CDATA[
 
 		public ModuleContainer (CompilerContext context)
 			
 		{
 			this.context = context;
 
 			caching_flags &= ~(Flags.Obsolete_Undetected | Flags.Excluded_Undetected);
 
 			types = new List<TypeContainer> ();
 			anonymous_types = new Dictionary<int, List<AnonymousTypeClass>> ();
 			global_ns = new GlobalRootNamespace ();
 			alias_ns = new Dictionary<string, RootNamespace> ();
 		}
 
 		#region Properties
 
  		public override AttributeTargets AttributeTargets {
  			get {
  				return AttributeTargets.Assembly;
  			}
 		}
 
 		public ModuleBuilder Builder {
 			get {
 				return builder;
 			}
 		}
 
 		public override CompilerContext Compiler {
 			get {
 				return context;
 			}
 		}
 
 		public override AssemblyDefinition DeclaringAssembly {
 			get {
 				return assembly;
 			}
 		}
 
 		public bool HasDefaultCharSet {
 			get {
 				return has_default_charset;
 			}
 		}
 
 		public bool HasExtensionMethod {
 			get {
 				return has_extenstion_method;
 			}
 			set {
 				has_extenstion_method = value;
 			}
 		}
 
 		//
 		// Returns module global
 		//
 		public RootNamespace GlobalRootNamespace {
 		    get {
 		        return global_ns;
 		    }
 		}
 
 		public override ModuleContainer Module {
 			get {
 				return this;
 			}
 		}
 
 		internal PredefinedAttributes PredefinedAttributes {
 			get {
 				return predefined_attributes;
 			}
 		}
 
 		internal PredefinedTypes PredefinedTypes {
 			get {
 				return predefined_types;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public void AddAnonymousType (AnonymousTypeClass type)
 		{
 			List<AnonymousTypeClass> existing;
 			if (!anonymous_types.TryGetValue (type.Parameters.Count, out existing))
 			if (existing == null) {
 				existing = new List<AnonymousTypeClass> ();
 				anonymous_types.Add (type.Parameters.Count, existing);
 			}
 
 			existing.Add (type);
 		}
 
 		public void AddAttributes (List<Attribute> attrs)
 		{
 			AddAttributes (attrs, this);
 		}
 
 		public void AddAttributes (List<Attribute> attrs, IMemberContext context)
 		{
 			foreach (Attribute a in attrs)
 				a.AttachTo (this, context);
 
 			if (attributes == null) {
 				attributes = new Attributes (attrs);
 				return;
 			}
 			attributes.AddAttributes (attrs);
 		}
 
 		public override TypeContainer AddPartial (TypeContainer nextPart)
 		{
 			return AddPartial (nextPart, nextPart.Name);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Assembly) {
 				assembly.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				Attribute cls = DeclaringAssembly.CLSCompliantAttribute;
 				if (cls == null) {
 					Report.Warning (3012, 1, a.Location,
 						"You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking");
 				} else if (DeclaringAssembly.IsCLSCompliant != a.GetBoolean ()) {
 					Report.SymbolRelatedToPreviousError (cls.Location, cls.GetSignatureForError ());
 					Report.Warning (3017, 1, a.Location,
 						"You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly");
 					return;
 				}
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override void CloseType ()
 		{
 			HackCorlibEnums ();
 
 			foreach (TypeContainer tc in types) {
 				tc.CloseType ();
 			}
 
 			if (compiler_generated != null)
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 		}
 
 		public TypeBuilder CreateBuilder (string name, TypeAttributes attr, int typeSize)
 		{
 			return builder.DefineType (name, attr, null, typeSize);
 		}
 
 		//
 		// Creates alias global namespace
 		//
 		public RootNamespace CreateRootNamespace (string alias)
 		{
 			if (alias == global_ns.Alias) {
 				NamespaceEntry.Error_GlobalNamespaceRedefined (Location.Null, Report);
 				return global_ns;
 			}
 
 			RootNamespace rn;
 			if (!alias_ns.TryGetValue (alias, out rn)) {
 				rn = new RootNamespace (alias);
 				alias_ns.Add (alias, rn);
 			}
 
 			return rn;
 		}
 
 		public new void Define ()
 		{
 			builder = assembly.CreateModuleBuilder ();
 
 			// FIXME
 			static_data = null;
 
 			// TODO
 			// but that require DefineType clean-up
 			ResolveGlobalAttributes ();
 
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 
 			InitializePredefinedTypes ();
 
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 		}
 
 		public override void Emit ()
 		{
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (RootContext.Unsafe) {
 				var pa = PredefinedAttributes.UnverifiableCode;
 				if (pa.IsDefined)
 					pa.EmitAttribute (builder);
 			}
 
 			foreach (var tc in types)
 				tc.DefineConstants ();
 
 			HackCorlib ();
 
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 
 			if (Compiler.Report.Errors > 0)
 				return;
 
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 
 			if (compiler_generated != null)
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 		}
 
 		public AnonymousTypeClass GetAnonymousType (IList<AnonymousTypeParameter> parameters)
 		{
 			List<AnonymousTypeClass> candidates;
 			if (!anonymous_types.TryGetValue (parameters.Count, out candidates))
 				return null;
 
 			int i;
 			foreach (AnonymousTypeClass at in candidates) {
 				for (i = 0; i < parameters.Count; ++i) {
 					if (!parameters [i].Equals (at.Parameters [i]))
 						break;
 				}
 
 				if (i == parameters.Count)
 					return at;
 			}
 
 			return null;
 		}
 
 		public RootNamespace GetRootNamespace (string name)
 		{
 			RootNamespace rn;
 			alias_ns.TryGetValue (name, out rn);
 			return rn;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return "<module>";
 		}
 
 		void HackCorlib ()
 		{
 #if !STATIC
 			if (RootContext.StdLib)
 				return;
 
 			//
 			// HACK
 			// has different predefined types and this method sets mscorlib types
 			// to be same to avoid type check errors in CreateType.
 			//
 			var type = typeof (Type);
 			var system_4_type_arg = new[] { type, type, type, type };
 
 			MethodInfo set_corlib_type_builders =
 				typeof (System.Reflection.Emit.AssemblyBuilder).GetMethod (
 				"SetCorlibTypeBuilders", BindingFlags.NonPublic | BindingFlags.Instance, null,
 				system_4_type_arg, null);
 
 			if (set_corlib_type_builders == null) {
 				Compiler.Report.Warning (-26, 3,
 					"The compilation may fail due to missing `System.Reflection.Emit.AssemblyBuilder.SetCorlibTypeBuilders(...)' method");
 				return;
 			}
 
 			object[] args = new object[4];
 			args[0] = TypeManager.object_type.GetMetaInfo ();
 			args[1] = TypeManager.value_type.GetMetaInfo ();
 			args[2] = TypeManager.enum_type.GetMetaInfo ();
 			args[3] = TypeManager.void_type.GetMetaInfo ();
 			set_corlib_type_builders.Invoke (assembly.Builder, args);
 #endif
 		}
 
 		void HackCorlibEnums ()
 		{
 			if (RootContext.StdLib)
 				return;
 
 			// Another Mono corlib HACK
 			// mono_class_layout_fields requires to have enums created
 			// before creating a class which used the enum for any of its fields
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 		}
 
 		public void InitializePredefinedTypes ()
 		{
 			predefined_attributes = new PredefinedAttributes (this);
 			predefined_types = new PredefinedTypes (this);
 		}
 
 		public override bool IsClsComplianceRequired ()
 		{
 			return DeclaringAssembly.IsCLSCompliant;
 		}
 
 		//
 		// Makes const data field inside internal type container
 		//
 		public FieldSpec MakeStaticData (byte[] data, Location loc)
 		{
 			if (static_data == null) {
 				static_data = new StaticDataContainer (this);
 				static_data.CreateType ();
 				static_data.DefineType ();
 
 				AddCompilerGeneratedClass (static_data);
 			}
 
 			return static_data.DefineInitializedData (data, loc);
 		}
 
 		protected override bool AddMemberType (TypeContainer ds)
 		{
 			if (!AddToContainer (ds, ds.Name))
 				return false;
 			ds.NamespaceEntry.NS.AddType (ds.Definition);
 			return true;
 		}
 
 		protected override void RemoveMemberType (DeclSpace ds)
 		{
 			ds.NamespaceEntry.NS.RemoveDeclSpace (ds.Basename);
 			base.RemoveMemberType (ds);
 		}
 
 		/// <summary>
 		/// It is called very early therefore can resolve only predefined attributes
 		/// </summary>
 		void ResolveGlobalAttributes ()
 		{
 			if (OptAttributes == null)
 				return;
 
 			if (!OptAttributes.CheckTargets ())
 				return;
 
 			// FIXME
 			var DefaultCharSet_attr = new PredefinedAttribute (this, "System.Runtime.InteropServices", "DefaultCharSetAttribute");
 			DefaultCharSet_attr.Define ();
 			Attribute a = ResolveModuleAttribute (DefaultCharSet_attr);
 			if (a != null) {
 				has_default_charset = true;
 				DefaultCharSet = a.GetCharSetValue ();
 				switch (DefaultCharSet) {
 				case CharSet.Ansi
 				case CharSet.None
 					break;
 				case CharSet.Auto
 					DefaultCharSetType = TypeAttributes.AutoClass;
 					break;
 				case CharSet.Unicode
 					DefaultCharSetType = TypeAttributes.UnicodeClass;
 					break;
 				default
 					Report.Error (1724, a.Location, "Value specified for the argument to `{0}' is not valid", 
 						DefaultCharSet_attr.GetSignatureForError ());
 					break;
 				}
 			}
 		}
 
 		public Attribute ResolveAssemblyAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("assembly", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
 
 		Attribute ResolveModuleAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("module", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
 
 		public void SetDeclaringAssembly (AssemblyDefinition assembly)
 		{
 			// TODO
 			this.assembly = assembly;
 		}
 	}
 
 	class RootDeclSpace 
 		public RootDeclSpace (NamespaceEntry ns)
 			
 		{
 			PartialContainer = RootContext.ToplevelTypes;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="43" endline="447">
<![CDATA[
 		
 		Expression instance_expr;
 		ReturnParameter return_attributes;
 
 		const Modifiers MethodModifiers = Modifiers.PUBLIC | Modifiers.VIRTUAL;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.UNSAFE |
 			Modifiers.PRIVATE;
 
  		public Delegate (NamespaceEntry ns, DeclSpace parent, FullNamedExpression type,
 				 Modifiers mod_flags, MemberName name, ParametersCompiled param_list,
 				 Attributes attrs)
 			
 
 		{
 			this.ReturnType = type;
 			ModFlags        = ModifiersExtensions.Check (AllowedModifiers, mod_flags,
 							   IsTopLevel ? Modifiers.INTERNAL 
 							   Modifiers.PRIVATE, name.Location, Report);
 			parameters      = param_list;
 			spec = new TypeSpec (Kind, null, this, null, ModFlags | Modifiers.SEALED);
 		}
 
 		#region Properties
 		public TypeSpec MemberType {
 			get {
 				return ReturnType.Type;
 			}
 		}
 
 		public AParametersCollection Parameters {
 			get {
 				return parameters;
 			}
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Delegate;
 			}
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			var ctor_parameters = ParametersCompiled.CreateFullyResolved (
 				new [] {
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.intptr_type, Location), "method", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					TypeManager.object_type,
 					TypeManager.intptr_type
 				}
 			);
 
 			Constructor = new Constructor (this, Constructor.ConstructorName,
 				Modifiers.PUBLIC, null, ctor_parameters, null, Location);
 			Constructor.Define ();
 
 			//
 			// Here the various methods like Invoke, BeginInvoke etc are defined
 			//
 			// First, call the `out of band' special method for
 			// defining recursively any types we need
 			//
 			var p = parameters;
 
 			if (!p.Resolve (this))
 				return false;
 
 			//
 			// Invoke method
 			//
 
 			// Check accessibility
 			foreach (var partype in p.Types) {
 				if (!IsAccessibleAs (partype)) {
 					Report.SymbolRelatedToPreviousError (partype);
 					Report.Error (59, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (partype), GetSignatureForError ());
 				}
 			}
 
 			ReturnType = ReturnType.ResolveAsTypeTerminal (this, false);
 			if (ReturnType == null)
 				return false;
 
 			var ret_type = ReturnType.Type;
 
 			//
 			// We don't have to check any others because they are all
 			// guaranteed to be accessible - they are standard types.
 			//
 			if (!IsAccessibleAs (ret_type)) {
 				Report.SymbolRelatedToPreviousError (ret_type);
 				Report.Error (58, Location,
 						  "Inconsistent accessibility
 						  TypeManager.CSharpName (ret_type) + "' is less " +
 						  "accessible than delegate `" + GetSignatureForError () + "'");
 				return false;
 			}
 
 			CheckProtectedModifier ();
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ret_type)) {
 				Method.Error1599 (Location, ret_type, Report);
 				return false;
 			}
 
 			TypeManager.CheckTypeVariance (ret_type, Variance.Covariant, this);
 
 			InvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName (InvokeMethodName), p, null);
 			InvokeBuilder.Define ();
 
 			//
 			// Don't emit async method for compiler generated delegates (e.g. dynamic site containers)
 			//
 			if (!IsCompilerGenerated) {
 				DefineAsyncMethods (Parameters.CallingConvention);
 			}
 
 			return true;
 		}
 
 		void DefineAsyncMethods (CallingConventions cc)
 		{
 			var iasync_result = Module.PredefinedTypes.IAsyncResult;
 			var async_callback = Module.PredefinedTypes.AsyncCallback;
 
 			//
 			// It's ok when async types don't exist, the delegate will have Invoke method only
 			//
 			if (!iasync_result.Define () || !async_callback.Define ())
 				return;
 
 			//
 			// BeginInvoke
 			//
 			ParametersCompiled async_parameters;
 			if (Parameters.Count == 0) {
 				async_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			} else {
 				var compiled = new Parameter[Parameters.Count];
 				for (int i = 0; i < compiled.Length; ++i) {
 					var p = parameters[i];
 					compiled[i] = new Parameter (new TypeExpression (parameters.Types[i], Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				async_parameters = new ParametersCompiled (compiled);
 			}
 
 			async_parameters = ParametersCompiled.MergeGenerated (Compiler, async_parameters, false,
 				new Parameter[] {
 					new Parameter (new TypeExpression (async_callback.TypeSpec, Location), "callback", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					async_callback.TypeSpec,
 					TypeManager.object_type
 				}
 			);
 
 			BeginInvokeBuilder = new Method (this, null,
 				new TypeExpression (iasync_result.TypeSpec, Location), MethodModifiers,
 				new MemberName ("BeginInvoke"), async_parameters, null);
 			BeginInvokeBuilder.Define ();
 
 			//
 			// EndInvoke is a bit more interesting, all the parameters labeled as
 			// out or ref have to be duplicated here.
 			//
 
 			//
 			// Define parameters, and count out/ref parameters
 			//
 			ParametersCompiled end_parameters;
 			int out_params = 0;
 
 			foreach (Parameter p in Parameters.FixedParameters) {
 				if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 					++out_params;
 			}
 
 			if (out_params > 0) {
 				Parameter[] end_params = new Parameter[out_params];
 
 				int param = 0;
 				for (int i = 0; i < Parameters.FixedParameters.Length; ++i) {
 					Parameter p = parameters [i];
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) == 0)
 						continue;
 
 					end_params [param++] = new Parameter (new TypeExpression (p.Type, Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				end_parameters = new ParametersCompiled (end_params);
 			} else {
 				end_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			}
 
 			end_parameters = ParametersCompiled.MergeGenerated (Compiler, end_parameters, false,
 				new Parameter (
 					new TypeExpression (iasync_result.TypeSpec, Location),
 					"result", Parameter.Modifier.NONE, null, Location),
 				iasync_result.TypeSpec);
 
 			//
 			// Create method, define parameters, register parameters with type system
 			//
 			EndInvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName ("EndInvoke"), end_parameters, null);
 			EndInvokeBuilder.Define ();
 		}
 
 		public override void DefineConstants ()
 		{
 			if (!Parameters.IsEmpty) {
 				parameters.ResolveDefaultValues (this);
 			}
 		}
 
 		public override void EmitType ()
 		{
 			if (ReturnType.Type != null) {
 				if (ReturnType.Type == InternalType.Dynamic) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 				} else if (ReturnType.Type.HasDynamicElement) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType.Type, Location);
 				}
 			}
 
 			Constructor.ParameterInfo.ApplyAttributes (this, Constructor.ConstructorBuilder);
 			Constructor.ConstructorBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			parameters.ApplyAttributes (this, InvokeBuilder.MethodBuilder);
 			InvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			if (BeginInvokeBuilder != null) {
 				BeginInvokeBuilder.ParameterInfo.ApplyAttributes (this, BeginInvokeBuilder.MethodBuilder);
 				EndInvokeBuilder.ParameterInfo.ApplyAttributes (this, EndInvokeBuilder.MethodBuilder);
 
 				BeginInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 				EndInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 			}
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			base.Emit ();
 		}
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.multicast_delegate_type;
 			base_class = null;
 			return null;
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed |
 					base.TypeAttr;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		//TODO
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			parameters.VerifyClsCompliance (this);
 
 			if (!ReturnType.Type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
 
 
 		public static MethodSpec GetConstructor (CompilerContext ctx, TypeSpec container_type, TypeSpec delType)
 		{
 			var ctor = MemberCache.FindMember (delType, MemberFilter.Constructor (null), BindingRestriction.DeclaredOnly);
 			return (MethodSpec) ctor;
 		}
 
 		//
 		// Returns the "Invoke" from a delegate type
 		//
 		public static MethodSpec GetInvokeMethod (CompilerContext ctx, TypeSpec delType)
 		{
 			var invoke = MemberCache.FindMember (delType,
 				MemberFilter.Method (InvokeMethodName, 0, null, null),
 				BindingRestriction.DeclaredOnly);
 
 			return (MethodSpec) invoke;
 		}
 
 		public static AParametersCollection GetParameters (CompilerContext ctx, TypeSpec delType)
 		{
 			var invoke_mb = GetInvokeMethod (ctx, delType);
 			return invoke_mb.Parameters;
 		}
 
 		//
 		// 15.2 Delegate compatibility
 		//
 		public static bool IsTypeCovariant (Expression a, TypeSpec b)
 		{
 			//
 			// For each value parameter (a parameter with no ref or out modifier), an 
 			// identity conversion or implicit reference conversion exists from the
 			// parameter type in D to the corresponding parameter type in M
 			//
 			if (a.Type == b)
 				return true;
 
 			if (RootContext.Version == LanguageVersion.ISO_1)
 				return false;
 
 			return Convert.ImplicitReferenceConversionExists (a, b);
 		}
 
 		public static string FullDelegateDesc (MethodSpec invoke_method)
 		{
 			return TypeManager.GetFullNameSignature (invoke_method).Replace (".Invoke", "");
 		}
 		
 		public Expression InstanceExpression {
 			get {
 				return instance_expr;
 			}
 			set {
 				instance_expr = value;
 			}
 		}
 	}
 
 	//
 	// Base class for `NewDelegate' and `ImplicitDelegateCreation'
 	//
 	public abstract class DelegateCreation 
 	{
 		protected MethodSpec constructor_method;
 		protected MethodGroupExpr method_group;
 
 		public static Arguments CreateDelegateMethodArguments (AParametersCollection pd, TypeSpec[] types, Location loc)
 		{
 			Arguments delegate_arguments = new Arguments (pd.Count);
 			for (int i = 0; i < pd.Count; ++i) {
 				Argument.AType atype_modifier;
 				switch (pd.FixedParameters [i].ModFlags) {
 				case Parameter.Modifier.REF
 					atype_modifier = Argument.AType.Ref;
 					break;
 				case Parameter.Modifier.OUT
 					atype_modifier = Argument.AType.Out;
 					break;
 				default
 					atype_modifier = 0;
 					break;
 				}
 
 				delegate_arguments.Add (new Argument (new TypeExpression (types [i], loc), atype_modifier));
 			}
 			for (int i = 0; i < pd.Count; ++i) {
 				Argument.AType atype_modifier;
 				switch (pd.FixedParameters [i].ModFlags) {
 				case Parameter.Modifier.REF
 					atype_modifier = Argument.AType.Ref;
 					break;
 				case Parameter.Modifier.OUT
 					atype_modifier = Argument.AType.Out;
 					break;
 				default
 					atype_modifier = 0;
 					break;
 				}
 
 				delegate_arguments.Add (new Argument (new TypeExpression (types [i], loc), atype_modifier));
 			}
 
 			return delegate_arguments;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="786" endline="1264">
<![CDATA[
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
 
 		protected Method (DeclSpace parent, FullNamedExpression return_type, Modifiers mod, Modifiers amod,
 					MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		public override TypeParameter[] CurrentTypeParameters {
 			get {
 				if (GenericMethod != null)
 					return GenericMethod.CurrentTypeParameters;
 
 				return null;
 			}
 		}
 
 		public override bool HasUnresolvedConstraints {
 			get {
 				if (CurrentTypeParameters == null)
 					return false;
 
 				// When overriding base method constraints are fetched from
 				// base method but to find it we have to resolve parameters
 				// to find exact base method match
 				if (IsExplicitImpl || (ModFlags & Modifiers.OVERRIDE) != 0)
 					return base_method == null;
 
 				// Even for non-override generic method constraints check has to be
 				// delayed after all constraints are resolved
 				return true;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				// TODO
 				return CurrentTypeParameters.Select (l => l.Type).ToArray ();
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return CurrentTypeParameters == null ? 0 
 			}
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
 
 		void Error_DuplicateEntryPoint (Method b)
 		{
 			Report.Error (17, b.Location,
 				"Program `{0}' has more than one entry point defined
 				b.Module.Builder.ScopeName, b.GetSignatureForError ());
 		}
 
 		bool IsEntryPoint ()
 		{
 			if (ReturnType != TypeManager.void_type &&
 				ReturnType != TypeManager.int32_type)
 				return false;
 
 			if (parameters.IsEmpty)
 				return true;
 
 			if (parameters.Count > 1)
 				return false;
 
 			var ac = parameters.Types [0] as ArrayContainer;
 			return ac != null && ac.Rank == 1 && ac.Element == TypeManager.string_type &&
 					(parameters[0].ModFlags & ~Parameter.Modifier.PARAMS) == Parameter.Modifier.NONE;
 		}
 
 		public override FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			if (arity == 0) {
 				TypeParameter[] tp = CurrentTypeParameters;
 				if (tp != null) {
 					TypeParameter t = TypeParameter.FindTypeParameter (tp, name);
 					if (t != null)
 						return new TypeParameterExpr (t, loc);
 				}
 			}
 
 			return base.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				if (IsExplicitImpl) {
 					Error_ConditionalAttributeIsNotValid ();
 					return;
 				}
 
 				if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 					Report.Error (243, Location, "Conditional not valid on `{0}' because it is an override method", GetSignatureForError ());
 					return;
 				}
 
 				if (ReturnType != TypeManager.void_type) {
 					Report.Error (578, Location, "Conditional not valid on `{0}' because its return type is not void", GetSignatureForError ());
 					return;
 				}
 
 				if (IsInterface) {
 					Report.Error (582, Location, "Conditional not valid on interface members");
 					return;
 				}
 
 				if (MethodData.implementing != null) {
 					Report.SymbolRelatedToPreviousError (MethodData.implementing.DeclaringType);
 					Report.Error (629, Location, "Conditional member `{0}' cannot implement interface member `{1}'",
 						GetSignatureForError (), TypeManager.CSharpSignature (MethodData.implementing));
 					return;
 				}
 
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		protected virtual void DefineTypeParameters ()
 		{
 			var tparams = CurrentTypeParameters;
 
 			TypeParameterSpec[] base_tparams = null;
 			TypeParameterSpec[] base_decl_tparams = TypeParameterSpec.EmptyTypes;
 			TypeSpec[] base_targs = TypeSpec.EmptyTypes;
 			if (((ModFlags & Modifiers.OVERRIDE) != 0 || IsExplicitImpl)) {
 				if (base_method != null) {
 					base_tparams = base_method.GenericDefinition.TypeParameters;
 				
 					if (base_method.DeclaringType.IsGeneric) {
 						base_decl_tparams = base_method.DeclaringType.MemberDefinition.TypeParameters;
 
 						var base_type_parent = CurrentType;
 						while (base_type_parent.BaseType != base_method.DeclaringType) {
 							base_type_parent = base_type_parent.BaseType;
 						}
 
 						base_targs = base_type_parent.BaseType.TypeArguments;
 					}
 
 					if (base_method.IsGeneric) {
 						ObsoleteAttribute oa;
 						foreach (var base_tp in base_tparams) {
 							oa = base_tp.BaseType.GetAttributeObsolete ();
 							if (oa != null) {
 								AttributeTester.Report_ObsoleteMessage (oa, base_tp.BaseType.GetSignatureForError (), Location, Report);
 							}
 
 							if (base_tp.InterfacesDefined != null) {
 								foreach (var iface in base_tp.InterfacesDefined) {
 									oa = iface.GetAttributeObsolete ();
 									if (oa != null) {
 										AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 									}
 								}
 							}
 						}
 
 						if (base_decl_tparams.Length != 0) {
 							base_decl_tparams = base_decl_tparams.Concat (base_tparams).ToArray ();
 							base_targs = base_targs.Concat (tparams.Select<TypeParameter, TypeSpec> (l => l.Type)).ToArray ();
 						} else {
 							base_decl_tparams = base_tparams;
 							base_targs = tparams.Select (l => l.Type).ToArray ();
 						}
 					}
 				} else if (MethodData.implementing != null) {
 					base_tparams = MethodData.implementing.GenericDefinition.TypeParameters;
 					if (MethodData.implementing.DeclaringType.IsGeneric) {
 						base_decl_tparams = MethodData.implementing.DeclaringType.MemberDefinition.TypeParameters;
 						foreach (var iface in Parent.CurrentType.Interfaces) {
 							if (iface == MethodData.implementing.DeclaringType) {
 								base_targs = iface.TypeArguments;
 								break;
 							}
 						}
 					}
 				}
 			}
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 
 				if (!tp.ResolveConstraints (this))
 					continue;
 
 				//
 				// Copy base constraints for override/explicit methods
 				//
 				if (base_tparams != null) {
 					var base_tparam = base_tparams[i];
 					var local_tparam = tp.Type;
 					local_tparam.SpecialConstraint = base_tparam.SpecialConstraint;
 
 					var inflator = new TypeParameterInflator (CurrentType, base_decl_tparams, base_targs);
 					base_tparam.InflateConstraints (inflator, local_tparam);
 
 					//
 					// Check all type argument constraints for possible collision
 					// introduced by inflating inherited constraints in this context
 					//
 					// Conflict example
 					//
 					// class A<T> { virtual void Foo<U> () where U 
 					// class B 
 					//
 					var local_tparam_targs = local_tparam.TypeArguments;
 					if (local_tparam_targs != null) {					
 						for (int ii = 0; ii < local_tparam_targs.Length; ++ii) {
 							var ta = local_tparam_targs [ii];
 							if (!ta.IsClass && !ta.IsStruct)
 								continue;
 
 							if (Constraints.CheckConflictingInheritedConstraint (local_tparam, ta, this, Location)) {
 								local_tparam.ChangeTypeArgumentToBaseType (ii);
 							}
 						}
 					}
 
 					continue;
 				}
 				
 				if (MethodData.implementing != null) {
 					var base_tp = MethodData.implementing.Constraints[i];
 					if (!tp.Type.HasSameConstraintsImplementation (base_tp)) {
 						Report.SymbolRelatedToPreviousError (MethodData.implementing);
 						Report.Error (425, Location,
 							"The constraints for type parameter `{0}' of method `{1}' must match the constraints for type parameter `{2}' of interface method `{3}'. Consider using an explicit interface implementation instead",
 							tp.GetSignatureForError (), GetSignatureForError (), base_tp.GetSignatureForError (), MethodData.implementing.GetSignatureForError ());
 					}
 				}
 			}
 		}
 
 		//
 		// Creates the type
 		//
 		public override bool Define ()
 		{
 			if (type_expr.Type == TypeManager.void_type && parameters.IsEmpty && MemberName.Arity == 0 && MemberName.Name == Destructor.MetadataName) {
 				Report.Warning (465, 1, Location, "Introducing `Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?");
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (partialMethodImplementation != null && IsPartialDefinition)
 				MethodBuilder = partialMethodImplementation.MethodBuilder;
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ReturnType)) {
 				Error1599 (Location, ReturnType, Report);
 				return false;
 			}
 
 			if (CurrentTypeParameters == null) {
 				if (base_method != null) {
 					if (parameters.Count == 1 && ParameterTypes[0] == TypeManager.object_type && Name == "Equals")
 						Parent.PartialContainer.Mark_HasEquals ();
 					else if (parameters.IsEmpty && Name == "GetHashCode")
 						Parent.PartialContainer.Mark_HasGetHashCode ();
 				}
 					
 			} else {
 				DefineTypeParameters ();
 			}
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			if ((ModFlags & Modifiers.STATIC) == 0)
 				return true;
 
 			if (parameters.HasExtensionMethodType) {
 				if (Parent.PartialContainer.IsStatic && !Parent.IsGeneric) {
 					if (!Parent.IsTopLevel)
 						Report.Error (1109, Location, "`{0}'
 							GetSignatureForError ());
 
 					PredefinedAttribute pa = Module.PredefinedAttributes.Extension;
 					if (!pa.IsDefined) {
 						Report.Error (1110, Location,
 							"`{0}'
 							GetSignatureForError ());
 					}
 
 					ModFlags |= Modifiers.METHOD_EXTENSION;
 					Parent.PartialContainer.ModFlags |= Modifiers.METHOD_EXTENSION;
 					Spec.DeclaringType.SetExtensionMethodContainer ();
 					Parent.Module.HasExtensionMethod = true;
 				} else {
 					Report.Error (1106, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 
 			//
 			// This is used to track the Entry Point,
 			//
 			if (RootContext.NeedsEntryPoint &&
 				Name == "Main" &&
 				(RootContext.MainClass == null ||
 				RootContext.MainClass == Parent.TypeBuilder.FullName)){
 				if (IsEntryPoint ()) {
 
 					if (Parent.DeclaringAssembly.EntryPoint == null) {
 						if (Parent.IsGeneric || MemberName.IsGeneric) {
 							Report.Warning (402, 4, Location, "`{0}'
 								GetSignatureForError ());
 						} else {
 							SetIsUsed ();
 							Parent.DeclaringAssembly.EntryPoint = this;
 						}
 					} else {
 						Error_DuplicateEntryPoint (Parent.DeclaringAssembly.EntryPoint);
 						Error_DuplicateEntryPoint (this);
 					}
 				} else {
 					Report.Warning (28, 4, Location, "`{0}' has the wrong signature to be an entry point",
 						GetSignatureForError ());
 				}
 			}
 
 			return true;
 		}
 
 		//
 		// Emits the code
 		// 
 		public override void Emit ()
 		{
 			try {
 				if (IsPartialDefinition) {
 					//
 					// Use partial method implementation builder for partial method declaration attributes
 					//
 					if (partialMethodImplementation != null) {
 						MethodBuilder = partialMethodImplementation.MethodBuilder;
 					}
 
 					return;
 				}
 				
 				if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.PartialDefinitionExists) == 0) {
 					Report.Error (759, Location, "A partial method `{0}' implementation is missing a partial method declaration",
 						GetSignatureForError ());
 				}
 
 				if (CurrentTypeParameters != null) {
 					var ge = type_expr as GenericTypeExpr;
 					if (ge != null)
 						ge.CheckConstraints (this);
 
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 				}
 
 				base.Emit ();
 				
 				if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 					Module.PredefinedAttributes.Extension.EmitAttribute (MethodBuilder);
 			} catch {
 				Console.WriteLine ("Internal compiler error at {0}
 						   Location, MethodBuilder);
 				throw;
 			}
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			// TODO
 			if (overload is Operator)
 				return overload.EnableOverloadChecks (this);
 
 			if (overload is Indexer)
 				return false;
 
 			return base.EnableOverloadChecks (overload);
 		}
 
 		public static void Error1599 (Location loc, TypeSpec t, Report Report)
 		{
 			Report.Error (1599, loc, "Method or delegate cannot return type `{0}'", TypeManager.CSharpName (t));
 		}
 
 		protected override bool ResolveMemberType ()
 		{
 			if (GenericMethod != null) {
 				MethodBuilder = Parent.TypeBuilder.DefineMethod (GetFullName (MemberName), flags);
 				if (!GenericMethod.Define (this))
 					return false;
 			}
 
 			return base.ResolveMemberType ();
 		}
 
 		public void SetPartialDefinition (Method methodDefinition)
 		{
 			caching_flags |= Flags.PartialDefinitionExists;
 			methodDefinition.partialMethodImplementation = this;
 
 			// Ensure we are always using method declaration parameters
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 
 			if (methodDefinition.attributes == null)
 				return;
 
 			if (attributes == null) {
 				attributes = methodDefinition.attributes;
 			} else {
 				attributes.Attrs.AddRange (methodDefinition.attributes.Attrs);
 			}
 		}
 	}
 
 	public abstract class ConstructorInitializer 
 	{
 		Arguments argument_list;
 		MethodSpec base_ctor;
 
 		public ConstructorInitializer (Arguments argument_list, Location loc)
 		{
 			this.argument_list = argument_list;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="718" endline="1185">
<![CDATA[
 				switch (ExplicitTarget) {
 				case "return"
 				case "param"
 				case "field"
 				case "method"
 				case "property"
 				case "module"
 				}
 				throw new InternalErrorException ("Unknown explicit target
 			}
 				
 			StringBuilder sb = new StringBuilder ();
 			foreach (string s in valid_targets) {
 				sb.Append (s);
 				sb.Append (", ");
 			}
 			sb.Remove (sb.Length - 2, 2);
 			Report.Error (657, Location, "`{0}' is not a valid attribute location for this declaration. " +
 				"Valid attribute locations for this declaration are `{1}'", ExplicitTarget, sb.ToString ());
 			return false;
 		}
 
 		/// <summary>
 		/// Tests permitted SecurityAction for assembly or other types
 		/// </summary>
 		protected virtual bool IsSecurityActionValid (bool for_assembly)
 		{
 			SecurityAction action = GetSecurityActionValue ();
 
 			switch (action) {
 #pragma warning disable 618
 			case SecurityAction.Demand
 			case SecurityAction.Assert
 			case SecurityAction.Deny
 			case SecurityAction.PermitOnly
 			case SecurityAction.LinkDemand
 			case SecurityAction.InheritanceDemand
 				if (!for_assembly)
 					return true;
 				break;
 
 			case SecurityAction.RequestMinimum
 			case SecurityAction.RequestOptional
 			case SecurityAction.RequestRefuse
 				if (for_assembly)
 					return true;
 				break;
 #pragma warning restore 618
 
 			default
 				Error_AttributeEmitError ("SecurityAction is out of range");
 				return false;
 			}
 
 			Error_AttributeEmitError (String.Concat ("SecurityAction `", action, "' is not valid for this declaration"));
 			return false;
 		}
 
 		System.Security.Permissions.SecurityAction GetSecurityActionValue ()
 		{
 			return (SecurityAction) ((Constant) PosArguments[0].Expr).GetValue ();
 		}
 
 		/// <summary>
 		/// Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
 		/// </summary>
 		/// <returns></returns>
 		public void ExtractSecurityPermissionSet (MethodSpec ctor, ref SecurityType permissions)
 		{
 #if STATIC
 			object[] values = new object [PosArguments.Count];
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 
 			PropertyInfo[] prop;
 			object[] prop_values;
 			if (named_values == null) {
 				prop = null;
 				prop_values = null;
 			} else {
 				prop = new PropertyInfo[named_values.Count];
 				prop_values = new object [named_values.Count];
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			var cab = new CustomAttributeBuilder ((ConstructorInfo) ctor.GetMetaInfo (), values, prop, prop_values);
 			permissions.Add (cab);
 #else
 			Type orig_assembly_type = null;
 
 			if (Type.MemberDefinition is TypeContainer) {
 				if (!RootContext.StdLib) {
 					orig_assembly_type = System.Type.GetType (Type.GetMetaInfo ().FullName);
 				} else {
 					string orig_version_path = Environment.GetEnvironmentVariable ("__SECURITY_BOOTSTRAP_DB");
 					if (orig_version_path == null) {
 						Error_AttributeEmitError ("security custom attributes can not be referenced from defining assembly");
 						return;
 					}
 
 					if (orig_sec_assembly == null) {
 						string file = Path.Combine (orig_version_path, Path.GetFileName (RootContext.OutputFile));
 						orig_sec_assembly = Assembly.LoadFile (file);
 					}
 
 					orig_assembly_type = orig_sec_assembly.GetType (Type.GetMetaInfo ().FullName, true);
 					if (orig_assembly_type == null) {
 						Report.Warning (-112, 1, Location, "Self-referenced security attribute `{0}' " +
 								"was not found in previous version of assembly");
 						return;
 					}
 				}
 			}
 
 			SecurityAttribute sa;
 			object[] args;
 
 			// For all non-selfreferencing security attributes we can avoid all hacks
 			if (orig_assembly_type == null) {
 				args = new object[PosArguments.Count];
 				for (int j = 0; j < args.Length; ++j) {
 					args[j] = ((Constant) PosArguments[j].Expr).GetValue ();
 				}
 
 				sa = (SecurityAttribute) Activator.CreateInstance (Type.GetMetaInfo (), args);
 
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						pi.SetValue (sa, ((Constant) named_values [i].Value.Expr).GetValue (), null);
 					}
 				}
 			} else {
 				// HACK
 				args = new object[] { GetSecurityActionValue () };
 				sa = (SecurityAttribute) Activator.CreateInstance (orig_assembly_type, args);
 
 				// All types are from newly created assembly but for invocation with old one we need to convert them
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo emited_pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						// FIXME
 						// TODO
 						PropertyInfo pi = orig_assembly_type.GetProperty (emited_pi.Name);
 
 						pi.SetValue (sa, ((Constant) named_values[i].Value.Expr).GetValue (), null);
 					}
 				}
 			}
 
 			IPermission perm;
 			perm = sa.CreatePermission ();
 			SecurityAction action = (SecurityAction) args [0];
 
 			// IS is correct because for corlib we are using an instance from old corlib
 			if (!(perm is System.Security.CodeAccessPermission)) {
 				switch (action) {
 				case SecurityAction.Demand
 					action = (SecurityAction)13;
 					break;
 				case SecurityAction.LinkDemand
 					action = (SecurityAction)14;
 					break;
 				case SecurityAction.InheritanceDemand
 					action = (SecurityAction)15;
 					break;
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			PermissionSet ps;
 			if (!permissions.TryGetValue (action, out ps)) {
 				if (sa is PermissionSetAttribute)
 					ps = new PermissionSet (sa.Unrestricted ? PermissionState.Unrestricted 
 				else
 					ps = new PermissionSet (PermissionState.None);
 
 				permissions.Add (action, ps);
 			} else if (!ps.IsUnrestricted () && (sa is PermissionSetAttribute) && sa.Unrestricted) {
 				ps = ps.Union (new PermissionSet (PermissionState.Unrestricted));
 				permissions [action] = ps;
 			}
 			ps.AddPermission (perm);
 #endif
 		}
 
 		public Constant GetNamedValue (string name)
 		{
 			if (named_values == null)
 				return null;
 
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 
 			return null;
 		}
 
 		public CharSet GetCharSetValue ()
 		{
 			return (CharSet)System.Enum.Parse (typeof (CharSet), ((Constant) PosArguments [0].Expr).GetValue ().ToString ());
 		}
 
 		public bool HasField (string fieldName)
 		{
 			if (named_values == null)
 				return false;
 
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 
 			return false;
 		}
 
 		//
 		// Returns true for MethodImplAttribute with MethodImplOptions.InternalCall value
 		// 
 		public bool IsInternalCall ()
 		{
 			MethodImplOptions options = 0;
 			if (PosArguments.Count == 1) {
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			} else if (HasField ("Value")) {
 				var named = GetNamedValue ("Value");
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), named.GetValue ().ToString ());
 			}
 
 			return (options & MethodImplOptions.InternalCall) != 0;
 		}
 
 		//
 		// Returns true for StructLayoutAttribute with LayoutKind.Explicit value
 		// 
 		public bool IsExplicitLayoutKind ()
 		{
 			if (PosArguments == null || PosArguments.Count != 1)
 				return false;
 
 			var value = (LayoutKind) System.Enum.Parse (typeof (LayoutKind), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			return value == LayoutKind.Explicit;
 		}
 
 		public Expression GetParameterDefaultValue ()
 		{
 			if (PosArguments == null)
 				return null;
 
 			return PosArguments[0].Expr;
 		}
 
 		public override bool Equals (object obj)
 		{
 			Attribute a = obj as Attribute;
 			if (a == null)
 				return false;
 
 			return Type == a.Type && Target == a.Target;
 		}
 
 		public override int GetHashCode ()
 		{
 			return type.GetHashCode () ^ Target.GetHashCode ();
 		}
 
 		/// <summary>
 		/// Emit attribute for Attributable symbol
 		/// </summary>
 		public void Emit (Dictionary<Attribute, List<Attribute>> allEmitted)
 		{
 			var ctor = Resolve ();
 			if (ctor == null)
 				return;
 
 			var predefined = context.Module.PredefinedAttributes;
 
 			AttributeUsageAttribute usage_attr = Type.GetAttributeUsage (predefined.AttributeUsage);
 			if ((usage_attr.ValidOn & Target) == 0) {
 				Report.Error (592, Location, "The attribute `{0}' is not valid on this declaration type. " +
 					      "It is valid on `{1}' declarations only",
 					GetSignatureForError (), GetValidTargets ());
 				return;
 			}
 
 			byte[] cdata;
 			if (PosArguments == null && named_values == null) {
 				cdata = AttributeEncoder.Empty;
 			} else {
 				AttributeEncoder encoder = new AttributeEncoder ();
 
 				if (PosArguments != null) {
 					var param_types = ctor.Parameters.Types;
 					for (int j = 0; j < PosArguments.Count; ++j) {
 						var pt = param_types[j];
 						var arg_expr = PosArguments[j].Expr;
 						if (j == 0) {
 							if (Type == predefined.IndexerName || Type == predefined.Conditional) {
 								string v = ((StringConstant) arg_expr).Value;
 								if (!Tokenizer.IsValidIdentifier (v) || Tokenizer.IsKeyword (v)) {
 									context.Compiler.Report.Error (633, arg_expr.Location,
 										"The argument to the `{0}' attribute must be a valid identifier", GetSignatureForError ());
 								}
 							} else if (Type == predefined.Guid) {
 								try {
 									string v = ((StringConstant) arg_expr).Value;
 									new Guid (v);
 								} catch (Exception e) {
 									Error_AttributeEmitError (e.Message);
 									return;
 								}
 							} else if (Type == predefined.AttributeUsage) {
 								int v = ((IntConstant) ((EnumConstant) arg_expr).Child).Value;
 								if (v == 0) {
 									context.Compiler.Report.Error (591, Location, "Invalid value for argument to `{0}' attribute",
 										"System.AttributeUsage");
 								}
 							} else if (Type == predefined.MarshalAs) {
 								if (PosArguments.Count == 1) {
 									var u_type = (UnmanagedType) System.Enum.Parse (typeof (UnmanagedType), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 									if (u_type == UnmanagedType.ByValArray && !(Owner is FieldBase)) {
 										Error_AttributeEmitError ("Specified unmanaged type is only valid on fields");
 									}
 								}
 							} else if (Type == predefined.DllImport) {
 								if (PosArguments.Count == 1) {
 									var value = ((Constant) PosArguments[0].Expr).GetValue () as string;
 									if (string.IsNullOrEmpty (value))
 										Error_AttributeEmitError ("DllName cannot be empty");
 								}
 							} else if (Type == predefined.MethodImpl && pt == TypeManager.short_type &&
 								!System.Enum.IsDefined (typeof (MethodImplOptions), ((Constant) arg_expr).GetValue ().ToString ())) {
 								Error_AttributeEmitError ("Incorrect argument value.");
 								return;
 							}
 						}
 
 						arg_expr.EncodeAttributeValue (context, encoder, pt);
 					}
 				}
 
 				if (named_values != null) {
 					encoder.Encode ((ushort) named_values.Count);
 					foreach (var na in named_values) {
 						if (na.Key is FieldExpr)
 							encoder.Encode ((byte) 0x53);
 						else
 							encoder.Encode ((byte) 0x54);
 
 						encoder.Encode (na.Key.Type);
 						encoder.Encode (na.Value.Name);
 						na.Value.Expr.EncodeAttributeValue (context, encoder, na.Key.Type);
 					}
 				} else {
 					encoder.EncodeEmptyNamedArguments ();
 				}
 
 				cdata = encoder.ToArray ();
 			}
 
 			try {
 				foreach (Attributable target in targets)
 					target.ApplyAttributeBuilder (this, ctor, cdata, predefined);
 			} catch (Exception e) {
 				Error_AttributeEmitError (e.Message);
 				return;
 			}
 
 			if (!usage_attr.AllowMultiple && allEmitted != null) {
 				if (allEmitted.ContainsKey (this)) {
 					var a = allEmitted [this];
 					if (a == null) {
 						a = new List<Attribute> (2);
 						allEmitted [this] = a;
 					}
 					a.Add (this);
 				} else {
 					allEmitted.Add (this, null);
 				}
 			}
 
 			if (!RootContext.VerifyClsCompliance)
 				return;
 
 			// Here we are testing attribute arguments for array usage (error 3016)
 			if (Owner.IsClsComplianceRequired ()) {
 				if (PosArguments != null)
 					PosArguments.CheckArrayAsAttribute (context.Compiler);
 			
 				if (NamedArguments == null)
 					return;
 
 				NamedArguments.CheckArrayAsAttribute (context.Compiler);
 			}
 		}
 
 		private Expression GetValue () 
 		{
 			if (PosArguments == null || PosArguments.Count < 1)
 				return null;
 
 			return PosArguments [0].Expr;
 		}
 
 		public string GetString () 
 		{
 			Expression e = GetValue ();
 			if (e is StringConstant)
 				return ((StringConstant)e).Value;
 			return null;
 		}
 
 		public bool GetBoolean () 
 		{
 			Expression e = GetValue ();
 			if (e is BoolConstant)
 				return ((BoolConstant)e).Value;
 			return false;
 		}
 
 		public TypeSpec GetArgumentType ()
 		{
 			TypeOf e = GetValue () as TypeOf;
 			if (e == null)
 				return null;
 			return e.TypeArgument;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			throw new NotSupportedException ("ET");
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 	}
 	
 
 	/// <summary>
 	/// For global attributes (assembly, module) we need special handling.
 	/// Attributes can be located in the several files
 	/// </summary>
 	public class GlobalAttribute 
 	{
 		public readonly NamespaceEntry ns;
 
 		public GlobalAttribute (NamespaceEntry ns, string target, ATypeNameExpression expression,
 					Arguments[] args, Location loc, bool nameEscaped)
 			base (target, expression, args, loc, nameEscaped)
 		{
 			this.ns = ns;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="35" endline="503">
<![CDATA[
 
 #if !STATIC
 		// Reflection Emit hacking
 		static readonly Type TypeBuilder;
 		static readonly Type GenericTypeBuilder;
 
 		static TypeSpec ()
 		{
 			var assembly = typeof (object).Assembly;
 			TypeBuilder = assembly.GetType ("System.Reflection.Emit.TypeBuilder");
 			GenericTypeBuilder = assembly.GetType ("System.Reflection.MonoGenericClass");
 			if (GenericTypeBuilder == null)
 				GenericTypeBuilder = assembly.GetType ("System.Reflection.Emit.TypeBuilderInstantiation");
 		}
 #endif
 
 		public TypeSpec (MemberKind kind, TypeSpec declaringType, ITypeDefinition definition, MetaType info, Modifiers modifiers)
 			
 		{
 			this.declaringType = declaringType;
 			this.info = info;
 
 			if (definition != null && definition.TypeParametersCount > 0)
 				state |= StateFlags.IsGeneric;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return MemberDefinition.TypeParametersCount;
 			}
 		}
 
 		public virtual TypeSpec BaseType {
 			get {
 				return base_type;
 			}
 			set {
 				base_type = value;
 			}
 		}
 
 		public virtual BuildinTypeSpec.Type BuildinType {
 			get {
 				return BuildinTypeSpec.Type.None;
 			}
 		}
 
 		public bool HasDynamicElement {
 			get {
 				return (state & StateFlags.HasDynamicElement) != 0;
 			}
 		}
 
 		public virtual IList<TypeSpec> Interfaces {
 			get {
 				return ifaces;
 			}
 			set {
 				ifaces = value;
 			}
 		}
 
 		public bool IsArray {
 			get {
 				return Kind == MemberKind.ArrayType;
 			}
 		}
 
 		public bool IsAttribute {
 			get {
 				if (!IsClass)
 					return false;
 
 				var type = this;
 				do {
 					if (type.IsGeneric)
 						return false;
 
 					if (type == TypeManager.attribute_type)
 						return true;
 					
 					type = type.base_type;
 				} while (type != null);
 
 				return false;
 			}
 		}
 
 		public bool IsInterface {
 			get {
 				return Kind == MemberKind.Interface;
 			}
 		}
 
 		public bool IsClass {
 			get {
 				return Kind == MemberKind.Class;
 			}
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
 		}
 
 		public bool IsDelegate {
 			get {
 				return Kind == MemberKind.Delegate;
 			}
 		}
 
 		public bool IsEnum {
 			get { return Kind == MemberKind.Enum; }
 		}
 
 		// TODO
 		// IsGenericType -- recursive
 		// HasTypeParameter -- non-recursive
 		public bool IsGenericOrParentIsGeneric {
 			get {
 				var ts = this;
 				do {
 					if (ts.IsGeneric)
 						return true;
 					ts = ts.declaringType;
 				} while (ts != null);
 
 				return false;
 			}
 		}
 
 		public bool IsGenericParameter {
 			get { return Kind == MemberKind.TypeParameter; }
 		}
 
 		public bool IsNested {
 			get { return declaringType != null && Kind != MemberKind.TypeParameter; }
 		}
 
 		public bool IsPointer {
 			get {
 				return Kind == MemberKind.PointerType;
 			}
 		}
 
 		public bool IsSealed {
 			get { return (Modifiers & Modifiers.SEALED) != 0; }
 		}
 
 		public bool IsStruct {
 			get { 
 				return Kind == MemberKind.Struct;
 			}
 		}
 
 		public bool IsTypeBuilder {
 			get {
 #if STATIC
 				return true;
 #else
 				var meta = GetMetaInfo().GetType ();
 				return meta == TypeBuilder || meta == GenericTypeBuilder;
 #endif
 			}
 		}
 
 		public MemberCache MemberCache {
 			get {
 				if (cache == null || (state & StateFlags.PendingMemberCacheMembers) != 0)
 					InitializeMemberCache (false);
 
 				return cache;
 			}
 			set {
 				if (cache != null)
 					throw new InternalErrorException ("Membercache reset");
 
 				cache = value;
 			}
 		}
 
 		public MemberCache MemberCacheTypes {
 			get {
 				if (cache == null)
 					InitializeMemberCache (true);
 
 				return cache;
 			}
 		}	
 
 		public new ITypeDefinition MemberDefinition {
 			get {
 				return (ITypeDefinition) definition;
 			}
 		}
 
 		// TODO
 		// remove the property, YES IT WOULD !!!
 		public virtual TypeSpec[] TypeArguments {
 			get { return TypeSpec.EmptyTypes; }
 		}
 
 		#endregion
 
 		public bool AddInterface (TypeSpec iface)
 		{
 			if ((state & StateFlags.InterfacesExpanded) != 0)
 				throw new InternalErrorException ("Modifying expanded interface list");
 
 			if (ifaces == null) {
 				ifaces = new List<TypeSpec> () { iface };
 				return true;
 			}
 
 			if (!ifaces.Contains (iface)) {
 				ifaces.Add (iface);
 				return true;
 			}
 
 			return false;
 		}
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (Kind != MemberKind.Class)
 				throw new InternalErrorException ();
 
 			if (!pa.IsDefined)
 				return Attribute.DefaultUsageAttribute;
 
 			AttributeUsageAttribute aua = null;
 			var type = this;
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 
 			return aua;
 		}
 
 		public virtual MetaType GetMetaInfo ()
 		{
 			return info;
 		}
 
 		public virtual TypeSpec GetDefinition ()
 		{
 			return this;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string s;
 
 			if (IsNested) {
 				s = DeclaringType.GetSignatureForError ();
 			} else if (MemberDefinition is AnonymousTypeClass) {
 				return ((AnonymousTypeClass) MemberDefinition).GetSignatureForError ();
 			} else {
 				s = MemberDefinition.Namespace;
 			}
 
 			if (!string.IsNullOrEmpty (s))
 				s += ".";
 
 			return s + Name + GetTypeNameSignature ();
 		}
 
 		protected virtual string GetTypeNameSignature ()
 		{
 			if (!IsGeneric)
 				return null;
 
 			return "<" + TypeManager.CSharpName (MemberDefinition.TypeParameters) + ">";
 		}
 
 		public bool ImplementsInterface (TypeSpec iface, bool variantly)
 		{
 			var t = this;
 			do {
 				if (t.Interfaces != null) {	// TODO
 					foreach (TypeSpec i in t.Interfaces) {
 						if (i == iface || TypeSpecComparer.IsEqual (i, iface))
 							return true;
 
 						if (variantly && TypeSpecComparer.Variant.IsEqual (i, iface))
 							return true;
 					}
 				}
 
 				t = t.BaseType;
 			} while (t != null);
 
 			return false;
 		}
 
 		protected virtual void InitializeMemberCache (bool onlyTypes)
 		{
 			MemberDefinition.LoadMembers (this, onlyTypes, ref cache);
 
 			if (onlyTypes)
 				state |= StateFlags.PendingMemberCacheMembers;
 			else
 				state &= ~StateFlags.PendingMemberCacheMembers;
 		}
 
 		//
 		// Is @baseClass base implementation of @type. With enabled @dynamicIsEqual the slower
 		// comparison is used to hide differences between `object' and `dynamic' for generic
 		// types. Should not be used for comparisons where G<object> != G<dynamic>
 		//
 		public static bool IsBaseClass (TypeSpec type, TypeSpec baseClass, bool dynamicIsObject)
 		{
 			if (dynamicIsObject && baseClass.IsGeneric) {
 				//
 				// Returns true for a hierarchies like this when passing baseClass of A<dynamic>
 				//
 				// class B 
 				//
 				while (type != null) {
 					type = type.BaseType;
 					if (TypeSpecComparer.IsEqual (type, baseClass))
 						return true;
 				}
 
 				return false;
 			}
 
 			while (type != null) {
 				type = type.BaseType;
 				if (type == baseClass)
 					return true;
 			}
 
 			return false;
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var targs = IsGeneric ? MemberDefinition.TypeParameters 
 
 			//
 			// When inflating nested type from inside the type instance will be same
 			// because type parameters are same for all nested types
 			//
 			if (DeclaringType == inflator.TypeInstance) {
 				return MakeGenericType (targs);
 			}
 
 			return new InflatedTypeSpec (this, inflator.TypeInstance, targs);
 		}
 
 		public InflatedTypeSpec MakeGenericType (TypeSpec[] targs)
 		{
 			if (targs.Length == 0 && !IsNested)
 				throw new ArgumentException ("Empty type arguments for type " + GetSignatureForError ());
 
 			InflatedTypeSpec instance;
 
 			if (inflated_instances == null) {
 				inflated_instances = new Dictionary<TypeSpec[], InflatedTypeSpec> (TypeSpecComparer.Default);
 
 				if (IsNested) {
 					instance = this as InflatedTypeSpec;
 					if (instance != null) {
 						//
 						// Nested types could be inflated on already inflated instances
 						// Caching this type ensured we are using same instance for
 						// inside/outside inflation using local type parameters
 						//
 						inflated_instances.Add (TypeArguments, instance);
 					}
 				}
 			}
 
 			if (!inflated_instances.TryGetValue (targs, out instance)) {
 				if (GetDefinition () != this && !IsNested)
 					throw new InternalErrorException ("`{0}' must be type definition or nested non-inflated type to MakeGenericType",
 						GetSignatureForError ());
 
 				instance = new InflatedTypeSpec (this, declaringType, targs);
 				inflated_instances.Add (targs, instance);
 			}
 
 			return instance;
 		}
 
 		public virtual TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			return this;
 		}
 
 		public void SetMetaInfo (MetaType info)
 		{
 			if (this.info != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.info = info;
 		}
 
 		public void SetExtensionMethodContainer ()
 		{
 			modifiers |= Modifiers.METHOD_EXTENSION;
 		}
 	}
 
 	public sealed class BuildinTypeSpec 
 	{
 		public enum Type
 		{
 			None = 0,
 
 			// TODO
 			Object,
 			ValueType,
 			Attribute,
 			Int,
 			UInt,
 			Long,
 			ULong,
 			Float,
 			Double,
 			Char,
 			Short,
 			Decimal,
 			Bool,
 			SByte,
 			Byte,
 			UShort,
 			String,
 			Enum,
 			Delegate,
 			MulticastDelegate,
 			Void,
 			Array,
 			Type,
 			IEnumerator,
 			IEnumerable,
 			IDisposable,
 			IntPtr,
 			UIntPtr,
 			RuntimeFieldHandle,
 			RuntimeTypeHandle,
 			Exception,
 
 			Null,
 			Dynamic
 		}
 
 		readonly Type type;
 		readonly string ns;
 		readonly string name;
 
 		public BuildinTypeSpec (MemberKind kind, string ns, string name, Type buildinKind)
 			
 		{
 			this.type = buildinKind;
 			this.ns = ns;
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7471" endline="7928">
<![CDATA[
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, TypeArguments targs, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, int arity, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			if (alias == GlobalAlias) {
 				expr = ec.Module.GlobalRootNamespace;
 				return base.ResolveAsTypeStep (ec, silent);
 			}
 
 			int errors = ec.Compiler.Report.Errors;
 			expr = ec.LookupNamespaceAlias (alias);
 			if (expr == null) {
 				if (errors == ec.Compiler.Report.Errors)
 					ec.Compiler.Report.Error (432, loc, "Alias `{0}' not found", alias);
 				return null;
 			}
 
 			FullNamedExpression fne = base.ResolveAsTypeStep (ec, silent);
 			if (fne == null)
 				return null;
 
 			if (expr.eclass == ExprClass.Type) {
 				if (!silent) {
 					ec.Compiler.Report.Error (431, loc,
 						"Alias `{0}' cannot be used with '
 				}
 				return null;
 			}
 
 			return fne;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return ResolveAsTypeStep (ec, false);
 		}
 
 		protected override void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			rc.Compiler.Report.Error (687, loc,
 				"A namespace alias qualifier `{0}' did not resolve to a namespace or a type",
 				GetSignatureForError ());
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name = Name;
 			if (targs != null) {
 				name = Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return alias + "
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			return DoResolve (rc);
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing 
 		}
 	}
 
 	/// <summary>
 	///   Implements the member access expression
 	/// </summary>
 	public class MemberAccess 
 	{
 		protected Expression expr;
 
 		public MemberAccess (Expression expr, string id)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, TypeArguments args, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, int arity, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public Expression LeftExpression {
 			get {
 				return expr;
 			}
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return DoResolveName (ec, null);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			return DoResolveName (ec, right_side);
 		}
 
 		Expression DoResolveName (ResolveContext rc, Expression right_side)
 		{
 			Expression e = LookupNameExpression (rc, right_side == null ? MemberLookupRestrictions.ReadAccess 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 					e.Error_UnexpectedKind (rc, ResolveFlags.VariableOrValue, loc);
 					return null;
 				}
 
 				e = e.ResolveLValue (rc, right_side);
 			} else {
 				e = e.Resolve (rc, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 			}
 
 			return e;
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			var sn = expr as SimpleName;
 			const ResolveFlags flags = ResolveFlags.VariableOrValue | ResolveFlags.Type;
 
 			//
 			// Resolve the expression with flow analysis turned off, we'll do the definite
 			// assignment checks later.  This is because we don't know yet what the expression
 			// will resolve to - it may resolve to a FieldExpr and in this case we must do the
 			// definite assignment check on the actual field and not on the whole struct.
 			//
 			using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 				if (sn != null) {
 					expr = sn.LookupNameExpression (rc, MemberLookupRestrictions.ReadAccess | MemberLookupRestrictions.ExactArity);
 
 					// Call resolve on expression which does have type set as we need expression type
 					// TODO
 					if (expr is VariableReference || expr is ConstantExpr || expr is Linq.TransparentMemberAccess) {
 						using (rc.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 							expr = expr.Resolve (rc);
 						}
 					} else if (expr is TypeParameterExpr) {
 						expr.Error_UnexpectedKind (rc, flags, sn.Location);
 						expr = null;
 					}
 				} else {
 					expr = expr.Resolve (rc, flags);
 				}
 			}
 
 			if (expr == null)
 				return null;
 
 			Namespace ns = expr as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 					return null;
 				}
 
 				if (HasTypeArguments)
 					return new GenericTypeExpr (retval.Type, targs, loc);
 
 				return retval;
 			}
 
 			MemberExpr me;
 			TypeSpec expr_type = expr.Type;
 			if (expr_type == InternalType.Dynamic) {
 				me = expr as MemberExpr;
 				if (me != null)
 					me.ResolveInstanceExpression (rc, null);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new DynamicMemberBinder (Name, args, loc);
 			}
 
 			const MemberKind dot_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.Delegate | MemberKind.Enum |
 				MemberKind.Interface | MemberKind.TypeParameter | MemberKind.ArrayType;
 
 			if ((expr_type.Kind & dot_kinds) == 0 || expr_type == TypeManager.void_type) {
 				if (expr_type == InternalType.Null && rc.Compiler.IsRuntimeBinder)
 					rc.Report.Error (Report.RuntimeErrorId, loc, "Cannot perform member binding on `null' value");
 				else
 					Unary.Error_OperatorCannotBeApplied (rc, loc, ".", expr_type);
 				return null;
 			}
 
 			var current_type = rc.CurrentType;
 			var lookup_arity = Arity;
 			bool errorMode = false;
 			Expression member_lookup;
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 
 			TypeExpr texpr = member_lookup as TypeExpr;
 			if (texpr != null) {
 				if (!(expr is TypeExpr)) {
 					me = expr as MemberExpr;
 					if (me == null || me.ProbeIdenticalTypeName (rc, expr, sn) == expr) {
 						rc.Report.Error (572, loc, "`{0}'
 							Name, member_lookup.GetSignatureForError ());
 						return null;
 					}
 				}
 
 				if (!texpr.Type.IsAccessible (rc.CurrentType)) {
 					rc.Report.SymbolRelatedToPreviousError (member_lookup.Type);
 					ErrorIsInaccesible (rc, member_lookup.Type.GetSignatureForError (), loc);
 					return null;
 				}
 
 				if (HasTypeArguments) {
 					return new GenericTypeExpr (member_lookup.Type, targs, loc);
 				}
 
 				return member_lookup;
 			}
 
 			me = member_lookup as MemberExpr;
 
 			if (sn != null && me.IsStatic)
 				expr = me.ProbeIdenticalTypeName (rc, expr, sn);
 
 			me = me.ResolveMemberAccess (rc, expr, sn);
 
 			if (Arity > 0) {
 				if (!targs.Resolve (rc))
 					return null;
 
 				me.SetTypeArguments (rc, targs);
 			}
 
 			if (sn != null && (!TypeManager.IsValueType (expr_type) || me is PropertyExpr)) {
 				if (me.IsInstance) {
 					LocalVariableReference var = expr as LocalVariableReference;
 					if (var != null && !var.VerifyAssigned (rc))
 						return null;
 				}
 			}
 
 			return me;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			return ResolveNamespaceOrType (ec, silent);
 		}
 
 		public FullNamedExpression ResolveNamespaceOrType (IMemberContext rc, bool silent)
 		{
 			FullNamedExpression expr_resolved = expr.ResolveAsTypeStep (rc, silent);
 
 			if (expr_resolved == null)
 				return null;
 
 			Namespace ns = expr_resolved as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					if (!silent)
 						ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 				} else if (HasTypeArguments) {
 					retval = new GenericTypeExpr (retval.Type, targs, loc).ResolveAsTypeStep (rc, silent);
 				}
 
 				return retval;
 			}
 
 			TypeExpr tnew_expr = expr_resolved.ResolveAsTypeTerminal (rc, false);
 			if (tnew_expr == null)
 				return null;
 
 			TypeSpec expr_type = tnew_expr.Type;
 			if (TypeManager.IsGenericParameter (expr_type)) {
 				rc.Compiler.Report.Error (704, loc, "A nested type cannot be specified through a type parameter `{0}'",
 					tnew_expr.GetSignatureForError ());
 				return null;
 			}
 
 			TypeSpec nested = null;
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			
 			TypeExpr texpr;
 			if (Arity > 0) {
 				if (HasTypeArguments) {
 					texpr = new GenericTypeExpr (nested, targs, loc);
 				} else {
 					texpr = new GenericOpenTypeExpr (nested, loc);
 				}
 			} else {
 				texpr = new TypeExpression (nested, loc);
 			}
 
 			return texpr.ResolveAsTypeStep (rc, false);
 		}
 
 		protected virtual void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			var nested = MemberCache.FindNestedType (expr_type, Name, -System.Math.Max (1, Arity));
 
 			if (nested != null) {
 				Error_TypeArgumentsCannotBeUsed (rc.Compiler.Report, expr.Location, nested, Arity);
 				return;
 			}
 
 			var any_other_member = MemberLookup (null, rc.CurrentType, expr_type, Name, 0, MemberLookupRestrictions.None, loc);
 			if (any_other_member != null) {
 				any_other_member.Error_UnexpectedKind (rc.Compiler.Report, null, "type", loc);
 				return;
 			}
 
 			rc.Compiler.Report.Error (426, loc, "The nested type `{0}' does not exist in the type `{1}'",
 				Name, expr_type.GetSignatureForError ());
 		}
 
 		protected override void Error_TypeDoesNotContainDefinition (ResolveContext ec, TypeSpec type, string name)
 		{
 			if (RootContext.Version > LanguageVersion.ISO_2 && !ec.Compiler.IsRuntimeBinder && MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (1061, loc,
 					"Type `{0}' does not contain a definition for `{1}' and no extension method `{1}' of type `{0}' could be found (are you missing a using directive or an assembly reference?)",
 					type.GetSignatureForError (), name);
 				return;
 			}
 
 			base.Error_TypeDoesNotContainDefinition (ec, type, name);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return expr.GetSignatureForError () + "." + base.GetSignatureForError ();
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	/// <summary>
 	///   Implements checked expressions
 	/// </summary>
 	public class CheckedExpr 
 
 		public Expression Expr;
 
 		public CheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="192" endline="695">
<![CDATA[
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
 
 		#region Properties
 
 		public DefaultParameterValueExpression DefaultValue {
 			get {
 				return default_expr as DefaultParameterValueExpression;
 			}
 			set {
 				default_expr = value;
 			}
 		}
 
 		Expression IParameterData.DefaultValue {
 			get {
 				var expr = default_expr as DefaultParameterValueExpression;
 				return expr == null ? default_expr 
 			}
 		}
 
 		bool HasOptionalExpression {
 			get {
 				return default_expr is DefaultParameterValueExpression;
 			}
 		}
 
 		public Location Location {
 			get {
 				return loc;
 			}
 		}
 
 		public TypeSpec Type {
 			get {
 				return parameter_type;
 			}
 		}
 
 		public FullNamedExpression TypeExpression  {
 			get {
 				return texpr;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.In && ModFlags == Modifier.OUT) {
 				a.Report.Error (36, a.Location, "An out parameter cannot have the `In' attribute");
 				return;
 			}
 
 			if (a.Type == pa.ParamArray) {
 				a.Report.Error (674, a.Location, "Do not use `System.ParamArrayAttribute'. Use the `params' keyword instead");
 				return;
 			}
 
 			if (a.Type == pa.Out && (ModFlags & Modifier.REF) == Modifier.REF &&
 			    !OptAttributes.Contains (pa.In)) {
 				a.Report.Error (662, a.Location,
 					"Cannot specify only `Out' attribute on a ref parameter. Use both `In' and `Out' attributes or neither");
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				a.Report.Warning (3022, 1, a.Location, "CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead");
 			}
 
 			if (a.Type == pa.DefaultParameterValue || a.Type == pa.OptionalParameter) {
 				if (HasOptionalExpression) {
 					a.Report.Error (1745, a.Location,
 						"Cannot specify `{0}' attribute on optional parameter `{1}'",
 						TypeManager.CSharpName (a.Type).Replace ("Attribute", ""), Name);
 				}
 
 				if (a.Type == pa.DefaultParameterValue)
 					return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 		
 		public virtual bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			if (parameter_type == null)
 				return true;
 
 			return member.IsAccessibleAs (parameter_type);
 		}
 
 		public static void Reset ()
 		{
 			parameter_expr_tree_type = null;
 		}
 
 		// <summary>
 		//   Resolve is used in method definitions
 		// </summary>
 		public virtual TypeSpec Resolve (IMemberContext rc, int index)
 		{
 			if (parameter_type != null)
 				return parameter_type;
 
 			if (attributes != null)
 				attributes.AttachTo (this, rc);
 
 			var expr = texpr.ResolveAsTypeTerminal (rc, false);
 			if (expr == null)
 				return null;
 
 			this.idx = index;
 			texpr = expr;
 			parameter_type = texpr.Type;
 	
 			if ((modFlags & Parameter.Modifier.ISBYREF) != 0 &&
 				TypeManager.IsSpecialType (parameter_type)) {
 				rc.Compiler.Report.Error (1601, Location, "Method or delegate parameter cannot be of type `{0}'",
 					GetSignatureForError ());
 				return null;
 			}
 
 			TypeManager.CheckTypeVariance (parameter_type,
 				(modFlags & Parameter.Modifier.ISBYREF) != 0 ? Variance.None 
 				rc);
 
 			if (parameter_type.IsStatic) {
 				rc.Compiler.Report.Error (721, Location, "`{0}'
 					texpr.GetSignatureForError ());
 				return parameter_type;
 			}
 
 			if ((modFlags & Modifier.This) != 0 && (parameter_type.IsPointer || parameter_type == InternalType.Dynamic)) {
 				rc.Compiler.Report.Error (1103, Location, "The extension method cannot be of type `{0}'",
 					TypeManager.CSharpName (parameter_type));
 			}
 
 			return parameter_type;
 		}
 
 		public void ResolveDefaultValue (ResolveContext rc)
 		{
 			//
 			// Default value was specified using an expression
 			//
 			if (default_expr != null) {
 				((DefaultParameterValueExpression)default_expr).Resolve (rc, this);
 				return;
 			}
 
 			if (attributes == null)
 				return;
 			
 			var opt_attr = attributes.Search (rc.Module.PredefinedAttributes.OptionalParameter);
 			var def_attr = attributes.Search (rc.Module.PredefinedAttributes.DefaultParameterValue);
 			if (def_attr != null) {
 				if (def_attr.Resolve () == null)
 					return;
 
 				var default_expr_attr = def_attr.GetParameterDefaultValue ();
 				if (default_expr_attr == null)
 					return;
 
 				var dpa_rc = def_attr.CreateResolveContext ();
 				default_expr = default_expr_attr.Resolve (dpa_rc);
 
 				if (default_expr is BoxedCast)
 					default_expr = ((BoxedCast) default_expr).Child;
 
 				Constant c = default_expr as Constant;
 				if (c == null) {
 					if (parameter_type == TypeManager.object_type) {
 						rc.Compiler.Report.Error (1910, default_expr.Location,
 							"Argument of type `{0}' is not applicable for the DefaultParameterValue attribute",
 							default_expr.Type.GetSignatureForError ());
 					} else {
 						rc.Compiler.Report.Error (1909, default_expr.Location,
 							"The DefaultParameterValue attribute is not applicable on parameters of type `{0}'",
 							default_expr.Type.GetSignatureForError ()); ;
 					}
 
 					default_expr = null;
 					return;
 				}
 
 				if (TypeSpecComparer.IsEqual (default_expr.Type, parameter_type) ||
 					(default_expr is NullConstant && TypeManager.IsReferenceType (parameter_type) && !parameter_type.IsGenericParameter) ||
 					TypeSpecComparer.IsEqual (parameter_type, TypeManager.object_type)) {
 					return;
 				}
 
 				//
 				// LAMESPEC
 				// User operators returning same type as parameter type are considered
 				// valid for this attribute only
 				//
 				// struct S { public static implicit operator S (int i) {} }
 				//
 				// void M ([DefaultParameterValue (3)]S s)
 				//
 				var expr = Convert.ImplicitUserConversion (dpa_rc, default_expr, parameter_type, loc);
 				if (expr != null && TypeSpecComparer.IsEqual (expr.Type, parameter_type)) {
 					return;
 				}
 				
 				rc.Compiler.Report.Error (1908, default_expr.Location, "The type of the default value should match the type of the parameter");
 				return;
 			}
 
 			if (opt_attr != null) {
 				default_expr = EmptyExpression.MissingValue;
 			}
 		}
 
 		public bool HasDefaultValue {
 			get { return default_expr != null; }
 		}
 
 		public bool HasExtensionMethodModifier {
 			get { return (modFlags & Modifier.This) != 0; }
 		}
 
 		//
 		// Hoisted parameter variant
 		//
 		public HoistedVariable HoistedVariant {
 			get {
 				return hoisted_variant;
 			}
 			set {
 				hoisted_variant = value;
 			}
 		}
 
 		public Modifier ModFlags {
 			get { return modFlags & ~Modifier.This; }
 		}
 
 		public string Name {
 			get { return name; }
 			set { name = value; }
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Parameter;
 			}
 		}
 
 		public virtual string GetSignatureForError ()
 		{
 			string type_name;
 			if (parameter_type != null)
 				type_name = TypeManager.CSharpName (parameter_type);
 			else
 				type_name = texpr.GetSignatureForError ();
 
 			string mod = GetModifierSignature (modFlags);
 			if (mod.Length > 0)
 				return String.Concat (mod, " ", type_name);
 
 			return type_name;
 		}
 
 		public static string GetModifierSignature (Modifier mod)
 		{
 			switch (mod) {
 			case Modifier.OUT
 				return "out";
 			case Modifier.PARAMS
 				return "params";
 			case Modifier.REF
 				return "ref";
 			case Modifier.This
 				return "this";
 			default
 				return "";
 			}
 		}
 
 		public void IsClsCompliant (IMemberContext ctx)
 		{
 			if (parameter_type.IsCLSCompliant ())
 				return;
 
 			ctx.Compiler.Report.Warning (3001, 1, Location,
 				"Argument type `{0}' is not CLS-compliant", parameter_type.GetSignatureForError ());
 		}
 
 		public virtual void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			if (builder != null)
 				throw new InternalErrorException ("builder already exists");
 
 			var pattrs = ParametersCompiled.GetParameterAttribute (modFlags);
 			if (HasOptionalExpression)
 				pattrs |= ParameterAttributes.Optional;
 
 			if (mb == null)
 				builder = cb.DefineParameter (index, pattrs, Name);
 			else
 				builder = mb.DefineParameter (index, pattrs, Name);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (HasDefaultValue) {
 				//
 				// Emit constant values for true constants only, the other
 				// constant-like expressions will rely on default value expression
 				//
 				var def_value = DefaultValue;
 				Constant c = def_value != null ? def_value.Child as Constant 
 				if (c != null) {
 					if (default_expr.Type == TypeManager.decimal_type) {
 						pa.DecimalConstant.EmitAttribute (builder, (decimal) c.GetValue (), c.Location);
 					} else {
 						builder.SetConstant (c.GetValue ());
 					}
 				} else if (default_expr.Type.IsStruct) {
 					//
 					// Handles special case where default expression is used with value-type
 					//
 					// void Foo (S s = default (S)) {}
 					//
 					builder.SetConstant (null);
 				}
 			}
 
 			if (parameter_type != null) {
 				if (parameter_type == InternalType.Dynamic) {
 					pa.Dynamic.EmitAttribute (builder);
 				} else if (parameter_type.HasDynamicElement) {
 					pa.Dynamic.EmitAttribute (builder, parameter_type, Location);
 				}
 			}
 		}
 
 		public Parameter Clone ()
 		{
 			Parameter p = (Parameter) MemberwiseClone ();
 			if (attributes != null)
 				p.attributes = attributes.Clone ();
 
 			return p;
 		}
 
 		public ExpressionStatement CreateExpressionTreeVariable (BlockContext ec)
 		{
 			if ((modFlags & Modifier.ISBYREF) != 0)
 				ec.Report.Error (1951, Location, "An expression tree parameter cannot use `ref' or `out' modifier");
 
 			expr_tree_variable = TemporaryVariableReference.Create (ResolveParameterExpressionType (ec, Location).Type, ec.CurrentBlock.ParametersBlock, Location);
 			expr_tree_variable = (TemporaryVariableReference) expr_tree_variable.Resolve (ec);
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (new TypeOf (
 				new TypeExpression (parameter_type, Location), Location)));
 			arguments.Add (new Argument (new StringConstant (Name, Location)));
 			return new SimpleAssign (ExpressionTreeVariableReference (),
 				Expression.CreateExpressionFactoryCall (ec, "Parameter", null, arguments, Location));
 		}
 
 		public void Emit (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			ParameterReference.EmitLdArg (ec, arg_idx);
 		}
 
 		public void EmitAssign (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			if (arg_idx <= 255)
 				ec.Emit (OpCodes.Starg_S, (byte) arg_idx);
 			else
 				ec.Emit (OpCodes.Starg, arg_idx);
 		}
 
 		public void EmitAddressOf (EmitContext ec)
 		{
 			int arg_idx = idx;
 
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			bool is_ref = (ModFlags & Modifier.ISBYREF) != 0;
 			if (is_ref) {
 				ParameterReference.EmitLdArg (ec, arg_idx);
 			} else {
 				if (arg_idx <= 255)
 					ec.Emit (OpCodes.Ldarga_S, (byte) arg_idx);
 				else
 					ec.Emit (OpCodes.Ldarga, arg_idx);
 			}
 		}
 
 		public TemporaryVariableReference ExpressionTreeVariableReference ()
 		{
 			return expr_tree_variable;
 		}
 
 		//
 		// System.Linq.Expressions.ParameterExpression type
 		//
 		public static TypeExpr ResolveParameterExpressionType (IMemberContext ec, Location location)
 		{
 			if (parameter_expr_tree_type != null)
 				return parameter_expr_tree_type;
 
 			TypeSpec p_type = ec.Module.PredefinedTypes.ParameterExpression.Resolve (location);
 			parameter_expr_tree_type = new TypeExpression (p_type, location).
 				ResolveAsTypeTerminal (ec, false);
 
 			return parameter_expr_tree_type;
 		}
 
 		public void Warning_UselessOptionalParameter (Report Report)
 		{
 			Report.Warning (1066, 1, Location,
 				"The default value specified for optional parameter `{0}' will never be used",
 				Name);
 		}
 	}
 
 	//
 	// Imported or resolved parameter information
 	//
 	public class ParameterData 
 	{
 		readonly string name;
 		readonly Parameter.Modifier modifiers;
 		readonly Expression default_value;
 
 		public ParameterData (string name, Parameter.Modifier modifiers)
 		{
 			this.name = name;
 			this.modifiers = modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="612" endline="1112">
<![CDATA[
 
 		Variance variance;
 		SpecialConstraint spec;
 		readonly int tp_pos;
 		TypeSpec[] targs;
 		TypeSpec[] ifaces_defined;
 
 		//
 		// Creates type owned type parameter
 		//
 		public TypeParameterSpec (TypeSpec declaringType, int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 			this.variance = variance;
 			this.spec = spec;
 			state &= ~StateFlags.Obsolete_Undetected;
 			tp_pos = index;
 		}
 
 		//
 		// Creates method owned type parameter
 		//
 		public TypeParameterSpec (int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 		}
 
 		#region Properties
 
 		public int DeclaredPosition {
 			get {
 				return tp_pos;
 			}
 		}
 
 		public bool HasSpecialConstructor {
 			get {
 				return (spec & SpecialConstraint.Constructor) != 0;
 			}
 		}
 
 		public bool HasSpecialClass {
 			get {
 				return (spec & SpecialConstraint.Class) != 0;
 			}
 		}
 
 		public bool HasSpecialStruct {
 			get {
 				return (spec & SpecialConstraint.Struct) != 0;
 			}
 		}
 
 		public bool HasTypeConstraint {
 			get {
 				return BaseType != TypeManager.object_type && BaseType != TypeManager.value_type;
 			}
 		}
 
 		public override IList<TypeSpec> Interfaces {
 			get {
 				if ((state & StateFlags.InterfacesExpanded) == 0) {
 					if (ifaces != null) {
 						for (int i = 0; i < ifaces.Count; ++i ) {
 							var iface_type = ifaces[i];
 							if (iface_type.Interfaces != null) {
 								if (ifaces_defined == null)
 									ifaces_defined = ifaces.ToArray ();
 
 								for (int ii = 0; ii < iface_type.Interfaces.Count; ++ii) {
 									var ii_iface_type = iface_type.Interfaces [ii];
 
 									AddInterface (ii_iface_type);
 								}
 							}
 						}
 					}
 
 					if (ifaces_defined == null && ifaces != null)
 						ifaces_defined = ifaces.ToArray ();
 
 					state |= StateFlags.InterfacesExpanded;
 				}
 
 				return ifaces;
 			}
 		}
 
 		//
 		// Unexpanded interfaces list
 		//
 		public TypeSpec[] InterfacesDefined {
 			get {
 				if (ifaces_defined == null && ifaces != null)
 					ifaces_defined = ifaces.ToArray ();
 
 				return ifaces_defined;
 			}
 			set {
 				ifaces_defined = value;
 			}
 		}
 
 		public bool IsConstrained {
 			get {
 				return spec != SpecialConstraint.None || ifaces != null || targs != null || HasTypeConstraint;
 			}
 		}
 
 		//
 		// Returns whether the type parameter is "known to be a reference type"
 		//
 		public bool IsReferenceType {
 			get {
 				if ((spec & SpecialConstraint.Class) != 0 || HasTypeConstraint)
 					return true;
 
 				if (targs != null) {
 					foreach (var ta in targs) {
 						if (TypeManager.IsReferenceType (ta))
 							return true;
 					}
 				}
 
 				return false;
 			}
 		}
 
 		public bool IsValueType {	// TODO
 			get {
 				// TODO MemberCache
 				return HasSpecialStruct;
 			}
 		}
 
 		public override string Name {
 			get {
 				return definition.Name;
 			}
 		}
 
 		public bool IsMethodOwned {
 			get {
 				return DeclaringType == null;
 			}
 		}
 
 		public SpecialConstraint SpecialConstraint {
 			get {
 				return spec;
 			}
 			set {
 				spec = value;
 			}
 		}
 
 		//
 		// Types used to inflate the generic type
 		//
 		public new TypeSpec[] TypeArguments {
 			get {
 				return targs;
 			}
 			set {
 				targs = value;
 			}
 		}
 
 		public Variance Variance {
 			get {
 				return variance;
 			}
 		}
 
 		#endregion
 
 		public void ChangeTypeArgumentToBaseType (int index)
 		{
 			BaseType = targs [index];
 			if (targs.Length == 1) {
 				targs = null;
 			} else {
 				var copy = new TypeSpec[targs.Length - 1];
 				if (index > 0)
 					Array.Copy (targs, copy, index);
 
 				Array.Copy (targs, index + 1, copy, index, targs.Length - index - 1);
 				targs = copy;
 			}
 		}
 
 		public string DisplayDebugInfo ()
 		{
 			var s = GetSignatureForError ();
 			return IsMethodOwned ? s + "!!" 
 		}
 
 		//
 		// Finds effective base class
 		//
 		public TypeSpec GetEffectiveBase ()
 		{
 			if (HasSpecialStruct) {
 				return TypeManager.value_type;
 			}
 
 			if (BaseType != null && targs == null)
 				return BaseType;
 
 			var types = targs;
 			if (HasTypeConstraint) {
 				Array.Resize (ref types, types.Length + 1);
 				types[types.Length - 1] = BaseType;
 			}
 
 			if (types != null)
 				return Convert.FindMostEncompassedType (types.Select (l => l.BaseType));
 
 			return TypeManager.object_type;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Name;
 		}
 
 		//
 		// Constraints have to match by definition but not position, used by
 		// partial classes or methods
 		//
 		public bool HasSameConstraintsDefinition (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			if (BaseType != other.BaseType)
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (InterfacesDefined, other.InterfacesDefined))
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (targs, other.targs))
 				return false;
 
 			return true;
 		}
 
 		//
 		// Constraints have to match by using same set of types, used by
 		// implicit interface implementation
 		//
 		public bool HasSameConstraintsImplementation (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			//
 			// It can be same base type or inflated type parameter
 			//
 			// interface I<T> { void Foo<U> where U 
 			// class A 
 			//
 			bool found;
 			if (!TypeSpecComparer.Override.IsEqual (BaseType, other.BaseType)) {
 				if (other.targs == null)
 					return false;
 
 				found = false;
 				foreach (var otarg in other.targs) {
 					if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 						found = true;
 						break;
 					}
 				}
 
 				if (!found)
 					return false;
 			}
 
 			// Check interfaces implementation -> definition
 			if (InterfacesDefined != null) {
 				foreach (var iface in InterfacesDefined) {
 					found = false;
 					if (other.InterfacesDefined != null) {
 						foreach (var oiface in other.InterfacesDefined) {
 							if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (found)
 						continue;
 
 					if (other.targs != null) {
 						foreach (var otarg in other.targs) {
 							if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check interfaces implementation <- definition
 			if (other.InterfacesDefined != null) {
 				if (InterfacesDefined == null)
 					return false;
 
 				foreach (var oiface in other.InterfacesDefined) {
 					found = false;
 					foreach (var iface in InterfacesDefined) {
 						if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation -> definition
 			if (targs != null) {
 				if (other.targs == null)
 					return false;
 
 				foreach (var targ in targs) {
 					found = false;
 					foreach (var otarg in other.targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation <- definition
 			if (other.targs != null) {
 				foreach (var otarg in other.targs) {
 					// Ignore inflated type arguments, were checked above
 					if (!otarg.IsGenericParameter)
 						continue;
 
 					if (targs == null)
 						return false;
 
 					found = false;
 					foreach (var targ in targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}				
 			}
 
 			return true;
 		}
 
 		public static TypeParameterSpec[] InflateConstraints (TypeParameterInflator inflator, TypeParameterSpec[] tparams)
 		{
 			return InflateConstraints (tparams, l => l, inflator);
 		}
 
 		public static TypeParameterSpec[] InflateConstraints<T> (TypeParameterSpec[] tparams, Func<T, TypeParameterInflator> inflatorFactory, T arg)
 		{
 			TypeParameterSpec[] constraints = null;
 			TypeParameterInflator? inflator = null;
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 				if (tp.HasTypeConstraint || tp.Interfaces != null || tp.TypeArguments != null) {
 					if (constraints == null) {
 						constraints = new TypeParameterSpec[tparams.Length];
 						Array.Copy (tparams, constraints, constraints.Length);
 					}
 
 					//
 					// Using a factory to avoid possibly expensive inflator build up
 					//
 					if (inflator == null)
 						inflator = inflatorFactory (arg);
 
 					constraints[i] = (TypeParameterSpec) constraints[i].InflateMember (inflator.Value);
 				}
 			}
 
 			if (constraints == null)
 				constraints = tparams;
 
 			return constraints;
 		}
 
 		public void InflateConstraints (TypeParameterInflator inflator, TypeParameterSpec tps)
 		{
 			tps.BaseType = inflator.Inflate (BaseType);
 			if (ifaces != null) {
 				tps.ifaces = new List<TypeSpec> (ifaces.Count);
 				for (int i = 0; i < ifaces.Count; ++i)
 					tps.ifaces.Add (inflator.Inflate (ifaces[i]));
 			}
 
 			if (targs != null) {
 				tps.targs = new TypeSpec[targs.Length];
 				for (int i = 0; i < targs.Length; ++i)
 					tps.targs[i] = inflator.Inflate (targs[i]);
 			}
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var tps = (TypeParameterSpec) MemberwiseClone ();
 			InflateConstraints (inflator, tps);
 			return tps;
 		}
 
 		//
 		// Populates type parameter members using type parameter constraints
 		// The trick here is to be called late enough but not too late to
 		// populate member cache with all members from other types
 		//
 		protected override void InitializeMemberCache (bool onlyTypes)
 		{
 			cache = new MemberCache ();
 
 			//
 			// For a type parameter the membercache is the union of the sets of members of the types
 			// specified as a primary constraint or secondary constraint
 			//
 			if (BaseType != TypeManager.object_type && BaseType != TypeManager.value_type)
 				cache.AddBaseType (BaseType);
 
 			if (ifaces != null) {
 				foreach (var iface_type in Interfaces) {
 					cache.AddInterface (iface_type);
 				}
 			}
 
 			if (targs != null) {
 				foreach (var ta in targs) {
 					if (ta.BaseType != TypeManager.object_type && ta.BaseType != TypeManager.value_type)
 						cache.AddBaseType (ta.BaseType);
 
 					if (ta.Interfaces != null) {
 						foreach (var iface_type in ta.Interfaces) {
 							cache.AddInterface (iface_type);
 						}
 					}
 				}
 			}
 		}
 
 		public bool IsConvertibleToInterface (TypeSpec iface)
 		{
 			if (Interfaces != null) {
 				foreach (var t in Interfaces) {
 					if (t == iface)
 						return true;
 				}
 			}
 
 			if (TypeArguments != null) {
 				foreach (var t in TypeArguments) {
 					if (((TypeParameterSpec) t).IsConvertibleToInterface (iface))
 						return true;
 				}
 			}
 
 			return false;
 		}
 
 		public override TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			return mutator.Mutate (this);
 		}
 	}
 
 	public struct TypeParameterInflator
 	{
 		readonly TypeSpec type;
 		readonly TypeParameterSpec[] tparams;
 		readonly TypeSpec[] targs;
 
 		public TypeParameterInflator (TypeParameterInflator nested, TypeSpec type)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="366" endline="445">
<![CDATA[
 
 		TypeExpr CreateSiteType (EmitContext ec, Arguments arguments, int dyn_args_count, bool is_statement)
 		{
 			int default_args = is_statement ? 1 
 			var module = ec.MemberContext.Module;
 
 			bool has_ref_out_argument = false;
 			var targs = new TypeExpression[dyn_args_count + default_args];
 			targs [0] = new TypeExpression (module.PredefinedTypes.CallSite.TypeSpec, loc);
 			for (int i = 0; i < dyn_args_count; ++i) {
 				Argument a = arguments [i];
 				if (a.ArgType == Argument.AType.Out || a.ArgType == Argument.AType.Ref)
 					has_ref_out_argument = true;
 
 				var t = a.Type;
 
 				// Convert any internal type like dynamic or null to object
 				if (t.Kind == MemberKind.InternalCompilerType)
 					t = TypeManager.object_type;
 
 				targs [i + 1] = new TypeExpression (t, loc);
 			}
 			for (int i = 0; i < dyn_args_count; ++i) {
 				Argument a = arguments [i];
 				if (a.ArgType == Argument.AType.Out || a.ArgType == Argument.AType.Ref)
 					has_ref_out_argument = true;
 
 				var t = a.Type;
 
 				// Convert any internal type like dynamic or null to object
 				if (t.Kind == MemberKind.InternalCompilerType)
 					t = TypeManager.object_type;
 
 				targs [i + 1] = new TypeExpression (t, loc);
 			}
 
 			TypeExpr del_type = null;
 			if (!has_ref_out_argument) {
 				string d_name = is_statement ? "Action" 
 
 				TypeExpr te = null;
 				Namespace type_ns = module.GlobalRootNamespace.GetNamespace ("System", true);
 				if (type_ns != null) {
 					te = type_ns.LookupType (module.Compiler, d_name, dyn_args_count + default_args, true, Location.Null);
 				}
 			
 				if (te != null) {
 					if (!is_statement)
 						targs [targs.Length - 1] = new TypeExpression (type, loc);
 
 					del_type = new GenericTypeExpr (te.Type, new TypeArguments (targs), loc);
 				}
 			}
 
 			//
 			// Create custom delegate when no appropriate predefined one is found
 			//
 			if (del_type == null) {
 				TypeSpec rt = is_statement ? TypeManager.void_type 
 				Parameter[] p = new Parameter [dyn_args_count + 1];
 				p[0] = new Parameter (targs [0], "p0", Parameter.Modifier.NONE, null, loc);
 
 				var site = ec.CreateDynamicSite ();
 				int index = site.Types == null ? 0 
 
 				if (site.Mutator != null)
 					rt = site.Mutator.Mutate (rt);
 
 				for (int i = 1; i < dyn_args_count + 1; ++i) {
 					var t = targs[i];
 					if (site.Mutator != null)
 						t.Type = site.Mutator.Mutate (t.Type);
 
 					p[i] = new Parameter (t, "p" + i.ToString ("X"), arguments[i - 1].Modifier, null, loc);
 				}
 				for (int i = 1; i < dyn_args_count + 1; ++i) {
 					var t = targs[i];
 					if (site.Mutator != null)
 						t.Type = site.Mutator.Mutate (t.Type);
 
 					p[i] = new Parameter (t, "p" + i.ToString ("X"), arguments[i - 1].Modifier, null, loc);
 				}
 
 				Delegate d = new Delegate (site.NamespaceEntry, site, new TypeExpression (rt, loc),
 					Modifiers.INTERNAL | Modifiers.COMPILER_GENERATED,
 					new MemberName ("Container" + index.ToString ("X")),
 					new ParametersCompiled (p), null);
 
 				d.CreateType ();
 				d.DefineType ();
 				d.Define ();
 				d.Emit ();
 
 				var inflated = site.AddDelegate (d);
 				del_type = new TypeExpression (inflated, loc);
 			}
 
 			TypeExpr site_type = new GenericTypeExpr (module.PredefinedTypes.CallSiteGeneric.TypeSpec, new TypeArguments (del_type), loc);
 			return site_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="677" endline="821">
<![CDATA[
 	}
 
 	// A 'return' or a 'yield break'
 	public abstract class ExitStatement 
 	{
 		protected bool unwind_protect;
 		protected abstract bool DoResolve (BlockContext ec);
 
 		public virtual void Error_FinallyClause (Report Report)
 		{
 			Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 		}
 
 		public sealed override bool Resolve (BlockContext ec)
 		{
 			if (!DoResolve (ec))
 				return false;
 
 			unwind_protect = ec.CurrentBranching.AddReturnOrigin (ec.CurrentBranching.CurrentUsageVector, this);
 			if (unwind_protect)
 				ec.NeedReturnLabel ();
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
 	}
 
 	/// <summary>
 	///   Implements the return statement
 	/// </summary>
 	public class Return 
 	{
 		protected Expression Expr;
 		public Return (Expression expr, Location l)
 		{
 			Expr = expr;
 			loc = l;
 		}
 
 		#region Properties
 		public Expression Expression {
 			get {
 				return Expr;
 			}
 		}
 		#endregion
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			if (Expr == null) {
 				if (ec.ReturnType == TypeManager.void_type)
 					return true;
 
 				if (ec.CurrentIterator != null) {
 					Error_ReturnFromIterator (ec);
 				} else {
 					ec.Report.Error (126, loc,
 						"An object of a type convertible to `{0}' is required for the return statement",
 						ec.ReturnType.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			Expr = Expr.Resolve (ec);
 
 			AnonymousExpression am = ec.CurrentAnonymousMethod;
 			if (am == null) {
 				if (ec.ReturnType == TypeManager.void_type) {
 					ec.Report.Error (127, loc,
 						"`{0}'
 						ec.GetSignatureForError ());
 				}
 			} else {
 				if (am.IsIterator) {
 					Error_ReturnFromIterator (ec);
 					return false;
 				}
 
 				var l = am as AnonymousMethodBody;
 				if (l != null && l.ReturnTypeInference != null && Expr != null) {
 					l.ReturnTypeInference.AddCommonTypeBound (Expr.Type);
 					return true;
 				}
 			}
 
 			if (Expr == null)
 				return false;
 
 			if (Expr.Type != ec.ReturnType) {
 				Expr = Convert.ImplicitConversionRequired (ec, Expr, ec.ReturnType, loc);
 
 				if (Expr == null) {
 					if (am != null) {
 						ec.Report.Error (1662, loc,
 							"Cannot convert `{0}' to delegate type `{1}' because some of the return types in the block are not implicitly convertible to the delegate return type",
 							am.ContainerType, am.GetSignatureForError ());
 					}
 					return false;
 				}
 			}
 
 			return true;			
 		}
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (Expr != null) {
 				Expr.Emit (ec);
 
 				if (unwind_protect)
 					ec.Emit (OpCodes.Stloc, ec.TemporaryReturn ());
 			}
 
 			if (unwind_protect)
 				ec.Emit (OpCodes.Leave, ec.ReturnLabel);
 			else
 				ec.Emit (OpCodes.Ret);
 		}
 
 		void Error_ReturnFromIterator (ResolveContext rc)
 		{
 			rc.Report.Error (1622, loc,
 				"Cannot return a value from iterators. Use the yield return statement to return a value, or yield break to end the iteration");
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Return target = (Return) t;
 			// It's null for simple return;
 			if (Expr != null)
 				target.Expr = Expr.Clone (clonectx);
 		}
 	}
 
 	public class Goto 
 		string target;
 		LabeledStatement label;
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddGotoOrigin (ec.CurrentBranching.CurrentUsageVector, this);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5408" endline="5579">
<![CDATA[
 	}
 
 	abstract class PropertyOrIndexerExpr<T> 
 	{
 		// getter and setter can be different for base calls
 		MethodSpec getter, setter;
 		protected T best_candidate;
 
 		protected LocalTemporary temp;
 		protected bool prepared;
 
 		protected PropertyOrIndexerExpr (Location l)
 		{
 			loc = l;
 		}
 
 		#region Properties
 
 		public MethodSpec Getter {
 			get {
 				return getter;
 			}
 			set {
 				getter = value;
 			}
 		}
 
 		public MethodSpec Setter {
 			get {
 				return setter;
 			}
 			set {
 				setter = value;
 			}
 		}
 
 		#endregion
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, null);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.Resolve (ec);
 			}
 
 			if (!ResolveGetter (ec))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				// TODO
 				INamedBlockVariable variable = null;
 				if (best_candidate != null && ec.CurrentBlock.ParametersBlock.TopBlock.GetLocalName (best_candidate.Name, ec.CurrentBlock, ref variable) && variable is Linq.RangeVariable) {
 					ec.Report.Error (1939, loc, "A range variable `{0}' may not be passes as `ref' or `out' parameter",
 						best_candidate.Name);
 				} else {
 					right_side.DoResolveLValue (ec, this);
 				}
 				return null;
 			}
 
 			// if the property/indexer returns a value type, and we try to set a field in it
 			if (right_side == EmptyExpression.LValueMemberAccess || right_side == EmptyExpression.LValueMemberOutAccess) {
 				Error_CannotModifyIntermediateExpressionValue (ec);
 			}
 
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, right_side);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.ResolveLValue (ec, right_side);
 			}
 
 			if (!ResolveSetter (ec))
 				return null;
 
 			return this;
 		}
 
 		//
 		// Implements the IAssignMethod interface for assignments
 		//
 		public abstract void Emit (EmitContext ec, bool leave_copy);
 		public abstract void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load);
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public abstract SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source);
 
 		protected abstract Expression OverloadResolve (ResolveContext rc, Expression right_side);
 
 		bool ResolveGetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasGet) {
 				if (InstanceExpression != EmptyExpression.Null) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate);
 					rc.Report.Error (154, loc, "The property or indexer `{0}' cannot be used in this context because it lacks the `get' accessor",
 						best_candidate.GetSignatureForError ());
 					return false;
 				}
 			} else if (!best_candidate.Get.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					rc.Report.Error (271, loc, "The property or indexer `{0}' cannot be used in this context because the get accessor is inaccessible",
 						TypeManager.CSharpSignature (best_candidate));
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					ErrorIsInaccesible (rc, best_candidate.Get.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility) {
 				CheckProtectedMemberAccess (rc, best_candidate.Get);
 			}
 
 			getter = CandidateToBaseOverride (rc, best_candidate.Get);
 			return true;
 		}
 
 		bool ResolveSetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasSet) {
 				rc.Report.Error (200, loc, "Property or indexer `{0}' cannot be assigned to (it is read-only)",
 					GetSignatureForError ());
 				return false;
 			}
 
 			if (!best_candidate.Set.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					rc.Report.Error (272, loc, "The property or indexer `{0}' cannot be used in this context because the set accessor is inaccessible",
 						GetSignatureForError ());
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					ErrorIsInaccesible (rc, best_candidate.Set.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility)
 				CheckProtectedMemberAccess (rc, best_candidate.Set);
 
 			setter = CandidateToBaseOverride (rc, best_candidate.Set);
 			return true;
 		}
 	}
 
 	/// <summary>
 	///   Fully resolved expression that evaluates to an Event
 	/// </summary>
 	public class EventExpr 
 	{
 		readonly EventSpec spec;
 		MethodSpec op;
 
 		public EventExpr (EventSpec spec, Location loc)
 		{
 			this.spec = spec;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="631" endline="811">
<![CDATA[
 
 		TypeSpec CreateType (MetaType type, TypeSpec declaringType, DynamicTypeReader dtype, bool canImportBaseType)
 		{
 			TypeSpec spec;
 			if (import_cache.TryGetValue (type, out spec)) {
 				if (spec == TypeManager.object_type) {
 					if (dtype.IsDynamicObject (this))
 						return InternalType.Dynamic;
 
 					return spec;
 				}
 
 				if (!spec.IsGeneric || type.IsGenericTypeDefinition)
 					return spec;
 
 				if (!dtype.HasDynamicAttribute (this))
 					return spec;
 
 				// We've found same object in the cache but this one has a dynamic custom attribute
 				// and it's most likely dynamic version of same type IFoo<object> agains IFoo<dynamic>
 				// Do type resolve process again in that case
 
 				// TODO
 			}
 
 			if (type.IsGenericType && !type.IsGenericTypeDefinition) {
 				var type_def = type.GetGenericTypeDefinition ();
 				var targs = CreateGenericArguments (0, type.GetGenericArguments (), dtype);
 				if (declaringType == null) {
 					// Simple case, no nesting
 					spec = CreateType (type_def, null, new DynamicTypeReader (), canImportBaseType);
 					spec = spec.MakeGenericType (targs);
 				} else {
 					//
 					// Nested type case, converting .NET types like
 					// A`1.B`1.C`1<int, long, string> to typespec like
 					// A<int>.B<long>.C<string>
 					//
 					var nested_hierarchy = new List<TypeSpec> ();
 					while (declaringType.IsNested) {
 						nested_hierarchy.Add (declaringType);
 						declaringType = declaringType.DeclaringType;
 					}
 					while (declaringType.IsNested) {
 						nested_hierarchy.Add (declaringType);
 						declaringType = declaringType.DeclaringType;
 					}
 
 					int targs_pos = 0;
 					if (declaringType.Arity > 0) {
 						spec = declaringType.MakeGenericType (targs.Skip (targs_pos).Take (declaringType.Arity).ToArray ());
 						targs_pos = spec.Arity;
 					} else {
 						spec = declaringType;
 					}
 
 					for (int i = nested_hierarchy.Count; i != 0; --i) {
 						var t = nested_hierarchy [i - 1];
 						spec = MemberCache.FindNestedType (spec, t.Name, t.Arity);
 						if (t.Arity > 0) {
 							spec = spec.MakeGenericType (targs.Skip (targs_pos).Take (spec.Arity).ToArray ());
 							targs_pos += t.Arity;
 						}
 					}
 					for (int i = nested_hierarchy.Count; i != 0; --i) {
 						var t = nested_hierarchy [i - 1];
 						spec = MemberCache.FindNestedType (spec, t.Name, t.Arity);
 						if (t.Arity > 0) {
 							spec = spec.MakeGenericType (targs.Skip (targs_pos).Take (spec.Arity).ToArray ());
 							targs_pos += t.Arity;
 						}
 					}
 
 					string name = type.Name;
 					int index = name.IndexOf ('`');
 					if (index > 0)
 						name = name.Substring (0, index);
 
 					spec = MemberCache.FindNestedType (spec, name, targs.Length - targs_pos);
 					if (spec.Arity > 0) {
 						spec = spec.MakeGenericType (targs.Skip (targs_pos).ToArray ());
 					}
 				}
 
 				// Don't add generic type with dynamic arguments, they can interfere with same type
 				// using object type arguments
 				if (!spec.HasDynamicElement) {
 
 					// Add to reading cache to speed up reading
 					if (!import_cache.ContainsKey (type))
 						import_cache.Add (type, spec);
 				}
 
 				return spec;
 			}
 
 			Modifiers mod;
 			MemberKind kind;
 
 			var ma = type.Attributes;
 			switch (ma & TypeAttributes.VisibilityMask) {
 			case TypeAttributes.Public
 			case TypeAttributes.NestedPublic
 				mod = Modifiers.PUBLIC;
 				break;
 			case TypeAttributes.NestedPrivate
 				mod = Modifiers.PRIVATE;
 				break;
 			case TypeAttributes.NestedFamily
 				mod = Modifiers.PROTECTED;
 				break;
 			case TypeAttributes.NestedFamORAssem
 				mod = Modifiers.PROTECTED | Modifiers.INTERNAL;
 				break;
 			default
 				mod = Modifiers.INTERNAL;
 				break;
 			}
 
 			if ((ma & TypeAttributes.Interface) != 0) {
 				kind = MemberKind.Interface;
 			} else if (type.IsGenericParameter) {
 				kind = MemberKind.TypeParameter;
 			} else {
 				var base_type = type.BaseType;
 				if (base_type == null || (ma & TypeAttributes.Abstract) != 0) {
 					kind = MemberKind.Class;
 				} else {
 					kind = DetermineKindFromBaseType (base_type);
 					if (kind == MemberKind.Struct || kind == MemberKind.Delegate) {
 						mod |= Modifiers.SEALED;
 					}
 				}
 
 				if (kind == MemberKind.Class) {
 					if ((ma & TypeAttributes.Sealed) != 0) {
 						mod |= Modifiers.SEALED;
 						if ((ma & TypeAttributes.Abstract) != 0)
 							mod |= Modifiers.STATIC;
 					} else if ((ma & TypeAttributes.Abstract) != 0) {
 						mod |= Modifiers.ABSTRACT;
 					}
 				}
 			}
 
 			var definition = new ImportedTypeDefinition (type, this);
 			BuildinTypeSpec pt;
 
 			if (kind == MemberKind.Enum) {
 				const BindingFlags underlying_member = BindingFlags.DeclaredOnly |
 					BindingFlags.Instance |
 					BindingFlags.Public | BindingFlags.NonPublic;
 
 				var type_members = type.GetFields (underlying_member);
 				foreach (var type_member in type_members) {
 					spec = new EnumSpec (declaringType, definition, CreateType (type_member.FieldType), type, mod);
 					break;
 				foreach (var type_member in type_members) {
 					spec = new EnumSpec (declaringType, definition, CreateType (type_member.FieldType), type, mod);
 					break;
 				}
 
 				if (spec == null)
 					kind = MemberKind.Class;
 
 			} else if (kind == MemberKind.TypeParameter) {
 				// Return as type_cache was updated
 				return CreateTypeParameter (type, declaringType);
 			} else if (type.IsGenericTypeDefinition) {
 				definition.TypeParameters = CreateGenericParameters (type, declaringType);
 
 				// Constraints are not loaded on demand and can reference this type
 				if (import_cache.TryGetValue (type, out spec))
 					return spec;
 
 			} else if (buildin_types.TryGetValue (type, out pt)) {
 				spec = pt;
 				pt.SetDefinition (definition, type, mod);
 			}
 
 			if (spec == null)
 				spec = new TypeSpec (kind, declaringType, definition, type, mod);
 
 			import_cache.Add (type, spec);
 
 			//
 			// Two stage setup as the base type can be inflated declaring type or
 			// another nested type inside same declaring type which has not been
 			// loaded, therefore we can import a base type of nested types once
 			// the types have been imported
 			//
 			if (canImportBaseType)
 				ImportTypeBase (spec, type);
 
 			return spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1122" endline="1248">
<![CDATA[
 
 			public AttributeUsageAttribute AttributeUsage;
 			public ObsoleteAttribute Obsolete;
 			public string[] Conditionals;
 			public string DefaultIndexerName;
 			public bool IsNotCLSCompliant;
 			public TypeSpec CoClass;
 			
 			public static AttributesBag Read (MemberInfo mi, MetadataImporter importer)
 			{
 				AttributesBag bag = null;
 				List<string> conditionals = null;
 
 				// It should not throw any loading exception
 				IList<CustomAttributeData> attrs = CustomAttributeData.GetCustomAttributes (mi);
 
 				string ns, name;
 				foreach (var a in attrs) {
 					importer.GetCustomAttributeTypeName (a, out ns, out name);
 					if (name == "ObsoleteAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						var args = a.ConstructorArguments;
 
 						if (args.Count == 1) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value);
 						} else if (args.Count == 2) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value, (bool) args[1].Value);
 						} else {
 							bag.Obsolete = new ObsoleteAttribute ();
 						}
 
 						continue;
 					}
 
 					if (name == "ConditionalAttribute") {
 						if (ns != "System.Diagnostics")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						if (conditionals == null)
 							conditionals = new List<string> (2);
 
 						conditionals.Add ((string) a.ConstructorArguments[0].Value);
 						continue;
 					}
 
 					if (name == "CLSCompliantAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						bag.IsNotCLSCompliant = !(bool) a.ConstructorArguments[0].Value;
 						continue;
 					}
 
 					// Type only attributes
 					if (mi.MemberType == MemberTypes.TypeInfo || mi.MemberType == MemberTypes.NestedType) {
 						if (name == "DefaultMemberAttribute") {
 							if (ns != "System.Reflection")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.DefaultIndexerName = (string) a.ConstructorArguments[0].Value;
 							continue;
 						}
 
 						if (name == "AttributeUsageAttribute") {
 							if (ns != "System")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.AttributeUsage = new AttributeUsageAttribute ((AttributeTargets) a.ConstructorArguments[0].Value);
 							foreach (var named in a.NamedArguments) {
 								if (named.MemberInfo.Name == "AllowMultiple")
 									bag.AttributeUsage.AllowMultiple = (bool) named.TypedValue.Value;
 								else if (named.MemberInfo.Name == "Inherited")
 									bag.AttributeUsage.Inherited = (bool) named.TypedValue.Value;
 							}
 							continue;
 						}
 
 						// Interface only attribute
 						if (name == "CoClassAttribute") {
 							if (ns != "System.Runtime.InteropServices")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.CoClass = importer.ImportType ((MetaType) a.ConstructorArguments[0].Value);
 							continue;
 						}
 					}
 				}
 
 				if (bag == null)
 					return Default;
 
 				if (conditionals != null)
 					bag.Conditionals = conditionals.ToArray ();
 				
 				return bag;
 			}
 		}
 
 		protected readonly MemberInfo provider;
 		protected AttributesBag cattrs;
 		protected readonly MetadataImporter importer;
 
 		public ImportedDefinition (MemberInfo provider, MetadataImporter importer)
 		{
 			this.provider = provider;
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="578" endline="671">
<![CDATA[
 
 		[Flags]
 		public enum MemberLookupRestrictions
 		{
 			None = 0,
 			InvocableOnly = 1,
 			ExactArity = 1 << 2,
 			ReadAccess = 1 << 3
 		}
 
 		//
 		// Lookup type `queried_type' for code in class `container_type' with a qualifier of
 		// `qualifier_type' or null to lookup members in the current class.
 		//
 		public static Expression MemberLookup (ResolveContext rc, TypeSpec currentType, TypeSpec queried_type, string name, int arity, MemberLookupRestrictions restrictions, Location loc)
 		{
 			var members = MemberCache.FindMembers (queried_type, name, false);
 			if (members == null)
 				return null;
 
 			MemberSpec non_method = null;
 			MemberSpec ambig_non_method = null;
 			currentType = currentType ?? InternalType.FakeInternalType;
 			do {
 				for (int i = 0; i < members.Count; ++i) {
 					var member = members[i];
 
 					// HACK
 					if ((member.Modifiers & Modifiers.OVERRIDE) != 0 && member.Kind != MemberKind.Event)
 						continue;
 
 					if ((arity > 0 || (restrictions & MemberLookupRestrictions.ExactArity) != 0) && member.Arity != arity)
 						continue;
 
 					if (rc != null) {
 						if (!member.IsAccessible (currentType))
 							continue;
 
 						//
 						// With runtime binder we can have a situation where queried type is inaccessible
 						// because it came via dynamic object, the check about inconsisted accessibility
 						// had no effect as the type was unknown during compilation
 						//
 						// class A {
 						//		private class N { }
 						//
 						//		public dynamic Foo ()
 						//		{
 						//			return new N ();
 						//		}
 						//	}
 						//
 						if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (currentType))
 							continue;
 					}
 
 					if ((restrictions & MemberLookupRestrictions.InvocableOnly) != 0) {
 						if (member is MethodSpec)
 							return new MethodGroupExpr (members, queried_type, loc);
 
 						if (!Invocation.IsMemberInvocable (member))
 							continue;
 					}
 
 					if (non_method == null || member is MethodSpec) {
 						non_method = member;
 					} else if (currentType != null) {
 						ambig_non_method = member;
 					}
 				}
 				for (int i = 0; i < members.Count; ++i) {
 					var member = members[i];
 
 					// HACK
 					if ((member.Modifiers & Modifiers.OVERRIDE) != 0 && member.Kind != MemberKind.Event)
 						continue;
 
 					if ((arity > 0 || (restrictions & MemberLookupRestrictions.ExactArity) != 0) && member.Arity != arity)
 						continue;
 
 					if (rc != null) {
 						if (!member.IsAccessible (currentType))
 							continue;
 
 						//
 						// With runtime binder we can have a situation where queried type is inaccessible
 						// because it came via dynamic object, the check about inconsisted accessibility
 						// had no effect as the type was unknown during compilation
 						//
 						// class A {
 						//		private class N { }
 						//
 						//		public dynamic Foo ()
 						//		{
 						//			return new N ();
 						//		}
 						//	}
 						//
 						if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (currentType))
 							continue;
 					}
 
 					if ((restrictions & MemberLookupRestrictions.InvocableOnly) != 0) {
 						if (member is MethodSpec)
 							return new MethodGroupExpr (members, queried_type, loc);
 
 						if (!Invocation.IsMemberInvocable (member))
 							continue;
 					}
 
 					if (non_method == null || member is MethodSpec) {
 						non_method = member;
 					} else if (currentType != null) {
 						ambig_non_method = member;
 					}
 				}
 
 				if (non_method != null) {
 					if (ambig_non_method != null && rc != null) {
 						rc.Report.SymbolRelatedToPreviousError (non_method);
 						rc.Report.SymbolRelatedToPreviousError (ambig_non_method);
 						rc.Report.Error (229, loc, "Ambiguity between `{0}' and `{1}'",
 							non_method.GetSignatureForError (), ambig_non_method.GetSignatureForError ());
 					}
 
 					if (non_method is MethodSpec)
 						return new MethodGroupExpr (members, queried_type, loc);
 
 					return ExprClassFromMemberInfo (non_method, loc);
 				}
 
 				if (members[0].DeclaringType.BaseType == null)
 					members = null;
 				else
 					members = MemberCache.FindMembers (members[0].DeclaringType.BaseType, name, false);
 
 			} while (members != null);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1947" endline="2040">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			Block prev_block = ec.CurrentBlock;
 			bool ok = true;
 
 			ec.CurrentBlock = this;
 			ec.StartFlowBranching (this);
 
 			Report.Debug (4, "RESOLVE BLOCK", StartLocation, ec.CurrentBranching);
 
 			//
 			// Compiler generated scope statements
 			//
 			if (scope_initializers != null) {
 				for (resolving_init_idx = 0; resolving_init_idx < scope_initializers.Count; ++resolving_init_idx) {
 					scope_initializers[resolving_init_idx.Value].Resolve (ec);
 				}
 				for (resolving_init_idx = 0; resolving_init_idx < scope_initializers.Count; ++resolving_init_idx) {
 					scope_initializers[resolving_init_idx.Value].Resolve (ec);
 				}
 
 				resolving_init_idx = null;
 			}
 
 			//
 			// This flag is used to notate nested statements as unreachable from the beginning of this block.
 			// For the purposes of this resolution, it doesn't matter that the whole block is unreachable 
 			// from the beginning of the function.  The outer Resolve() that detected the unreachability is
 			// responsible for handling the situation.
 			//
 			int statement_count = statements.Count;
 			for (int ix = 0; ix < statement_count; ix++){
 				Statement s = statements [ix];
 
 				//
 				// Warn if we detect unreachable code.
 				//
 				if (unreachable) {
 					if (s is EmptyStatement)
 						continue;
 
 					if (!unreachable_shown && !(s is LabeledStatement)) {
 						ec.Report.Warning (162, 2, s.loc, "Unreachable code detected");
 						unreachable_shown = true;
 					}
 
 					Block c_block = s as Block;
 					if (c_block != null)
 						c_block.unreachable = c_block.unreachable_shown = true;
 				}
 
 				//
 				// Note that we're not using ResolveUnreachable() for unreachable
 				// statements here.  ResolveUnreachable() creates a temporary
 				// flow branching and kills it afterwards.  This leads to problems
 				// if you have two unreachable statements where the first one
 				// assigns a variable and the second one tries to access it.
 				//
 
 				if (!s.Resolve (ec)) {
 					ok = false;
 					if (ec.IsInProbingMode)
 						break;
 
 					statements [ix] = new EmptyStatement (s.loc);
 					continue;
 				}
 
 				if (unreachable && !(s is LabeledStatement) && !(s is Block))
 					statements [ix] = new EmptyStatement (s.loc);
 
 				unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 				if (unreachable && s is LabeledStatement)
 					throw new InternalErrorException ("should not happen");
 			}
 			for (int ix = 0; ix < statement_count; ix++){
 				Statement s = statements [ix];
 
 				//
 				// Warn if we detect unreachable code.
 				//
 				if (unreachable) {
 					if (s is EmptyStatement)
 						continue;
 
 					if (!unreachable_shown && !(s is LabeledStatement)) {
 						ec.Report.Warning (162, 2, s.loc, "Unreachable code detected");
 						unreachable_shown = true;
 					}
 
 					Block c_block = s as Block;
 					if (c_block != null)
 						c_block.unreachable = c_block.unreachable_shown = true;
 				}
 
 				//
 				// Note that we're not using ResolveUnreachable() for unreachable
 				// statements here.  ResolveUnreachable() creates a temporary
 				// flow branching and kills it afterwards.  This leads to problems
 				// if you have two unreachable statements where the first one
 				// assigns a variable and the second one tries to access it.
 				//
 
 				if (!s.Resolve (ec)) {
 					ok = false;
 					if (ec.IsInProbingMode)
 						break;
 
 					statements [ix] = new EmptyStatement (s.loc);
 					continue;
 				}
 
 				if (unreachable && !(s is LabeledStatement) && !(s is Block))
 					statements [ix] = new EmptyStatement (s.loc);
 
 				unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 				if (unreachable && s is LabeledStatement)
 					throw new InternalErrorException ("should not happen");
 			}
 
 			Report.Debug (4, "RESOLVE BLOCK DONE", StartLocation,
 				      ec.CurrentBranching, statement_count);
 
 			while (ec.CurrentBranching is FlowBranchingLabeled)
 				ec.EndFlowBranching ();
 			while (ec.CurrentBranching is FlowBranchingLabeled)
 				ec.EndFlowBranching ();
 
 			bool flow_unreachable = ec.EndFlowBranching ();
 
 			ec.CurrentBlock = prev_block;
 
 			if (flow_unreachable)
 				flags |= Flags.HasRet;
 
 			// If we're a non-static `struct' constructor which doesn't have an
 			// initializer, then we must initialize all of the struct's fields.
 			if (this == ParametersBlock.TopBlock && !ParametersBlock.TopBlock.IsThisAssigned (ec) && !flow_unreachable)
 				ok = false;
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2653" endline="2756">
<![CDATA[
 
 		int consume_identifier (int c, bool quoted) 
 		{
 			//
 			// This method is very performance sensitive. It accounts
 			// for approximately 25% of all parser time
 			//
 
 			int pos = 0;
 			int column = col;
 
 			if (c == '\\') {
 				int surrogate;
 				c = escape (c, out surrogate);
 				if (surrogate != 0) {
 					id_builder [pos++] = (char) c;
 					c = surrogate;
 				}
 			}
 
 			id_builder [pos++] = (char) c;
 
 			try {
 				while (true) {
 					c = reader.Read ();
 
 					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9')) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					if (c < 0x80) {
 						if (c == '\\') {
 							int surrogate;
 							c = escape (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									id_builder[pos++] = (char) c;
 								c = surrogate;
 							}
 
 							continue;
 						}
 					} else if (Char.IsLetter ((char) c) || Char.GetUnicodeCategory ((char) c) == UnicodeCategory.ConnectorPunctuation) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					putback_char = c;
 					break;
 				while (true) {
 					c = reader.Read ();
 
 					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9')) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					if (c < 0x80) {
 						if (c == '\\') {
 							int surrogate;
 							c = escape (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									id_builder[pos++] = (char) c;
 								c = surrogate;
 							}
 
 							continue;
 						}
 					} else if (Char.IsLetter ((char) c) || Char.GetUnicodeCategory ((char) c) == UnicodeCategory.ConnectorPunctuation) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					putback_char = c;
 					break;
 				}
 			} catch (IndexOutOfRangeException) {
 				Report.Error (645, Location, "Identifier too long (limit is 512 chars)");
 				--pos;
 				col += pos;
 			}
 
 			col += pos - 1;
 
 			//
 			// Optimization
 			// on uppercase letters
 			//
 			if (id_builder [0] >= '_' && !quoted) {
 				int keyword = GetKeyword (id_builder, pos);
 				if (keyword != -1) {
 					val = LocatedToken.Create (null, ref_line, column);
 					return keyword;
 				}
 			}
 
 			//
 			// Keep identifiers in an array of hashtables to avoid needless
 			// allocations
 			//
 			var identifiers_group = identifiers [pos];
 			string s;
 			if (identifiers_group != null) {
 				if (identifiers_group.TryGetValue (id_builder, out s)) {
 					val = LocatedToken.Create (s, ref_line, column);
 					if (quoted)
 						AddEscapedIdentifier (((LocatedToken) val).Location);
 					return Token.IDENTIFIER;
 				}
 			} else {
 				// TODO
 				// corlib compilation peaks at 1000 and System.Core at 150
 				int capacity = pos > 20 ? 10 
 				identifiers_group = new Dictionary<char[],string> (capacity, new IdentifiersComparer (pos));
 				identifiers [pos] = identifiers_group;
 			}
 
 			char [] chars = new char [pos];
 			Array.Copy (id_builder, chars, pos);
 
 			s = new string (id_builder, 0, pos);
 			identifiers_group.Add (chars, s);
 
 			val = LocatedToken.Create (s, ref_line, column);
 			if (quoted)
 				AddEscapedIdentifier (((LocatedToken) val).Location);
 
 			return Token.IDENTIFIER;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1679" endline="1756">
<![CDATA[
 
 		public static AnonymousTypeClass Create (CompilerContext ctx, TypeContainer parent, IList<AnonymousTypeParameter> parameters, Location loc)
 		{
 			string name = ClassNamePrefix + types_counter++;
 
 			ParametersCompiled all_parameters;
 			TypeParameterName[] t_params;
 			SimpleName[] t_args;
 
 			if (parameters.Count == 0) {
 				all_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 				t_params = new TypeParameterName[0];
 				t_args = null;
 			} else {
 				t_args = new SimpleName[parameters.Count];
 				t_params = new TypeParameterName[parameters.Count];
 				Parameter[] ctor_params = new Parameter[parameters.Count];
 				for (int i = 0; i < parameters.Count; ++i) {
 					AnonymousTypeParameter p = parameters[i];
 
 					t_args[i] = new SimpleName ("<" + p.Name + ">__T", p.Location);
 					t_params[i] = new TypeParameterName (t_args[i].Name, null, p.Location);
 					ctor_params[i] = new GeneratedParameter (t_args[i], p);
 				}
 				for (int i = 0; i < parameters.Count; ++i) {
 					AnonymousTypeParameter p = parameters[i];
 
 					t_args[i] = new SimpleName ("<" + p.Name + ">__T", p.Location);
 					t_params[i] = new TypeParameterName (t_args[i].Name, null, p.Location);
 					ctor_params[i] = new GeneratedParameter (t_args[i], p);
 				}
 
 				all_parameters = new ParametersCompiled (ctor_params);
 			}
 
 			//
 			// Create generic anonymous type host with generic arguments
 			// named upon properties names
 			//
 			AnonymousTypeClass a_type = new AnonymousTypeClass (parent.NamespaceEntry.SlaveDeclSpace,
 				new MemberName (name, new TypeArguments (t_params), loc), parameters, loc);
 
 			if (parameters.Count > 0)
 				a_type.SetParameterInfo (null);
 
 			Constructor c = new Constructor (a_type, name, Modifiers.PUBLIC | Modifiers.DEBUGGER_HIDDEN,
 				null, all_parameters, null, loc);
 			c.Block = new ToplevelBlock (ctx, c.ParameterInfo, loc);
 
 			// 
 			// Create fields and contructor body with field initialization
 			//
 			bool error = false;
 			for (int i = 0; i < parameters.Count; ++i) {
 				AnonymousTypeParameter p = parameters [i];
 
 				Field f = new Field (a_type, t_args [i], Modifiers.PRIVATE | Modifiers.READONLY,
 					new MemberName ("<" + p.Name + ">", p.Location), null);
 
 				if (!a_type.AddField (f)) {
 					error = true;
 					continue;
 				}
 
 				c.Block.AddStatement (new StatementExpression (
 					new SimpleAssign (new MemberAccess (new This (p.Location), f.Name),
 						c.Block.GetParameterReference (i, p.Location))));
 
 				ToplevelBlock get_block = new ToplevelBlock (ctx, p.Location);
 				get_block.AddStatement (new Return (
 					new MemberAccess (new This (p.Location), f.Name), p.Location));
 
 				Property prop = new Property (a_type, t_args [i], Modifiers.PUBLIC,
 					new MemberName (p.Name, p.Location), null);
 				prop.Get = new Property.GetMethod (prop, 0, null, p.Location);
 				prop.Get.Block = get_block;
 				a_type.AddProperty (prop);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				AnonymousTypeParameter p = parameters [i];
 
 				Field f = new Field (a_type, t_args [i], Modifiers.PRIVATE | Modifiers.READONLY,
 					new MemberName ("<" + p.Name + ">", p.Location), null);
 
 				if (!a_type.AddField (f)) {
 					error = true;
 					continue;
 				}
 
 				c.Block.AddStatement (new StatementExpression (
 					new SimpleAssign (new MemberAccess (new This (p.Location), f.Name),
 						c.Block.GetParameterReference (i, p.Location))));
 
 				ToplevelBlock get_block = new ToplevelBlock (ctx, p.Location);
 				get_block.AddStatement (new Return (
 					new MemberAccess (new This (p.Location), f.Name), p.Location));
 
 				Property prop = new Property (a_type, t_args [i], Modifiers.PUBLIC,
 					new MemberName (p.Name, p.Location), null);
 				prop.Get = new Property.GetMethod (prop, 0, null, p.Location);
 				prop.Get.Block = get_block;
 				a_type.AddProperty (prop);
 			}
 
 			if (error)
 				return null;
 
 			a_type.AddConstructor (c);
 			return a_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4833" endline="4895">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (this);
 
 			if (!Block.Resolve (ec))
 				ok = false;
 
 			TypeSpec[] prev_catches = new TypeSpec [Specific.Count];
 			int last_index = 0;
 			foreach (Catch c in Specific){
 				ec.CurrentBranching.CreateSibling (c.Block, FlowBranching.SiblingType.Catch);
 
 				if (!c.Resolve (ec)) {
 					ok = false;
 					continue;
 				}
 
 				TypeSpec resolved_type = c.CatchType;
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 
 				prev_catches [last_index++] = resolved_type;
 			}
 			foreach (Catch c in Specific){
 				ec.CurrentBranching.CreateSibling (c.Block, FlowBranching.SiblingType.Catch);
 
 				if (!c.Resolve (ec)) {
 					ok = false;
 					continue;
 				}
 
 				TypeSpec resolved_type = c.CatchType;
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 
 				prev_catches [last_index++] = resolved_type;
 			}
 
 			if (General != null) {
 				foreach (Catch c in Specific) {
 					if (c.CatchType != TypeManager.exception_type)
 						continue;
 
 					if (!ec.Module.DeclaringAssembly.WrapNonExceptionThrows)
 						continue;
 
 					if (!ec.Module.PredefinedAttributes.RuntimeCompatibility.IsDefined)
 						continue;
 
 					ec.Report.Warning (1058, 1, c.loc,
 						"A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a `System.Runtime.CompilerServices.RuntimeWrappedException'");
 				}
 				foreach (Catch c in Specific) {
 					if (c.CatchType != TypeManager.exception_type)
 						continue;
 
 					if (!ec.Module.DeclaringAssembly.WrapNonExceptionThrows)
 						continue;
 
 					if (!ec.Module.PredefinedAttributes.RuntimeCompatibility.IsDefined)
 						continue;
 
 					ec.Report.Warning (1058, 1, c.loc,
 						"A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a `System.Runtime.CompilerServices.RuntimeWrappedException'");
 				}
 
 				ec.CurrentBranching.CreateSibling (General.Block, FlowBranching.SiblingType.Catch);
 
 				if (!General.Resolve (ec))
 					ok = false;
 			}
 
 			ec.EndFlowBranching ();
 
 			// System.Reflection.Emit automatically emits a 'leave' at the end of a try/catch clause
 			// So, ensure there's some IL code after this statement
 			if (!inside_try_finally && !code_follows && ec.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				ec.NeedReturnLabel ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="780" endline="910">
<![CDATA[
 
 		/// <summary>
 		/// Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
 		/// </summary>
 		/// <returns></returns>
 		public void ExtractSecurityPermissionSet (MethodSpec ctor, ref SecurityType permissions)
 		{
 #if STATIC
 			object[] values = new object [PosArguments.Count];
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 
 			PropertyInfo[] prop;
 			object[] prop_values;
 			if (named_values == null) {
 				prop = null;
 				prop_values = null;
 			} else {
 				prop = new PropertyInfo[named_values.Count];
 				prop_values = new object [named_values.Count];
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			var cab = new CustomAttributeBuilder ((ConstructorInfo) ctor.GetMetaInfo (), values, prop, prop_values);
 			permissions.Add (cab);
 #else
 			Type orig_assembly_type = null;
 
 			if (Type.MemberDefinition is TypeContainer) {
 				if (!RootContext.StdLib) {
 					orig_assembly_type = System.Type.GetType (Type.GetMetaInfo ().FullName);
 				} else {
 					string orig_version_path = Environment.GetEnvironmentVariable ("__SECURITY_BOOTSTRAP_DB");
 					if (orig_version_path == null) {
 						Error_AttributeEmitError ("security custom attributes can not be referenced from defining assembly");
 						return;
 					}
 
 					if (orig_sec_assembly == null) {
 						string file = Path.Combine (orig_version_path, Path.GetFileName (RootContext.OutputFile));
 						orig_sec_assembly = Assembly.LoadFile (file);
 					}
 
 					orig_assembly_type = orig_sec_assembly.GetType (Type.GetMetaInfo ().FullName, true);
 					if (orig_assembly_type == null) {
 						Report.Warning (-112, 1, Location, "Self-referenced security attribute `{0}' " +
 								"was not found in previous version of assembly");
 						return;
 					}
 				}
 			}
 
 			SecurityAttribute sa;
 			object[] args;
 
 			// For all non-selfreferencing security attributes we can avoid all hacks
 			if (orig_assembly_type == null) {
 				args = new object[PosArguments.Count];
 				for (int j = 0; j < args.Length; ++j) {
 					args[j] = ((Constant) PosArguments[j].Expr).GetValue ();
 				}
 
 				sa = (SecurityAttribute) Activator.CreateInstance (Type.GetMetaInfo (), args);
 
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						pi.SetValue (sa, ((Constant) named_values [i].Value.Expr).GetValue (), null);
 					}
 				}
 			} else {
 				// HACK
 				args = new object[] { GetSecurityActionValue () };
 				sa = (SecurityAttribute) Activator.CreateInstance (orig_assembly_type, args);
 
 				// All types are from newly created assembly but for invocation with old one we need to convert them
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo emited_pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						// FIXME
 						// TODO
 						PropertyInfo pi = orig_assembly_type.GetProperty (emited_pi.Name);
 
 						pi.SetValue (sa, ((Constant) named_values[i].Value.Expr).GetValue (), null);
 					}
 				}
 			}
 
 			IPermission perm;
 			perm = sa.CreatePermission ();
 			SecurityAction action = (SecurityAction) args [0];
 
 			// IS is correct because for corlib we are using an instance from old corlib
 			if (!(perm is System.Security.CodeAccessPermission)) {
 				switch (action) {
 				case SecurityAction.Demand
 					action = (SecurityAction)13;
 					break;
 				case SecurityAction.LinkDemand
 					action = (SecurityAction)14;
 					break;
 				case SecurityAction.InheritanceDemand
 					action = (SecurityAction)15;
 					break;
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			PermissionSet ps;
 			if (!permissions.TryGetValue (action, out ps)) {
 				if (sa is PermissionSetAttribute)
 					ps = new PermissionSet (sa.Unrestricted ? PermissionState.Unrestricted 
 				else
 					ps = new PermissionSet (PermissionState.None);
 
 				permissions.Add (action, ps);
 			} else if (!ps.IsUnrestricted () && (sa is PermissionSetAttribute) && sa.Unrestricted) {
 				ps = ps.Union (new PermissionSet (PermissionState.Unrestricted));
 				permissions [action] = ps;
 			}
 			ps.AddPermission (perm);
 #endif
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1027" endline="1155">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			
 			if (expr == null)
 				return null;
 
 			if (expr.Type == InternalType.Dynamic) {
 				//
 				// Handle postfix unary operators using local
 				// temporary variable
 				//
 				if ((mode & Mode.IsPost) != 0)
 					expr = new DynamicPostMutator (expr);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new SimpleAssign (expr, new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc)).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (expr.Type))
 				return new Nullable.LiftedUnaryMutator (mode, expr, loc).Resolve (ec);
 
 			eclass = ExprClass.Value;
 			type = expr.Type;
 
 			if (expr is RuntimeValueExpression) {
 				operation = expr;
 			} else {
 				// Use itself at the top of the stack
 				operation = new EmptyExpression (type);
 			}
 
 			//
 			// The operand of the prefix/postfix increment decrement operators
 			// should be an expression that is classified as a variable,
 			// a property access or an indexer access
 			//
 			// TODO
 			if (expr.eclass == ExprClass.Variable || expr.eclass == ExprClass.IndexerAccess || expr.eclass == ExprClass.PropertyAccess) {
 				expr = expr.ResolveLValue (ec, expr);
 			} else {
 				ec.Report.Error (1059, loc, "The operand of an increment or decrement operator must be a variable, property or indexer");
 			}
 
 			//
 			// Step 1
 			//
 			var user_op = IsDecrement ? Operator.OpType.Decrement 
 			var methods = MemberCache.GetUserOperator (type, user_op, false);
 
 			if (methods != null) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 
 				var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 				var method = res.ResolveOperator (ec, ref args);
 				if (method == null)
 					return null;
 
 				args[0].Expr = operation;
 				operation = new UserOperatorCall (method, args, null, loc);
 				operation = Convert.ImplicitConversionRequired (ec, operation, type, loc);
 				return this;
 			}
 
 			//
 			// Step 2
 			//
 			if (predefined == null)
 				CreatePredefinedOperators ();
 
 			// Predefined without user conversion first for speed-up
 			Expression source = null;
 			bool primitive_type = false;
 			foreach (var t in predefined) {
 				if (t == type) {
 					source = operation;
 					primitive_type = true;
 					break;
 				}
 			}
 			foreach (var t in predefined) {
 				if (t == type) {
 					source = operation;
 					primitive_type = true;
 					break;
 				}
 			}
 
 			// ++/-- on pointer variables of all types except void*
 			if (source == null && type.IsPointer) {
 				if (((PointerContainer) type).Element.BuildinType == BuildinTypeSpec.Type.Void) {
 					Error_VoidPointerOperation (ec);
 					return null;
 				}
 
 				source = operation;
 			}
 
 			if (source == null) {
 				// LAMESPEC
 				foreach (var t in predefined) {
 					source = Convert.ImplicitUserConversion (ec, operation, t, loc);
 					if (source != null) {
 						break;
 					}
 				}
 				foreach (var t in predefined) {
 					source = Convert.ImplicitUserConversion (ec, operation, t, loc);
 					if (source != null) {
 						break;
 					}
 				}
 			}
 
 			// ++/-- on enum types
 			if (source == null && type.IsEnum)
 				source = operation;
 
 			if (source == null) {
 				Unary.Error_OperatorCannotBeApplied (ec, loc, Operator.GetName (user_op), type);
 				return null;
 			}
 
 			var one = new IntConstant (1, loc);
 			var op = IsDecrement ? Binary.Operator.Subtraction 
 			operation = new Binary (op, source, one, loc);
 			operation = operation.Resolve (ec);
 			if (operation == null)
 				throw new NotImplementedException ("should not be reached");
 
 			if (operation.Type != type) {
 				if (primitive_type)
 					operation = Convert.ExplicitNumericConversion (operation, type);
 				else
 					operation = Convert.ImplicitConversionRequired (ec, operation, type, loc);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="661" endline="788">
<![CDATA[
 
 		/// <summary>
 		///  Determines if a standard implicit conversion exists from
 		///  expr_type to target_type
 		///
 		/// </summary>
 		public static bool ImplicitStandardConversionExists (Expression expr, TypeSpec target_type)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			NullLiteral nl = expr as NullLiteral;
 			if (nl != null)
 				return nl.ConvertImplicitly (null, target_type) != null;
 
 			if (expr_type == TypeManager.void_type)
 				return false;
 
 			if (expr_type == target_type)
 				return true;
 
 			// Implicit dynamic conversion
 			if (expr_type == InternalType.Dynamic) {
 				switch (target_type.Kind) {
 				case MemberKind.ArrayType
 				case MemberKind.Class
 				case MemberKind.Struct
 				case MemberKind.Delegate
 				case MemberKind.Enum
 				case MemberKind.Interface
 				case MemberKind.TypeParameter
 					return true;
 				}
 
 				// dynamic to __arglist
 				if (target_type == InternalType.Arglist)
 					return true;
 
 				return false;
 			}
 
 			if (TypeManager.IsNullableType (target_type)) {
 				return ImplicitNulableConversion (null, expr, target_type) != null;
 			}
 
 			// First numeric conversions
 			if (ImplicitNumericConversion (null, expr_type, target_type) != null)
 				return true;
 
 			if (ImplicitReferenceConversionExists (expr, target_type))
 				return true;
 
 			if (ImplicitBoxingConversion (null, expr_type, target_type) != null)
 				return true;
 			
 			//
 			// Implicit Constant Expression Conversions
 			//
 			if (expr is IntConstant){
 				int value = ((IntConstant) expr).Value;
 
 				if (target_type == TypeManager.sbyte_type){
 					if (value >= SByte.MinValue && value <= SByte.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.byte_type){
 					if (value >= 0 && value <= Byte.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.short_type){
 					if (value >= Int16.MinValue && value <= Int16.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.ushort_type){
 					if (value >= UInt16.MinValue && value <= UInt16.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.uint32_type){
 					if (value >= 0)
 						return true;
 				} else if (target_type == TypeManager.uint64_type){
 					 //
 					 // we can optimize this case
 					 // always fits on a uint64.  But we need an opcode
 					 // to do it.
 					 //
 					if (value >= 0)
 						return true;
 				}
 			}
 
 			if (expr is LongConstant && target_type == TypeManager.uint64_type){
 				//
 				// Try the implicit constant expression conversion
 				// from long to ulong, instead of a nice routine,
 				// we just inline it
 				//
 				long v = ((LongConstant) expr).Value;
 				if (v >= 0)
 					return true;
 			}
 
 			if (expr is IntegralConstant && TypeManager.IsEnumType (target_type)) {
 				var i = (IntegralConstant) expr;
 				//
 				// LAMESPEC
 				//
 				// An implicit enumeration conversion permits the decimal-integer-literal 0
 				// to be converted to any enum-type and to any nullable-type whose underlying
 				// type is an enum-type
 				//
 				return i.IsZeroInteger;
 			}
 
 			//
 			// If `expr_type' implements `target_type' (which is an iface)
 			// see TryImplicitIntConversion
 			//
 			if (target_type.IsInterface && expr_type.ImplementsInterface (target_type, true))
 				return true;
 
 			if (target_type.IsPointer && expr_type.IsPointer && ((PointerContainer) target_type).Element.BuildinType == BuildinTypeSpec.Type.Void)
 				return true;
 
 			// Conversion from __arglist to System.ArgIterator
 			if (expr_type == InternalType.Arglist)
 				return target_type == TypeManager.arg_iterator_type;
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type))
 				return true;
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2743" endline="2842">
<![CDATA[
 
 		public bool ResolveInstanceExpression (ResolveContext rc, Expression rhs)
 		{
 			if (IsStatic) {
 				if (InstanceExpression != null) {
 					if (InstanceExpression is TypeExpr) {
 						var t = InstanceExpression.Type;
 						do {
 							ObsoleteAttribute oa = t.GetAttributeObsolete ();
 							if (oa != null && !rc.IsObsolete) {
 								AttributeTester.Report_ObsoleteMessage (oa, t.GetSignatureForError (), loc, rc.Report);
 							}
 
 							t = t.DeclaringType;
 						} while (t != null);
 					} else {
 						var runtime_expr = InstanceExpression as RuntimeValueExpression;
 						if (runtime_expr == null || !runtime_expr.IsSuggestionOnly) {
 							rc.Report.Error (176, loc,
 								"Static member `{0}' cannot be accessed with an instance reference, qualify it with a type name instead",
 								GetSignatureForError ());
 						}
 					}
 
 					InstanceExpression = null;
 				}
 
 				return false;
 			}
 
 			if (InstanceExpression == null || InstanceExpression is TypeExpr) {
 				if (InstanceExpression != null || !This.IsThisAvailable (rc, true)) {
 					if (rc.HasSet (ResolveContext.Options.FieldInitializerScope))
 						rc.Report.Error (236, loc,
 							"A field initializer cannot reference the nonstatic field, method, or property `{0}'",
 							GetSignatureForError ());
 					else
 						rc.Report.Error (120, loc,
 							"An object reference is required to access non-static member `{0}'",
 							GetSignatureForError ());
 
 					return false;
 				}
 
 				if (!TypeManager.IsFamilyAccessible (rc.CurrentType, DeclaringType)) {
 					rc.Report.Error (38, loc,
 						"Cannot access a nonstatic member of outer type `{0}' via nested type `{1}'",
 						DeclaringType.GetSignatureForError (), rc.CurrentType.GetSignatureForError ());
 				}
 
 				InstanceExpression = new This (loc);
 				if (this is FieldExpr && rc.CurrentType.IsStruct) {
 					using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 						InstanceExpression = InstanceExpression.Resolve (rc);
 					}
 				} else {
 					InstanceExpression = InstanceExpression.Resolve (rc);
 				}
 
 				return false;
 			}
 
 			var me = InstanceExpression as MemberExpr;
 			if (me != null) {
 				me.ResolveInstanceExpression (rc, rhs);
 
 				var fe = me as FieldExpr;
 				if (fe != null && fe.IsMarshalByRefAccess ()) {
 					rc.Report.SymbolRelatedToPreviousError (me.DeclaringType);
 					rc.Report.Warning (1690, 1, loc,
 						"Cannot call methods, properties, or indexers on `{0}' because it is a value type member of a marshal-by-reference class",
 						me.GetSignatureForError ());
 				}
 
 				return true;
 			}
 
 			//
 			// Run member-access postponed check once we know that
 			// the expression is not field expression which is the only
 			// expression which can use uninitialized this
 			//
 			if (InstanceExpression is This && !(this is FieldExpr) && rc.CurrentType.IsStruct) {
 				((This)InstanceExpression).CheckStructThisDefiniteAssignment (rc);
 			}
 
 			//
 			// Additional checks for l-value member access
 			//
 			if (rhs != null) {
 				//
 				// TODO
 				//
 				if (InstanceExpression is UnboxCast) {
 					rc.Report.Error (445, InstanceExpression.Location, "Cannot modify the result of an unboxing conversion");
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="939" endline="1009">
<![CDATA[
 
 		//
 		// Checks that some operators come in pairs
 		//  == and !=
 		// > and <
 		// >= and <=
 		// true and false
 		//
 		// They are matched based on the return type and the argument types
 		//
 		void CheckPairedOperators ()
 		{
 			bool has_equality_or_inequality = false;
 			var operators = this.operators.ToArray ();
 			bool[] has_pair = new bool[operators.Length];
 
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null)
 					continue;
 
 				Operator o_a = (Operator) operators[i];
 				Operator.OpType o_type = o_a.OperatorType;
 				if (o_type == Operator.OpType.Equality || o_type == Operator.OpType.Inequality)
 					has_equality_or_inequality = true;
 
 				Operator.OpType matching_type = o_a.GetMatchingOperator ();
 				if (matching_type == Operator.OpType.TOP) {
 					operators[i] = null;
 					continue;
 				}
 
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 			}
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null)
 					continue;
 
 				Operator o_a = (Operator) operators[i];
 				Operator.OpType o_type = o_a.OperatorType;
 				if (o_type == Operator.OpType.Equality || o_type == Operator.OpType.Inequality)
 					has_equality_or_inequality = true;
 
 				Operator.OpType matching_type = o_a.GetMatchingOperator ();
 				if (matching_type == Operator.OpType.TOP) {
 					operators[i] = null;
 					continue;
 				}
 
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 			}
 
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null || has_pair[i])
 					continue;
 
 				Operator o = (Operator) operators [i];
 				Report.Error (216, o.Location,
 					"The operator `{0}' requires a matching operator `{1}' to also be defined",
 					o.GetSignatureForError (), Operator.GetName (o.GetMatchingOperator ()));
 			}
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null || has_pair[i])
 					continue;
 
 				Operator o = (Operator) operators [i];
 				Report.Error (216, o.Location,
 					"The operator `{0}' requires a matching operator `{1}' to also be defined",
 					o.GetSignatureForError (), Operator.GetName (o.GetMatchingOperator ()));
 			}
 
 			if (has_equality_or_inequality) {
 				if (Methods == null || !HasEquals)
 					Report.Warning (660, 2, Location, "`{0}' defines operator == or operator != but does not override Object.Equals(object o)",
 						GetSignatureForError ());
 
 				if (Methods == null || !HasGetHashCode)
 					Report.Warning (661, 2, Location, "`{0}' defines operator == or operator != but does not override Object.GetHashCode()",
 						GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="709" endline="803">
<![CDATA[
 
 		//
 		// Returns all not implememted abstract members inside abstract type
 		// NOTE
 		//
 		public static IList<MethodSpec> GetNotImplementedAbstractMethods (TypeSpec type)
 		{
 			if (type.MemberCache.missing_abstract != null)
 				return type.MemberCache.missing_abstract;
 				
 			var abstract_methods = new List<MethodSpec> ();
 			List<TypeSpec> hierarchy = null;
 
 			//
 			// Stage 1
 			//
 			var abstract_type = type;
 			while (true) {
 				foreach (var entry in abstract_type.MemberCache.member_hash) {
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 				}
 				foreach (var entry in abstract_type.MemberCache.member_hash) {
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 				}
 
 				var base_type = abstract_type.BaseType;
 				if (!base_type.IsAbstract)
 					break;
 
 				if (hierarchy == null)
 					hierarchy = new List<TypeSpec> ();
 
 				hierarchy.Add (abstract_type);
 				abstract_type = base_type;
 			}
 			while (true) {
 				foreach (var entry in abstract_type.MemberCache.member_hash) {
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 				}
 
 				var base_type = abstract_type.BaseType;
 				if (!base_type.IsAbstract)
 					break;
 
 				if (hierarchy == null)
 					hierarchy = new List<TypeSpec> ();
 
 				hierarchy.Add (abstract_type);
 				abstract_type = base_type;
 			}
 
 			int not_implemented_count = abstract_methods.Count;
 			if (not_implemented_count == 0 || hierarchy == null) {
 				type.MemberCache.missing_abstract = abstract_methods;
 				return type.MemberCache.missing_abstract;
 			}
 
 			//
 			// Stage 2
 			//
 			foreach (var type_up in hierarchy) {
 				var members = type_up.MemberCache.member_hash;
 				if (members.Count == 0)
 					continue;
 
 				for (int i = 0; i < abstract_methods.Count; ++i) {
 					var candidate = abstract_methods [i];
 					if (candidate == null)
 						continue;
 
 					IList<MemberSpec> applicable;
 					if (!members.TryGetValue (candidate.Name, out applicable))
 						continue;
 
 					var filter = new MemberFilter (candidate);
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 				}
 				for (int i = 0; i < abstract_methods.Count; ++i) {
 					var candidate = abstract_methods [i];
 					if (candidate == null)
 						continue;
 
 					IList<MemberSpec> applicable;
 					if (!members.TryGetValue (candidate.Name, out applicable))
 						continue;
 
 					var filter = new MemberFilter (candidate);
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 				}
 			}
 			foreach (var type_up in hierarchy) {
 				var members = type_up.MemberCache.member_hash;
 				if (members.Count == 0)
 					continue;
 
 				for (int i = 0; i < abstract_methods.Count; ++i) {
 					var candidate = abstract_methods [i];
 					if (candidate == null)
 						continue;
 
 					IList<MemberSpec> applicable;
 					if (!members.TryGetValue (candidate.Name, out applicable))
 						continue;
 
 					var filter = new MemberFilter (candidate);
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 				}
 			}
 
 			if (not_implemented_count == abstract_methods.Count) {
 				type.MemberCache.missing_abstract = abstract_methods;
 				return type.MemberCache.missing_abstract;
 			}
 
 			var not_implemented = new MethodSpec[not_implemented_count];
 			int counter = 0;
 			foreach (var m in abstract_methods) {
 				if (m == null)
 					continue;
 
 				not_implemented[counter++] = m;
 			}
 			foreach (var m in abstract_methods) {
 				if (m == null)
 					continue;
 
 				not_implemented[counter++] = m;
 			}
 
 			type.MemberCache.missing_abstract = not_implemented;
 			return type.MemberCache.missing_abstract;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3360" endline="3433">
<![CDATA[
 
 		//
 		// Build-in operators method overloading
 		//
 		protected virtual Expression ResolveOperatorPredefined (ResolveContext ec, PredefinedOperator [] operators, bool primitives_only, TypeSpec enum_type)
 		{
 			PredefinedOperator best_operator = null;
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Operator oper_mask = oper & ~Operator.ValuesOnlyMask;
 
 			foreach (PredefinedOperator po in operators) {
 				if ((po.OperatorsMask & oper_mask) == 0)
 					continue;
 
 				if (primitives_only) {
 					if (!po.IsPrimitiveApplicable (l, r))
 						continue;
 				} else {
 					if (!po.IsApplicable (ec, left, right))
 						continue;
 				}
 
 				if (best_operator == null) {
 					best_operator = po;
 					if (primitives_only)
 						break;
 
 					continue;
 				}
 
 				best_operator = po.ResolveBetterOperator (ec, best_operator);
 
 				if (best_operator == null) {
 					ec.Report.Error (34, loc, "Operator `{0}' is ambiguous on operands of type `{1}' and `{2}'",
 						OperName (oper), TypeManager.CSharpName (l), TypeManager.CSharpName (r));
 
 					best_operator = po;
 					break;
 				}
 			}
 			foreach (PredefinedOperator po in operators) {
 				if ((po.OperatorsMask & oper_mask) == 0)
 					continue;
 
 				if (primitives_only) {
 					if (!po.IsPrimitiveApplicable (l, r))
 						continue;
 				} else {
 					if (!po.IsApplicable (ec, left, right))
 						continue;
 				}
 
 				if (best_operator == null) {
 					best_operator = po;
 					if (primitives_only)
 						break;
 
 					continue;
 				}
 
 				best_operator = po.ResolveBetterOperator (ec, best_operator);
 
 				if (best_operator == null) {
 					ec.Report.Error (34, loc, "Operator `{0}' is ambiguous on operands of type `{1}' and `{2}'",
 						OperName (oper), TypeManager.CSharpName (l), TypeManager.CSharpName (r));
 
 					best_operator = po;
 					break;
 				}
 			}
 
 			if (best_operator == null)
 				return null;
 
 			Expression expr = best_operator.ConvertResult (ec, this);
 
 			//
 			// Optimize &/&& constant expressions with 0 value
 			//
 			if (oper == Operator.BitwiseAnd || oper == Operator.LogicalAnd) {
 				Constant rc = right as Constant;
 				Constant lc = left as Constant;
 				if (((lc != null && lc.IsDefaultValue) || (rc != null && rc.IsDefaultValue)) && !(this is Nullable.LiftedBinaryOperator)) {
 					//
 					// The result is a constant with side-effect
 					//
 					Constant side_effect = rc == null ?
 						new SideEffectConstant (lc, right, loc) 
 						new SideEffectConstant (rc, left, loc);
 
 					return ReducedExpression.Create (side_effect.Resolve (ec), expr);
 				}
 			}
 
 			if (enum_type == null)
 				return expr;
 
 			//
 			// HACK
 			//
 			expr.Type = enum_type;
 			return EmptyCast.Create (expr, enum_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3542" endline="3714">
<![CDATA[
 
 		/// <summary>
 		///   Determines "Better function" between candidate
 		///   and the current best match
 		/// </summary>
 		/// <remarks>
 		///    Returns a boolean indicating 
 		///     false if candidate ain't better
 		///     true  if candidate is better than the current best match
 		/// </remarks>
 		static bool BetterFunction (ResolveContext ec, Arguments args, MemberSpec candidate, AParametersCollection cparam, bool candidate_params,
 			MemberSpec best, AParametersCollection bparam, bool best_params)
 		{
 			AParametersCollection candidate_pd = ((IParametersMember) candidate).Parameters;
 			AParametersCollection best_pd = ((IParametersMember) best).Parameters;
 
 			bool better_at_least_one = false;
 			bool same = true;
 			int args_count = args == null ? 0 
 			int j = 0;
 			Argument a = null;
 			TypeSpec ct, bt;
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 
 			if (better_at_least_one)
 				return true;
 
 			//
 			// This handles the case
 			//
 			//   Add (float f1, float f2, float f3);
 			//   Add (params decimal [] foo);
 			//
 			// The call Add (3, 4, 5) should be ambiguous.  Without this check, the
 			// first candidate would've chosen as better.
 			//
 			if (!same && !a.IsDefaultArgument)
 				return false;
 
 			//
 			// The two methods have equal non-optional parameter types, apply tie-breaking rules
 			//
 
 			//
 			// This handles the following cases
 			//
 			//  Foo (int i) is better than Foo (int i, long l = 0)
 			//  Foo (params int[] args) is better than Foo (int i = 0, params int[] args)
 			//
 			// Prefer non-optional version
 			//
 			// LAMESPEC
 			//
 			if (candidate_params == best_params && candidate_pd.Count != best_pd.Count) {
 				if (candidate_pd.Count >= best_pd.Count)
 					return false;
 
 				if (j < candidate_pd.Count && candidate_pd.FixedParameters[j].HasDefaultValue)
 					return false;
 
 				return true;
 			}
 
 			//
 			// One is a non-generic method and second is a generic method, then non-generic is better
 			//
 			if (best.IsGeneric != candidate.IsGeneric)
 				return best.IsGeneric;
 
 			//
 			// This handles the following cases
 			//
 			//   Trim () is better than Trim (params char[] chars)
 			//   Concat (string s1, string s2, string s3) is better than
 			//     Concat (string s1, params string [] srest)
 			//   Foo (int, params int [] rest) is better than Foo (params int [] rest)
 			//
 			// Prefer non-expanded version
 			//
 			if (candidate_params != best_params)
 				return best_params;
 
 			int candidate_param_count = candidate_pd.Count;
 			int best_param_count = best_pd.Count;
 
 			if (candidate_param_count != best_param_count)
 				// can only happen if (candidate_params && best_params)
 				return candidate_param_count > best_param_count && best_pd.HasParams;
 
 			//
 			// Both methods have the same number of parameters, and the parameters have equal types
 			// Pick the "more specific" signature using rules over original (non-inflated) types
 			//
 			var candidate_def_pd = ((IParametersMember) candidate.MemberDefinition).Parameters;
 			var best_def_pd = ((IParametersMember) best.MemberDefinition).Parameters;
 
 			bool specific_at_least_once = false;
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 
 			if (specific_at_least_once)
 				return true;
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1137" endline="1225">
<![CDATA[
 
 		bool DefineBaseTypes ()
 		{
 			iface_exprs = ResolveBaseTypes (out base_type_expr);
 			if (partial_parts != null) {
 				iface_exprs = GetNormalPartialBases ();
 			}
 
 			var cycle = CheckRecursiveDefinition (this);
 			if (cycle != null) {
 				Report.SymbolRelatedToPreviousError (cycle);
 				if (this is Interface) {
 					Report.Error (529, Location,
 						"Inherited interface `{0}' causes a cycle in the interface hierarchy of `{1}'",
 					    GetSignatureForError (), cycle.GetSignatureForError ());
 
 					iface_exprs = null;
 				} else {
 					Report.Error (146, Location,
 						"Circular base class dependency involving `{0}' and `{1}'",
 						GetSignatureForError (), cycle.GetSignatureForError ());
 
 					base_type = null;
 				}
 			}
 
 			if (iface_exprs != null) {
 				foreach (TypeExpr iface in iface_exprs) {
 					// Prevents a crash, the interface might not have been resolved
 					if (iface == null)
 						continue;
 					
 					var iface_type = iface.Type;
 
 					if (!spec.AddInterface (iface_type))
 						continue;
 
 					if (iface_type.IsGeneric && spec.Interfaces != null) {
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 					}
 
 					TypeBuilder.AddInterfaceImplementation (iface_type.GetMetaInfo ());
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null) {
 						// TODO
 						compiled_iface.DefineType ();
 					}
 
 					if (iface_type.Interfaces != null) {
 						var base_ifaces = new List<TypeSpec> (iface_type.Interfaces);
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 					}
 				}
 				foreach (TypeExpr iface in iface_exprs) {
 					// Prevents a crash, the interface might not have been resolved
 					if (iface == null)
 						continue;
 					
 					var iface_type = iface.Type;
 
 					if (!spec.AddInterface (iface_type))
 						continue;
 
 					if (iface_type.IsGeneric && spec.Interfaces != null) {
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 					}
 
 					TypeBuilder.AddInterfaceImplementation (iface_type.GetMetaInfo ());
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null) {
 						// TODO
 						compiled_iface.DefineType ();
 					}
 
 					if (iface_type.Interfaces != null) {
 						var base_ifaces = new List<TypeSpec> (iface_type.Interfaces);
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 					}
 				}
 			}
 
 			if (Kind == MemberKind.Interface) {
 				spec.BaseType = TypeManager.object_type;
 				return true;
 			}
 
 			if (base_type != null) {
 				spec.BaseType = base_type;
 
 				// Set base type after type creation
 				TypeBuilder.SetParent (base_type.GetMetaInfo ());
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="343" endline="445">
<![CDATA[
 
 		bool ParseArguments (string[] args, bool require_files, Func<string [], int, int> unknown_option_parser)
 		{
 			List<string> response_file_list = null;
 			bool parsing_options = true;
 
 			for (int i = 0; i < args.Length; i++) {
 				string arg = args [i];
 				if (arg.Length == 0)
 					continue;
 
 				if (arg [0] == '@') {
 					string [] extra_args;
 					string response_file = arg.Substring (1);
 
 					if (response_file_list == null)
 						response_file_list = new List<string> ();
 
 					if (response_file_list.Contains (response_file)) {
 						Report.Error (
 							1515, "Response file `" + response_file +
 							"' specified multiple times");
 						return false;
 					}
 
 					response_file_list.Add (response_file);
 
 					extra_args = LoadArgs (response_file);
 					if (extra_args == null) {
 						Report.Error (2011, "Unable to open response file
 								  response_file);
 						return false;
 					}
 
 					args = AddArgs (args, extra_args);
 					continue;
 				}
 
 				if (parsing_options) {
 					if (arg == "--") {
 						parsing_options = false;
 						continue;
 					}
 
 					if (arg [0] == '-') {
 						if (UnixParseOption (arg, ref args, ref i))
 							continue;
 
 						// Try a -CSCOPTION
 						string csc_opt = "/" + arg.Substring (1);
 						if (CSCParseOption (csc_opt, ref args))
 							continue;
 
 						if (unknown_option_parser != null){
 							var ret = unknown_option_parser (args, i);
 							if (ret != -1){
 								i = ret;
 								return true;
 							}
 						}
 						
 						Error_WrongOption (arg);
 						return false;
 					}
 					if (arg [0] == '/') {
 						if (CSCParseOption (arg, ref args))
 							continue;
 
 						// Need to skip `/home/test.cs' however /test.cs is considered as error
 						if (arg.Length < 2 || arg.IndexOf ('/', 2) == -1) {
 							Error_WrongOption (arg);
 							return false;
 						}
 					}
 				}
 
 				ProcessSourceFiles (arg, false);
 			}
 			for (int i = 0; i < args.Length; i++) {
 				string arg = args [i];
 				if (arg.Length == 0)
 					continue;
 
 				if (arg [0] == '@') {
 					string [] extra_args;
 					string response_file = arg.Substring (1);
 
 					if (response_file_list == null)
 						response_file_list = new List<string> ();
 
 					if (response_file_list.Contains (response_file)) {
 						Report.Error (
 							1515, "Response file `" + response_file +
 							"' specified multiple times");
 						return false;
 					}
 
 					response_file_list.Add (response_file);
 
 					extra_args = LoadArgs (response_file);
 					if (extra_args == null) {
 						Report.Error (2011, "Unable to open response file
 								  response_file);
 						return false;
 					}
 
 					args = AddArgs (args, extra_args);
 					continue;
 				}
 
 				if (parsing_options) {
 					if (arg == "--") {
 						parsing_options = false;
 						continue;
 					}
 
 					if (arg [0] == '-') {
 						if (UnixParseOption (arg, ref args, ref i))
 							continue;
 
 						// Try a -CSCOPTION
 						string csc_opt = "/" + arg.Substring (1);
 						if (CSCParseOption (csc_opt, ref args))
 							continue;
 
 						if (unknown_option_parser != null){
 							var ret = unknown_option_parser (args, i);
 							if (ret != -1){
 								i = ret;
 								return true;
 							}
 						}
 						
 						Error_WrongOption (arg);
 						return false;
 					}
 					if (arg [0] == '/') {
 						if (CSCParseOption (arg, ref args))
 							continue;
 
 						// Need to skip `/home/test.cs' however /test.cs is considered as error
 						if (arg.Length < 2 || arg.IndexOf ('/', 2) == -1) {
 							Error_WrongOption (arg);
 							return false;
 						}
 					}
 				}
 
 				ProcessSourceFiles (arg, false);
 			}
 
 			if (require_files == false)
 				return true;
 					
 			//
 			// If we are an exe, require a source file for the entry point
 			//
 			if (RootContext.Target == Target.Exe || RootContext.Target == Target.WinExe || RootContext.Target == Target.Module) {
 				if (first_source == null) {
 					Report.Error (2008, "No files to compile were specified");
 					return false;
 				}
 
 			}
 
 			//
 			// If there is nothing to put in the assembly, and we are not a library
 			//
 			if (first_source == null && RootContext.Resources == null) {
 				Report.Error (2008, "No files to compile were specified");
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1781" endline="1971">
<![CDATA[
 
 		protected override bool DoDefineMembers ()
 		{
 			if (!base.DoDefineMembers ())
 				return false;
 
 			Location loc = Location;
 
 			var equals_parameters = ParametersCompiled.CreateFullyResolved (
 				new Parameter (new TypeExpression (TypeManager.object_type, loc), "obj", 0, null, loc),	TypeManager.object_type);
 
 			Method equals = new Method (this, null, new TypeExpression (TypeManager.bool_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN, new MemberName ("Equals", loc),
 				equals_parameters, null);
 
 			equals_parameters[0].Resolve (equals, 0);
 
 			Method tostring = new Method (this, null, new TypeExpression (TypeManager.string_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN, new MemberName ("ToString", loc),
 				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			ToplevelBlock equals_block = new ToplevelBlock (Compiler, equals.ParameterInfo, loc);
 
 			TypeExpr current_type;
 			if (type_params != null) {
 				var targs = new TypeArguments ();
 				foreach (var type_param in type_params)
 					targs.Add (new TypeParameterExpr (type_param, type_param.Location));
 				foreach (var type_param in type_params)
 					targs.Add (new TypeParameterExpr (type_param, type_param.Location));
 
 				current_type = new GenericTypeExpr (Definition, targs, loc);
 			} else {
 				current_type = new TypeExpression (Definition, loc);
 			}
 
 			var li_other = LocalVariable.CreateCompilerGenerated (CurrentType, equals_block, loc);
 			equals_block.AddStatement (new BlockVariableDeclaration (new TypeExpression (li_other.Type, loc), li_other));
 			var other_variable = new LocalVariableReference (li_other, loc);
 
 			MemberAccess system_collections_generic = new MemberAccess (new MemberAccess (
 				new QualifiedAliasMember ("global", "System", loc), "Collections", loc), "Generic", loc);
 
 			Expression rs_equals = null;
 			Expression string_concat = new StringConstant ("{", loc);
 			Expression rs_hashcode = new IntConstant (-2128831035, loc);
 			for (int i = 0; i < parameters.Count; ++i) {
 				var p = parameters [i];
 				var f = Fields [i];
 
 				MemberAccess equality_comparer = new MemberAccess (new MemberAccess (
 					system_collections_generic, "EqualityComparer",
 						new TypeArguments (new SimpleName (CurrentTypeParameters [i].Name, loc)), loc),
 						"Default", loc);
 
 				Arguments arguments_equal = new Arguments (2);
 				arguments_equal.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				arguments_equal.Add (new Argument (new MemberAccess (other_variable, f.Name)));
 
 				Expression field_equal = new Invocation (new MemberAccess (equality_comparer,
 					"Equals", loc), arguments_equal);
 
 				Arguments arguments_hashcode = new Arguments (1);
 				arguments_hashcode.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				Expression field_hashcode = new Invocation (new MemberAccess (equality_comparer,
 					"GetHashCode", loc), arguments_hashcode);
 
 				IntConstant FNV_prime = new IntConstant (16777619, loc);				
 				rs_hashcode = new Binary (Binary.Operator.Multiply,
 					new Binary (Binary.Operator.ExclusiveOr, rs_hashcode, field_hashcode, loc),
 					FNV_prime, loc);
 
 				Expression field_to_string = new Conditional (new BooleanExpression (new Binary (Binary.Operator.Inequality,
 					new MemberAccess (new This (f.Location), f.Name), new NullLiteral (loc), loc)),
 					new Invocation (new MemberAccess (
 						new MemberAccess (new This (f.Location), f.Name), "ToString"), null),
 					new StringConstant (string.Empty, loc), loc);
 
 				if (rs_equals == null) {
 					rs_equals = field_equal;
 					string_concat = new Binary (Binary.Operator.Addition,
 						string_concat,
 						new Binary (Binary.Operator.Addition,
 							new StringConstant (" " + p.Name + " = ", loc),
 							field_to_string,
 							loc),
 						loc);
 					continue;
 				}
 
 				//
 				// Implementation of ToString () body using string concatenation
 				//				
 				string_concat = new Binary (Binary.Operator.Addition,
 					new Binary (Binary.Operator.Addition,
 						string_concat,
 						new StringConstant (", " + p.Name + " = ", loc),
 						loc),
 					field_to_string,
 					loc);
 
 				rs_equals = new Binary (Binary.Operator.LogicalAnd, rs_equals, field_equal, loc);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				var p = parameters [i];
 				var f = Fields [i];
 
 				MemberAccess equality_comparer = new MemberAccess (new MemberAccess (
 					system_collections_generic, "EqualityComparer",
 						new TypeArguments (new SimpleName (CurrentTypeParameters [i].Name, loc)), loc),
 						"Default", loc);
 
 				Arguments arguments_equal = new Arguments (2);
 				arguments_equal.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				arguments_equal.Add (new Argument (new MemberAccess (other_variable, f.Name)));
 
 				Expression field_equal = new Invocation (new MemberAccess (equality_comparer,
 					"Equals", loc), arguments_equal);
 
 				Arguments arguments_hashcode = new Arguments (1);
 				arguments_hashcode.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				Expression field_hashcode = new Invocation (new MemberAccess (equality_comparer,
 					"GetHashCode", loc), arguments_hashcode);
 
 				IntConstant FNV_prime = new IntConstant (16777619, loc);				
 				rs_hashcode = new Binary (Binary.Operator.Multiply,
 					new Binary (Binary.Operator.ExclusiveOr, rs_hashcode, field_hashcode, loc),
 					FNV_prime, loc);
 
 				Expression field_to_string = new Conditional (new BooleanExpression (new Binary (Binary.Operator.Inequality,
 					new MemberAccess (new This (f.Location), f.Name), new NullLiteral (loc), loc)),
 					new Invocation (new MemberAccess (
 						new MemberAccess (new This (f.Location), f.Name), "ToString"), null),
 					new StringConstant (string.Empty, loc), loc);
 
 				if (rs_equals == null) {
 					rs_equals = field_equal;
 					string_concat = new Binary (Binary.Operator.Addition,
 						string_concat,
 						new Binary (Binary.Operator.Addition,
 							new StringConstant (" " + p.Name + " = ", loc),
 							field_to_string,
 							loc),
 						loc);
 					continue;
 				}
 
 				//
 				// Implementation of ToString () body using string concatenation
 				//				
 				string_concat = new Binary (Binary.Operator.Addition,
 					new Binary (Binary.Operator.Addition,
 						string_concat,
 						new StringConstant (", " + p.Name + " = ", loc),
 						loc),
 					field_to_string,
 					loc);
 
 				rs_equals = new Binary (Binary.Operator.LogicalAnd, rs_equals, field_equal, loc);
 			}
 
 			string_concat = new Binary (Binary.Operator.Addition,
 				string_concat,
 				new StringConstant (" }", loc),
 				loc);
 
 			//
 			// Equals (object obj) override
 			//		
 			var other_variable_assign = new TemporaryVariableReference (li_other, loc);
 			equals_block.AddStatement (new StatementExpression (
 				new SimpleAssign (other_variable_assign,
 					new As (equals_block.GetParameterReference (0, loc),
 						current_type, loc), loc)));
 
 			Expression equals_test = new Binary (Binary.Operator.Inequality, other_variable, new NullLiteral (loc), loc);
 			if (rs_equals != null)
 				equals_test = new Binary (Binary.Operator.LogicalAnd, equals_test, rs_equals, loc);
 			equals_block.AddStatement (new Return (equals_test, loc));
 
 			equals.Block = equals_block;
 			equals.Define ();
 			AddMethod (equals);
 
 			//
 			// GetHashCode () override
 			//
 			Method hashcode = new Method (this, null, new TypeExpression (TypeManager.int32_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN,
 				new MemberName ("GetHashCode", loc),
 				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			//
 			// Modified FNV with good avalanche behavior and uniform
 			// distribution with larger hash sizes.
 			//
 			// const int FNV_prime = 16777619;
 			// int hash = (int) 2166136261;
 			// foreach (int d in data)
 			//     hash = (hash ^ d) * FNV_prime;
 			// hash += hash << 13;
 			// hash ^= hash >> 7;
 			// hash += hash << 3;
 			// hash ^= hash >> 17;
 			// hash += hash << 5;
 
 			ToplevelBlock hashcode_top = new ToplevelBlock (Compiler, loc);
 			Block hashcode_block = new Block (hashcode_top, loc, loc);
 			hashcode_top.AddStatement (new Unchecked (hashcode_block, loc));
 
 			var li_hash = LocalVariable.CreateCompilerGenerated (TypeManager.int32_type, hashcode_top, loc);
 			hashcode_block.AddStatement (new BlockVariableDeclaration (new TypeExpression (li_hash.Type, loc), li_hash));
 			LocalVariableReference hash_variable_assign = new LocalVariableReference (li_hash, loc);
 			hashcode_block.AddStatement (new StatementExpression (
 				new SimpleAssign (hash_variable_assign, rs_hashcode)));
 
 			var hash_variable = new LocalVariableReference (li_hash, loc);
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (13, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.ExclusiveOr, hash_variable,
 					new Binary (Binary.Operator.RightShift, hash_variable, new IntConstant (7, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (3, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.ExclusiveOr, hash_variable,
 					new Binary (Binary.Operator.RightShift, hash_variable, new IntConstant (17, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (5, loc), loc), loc)));
 
 			hashcode_block.AddStatement (new Return (hash_variable, loc));
 			hashcode.Block = hashcode_top;
 			hashcode.Define ();
 			AddMethod (hashcode);
 
 			//
 			// ToString () override
 			//
 
 			ToplevelBlock tostring_block = new ToplevelBlock (Compiler, loc);
 			tostring_block.AddStatement (new Return (string_concat, loc));
 			tostring.Block = tostring_block;
 			tostring.Define ();
 			AddMethod (tostring);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="254" endline="599">
<![CDATA[
 		static readonly char[] simple_whitespaces = new char[] { ' ', '\t' };
 
 		public bool PropertyParsing {
 			get { return handle_get_set; }
 			set { handle_get_set = value; }
 		}
 
 		public bool EventParsing {
 			get { return handle_remove_add; }
 			set { handle_remove_add = value; }
 		}
 
 		public bool ConstraintsParsing {
 			get { return handle_where; }
 			set { handle_where = value; }
 		}
 
 		public bool TypeOfParsing {
 			get { return handle_typeof; }
 			set { handle_typeof = value; }
 		}
 
 		public int TabSize {
 			get { return tab_size; }
 			set { tab_size = value; }
 		}
 		
 		public XmlCommentState doc_state {
 			get { return xml_doc_state; }
 			set {
 				if (value == XmlCommentState.Allowed) {
 					check_incorrect_doc_comment ();
 					reset_doc_comment ();
 				}
 				xml_doc_state = value;
 			}
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
 
 		public bool IsEscapedIdentifier (MemberName name)
 		{
 			return escaped_identifiers != null && escaped_identifiers.Contains (name.Location);
 		}
 
 		//
 		// Class variables
 		// 
 		static KeywordEntry<int>[][] keywords;
 		static KeywordEntry<PreprocessorDirective>[][] keywords_preprocessor;
 		static Dictionary<string, object> keyword_strings; 		// TODO
 		static NumberStyles styles;
 		static NumberFormatInfo csharp_format_info;
 
 		// Pragma arguments
 		static readonly char[] pragma_warning = "warning".ToCharArray ();
 		static readonly char[] pragma_warning_disable = "disable".ToCharArray ();
 		static readonly char[] pragma_warning_restore = "restore".ToCharArray ();
 		static readonly char[] pragma_checksum = "checksum".ToCharArray ();
 		
 		//
 		// Values for the associated token returned
 		//
 		internal int putback_char; 	// Used by repl only
 		object val;
 
 		//
 		// Pre-processor
 		//
 		const int TAKING        = 1;
 		const int ELSE_SEEN     = 4;
 		const int PARENT_TAKING = 8;
 		const int REGION        = 16;		
 
 		//
 		// pre-processor if stack state
 		//
 		Stack<int> ifstack;
 
 		static System.Text.StringBuilder string_builder;
 
 		const int max_id_size = 512;
 		static char [] id_builder = new char [max_id_size];
 
 		public static Dictionary<char[], string>[] identifiers = new Dictionary<char[], string>[max_id_size + 1];
 
 		const int max_number_size = 512;
 		static char [] number_builder = new char [max_number_size];
 		static int number_pos;
 
 		static StringBuilder static_cmd_arg = new System.Text.StringBuilder ();
 		
 		public int Line {
 			get {
 				return ref_line;
 			}
 		}
 
 		//
 		// This is used when the tokenizer needs to save
 		// the current position as it needs to do some parsing
 		// on its own to deamiguate a token in behalf of the
 		// parser.
 		//
 		Stack<Position> position_stack = new Stack<Position> (2);
 
 		class Position {
 			public int position;
 			public int line;
 			public int ref_line;
 			public int col;
 			public bool hidden;
 			public int putback_char;
 			public int previous_col;
 			public Stack<int> ifstack;
 			public int parsing_generic_less_than;
 			public int current_token;
 			public object val;
 
 			public Position (Tokenizer t)
 			{
 				position = t.reader.Position;
 				line = t.line;
 				ref_line = t.ref_line;
 				col = t.col;
 				hidden = t.hidden;
 				putback_char = t.putback_char;
 				previous_col = t.previous_col;
 				if (t.ifstack != null && t.ifstack.Count != 0) {
 					// There is no simple way to clone Stack<T> all
 					// methods reverse the order
 					var clone = t.ifstack.ToArray ();
 					Array.Reverse (clone);
 					ifstack = new Stack<int> (clone);
 				}
 				parsing_generic_less_than = t.parsing_generic_less_than;
 				current_token = t.current_token;
 				val = t.val;
 			}
 		}
 		
 		public void PushPosition ()
 		{
 			position_stack.Push (new Position (this));
 		}
 
 		public void PopPosition ()
 		{
 			Position p = position_stack.Pop ();
 
 			reader.Position = p.position;
 			ref_line = p.ref_line;
 			line = p.line;
 			col = p.col;
 			hidden = p.hidden;
 			putback_char = p.putback_char;
 			previous_col = p.previous_col;
 			ifstack = p.ifstack;
 			parsing_generic_less_than = p.parsing_generic_less_than;
 			current_token = p.current_token;
 			val = p.val;
 		}
 
 		// Do not reset the position, ignore it.
 		public void DiscardPosition ()
 		{
 			position_stack.Pop ();
 		}
 		
 		static void AddKeyword (string kw, int token)
 		{
 			keyword_strings.Add (kw, null);
 
 			AddKeyword (keywords, kw, token);
 		}
 
 		static void AddPreprocessorKeyword (string kw, PreprocessorDirective directive)
 		{
 			AddKeyword (keywords_preprocessor, kw, directive);
 		}
 
 		static void AddKeyword<T> (KeywordEntry<T>[][] keywords, string kw, T token)
 		{
 			int length = kw.Length;
 			if (keywords[length] == null) {
 				keywords[length] = new KeywordEntry<T>['z' - '_' + 1];
 			}
 
 			int char_index = kw[0] - '_';
 			var kwe = keywords[length][char_index];
 			if (kwe == null) {
 				keywords[length][char_index] = new KeywordEntry<T> (kw, token);
 				return;
 			}
 
 			while (kwe.Next != null) {
 				kwe = kwe.Next;
 			}
 
 			kwe.Next = new KeywordEntry<T> (kw, token);
 		}
 
 		static void InitTokens ()
 		{
 			keyword_strings = new Dictionary<string, object> ();
 
 			// 11 is the length of the longest keyword for now
 			keywords = new KeywordEntry<int> [11] [];
 
 			AddKeyword ("__arglist", Token.ARGLIST);
 			AddKeyword ("abstract", Token.ABSTRACT);
 			AddKeyword ("as", Token.AS);
 			AddKeyword ("add", Token.ADD);
 			AddKeyword ("base", Token.BASE);
 			AddKeyword ("bool", Token.BOOL);
 			AddKeyword ("break", Token.BREAK);
 			AddKeyword ("byte", Token.BYTE);
 			AddKeyword ("case", Token.CASE);
 			AddKeyword ("catch", Token.CATCH);
 			AddKeyword ("char", Token.CHAR);
 			AddKeyword ("checked", Token.CHECKED);
 			AddKeyword ("class", Token.CLASS);
 			AddKeyword ("const", Token.CONST);
 			AddKeyword ("continue", Token.CONTINUE);
 			AddKeyword ("decimal", Token.DECIMAL);
 			AddKeyword ("default", Token.DEFAULT);
 			AddKeyword ("delegate", Token.DELEGATE);
 			AddKeyword ("do", Token.DO);
 			AddKeyword ("double", Token.DOUBLE);
 			AddKeyword ("else", Token.ELSE);
 			AddKeyword ("enum", Token.ENUM);
 			AddKeyword ("event", Token.EVENT);
 			AddKeyword ("explicit", Token.EXPLICIT);
 			AddKeyword ("extern", Token.EXTERN);
 			AddKeyword ("false", Token.FALSE);
 			AddKeyword ("finally", Token.FINALLY);
 			AddKeyword ("fixed", Token.FIXED);
 			AddKeyword ("float", Token.FLOAT);
 			AddKeyword ("for", Token.FOR);
 			AddKeyword ("foreach", Token.FOREACH);
 			AddKeyword ("goto", Token.GOTO);
 			AddKeyword ("get", Token.GET);
 			AddKeyword ("if", Token.IF);
 			AddKeyword ("implicit", Token.IMPLICIT);
 			AddKeyword ("in", Token.IN);
 			AddKeyword ("int", Token.INT);
 			AddKeyword ("interface", Token.INTERFACE);
 			AddKeyword ("internal", Token.INTERNAL);
 			AddKeyword ("is", Token.IS);
 			AddKeyword ("lock", Token.LOCK);
 			AddKeyword ("long", Token.LONG);
 			AddKeyword ("namespace", Token.NAMESPACE);
 			AddKeyword ("new", Token.NEW);
 			AddKeyword ("null", Token.NULL);
 			AddKeyword ("object", Token.OBJECT);
 			AddKeyword ("operator", Token.OPERATOR);
 			AddKeyword ("out", Token.OUT);
 			AddKeyword ("override", Token.OVERRIDE);
 			AddKeyword ("params", Token.PARAMS);
 			AddKeyword ("private", Token.PRIVATE);
 			AddKeyword ("protected", Token.PROTECTED);
 			AddKeyword ("public", Token.PUBLIC);
 			AddKeyword ("readonly", Token.READONLY);
 			AddKeyword ("ref", Token.REF);
 			AddKeyword ("remove", Token.REMOVE);
 			AddKeyword ("return", Token.RETURN);
 			AddKeyword ("sbyte", Token.SBYTE);
 			AddKeyword ("sealed", Token.SEALED);
 			AddKeyword ("set", Token.SET);
 			AddKeyword ("short", Token.SHORT);
 			AddKeyword ("sizeof", Token.SIZEOF);
 			AddKeyword ("stackalloc", Token.STACKALLOC);
 			AddKeyword ("static", Token.STATIC);
 			AddKeyword ("string", Token.STRING);
 			AddKeyword ("struct", Token.STRUCT);
 			AddKeyword ("switch", Token.SWITCH);
 			AddKeyword ("this", Token.THIS);
 			AddKeyword ("throw", Token.THROW);
 			AddKeyword ("true", Token.TRUE);
 			AddKeyword ("try", Token.TRY);
 			AddKeyword ("typeof", Token.TYPEOF);
 			AddKeyword ("uint", Token.UINT);
 			AddKeyword ("ulong", Token.ULONG);
 			AddKeyword ("unchecked", Token.UNCHECKED);
 			AddKeyword ("unsafe", Token.UNSAFE);
 			AddKeyword ("ushort", Token.USHORT);
 			AddKeyword ("using", Token.USING);
 			AddKeyword ("virtual", Token.VIRTUAL);
 			AddKeyword ("void", Token.VOID);
 			AddKeyword ("volatile", Token.VOLATILE);
 			AddKeyword ("while", Token.WHILE);
 			AddKeyword ("partial", Token.PARTIAL);
 			AddKeyword ("where", Token.WHERE);
 			AddKeyword ("async", Token.ASYNC);
 
 			// LINQ keywords
 			AddKeyword ("from", Token.FROM);
 			AddKeyword ("join", Token.JOIN);
 			AddKeyword ("on", Token.ON);
 			AddKeyword ("equals", Token.EQUALS);
 			AddKeyword ("select", Token.SELECT);
 			AddKeyword ("group", Token.GROUP);
 			AddKeyword ("by", Token.BY);
 			AddKeyword ("let", Token.LET);
 			AddKeyword ("orderby", Token.ORDERBY);
 			AddKeyword ("ascending", Token.ASCENDING);
 			AddKeyword ("descending", Token.DESCENDING);
 			AddKeyword ("into", Token.INTO);
 
 			keywords_preprocessor = new KeywordEntry<PreprocessorDirective>[10][];
 
 			AddPreprocessorKeyword ("region", PreprocessorDirective.Region);
 			AddPreprocessorKeyword ("endregion", PreprocessorDirective.Endregion);
 			AddPreprocessorKeyword ("if", PreprocessorDirective.If);
 			AddPreprocessorKeyword ("endif", PreprocessorDirective.Endif);
 			AddPreprocessorKeyword ("elif", PreprocessorDirective.Elif);
 			AddPreprocessorKeyword ("else", PreprocessorDirective.Else);
 			AddPreprocessorKeyword ("define", PreprocessorDirective.Define);
 			AddPreprocessorKeyword ("undef", PreprocessorDirective.Undef);
 			AddPreprocessorKeyword ("error", PreprocessorDirective.Error);
 			AddPreprocessorKeyword ("warning", PreprocessorDirective.Warning);
 			AddPreprocessorKeyword ("pragma", PreprocessorDirective.Pragma);
 			AddPreprocessorKeyword ("line", PreprocessorDirective.Line);
 		}
 
 		//
 		// Class initializer
 		// 
 		static Tokenizer ()
 		{
 			InitTokens ();			
 			csharp_format_info = NumberFormatInfo.InvariantInfo;
 			styles = NumberStyles.Float;
 
 			string_builder = new System.Text.StringBuilder ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2291" endline="2435">
<![CDATA[
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			int lookup_arity = Arity;
 			bool errorMode = false;
 			Expression e;
 			Block current_block = rc.CurrentBlock;
 			INamedBlockVariable variable = null;
 			bool variable_found = false;
 
 			while (true) {
 				//
 				// Stage 1
 				//
 				// LAMESPEC
 				//
 				if (current_block != null && lookup_arity == 0) {
 					if (current_block.ParametersBlock.TopBlock.GetLocalName (Name, current_block.Original, ref variable)) {
 						if (!variable.IsDeclared) {
 							// We found local name in accessible block but it's not
 							// initialized yet, maybe the user wanted to bind to something else
 							errorMode = true;
 							variable_found = true;
 						} else {
 							e = variable.CreateReferenceExpression (rc, loc);
 							if (e != null) {
 								if (Arity > 0)
 									Error_TypeArgumentsCannotBeUsed (rc.Report, "variable", Name, loc);
 
 								return e;
 							}
 						}
 					}
 				}
 
 				//
 				// Stage 2
 				//
 				TypeSpec member_type = rc.CurrentType;
 				TypeSpec current_type = member_type;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				}
 
 				//
 				// Stage 3
 				//
 				if ((restrictions & MemberLookupRestrictions.InvocableOnly) == 0 && !variable_found) {
 					e = ResolveAsTypeStep (rc, lookup_arity == 0 || !errorMode);
 					if (e != null) {
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						return e;
 					}
 				}
 
 				if (errorMode) {
 					if (variable_found) {
 						rc.Report.Error (841, loc, "A local variable `{0}' cannot be used before it is declared", Name);
 					} else {
 						rc.Report.Error (103, loc, "The name `{0}' does not exist in the current context", Name);
 					}
 
 					return null;
 				}
 
 				if (RootContext.EvalMode) {
 					var fi = Evaluator.LookupField (Name);
 					if (fi != null)
 						return new FieldExpr (fi.Item1, loc);
 				}
 
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 			while (true) {
 				//
 				// Stage 1
 				//
 				// LAMESPEC
 				//
 				if (current_block != null && lookup_arity == 0) {
 					if (current_block.ParametersBlock.TopBlock.GetLocalName (Name, current_block.Original, ref variable)) {
 						if (!variable.IsDeclared) {
 							// We found local name in accessible block but it's not
 							// initialized yet, maybe the user wanted to bind to something else
 							errorMode = true;
 							variable_found = true;
 						} else {
 							e = variable.CreateReferenceExpression (rc, loc);
 							if (e != null) {
 								if (Arity > 0)
 									Error_TypeArgumentsCannotBeUsed (rc.Report, "variable", Name, loc);
 
 								return e;
 							}
 						}
 					}
 				}
 
 				//
 				// Stage 2
 				//
 				TypeSpec member_type = rc.CurrentType;
 				TypeSpec current_type = member_type;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				}
 
 				//
 				// Stage 3
 				//
 				if ((restrictions & MemberLookupRestrictions.InvocableOnly) == 0 && !variable_found) {
 					e = ResolveAsTypeStep (rc, lookup_arity == 0 || !errorMode);
 					if (e != null) {
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						return e;
 					}
 				}
 
 				if (errorMode) {
 					if (variable_found) {
 						rc.Report.Error (841, loc, "A local variable `{0}' cannot be used before it is declared", Name);
 					} else {
 						rc.Report.Error (103, loc, "The name `{0}' does not exist in the current context", Name);
 					}
 
 					return null;
 				}
 
 				if (RootContext.EvalMode) {
 					var fi = Evaluator.LookupField (Name);
 					if (fi != null)
 						return new FieldExpr (fi.Item1, loc);
 				}
 
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="151" endline="176">
<![CDATA[
 	}
 #endif
 
 	public class MonoSymbolFile 
 	{
 		List<MethodEntry> methods = new List<MethodEntry> ();
 		List<SourceFileEntry> sources = new List<SourceFileEntry> ();
 		List<CompileUnitEntry> comp_units = new List<CompileUnitEntry> ();
 		Dictionary<Type, int> type_hash = new Dictionary<Type, int> ();
 		Dictionary<int, AnonymousScopeEntry> anonymous_scopes;
 
 		OffsetTable ot;
 		int last_type_index;
 		int last_method_index;
 		int last_namespace_index;
 
 		public readonly string FileName = "<dynamic>";
 		public readonly int MajorVersion = OffsetTable.MajorVersion;
 		public readonly int MinorVersion = OffsetTable.MinorVersion;
 
 		public int NumLineNumbers;
 
 		internal MonoSymbolFile ()
 		{
 			ot = new OffsetTable ();
 		}
 
 		internal int AddSource (SourceFileEntry source)
 		{
 			sources.Add (source);
 			return sources.Count;
 		}
 
 		internal int AddCompileUnit (CompileUnitEntry entry)
 		{
 			comp_units.Add (entry);
 			return comp_units.Count;
 		}
 
 		internal int DefineType (Type type)
 		{
 			int index;
 			if (type_hash.TryGetValue (type, out index))
 				return index;
 
 			index = ++last_type_index;
 			type_hash.Add (type, index);
 			return index;
 		}
 
 		internal void AddMethod (MethodEntry entry)
 		{
 			methods.Add (entry);
 		}
 
 		public MethodEntry DefineMethod (CompileUnitEntry comp_unit, int token,
 						 ScopeVariable[] scope_vars, LocalVariableEntry[] locals,
 						 LineNumberEntry[] lines, CodeBlockEntry[] code_blocks,
 						 string real_name, MethodEntry.Flags flags,
 						 int namespace_id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			MethodEntry method = new MethodEntry (
 				this, comp_unit, token, scope_vars, locals, lines, code_blocks, 
 				real_name, flags, namespace_id);
 			AddMethod (method);
 			return method;
 		}
 
 		internal void DefineAnonymousScope (int id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			if (anonymous_scopes == null)
 				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>  ();
 
 			anonymous_scopes.Add (id, new AnonymousScopeEntry (id));
 		}
 
 		internal void DefineCapturedVariable (int scope_id, string name, string captured_name,
 						      CapturedVariable.CapturedKind kind)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedVariable (name, captured_name, kind);
 		}
 
 		internal void DefineCapturedScope (int scope_id, int id, string captured_name)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedScope (id, captured_name);
 		}
 
 		internal int GetNextTypeIndex ()
 		{
 			return ++last_type_index;
 		}
 
 		internal int GetNextMethodIndex ()
 		{
 			return ++last_method_index;
 		}
 
 		internal int GetNextNamespaceIndex ()
 		{
 			return ++last_namespace_index;
 		}
 		
 		void Write (MyBinaryWriter bw, Guid guid)
 		{
 			// Magic number and file version.
 			bw.Write (OffsetTable.Magic);
 			bw.Write (MajorVersion);
 			bw.Write (MinorVersion);
 
 			bw.Write (guid.ToByteArray ());
 
 			//
 			// Offsets of file sections; we must write this after we're done
 			// writing the whole file, so we just reserve the space for it here.
 			//
 			long offset_table_offset = bw.BaseStream.Position;
 			ot.Write (bw, MajorVersion, MinorVersion);
 
 			//
 			// Sort the methods according to their tokens and update their index.
 			//
 			methods.Sort ();
 			for (int i = 0; i < methods.Count; i++)
 				((MethodEntry) methods [i]).Index = i + 1;
 
 			//
 			// Write data sections.
 			//
 			ot.DataSectionOffset = (int) bw.BaseStream.Position;
 			foreach (SourceFileEntry source in sources)
 				source.WriteData (bw);
 			foreach (CompileUnitEntry comp_unit in comp_units)
 				comp_unit.WriteData (bw);
 			foreach (MethodEntry method in methods)
 				method.WriteData (this, bw);
 			ot.DataSectionSize = (int) bw.BaseStream.Position - ot.DataSectionOffset;
 
 			//
 			// Write the method index table.
 			//
 			ot.MethodTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < methods.Count; i++) {
 				MethodEntry entry = (MethodEntry) methods [i];
 				entry.Write (bw);
 			}
 			ot.MethodTableSize = (int) bw.BaseStream.Position - ot.MethodTableOffset;
 
 			//
 			// Write source table.
 			//
 			ot.SourceTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < sources.Count; i++) {
 				SourceFileEntry source = (SourceFileEntry) sources [i];
 				source.Write (bw);
 			}
 			ot.SourceTableSize = (int) bw.BaseStream.Position - ot.SourceTableOffset;
 
 			//
 			// Write compilation unit table.
 			//
 			ot.CompileUnitTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < comp_units.Count; i++) {
 				CompileUnitEntry unit = (CompileUnitEntry) comp_units [i];
 				unit.Write (bw);
 			}
 			ot.CompileUnitTableSize = (int) bw.BaseStream.Position - ot.CompileUnitTableOffset;
 
 			//
 			// Write anonymous scope table.
 			//
 			ot.AnonymousScopeCount = anonymous_scopes != null ? anonymous_scopes.Count 
 			ot.AnonymousScopeTableOffset = (int) bw.BaseStream.Position;
 			if (anonymous_scopes != null) {
 				foreach (AnonymousScopeEntry scope in anonymous_scopes.Values)
 					scope.Write (bw);
 			}
 			ot.AnonymousScopeTableSize = (int) bw.BaseStream.Position - ot.AnonymousScopeTableOffset;
 
 			//
 			// Fixup offset table.
 			//
 			ot.TypeCount = last_type_index;
 			ot.MethodCount = methods.Count;
 			ot.SourceCount = sources.Count;
 			ot.CompileUnitCount = comp_units.Count;
 
 			//
 			// Write offset table.
 			//
 			ot.TotalFileSize = (int) bw.BaseStream.Position;
 			bw.Seek ((int) offset_table_offset, SeekOrigin.Begin);
 			ot.Write (bw, MajorVersion, MinorVersion);
 			bw.Seek (0, SeekOrigin.End);
 
 #if false
 			Console.WriteLine ("TOTAL
 					   "{3} methods.", NumLineNumbers, LineNumberSize,
 					   ExtendedLineNumberSize, methods.Count);
 #endif
 		}
 
 		public void CreateSymbolFile (Guid guid, FileStream fs)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			Write (new MyBinaryWriter (fs), guid);
 		}
 
 		MyBinaryReader reader;
 		Dictionary<int, SourceFileEntry> source_file_hash;
 		Dictionary<int, CompileUnitEntry> compile_unit_hash;
 
 		List<MethodEntry> method_list;
 		Dictionary<int, MethodEntry> method_token_hash;
 		Dictionary<string, int> source_name_hash;
 
 		Guid guid;
 
 		MonoSymbolFile (string filename)
 		{
 			this.FileName = filename;
 			FileStream stream = new FileStream (filename, FileMode.Open, FileAccess.Read);
 			reader = new MyBinaryReader (stream);
 
 			try {
 				long magic = reader.ReadInt64 ();
 				int major_version = reader.ReadInt32 ();
 				int minor_version = reader.ReadInt32 ();
 
 				if (magic != OffsetTable.Magic)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' is not a valid " +
 						"Mono symbol file", filename);
 				if (major_version != OffsetTable.MajorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}, " +
 						"but expected {2}", filename, major_version,
 						OffsetTable.MajorVersion);
 				if (minor_version != OffsetTable.MinorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}.{2}, " +
 						"but expected {3}.{4}", filename, major_version,
 						minor_version, OffsetTable.MajorVersion,
 						OffsetTable.MinorVersion);
 
 				MajorVersion = major_version;
 				MinorVersion = minor_version;
 				guid = new Guid (reader.ReadBytes (16));
 
 				ot = new OffsetTable (reader, major_version, minor_version);
 			} catch {
 				throw new MonoSymbolFileException (
 					"Cannot read symbol file `{0}'", filename);
 			}
 
 			source_file_hash = new Dictionary<int, SourceFileEntry> ();
 			compile_unit_hash = new Dictionary<int, CompileUnitEntry> ();
 		}
 
 		void CheckGuidMatch (Guid other, string filename, string assembly)
 		{
 			if (other == guid)
 				return;
 
 			throw new MonoSymbolFileException (
 				"Symbol file `{0}' does not match assembly `{1}'",
 				filename, assembly);
 		}
 
 #if CECIL
 		protected MonoSymbolFile (string filename, Mono.Cecil.ModuleDefinition module)
 			
 		{
 			CheckGuidMatch (module.Mvid, filename, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module)
 		{
 			return ReadSymbolFile (module, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module, string filename)
 		{
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, module);
 		}
 #else
 		protected MonoSymbolFile (string filename, Assembly assembly) 
 		{
 			// Check that the MDB file matches the assembly, if we have been
 			// passed an assembly.
 			if (assembly == null)
 				return;
 			
 			Module[] modules = assembly.GetModules ();
 			Guid assembly_guid = MonoDebuggerSupport.GetGuid (modules [0]);
 
 			CheckGuidMatch (assembly_guid, filename, assembly.Location);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Assembly assembly)
 		{
 			string filename = assembly.Location;
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, assembly);
 		}
 #endif
 
 		public static MonoSymbolFile ReadSymbolFile (string mdbFilename)
 		{
 			return new MonoSymbolFile (mdbFilename, null);
 		}
 
 		public int CompileUnitCount {
 			get { return ot.CompileUnitCount; }
 		}
 
 		public int SourceCount {
 			get { return ot.SourceCount; }
 		}
 
 		public int MethodCount {
 			get { return ot.MethodCount; }
 		}
 
 		public int TypeCount {
 			get { return ot.TypeCount; }
 		}
 
 		public int AnonymousScopeCount {
 			get { return ot.AnonymousScopeCount; }
 		}
 
 		public int NamespaceCount {
 			get { return last_namespace_index; }
 		}
 
 		public Guid Guid {
 			get { return guid; }
 		}
 
 		public OffsetTable OffsetTable {
 			get { return ot; }
 		}
 
 		internal int LineNumberCount = 0;
 		internal int LocalCount = 0;
 		internal int StringSize = 0;
 
 		internal int LineNumberSize = 0;
 		internal int ExtendedLineNumberSize = 0;
 		internal MonoSymbolFile ()
 		{
 			ot = new OffsetTable ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="56" endline="515">
<![CDATA[
 			28, 67, 78,
 			105, 108, 109, 114, 162, 164, 168, 169, 183, 184, 197,
 			219, 251, 252, 253, 278, 282,
 			402, 414, 419, 420, 429, 436, 440, 458, 464, 465, 467, 469, 472,
 			612, 618, 626, 628, 642, 649, 652, 658, 659, 660, 661, 665, 672, 675, 693,
 			728,
 			809,
 			1030, 1058, 1066,
 			1522, 1570, 1571, 1572, 1573, 1574, 1580, 1581, 1584, 1587, 1589, 1590, 1591, 1592,
 			1607, 1616, 1633, 1634, 1635, 1685, 1690, 1691, 1692, 1695, 1696, 1699, 1683,
 			1700, 1701, 1702, 1709, 1717, 1718, 1720,
 			1901, 1981,
 			2002, 2023, 2029,
 			3000, 3001, 3002, 3003, 3005, 3006, 3007, 3008, 3009,
 			3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019,
 			3021, 3022, 3023, 3024, 3026, 3027
 		};
 
 		static HashSet<int> AllWarningsHashSet;
 
 		public Report (ReportPrinter printer)
 		{
 			if (printer == null)
 				throw new ArgumentNullException ("printer");
 
 			this.printer = printer;
 			warning_level = 4;
 		}
 
 		public void DisableReporting ()
 		{
 			++reporting_disabled;
 		}
 
 		public void EnableReporting ()
 		{
 			--reporting_disabled;
 		}
 
 		public void FeatureIsNotAvailable (Location loc, string feature)
 		{
 			string version;
 			switch (RootContext.Version) {
 			case LanguageVersion.ISO_1
 				version = "1.0";
 				break;
 			case LanguageVersion.ISO_2
 				version = "2.0";
 				break;
 			case LanguageVersion.V_3
 				version = "3.0";
 				break;
 			default
 				throw new InternalErrorException ("Invalid feature version", RootContext.Version);
 			}
 
 			Error (1644, loc,
 				"Feature `{0}' cannot be used because it is not part of the C# {1} language specification",
 				      feature, version);
 		}
 
 		public void FeatureIsNotSupported (Location loc, string feature)
 		{
 			Error (1644, loc,
 				"Feature `{0}' is not supported in Mono mcs1 compiler. Consider using the `gmcs' compiler instead",
 				feature);
 		}
 		
 		bool IsWarningEnabled (int code, int level, Location loc)
 		{
 			if (WarningLevel < level)
 				return false;
 
 			if (IsWarningDisabledGlobally (code))
 				return false;
 
 			if (warning_regions_table == null || loc.IsNull)
 				return true;
 
 			WarningRegions regions;
 			if (!warning_regions_table.TryGetValue (loc.File, out regions))
 				return true;
 
 			return regions.IsWarningEnabled (code, loc.Row);
 		}
 
 		public bool IsWarningDisabledGlobally (int code)
 		{
 			return warning_ignore_table != null && warning_ignore_table.Contains (code);
 		}
 
 		bool IsWarningAsError (int code)
 		{
 			bool is_error = WarningsAreErrors;
 
 			// Check specific list
 			if (warnings_as_error != null)
 				is_error |= warnings_as_error.Contains (code);
 
 			// Ignore excluded warnings
 			if (warnings_only != null && warnings_only.Contains (code))
 				is_error = false;
 
 			return is_error;
 		}
 		        
 		public void RuntimeMissingSupport (Location loc, string feature) 
 		{
 			Error (-88, loc, "Your .NET Runtime does not support `{0}'. Please use the latest Mono runtime instead.", feature);
 		}
 
 		/// <summary>
 		/// In most error cases is very useful to have information about symbol that caused the error.
 		/// Call this method before you call Report.Error when it makes sense.
 		/// </summary>
 		public void SymbolRelatedToPreviousError (Location loc, string symbol)
 		{
 			SymbolRelatedToPreviousError (loc.ToString ());
 		}
 
 		public void SymbolRelatedToPreviousError (MemberSpec ms)
 		{
 			if (reporting_disabled > 0 || !printer.HasRelatedSymbolSupport)
 				return;
 
 			var mc = ms.MemberDefinition as MemberCore;
 			while (ms is ElementTypeSpec) {
 				ms = ((ElementTypeSpec) ms).Element;
 				mc = ms.MemberDefinition as MemberCore;
 			}
 
 			if (mc != null) {
 				SymbolRelatedToPreviousError (mc);
 			} else {
 				if (ms.DeclaringType != null)
 					ms = ms.DeclaringType;
 
 				var imported_type = ms.MemberDefinition as ImportedTypeDefinition;
 				if (imported_type != null) {
 					var iad = imported_type.DeclaringAssembly as ImportedAssemblyDefinition;
 					SymbolRelatedToPreviousError (iad.Location);
 				}
 			}
 		}
 
 		public void SymbolRelatedToPreviousError (MemberCore mc)
 		{
 			SymbolRelatedToPreviousError (mc.Location, mc.GetSignatureForError ());
 		}
 
 		public void SymbolRelatedToPreviousError (string loc)
 		{
 			string msg = String.Format ("{0} (Location of the symbol related to previous ", loc);
 			if (extra_information.Contains (msg))
 				return;
 
 			extra_information.Add (msg);
 		}
 
 		public void AddWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_as_error == null)
 				warnings_as_error = new List<int> ();
 			
 			warnings_as_error.Add (id);
 		}
 
 		public void RemoveWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_only == null)
 				warnings_only = new List<int> ();
 
 			warnings_only.Add (id);
 		}
 
 		public bool CheckWarningCode (string code, Location loc)
 		{
 			Warning (1691, 1, loc, "`{0}' is not a valid warning number", code);
 			return false;
 		}
 
 		public bool CheckWarningCode (int code, Location loc)
 		{
 			if (AllWarningsHashSet == null)
 				AllWarningsHashSet = new HashSet<int> (AllWarnings);
 
 			if (AllWarningsHashSet.Contains (code))
 				return true;
 
 			return CheckWarningCode (code.ToString (), loc);
 		}
 
 		public void ExtraInformation (Location loc, string msg)
 		{
 			extra_information.Add (String.Format ("{0} {1}", loc, msg));
 		}
 
 		public WarningRegions RegisterWarningRegion (Location location)
 		{
 			WarningRegions regions;
 			if (warning_regions_table == null) {
 				regions = null;
 				warning_regions_table = new Dictionary<int, WarningRegions> ();
 			} else {
 				warning_regions_table.TryGetValue (location.File, out regions);
 			}
 
 			if (regions == null) {
 				regions = new WarningRegions ();
 				warning_regions_table.Add (location.File, regions);
 			}
 
 			return regions;
 		}
 
 		public void Warning (int code, int level, Location loc, string message)
 		{
 			if (reporting_disabled > 0)
 				return;
 
 			if (!IsWarningEnabled (code, level, loc))
 				return;
 
 			AbstractMessage msg;
 			if (IsWarningAsError (code))
 				msg = new ErrorMessage (code, loc, message, extra_information);
 			else
 				msg = new WarningMessage (code, loc, message, extra_information);
 
 			extra_information.Clear ();
 			printer.Print (msg);
 		}
 
 		public void Warning (int code, int level, Location loc, string format, string arg)
 		{
 			Warning (code, level, loc, String.Format (format, arg));
 		}
 
 		public void Warning (int code, int level, Location loc, string format, string arg1, string arg2)
 		{
 			Warning (code, level, loc, String.Format (format, arg1, arg2));
 		}
 
 		public void Warning (int code, int level, Location loc, string format, params object[] args)
 		{
 			Warning (code, level, loc, String.Format (format, args));
 		}
 
 		public void Warning (int code, int level, string message)
 		{
 			Warning (code, level, Location.Null, message);
 		}
 
 		public void Warning (int code, int level, string format, string arg)
 		{
 			Warning (code, level, Location.Null, format, arg);
 		}
 
 		public void Warning (int code, int level, string format, string arg1, string arg2)
 		{
 			Warning (code, level, Location.Null, format, arg1, arg2);
 		}
 
 		public void Warning (int code, int level, string format, params string[] args)
 		{
 			Warning (code, level, Location.Null, String.Format (format, args));
 		}
 
 		//
 		// Warnings encountered so far
 		//
 		public int Warnings {
 			get { return printer.WarningsCount; }
 		}
 
 		public void Error (int code, Location loc, string error)
 		{
 			if (reporting_disabled > 0)
 				return;
 
 			ErrorMessage msg = new ErrorMessage (code, loc, error, extra_information);
 			extra_information.Clear ();
 
 			printer.Print (msg);
 		}
 
 		public void Error (int code, Location loc, string format, string arg)
 		{
 			Error (code, loc, String.Format (format, arg));
 		}
 
 		public void Error (int code, Location loc, string format, string arg1, string arg2)
 		{
 			Error (code, loc, String.Format (format, arg1, arg2));
 		}
 
 		public void Error (int code, Location loc, string format, params string[] args)
 		{
 			Error (code, loc, String.Format (format, args));
 		}
 
 		public void Error (int code, string error)
 		{
 			Error (code, Location.Null, error);
 		}
 
 		public void Error (int code, string format, string arg)
 		{
 			Error (code, Location.Null, format, arg);
 		}
 
 		public void Error (int code, string format, string arg1, string arg2)
 		{
 			Error (code, Location.Null, format, arg1, arg2);
 		}
 
 		public void Error (int code, string format, params string[] args)
 		{
 			Error (code, Location.Null, String.Format (format, args));
 		}
 
 		//
 		// Errors encountered so far
 		//
 		public int Errors {
 			get { return printer.ErrorsCount; }
 		}
 
 		public bool IsDisabled {
 			get {
 				return reporting_disabled > 0;
 			}
 		}
 
 		public ReportPrinter Printer {
 			get { return printer; }
 		}
 
 		public void SetIgnoreWarning (int code)
 		{
 			if (warning_ignore_table == null)
 				warning_ignore_table = new HashSet<int> ();
 
 			warning_ignore_table.Add (code);
 		}
 
 		public ReportPrinter SetPrinter (ReportPrinter printer)
 		{
 			ReportPrinter old = this.printer;
 			this.printer = printer;
 			return old;
 		}
 
 		public int WarningLevel {
 			get {
 				return warning_level;
 			}
 			set {
 				warning_level = value;
 			}
 		}
 
 		[Conditional ("MCS_DEBUG")]
 		static public void Debug (string message, params object[] args)
 		{
 			Debug (4, message, args);
 		}
 			
 		[Conditional ("MCS_DEBUG")]
 		static public void Debug (int category, string message, params object[] args)
 		{
 			if ((category & DebugFlags) == 0)
 				return;
 
 			StringBuilder sb = new StringBuilder (message);
 
 			if ((args != null) && (args.Length > 0)) {
 				sb.Append ("
 
 				bool first = true;
 				foreach (object arg in args) {
 					if (first)
 						first = false;
 					else
 						sb.Append (", ");
 					if (arg == null)
 						sb.Append ("null");
 //					else if (arg is ICollection)
 //						sb.Append (PrintCollection ((ICollection) arg));
 					else
 						sb.Append (arg);
 				}
 			}
 
 			Console.WriteLine (sb.ToString ());
 		}
 /*
 		static public string PrintCollection (ICollection collection)
 		{
 			StringBuilder sb = new StringBuilder ();
 
 			sb.Append (collection.GetType ());
 			sb.Append ("(");
 
 			bool first = true;
 			foreach (object o in collection) {
 				if (first)
 					first = false;
 				else
 					sb.Append (", ");
 				sb.Append (o);
 			}
 
 			sb.Append (")");
 			return sb.ToString ();
 		}
 */ 
 	}
 
 	public abstract class AbstractMessage
 	{
 		readonly string[] extra_info;
 		protected readonly int code;
 		protected readonly Location location;
 		readonly string message;
 
 		protected AbstractMessage (int code, Location loc, string msg, List<string> extraInfo)
 		{
 			this.code = code;
 			if (code < 0)
 				this.code = 8000 - code;
 
 			this.location = loc;
 			this.message = msg;
 			if (extraInfo.Count != 0) {
 				this.extra_info = extraInfo.ToArray ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="133" endline="303">
<![CDATA[
 
 		//
 		// Resolve the constraints types with only possible early checks, return
 		// value `false' is reserved for recursive failure
 		//
 		public bool Resolve (IMemberContext context, TypeParameter tp)
 		{
 			if (resolved)
 				return true;
 
 			if (resolving)
 				return false;
 
 			resolving = true;
 			var spec = tp.Type;
 			List<TypeParameterSpec> tparam_types = null;
 			bool iface_found = false;
 
 			spec.BaseType = TypeManager.object_type;
 
 			for (int i = 0; i < constraints.Count; ++i) {
 				var constraint = constraints[i];
 
 				if (constraint is SpecialContraintExpr) {
 					spec.SpecialConstraint |= ((SpecialContraintExpr) constraint).Constraint;
 					if (spec.HasSpecialStruct)
 						spec.BaseType = TypeManager.value_type;
 
 					// Set to null as it does not have a type
 					constraints[i] = null;
 					continue;
 				}
 
 				var type_expr = constraints[i] = constraint.ResolveAsTypeTerminal (context, false);
 				if (type_expr == null)
 					continue;
 
 				var gexpr = type_expr as GenericTypeExpr;
 				if (gexpr != null && gexpr.HasDynamicArguments ()) {
 					context.Compiler.Report.Error (1968, constraint.Location,
 						"A constraint cannot be the dynamic type `{0}'", gexpr.GetSignatureForError ());
 					continue;
 				}
 
 				var type = type_expr.Type;
 
 				if (!context.CurrentMemberDefinition.IsAccessibleAs (type)) {
 					context.Compiler.Report.SymbolRelatedToPreviousError (type);
 					context.Compiler.Report.Error (703, loc,
 						"Inconsistent accessibility
 						type.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				if (type.IsInterface) {
 					if (!spec.AddInterface (type)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 					}
 
 					iface_found = true;
 					continue;
 				}
 
 
 				var constraint_tp = type as TypeParameterSpec;
 				if (constraint_tp != null) {
 					if (tparam_types == null) {
 						tparam_types = new List<TypeParameterSpec> (2);
 					} else if (tparam_types.Contains (constraint_tp)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 						continue;
 					}
 
 					//
 					// Checks whether each generic method parameter constraint type
 					// is valid with respect to T
 					//
 					if (tp.IsMethodTypeParameter) {
 						TypeManager.CheckTypeVariance (type, Variance.Contravariant, context);
 					}
 
 					var tp_def = constraint_tp.MemberDefinition as TypeParameter;
 					if (tp_def != null && !tp_def.ResolveConstraints (context)) {
 						context.Compiler.Report.Error (454, constraint.Location,
 							"Circular constraint dependency involving `{0}' and `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					//
 					// Checks whether there are no conflicts between type parameter constraints
 					//
 					// class Foo<T, U>
 					//      where T 
 					//      where U 
 					//
 					// A and B are not convertible and only 1 class constraint is allowed
 					//
 					if (constraint_tp.HasTypeConstraint) {
 						if (spec.HasTypeConstraint || spec.HasSpecialStruct) {
 							if (!CheckConflictingInheritedConstraint (spec, constraint_tp.BaseType, context, constraint.Location))
 								continue;
 						} else {
 							for (int ii = 0; ii < tparam_types.Count; ++ii) {
 								if (!tparam_types[ii].HasTypeConstraint)
 									continue;
 
 								if (!CheckConflictingInheritedConstraint (spec, tparam_types[ii].BaseType, constraint_tp.BaseType, context, constraint.Location))
 									break;
 							}
 							for (int ii = 0; ii < tparam_types.Count; ++ii) {
 								if (!tparam_types[ii].HasTypeConstraint)
 									continue;
 
 								if (!CheckConflictingInheritedConstraint (spec, tparam_types[ii].BaseType, constraint_tp.BaseType, context, constraint.Location))
 									break;
 							}
 						}
 					}
 
 					if (constraint_tp.HasSpecialStruct) {
 						context.Compiler.Report.Error (456, constraint.Location,
 							"Type parameter `{0}' has the `struct' constraint, so it cannot be used as a constraint for `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					tparam_types.Add (constraint_tp);
 					continue;
 				}
 
 				if (iface_found || spec.HasTypeConstraint) {
 					context.Compiler.Report.Error (406, constraint.Location,
 						"The class type constraint `{0}' must be listed before any other constraints. Consider moving type constraint to the beginning of the constraint list",
 						type.GetSignatureForError ());
 				}
 
 				if (spec.HasSpecialStruct || spec.HasSpecialClass) {
 					context.Compiler.Report.Error (450, type_expr.Location,
 						"`{0}'
 						type.GetSignatureForError ());
 				}
 
 				if (type == InternalType.Dynamic) {
 					context.Compiler.Report.Error (1967, constraint.Location, "A constraint cannot be the dynamic type");
 					continue;
 				}
 
 				if (type.IsSealed || !type.IsClass) {
 					context.Compiler.Report.Error (701, loc,
 						"`{0}' is not a valid constraint. A constraint must be an interface, a non-sealed class or a type parameter",
 						TypeManager.CSharpName (type));
 					continue;
 				}
 
 				if (type.IsStatic) {
 					context.Compiler.Report.Error (717, constraint.Location,
 						"`{0}' is not a valid constraint. Static classes cannot be used as constraints",
 						type.GetSignatureForError ());
 				} else if (type == TypeManager.array_type || type == TypeManager.delegate_type ||
 							type == TypeManager.enum_type || type == TypeManager.value_type ||
 							type == TypeManager.object_type || type == TypeManager.multicast_delegate_type) {
 					context.Compiler.Report.Error (702, constraint.Location,
 						"A constraint cannot be special class `{0}'", type.GetSignatureForError ());
 					continue;
 				}
 
 				spec.BaseType = type;
 			}
 			for (int i = 0; i < constraints.Count; ++i) {
 				var constraint = constraints[i];
 
 				if (constraint is SpecialContraintExpr) {
 					spec.SpecialConstraint |= ((SpecialContraintExpr) constraint).Constraint;
 					if (spec.HasSpecialStruct)
 						spec.BaseType = TypeManager.value_type;
 
 					// Set to null as it does not have a type
 					constraints[i] = null;
 					continue;
 				}
 
 				var type_expr = constraints[i] = constraint.ResolveAsTypeTerminal (context, false);
 				if (type_expr == null)
 					continue;
 
 				var gexpr = type_expr as GenericTypeExpr;
 				if (gexpr != null && gexpr.HasDynamicArguments ()) {
 					context.Compiler.Report.Error (1968, constraint.Location,
 						"A constraint cannot be the dynamic type `{0}'", gexpr.GetSignatureForError ());
 					continue;
 				}
 
 				var type = type_expr.Type;
 
 				if (!context.CurrentMemberDefinition.IsAccessibleAs (type)) {
 					context.Compiler.Report.SymbolRelatedToPreviousError (type);
 					context.Compiler.Report.Error (703, loc,
 						"Inconsistent accessibility
 						type.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				if (type.IsInterface) {
 					if (!spec.AddInterface (type)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 					}
 
 					iface_found = true;
 					continue;
 				}
 
 
 				var constraint_tp = type as TypeParameterSpec;
 				if (constraint_tp != null) {
 					if (tparam_types == null) {
 						tparam_types = new List<TypeParameterSpec> (2);
 					} else if (tparam_types.Contains (constraint_tp)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 						continue;
 					}
 
 					//
 					// Checks whether each generic method parameter constraint type
 					// is valid with respect to T
 					//
 					if (tp.IsMethodTypeParameter) {
 						TypeManager.CheckTypeVariance (type, Variance.Contravariant, context);
 					}
 
 					var tp_def = constraint_tp.MemberDefinition as TypeParameter;
 					if (tp_def != null && !tp_def.ResolveConstraints (context)) {
 						context.Compiler.Report.Error (454, constraint.Location,
 							"Circular constraint dependency involving `{0}' and `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					//
 					// Checks whether there are no conflicts between type parameter constraints
 					//
 					// class Foo<T, U>
 					//      where T 
 					//      where U 
 					//
 					// A and B are not convertible and only 1 class constraint is allowed
 					//
 					if (constraint_tp.HasTypeConstraint) {
 						if (spec.HasTypeConstraint || spec.HasSpecialStruct) {
 							if (!CheckConflictingInheritedConstraint (spec, constraint_tp.BaseType, context, constraint.Location))
 								continue;
 						} else {
 							for (int ii = 0; ii < tparam_types.Count; ++ii) {
 								if (!tparam_types[ii].HasTypeConstraint)
 									continue;
 
 								if (!CheckConflictingInheritedConstraint (spec, tparam_types[ii].BaseType, constraint_tp.BaseType, context, constraint.Location))
 									break;
 							}
 						}
 					}
 
 					if (constraint_tp.HasSpecialStruct) {
 						context.Compiler.Report.Error (456, constraint.Location,
 							"Type parameter `{0}' has the `struct' constraint, so it cannot be used as a constraint for `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					tparam_types.Add (constraint_tp);
 					continue;
 				}
 
 				if (iface_found || spec.HasTypeConstraint) {
 					context.Compiler.Report.Error (406, constraint.Location,
 						"The class type constraint `{0}' must be listed before any other constraints. Consider moving type constraint to the beginning of the constraint list",
 						type.GetSignatureForError ());
 				}
 
 				if (spec.HasSpecialStruct || spec.HasSpecialClass) {
 					context.Compiler.Report.Error (450, type_expr.Location,
 						"`{0}'
 						type.GetSignatureForError ());
 				}
 
 				if (type == InternalType.Dynamic) {
 					context.Compiler.Report.Error (1967, constraint.Location, "A constraint cannot be the dynamic type");
 					continue;
 				}
 
 				if (type.IsSealed || !type.IsClass) {
 					context.Compiler.Report.Error (701, loc,
 						"`{0}' is not a valid constraint. A constraint must be an interface, a non-sealed class or a type parameter",
 						TypeManager.CSharpName (type));
 					continue;
 				}
 
 				if (type.IsStatic) {
 					context.Compiler.Report.Error (717, constraint.Location,
 						"`{0}' is not a valid constraint. Static classes cannot be used as constraints",
 						type.GetSignatureForError ());
 				} else if (type == TypeManager.array_type || type == TypeManager.delegate_type ||
 							type == TypeManager.enum_type || type == TypeManager.value_type ||
 							type == TypeManager.object_type || type == TypeManager.multicast_delegate_type) {
 					context.Compiler.Report.Error (702, constraint.Location,
 						"A constraint cannot be special class `{0}'", type.GetSignatureForError ());
 					continue;
 				}
 
 				spec.BaseType = type;
 			}
 
 			if (tparam_types != null)
 				spec.TypeArguments = tparam_types.ToArray ();
 
 			resolving = false;
 			resolved = true;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="1036" endline="1149">
<![CDATA[
 
 		//
 		// Checks all appropriate container members for CLS compliance
 		//
 		public void VerifyClsCompliance (TypeSpec container, Report report)
 		{
 			if (locase_members != null)
 				return;
 
 			if (container.BaseType == null) {
 				locase_members = new Dictionary<string, MemberSpec[]> (member_hash.Count); // StringComparer.OrdinalIgnoreCase);
 			} else {
 				container.BaseType.MemberCache.VerifyClsCompliance (container.BaseType, report);
 				locase_members = new Dictionary<string, MemberSpec[]> (container.BaseType.MemberCache.locase_members); //, StringComparer.OrdinalIgnoreCase);
 			}
 
 			var is_imported_type = container.MemberDefinition.IsImported;
 			foreach (var entry in container.MemberCache.member_hash) {
 				for (int i = 0; i < entry.Value.Count; ++i ) {
 					var name_entry = entry.Value[i];
 					if ((name_entry.Modifiers & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 						continue;
 
 					if ((name_entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.COMPILER_GENERATED)) != 0)
 						continue;
 
 					if ((name_entry.Kind & MemberKind.MaskType) == 0)
 						continue;
 
 					if (name_entry.MemberDefinition.IsNotCLSCompliant ())
 					    continue;
 
 					IParametersMember p_a = name_entry as IParametersMember;
 					if (p_a != null && !name_entry.IsAccessor) {
 						if (!is_imported_type) {
 							var p_a_pd = p_a.Parameters;
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 						}
 					}
 
 					if (i > 0 || name_entry.Kind == MemberKind.Constructor || name_entry.Kind == MemberKind.Indexer)
 						continue;
 
 					var name_entry_locase = name_entry.Name.ToLowerInvariant ();
 
 					MemberSpec[] found;
 					if (!locase_members.TryGetValue (name_entry_locase, out found)) {
 						found = new MemberSpec[] { name_entry };
 						locase_members.Add (name_entry_locase, found);
 					} else {
 						bool same_names_only = true;
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 
 						if (!same_names_only) {
 							Array.Resize (ref found, found.Length + 1);
 							found[found.Length - 1] = name_entry;
 							locase_members[name_entry_locase] = found;
 						}
 					}
 				}
 				for (int i = 0; i < entry.Value.Count; ++i ) {
 					var name_entry = entry.Value[i];
 					if ((name_entry.Modifiers & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 						continue;
 
 					if ((name_entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.COMPILER_GENERATED)) != 0)
 						continue;
 
 					if ((name_entry.Kind & MemberKind.MaskType) == 0)
 						continue;
 
 					if (name_entry.MemberDefinition.IsNotCLSCompliant ())
 					    continue;
 
 					IParametersMember p_a = name_entry as IParametersMember;
 					if (p_a != null && !name_entry.IsAccessor) {
 						if (!is_imported_type) {
 							var p_a_pd = p_a.Parameters;
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 						}
 					}
 
 					if (i > 0 || name_entry.Kind == MemberKind.Constructor || name_entry.Kind == MemberKind.Indexer)
 						continue;
 
 					var name_entry_locase = name_entry.Name.ToLowerInvariant ();
 
 					MemberSpec[] found;
 					if (!locase_members.TryGetValue (name_entry_locase, out found)) {
 						found = new MemberSpec[] { name_entry };
 						locase_members.Add (name_entry_locase, found);
 					} else {
 						bool same_names_only = true;
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 
 						if (!same_names_only) {
 							Array.Resize (ref found, found.Length + 1);
 							found[found.Length - 1] = name_entry;
 							locase_members[name_entry_locase] = found;
 						}
 					}
 				}
 			}
 			foreach (var entry in container.MemberCache.member_hash) {
 				for (int i = 0; i < entry.Value.Count; ++i ) {
 					var name_entry = entry.Value[i];
 					if ((name_entry.Modifiers & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 						continue;
 
 					if ((name_entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.COMPILER_GENERATED)) != 0)
 						continue;
 
 					if ((name_entry.Kind & MemberKind.MaskType) == 0)
 						continue;
 
 					if (name_entry.MemberDefinition.IsNotCLSCompliant ())
 					    continue;
 
 					IParametersMember p_a = name_entry as IParametersMember;
 					if (p_a != null && !name_entry.IsAccessor) {
 						if (!is_imported_type) {
 							var p_a_pd = p_a.Parameters;
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 						}
 					}
 
 					if (i > 0 || name_entry.Kind == MemberKind.Constructor || name_entry.Kind == MemberKind.Indexer)
 						continue;
 
 					var name_entry_locase = name_entry.Name.ToLowerInvariant ();
 
 					MemberSpec[] found;
 					if (!locase_members.TryGetValue (name_entry_locase, out found)) {
 						found = new MemberSpec[] { name_entry };
 						locase_members.Add (name_entry_locase, found);
 					} else {
 						bool same_names_only = true;
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 
 						if (!same_names_only) {
 							Array.Resize (ref found, found.Length + 1);
 							found[found.Length - 1] = name_entry;
 							locase_members[name_entry_locase] = found;
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3722" endline="4022">
<![CDATA[
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="100" endline="291">
<![CDATA[
 		private readonly int position;
 
 		private sealed class DummyModule 
 		{
 			internal DummyModule()
 				
 			{
 			}
 
 			public override bool Equals(object obj)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int GetHashCode()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ToString()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int MDStreamVersion
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Assembly Assembly
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			internal override Type GetTypeImpl(string typeName)
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override void GetTypesImpl(List<Type> list)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string FullyQualifiedName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override string Name
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Guid ModuleVersionId
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ResolveString(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ScopeName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override AssemblyName[] __GetReferencedAssemblies()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override Type GetModuleType()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override ByteReader GetBlob(int blobIndex)
 			{
 				throw new InvalidOperationException();
 			}
 		}
 
 		internal static Type Make(int position)
 		{
 			return module.CanonicalizeType(new UnboundGenericMethodParameter(position));
 		}
 
 		private UnboundGenericMethodParameter(int position)
 		{
 			this.position = position;
 		}
 
 		public override bool Equals(object obj)
 		{
 			UnboundGenericMethodParameter other = obj as UnboundGenericMethodParameter;
 			return other != null && other.position == position;
 		}
 
 		public override int GetHashCode()
 		{
 			return position;
 		}
 
 		public override string Namespace
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override string Name
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override int MetadataToken
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Module Module
 		{
 			get { return module; }
 		}
 
 		public override int GenericParameterPosition
 		{
 			get { return position; }
 		}
 
 		public override Type DeclaringType
 		{
 			get { return null; }
 		}
 
 		public override MethodBase DeclaringMethod
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Type[] GetGenericParameterConstraints()
 		{
 			throw new InvalidOperationException();
 		}
 
 		public override GenericParameterAttributes GenericParameterAttributes
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			return binder.BindMethodParameter(this);
 		}
 	}
 
 	sealed class GenericTypeParameter 
 	{
 		private readonly ModuleReader module;
 		private readonly int index;
 
 		internal GenericTypeParameter(ModuleReader module, int index)
 		{
 			this.module = module;
 			this.index = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="169" endline="837">
<![CDATA[
 		bool hidden = false;
 		int ref_line = 1;
 		int line = 1;
 		int col = 0;
 		int previous_col;
 		int current_token;
 		int tab_size;
 		bool handle_get_set = false;
 		bool handle_remove_add = false;
 		bool handle_where = false;
 		bool handle_typeof = false;
 		bool lambda_arguments_parsing;
 		Location current_comment_location = Location.Null;
 		List<Location> escaped_identifiers;
 		int parsing_generic_less_than;
 		
 		//
 		// Used mainly for parser optimizations. Some expressions for instance
 		// can appear only in block (including initializer, base initializer)
 		// scope only
 		//
 		public int parsing_block;
 		internal bool query_parsing;
 		
 		// 
 		// When parsing type only, useful for ambiguous nullable types
 		//
 		public int parsing_type;
 		
 		//
 		// Set when parsing generic declaration (type or method header)
 		//
 		public bool parsing_generic_declaration;
 		
 		//
 		// The value indicates that we have not reach any declaration or
 		// namespace yet
 		//
 		public int parsing_declaration;
 
 		//
 		// The special character to inject on streams to trigger the EXPRESSION_PARSE
 		// token to be returned.   It just happens to be a Unicode character that
 		// would never be part of a program (can not be an identifier).
 		//
 		// This character is only tested just before the tokenizer is about to report
 		// an error;   So on the regular operation mode, this addition will have no
 		// impact on the tokenizer's performance.
 		//
 		
 		public const int EvalStatementParserCharacter = 0x2190;   // Unicode Left Arrow
 		public const int EvalCompilationUnitParserCharacter = 0x2191;  // Unicode Arrow
 		public const int EvalUsingDeclarationsParserCharacter = 0x2192;  // Unicode Arrow
 		
 		//
 		// XML documentation buffer. The save point is used to divide
 		// comments on types and comments on members.
 		//
 		StringBuilder xml_comment_buffer;
 
 		//
 		// See comment on XmlCommentState enumeration.
 		//
 		XmlCommentState xml_doc_state = XmlCommentState.Allowed;
 
 		//
 		// Whether tokens have been seen on this line
 		//
 		bool tokens_seen = false;
 
 		//
 		// Set to true once the GENERATE_COMPLETION token has bee
 		// returned.   This helps produce one GENERATE_COMPLETION,
 		// as many COMPLETE_COMPLETION as necessary to complete the
 		// AST tree and one final EOF.
 		//
 		bool generated;
 		
 		//
 		// Whether a token has been seen on the file
 		// This is needed because `define' is not allowed to be used
 		// after a token has been seen.
 		//
 		bool any_token_seen = false;
 
 		static readonly char[] simple_whitespaces = new char[] { ' ', '\t' };
 
 		public bool PropertyParsing {
 			get { return handle_get_set; }
 			set { handle_get_set = value; }
 		}
 
 		public bool EventParsing {
 			get { return handle_remove_add; }
 			set { handle_remove_add = value; }
 		}
 
 		public bool ConstraintsParsing {
 			get { return handle_where; }
 			set { handle_where = value; }
 		}
 
 		public bool TypeOfParsing {
 			get { return handle_typeof; }
 			set { handle_typeof = value; }
 		}
 
 		public int TabSize {
 			get { return tab_size; }
 			set { tab_size = value; }
 		}
 		
 		public XmlCommentState doc_state {
 			get { return xml_doc_state; }
 			set {
 				if (value == XmlCommentState.Allowed) {
 					check_incorrect_doc_comment ();
 					reset_doc_comment ();
 				}
 				xml_doc_state = value;
 			}
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
 
 		public bool IsEscapedIdentifier (MemberName name)
 		{
 			return escaped_identifiers != null && escaped_identifiers.Contains (name.Location);
 		}
 
 		//
 		// Class variables
 		// 
 		static KeywordEntry<int>[][] keywords;
 		static KeywordEntry<PreprocessorDirective>[][] keywords_preprocessor;
 		static Dictionary<string, object> keyword_strings; 		// TODO
 		static NumberStyles styles;
 		static NumberFormatInfo csharp_format_info;
 
 		// Pragma arguments
 		static readonly char[] pragma_warning = "warning".ToCharArray ();
 		static readonly char[] pragma_warning_disable = "disable".ToCharArray ();
 		static readonly char[] pragma_warning_restore = "restore".ToCharArray ();
 		static readonly char[] pragma_checksum = "checksum".ToCharArray ();
 		
 		//
 		// Values for the associated token returned
 		//
 		internal int putback_char; 	// Used by repl only
 		object val;
 
 		//
 		// Pre-processor
 		//
 		const int TAKING        = 1;
 		const int ELSE_SEEN     = 4;
 		const int PARENT_TAKING = 8;
 		const int REGION        = 16;		
 
 		//
 		// pre-processor if stack state
 		//
 		Stack<int> ifstack;
 
 		static System.Text.StringBuilder string_builder;
 
 		const int max_id_size = 512;
 		static char [] id_builder = new char [max_id_size];
 
 		public static Dictionary<char[], string>[] identifiers = new Dictionary<char[], string>[max_id_size + 1];
 
 		const int max_number_size = 512;
 		static char [] number_builder = new char [max_number_size];
 		static int number_pos;
 
 		static StringBuilder static_cmd_arg = new System.Text.StringBuilder ();
 		
 		public int Line {
 			get {
 				return ref_line;
 			}
 		}
 
 		//
 		// This is used when the tokenizer needs to save
 		// the current position as it needs to do some parsing
 		// on its own to deamiguate a token in behalf of the
 		// parser.
 		//
 		Stack<Position> position_stack = new Stack<Position> (2);
 
 		class Position {
 			public int position;
 			public int line;
 			public int ref_line;
 			public int col;
 			public bool hidden;
 			public int putback_char;
 			public int previous_col;
 			public Stack<int> ifstack;
 			public int parsing_generic_less_than;
 			public int current_token;
 			public object val;
 
 			public Position (Tokenizer t)
 			{
 				position = t.reader.Position;
 				line = t.line;
 				ref_line = t.ref_line;
 				col = t.col;
 				hidden = t.hidden;
 				putback_char = t.putback_char;
 				previous_col = t.previous_col;
 				if (t.ifstack != null && t.ifstack.Count != 0) {
 					// There is no simple way to clone Stack<T> all
 					// methods reverse the order
 					var clone = t.ifstack.ToArray ();
 					Array.Reverse (clone);
 					ifstack = new Stack<int> (clone);
 				}
 				parsing_generic_less_than = t.parsing_generic_less_than;
 				current_token = t.current_token;
 				val = t.val;
 			}
 		}
 		
 		public void PushPosition ()
 		{
 			position_stack.Push (new Position (this));
 		}
 
 		public void PopPosition ()
 		{
 			Position p = position_stack.Pop ();
 
 			reader.Position = p.position;
 			ref_line = p.ref_line;
 			line = p.line;
 			col = p.col;
 			hidden = p.hidden;
 			putback_char = p.putback_char;
 			previous_col = p.previous_col;
 			ifstack = p.ifstack;
 			parsing_generic_less_than = p.parsing_generic_less_than;
 			current_token = p.current_token;
 			val = p.val;
 		}
 
 		// Do not reset the position, ignore it.
 		public void DiscardPosition ()
 		{
 			position_stack.Pop ();
 		}
 		
 		static void AddKeyword (string kw, int token)
 		{
 			keyword_strings.Add (kw, null);
 
 			AddKeyword (keywords, kw, token);
 		}
 
 		static void AddPreprocessorKeyword (string kw, PreprocessorDirective directive)
 		{
 			AddKeyword (keywords_preprocessor, kw, directive);
 		}
 
 		static void AddKeyword<T> (KeywordEntry<T>[][] keywords, string kw, T token)
 		{
 			int length = kw.Length;
 			if (keywords[length] == null) {
 				keywords[length] = new KeywordEntry<T>['z' - '_' + 1];
 			}
 
 			int char_index = kw[0] - '_';
 			var kwe = keywords[length][char_index];
 			if (kwe == null) {
 				keywords[length][char_index] = new KeywordEntry<T> (kw, token);
 				return;
 			}
 
 			while (kwe.Next != null) {
 				kwe = kwe.Next;
 			}
 
 			kwe.Next = new KeywordEntry<T> (kw, token);
 		}
 
 		static void InitTokens ()
 		{
 			keyword_strings = new Dictionary<string, object> ();
 
 			// 11 is the length of the longest keyword for now
 			keywords = new KeywordEntry<int> [11] [];
 
 			AddKeyword ("__arglist", Token.ARGLIST);
 			AddKeyword ("abstract", Token.ABSTRACT);
 			AddKeyword ("as", Token.AS);
 			AddKeyword ("add", Token.ADD);
 			AddKeyword ("base", Token.BASE);
 			AddKeyword ("bool", Token.BOOL);
 			AddKeyword ("break", Token.BREAK);
 			AddKeyword ("byte", Token.BYTE);
 			AddKeyword ("case", Token.CASE);
 			AddKeyword ("catch", Token.CATCH);
 			AddKeyword ("char", Token.CHAR);
 			AddKeyword ("checked", Token.CHECKED);
 			AddKeyword ("class", Token.CLASS);
 			AddKeyword ("const", Token.CONST);
 			AddKeyword ("continue", Token.CONTINUE);
 			AddKeyword ("decimal", Token.DECIMAL);
 			AddKeyword ("default", Token.DEFAULT);
 			AddKeyword ("delegate", Token.DELEGATE);
 			AddKeyword ("do", Token.DO);
 			AddKeyword ("double", Token.DOUBLE);
 			AddKeyword ("else", Token.ELSE);
 			AddKeyword ("enum", Token.ENUM);
 			AddKeyword ("event", Token.EVENT);
 			AddKeyword ("explicit", Token.EXPLICIT);
 			AddKeyword ("extern", Token.EXTERN);
 			AddKeyword ("false", Token.FALSE);
 			AddKeyword ("finally", Token.FINALLY);
 			AddKeyword ("fixed", Token.FIXED);
 			AddKeyword ("float", Token.FLOAT);
 			AddKeyword ("for", Token.FOR);
 			AddKeyword ("foreach", Token.FOREACH);
 			AddKeyword ("goto", Token.GOTO);
 			AddKeyword ("get", Token.GET);
 			AddKeyword ("if", Token.IF);
 			AddKeyword ("implicit", Token.IMPLICIT);
 			AddKeyword ("in", Token.IN);
 			AddKeyword ("int", Token.INT);
 			AddKeyword ("interface", Token.INTERFACE);
 			AddKeyword ("internal", Token.INTERNAL);
 			AddKeyword ("is", Token.IS);
 			AddKeyword ("lock", Token.LOCK);
 			AddKeyword ("long", Token.LONG);
 			AddKeyword ("namespace", Token.NAMESPACE);
 			AddKeyword ("new", Token.NEW);
 			AddKeyword ("null", Token.NULL);
 			AddKeyword ("object", Token.OBJECT);
 			AddKeyword ("operator", Token.OPERATOR);
 			AddKeyword ("out", Token.OUT);
 			AddKeyword ("override", Token.OVERRIDE);
 			AddKeyword ("params", Token.PARAMS);
 			AddKeyword ("private", Token.PRIVATE);
 			AddKeyword ("protected", Token.PROTECTED);
 			AddKeyword ("public", Token.PUBLIC);
 			AddKeyword ("readonly", Token.READONLY);
 			AddKeyword ("ref", Token.REF);
 			AddKeyword ("remove", Token.REMOVE);
 			AddKeyword ("return", Token.RETURN);
 			AddKeyword ("sbyte", Token.SBYTE);
 			AddKeyword ("sealed", Token.SEALED);
 			AddKeyword ("set", Token.SET);
 			AddKeyword ("short", Token.SHORT);
 			AddKeyword ("sizeof", Token.SIZEOF);
 			AddKeyword ("stackalloc", Token.STACKALLOC);
 			AddKeyword ("static", Token.STATIC);
 			AddKeyword ("string", Token.STRING);
 			AddKeyword ("struct", Token.STRUCT);
 			AddKeyword ("switch", Token.SWITCH);
 			AddKeyword ("this", Token.THIS);
 			AddKeyword ("throw", Token.THROW);
 			AddKeyword ("true", Token.TRUE);
 			AddKeyword ("try", Token.TRY);
 			AddKeyword ("typeof", Token.TYPEOF);
 			AddKeyword ("uint", Token.UINT);
 			AddKeyword ("ulong", Token.ULONG);
 			AddKeyword ("unchecked", Token.UNCHECKED);
 			AddKeyword ("unsafe", Token.UNSAFE);
 			AddKeyword ("ushort", Token.USHORT);
 			AddKeyword ("using", Token.USING);
 			AddKeyword ("virtual", Token.VIRTUAL);
 			AddKeyword ("void", Token.VOID);
 			AddKeyword ("volatile", Token.VOLATILE);
 			AddKeyword ("while", Token.WHILE);
 			AddKeyword ("partial", Token.PARTIAL);
 			AddKeyword ("where", Token.WHERE);
 			AddKeyword ("async", Token.ASYNC);
 
 			// LINQ keywords
 			AddKeyword ("from", Token.FROM);
 			AddKeyword ("join", Token.JOIN);
 			AddKeyword ("on", Token.ON);
 			AddKeyword ("equals", Token.EQUALS);
 			AddKeyword ("select", Token.SELECT);
 			AddKeyword ("group", Token.GROUP);
 			AddKeyword ("by", Token.BY);
 			AddKeyword ("let", Token.LET);
 			AddKeyword ("orderby", Token.ORDERBY);
 			AddKeyword ("ascending", Token.ASCENDING);
 			AddKeyword ("descending", Token.DESCENDING);
 			AddKeyword ("into", Token.INTO);
 
 			keywords_preprocessor = new KeywordEntry<PreprocessorDirective>[10][];
 
 			AddPreprocessorKeyword ("region", PreprocessorDirective.Region);
 			AddPreprocessorKeyword ("endregion", PreprocessorDirective.Endregion);
 			AddPreprocessorKeyword ("if", PreprocessorDirective.If);
 			AddPreprocessorKeyword ("endif", PreprocessorDirective.Endif);
 			AddPreprocessorKeyword ("elif", PreprocessorDirective.Elif);
 			AddPreprocessorKeyword ("else", PreprocessorDirective.Else);
 			AddPreprocessorKeyword ("define", PreprocessorDirective.Define);
 			AddPreprocessorKeyword ("undef", PreprocessorDirective.Undef);
 			AddPreprocessorKeyword ("error", PreprocessorDirective.Error);
 			AddPreprocessorKeyword ("warning", PreprocessorDirective.Warning);
 			AddPreprocessorKeyword ("pragma", PreprocessorDirective.Pragma);
 			AddPreprocessorKeyword ("line", PreprocessorDirective.Line);
 		}
 
 		//
 		// Class initializer
 		// 
 		static Tokenizer ()
 		{
 			InitTokens ();			
 			csharp_format_info = NumberFormatInfo.InvariantInfo;
 			styles = NumberStyles.Float;
 
 			string_builder = new System.Text.StringBuilder ();
 		}
 
 		int GetKeyword (char[] id, int id_len)
 		{
 			//
 			// Keywords are stored in an array of arrays grouped by their
 			// length and then by the first character
 			//
 			if (id_len >= keywords.Length || keywords [id_len] == null)
 				return -1;
 
 			int first_index = id [0] - '_';
 			if (first_index > 'z' - '_')
 				return -1;
 
 			var kwe = keywords [id_len] [first_index];
 			if (kwe == null)
 				return -1;
 
 			int res;
 			do {
 				res = kwe.Token;
 				for (int i = 1; i < id_len; ++i) {
 					if (id [i] != kwe.Value [i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 			} while (res == 0 && kwe != null);
 
 			if (res == 0)
 				return -1;
 
 			int next_token;
 			switch (res) {
 			case Token.GET
 			case Token.SET
 				if (!handle_get_set)
 					res = -1;
 				break;
 			case Token.REMOVE
 			case Token.ADD
 				if (!handle_remove_add)
 					res = -1;
 				break;
 			case Token.EXTERN
 				if (parsing_declaration == 0)
 					res = Token.EXTERN_ALIAS;
 				break;
 			case Token.DEFAULT
 				if (peek_token () == Token.COLON) {
 					token ();
 					res = Token.DEFAULT_COLON;
 				}
 				break;
 			case Token.WHERE
 				if (!handle_where && !query_parsing)
 					res = -1;
 				break;
 			case Token.FROM
 				//
 				// A query expression is any expression that starts with `from identifier'
 				// followed by any token except ; , =
 				// 
 				if (!query_parsing) {
 					if (lambda_arguments_parsing) {
 						res = -1;
 						break;
 					}
 
 					PushPosition ();
 					// HACK
 					// store identifiers array
 					parsing_generic_less_than = 1;
 					switch (xtoken ()) {
 					case Token.IDENTIFIER
 					case Token.INT
 					case Token.BOOL
 					case Token.BYTE
 					case Token.CHAR
 					case Token.DECIMAL
 					case Token.FLOAT
 					case Token.LONG
 					case Token.OBJECT
 					case Token.STRING
 					case Token.UINT
 					case Token.ULONG
 						next_token = xtoken ();
 						if (next_token == Token.SEMICOLON || next_token == Token.COMMA || next_token == Token.EQUALS)
 							goto default;
 						
 						res = Token.FROM_FIRST;
 						query_parsing = true;
 						if (RootContext.Version <= LanguageVersion.ISO_2)
 							Report.FeatureIsNotAvailable (Location, "query expressions");
 						break;
 					case Token.VOID
 						Expression.Error_VoidInvalidInTheContext (Location, Report);
 						break;
 					default
 						PopPosition ();
 						// HACK
 						// which has been overwritten before we grabbed the identifier
 						id_builder [0] = 'f'; id_builder [1] = 'r'; id_builder [2] = 'o'; id_builder [3] = 'm';
 						return -1;
 					}
 					PopPosition ();
 				}
 				break;
 			case Token.JOIN
 			case Token.ON
 			case Token.EQUALS
 			case Token.SELECT
 			case Token.GROUP
 			case Token.BY
 			case Token.LET
 			case Token.ORDERBY
 			case Token.ASCENDING
 			case Token.DESCENDING
 			case Token.INTO
 				if (!query_parsing)
 					res = -1;
 				break;
 				
 			case Token.USING
 			case Token.NAMESPACE
 				// TODO
 				check_incorrect_doc_comment ();
 				break;
 				
 			case Token.PARTIAL
 				if (parsing_block > 0) {
 					res = -1;
 					break;
 				}
 
 				// Save current position and parse next token.
 				PushPosition ();
 
 				next_token = token ();
 				bool ok = (next_token == Token.CLASS) ||
 					(next_token == Token.STRUCT) ||
 					(next_token == Token.INTERFACE) ||
 					(next_token == Token.VOID);
 
 				PopPosition ();
 
 				if (ok) {
 					if (next_token == Token.VOID) {
 						if (RootContext.Version == LanguageVersion.ISO_1 ||
 						    RootContext.Version == LanguageVersion.ISO_2)
 							Report.FeatureIsNotAvailable (Location, "partial methods");
 					} else if (RootContext.Version == LanguageVersion.ISO_1)
 						Report.FeatureIsNotAvailable (Location, "partial types");
 
 					return res;
 				}
 
 				if (next_token < Token.LAST_KEYWORD) {
 					Report.Error (267, Location,
 						"The `partial' modifier can be used only immediately before `class', `struct', `interface', or `void' keyword");
 					return token ();
 				}					
 
 				res = -1;
 				break;
 
 			case Token.ASYNC
 				if (parsing_block > 0 || RootContext.Version != LanguageVersion.Future) {
 					res = -1;
 					break;
 				}
 				break;
 			}
 
 			return res;
 		}
 
 		static PreprocessorDirective GetPreprocessorDirective (char[] id, int id_len)
 		{
 			//
 			// Keywords are stored in an array of arrays grouped by their
 			// length and then by the first character
 			//
 			if (id_len >= keywords_preprocessor.Length || keywords_preprocessor[id_len] == null)
 				return PreprocessorDirective.Invalid;
 
 			int first_index = id[0] - '_';
 			if (first_index > 'z' - '_')
 				return PreprocessorDirective.Invalid;
 
 			var kwe = keywords_preprocessor[id_len][first_index];
 			if (kwe == null)
 				return PreprocessorDirective.Invalid;
 
 			PreprocessorDirective res = PreprocessorDirective.Invalid;
 			do {
 				res = kwe.Token;
 				for (int i = 1; i < id_len; ++i) {
 					if (id[i] != kwe.Value[i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 			} while (res == PreprocessorDirective.Invalid && kwe != null);
 
 			return res;
 		}
 
 		public Location Location {
 			get {
 				return new Location (ref_line, hidden ? -1 
 			}
 		}
 
 		public Tokenizer (SeekableStreamReader input, CompilationUnit file, CompilerContext ctx)
 		{
 			this.ref_name = file;
 			this.file_name = file;
 			this.context = ctx;
 			reader = input;
 			
 			putback_char = -1;
 
 			xml_comment_buffer = new StringBuilder ();
 
 			if (Environment.OSVersion.Platform == PlatformID.Win32NT)
 				tab_size = 4;
 			else
 				tab_size = 8;
 
 			//
 			// FIXME
 			// find out why the MS compiler allows this
 			//
 			Mono.CSharp.Location.Push (file, file);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4853" endline="5519">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
 
 		#region Properties
 
 		public override bool IsLockedByStatement {
 			get {
 				return pi.IsLocked;
 			}
 			set	{
 				pi.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return (pi.Parameter.ModFlags & Parameter.Modifier.ISBYREF) != 0; }
 		}
 
 		bool HasOutModifier {
 			get { return pi.Parameter.ModFlags == Parameter.Modifier.OUT; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return pi.Parameter.HoistedVariant;
 		}
 
 		//
 		// A ref or out parameter is classified as a moveable variable, even 
 		// if the argument given for the parameter is a fixed variable
 		//		
 		public override bool IsFixed {
 			get { return !IsRef; }
 		}
 
 		public override string Name {
 			get { return Parameter.Name; }
 		}
 
 		public Parameter Parameter {
 			get { return pi.Parameter; }
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return pi.VariableInfo; }
 		}
 
 		protected override ILocalVariable Variable {
 			get { return Parameter; }
 		}
 
 		#endregion
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			// HACK
 			if (ec.IsInProbingMode)
 				return true;
 			
 			if (!ec.DoFlowAnalysis || !HasOutModifier || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			ec.Report.Error (269, loc, "Use of unassigned out parameter `{0}'", Name);
 			return false;
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			Parameter.HasAddressTaken = true;
 		}
 
 		void SetAssigned (ResolveContext ec)
 		{
 			if (HasOutModifier && ec.DoFlowAnalysis)
 				ec.CurrentBranching.SetAssigned (VariableInfo);
 		}
 
 		bool DoResolveBase (ResolveContext ec)
 		{
 			type = pi.ParameterType;
 			eclass = ExprClass.Variable;
 
 			//
 			// If we are referencing a parameter from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (pi)) {
 				if (Parameter.HasAddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (IsRef) {
 					ec.Report.Error (1628, loc,
 						"Parameter `{0}' cannot be used inside `{1}' when using `ref' or `out' modifier",
 						Name, ec.CurrentAnonymousMethod.ContainerType);
 				}
 
 				if (ec.IsVariableCapturingRequired && !pi.Block.ParametersBlock.IsExpressionTree) {
 					AnonymousMethodStorey storey = pi.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureParameter (ec, this);
 				}
 			}
 
 			return true;
 		}
 
 		public override int GetHashCode ()
 		{
 			return Name.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			ParameterReference pr = obj as ParameterReference;
 			if (pr == null)
 				return false;
 
 			return Name == pr.Name;
 		}
 
 		public override void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			//
 			// ParameterReferences might already be a reference
 			//
 			if (IsRef) {
 				EmitLoad (ec);
 				return;
 			}
 
 			base.AddressOf (ec, mode);
 		}
 		
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			// Nothing to clone
 			return;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			return Parameter.ExpressionTreeVariableReference ();
 		}
 
 		//
 		// Notice that for ref/out parameters, the type exposed is not the
 		// same type exposed externally.
 		//
 		// for "ref int a"
 		//   externally we expose "int&"
 		//   here we expose       "int".
 		//
 		// We record this in "is_ref".  This means that the type system can treat
 		// the type as it is expected, but when we generate the code, we generate
 		// the alternate kind of code.
 		//
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			// HACK
 			if (ec.IsInProbingMode)
 				return this;
 
 			if (HasOutModifier && ec.DoFlowAnalysis &&
 			    (!ec.OmitStructFlowAnalysis || !VariableInfo.TypeInfo.IsStruct) && !IsAssigned (ec, loc))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			SetAssigned (ec);
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		static public void EmitLdArg (EmitContext ec, int x)
 		{
 			switch (x) {
 			case 0
 			case 1
 			case 2
 			case 3
 			default
 				if (x > byte.MaxValue)
 					ec.Emit (OpCodes.Ldarg, x);
 				else
 					ec.Emit (OpCodes.Ldarg_S, (byte) x);
 				break;
 			}
 		}
 	}
 	
 	/// <summary>
 	///   Invocation of methods or delegates.
 	/// </summary>
 	public class Invocation 
 	{
 		protected Arguments arguments;
 		protected Expression expr;
 		protected MethodGroupExpr mg;
 		
 		public Invocation (Expression expr, Arguments arguments)
 		{
 			this.expr = expr;		
 			this.arguments = arguments;
 			if (expr != null)
 				loc = expr.Location;
 		}
 
 		#region Properties
 		public Arguments Arguments {
 			get {
 				return arguments;
 			}
 		}
 		
 		public Expression Expression {
 			get {
 				return expr;
 			}
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
 
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance = mg.IsInstance ?
 				mg.InstanceExpression.CreateExpressionTree (ec) 
 				new NullLiteral (loc);
 
 			var args = Arguments.CreateForExpressionTree (ec, arguments,
 				instance,
 				mg.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression member_expr;
 			var atn = expr as ATypeNameExpression;
 			if (atn != null) {
 				member_expr = atn.LookupNameExpression (ec, MemberLookupRestrictions.InvocableOnly | MemberLookupRestrictions.ReadAccess);
 				if (member_expr != null)
 					member_expr = member_expr.Resolve (ec);
 			} else {
 				member_expr = expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			}
 
 			if (member_expr == null)
 				return null;
 
 			//
 			// Next, evaluate all the expressions in the argument list
 			//
 			bool dynamic_arg = false;
 			if (arguments != null)
 				arguments.Resolve (ec, out dynamic_arg);
 
 			TypeSpec expr_type = member_expr.Type;
 			if (expr_type == InternalType.Dynamic)
 				return DoResolveDynamic (ec, member_expr);
 
 			mg = member_expr as MethodGroupExpr;
 			Expression invoke = null;
 
 			if (mg == null) {
 				if (expr_type != null && TypeManager.IsDelegateType (expr_type)) {
 					invoke = new DelegateInvocation (member_expr, arguments, loc);
 					invoke = invoke.Resolve (ec);
 					if (invoke == null || !dynamic_arg)
 						return invoke;
 				} else {
 					if (member_expr is RuntimeValueExpression) {
 						ec.Report.Error (Report.RuntimeErrorId, loc, "Cannot invoke a non-delegate type `{0}'",
 							member_expr.Type.GetSignatureForError ()); ;
 						return null;
 					}
 
 					MemberExpr me = member_expr as MemberExpr;
 					if (me == null) {
 						member_expr.Error_UnexpectedKind (ec, ResolveFlags.MethodGroup, loc);
 						return null;
 					}
 
 					ec.Report.Error (1955, loc, "The member `{0}' cannot be used as method or delegate",
 							member_expr.GetSignatureForError ());
 					return null;
 				}
 			}
 
 			if (invoke == null) {
 				mg = DoResolveOverload (ec);
 				if (mg == null)
 					return null;
 			}
 
 			if (dynamic_arg)
 				return DoResolveDynamic (ec, member_expr);
 
 			var method = mg.BestCandidate;
 			type = mg.BestCandidateReturnType;
 		
 			if (arguments == null && method.DeclaringType == TypeManager.object_type && method.Name == Destructor.MetadataName) {
 				if (mg.IsBase)
 					ec.Report.Error (250, loc, "Do not directly call your base class Finalize method. It is called automatically from your destructor");
 				else
 					ec.Report.Error (245, loc, "Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available");
 				return null;
 			}
 
 			IsSpecialMethodInvocation (ec, method, loc);
 			
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		protected virtual Expression DoResolveDynamic (ResolveContext ec, Expression memberExpr)
 		{
 			Arguments args;
 			DynamicMemberBinder dmb = memberExpr as DynamicMemberBinder;
 			if (dmb != null) {
 				args = dmb.Arguments;
 				if (arguments != null)
 					args.AddRange (arguments);
 			} else if (mg == null) {
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				args.Insert (0, new Argument (memberExpr));
 				this.expr = null;
 			} else {
 				if (mg.IsBase) {
 					ec.Report.Error (1971, loc,
 						"The base call to method `{0}' cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access",
 						mg.Name);
 					return null;
 				}
 
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				MemberAccess ma = expr as MemberAccess;
 				if (ma != null) {
 					var left_type = ma.LeftExpression as TypeExpr;
 					if (left_type != null) {
 						args.Insert (0, new Argument (new TypeOf (left_type, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						//
 						// Any value type has to be pass as by-ref to get back the same
 						// instance on which the member was called
 						//
 						var mod = TypeManager.IsValueType (ma.LeftExpression.Type) ? Argument.AType.Ref 
 						args.Insert (0, new Argument (ma.LeftExpression.Resolve (ec), mod));
 					}
 				} else {	// is SimpleName
 					if (ec.IsStatic) {
 						args.Insert (0, new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						args.Insert (0, new Argument (new This (loc).Resolve (ec)));
 					}
 				}
 			}
 
 			return new DynamicInvocation (expr as ATypeNameExpression, args, loc).Resolve (ec);
 		}
 
 		protected virtual MethodGroupExpr DoResolveOverload (ResolveContext ec)
 		{
 			return mg.OverloadResolve (ec, ref arguments, null, OverloadResolver.Restrictions.None);
 		}
 
 		static MetaType[] GetVarargsTypes (MethodSpec mb, Arguments arguments)
 		{
 			AParametersCollection pd = mb.Parameters;
 
 			Argument a = arguments[pd.Count - 1];
 			Arglist list = (Arglist) a.Expr;
 
 			return list.ArgumentTypes;
 		}
 
 		//
 		// If a member is a method or event, or if it is a constant, field or property of either a delegate type
 		// or the type dynamic, then the member is invocable
 		//
 		public static bool IsMemberInvocable (MemberSpec member)
 		{
 			switch (member.Kind) {
 			case MemberKind.Event
 				return true;
 			case MemberKind.Field
 			case MemberKind.Property
 				var m = member as IInterfaceMemberSpec;
 				return m.MemberType.IsDelegate || m.MemberType == InternalType.Dynamic;
 			default
 				return false;
 			}
 		}
 
 		public static bool IsSpecialMethodInvocation (ResolveContext ec, MethodSpec method, Location loc)
 		{
 			if (!method.IsReservedMethod)
 				return false;
 
 			if (ec.HasSet (ResolveContext.Options.InvokeSpecialName) || ec.CurrentMemberDefinition.IsCompilerGenerated)
 				return false;
 
 			ec.Report.SymbolRelatedToPreviousError (method);
 			ec.Report.Error (571, loc, "`{0}'
 				method.GetSignatureForError ());
 	
 			return true;
 		}
 
 		//
 		// Used to decide whether call or callvirt is needed
 		//
 		static bool IsVirtualCallRequired (Expression instance, MethodSpec method)
 		{
 			//
 			// There are 2 scenarious where we emit callvirt
 			//
 			// Case 1
 			// Case 2
 			// correct NRE exception when the method is called
 			//
 			var decl_type = method.DeclaringType;
 			if (decl_type.IsStruct || decl_type.IsEnum)
 				return false;
 
 			if (instance is BaseThis)
 				return false;
 
 			//
 			// It's non-virtual and will never be null
 			//
 			if (!method.IsVirtual && (instance is This || instance is New || instance is ArrayCreation || instance is DelegateCreation))
 				return false;
 
 			return true;
 		}
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
 		
 		// `dup_args' leaves an extra copy of the arguments on the stack
 		// `omit_args' does not leave any arguments at all.
 		// So, basically, you could make one call with `dup_args' set to true,
 		// and then another with `omit_args' set to true, and the two calls
 		// would have the same set of arguments. However, each argument would
 		// only have been evaluated once.
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc,
 		                             bool dup_args, bool omit_args)
 		{
 			LocalTemporary this_arg = null;
 
 			// Speed up the check by not doing it on not allowed targets
 			if (method.ReturnType == TypeManager.void_type && method.IsConditionallyExcluded (loc))
 				return;
 
 			OpCode call_op;
 			TypeSpec iexpr_type;
 
 			if (method.IsStatic) {
 				iexpr_type = null;
 				call_op = OpCodes.Call;
 			} else {
 				iexpr_type = instance_expr.Type;
 
 				if (IsVirtualCallRequired (instance_expr, method)) {
 					call_op = OpCodes.Callvirt;
 				} else {
 					call_op = OpCodes.Call;
 				}
 
 				//
 				// If this is ourselves, push "this"
 				//
 				if (!omit_args) {
 					TypeSpec t = iexpr_type;
 
 					//
 					// Push the instance expression
 					//
 					if ((iexpr_type.IsStruct && (call_op == OpCodes.Callvirt || (call_op == OpCodes.Call && method.DeclaringType == iexpr_type))) ||
 						iexpr_type.IsGenericParameter || TypeManager.IsNullableType (method.DeclaringType)) {
 						//
 						// If the expression implements IMemoryLocation, then
 						// we can optimize and use AddressOf on the
 						// return.
 						//
 						// If not we have to use some temporary storage for
 						// it.
 						var iml = instance_expr as IMemoryLocation;
 						if (iml != null) {
 							iml.AddressOf (ec, AddressOp.LoadStore);
 						} else {
 							LocalTemporary temp = new LocalTemporary (iexpr_type);
 							instance_expr.Emit (ec);
 							temp.Store (ec);
 							temp.AddressOf (ec, AddressOp.Load);
 						}
 
 						// avoid the overhead of doing this all the time.
 						if (dup_args)
 							t = ReferenceContainer.MakeType (iexpr_type);
 					} else if (iexpr_type.IsEnum || iexpr_type.IsStruct) {
 						instance_expr.Emit (ec);
 						ec.Emit (OpCodes.Box, iexpr_type);
 						t = iexpr_type = TypeManager.object_type;
 					} else {
 						instance_expr.Emit (ec);
 					}
 
 					if (dup_args) {
 						ec.Emit (OpCodes.Dup);
 						if (Arguments != null && Arguments.Count != 0) {
 							this_arg = new LocalTemporary (t);
 							this_arg.Store (ec);
 						}
 					}
 				}
 			}
 
 			if (!omit_args && Arguments != null) {
 				var dup_arg_exprs = Arguments.Emit (ec, dup_args);
 				if (dup_args) {
 					this_arg.Emit (ec);
 					LocalTemporary lt;
 					foreach (var dup in dup_arg_exprs) {
 						dup.Emit (ec);
 						lt = dup as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 			}
 
 			if (call_op == OpCodes.Callvirt && (iexpr_type.IsGenericParameter || iexpr_type.IsStruct)) {
 				ec.Emit (OpCodes.Constrained, iexpr_type);
 			}
 
 			if (method.Parameters.HasArglist) {
 				var varargs_types = GetVarargsTypes (method, Arguments);
 				ec.Emit (call_op, method, varargs_types);
 				return;
 			}
 
 			//
 			// If you have
 			// this.DoFoo ();
 			// and DoFoo is not virtual, you can omit the callvirt,
 			// because you don't need the null checking behavior.
 			//
 			ec.Emit (call_op, method);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			mg.EmitCall (ec, arguments);
 		}
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return MakeExpression (ctx, mg.InstanceExpression, mg.BestCandidate, arguments);
 		}
 
 		public static SLE.Expression MakeExpression (BuilderContext ctx, Expression instance, MethodSpec mi, Arguments args)
 		{
 #if STATIC
 			throw new NotSupportedException ();
 #else
 			var instance_expr = instance == null ? null 
 			return SLE.Expression.Call (instance_expr, (MethodInfo) mi.GetMetaInfo (), Arguments.MakeExpression (args, ctx));
 #endif
 		}
 	}
 
 	//
 	// Implements simple new expression 
 	//
 	public class New 
 	{
 		protected Arguments arguments;
 
 		//
 		// During bootstrap, it contains the RequestedType,
 		// but if `type' is not null, it *might* contain a NewDelegate
 		// (because of field multi-initialization)
 		//
 		protected Expression RequestedType;
 
 		protected MethodSpec method;
 
 		public New (Expression requested_type, Arguments arguments, Location l)
 		{
 			RequestedType = requested_type;
 			this.arguments = arguments;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="53" endline="702">
<![CDATA[
 		static object evaluator_lock = new object ();
 		
 		static string current_debug_name;
 		static int count;
 		static Thread invoke_thread;
 
 		static List<NamespaceEntry.UsingAliasEntry> using_alias_list = new List<NamespaceEntry.UsingAliasEntry> ();
 		internal static List<NamespaceEntry.UsingEntry> using_list = new List<NamespaceEntry.UsingEntry> ();
 		static Dictionary<string, Tuple<FieldSpec, FieldInfo>> fields = new Dictionary<string, Tuple<FieldSpec, FieldInfo>> ();
 
 		static TypeSpec interactive_base_class;
 		static Driver driver;
 		static bool inited;
 
 		static CompilerContext ctx;
 		static DynamicLoader loader;
 		
 		public static TextWriter MessageOutput = Console.Out;
 
 		/// <summary>
 		///   Optional initialization for the Evaluator.
 		/// </summary>
 		/// <remarks>
 		///  Initializes the Evaluator with the command line options
 		///  that would be processed by the command line compiler.  Only
 		///  the first call to Init will work, any future invocations are
 		///  ignored.
 		///
 		///  You can safely avoid calling this method if your application
 		///  does not need any of the features exposed by the command line
 		///  interface.
 		/// </remarks>
 		public static void Init (string [] args)
 		{
 			InitAndGetStartupFiles (args);
 		}
 
 		internal static ReportPrinter SetPrinter (ReportPrinter report_printer)
 		{
 			return ctx.Report.SetPrinter (report_printer);
 		}				
 
 		public static string [] InitAndGetStartupFiles (string [] args)
 		{
 			return InitAndGetStartupFiles (args, null);
 		}
 
 		/// <summary>
 		///   Optional initialization for the Evaluator.
 		/// </summary>
 		/// <remarks>
 		///  Initializes the Evaluator with the command line
 		///  options that would be processed by the command
 		///  line compiler.  Only the first call to
 		///  InitAndGetStartupFiles or Init will work, any future
 		///  invocations are ignored.
 		///
 		///  You can safely avoid calling this method if your application
 		///  does not need any of the features exposed by the command line
 		///  interface.
 		///
 		///  This method return an array of strings that contains any
 		///  files that were specified in `args'.
 		///
 		///  If the unknownOptionParser is not null, this function is invoked
 		///  with the current args array and the index of the option that is not
 		///  known.  A value of true means that the value was processed, otherwise
 		///  it will be reported as an error
 		/// </remarks>
 		public static string [] InitAndGetStartupFiles (string [] args, Func<string [], int, int> unknownOptionParser)
 		{
 			lock (evaluator_lock){
 				if (inited)
 					return new string [0];
 
 				CompilerCallableEntryPoint.Reset ();
 				var crp = new ConsoleReportPrinter ();
 				driver = Driver.Create (args, false, unknownOptionParser, crp);
 				if (driver == null)
 					throw new Exception ("Failed to create compiler driver with the given arguments");
 
 				crp.Fatal = driver.fatal_errors;
 				ctx = driver.ctx;
 
 				RootContext.ToplevelTypes = new ModuleContainer (ctx);
 				
 				var startup_files = new List<string> ();
 				foreach (CompilationUnit file in Location.SourceFiles)
 					startup_files.Add (file.Path);
 				
 				CompilerCallableEntryPoint.PartialReset ();
 
 				var importer = new ReflectionImporter (ctx.BuildinTypes);
 				loader = new DynamicLoader (importer, ctx);
 
 				RootContext.ToplevelTypes.SetDeclaringAssembly (new AssemblyDefinitionDynamic (RootContext.ToplevelTypes, "temp"));
 
 				loader.LoadReferences (RootContext.ToplevelTypes);
 				ctx.BuildinTypes.CheckDefinitions (RootContext.ToplevelTypes);
 				RootContext.ToplevelTypes.InitializePredefinedTypes ();
 
 				RootContext.EvalMode = true;
 				inited = true;
 
 				return startup_files.ToArray ();
 			}
 		}
 
 		static void Init ()
 		{
 			Init (new string [0]);
 		}
 		
 		static void Reset ()
 		{
 			CompilerCallableEntryPoint.PartialReset ();
 			
 			Location.AddFile (null, "{interactive}");
 			Location.Initialize ();
 
 			current_debug_name = "interactive" + (count++) + ".dll";
 		}
 
 		/// <summary>
 		///   The base class for the classes that host the user generated code
 		/// </summary>
 		/// <remarks>
 		///
 		///   This is the base class that will host the code
 		///   executed by the Evaluator.  By default
 		///   this is the Mono.CSharp.InteractiveBase class
 		///   which is useful for interactive use.
 		///
 		///   By changing this property you can control the
 		///   base class and the static members that are
 		///   available to your evaluated code.
 		/// </remarks>
 		static public TypeSpec InteractiveBaseClass {
 			get {
 				if (interactive_base_class != null)
 					return interactive_base_class;
 
 				return loader.Importer.ImportType (typeof (InteractiveBase));
 			}
 		}
 
 		public static void SetInteractiveBaseClass (Type type)
 		{
 			if (type == null)
 				throw new ArgumentNullException ();
 
 			if (!inited)
 				throw new Exception ("Evaluator has to be initiated before seting custom InteractiveBase class");
 
 			lock (evaluator_lock)
 				interactive_base_class = loader.Importer.ImportType (type);
 		}
 
 		/// <summary>
 		///   Interrupts the evaluation of an expression executing in Evaluate.
 		/// </summary>
 		/// <remarks>
 		///   Use this method to interrupt long-running invocations.
 		/// </remarks>
 		public static void Interrupt ()
 		{
 			if (!inited || !invoking)
 				return;
 			
 			if (invoke_thread != null)
 				invoke_thread.Abort ();
 		}
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   If the return value of this function is null,
 		///   this indicates that the parsing was complete.
 		///   If the return value is a string it indicates
 		///   that the input string was partial and that the
 		///   invoking code should provide more code before
 		///   the code can be successfully compiled.
 		///
 		///   If you know that you will always get full expressions or
 		///   statements and do not care about partial input, you can use
 		///   the other Compile overload. 
 		///
 		///   On success, in addition to returning null, the
 		///   compiled parameter will be set to the delegate
 		///   that can be invoked to execute the code.
 		///
 	        /// </remarks>
 		static public string Compile (string input, out CompiledMethod compiled)
 		{
 			if (input == null || input.Length == 0){
 				compiled = null;
 				return null;
 			}
 
 			lock (evaluator_lock){
 				if (!inited)
 					Init ();
 				else
 					ctx.Report.Printer.Reset ();
 
 			//	RootContext.ToplevelTypes = new ModuleContainer (ctx);
 
 				bool partial_input;
 				CSharpParser parser = ParseString (ParseMode.Silent, input, out partial_input);
 				if (parser == null){
 					compiled = null;
 					if (partial_input)
 						return input;
 					
 					ParseString (ParseMode.ReportErrors, input, out partial_input);
 					return null;
 				}
 				
 				object parser_result = parser.InteractiveResult;
 				
 				if (!(parser_result is Class)){
 					int errors = ctx.Report.Errors;
 
 					NamespaceEntry.VerifyAllUsing ();
 					if (errors == ctx.Report.Errors)
 						parser.CurrentNamespace.Extract (using_alias_list, using_list);
 					else
 						NamespaceEntry.Reset ();
 				}
 
 #if STATIC
 				throw new NotSupportedException ();
 #else
 				compiled = CompileBlock (parser_result as Class, parser.undo, ctx.Report);
 				return null;
 #endif
 			}
 		}
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   This method can only deal with fully formed input
 		///   strings and does not provide a completion mechanism.
 		///   If you must deal with partial input (for example for
 		///   interactive use) use the other overload. 
 		///
 		///   On success, a delegate is returned that can be used
 		///   to invoke the method.
 		///
 	        /// </remarks>
 		static public CompiledMethod Compile (string input)
 		{
 			CompiledMethod compiled;
 
 			// Ignore partial inputs
 			if (Compile (input, out compiled) != null){
 				// Error, the input was partial.
 				return null;
 			}
 
 			// Either null (on error) or the compiled method.
 			return compiled;
 		}
 
 		//
 		// Todo
 		// the recording themselves?
 		//
 
 		/// <summary>
 		///   Evaluates and expression or statement and returns any result values.
 		/// </summary>
 		/// <remarks>
 		///   Evaluates the input string as a C# expression or
 		///   statement.  If the input string is an expression
 		///   the result will be stored in the result variable
 		///   and the result_set variable will be set to true.
 		///
 		///   It is necessary to use the result/result_set
 		///   pair to identify when a result was set (for
 		///   example, execution of user-provided input can be
 		///   an expression, a statement or others, and
 		///   result_set would only be set if the input was an
 		///   expression.
 		///
 		///   If the return value of this function is null,
 		///   this indicates that the parsing was complete.
 		///   If the return value is a string, it indicates
 		///   that the input is partial and that the user
 		///   should provide an updated string.
 		/// </remarks>
 		public static string Evaluate (string input, out object result, out bool result_set)
 		{
 			CompiledMethod compiled;
 
 			result_set = false;
 			result = null;
 
 			input = Compile (input, out compiled);
 			if (input != null)
 				return input;
 			
 			if (compiled == null)
 				return null;
 				
 			//
 			// The code execution does not need to keep the compiler lock
 			//
 			object retval = typeof (NoValueSet);
 
 			try {
 				invoke_thread = System.Threading.Thread.CurrentThread;
 				invoking = true;
 				compiled (ref retval);
 			} catch (ThreadAbortException e){
 				Thread.ResetAbort ();
 				Console.WriteLine ("Interrupted!\n{0}", e);
 			} finally {
 				invoking = false;
 			}
 
 			//
 			// We use a reference to a compiler type, in this case
 			// Driver as a flag to indicate that this was a statement
 			//
 			if (retval != typeof (NoValueSet)){
 				result_set = true;
 				result = retval; 
 			}
 
 			return null;
 		}
 
 		public static string [] GetCompletions (string input, out string prefix)
 		{
 			prefix = "";
 			if (input == null || input.Length == 0)
 				return null;
 			
 			lock (evaluator_lock){
 				if (!inited)
 					Init ();
 				
 				bool partial_input;
 				CSharpParser parser = ParseString (ParseMode.GetCompletions, input, out partial_input);
 				if (parser == null){
 					if (CSharpParser.yacc_verbose_flag != 0)
 						Console.WriteLine ("DEBUG
 					return null;
 				}
 				
 				Class parser_result = parser.InteractiveResult as Class;
 				
 				if (parser_result == null){
 					if (CSharpParser.yacc_verbose_flag != 0)
 						Console.WriteLine ("Do not know how to cope with !Class yet");
 					return null;
 				}
 
 				try {
 					var a = new AssemblyDefinitionDynamic (RootContext.ToplevelTypes, "temp");
 					a.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Run);
 					RootContext.ToplevelTypes.SetDeclaringAssembly (a);
 					RootContext.ToplevelTypes.Define ();
 					if (ctx.Report.Errors != 0)
 						return null;
 					
 					MethodOrOperator method = null;
 					foreach (MemberCore member in parser_result.Methods){
 						if (member.Name != "Host")
 							continue;
 						
 						method = (MethodOrOperator) member;
 						break;
 					}
 					if (method == null)
 						throw new InternalErrorException ("did not find the the Host method");
 
 					BlockContext bc = new BlockContext (method, method.Block, method.ReturnType);
 
 					try {
 						method.Block.Resolve (null, bc, method);
 					} catch (CompletionResult cr){
 						prefix = cr.BaseText;
 						return cr.Result;
 					} 
 				} finally {
 					parser.undo.ExecuteUndo ();
 				}
 				
 			}
 			return null;
 		}
 
 		/// <summary>
 		///   Executes the given expression or statement.
 		/// </summary>
 		/// <remarks>
 		///    Executes the provided statement, returns true
 		///    on success, false on parsing errors.  Exceptions
 		///    might be thrown by the called code.
 		/// </remarks>
 		public static bool Run (string statement)
 		{
 			if (!inited)
 				Init ();
 
 			object result;
 			bool result_set;
 
 			bool ok = Evaluate (statement, out result, out result_set) == null;
 			
 			return ok;
 		}
 
 		/// <summary>
 		///   Evaluates and expression or statement and returns the result.
 		/// </summary>
 		/// <remarks>
 		///   Evaluates the input string as a C# expression or
 		///   statement and returns the value.   
 		///
 		///   This method will throw an exception if there is a syntax error,
 		///   of if the provided input is not an expression but a statement.
 		/// </remarks>
 		public static object Evaluate (string input)
 		{
 			object result;
 			bool result_set;
 			
 			string r = Evaluate (input, out result, out result_set);
 
 			if (r != null)
 				throw new ArgumentException ("Syntax error on input
 			
 			if (result_set == false)
 				throw new ArgumentException ("The expression did not set a result");
 
 			return result;
 		}
 
 		enum InputKind {
 			EOF,
 			StatementOrExpression,
 			CompilationUnit,
 			Error
 		}
 
 		//
 		// Deambiguates the input string to determine if we
 		// want to process a statement or if we want to
 		// process a compilation unit.
 		//
 		// This is done using a top-down predictive parser,
 		// since the yacc/jay parser can not deambiguage this
 		// without more than one lookahead token.   There are very
 		// few ambiguities.
 		//
 		static InputKind ToplevelOrStatement (SeekableStreamReader seekable)
 		{
 			Tokenizer tokenizer = new Tokenizer (seekable, (CompilationUnit) Location.SourceFiles [0], ctx);
 			
 			int t = tokenizer.token ();
 			switch (t){
 			case Token.EOF
 				return InputKind.EOF;
 				
 			// These are toplevels
 			case Token.EXTERN
 			case Token.OPEN_BRACKET
 			case Token.ABSTRACT
 			case Token.CLASS
 			case Token.ENUM
 			case Token.INTERFACE
 			case Token.INTERNAL
 			case Token.NAMESPACE
 			case Token.PRIVATE
 			case Token.PROTECTED
 			case Token.PUBLIC
 			case Token.SEALED
 			case Token.STATIC
 			case Token.STRUCT
 				return InputKind.CompilationUnit;
 				
 			// Definitely expression
 			case Token.FIXED
 			case Token.BOOL
 			case Token.BYTE
 			case Token.CHAR
 			case Token.DECIMAL
 			case Token.DOUBLE
 			case Token.FLOAT
 			case Token.INT
 			case Token.LONG
 			case Token.NEW
 			case Token.OBJECT
 			case Token.SBYTE
 			case Token.SHORT
 			case Token.STRING
 			case Token.UINT
 			case Token.ULONG
 				return InputKind.StatementOrExpression;
 
 			// These need deambiguation help
 			case Token.USING
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 
 				if (t == Token.IDENTIFIER)
 					return InputKind.CompilationUnit;
 				return InputKind.StatementOrExpression;
 
 
 			// Distinguish between
 			//    delegate opt_anonymous_method_signature block
 			//    delegate type 
 			case Token.DELEGATE
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 				if (t == Token.OPEN_PARENS || t == Token.OPEN_BRACE)
 					return InputKind.StatementOrExpression;
 				return InputKind.CompilationUnit;
 
 			// Distinguih between
 			//    unsafe block
 			//    unsafe as modifier of a type declaration
 			case Token.UNSAFE
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 				if (t == Token.OPEN_PARENS)
 					return InputKind.StatementOrExpression;
 				return InputKind.CompilationUnit;
 				
 		        // These are errors
 			// from the grammar, ERROR and then everything else
 
 			case Token.READONLY
 			case Token.OVERRIDE
 			case Token.ERROR
 				return InputKind.Error;
 
 			// This catches everything else allowed by
 			// expressions.  We could add one-by-one use cases
 			// if needed.
 			default
 				return InputKind.StatementOrExpression;
 			}
 		}
 		
 		//
 		// Parses the string @input and returns a CSharpParser if succeeful.
 		//
 		// if @silent is set to true then no errors are
 		// reported to the user.  This is used to do various calls to the
 		// parser and check if the expression is parsable.
 		//
 		// @partial_input
 		// parsed expression was partial, and more data is needed
 		//
 		static CSharpParser ParseString (ParseMode mode, string input, out bool partial_input)
 		{
 			partial_input = false;
 			Reset ();
 			queued_fields.Clear ();
 			Tokenizer.LocatedToken.Initialize ();
 
 			Stream s = new MemoryStream (Encoding.Default.GetBytes (input));
 			SeekableStreamReader seekable = new SeekableStreamReader (s, Encoding.Default);
 
 			InputKind kind = ToplevelOrStatement (seekable);
 			if (kind == InputKind.Error){
 				if (mode == ParseMode.ReportErrors)
 					ctx.Report.Error (-25, "Detection Parsing Error");
 				partial_input = false;
 				return null;
 			}
 
 			if (kind == InputKind.EOF){
 				if (mode == ParseMode.ReportErrors)
 					Console.Error.WriteLine ("Internal error
 				partial_input = true;
 				return null;
 				
 			}
 			seekable.Position = 0;
 
 			CSharpParser parser = new CSharpParser (seekable, Location.SourceFiles [0], RootContext.ToplevelTypes);
 
 			if (kind == InputKind.StatementOrExpression){
 				parser.Lexer.putback_char = Tokenizer.EvalStatementParserCharacter;
 				RootContext.StatementMode = true;
 			} else {
 				//
 				// Do not activate EvalCompilationUnitParserCharacter until
 				// I have figured out all the limitations to invoke methods
 				// in the generated classes.  See repl.txt
 				//
 				parser.Lexer.putback_char = Tokenizer.EvalUsingDeclarationsParserCharacter;
 				//parser.Lexer.putback_char = Tokenizer.EvalCompilationUnitParserCharacter;
 				RootContext.StatementMode = false;
 			}
 
 			if (mode == ParseMode.GetCompletions)
 				parser.Lexer.CompleteOnEOF = true;
 
 			ReportPrinter old_printer = null;
 			if ((mode == ParseMode.Silent || mode == ParseMode.GetCompletions) && CSharpParser.yacc_verbose_flag == 0)
 				old_printer = SetPrinter (new StreamReportPrinter (TextWriter.Null));
 
 			try {
 				parser.parse ();
 			} finally {
 				if (ctx.Report.Errors != 0){
 					if (mode != ParseMode.ReportErrors  && parser.UnexpectedEOF)
 						partial_input = true;
 
 					parser.undo.ExecuteUndo ();
 					parser = null;
 				}
 
 				if (old_printer != null)
 					SetPrinter (old_printer);
 			}
 			return parser;
 		}
 
 		//
 		// Queue all the fields that we use, as we need to then go from FieldBuilder to FieldInfo
 		// or reflection gets confused (it basically gets confused, and variables override each
 		// other).
 		//
 		static List<Field> queued_fields = new List<Field> ();
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1991" endline="2108">
<![CDATA[
 
 		bool CheckConstraint (MemberSpec context, TypeSpec atype, TypeParameterSpec tparam, Location loc)
 		{
 			//
 			// First, check the `class' and `struct' constraints.
 			//
 			if (tparam.HasSpecialClass && !TypeManager.IsReferenceType (atype)) {
 				if (mc != null) {
 					mc.Compiler.Report.Error (452, loc,
 						"The type `{0}' must be a reference type in order to use it as type parameter `{1}' in the generic type or method `{2}'",
 						TypeManager.CSharpName (atype), tparam.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			if (tparam.HasSpecialStruct && (!TypeManager.IsValueType (atype) || TypeManager.IsNullableType (atype))) {
 				if (mc != null) {
 					mc.Compiler.Report.Error (453, loc,
 						"The type `{0}' must be a non-nullable value type in order to use it as type parameter `{1}' in the generic type or method `{2}'",
 						TypeManager.CSharpName (atype), tparam.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			bool ok = true;
 
 			//
 			// Check the class constraint
 			//
 			if (tparam.HasTypeConstraint) {
 				var dep = tparam.BaseType.GetMissingDependencies ();
 				if (dep != null) {
 					if (mc == null)
 						return false;
 
 					ImportedTypeDefinition.Error_MissingDependency (mc, dep, loc);
 					ok = false;
 				}
 
 				if (!CheckConversion (mc, context, atype, tparam, tparam.BaseType, loc)) {
 					if (mc == null)
 						return false;
 
 					ok = false;
 				}
 			}
 
 			//
 			// Check the interfaces constraints
 			//
 			if (tparam.Interfaces != null) {
 				if (TypeManager.IsNullableType (atype)) {
 					if (mc == null)
 						return false;
 
 					mc.Compiler.Report.Error (313, loc,
 						"The type `{0}' cannot be used as type parameter `{1}' in the generic type or method `{2}'. The nullable type `{0}' never satisfies interface constraint",
 						atype.GetSignatureForError (), tparam.GetSignatureForError (), context.GetSignatureForError ());
 					ok = false;
 				} else {
 					foreach (TypeSpec iface in tparam.Interfaces) {
 						var dep = iface.GetMissingDependencies ();
 						if (dep != null) {
 							if (mc == null)
 								return false;
 
 							ImportedTypeDefinition.Error_MissingDependency (mc, dep, loc);
 							ok = false;
 
 							// return immediately to avoid duplicate errors because we are scanning
 							// expanded interface list
 							return false;
 						}
 
 						if (!CheckConversion (mc, context, atype, tparam, iface, loc)) {
 							if (mc == null)
 								return false;
 
 							ok = false;
 						}
 					}
 					foreach (TypeSpec iface in tparam.Interfaces) {
 						var dep = iface.GetMissingDependencies ();
 						if (dep != null) {
 							if (mc == null)
 								return false;
 
 							ImportedTypeDefinition.Error_MissingDependency (mc, dep, loc);
 							ok = false;
 
 							// return immediately to avoid duplicate errors because we are scanning
 							// expanded interface list
 							return false;
 						}
 
 						if (!CheckConversion (mc, context, atype, tparam, iface, loc)) {
 							if (mc == null)
 								return false;
 
 							ok = false;
 						}
 					}
 				}
 			}
 
 			//
 			// Check the type parameter constraint
 			//
 			if (tparam.TypeArguments != null) {
 				foreach (var ta in tparam.TypeArguments) {
 					if (!CheckConversion (mc, context, atype, tparam, ta, loc)) {
 						if (mc == null)
 							return false;
 
 						ok = false;
 					}
 				}
 				foreach (var ta in tparam.TypeArguments) {
 					if (!CheckConversion (mc, context, atype, tparam, ta, loc)) {
 						if (mc == null)
 							return false;
 
 						ok = false;
 					}
 				}
 			}
 
 			//
 			// Finally, check the constructor constraint.
 			//
 			if (!tparam.HasSpecialConstructor)
 				return ok;
 
 			if (!HasDefaultConstructor (atype)) {
 				if (mc != null) {
 					mc.Compiler.Report.SymbolRelatedToPreviousError (atype);
 					mc.Compiler.Report.Error (310, loc,
 						"The type `{0}' must have a public parameterless constructor in order to use it as parameter `{1}' in the generic type or method `{2}'",
 						TypeManager.CSharpName (atype), tparam.GetSignatureForError (), context.GetSignatureForError ());
 				}
 				return false;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1050" endline="1205">
<![CDATA[
 
 		//
 		// User-defined conversions
 		//
 		static Expression UserDefinedConversion (ResolveContext ec, Expression source, TypeSpec target, bool implicitOnly, Location loc)
 		{
 			List<MethodSpec> candidates = null;
 
 			//
 			// If S or T are nullable types, source_type and target_type are their underlying types
 			// otherwise source_type and target_type are equal to S and T respectively.
 			//
 			TypeSpec source_type = source.Type;
 			TypeSpec target_type = target;
 			Expression source_type_expr;
 
 			if (TypeManager.IsNullableType (source_type)) {
 				// No implicit conversion S? -> T for non-reference types
 				if (implicitOnly && !TypeManager.IsReferenceType (target_type) && !TypeManager.IsNullableType (target_type))
 					return null;
 
 				source_type_expr = Nullable.Unwrap.Create (source);
 				source_type = source_type_expr.Type;
 			} else {
 				source_type_expr = source;
 			}
 
 			if (TypeManager.IsNullableType (target_type))
 				target_type = Nullable.NullableInfo.GetUnderlyingType (target_type);
 
 			// Only these containers can contain a user defined implicit or explicit operators
 			const MemberKind user_conversion_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.TypeParameter;
 
 			if ((source_type.Kind & user_conversion_kinds) != 0 && source_type != TypeManager.decimal_type) {
 				bool declared_only = source_type.IsStruct;
 
 				var operators = MemberCache.GetUserOperator (source_type, Operator.OpType.Implicit, declared_only);
 				if (operators != null) {
 					FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, implicitOnly, ref candidates);
 				}
 
 				if (!implicitOnly) {
 					operators = MemberCache.GetUserOperator (source_type, Operator.OpType.Explicit, declared_only);
 					if (operators != null) {
 						FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, false, ref candidates);
 					}
 				}
 			}
 
 			if ((target.Kind & user_conversion_kinds) != 0 && target_type != TypeManager.decimal_type) {
 				bool declared_only = target.IsStruct || implicitOnly;
 
 				var operators = MemberCache.GetUserOperator (target_type, Operator.OpType.Implicit, declared_only);
 				if (operators != null) {
 					FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, implicitOnly, ref candidates);
 				}
 
 				if (!implicitOnly) {
 					operators = MemberCache.GetUserOperator (target_type, Operator.OpType.Explicit, declared_only);
 					if (operators != null) {
 						FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, false, ref candidates);
 					}
 				}
 			}
 
 			if (candidates == null)
 				return null;
 
 			//
 			// Find the most specific conversion operator
 			//
 			MethodSpec most_specific_operator;
 			TypeSpec s_x, t_x;
 			if (candidates.Count == 1) {
 				most_specific_operator = candidates[0];
 				s_x = most_specific_operator.Parameters.Types[0];
 				t_x = most_specific_operator.ReturnType;
 			} else {
 				//
 				// Pass original source type to find the best match against input type and
 				// not the unwrapped expression
 				//
 				s_x = FindMostSpecificSource (candidates, source.Type, source_type_expr, !implicitOnly);
 				if (s_x == null)
 					return null;
 
 				t_x = FindMostSpecificTarget (candidates, target, !implicitOnly);
 				if (t_x == null)
 					return null;
 
 				most_specific_operator = null;
 				for (int i = 0; i < candidates.Count; ++i) {
 					if (candidates[i].ReturnType == t_x && candidates[i].Parameters.Types[0] == s_x) {
 						most_specific_operator = candidates[i];
 						break;
 					}
 				}
 				for (int i = 0; i < candidates.Count; ++i) {
 					if (candidates[i].ReturnType == t_x && candidates[i].Parameters.Types[0] == s_x) {
 						most_specific_operator = candidates[i];
 						break;
 					}
 				}
 
 				if (most_specific_operator == null) {
 					MethodSpec ambig_arg = null;
 					foreach (var candidate in candidates) {
 						if (candidate.ReturnType == t_x)
 							most_specific_operator = candidate;
 						else if (candidate.Parameters.Types[0] == s_x)
 							ambig_arg = candidate;
 					}
 					foreach (var candidate in candidates) {
 						if (candidate.ReturnType == t_x)
 							most_specific_operator = candidate;
 						else if (candidate.Parameters.Types[0] == s_x)
 							ambig_arg = candidate;
 					}
 
 					ec.Report.Error (457, loc,
 						"Ambiguous user defined operators `{0}' and `{1}' when converting from `{2}' to `{3}'",
 						ambig_arg.GetSignatureForError (), most_specific_operator.GetSignatureForError (),
 						source.Type.GetSignatureForError (), target.GetSignatureForError ());
 				}
 			}
 
 			//
 			// Convert input type when it's different to best operator argument
 			//
 			if (s_x != source_type)
 				source = implicitOnly ?
 					ImplicitConversionStandard (ec, source_type_expr, s_x, loc) 
 					ExplicitConversionStandard (ec, source_type_expr, s_x, loc);
 			else {
 				source = source_type_expr;
 			}
 
 			source = new UserCast (most_specific_operator, source, loc).Resolve (ec);
 
 			//
 			// Convert result type when it's different to best operator return type
 			//
 			if (t_x != target_type) {
 				//
 				// User operator is of T?, no need to lift it
 				//
 				if (TypeManager.IsNullableType (t_x) && t_x == target)
 					return source;
 
 				source = implicitOnly ?
 					ImplicitConversionStandard (ec, source, target_type, loc) 
 					ExplicitConversionStandard (ec, source, target_type, loc);
 
 				if (source == null)
 					return null;
 			}
 
 			//
 			// Source expression is of nullable type, lift the result in the case it's null and
 			// not nullable/lifted user operator is used
 			//
 			if (source_type_expr is Nullable.Unwrap && !TypeManager.IsNullableType (s_x) && (TypeManager.IsReferenceType (target) || target_type != target))
 				source = new Nullable.Lifted (source, source_type_expr, target).Resolve (ec);
 			else if (target_type != target)
 				source = Nullable.Wrap.Create (source, target);
 
 			return source;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2997" endline="3191">
<![CDATA[
 
 		//
 		// Enumeration operators
 		//
 		Expression ResolveOperatorEnum (ResolveContext ec, bool lenum, bool renum, TypeSpec ltype, TypeSpec rtype)
 		{
 			//
 			// bool operator == (E x, E y);
 			// bool operator != (E x, E y);
 			// bool operator < (E x, E y);
 			// bool operator > (E x, E y);
 			// bool operator <= (E x, E y);
 			// bool operator >= (E x, E y);
 			//
 			// E operator & (E x, E y);
 			// E operator | (E x, E y);
 			// E operator ^ (E x, E y);
 			//
 			// U operator - (E e, E f)
 			// E operator - (E e, U x)
 			// E operator - (U x, E e)	// LAMESPEC
 			//
 			// E operator + (E e, U x)
 			// E operator + (U x, E e)
 			//
 			Expression ltemp = left;
 			Expression rtemp = right;
 			TypeSpec underlying_type;
 			TypeSpec underlying_type_result;
 			TypeSpec res_type;
 			Expression expr;
 			
 			//
 			// LAMESPEC
 			// the one which contains more enum parameters always wins even if there
 			// is an implicit conversion involved
 			//
 			if ((oper & (Operator.ComparisonMask | Operator.BitwiseMask)) != 0) {
 				if (renum) {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					expr = Convert.ImplicitConversion (ec, left, rtype, loc);
 					if (expr == null)
 						return null;
 
 					left = expr;
 					ltype = expr.Type;
 				} else if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					expr = Convert.ImplicitConversion (ec, right, ltype, loc);
 					if (expr == null)
 						return null;
 
 					right = expr;
 					rtype = expr.Type;
 				} else {
 					return null;
 				}
 
 				if ((oper & Operator.BitwiseMask) != 0) {
 					res_type = ltype;
 					underlying_type_result = underlying_type;
 				} else {
 					res_type = null;
 					underlying_type_result = null;
 				}
 			} else if (oper == Operator.Subtraction) {
 				if (renum) {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					if (ltype != rtype) {
 						expr = Convert.ImplicitConversion (ec, left, rtype, left.Location);
 						if (expr == null) {
 							expr = Convert.ImplicitConversion (ec, left, underlying_type, left.Location);
 							if (expr == null)
 								return null;
 
 							res_type = rtype;
 						} else {
 							res_type = underlying_type;
 						}
 
 						left = expr;
 					} else {
 						res_type = underlying_type;
 					}
 
 					underlying_type_result = underlying_type;
 				} else if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					expr = Convert.ImplicitConversion (ec, right, ltype, right.Location);
 					if (expr == null || expr is EnumConstant) {
 						expr = Convert.ImplicitConversion (ec, right, underlying_type, right.Location);
 						if (expr == null)
 							return null;
 
 						res_type = ltype;
 					} else {
 						res_type = underlying_type;
 					}
 
 					right = expr;
 					underlying_type_result = underlying_type;
 				} else {
 					return null;
 				}
 			} else if (oper == Operator.Addition) {
 				if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					res_type = ltype;
 
 					if (rtype != underlying_type && (state & (State.RightNullLifted | State.LeftNullLifted)) == 0) {
 						expr = Convert.ImplicitConversion (ec, right, underlying_type, right.Location);
 						if (expr == null)
 							return null;
 
 						right = expr;
 					}
 				} else {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					res_type = rtype;
 					if (ltype != underlying_type) {
 						expr = Convert.ImplicitConversion (ec, left, underlying_type, left.Location);
 						if (expr == null)
 							return null;
 
 						left = expr;
 					}
 				}
 
 				underlying_type_result = underlying_type;
 			} else {
 				return null;
 			}
 
 			// Unwrap the constant correctly, so DoBinaryOperatorPromotion can do the magic
 			// with constants and expressions
 			if (left.Type != underlying_type) {
 				if (left is Constant)
 					left = ((Constant) left).ConvertExplicitly (false, underlying_type).Resolve (ec);
 				else
 					left = EmptyCast.Create (left, underlying_type);
 			}
 
 			if (right.Type != underlying_type) {
 				if (right is Constant)
 					right = ((Constant) right).ConvertExplicitly (false, underlying_type).Resolve (ec);
 				else
 					right = EmptyCast.Create (right, underlying_type);
 			}
 
 			//
 			// C# specification uses explicit cast syntax which means binary promotion
 			// should happen, however it seems that csc does not do that
 			//
 			if (!DoBinaryOperatorPromotion (ec)) {
 				left = ltemp;
 				right = rtemp;
 				return null;
 			}
 
 			if (underlying_type_result != null && left.Type != underlying_type_result) {
 				enum_conversion = Convert.ExplicitNumericConversion (new EmptyExpression (left.Type), underlying_type_result);
 			}
 
 			expr = ResolveOperatorPredefined (ec, standard_operators, true, res_type);
 			if (expr == null)
 				return null;
 
 			if (!IsCompound)
 				return expr;
 
 			//
 			// Section
 			//
 
 			//
 			// If the return type of the selected operator is implicitly convertible to the type of x
 			//
 			if (Convert.ImplicitConversionExists (ec, expr, ltype))
 				return expr;
 
 			//
 			// Otherwise, if the selected operator is a predefined operator, if the return type of the
 			// selected operator is explicitly convertible to the type of x, and if y is implicitly
 			// convertible to the type of x or the operator is a shift operator, then the operation
 			// is evaluated as x = (T)(x op y), where T is the type of x
 			//
 			expr = Convert.ExplicitConversion (ec, expr, ltype, loc);
 			if (expr == null)
 				return null;
 
 			if (Convert.ImplicitConversionExists (ec, ltemp, ltype))
 				return expr;
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="187" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="398" endline="520">
<![CDATA[
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodBuilder method;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(MethodBuilder method, int parameter)
 			{
 				this.method = method;
 				this.parameter = parameter;
 			}
 
 			private ParameterBuilder ParameterBuilder
 			{
 				get
 				{
 					if (method.parameters != null)
 					{
 						foreach (ParameterBuilder pb in method.parameters)
 						{
 							if (pb.Position == parameter)
 							{
 								return pb;
 							}
 						}
 					}
 					return null;
 				}
 			}
 
 			public override string Name
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.Name 
 				}
 			}
 
 			public override Type ParameterType
 			{
 				get { return parameter == -1 ? method.returnType 
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? (ParameterAttributes)pb.Attributes 
 				}
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.HasDefault) != 0)
 					{
 						return method.ModuleBuilder.Constant.GetRawConstantValue(method.ModuleBuilder, pb.PseudoToken);
 					}
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.Optional) != 0)
 					{
 						return Missing.Value;
 					}
 					return null;
 				}
 			}
 
 			private Type[] GetCustomModifiers(int optOrReq)
 			{
 				if (method.modifiers == null || method.modifiers[parameter + 1] == null)
 				{
 					return Type.EmptyTypes;
 				}
 				return Util.Copy(method.modifiers[parameter + 1][optOrReq]);
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return GetCustomModifiers(0);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return GetCustomModifiers(1);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method; }
 			}
 
 			public override int MetadataToken
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.PseudoToken 
 				}
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[parameterTypes.Length];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="260" endline="402">
<![CDATA[
 
 		public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
 		{
 			ModuleBuilder manifestModule = null;
 
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.PopulatePropertyAndEventTables();
 
 				if (manifestModule == null
 					&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
 				{
 					manifestModule = moduleBuilder;
 				}
 			}
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.PopulatePropertyAndEventTables();
 
 				if (manifestModule == null
 					&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
 				{
 					manifestModule = moduleBuilder;
 				}
 			}
 
 			if (manifestModule == null)
 			{
 				manifestModule = DefineDynamicModule("RefEmit_OnDiskManifestModule", assemblyFileName, false);
 			}
 
 			AssemblyTable.Record assemblyRecord = new AssemblyTable.Record();
 			assemblyRecord.HashAlgId = (int)hashAlgorithm;
 			assemblyRecord.Name = manifestModule.Strings.Add(name);
 			assemblyRecord.MajorVersion = majorVersion;
 			assemblyRecord.MinorVersion = minorVersion;
 			assemblyRecord.BuildNumber = buildVersion;
 			assemblyRecord.RevisionNumber = revisionVersion;
 			if (publicKey != null)
 			{
 				assemblyRecord.PublicKey = manifestModule.Blobs.Add(ByteBuffer.Wrap(publicKey));
 				assemblyRecord.Flags = (int)(flags | AssemblyNameFlags.PublicKey);
 			}
 			else
 			{
 				assemblyRecord.Flags = (int)(flags & ~AssemblyNameFlags.PublicKey);
 			}
 			if (culture != null)
 			{
 				assemblyRecord.Culture = manifestModule.Strings.Add(culture);
 			}
 			int token = 0x20000000 + manifestModule.AssemblyTable.AddRecord(assemblyRecord);
 
 #pragma warning disable 618
 			// this values are obsolete, but we already know that so we disable the warning
 			System.Security.Permissions.SecurityAction requestMinimum = System.Security.Permissions.SecurityAction.RequestMinimum;
 			System.Security.Permissions.SecurityAction requestOptional = System.Security.Permissions.SecurityAction.RequestOptional;
 			System.Security.Permissions.SecurityAction requestRefuse = System.Security.Permissions.SecurityAction.RequestRefuse;
 #pragma warning restore 618
 			if (requiredPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestMinimum, requiredPermissions);
 			}
 			if (optionalPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestOptional, optionalPermissions);
 			}
 			if (refusedPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestRefuse, refusedPermissions);
 			}
 
 			if (versionInfo != null)
 			{
 				versionInfo.SetName(GetName());
 				versionInfo.SetFileName(assemblyFileName);
 				foreach (CustomAttributeBuilder cab in customAttributes)
 				{
 					// .NET doesn't support copying blob custom attributes into the version info
 					if (!cab.HasBlob)
 					{
 						versionInfo.SetAttribute(cab);
 					}
 				}
 				foreach (CustomAttributeBuilder cab in customAttributes)
 				{
 					// .NET doesn't support copying blob custom attributes into the version info
 					if (!cab.HasBlob)
 					{
 						versionInfo.SetAttribute(cab);
 					}
 				}
 				ByteBuffer versionInfoData = new ByteBuffer(512);
 				versionInfo.Write(versionInfoData);
 				if (unmanagedResources == null)
 				{
 					unmanagedResources = new ResourceSection();
 				}
 				unmanagedResources.AddVersionInfo(versionInfoData);
 			}
 
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				// we intentionally don't filter out the version info (pseudo) custom attributes (to be compatible with .NET)
 				manifestModule.SetCustomAttribute(0x20000001, cab);
 			}
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				// we intentionally don't filter out the version info (pseudo) custom attributes (to be compatible with .NET)
 				manifestModule.SetCustomAttribute(0x20000001, cab);
 			}
 
 			manifestModule.AddDeclarativeSecurity(0x20000001, declarativeSecurity);
 
 			foreach (Type type in typeForwarders)
 			{
 				manifestModule.AddTypeForwarder(type);
 			}
 			foreach (Type type in typeForwarders)
 			{
 				manifestModule.AddTypeForwarder(type);
 			}
 
 			foreach (ResourceFile resfile in resourceFiles)
 			{
 				int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
 				ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 				rec.Offset = 0;
 				rec.Flags = (int)resfile.Attributes;
 				rec.Name = manifestModule.Strings.Add(resfile.Name);
 				rec.Implementation = fileToken;
 				manifestModule.ManifestResource.AddRecord(rec);
 			}
 			foreach (ResourceFile resfile in resourceFiles)
 			{
 				int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
 				ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 				rec.Offset = 0;
 				rec.Flags = (int)resfile.Attributes;
 				rec.Name = manifestModule.Strings.Add(resfile.Name);
 				rec.Implementation = fileToken;
 				manifestModule.ManifestResource.AddRecord(rec);
 			}
 
 			int entryPointToken = 0;
 
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.FillAssemblyRefTable();
 				if (moduleBuilder != manifestModule)
 				{
 					int fileToken;
 					if (entryPoint != null && entryPoint.Module == moduleBuilder)
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
 						entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					else
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
 						fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					moduleBuilder.ExportTypes(fileToken, manifestModule);
 				}
 			}
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.FillAssemblyRefTable();
 				if (moduleBuilder != manifestModule)
 				{
 					int fileToken;
 					if (entryPoint != null && entryPoint.Module == moduleBuilder)
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
 						entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					else
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
 						fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					moduleBuilder.ExportTypes(fileToken, manifestModule);
 				}
 			}
 
 			foreach (Module module in addedModules)
 			{
 				int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
 				module.ExportTypes(fileToken, manifestModule);
 			}
 			foreach (Module module in addedModules)
 			{
 				int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
 				module.ExportTypes(fileToken, manifestModule);
 			}
 
 			if (entryPointToken == 0 && entryPoint != null)
 			{
 				entryPointToken = entryPoint.MetadataToken;
 			}
 
 			// finally, write the manifest module
 			ModuleWriter.WriteModule(keyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="188" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="248" endline="868">
<![CDATA[
 			new char [] {' ', '\t', '\n', '\r'};
 
 		//
 		// returns a full runtime type name from a name which might
 		// be C# specific type name.
 		//
 		private static TypeSpec FindDocumentedType (MemberCore mc, string name, DeclSpace ds, string cref, Report r)
 		{
 			bool is_array = false;
 			string identifier = name;
 			if (name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				if (tmp [tmp.Length - 1] == '[') {
 					identifier = tmp.Substring (0, tmp.Length - 1).Trim (wsChars);
 					is_array = true;
 				}
 			}
 			TypeSpec t = FindDocumentedTypeNonArray (mc, identifier, ds, cref, r);
 			if (t != null && is_array)
 				t = ArrayContainer.MakeType (t);
 			return t;
 		}
 
 		private static TypeSpec FindDocumentedTypeNonArray (MemberCore mc, 
 			string identifier, DeclSpace ds, string cref, Report r)
 		{
 			switch (identifier) {
 			case "int"
 				return TypeManager.int32_type;
 			case "uint"
 				return TypeManager.uint32_type;
 			case "short"
 				return TypeManager.short_type;;
 			case "ushort"
 				return TypeManager.ushort_type;
 			case "long"
 				return TypeManager.int64_type;
 			case "ulong"
 				return TypeManager.uint64_type;;
 			case "float"
 				return TypeManager.float_type;;
 			case "double"
 				return TypeManager.double_type;
 			case "char"
 				return TypeManager.char_type;;
 			case "decimal"
 				return TypeManager.decimal_type;;
 			case "byte"
 				return TypeManager.byte_type;;
 			case "sbyte"
 				return TypeManager.sbyte_type;;
 			case "object"
 				return TypeManager.object_type;;
 			case "bool"
 				return TypeManager.bool_type;;
 			case "string"
 				return TypeManager.string_type;;
 			case "void"
 				return TypeManager.void_type;;
 			}
 			FullNamedExpression e = ds.LookupNamespaceOrType (identifier, 0, mc.Location, false);
 			if (e != null) {
 				if (!(e is TypeExpr))
 					return null;
 				return e.Type;
 			}
 			int index = identifier.LastIndexOf ('.');
 			if (index < 0)
 				return null;
 
 			var nsName = identifier.Substring (0, index);
 			var typeName = identifier.Substring (index + 1);
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (nsName, false);
 			ns = ns ?? mc.Module.GlobalRootNamespace.GetNamespace(nsName, false);
 			if (ns != null) {
 				var te = ns.LookupType(mc.Compiler, typeName, 0, true, mc.Location);
 				if(te != null)
 					return te.Type;
 			}
 
 			int warn;
 			TypeSpec parent = FindDocumentedType (mc, identifier.Substring (0, index), ds, cref, r);
 			if (parent == null)
 				return null;
 			// no need to detect warning 419 here
 			var ts = FindDocumentedMember (mc, parent,
 				identifier.Substring (index + 1),
 				null, ds, out warn, cref, false, null, r) as TypeSpec;
 			if (ts != null)
 				return ts;
 			return null;
 		}
 
 		//
 		// Returns a MemberInfo that is referenced in XML documentation
 		// (by "see" or "seealso" elements).
 		//
 		private static MemberSpec FindDocumentedMember (MemberCore mc,
 			TypeSpec type, string member_name, AParametersCollection param_list, 
 			DeclSpace ds, out int warning_type, string cref,
 			bool warn419, string name_for_error, Report r)
 		{
 //			for (; type != null; type = type.DeclaringType) {
 				var mi = FindDocumentedMemberNoNest (
 					mc, type, member_name, param_list, ds,
 					out warning_type, cref, warn419,
 					name_for_error, r);
 				if (mi != null)
 					return mi; // new FoundMember (type, mi);
 //			}
 			warning_type = 0;
 			return null;
 		}
 
 		private static MemberSpec FindDocumentedMemberNoNest (
 			MemberCore mc, TypeSpec type, string member_name,
 			AParametersCollection param_list, DeclSpace ds, out int warning_type, 
 			string cref, bool warn419, string name_for_error, Report Report)
 		{
 			warning_type = 0;
 //			var filter = new MemberFilter (member_name, 0, MemberKind.All, param_list, null);
 			IList<MemberSpec> found = null;
 			while (type != null && found == null) {
 				found = MemberCache.FindMembers (type, member_name, false);
 				type = type.DeclaringType;
 			}
 
 			if (found == null)
 				return null;
 
 			if (warn419 && found.Count > 1) {
 				Report419 (mc, name_for_error, found.ToArray (), Report);
 			}
 
 			return found [0];
 
 /*
 			if (param_list == null) {
 				// search for fields/events etc.
 				mis = TypeManager.MemberLookup (type, null,
 					type, MemberKind.All,
 					BindingRestriction.None,
 					member_name, null);
 				mis = FilterOverridenMembersOut (mis);
 				if (mis == null || mis.Length == 0)
 					return null;
 				if (warn419 && IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			MethodSignature msig = new MethodSignature (member_name, null, param_list);
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 
 			if (warn419 && mis.Length > 0) {
 				if (IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			// search for operators (whose parameters exactly
 			// matches with the list) and possibly report CS1581.
 			string oper = null;
 			string return_type_name = null;
 			if (member_name.StartsWith ("implicit operator ")) {
 				Operator.GetMetadataName (Operator.OpType.Implicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("explicit operator ")) {
 				oper = Operator.GetMetadataName (Operator.OpType.Explicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("operator ")) {
 				oper = member_name.Substring (9).Trim (wsChars);
 				switch (oper) {
 				// either unary or binary
 				case "+"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Addition) 
 						Operator.GetMetadataName (Operator.OpType.UnaryPlus);
 					break;
 				case "-"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Subtraction) 
 						Operator.GetMetadataName (Operator.OpType.UnaryNegation);
 					break;
 				default
 					oper = Operator.GetMetadataName (oper);
 					if (oper != null)
 						break;
 
 					warning_type = 1584;
 					Report.Warning (1020, 1, mc.Location, "Overloadable {0} operator is expected", param_list.Length == 2 ? "binary" 
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					return null;
 				}
 			}
 			// here we still don't consider return type (to
 			// detect CS1581 or CS1002+CS1584).
 			msig = new MethodSignature (oper, null, param_list);
 
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 			if (mis.Length == 0)
 				return null; // CS1574
 			var mi = mis [0];
 			TypeSpec expected = mi is MethodSpec ?
 				((MethodSpec) mi).ReturnType 
 				mi is PropertySpec ?
 				((PropertySpec) mi).PropertyType 
 				null;
 			if (return_type_name != null) {
 				TypeSpec returnType = FindDocumentedType (mc, return_type_name, ds, cref, Report);
 				if (returnType == null || returnType != expected) {
 					warning_type = 1581;
 					Report.Warning (1581, 1, mc.Location, "Invalid return type in XML comment cref attribute `{0}'", cref);
 					return null;
 				}
 			}
 			return mis [0];
 */ 
 		}
 
 		//
 		// Processes "see" or "seealso" elements.
 		// Checks cref attribute.
 		//
 		private static void HandleXrefCommon (MemberCore mc,
 			DeclSpace ds, XmlElement xref, Report Report)
 		{
 			string cref = xref.GetAttribute ("cref").Trim (wsChars);
 			// when, XmlReader, "if (cref == null)"
 			if (!xref.HasAttribute ("cref"))
 				return;
 			if (cref.Length == 0)
 				Report.Warning (1001, 1, mc.Location, "Identifier expected");
 				// ... and continue until CS1584.
 
 			string signature; // "x
 			string name; // method invokation "(...)" are removed
 			string parameters; // method parameter list
 
 			// When it found '?
 			// MS ignores not only its member kind, but also
 			// the entire syntax correctness. Nor it also does
 			// type fullname resolution i.e. "T
 			// as T
 			// T
 			if (cref.Length > 2 && cref [1] == '
 				return;
 			else
 				signature = cref;
 
 			// Also note that without "T
 			// indication fails.
 
 			int parens_pos = signature.IndexOf ('(');
 			int brace_pos = parens_pos >= 0 ? -1 
 				signature.IndexOf ('[');
 			if (parens_pos > 0 && signature [signature.Length - 1] == ')') {
 				name = signature.Substring (0, parens_pos).Trim (wsChars);
 				parameters = signature.Substring (parens_pos + 1, signature.Length - parens_pos - 2).Trim (wsChars);
 			}
 			else if (brace_pos > 0 && signature [signature.Length - 1] == ']') {
 				name = signature.Substring (0, brace_pos).Trim (wsChars);
 				parameters = signature.Substring (brace_pos + 1, signature.Length - brace_pos - 2).Trim (wsChars);
 			}
 			else {
 				name = signature;
 				parameters = null;
 			}
 			Normalize (mc, ref name, Report);
 
 			string identifier = GetBodyIdentifierFromName (name);
 
 			// Check if identifier is valid.
 			// This check is not necessary to mark as error, but
 			// csc specially reports CS1584 for wrong identifiers.
 			string [] name_elems = identifier.Split ('.');
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 
 			// check if parameters are valid
 			AParametersCollection parameter_types;
 			if (parameters == null)
 				parameter_types = null;
 			else if (parameters.Length == 0)
 				parameter_types = ParametersCompiled.EmptyReadOnlyParameters;
 			else {
 				string [] param_list = parameters.Split (',');
 				var plist = new List<TypeSpec> ();
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 
 				parameter_types = ParametersCompiled.CreateFullyResolved (plist.ToArray ());
 			}
 
 			TypeSpec type = FindDocumentedType (mc, name, ds, cref, Report);
 			if (type != null
 				// delegate must not be referenced with args
 				&& (!type.IsDelegate
 				|| parameter_types == null)) {
 				string result = GetSignatureForDoc (type)
 					+ (brace_pos < 0 ? String.Empty 
 				xref.SetAttribute ("cref", "T
 				return; // a type
 			}
 
 			int period = name.LastIndexOf ('.');
 			if (period > 0) {
 				string typeName = name.Substring (0, period);
 				string member_name = name.Substring (period + 1);
 				string lookup_name = member_name == "this" ? MemberCache.IndexerNameAlias 
 				Normalize (mc, ref lookup_name, Report);
 				Normalize (mc, ref member_name, Report);
 				type = FindDocumentedType (mc, typeName, ds, cref, Report);
 				int warn_result;
 				if (type != null) {
 					var mi = FindDocumentedMember (mc, type, lookup_name, parameter_types, ds, out warn_result, cref, true, name, Report);
 					if (warn_result > 0)
 						return;
 					if (mi != null) {
 						// we cannot use 'type' directly
 						// to get its name, since mi
 						// could be from DeclaringType
 						// for nested types.
 						xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + member_name + GetParametersFormatted (mi));
 						return; // a member of a type
 					}
 				}
 			} else {
 				int warn_result;
 				var mi = FindDocumentedMember (mc, ds.PartialContainer.Definition, name, parameter_types, ds, out warn_result, cref, true, name, Report);
 
 				if (warn_result > 0)
 					return;
 				if (mi != null) {
 					// we cannot use 'type' directly
 					// to get its name, since mi
 					// could be from DeclaringType
 					// for nested types.
 					xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + name + GetParametersFormatted (mi));
 					return; // local member name
 				}
 			}
 
 			// It still might be part of namespace name.
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (name, false);
 			if (ns != null) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 			if (mc.Module.GlobalRootNamespace.IsNamespace (name)) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 
 			Report.Warning (1574, 1, mc.Location, "XML comment on `{0}' has cref attribute `{1}' that could not be resolved",
 				mc.GetSignatureForError (), cref);
 
 			xref.SetAttribute ("cref", "!
 		}
 
 		static string GetParametersFormatted (MemberSpec mi)
 		{
 			var pm = mi as IParametersMember;
 			if (pm == null || pm.Parameters.IsEmpty)
 				return string.Empty;
 
 			AParametersCollection parameters = pm.Parameters;
 /*
 			if (parameters == null || parameters.Count == 0)
 				return String.Empty;
 */
 			StringBuilder sb = new StringBuilder ();
 			sb.Append ('(');
 			for (int i = 0; i < parameters.Count; i++) {
 //				if (is_setter && i + 1 == parameters.Count)
 //					break; // skip "value".
 				if (i > 0)
 					sb.Append (',');
 				TypeSpec t = parameters.Types [i];
 				sb.Append (GetSignatureForDoc (t));
 			}
 			sb.Append (')');
 			return sb.ToString ();
 		}
 
 		static string GetBodyIdentifierFromName (string name)
 		{
 			string identifier = name;
 
 			if (name.Length > 0 && name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				int last = tmp.LastIndexOf ('[');
 				if (last > 0)
 					identifier = tmp.Substring (0, last).Trim (wsChars);
 			}
 
 			return identifier;
 		}
 
 		static void Report419 (MemberCore mc, string member_name, MemberSpec [] mis, Report Report)
 		{
 			Report.Warning (419, 3, mc.Location, 
 				"Ambiguous reference in cref attribute `{0}'. Assuming `{1}' but other overloads including `{2}' have also matched",
 				member_name,
 				TypeManager.GetFullNameSignature (mis [0]),
 				TypeManager.GetFullNameSignature (mis [1]));
 		}
 
 		//
 		// Get a prefix from member type for XML documentation (used
 		// to formalize cref target name).
 		//
 		static string GetMemberDocHead (MemberSpec type)
 		{
 			if (type is FieldSpec)
 				return "F
 			if (type is MethodSpec)
 				return "M
 			if (type is EventSpec)
 				return "E
 			if (type is PropertySpec)
 				return "P
 			if (type is TypeSpec)
 				return "T
 
 			return "!
 		}
 
 		// MethodCore
 
 		//
 		// Returns a string that represents the signature for this 
 		// member which should be used in XML documentation.
 		//
 		public static string GetMethodDocCommentName (MemberCore mc, ParametersCompiled parameters, DeclSpace ds)
 		{
 			IParameterData [] plist = parameters.FixedParameters;
 			string paramSpec = String.Empty;
 			if (plist != null) {
 				StringBuilder psb = new StringBuilder ();
 				int i = 0;
 				foreach (Parameter p in plist) {
 					psb.Append (psb.Length != 0 ? "," 
 					psb.Append (GetSignatureForDoc (parameters.Types [i++]));
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 						psb.Append ('@');
 				}
 				paramSpec = psb.ToString ();
 			}
 
 			if (paramSpec.Length > 0)
 				paramSpec += ")";
 
 			string name = mc.Name;
 			if (mc is Constructor)
 				name = "#ctor";
 			else if (mc is InterfaceMemberBase) {
 				var imb = (InterfaceMemberBase) mc;
 				name = imb.GetFullName (imb.ShortName);
 			}
 			name = name.Replace ('.', '#');
 
 			if (mc.MemberName.TypeArguments != null && mc.MemberName.TypeArguments.Count > 0)
 				name += "``" + mc.MemberName.CountTypeArguments;
 
 			string suffix = String.Empty;
 			Operator op = mc as Operator;
 			if (op != null) {
 				switch (op.OperatorType) {
 				case Operator.OpType.Implicit
 				case Operator.OpType.Explicit
 					suffix = "~" + GetSignatureForDoc (op.ReturnType);
 					break;
 				}
 			}
 			return String.Concat (mc.DocCommentHeader, ds.Name, ".", name, paramSpec, suffix);
 		}
 
 		static string GetSignatureForDoc (TypeSpec type)
 		{
 			var tp = type as TypeParameterSpec;
 			if (tp != null) {
 				int c = 0;
 				type = type.DeclaringType;
 				while (type != null && type.DeclaringType != null) {
 					type = type.DeclaringType;
 					c += type.MemberDefinition.TypeParametersCount;
 				}
 				var prefix = tp.IsMethodOwned ? "``" 
 				return prefix + (c + tp.DeclaredPosition);
 			}
 
 			var pp = type as PointerContainer;
 			if (pp != null)
 				return GetSignatureForDoc (pp.Element) + "*";
 
 			ArrayContainer ap = type as ArrayContainer;
 			if (ap != null)
 				return GetSignatureForDoc (ap.Element) +
 					ArrayContainer.GetPostfixSignature (ap.Rank);
 
 			if (TypeManager.IsGenericType (type)) {
 				string g = type.MemberDefinition.Namespace;
 				if (g != null && g.Length > 0)
 					g += '.';
 				int idx = type.Name.LastIndexOf ('`');
 				g += (idx < 0 ? type.Name 
 				int argpos = 0;
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (type))
 					g += (argpos++ > 0 ? "," 
 				g += '}';
 				return g;
 			}
 
 			string name = type.GetMetaInfo ().FullName != null ? type.GetMetaInfo ().FullName 
 			return name.Replace ("+", ".").Replace ('&', '@');
 		}
 
 		//
 		// Raised (and passed an XmlElement that contains the comment)
 		// when GenerateDocComment is writing documentation expectedly.
 		//
 		// FIXME
 		// that means removal of DOM use.
 		//
 		internal static void OnMethodGenerateDocComment (
 			MethodCore mc, XmlElement el, Report Report)
 		{
 			var paramTags = new Dictionary<string, string> ();
 			foreach (XmlElement pelem in el.SelectNodes ("param")) {
 				string xname = pelem.GetAttribute ("name");
 				if (xname.Length == 0)
 					continue; // really? but MS looks doing so
 				if (xname != "" && mc.ParameterInfo.GetParameterIndexByName (xname) < 0)
 					Report.Warning (1572, 2, mc.Location, "XML comment on `{0}' has a param tag for `{1}', but there is no parameter by that name",
 						mc.GetSignatureForError (), xname);
 				else if (paramTags.ContainsKey (xname))
 					Report.Warning (1571, 2, mc.Location, "XML comment on `{0}' has a duplicate param tag for `{1}'",
 						mc.GetSignatureForError (), xname);
 				paramTags [xname] = xname;
 			}
 			IParameterData [] plist = mc.ParameterInfo.FixedParameters;
 			foreach (Parameter p in plist) {
 				if (paramTags.Count > 0 && !paramTags.ContainsKey (p.Name))
 					Report.Warning (1573, 4, mc.Location, "Parameter `{0}' has no matching param tag in the XML comment for `{1}'",
 						p.Name, mc.GetSignatureForError ());
 			}
 		}
 
 		private static void Normalize (MemberCore mc, ref string name, Report Report)
 		{
 			if (name.Length > 0 && name [0] == '@')
 				name = name.Substring (1);
 			else if (name == "this")
 				name = "Item";
 			else if (Tokenizer.IsKeyword (name) && !IsTypeName (name))
 				Report.Warning (1041, 1, mc.Location, "Identifier expected. `{0}' is a keyword", name);
 		}
 
 		private static bool IsTypeName (string name)
 		{
 			switch (name) {
 			case "bool"
 			case "byte"
 			case "char"
 			case "decimal"
 			case "double"
 			case "float"
 			case "int"
 			case "long"
 			case "object"
 			case "sbyte"
 			case "short"
 			case "string"
 			case "uint"
 			case "ulong"
 			case "ushort"
 			case "void"
 				return true;
 			}
 			return false;
 		}
 	}
 
 	//
 	// Implements XML documentation generation.
 	//
 	public class Documentation
 	{
 		public Documentation (string xml_output_filename)
 		{
 			docfilename = xml_output_filename;
 			XmlDocumentation = new XmlDocument ();
 			XmlDocumentation.PreserveWhitespace = false;
 		}
 
 		private string docfilename;
 
 		//
 		// Used to create element which helps well-formedness checking.
 		//
 		public XmlDocument XmlDocumentation;
 
 		//
 		// The output for XML documentation.
 		//
 		public XmlWriter XmlCommentOutput;
 
 		//
 		// Stores XmlDocuments that are included in XML documentation.
 		// Keys are included filenames, values are XmlDocuments.
 		//
 		public Dictionary<string, XmlDocument> StoredDocuments = new Dictionary<string, XmlDocument> ();
 		public Documentation (string xml_output_filename)
 		{
 			docfilename = xml_output_filename;
 			XmlDocumentation = new XmlDocument ();
 			XmlDocumentation.PreserveWhitespace = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="474" endline="632">
<![CDATA[
 
 		//
 		// Processes "see" or "seealso" elements.
 		// Checks cref attribute.
 		//
 		private static void HandleXrefCommon (MemberCore mc,
 			DeclSpace ds, XmlElement xref, Report Report)
 		{
 			string cref = xref.GetAttribute ("cref").Trim (wsChars);
 			// when, XmlReader, "if (cref == null)"
 			if (!xref.HasAttribute ("cref"))
 				return;
 			if (cref.Length == 0)
 				Report.Warning (1001, 1, mc.Location, "Identifier expected");
 				// ... and continue until CS1584.
 
 			string signature; // "x
 			string name; // method invokation "(...)" are removed
 			string parameters; // method parameter list
 
 			// When it found '?
 			// MS ignores not only its member kind, but also
 			// the entire syntax correctness. Nor it also does
 			// type fullname resolution i.e. "T
 			// as T
 			// T
 			if (cref.Length > 2 && cref [1] == '
 				return;
 			else
 				signature = cref;
 
 			// Also note that without "T
 			// indication fails.
 
 			int parens_pos = signature.IndexOf ('(');
 			int brace_pos = parens_pos >= 0 ? -1 
 				signature.IndexOf ('[');
 			if (parens_pos > 0 && signature [signature.Length - 1] == ')') {
 				name = signature.Substring (0, parens_pos).Trim (wsChars);
 				parameters = signature.Substring (parens_pos + 1, signature.Length - parens_pos - 2).Trim (wsChars);
 			}
 			else if (brace_pos > 0 && signature [signature.Length - 1] == ']') {
 				name = signature.Substring (0, brace_pos).Trim (wsChars);
 				parameters = signature.Substring (brace_pos + 1, signature.Length - brace_pos - 2).Trim (wsChars);
 			}
 			else {
 				name = signature;
 				parameters = null;
 			}
 			Normalize (mc, ref name, Report);
 
 			string identifier = GetBodyIdentifierFromName (name);
 
 			// Check if identifier is valid.
 			// This check is not necessary to mark as error, but
 			// csc specially reports CS1584 for wrong identifiers.
 			string [] name_elems = identifier.Split ('.');
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 
 			// check if parameters are valid
 			AParametersCollection parameter_types;
 			if (parameters == null)
 				parameter_types = null;
 			else if (parameters.Length == 0)
 				parameter_types = ParametersCompiled.EmptyReadOnlyParameters;
 			else {
 				string [] param_list = parameters.Split (',');
 				var plist = new List<TypeSpec> ();
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 
 				parameter_types = ParametersCompiled.CreateFullyResolved (plist.ToArray ());
 			}
 
 			TypeSpec type = FindDocumentedType (mc, name, ds, cref, Report);
 			if (type != null
 				// delegate must not be referenced with args
 				&& (!type.IsDelegate
 				|| parameter_types == null)) {
 				string result = GetSignatureForDoc (type)
 					+ (brace_pos < 0 ? String.Empty 
 				xref.SetAttribute ("cref", "T
 				return; // a type
 			}
 
 			int period = name.LastIndexOf ('.');
 			if (period > 0) {
 				string typeName = name.Substring (0, period);
 				string member_name = name.Substring (period + 1);
 				string lookup_name = member_name == "this" ? MemberCache.IndexerNameAlias 
 				Normalize (mc, ref lookup_name, Report);
 				Normalize (mc, ref member_name, Report);
 				type = FindDocumentedType (mc, typeName, ds, cref, Report);
 				int warn_result;
 				if (type != null) {
 					var mi = FindDocumentedMember (mc, type, lookup_name, parameter_types, ds, out warn_result, cref, true, name, Report);
 					if (warn_result > 0)
 						return;
 					if (mi != null) {
 						// we cannot use 'type' directly
 						// to get its name, since mi
 						// could be from DeclaringType
 						// for nested types.
 						xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + member_name + GetParametersFormatted (mi));
 						return; // a member of a type
 					}
 				}
 			} else {
 				int warn_result;
 				var mi = FindDocumentedMember (mc, ds.PartialContainer.Definition, name, parameter_types, ds, out warn_result, cref, true, name, Report);
 
 				if (warn_result > 0)
 					return;
 				if (mi != null) {
 					// we cannot use 'type' directly
 					// to get its name, since mi
 					// could be from DeclaringType
 					// for nested types.
 					xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + name + GetParametersFormatted (mi));
 					return; // local member name
 				}
 			}
 
 			// It still might be part of namespace name.
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (name, false);
 			if (ns != null) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 			if (mc.Module.GlobalRootNamespace.IsNamespace (name)) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 
 			Report.Warning (1574, 1, mc.Location, "XML comment on `{0}' has cref attribute `{1}' that could not be resolved",
 				mc.GetSignatureForError (), cref);
 
 			xref.SetAttribute ("cref", "!
 		}
]]>
</clone_fragment>
</clone_group>
</clones>
