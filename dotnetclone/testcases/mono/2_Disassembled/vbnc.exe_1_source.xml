<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="100" endline="110"><![CDATA[
         Get
             If m_BlockStatements Is Nothing Then
                 m_BlockStatements = New Generic.List(Of BlockStatement)
                 For Each stmt As Statement In m_Statements
                     Dim blockStmt As BlockStatement
                     blockStmt = TryCast(stmt, BlockStatement)
                     If blockStmt IsNot Nothing Then m_BlockStatements.Add(blockStmt)
                 Next
             End If
             Return m_BlockStatements
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="111" endline="129"><![CDATA[
     End Property
 
     Sub FindStaticVariables(ByVal list As Generic.List(Of LocalVariableDeclaration))
         If m_StaticVariables IsNot Nothing Then
             list.AddRange(m_StaticVariables)
             Return
         End If
 
         For Each var As LocalVariableDeclaration In m_Variables
             If var.Modifiers.Is(ModifierMasks.Static) Then
                 list.Add(var)
             End If
         Next
         For Each stmt As BlockStatement In BlockStatements
             stmt.CodeBlock.FindStaticVariables(list)
         Next
 
         m_StaticVariables = list
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="130" endline="133"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     Private m_Variables As New Nameables(Of LocalVariableDeclaration)(Me)
     Private m_StaticVariables As Generic.List(Of LocalVariableDeclaration)
 
     ''' <summary>
     ''' A list of all the statements (expressions) in this code block.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Statements As New BaseObjects(Of Statement)(Compiler)
     Private m_BlockStatements As Generic.List(Of BlockStatement)
     Private m_Sequence As New BaseObjects(Of BaseObject)(Me)
 
     ''' <summary>
     ''' A list of all the labels in this code block.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Labels As New Generic.List(Of LabelDeclarationStatement)
 
     Private m_FirstStatement As Statement
 
     Private m_HasStructuredExceptionHandling As Boolean
 
     Private m_HasUnstructuredExceptionHandling As Boolean
     Private m_HasResume As Boolean
 
     Public EndUnstructuredExceptionHandler As Label
     ''' <summary>
     ''' This is the variable informing which handler should handle an exception.
     ''' </summary>
     ''' <remarks></remarks>
     Public VB_ActiveHandler As Mono.Cecil.Cil.VariableDefinition
     Public VB_ActiveHandlerLabel As Label
     ''' <summary>
     ''' A value is stored here to check if the running code is in the unstructured handler
     ''' 0
     ''' -1
     ''' </summary>
     ''' <remarks></remarks>
     Public VB_ResumeTarget As Mono.Cecil.Cil.VariableDefinition
     Public UnstructuredResumeNextHandler As Label
     Public UnstructuredResumeHandler As Label
     ''' <summary>
     ''' The end of the switch. The code here jumps to the end of the method.
     ''' </summary>
     ''' <remarks></remarks>
     Public UnstructuredSwitchHandlerEnd As Label
 
     ''' <summary>
     ''' The resume next exception handler. Index 1 of the switch table
     ''' </summary>
     ''' <remarks></remarks>
     Public ResumeNextExceptionHandler As Label
     ''' <summary>
     ''' The index into the jump table of the current instruction.
     ''' </summary>
     ''' <remarks></remarks>
     Public VB_CurrentInstruction As Mono.Cecil.Cil.VariableDefinition
     Public UnstructuredExceptionHandlers As Generic.List(Of Label)
     Public UnstructuredExceptionLabels As Generic.List(Of Label)
     Public EndMethodLabel As Label
 
     ''' <summary>
     ''' The location of the code that throws an internal exception.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_InternalExceptionLocation As Label
 
     Private m_EndOfMethodLabel As Nullable(Of Label)
 
     ReadOnly Property BlockStatements() As Generic.List(Of BlockStatement)
         Get
             If m_BlockStatements Is Nothing Then
                 m_BlockStatements = New Generic.List(Of BlockStatement)
                 For Each stmt As Statement In m_Statements
                     Dim blockStmt As BlockStatement
                     blockStmt = TryCast(stmt, BlockStatement)
                     If blockStmt IsNot Nothing Then m_BlockStatements.Add(blockStmt)
                 Next
             End If
             Return m_BlockStatements
         End Get
     End Property
 
     Sub FindStaticVariables(ByVal list As Generic.List(Of LocalVariableDeclaration))
         If m_StaticVariables IsNot Nothing Then
             list.AddRange(m_StaticVariables)
             Return
         End If
 
         For Each var As LocalVariableDeclaration In m_Variables
             If var.Modifiers.Is(ModifierMasks.Static) Then
                 list.Add(var)
             End If
         Next
         For Each stmt As BlockStatement In BlockStatements
             stmt.CodeBlock.FindStaticVariables(list)
         Next
 
         m_StaticVariables = list
     End Sub
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="134" endline="138"><![CDATA[
 
     Sub AddStatementAfter(ByVal Statement As Statement, ByVal After As Statement)
         m_Statements.Insert(m_Statements.IndexOf(After) + 1, Statement)
         m_Sequence.Insert(m_Sequence.IndexOf(After) + 1, Statement)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="139" endline="143"><![CDATA[
 
     Sub AddStatementBefore(ByVal Statement As Statement, ByVal Before As Statement)
         m_Statements.Insert(m_Statements.IndexOf(Before), Statement)
         m_Sequence.Insert(m_Sequence.IndexOf(Before), Statement)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="144" endline="148"><![CDATA[
 
     Sub AddStatement(ByVal Statement As Statement)
         m_Statements.Add(Statement)
         m_Sequence.Add(Statement)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="149" endline="154"><![CDATA[
 
     Sub AddLabel(ByVal lbl As LabelDeclarationStatement)
         m_Labels.Add(lbl)
         Dim cb As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         If cb IsNot Nothing Then cb.AddLabel(lbl)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="155" endline="159"><![CDATA[
 
     Sub AddVariable(ByVal var As LocalVariableDeclaration)
         m_Variables.Add(var)
         m_Sequence.Add(var)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="160" endline="165"><![CDATA[
 
     Sub AddVariables(ByVal list As Generic.ICollection(Of LocalVariableDeclaration))
         For Each var As LocalVariableDeclaration In list
             AddVariable(var)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="166" endline="181"><![CDATA[
 
     ''' <summary>
     ''' A label to just before the last ret instruction of the method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property EndOfMethodLabel() As Label
         Get
             If m_EndOfMethodLabel.HasValue Then
                 Return m_EndOfMethodLabel.Value
             Else
                 Helper.Assert(Me IsNot UpmostBlock)
                 Return Me.UpmostBlock.EndOfMethodLabel
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="182" endline="187"><![CDATA[
     End Property
 
     Property FirstStatement() As Statement
         Get
             Return m_FirstStatement
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="188" endline="190"><![CDATA[
         Set(ByVal value As Statement)
             m_FirstStatement = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="191" endline="196"><![CDATA[
     End Property
 
     ReadOnly Property Statements() As Generic.List(Of Statement)
         Get
             Return m_Statements
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="197" endline="202"><![CDATA[
     End Property
 
     Sub RemoveStatement(ByVal Statement As Statement)
         m_Statements.Remove(Statement)
         m_Sequence.Remove(Statement)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="203" endline="207"><![CDATA[
 
     Property HasResume() As Boolean
         Get
             Return m_HasResume
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="208" endline="213"><![CDATA[
         Set(ByVal value As Boolean)
             Helper.Assert(value = True)
             m_HasResume = value
             Dim parent As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
             If parent IsNot Nothing Then parent.HasResume = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="214" endline="219"><![CDATA[
     End Property
 
     Property HasUnstructuredExceptionHandling() As Boolean
         Get
             Return m_HasUnstructuredExceptionHandling
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="220" endline="224"><![CDATA[
         Set(ByVal value As Boolean)
             m_HasUnstructuredExceptionHandling = True
             Dim parent As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
             If parent IsNot Nothing Then parent.HasUnstructuredExceptionHandling = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="225" endline="230"><![CDATA[
     End Property
 
     Property HasStructuredExceptionHandling() As Boolean
         Get
             Return m_HasStructuredExceptionHandling
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="231" endline="235"><![CDATA[
         Set(ByVal value As Boolean)
             m_HasStructuredExceptionHandling = True
             Dim parent As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
             parent.HasStructuredExceptionHandling = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="236" endline="241"><![CDATA[
     End Property
 
     ReadOnly Property Labels() As Generic.List(Of LabelDeclarationStatement)
         Get
             Return m_Labels
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="242" endline="256"><![CDATA[
     End Property
 
     Function FindLabel(ByVal Name As Token) As LabelDeclarationStatement
         Dim cb As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         If cb IsNot Nothing Then
             Return cb.FindLabel(Name)
         Else
             For Each l As LabelDeclarationStatement In m_Labels
                 If l.Label.Equals(Name) Then
                     Return l
                 End If
             Next
         End If
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="257" endline="294"><![CDATA[
 
     Private Function GenerateUnstructuredStart(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndMethodLabel = Emitter.DefineLabel(Info)
         m_InternalExceptionLocation = Emitter.DefineLabel(Info)
         UnstructuredResumeNextHandler = Emitter.DefineLabel(Info)
         UnstructuredResumeHandler = Emitter.DefineLabel(Info)
         UnstructuredSwitchHandlerEnd = Emitter.DefineLabel(Info)
 
         VB_ActiveHandler = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Int32, "VB$ActiveHandler")
         VB_ActiveHandlerLabel = Emitter.DefineLabel(Info)
         VB_ResumeTarget = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Int32, "VB$ResumeTarget")
 
         EndUnstructuredExceptionHandler = Emitter.EmitBeginExceptionBlock(Info)
         UnstructuredExceptionLabels = New Generic.List(Of Label)
         UnstructuredExceptionHandlers = New Generic.List(Of Label)
 
         'Handler 0
         UnstructuredExceptionHandlers.Add(m_InternalExceptionLocation)
         UnstructuredExceptionHandlers.Add(UnstructuredResumeNextHandler)
         UnstructuredExceptionHandlers.Add(UnstructuredResumeHandler)
 
         'At entry to the method, the exception-handler location and the exception are both set to Nothing. 
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
 
         UnstructuredExceptionLabels.Add(UnstructuredSwitchHandlerEnd) 'index 0
         If Me.HasResume Then
             VB_CurrentInstruction = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Int32, "VB$CurrentStatement")
             ResumeNextExceptionHandler = Emitter.DefineLabel(Info)
 
             UnstructuredExceptionLabels.Add(ResumeNextExceptionHandler) 'index 1
         Else
             UnstructuredExceptionLabels.Add(UnstructuredSwitchHandlerEnd) 'index 1
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="295" endline="407"><![CDATA[
 
     Private Function GenerateUnstructuredEnd(ByVal Method As IMethod, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim retvar As Mono.Cecil.Cil.VariableDefinition = Method.DefaultReturnVariable
 
         'Add a label to the end of the code as the last item in the switch.
 
         If retvar IsNot Nothing Then
             Emitter.EmitLeave(Info, Me.EndMethodLabel)
         Else
             Emitter.EmitLeave(Info, Me.EndMethodLabel)
         End If
 
         Me.UnstructuredExceptionLabels.Add(UnstructuredSwitchHandlerEnd)
 
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Int32)
         If Me.HasResume Then
             'Increment the instruction pointer index with one, then jump to the switch
             Emitter.MarkLabel(Info, ResumeNextExceptionHandler)
             Emitter.EmitLoadI4Value(Info, -1)
             Emitter.EmitStoreVariable(Info, VB_ResumeTarget)
             Emitter.EmitLoadVariable(Info, VB_CurrentInstruction)
             Emitter.EmitLoadI4Value(Info, 1)
             Emitter.EmitAdd(Info, Compiler.TypeCache.System_Int32)
             Emitter.EmitStoreVariable(Info, tmpVar)
             Emitter.EmitLeave(Info, UnstructuredResumeHandler)
         End If
 
         'Emit the actual handler 
         Emitter.MarkLabel(Info, UnstructuredResumeNextHandler)
         Emitter.EmitLoadI4Value(Info, -1)
         Emitter.EmitStoreVariable(Info, VB_ActiveHandler)
         Emitter.EmitLoadVariable(Info, VB_ResumeTarget)
         Emitter.EmitStoreVariable(Info, tmpVar)
         Emitter.MarkLabel(Info, UnstructuredResumeHandler)
         Emitter.EmitLoadI4Value(Info, 0)
         Emitter.EmitStoreVariable(Info, VB_ResumeTarget)
         Emitter.EmitLoadVariable(Info, tmpVar)
         Emitter.EmitSwitch(Info, UnstructuredExceptionLabels.ToArray)
 
         Emitter.MarkLabel(Info, UnstructuredSwitchHandlerEnd)
         Emitter.EmitLeave(Info, EndMethodLabel)
 
         'Emit the handler selector
         Dim handlers() As Label = UnstructuredExceptionHandlers.ToArray
         Dim endHandlers As Label = Emitter.DefineLabel(Info)
         Dim removedLabel As Label = handlers(0)
         handlers(0) = endHandlers
         Emitter.MarkLabel(Info, VB_ActiveHandlerLabel)
 
         If VB_CurrentInstruction IsNot Nothing Then
             Emitter.EmitLoadVariable(Info, VB_CurrentInstruction)
             Emitter.EmitStoreVariable(Info, VB_ResumeTarget)
         End If
         Emitter.EmitLoadVariable(Info, VB_ActiveHandler)
         Emitter.EmitSwitch(Info, handlers)
         Emitter.EmitLeave(Info, EndMethodLabel)
         Emitter.MarkLabel(Info, endHandlers)
         Emitter.EmitLeave(Info, removedLabel)
 
         'Catch the exception
 
         'create a filter, only handle the exception if it is of type Exception, 
         'if it was not raised when in the unstructured handler and if there actually
         'is a registered exception handler.
         Info.ILGen.BeginExceptFilterBlock()
         Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
         Emitter.EmitLoadNull(Info.Clone(Me, True, False, Compiler.TypeCache.System_Exception))
         Emitter.EmitGT_Un(Info, Compiler.TypeCache.System_Exception) 'TypeOf ... Is System.Exception
 
         Emitter.EmitLoadVariable(Info, Me.VB_ActiveHandler)
         Emitter.EmitLoadI4Value(Info, 0)
         Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32) 'if a handler is registered.
         Emitter.EmitAnd(Info, Compiler.TypeCache.System_Boolean)
 
         Emitter.EmitLoadVariable(Info, Me.VB_ResumeTarget)
         Emitter.EmitLoadI4Value(Info, 0)
         Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32) 'if code is in a unstructured handler or not
         Emitter.EmitAnd(Info, Compiler.TypeCache.System_Boolean)
 
         'create the catch block
         Info.ILGen.BeginCatchBlock(CType(Nothing, Mono.Cecil.TypeReference))
         Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__SetProjectError_Exception)
         Emitter.EmitLeave(Info, VB_ActiveHandlerLabel)
 
         Info.ILGen.EndExceptionBlock()
 
         'Create an internal exception if the code gets here.
         Emitter.MarkLabel(Info, m_InternalExceptionLocation)
         Emitter.EmitLoadI4Value(Info, -2146828237)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Emitter.MarkLabel(Info, EndMethodLabel)
 
         Dim veryMethodEnd As Label = Emitter.DefineLabel(Info)
         Emitter.EmitLoadVariable(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean), VB_ResumeTarget)
         Emitter.EmitBranchIfFalse(Info, veryMethodEnd)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
         Emitter.MarkLabel(Info, veryMethodEnd)
 
         If retvar IsNot Nothing Then
             Emitter.MarkLabel(Info, m_EndOfMethodLabel.Value)
             Emitter.EmitLoadVariable(Info, retvar)
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Ret)
         Else
             Emitter.MarkLabel(Info, m_EndOfMethodLabel.Value)
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Ret)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="408" endline="421"><![CDATA[
 
     ReadOnly Property UpmostBlock() As CodeBlock
         Get
             Dim result As CodeBlock = Nothing
             Dim tmp As CodeBlock
 
             tmp = Me
             Do Until tmp Is Nothing
                 result = tmp
                 tmp = tmp.FindFirstParent(Of CodeBlock)()
             Loop
             Do Until tmp Is Nothing
                 result = tmp
                 tmp = tmp.FindFirstParent(Of CodeBlock)()
             Loop
 
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="422" endline="488"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Call this function from a method beeing emitted.
     ''' </summary>
     ''' <param name="Method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overloads Function GenerateCode(ByVal Method As IMethod) As Boolean
         Dim result As Boolean = True
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Emitting method
 #End If
 
         Dim info As New EmitInfo(Method)
 
         m_EndOfMethodLabel = Emitter.DefineLabel(info)
         If Me.HasUnstructuredExceptionHandling Then
             result = GenerateUnstructuredStart(info) AndAlso result
         End If
 
 #If DEBUG Then
         If CecilHelper.GetMemberType(Method.MemberDescriptor) = MemberTypes.Constructor = False Then
             info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Nop)
         End If
 #End If
 
         result = GenerateCode(info) AndAlso result
 
         If Me.HasUnstructuredExceptionHandling = False Then
             Emitter.MarkLabel(info, m_EndOfMethodLabel.Value)
         End If
 
         Dim retvar As Mono.Cecil.Cil.VariableDefinition = Method.DefaultReturnVariable
         If retvar IsNot Nothing Then
             Emitter.EmitLoadVariable(info, retvar)
         Else
             Helper.Assert(Method.HasReturnValue = False)
         End If
 
         If Me.HasUnstructuredExceptionHandling Then
             result = GenerateUnstructuredEnd(Method, info) AndAlso result
         Else
             Emitter.EmitRet(info)
 #If DEBUGREFLECTION Then
             Dim obj As Object
             If TypeOf info.Method Is ConstructorDeclaration Then
                 obj = CType(info.Method, ConstructorDeclaration).ConstructorBuilder
             Else
                 obj = info.Method.MethodBuilder
             End If
             Helper.DebugReflection_AppendLine("{0} = {1}.GetILGenerator", info.ILGen, obj)
             Helper.DebugReflection_AppendLine("{0}.Emit (System.Reflection.Emit.Opcodes.Ret)", info.ILGen)
 #End If
         End If
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Method " & Method.FullName & " emitted (ID
 #End If
 #If EXTENDEDDEBUG Then
         If info.Stack.Count <> 0 Then
             Throw New InternalException("End of method " & Method.FullName & " reached, but stack is not empty.")
         End If
 #End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="489" endline="502"><![CDATA[
 
     Private Function CreateLabelForCurrentInstruction(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         If UpmostBlock.HasResume Then
             Dim index As Integer
             Dim lbl As Label = Emitter.DefineLabel(Info)
             UpmostBlock.UnstructuredExceptionLabels.Add(lbl)
             index = UpmostBlock.UnstructuredExceptionLabels.IndexOf(lbl)
             Emitter.MarkLabel(Info, lbl)
             Emitter.EmitLoadI4Value(Info, index)
             Emitter.EmitStoreVariable(Info, UpmostBlock.VB_CurrentInstruction)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="503" endline="523"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             Dim var As LocalVariableDeclaration = m_Variables(i)
             result = CreateLabelForCurrentInstruction(Info) AndAlso result
             result = var.DefineLocalVariable(Info) AndAlso result
         Next
 
         For i As Integer = 0 To m_Sequence.Count - 1
             Dim stmt As BaseObject = m_Sequence.Item(i)
 
             Emitter.MarkSequencePoint(Info, stmt.Location)
 
             result = CreateLabelForCurrentInstruction(Info) AndAlso result
             result = stmt.GenerateCode(Info) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="524" endline="528"><![CDATA[
 
     ReadOnly Property Variables() As Nameables(Of LocalVariableDeclaration)
         Get
             Return m_Variables
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="529" endline="540"><![CDATA[
     End Property
 
     Overridable ReadOnly Property IsOneLiner() As Boolean
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Return False
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="541" endline="548"><![CDATA[
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Variables IsNot Nothing Then m_Variables.Initialize(Me)
         If m_Statements IsNot Nothing Then m_Statements.Initialize(Me)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="549" endline="562"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveTypeReferences AndAlso result
         Next
 
         For i As Integer = 0 To m_Statements.Count - 1
             result = m_Statements(i).ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="563" endline="586"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveCode(Info) AndAlso result
         Next
 
         'We may add statements as we go.
         Dim counter As Integer = 0
         Dim count As Integer = m_Statements.Count
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="587" endline="600"><![CDATA[
 
     Function FindVariable(ByVal Name As String) As IAttributableNamedDeclaration
         Dim found As Generic.List(Of INameable)
         found = m_Variables.Index.Item(Name)
         If found Is Nothing Then
             Return Nothing
         ElseIf found.Count = 1 Then
             Return DirectCast(found(0), IAttributableNamedDeclaration)
         ElseIf found.Count > 1 Then
             Throw New InternalException(Me)
         Else
             Return Nothing
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\ImplicitCodeBlock.vb" startline="27" endline="30"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal CodeGenerator As CodeGenerator)
         MyBase.new(Parent)
         m_CodeGenerator = CodeGenerator
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\ImplicitCodeBlock.vb" startline="31" endline="34"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return m_CodeGenerator(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\ImplicitCodeBlock.vb" startline="35" endline="38"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\ImplicitCodeBlock.vb" startline="39" endline="42"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstant.vb" startline="34" endline="36"><![CDATA[
         Get
             Return CBool(Value)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstant.vb" startline="37" endline="42"><![CDATA[
     End Property
 
     Sub New(ByVal Name As String, ByVal Value As Object)
     Public Name As String = ""
     ''' <summary>
     ''' The value of the constant. If a string value, it is case sensitive
     ''' Possible types
     ''' </summary>
     ''' <remarks></remarks>
     Public Value As Object
 
     ReadOnly Property IsDefined() As Boolean
         Get
             Return CBool(Value)
         End Get
     End Property
 
     Sub New(ByVal Name As String, ByVal Value As Object)
         Me.Name = Name
         Me.Value = Value
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstant.vb" startline="43" endline="51"><![CDATA[
 
     ''' <summary>
     ''' Returns the name of the constant.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overrides Function ToString() As String
         Return Name
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="25" endline="27"><![CDATA[
     Public Sub New()
         MyBase.New(Helper.StringComparer)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="28" endline="34"><![CDATA[
 
     Public Sub New(ByVal CopyFrom As ConditionalConstants)
         Me.New()
         For Each constant As ConditionalConstant In CopyFrom.Values
             Add(constant)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="35" endline="38"><![CDATA[
 
     Public Function Clone() As ConditionalConstants
         Return New ConditionalConstants(Me)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="39" endline="49"><![CDATA[
 
 #If DEBUG Then
     ReadOnly Property AsString() As String
         Get
             Dim result As String = String.Empty
             For Each item As Generic.KeyValuePair(Of String, ConditionalConstant) In Me
                 If result <> String.Empty Then result &= ";"
                 result &= item.Key & "=" & CStr(item.Value.Value)
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="50" endline="64"><![CDATA[
     End Property
 #End If
 
     ''' <summary>
     ''' Adds the constant to the collection. 
     ''' If the constant already exists, it is replaced.
     ''' </summary>
     ''' <param name="Constant"></param>
     ''' <remarks></remarks>
     Public Shadows Sub Add(ByVal Constant As ConditionalConstant)
         If MyBase.ContainsKey(Constant.Name) Then
             MyBase.Remove(Constant.Name)
         End If
         MyBase.Add(Constant.Name, Constant)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="65" endline="69"><![CDATA[
 
     Default Public Shadows ReadOnly Property Item(ByVal key As String) As ConditionalConstant
         Get
             Return DirectCast(MyBase.Item(key), ConditionalConstant)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="28" endline="30"><![CDATA[
         Get
             Return m_Scanner.CurrentConstants
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="31" endline="36"><![CDATA[
     End Property
 
     Public Sub New(ByVal Scanner As Scanner)
         MyBase.New(Scanner, Scanner.GetCurrentLocation())
         m_Scanner = Scanner
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="37" endline="40"><![CDATA[
 
     Sub NextToken()
         m_Scanner.NextUnconditionally()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="41" endline="45"><![CDATA[
 
     ReadOnly Property CurrentToken() As Token
         Get
             Return m_Scanner.Current
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="46" endline="104"><![CDATA[
     End Property
 
     Function RuleIdentifier(ByRef Result As Object) As Boolean
         'A value of 0 evaluates as false, anything else as true
         If CurrentToken.Equals(KS.Nothing) Then
             Result = Nothing
             NextToken()
         ElseIf CurrentToken.IsLiteral Then
             Dim tp As TypeCode = Type.GetTypeCode(CurrentToken.LiteralValue.GetType)
             Select Case tp
                 Case TypeCode.String
                     Result = CurrentToken.StringLiteral
                 Case TypeCode.Object
                     Throw New InternalException("Shouldn't happen, Nothing is a keyword.")
                 Case TypeCode.Boolean
                     Throw New InternalException("Shouldn't happen, True and False are keywords.")
                 Case TypeCode.DateTime
                     Result = CurrentToken.DateLiteral
                 Case Else
                     Helper.Assert(Compiler.TypeResolution.IsNumericType(CecilHelper.GetType(Compiler, CurrentToken.LiteralValue)))
                     Result = CDbl(CurrentToken.LiteralValue) 'AsFloatingPointLiteral.Literal
             End Select
             'Result = CurrentToken.Value.Literal
             NextToken()
         ElseIf CurrentToken.IsKeyword Then
             Dim tpType As Mono.Cecil.TypeReference = Compiler.TypeResolution.KeywordToType(CurrentToken.Keyword)
             If tpType Is Nothing Then
                 If CurrentToken.Equals(KS.True) Then
                     Result = True
                     NextToken()
                     Return True
                 ElseIf CurrentToken.Equals(KS.False) Then
                     Result = False
                     NextToken()
                     Return True
                 Else 'TODO
                     Compiler.Report.ShowMessage(Messages.VBNC30201, Location)
                 End If
                 NextToken()
                 Return False
             Else
                 'A builtin type, i.e
                 '#Const a = Integer.MaxValue
                 '#Const a = (user defined type).Constant is not allowed.
                 Throw New InternalException("") 'TODO
             End If
         ElseIf CurrentToken.IsIdentifier Then
             'Find the identifier in the list of defines.
             If CurrentConstants.ContainsKey(CurrentToken.Identifier) Then
                 Result = CurrentConstants.Item(CurrentToken.Identifier).Value
                 NextToken()
             Else
                 Result = Nothing
                 NextToken()
             End If
         End If
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="105" endline="135"><![CDATA[
 
     Function RuleExponent(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIdentifier(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="136" endline="158"><![CDATA[
 
     Function RuleUnaryNegation(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Minus) Then
             NextToken()
             RuleUnaryNegation = RuleExponent(LSide)
 
             Dim op1 As Double
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 LSide = 0
             Else
                 LSide = -op1
             End If
         Else
             If RuleExponent(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="159" endline="199"><![CDATA[
 
     Function RuleMultiplicationAndRealDivision(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleUnaryNegation(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="200" endline="233"><![CDATA[
 
     Function RuleIntegerDivision(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleMultiplicationAndRealDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.IntDivision)
             NextToken()
             RuleMultiplicationAndRealDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf CLng(op2) = 0 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                 LSide = CDbl(0)
             Else
                 LSide = CDbl(CLng(op1) \ CLng(op2))
             End If
         End While
         While CurrentToken.Equals(KS.IntDivision)
             NextToken()
             RuleMultiplicationAndRealDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf CLng(op2) = 0 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                 LSide = CDbl(0)
             Else
                 LSide = CDbl(CLng(op1) \ CLng(op2))
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="234" endline="264"><![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="265" endline="319"><![CDATA[
 
     Function RuleAdditionSubtractionStringConcat(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleMod(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Minus, KS.Add)
             Dim DoAdd As Boolean
             DoAdd = CurrentToken.Equals(KS.Add)
             NextToken()
             RuleMod(RSide)
 
             Dim bErr As Boolean
             If TypeOf LSide Is String AndAlso TypeOf RSide Is String Then
                 'String concat
                 LSide = CStr(LSide) & CStr(RSide)
             Else
                 Dim op1, op2 As Double
                 If TypeOf LSide Is String Then
                     op1 = Double.Parse(DirectCast(LSide, String))
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 ElseIf TypeOf RSide Is String Then
                     op2 = Double.Parse(DirectCast(RSide, String))
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 Else
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 End If
 
 
                 If bErr Then
                     LSide = CDbl(0)
                 ElseIf DoAdd Then
                     LSide = op1 + op2
                 Else
                     LSide = op1 - op2
                 End If
             End If
         End While
         While CurrentToken.Equals(KS.Minus, KS.Add)
             Dim DoAdd As Boolean
             DoAdd = CurrentToken.Equals(KS.Add)
             NextToken()
             RuleMod(RSide)
 
             Dim bErr As Boolean
             If TypeOf LSide Is String AndAlso TypeOf RSide Is String Then
                 'String concat
                 LSide = CStr(LSide) & CStr(RSide)
             Else
                 Dim op1, op2 As Double
                 If TypeOf LSide Is String Then
                     op1 = Double.Parse(DirectCast(LSide, String))
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 ElseIf TypeOf RSide Is String Then
                     op2 = Double.Parse(DirectCast(RSide, String))
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 Else
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 End If
 
 
                 If bErr Then
                     LSide = CDbl(0)
                 ElseIf DoAdd Then
                     LSide = op1 + op2
                 Else
                     LSide = op1 - op2
                 End If
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="320" endline="345"><![CDATA[
 
     Function RuleStringConcat(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleAdditionSubtractionStringConcat(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Concat)
             NextToken()
             RuleAdditionSubtractionStringConcat(RSide)
 
             Dim op1, op2 As String
             Dim bErr As Boolean
 
             op1 = LSide.ToString
             op2 = RSide.ToString
 
             If bErr Then
                 LSide = ""
             Else
                 LSide = op1 & op2
             End If
         End While
         While CurrentToken.Equals(KS.Concat)
             NextToken()
             RuleAdditionSubtractionStringConcat(RSide)
 
             Dim op1, op2 As String
             Dim bErr As Boolean
 
             op1 = LSide.ToString
             op2 = RSide.ToString
 
             If bErr Then
                 LSide = ""
             Else
                 LSide = op1 & op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="346" endline="385"><![CDATA[
 
     Function RuleArithmeticBitshift(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleStringConcat(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="386" endline="423"><![CDATA[
 
     Function RuleRelational(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleArithmeticBitshift(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Equals, KS.NotEqual, KS.GT, KS.LT, KS.GE, KS.LE)
             Dim DoWhat As KS = CurrentToken.Symbol
             NextToken()
             RuleArithmeticBitshift(RSide)
 
             'Compiler.Report.WriteLine(String.Format("RuleRelational
             Try
                 Select Case DoWhat
                     Case KS.Equals
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectEqual(LSide, RSide, True)
                     Case KS.NotEqual
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectNotEqual(LSide, RSide, True)
                     Case KS.GT
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectGreater(LSide, RSide, True)
                     Case KS.LT
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectLess(LSide, RSide, True)
                     Case KS.GE
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectGreaterEqual(LSide, RSide, True)
                     Case KS.LE
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectLessEqual(LSide, RSide, True)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             Catch ex As Exception
                 Helper.AddError(Me, ex.Message & VB.vbNewLine & ex.StackTrace)
                 Return False
             End Try
         End While
         While CurrentToken.Equals(KS.Equals, KS.NotEqual, KS.GT, KS.LT, KS.GE, KS.LE)
             Dim DoWhat As KS = CurrentToken.Symbol
             NextToken()
             RuleArithmeticBitshift(RSide)
 
             'Compiler.Report.WriteLine(String.Format("RuleRelational
             Try
                 Select Case DoWhat
                     Case KS.Equals
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectEqual(LSide, RSide, True)
                     Case KS.NotEqual
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectNotEqual(LSide, RSide, True)
                     Case KS.GT
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectGreater(LSide, RSide, True)
                     Case KS.LT
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectLess(LSide, RSide, True)
                     Case KS.GE
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectGreaterEqual(LSide, RSide, True)
                     Case KS.LE
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectLessEqual(LSide, RSide, True)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             Catch ex As Exception
                 Helper.AddError(Me, ex.Message & VB.vbNewLine & ex.StackTrace)
                 Return False
             End Try
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="424" endline="446"><![CDATA[
 
     Function RuleNot(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Not) Then
             NextToken()
             RuleNot = RuleRelational(LSide)
 
             Dim op1 As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 LSide = 0
             Else
                 LSide = Not op1
             End If
         Else
             If RuleRelational(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="447" endline="481"><![CDATA[
 
     Function RuleAnd_AndAlso(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleNot(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="482" endline="516"><![CDATA[
 
     Function RuleOr_OrElse(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleAnd_AndAlso(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="517" endline="547"><![CDATA[
 
     Function RuleXor(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleOr_OrElse(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="548" endline="551"><![CDATA[
 
     Function RuleExpression(ByRef Result As Object) As Boolean
         Return RuleXor(Result)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="552" endline="555"><![CDATA[
 
     Overloads Function Parse(ByRef Result As Object) As Boolean
         Parse = RuleExpression(Result)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="556" endline="576"><![CDATA[
 
     'Helper conversion functions
     Private Function ToDouble(ByVal value As Object, ByRef Result As Double) As Boolean
         Dim vTp As Mono.Cecil.TypeReference = CecilHelper.GetType(Compiler, value)
         If Helper.CompareType(vTp, Compiler.TypeCache.System_Byte) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Decimal) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Double) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Int32) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Int64) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_SByte) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Int16) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Single) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_UInt32) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_UInt64) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_UInt16) Then
             Result = CDbl(value)
             Return True
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="577" endline="581"><![CDATA[
 
     Private Function ToBoolean(ByVal value As Object, ByRef Result As Boolean) As Boolean
         Result = CBool(value)
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="65" endline="72"><![CDATA[
         Get
             If m_CilBody Is Nothing Then
                 Helper.Assert(m_Method IsNot Nothing)
                 Helper.Assert(m_Method.CecilBuilder IsNot Nothing)
                 m_CilBody = m_Method.CecilBuilder.Body
             End If
             Return m_CilBody
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="73" endline="78"><![CDATA[
     End Property
 
     ReadOnly Property Context() As ParsedObject
         Get
             Return m_Context
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="79" endline="84"><![CDATA[
     End Property
 
     ReadOnly Property Location() As Span
         Get
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="85" endline="96"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Used by Emitter.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Property InExceptionFilter() As Boolean
         Get
             Return m_InExceptionFilter
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="97" endline="99"><![CDATA[
         Set(ByVal value As Boolean)
             m_InExceptionFilter = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="100" endline="105"><![CDATA[
     End Property
 
     ReadOnly Property RHSExpression() As Expression
         Get
             Return m_RHSExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="106" endline="111"><![CDATA[
     End Property
 
     ReadOnly Property IsOptionCompareText() As Boolean
         Get
             Return m_Method.Location.File(Compiler).IsOptionCompareText
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="112" endline="117"><![CDATA[
     End Property
 
     ReadOnly Property IntegerOverflowChecks() As Boolean
         Get
             Return Not Compiler.CommandLine.RemoveIntChecks
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="118" endline="123"><![CDATA[
     End Property
 
     ReadOnly Property IsExplicitConversion() As Boolean
         Get
             Return m_IsExplicitConversion
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="124" endline="129"><![CDATA[
     End Property
 
     ReadOnly Property DesiredType() As Mono.Cecil.TypeReference
         Get
             Return m_DesiredType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="130" endline="141"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Is this a right hand side expression?
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property IsRHS() As Boolean
         Get
             Return m_IsRHS
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="142" endline="153"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Is this a left hand side expression?
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property IsLHS() As Boolean
         Get
             Return Not m_IsRHS
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="154" endline="170"><![CDATA[
     End Property
 
     Private m_FakeGenerator As EmitLog
     ''' <summary>
     ''' The ILGenerator used to emit the code.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ILGen() As EmitLog
         Get
             If m_FakeGenerator Is Nothing Then
                 m_FakeGenerator = New EmitLog(Compiler)
                 m_FakeGenerator.CilBody = CilBody
             End If
             Return m_FakeGenerator
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="171" endline="181"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The method where the code is located.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Method() As IMethod
         Get
             Return m_Method
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="182" endline="187"><![CDATA[
     End Property
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Method.Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="188" endline="197"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new EmitInfo starting in the specified method.
     ''' </summary>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Method As IMethod)
         m_Method = Method
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="198" endline="214"><![CDATA[
 
     ''' <summary>
     ''' Clone the emitinfo for a left hand side expression.
     ''' </summary>
     ''' <param name="RHSExpression"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Clone(ByVal Context As ParsedObject, ByVal RHSExpression As Expression) As EmitInfo
         Dim result As New EmitInfo(Me)
 
         result.m_IsRHS = False
         result.m_RHSExpression = RHSExpression
         result.m_DesiredType = Nothing
         result.m_Context = Context
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="215" endline="233"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Context"></param>
     ''' <param name="IsRHS">Default = True</param>
     ''' <param name="IsExplicitConversion"></param>
     ''' <param name="DesiredType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Clone(ByVal Context As ParsedObject, ByVal IsRHS As Boolean, Optional ByVal IsExplicitConversion As Boolean = False, Optional ByVal DesiredType As Mono.Cecil.TypeReference = Nothing) As EmitInfo
         Dim result As New EmitInfo(Me)
         result.m_IsRHS = IsRHS
         result.m_IsExplicitConversion = IsExplicitConversion
         result.m_DesiredType = DesiredType
         result.m_RHSExpression = Nothing
         result.m_Context = Context
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="234" endline="241"><![CDATA[
 
     Function Clone(ByVal Context As ParsedObject, ByVal DesiredType As Mono.Cecil.TypeReference) As EmitInfo
         Dim result As New EmitInfo(Me)
         result.m_DesiredType = DesiredType
         result.m_RHSExpression = Nothing
         result.m_Context = Context
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="242" endline="254"><![CDATA[
 
     ''' <summary>
     ''' Create a new EmitInfo copying the values from the specified info.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Private Sub New(ByVal Info As EmitInfo)
         Me.m_DesiredType = Info.m_DesiredType
         Me.m_IsExplicitConversion = Info.m_IsExplicitConversion
         Me.m_IsRHS = Info.m_IsRHS
         Me.m_Method = Info.m_Method
         Me.m_RHSExpression = Info.m_RHSExpression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="29" endline="31"><![CDATA[
         Get
             Return CecilLocal.VariableType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="42" endline="47"><![CDATA[
         Get
             If m_CilWorker Is Nothing Then
                 m_CilWorker = m_CilBody.GetILProcessor
             End If
             Return m_CilWorker
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="48" endline="53"><![CDATA[
     End Property
 
     Property CilBody() As Mono.Cecil.Cil.MethodBody
         Get
             Return m_CilBody
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="54" endline="57"><![CDATA[
         Set(ByVal value As Mono.Cecil.Cil.MethodBody)
             m_CilBody = value
             m_CilWorker = Nothing
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="58" endline="63"><![CDATA[
     End Property
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="64" endline="68"><![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="69" endline="73"><![CDATA[
 
     Shared ReadOnly Property IsLogging() As Boolean
         Get
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="74" endline="82"><![CDATA[
     End Property
 
     Private Overloads Shared Function ToString(ByVal obj As Object) As String
         If obj Is Nothing Then
             Return "Nothing"
         Else
             Return "Type
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="83" endline="89"><![CDATA[
 
     <Diagnostics.Conditional("DEBUGEMIT")> _
     Private Sub Log(ByVal str As String)
 #If DEBUGEMIT Then
         m_Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Emitted
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="90" endline="96"><![CDATA[
 
     <Diagnostics.Conditional("DEBUGEMIT")> _
     Private Sub Log(ByVal str As String, ByVal ParamArray args() As String)
 #If DEBUGEMIT Then
         Log(String.Format(str, args))
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="97" endline="101"><![CDATA[
 
     Public Sub BeginExceptFilterBlock()
         Log("BeginExceptFilterBlock")
         BeginExceptFilterBlockCecil()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="102" endline="107"><![CDATA[
     Public Function BeginExceptionBlock() As Label
         Log("BeginExceptionBlock")
         Dim result As New Label
         result.CecilLabel = BeginExceptionBlockCecil()
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="108" endline="112"><![CDATA[
 
     Public Sub BeginFinallyBlock()
         Log("BeginFinallyBlock")
         BeginFinallyBlockCecil()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="113" endline="119"><![CDATA[
 
     Public Function DefineLabel() As Label
         Log("DefineLabel")
         Dim result As New Label
         result.CecilLabel = DefineLabelCecil()
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="120" endline="123"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal label As Label)
         Emit(opcode, label.CecilLabel)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="124" endline="132"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal labels() As Label)
         Dim tmpCecil As Mono.Cecil.Cil.Instruction()
         ReDim tmpCecil(labels.Length - 1)
         For i As Integer = 0 To labels.Length - 1
             tmpCecil(i) = labels(i).CecilLabel
         Next
         Emit(opcode, tmpCecil)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="133" endline="137"><![CDATA[
 
     Public Sub EndExceptionBlock()
         Log("EndExceptionBlock")
         EndExceptionBlockCecil()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="138" endline="141"><![CDATA[
 
     Public Sub MarkLabel(ByVal loc As Label)
         MarkLabel(loc.CecilLabel)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="142" endline="146"><![CDATA[
 
     Public Sub MarkSequencePoint(ByVal document As System.Diagnostics.SymbolStore.ISymbolDocumentWriter, ByVal startLine As Integer, ByVal startColumn As Integer, ByVal endLine As Integer, ByVal endColumn As Integer)
         Log("MarkSequencePoint({0},{1},{2},{3},{4}", CObj(document).ToString, startLine.ToString, startColumn.ToString, endLine.ToString, endColumn.ToString)
         'Throw New NotImplementedException
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="147" endline="198"><![CDATA[
 
     Private Class TryBlock
         Public Start As Integer
         Public EndBlock As Mono.Cecil.Cil.Instruction
         Public EndTry As Mono.Cecil.Cil.Instruction
         Public Handlers As New Generic.List(Of Mono.Cecil.Cil.ExceptionHandler)
 
         ReadOnly Property CurrentHandler() As Mono.Cecil.Cil.ExceptionHandler
             Get
                 If Handlers.Count = 0 Then
                     Return Nothing
                 Else
                     Return Handlers(Handlers.Count - 1)
                 End If
             End Get
         End Property
     End Class
 
     Private m_ExceptionBlocks As Generic.Stack(Of TryBlock)
 
     Public Sub BeginCatchBlock(ByVal exceptionType As Mono.Cecil.TypeReference)
         Log("BeginCatchBlock")
         Helper.Assert(Helper.IsEmittableMember(m_Compiler, exceptionType))
 
         If exceptionType Is Nothing Then
             Dim block As TryBlock = m_ExceptionBlocks.Peek
             Dim ex As Mono.Cecil.Cil.ExceptionHandler = block.Handlers(block.Handlers.Count - 1)
             CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Endfilter)
             ex.FilterEnd = CreateAndEmitNop()
             ex.HandlerStart = ex.FilterEnd
         Else
             Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Catch)
             Dim block As TryBlock = m_ExceptionBlocks.Peek
             CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
             Dim handlerStart As Integer = CilBody.Instructions.Count
             If block.Handlers.Count = 0 Then
                 ex.TryEnd = CreateAndEmitNop()
             Else
                 ex.TryEnd = block.Handlers(0).TryEnd
                 CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
             End If
             If block.EndTry Is Nothing Then
                 block.EndTry = ex.TryEnd
             End If
             If block.Handlers.Count > 0 Then
                 block.Handlers(block.Handlers.Count - 1).HandlerEnd = CilBody.Instructions(CilBody.Instructions.Count - 1) 'CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
             End If
             ex.HandlerStart = CilBody.Instructions(handlerStart)
             ex.CatchType = exceptionType
             block.Handlers.Add(ex)
             End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="199" endline="216"><![CDATA[
 
     Private Sub BeginExceptFilterBlockCecil()
         Log("BeginExceptFilterBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Filter)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
 
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.FilterStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.HandlerStart = ex.FilterStart
         block.Handlers.Add(ex)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="217" endline="228"><![CDATA[
 
     Private Function BeginExceptionBlockCecil() As Mono.Cecil.Cil.Instruction
         Log("BeginExceptionBlock")
         Dim block As New TryBlock
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
         block.Start = CilBody.Instructions.Count
         block.EndBlock = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         If m_ExceptionBlocks Is Nothing Then m_ExceptionBlocks = New Generic.Stack(Of TryBlock)
         m_ExceptionBlocks.Push(block)
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
         Return block.EndBlock
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="229" endline="245"><![CDATA[
 
     Private Sub BeginFinallyBlockCecil()
         Log("BeginFinallyBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Finally)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.HandlerStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.TryEnd = ex.HandlerStart
         block.Handlers.Add(ex)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="246" endline="273"><![CDATA[
 
     Public Sub EndExceptionBlockCecil()
         Log("EndExceptionBlock")
         Dim block As TryBlock = m_ExceptionBlocks.Pop
         If block.EndTry Is Nothing Then block.EndTry = CreateAndEmitNop()
 
         Dim TryStart As Mono.Cecil.Cil.Instruction
         TryStart = CilBody.Instructions(block.Start)
         If block.Handlers(block.Handlers.Count - 1).HandlerType = Mono.Cecil.Cil.ExceptionHandlerType.Finally Then
             CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Endfinally)
         End If
         For i As Integer = 0 To block.Handlers.Count - 1
             Dim handler As Mono.Cecil.Cil.ExceptionHandler
             handler = block.Handlers(i)
             handler.TryStart = TryStart
             If handler.TryEnd Is Nothing Then
                 handler.TryEnd = block.EndTry
             End If
             If handler.HandlerEnd Is Nothing Then
                 If handler.HandlerType <> Mono.Cecil.Cil.ExceptionHandlerType.Finally Then
                     CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
                 End If
                 handler.HandlerEnd = block.EndBlock
             End If
             CilBody.ExceptionHandlers.Add(handler)
         Next
         CilWorker.Append(block.EndBlock)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="274" endline="283"><![CDATA[
 
     Public Function DeclareLocal(ByVal localType As Mono.Cecil.TypeReference) As Mono.Cecil.Cil.VariableDefinition
         Helper.Assert(Helper.IsEmittableMember(Compiler, localType))
         Log("DeclareLocal({0})", localType.ToString)
         Dim local As Mono.Cecil.Cil.VariableDefinition
         local = New Mono.Cecil.Cil.VariableDefinition(localType)
         m_CilBody.Variables.Add(local)
         m_CilBody.InitLocals = True
         Return local
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290"><![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="291" endline="297"><![CDATA[
 
     Public Function CreateAndEmitNop() As Mono.Cecil.Cil.Instruction
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         CilWorker.Append(result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="298" endline="302"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode)
         Log("Emit({0})", opcode.ToString)
         CilWorker.Emit(opcode)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="303" endline="307"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal arg As Byte)
         Log("Emit({0},{1})", opcode.ToString, ToString(arg))
         CilWorker.Emit(opcode, arg)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="308" endline="312"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal arg As Double)
         Log("Emit({0},{1})", opcode.ToString, ToString(arg))
         CilWorker.Emit(opcode, arg)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="313" endline="317"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal arg As Integer)
         Log("Emit({0},{1})", opcode.ToString, ToString(arg))
         CilWorker.Emit(opcode, arg)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="318" endline="322"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal arg As Long)
         Log("Emit({0},{1})", opcode.ToString, ToString(arg))
         CilWorker.Emit(opcode, arg)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="323" endline="327"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal arg As SByte)
         Log("Emit({0},{1})", opcode.ToString, ToString(arg))
         CilWorker.Emit(opcode, arg)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="328" endline="332"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal arg As Short)
         Log("Emit({0},{1})", opcode.ToString, ToString(arg))
         CilWorker.Emit(opcode, arg)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="333" endline="337"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal arg As Single)
         Log("Emit({0},{1})", opcode.ToString, ToString(arg))
         CilWorker.Emit(opcode, arg)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="338" endline="342"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal str As String)
         Log("Emit({0},{1})", opcode.ToString, ToString(str))
         CilWorker.Emit(opcode, str)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="343" endline="348"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal con As Mono.Cecil.MethodReference)
         Helper.Assert(Helper.IsEmittableMember(Compiler, con))
         Log("Emit({0},{1})", opcode.ToString, ToString(con))
         CilWorker.Emit(opcode, con)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="349" endline="353"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal label As Mono.Cecil.Cil.Instruction)
         Log("Emit({0},{1})", opcode.ToString, ToString(label))
         CilWorker.Emit(opcode, label)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="354" endline="358"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal labels() As Mono.Cecil.Cil.Instruction)
         Log("Emit({0},{1})", opcode.ToString, ToString(labels))
         CilWorker.Emit(opcode, labels)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="359" endline="364"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal local As Mono.Cecil.Cil.VariableDefinition)
         Helper.Assert(local IsNot Nothing)
         Log("Emit({0},{1})", opcode.ToString, ToString(local))
         CilWorker.Emit(opcode, local)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="365" endline="370"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal field As Mono.Cecil.FieldReference)
         Helper.Assert(Helper.IsEmittableMember(Compiler, field))
         Log("Emit({0},{1})", opcode.ToString, ToString(field))
         CilWorker.Emit(opcode, field)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="371" endline="376"><![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal cls As Mono.Cecil.TypeReference)
         Helper.Assert(Helper.IsEmittableMember(Compiler, cls))
         Log("Emit({0},{1})", opcode.ToString, ToString(cls))
         CilWorker.Emit(opcode, cls)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="377" endline="387"><![CDATA[
 
     Public Sub EmitCall(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal methodInfo As Mono.Cecil.MethodReference, ByVal optionalParameterTypes() As Mono.Cecil.TypeReference)
         'Helper.Assert(Helper.IsEmittableMember(Compiler, methodInfo))
         Log("EmitCall({0},{1},{2})", opcode.ToString, ToString(methodInfo), ToString(optionalParameterTypes))
         'Helper.Assert(Helper.IsEmittableMember(Compiler, methodInfo.ReturnType.ReturnType))
         If optionalParameterTypes Is Nothing Then
             CilWorker.Emit(opcode, methodInfo)
         Else
             Throw New NotImplementedException("CilWorker.Append(CilWorker.Create(opcode, methodInfo, optionalParameterTypes))")
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="388" endline="392"><![CDATA[
 
     Public Sub MarkLabel(ByVal loc As Mono.Cecil.Cil.Instruction)
         Log("MarkLabel({0}", ToString(loc))
         CilWorker.Append(loc)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="393" endline="398"><![CDATA[
 
     Public Sub ThrowException(ByVal excType As Mono.Cecil.TypeReference)
         Helper.Assert(Helper.IsEmittableMember(Compiler, excType))
         Log("ThrowException({0})", ToString(excType))
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Throw, excType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.DecimalFields.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="29" endline="31"><![CDATA[
     Shared Function DefineLabel(ByVal Info As EmitInfo) As Label
         Return Info.ILGen.DefineLabel
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="32" endline="46"><![CDATA[
 
     Shared Sub MarkSequencePoint(ByVal Info As EmitInfo, ByVal Location As Span)
         If Location.File(Info.Compiler) Is Nothing Then Return
         If Location.Line <= 0 Then Return
 
         Dim s As Mono.Cecil.Cil.SequencePoint
         Dim instr As Mono.Cecil.Cil.Instruction
         s = New Mono.Cecil.Cil.SequencePoint(Location.File(Info.Compiler).SymbolDocument)
         instr = Info.ILGen.CreateAndEmitNop()
         instr.SequencePoint = s
         s.StartLine = CInt(Location.Line)
         s.StartColumn = Location.Column
         s.EndLine = CInt(Location.Line)
         s.EndColumn = Location.EndColumn
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="47" endline="61"><![CDATA[
 
     Shared Function DeclareLocal(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference, Optional ByVal Name As String = "") As Mono.Cecil.Cil.VariableDefinition
         Dim result As Mono.Cecil.Cil.VariableDefinition
         Helper.Assert(Info IsNot Nothing)
         Helper.Assert(Info.ILGen IsNot Nothing)
 
         Type = Helper.GetTypeOrTypeReference(Info.Compiler, Type)
         result = Info.ILGen.DeclareLocal(Type)
 
         If Name <> String.Empty AndAlso Info.Compiler.EmittingDebugInfo Then
             result.Name = Name
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="62" endline="65"><![CDATA[
 
     Shared Sub FreeLocal(ByVal Local As Mono.Cecil.Cil.VariableDefinition)
         'local variable reuse not implemented yet.
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="66" endline="69"><![CDATA[
 
     Shared Sub MarkLabel(ByVal Info As EmitInfo, ByVal Label As Label)
         Info.ILGen.MarkLabel(Label)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="70" endline="75"><![CDATA[
 
     Shared Sub EmitBeginExceptionFilter(ByVal Info As EmitInfo)
         Helper.Assert(Info.InExceptionFilter = False)
         Info.ILGen.BeginExceptFilterBlock()
         Info.InExceptionFilter = True
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="76" endline="81"><![CDATA[
 
     Shared Sub EmitBeginCatch(ByVal Info As EmitInfo, ByVal ExceptionType As Mono.Cecil.TypeReference)
         If ExceptionType IsNot Nothing Then ExceptionType = Helper.GetTypeOrTypeReference(Info.Compiler, ExceptionType)
         Info.ILGen.BeginCatchBlock(ExceptionType)
         Info.InExceptionFilter = False
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="82" endline="86"><![CDATA[
 
     Shared Sub EmitEndExceptionBlock(ByVal Info As EmitInfo)
         Helper.Assert(Info.InExceptionFilter = False)
         Info.ILGen.EndExceptionBlock()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="87" endline="93"><![CDATA[
 
     Shared Function EmitBeginExceptionBlock(ByVal Info As EmitInfo) As Label
         Helper.Assert(Info.InExceptionFilter = False)
         Dim result As Label
         result = Info.ILGen.BeginExceptionBlock
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="94" endline="97"><![CDATA[
 
     Shared Sub EmitBeginFinallyBlock(ByVal Info As EmitInfo)
         Info.ILGen.BeginFinallyBlock()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="98" endline="102"><![CDATA[
 
     <Obsolete("Do not use this!")> Shared ReadOnly Property Compiler() As Compiler
         Get
             Throw New InternalException("")
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="103" endline="108"><![CDATA[
     End Property
 
     Shared Sub EmitPop(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Type = Helper.GetTypeOrTypeReference(Info.Compiler, Type)
         Info.ILGen.Emit(OpCodes.Pop)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="109" endline="112"><![CDATA[
 
     Shared Sub EmitBranchIfFalse(ByVal Info As EmitInfo, ByVal Label As Label)
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Brfalse, Label)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="113" endline="116"><![CDATA[
 
     Shared Sub EmitBranchIfTrue(ByVal Info As EmitInfo, ByVal Label As Label)
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Brtrue, Label)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="117" endline="122"><![CDATA[
 
     Shared Sub EmitBranchIfTrue(ByVal Info As EmitInfo, ByVal Label As Label, ByVal Type As Mono.Cecil.TypeReference)
         Type = Helper.GetTypeOrTypeReference(Info.Compiler, Type)
         Helper.Assert(Helper.CompareType(Type, Info.Compiler.TypeCache.System_Boolean) OrElse CecilHelper.IsClass(Type) OrElse CecilHelper.IsInterface(Type))
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Brtrue, Label)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="123" endline="126"><![CDATA[
 
     Shared Sub EmitBranch(ByVal Info As EmitInfo, ByVal Label As Label)
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Br, Label)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="127" endline="134"><![CDATA[
 
     Shared Sub EmitBranchOrLeave(ByVal Info As EmitInfo, ByVal Label As Label, ByVal FromStatement As Statement, ByVal ToStatement As Statement)
         If IsLeaveNecessary(FromStatement, ToStatement) Then
             EmitLeave(Info, Label)
         Else
             EmitBranch(Info, Label)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="135" endline="138"><![CDATA[
 
     Shared Sub EmitLeave(ByVal Info As EmitInfo, ByVal Label As Label)
         Info.ILGen.Emit(OpCodes.Leave, Label)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="139" endline="143"><![CDATA[
 
     Shared Sub EmitSub(ByVal Info As EmitInfo, ByVal SubType As Mono.Cecil.TypeReference)
         SubType = Helper.GetTypeOrTypeReference(Info.Compiler, SubType)
         Info.ILGen.Emit(OpCodes.Sub)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="144" endline="148"><![CDATA[
 
     Shared Sub EmitSubOvf(ByVal Info As EmitInfo, ByVal SubType As Mono.Cecil.TypeReference)
         SubType = Helper.GetTypeOrTypeReference(Info.Compiler, SubType)
         Info.ILGen.Emit(OpCodes.Sub_Ovf)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="149" endline="153"><![CDATA[
 
     Shared Sub EmitSubOvfUn(ByVal Info As EmitInfo, ByVal SubType As Mono.Cecil.TypeReference)
         SubType = Helper.GetTypeOrTypeReference(Info.Compiler, SubType)
         Info.ILGen.Emit(OpCodes.Sub_Ovf_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="154" endline="161"><![CDATA[
 
     Shared Sub EmitSubOrSubOvfOrSubOvfUn(ByVal Info As EmitInfo, ByVal SubType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitSubOvf(Info, SubType)
         Else
             EmitSub(Info, SubType)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="162" endline="166"><![CDATA[
 
     Shared Sub EmitOr(ByVal Info As EmitInfo, ByVal OrType As Mono.Cecil.TypeReference)
         OrType = Helper.GetTypeOrTypeReference(Info.Compiler, OrType)
         Info.ILGen.Emit(OpCodes.Or)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="167" endline="171"><![CDATA[
 
     Shared Sub EmitAnd(ByVal Info As EmitInfo, ByVal AndType As Mono.Cecil.TypeReference)
         AndType = Helper.GetTypeOrTypeReference(Info.Compiler, AndType)
         Info.ILGen.Emit(OpCodes.And)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="172" endline="176"><![CDATA[
 
     Shared Sub EmitXOr(ByVal Info As EmitInfo, ByVal XorType As Mono.Cecil.TypeReference)
         XorType = Helper.GetTypeOrTypeReference(Info.Compiler, XorType)
         Info.ILGen.Emit(OpCodes.Xor)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="177" endline="181"><![CDATA[
 
     Shared Sub EmitNot(ByVal Info As EmitInfo, ByVal NotType As Mono.Cecil.TypeReference)
         NotType = Helper.GetTypeOrTypeReference(Info.Compiler, NotType)
         Info.ILGen.Emit(OpCodes.Not)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="182" endline="186"><![CDATA[
 
     Shared Sub EmitMod(ByVal Info As EmitInfo, ByVal ModType As Mono.Cecil.TypeReference)
         ModType = Helper.GetTypeOrTypeReference(Info.Compiler, ModType)
         Info.ILGen.Emit(OpCodes.[Rem])
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="187" endline="191"><![CDATA[
 
     Shared Sub EmitEquals(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="192" endline="198"><![CDATA[
 
     Shared Sub EmitNotEquals(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Ceq)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="199" endline="205"><![CDATA[
 
     Shared Sub EmitGE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Clt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="206" endline="211"><![CDATA[
 
     Shared Sub EmitGE_Un(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         Info.ILGen.Emit(OpCodes.Clt_Un)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="212" endline="216"><![CDATA[
 
     Shared Sub EmitGT(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Cgt)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="217" endline="221"><![CDATA[
 
     Shared Sub EmitGT_Un(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Cgt_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="222" endline="228"><![CDATA[
 
     Shared Sub EmitLE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Cgt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="229" endline="234"><![CDATA[
 
     Shared Sub EmitLE_Un(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         Info.ILGen.Emit(OpCodes.Cgt_Un)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="235" endline="238"><![CDATA[
 
     Shared Sub EmitLT_Un(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         Info.ILGen.Emit(OpCodes.Clt_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="239" endline="243"><![CDATA[
 
     Shared Sub EmitLT(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Clt)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="244" endline="248"><![CDATA[
 
     Shared Sub EmitAdd(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         OperandType = Helper.GetTypeOrTypeBuilder(Info.Compiler, OperandType)
         Info.ILGen.Emit(OpCodes.Add)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="249" endline="256"><![CDATA[
 
     Shared Sub EmitAddOrAddOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitAddOvf(Info, OperandType)
         Else
             EmitAdd(Info, OperandType)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="257" endline="261"><![CDATA[
 
     Shared Sub EmitAddOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         OperandType = Helper.GetTypeOrTypeBuilder(Info.Compiler, OperandType)
         Info.ILGen.Emit(OpCodes.Add_Ovf)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="262" endline="266"><![CDATA[
 
     Shared Sub EmitMult(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         OperandType = Helper.GetTypeOrTypeBuilder(Info.Compiler, OperandType)
         Info.ILGen.Emit(OpCodes.Mul)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="267" endline="271"><![CDATA[
 
     Shared Sub EmitMultOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         OperandType = Helper.GetTypeOrTypeBuilder(Info.Compiler, OperandType)
         Info.ILGen.Emit(OpCodes.Mul_Ovf)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="272" endline="279"><![CDATA[
 
     Shared Sub EmitMultOrMultOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitMultOvf(Info, OperandType)
         Else
             EmitMult(Info, OperandType)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="280" endline="283"><![CDATA[
 
     Shared Sub EmitIs(ByVal Info As EmitInfo)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="284" endline="288"><![CDATA[
 
     Shared Sub EmitRShift(ByVal Info As EmitInfo, ByVal OpType As Mono.Cecil.TypeReference)
         OpType = Helper.GetTypeOrTypeBuilder(Info.Compiler, OpType)
         Info.ILGen.Emit(OpCodes.Shr)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="289" endline="293"><![CDATA[
 
     Shared Sub EmitLShift(ByVal Info As EmitInfo, ByVal OpType As Mono.Cecil.TypeReference)
         OpType = Helper.GetTypeOrTypeBuilder(Info.Compiler, OpType)
         Info.ILGen.Emit(OpCodes.Shl)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="294" endline="298"><![CDATA[
 
     Shared Sub EmitIntDiv(ByVal Info As EmitInfo, ByVal OpType As Mono.Cecil.TypeReference)
         OpType = Helper.GetTypeOrTypeBuilder(Info.Compiler, OpType)
         Info.ILGen.Emit(OpCodes.Div)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="299" endline="303"><![CDATA[
 
     Shared Sub EmitRealDiv(ByVal Info As EmitInfo, ByVal OpType As Mono.Cecil.TypeReference)
         OpType = Helper.GetTypeOrTypeBuilder(Info.Compiler, OpType)
         Info.ILGen.Emit(OpCodes.Div)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="304" endline="309"><![CDATA[
 
     Shared Sub EmitIsNot(ByVal Info As EmitInfo)
         Info.ILGen.Emit(OpCodes.Ceq)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="310" endline="313"><![CDATA[
 
     Shared Sub EmitDup(ByVal Info As EmitInfo)
         Info.ILGen.Emit(OpCodes.Dup)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="314" endline="335"><![CDATA[
 
     ''' <summary>
     ''' Loads a pointer to the specified method onto the stack.
     ''' Loads either a Lftfn or Ldvirtftn, according to the static 
     ''' state of the method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVftn(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Dim methodinf As Mono.Cecil.MethodReference = Method '= TryCast(Method, Mono.Cecil.MethodReference)
         If methodinf IsNot Nothing Then
             methodinf = Helper.GetMethodOrMethodReference(Info.Compiler, methodinf)
             If CecilHelper.FindDefinition(methodinf).IsStatic Then
                 Info.ILGen.Emit(OpCodes.Ldftn, methodinf)
             Else
                 Info.ILGen.Emit(OpCodes.Ldvirtftn, methodinf)
             End If
         Else
             Helper.Stop()
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="336" endline="340"><![CDATA[
 
     Shared Sub EmitInitObj(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Type = Helper.GetTypeOrTypeBuilder(Info.Compiler, Type)
         Info.ILGen.Emit(OpCodes.Initobj, Type)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="341" endline="344"><![CDATA[
 
     Shared Sub EmitNeg(ByVal Info As EmitInfo)
         Info.ILGen.Emit(OpCodes.Neg)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="345" endline="357"><![CDATA[
 
     ''' <summary>
     ''' Emit a newobj.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Constructor"></param>
     ''' <remarks></remarks>
     Shared Sub EmitNew(ByVal Info As EmitInfo, ByVal Constructor As Mono.Cecil.MethodReference)
         Dim vOriginalConstructor As Mono.Cecil.MethodReference = Constructor
         Helper.Assert(Constructor IsNot Nothing)
         Constructor = CecilHelper.MakeEmittable(Constructor)
         Info.ILGen.Emit(OpCodes.Newobj, Constructor)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="358" endline="364"><![CDATA[
 
     Shared Sub EmitCastClass(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Helper.Assert(CecilHelper.IsByRef(ToType) = False)
         Info.ILGen.Emit(OpCodes.Castclass, ToType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="365" endline="372"><![CDATA[
 
     Shared Sub EmitIsInst(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         Dim toOriginal As Mono.Cecil.TypeReference = ToType
 
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Info.ILGen.Emit(OpCodes.Isinst, ToType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="373" endline="393"><![CDATA[
 
     Shared Sub EmitValueTypeToObjectConversion(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         'Dim FromType As Type = Info.Stack.Peek
         Dim FromTP, ToTP As TypeCode
 
         FromTP = Helper.GetTypeCode(Info.Compiler, FromType)
         ToTP = Helper.GetTypeCode(Info.Compiler, ToType)
 
         Helper.Assert(ToTP = TypeCode.Object)
 
         If CecilHelper.IsByRef(ToType) AndAlso Helper.CompareType(CecilHelper.GetElementType(ToType), FromType) Then
             Dim localvar As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, FromType)
             Emitter.EmitStoreVariable(Info, localvar)
             Emitter.EmitLoadVariableLocation(Info, localvar)
         ElseIf Helper.IsEnum(Info.Compiler, CecilHelper.FindDefinition(FromType).BaseType) AndAlso Helper.CompareType(ToType, Info.Compiler.TypeCache.System_Enum) Then
 
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="394" endline="398"><![CDATA[
 
     Shared Sub EmitConv_U1(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_U1)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="399" endline="403"><![CDATA[
 
     Shared Sub EmitConv_U1_Overflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_U1)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="404" endline="408"><![CDATA[
 
     Shared Sub EmitConv_U1_Overflow_Underflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_U1_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="409" endline="413"><![CDATA[
 
     Shared Sub EmitConv_I1(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_I1)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="414" endline="418"><![CDATA[
 
     Shared Sub EmitConv_I1_Overflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_I1)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="419" endline="423"><![CDATA[
 
     Shared Sub EmitConv_I1_Overflow_Underflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_I1_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="424" endline="428"><![CDATA[
 
     Shared Sub EmitConv_U2(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_U2)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="429" endline="433"><![CDATA[
 
     Shared Sub EmitConv_U2_Overflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_U2)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="434" endline="438"><![CDATA[
 
     Shared Sub EmitConv_U2_Overflow_Underflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_U2_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="439" endline="443"><![CDATA[
 
     Shared Sub EmitConv_I2(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_I2)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="444" endline="448"><![CDATA[
 
     Shared Sub EmitConv_I2_Overflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_I2)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="449" endline="453"><![CDATA[
 
     Shared Sub EmitConv_I2_Overflow_Underflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_I2_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="454" endline="458"><![CDATA[
 
     Shared Sub EmitConv_U4(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_U4)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="459" endline="463"><![CDATA[
 
     Shared Sub EmitConv_U4_Overflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_U4)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="464" endline="468"><![CDATA[
 
     Shared Sub EmitConv_U4_Overflow_Underflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_U4_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="469" endline="473"><![CDATA[
 
     Shared Sub EmitConv_I4(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_I4)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="474" endline="478"><![CDATA[
 
     Shared Sub EmitConv_I4_Overflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_I4)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="479" endline="483"><![CDATA[
 
     Shared Sub EmitConv_I4_Overflow_Underflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_I4_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="484" endline="488"><![CDATA[
 
     Shared Sub EmitConv_U8(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_U8)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="489" endline="493"><![CDATA[
 
     Shared Sub EmitConv_U8_Overflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_U8)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="494" endline="498"><![CDATA[
 
     Shared Sub EmitConv_U8_Overflow_Underflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_U8_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="499" endline="503"><![CDATA[
 
     Shared Sub EmitConv_I8(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_I8)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="504" endline="508"><![CDATA[
 
     Shared Sub EmitConv_I8_Overflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_I8)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="509" endline="513"><![CDATA[
 
     Shared Sub EmitConv_I8_Overflow_Underflow(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_Ovf_I8_Un)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="514" endline="518"><![CDATA[
 
     Shared Sub EmitConv_R8(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_R8)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="519" endline="523"><![CDATA[
 
     Shared Sub EmitConv_R4(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         Info.ILGen.Emit(OpCodes.Conv_R4)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="524" endline="825"><![CDATA[
 
     ''' <summary>
     ''' Convert the value on the stack to ToType.
     ''' </summary>
     ''' <param name="ToType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitConversion(ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference, ByVal Info As EmitInfo)
         Dim ToTypeOriginal, FromTypeOriginal As Mono.Cecil.TypeReference
 
         If Helper.CompareType(FromType, Info.Compiler.TypeCache.Nothing) Then Return
 
         ToTypeOriginal = ToType
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
 
         'Dim FromType As Type = Info.Stack.Peek
         Dim FromTP, ToTP As TypeCode
         Dim converted As Boolean = False
 
         FromTypeOriginal = FromType
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
 
         FromTP = Helper.GetTypeCode(Info.Compiler, FromType)
         ToTP = Helper.GetTypeCode(Info.Compiler, ToType)
 
 #If DEBUGIMPLICITCONVERSION Then
                     		If FromTP <> ToTP OrElse FromTP = TypeCode.Object OrElse ToTP = TypeCode.Object Then
                     			Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, String.Format("Converting from '{0}' to '{1}'.", FromTP.ToString, ToTP.ToString))
                     		End If
 #End If
 
         If ToTP = TypeCode.Object AndAlso FromTP <> TypeCode.Object AndAlso Helper.CompareType(ToType, Info.Compiler.TypeCache.System_Object) = False Then
             EmitValueTypeToObjectConversion(Info, FromType, ToType)
             Return
         End If
 
         Dim Switch As TypeCombinations = Helper.GetCombination(FromTP, ToTP)
 
         Select Case Switch
             Case TypeCombinations.Boolean_Boolean, _
              TypeCombinations.Byte_Byte, _
               TypeCombinations.Char_Char, _
                TypeCombinations.DateTime_DateTime, _
                 TypeCombinations.Decimal_Decimal, _
                  TypeCombinations.Double_Double, _
                   TypeCombinations.Empty_Empty, _
                    TypeCombinations.Int16_Int16, _
                     TypeCombinations.Int32_Int32, _
                      TypeCombinations.Int64_Int64, _
                        TypeCombinations.SByte_SByte, _
                         TypeCombinations.Single_Single, _
                          TypeCombinations.String_String, _
                           TypeCombinations.UInt16_UInt16, _
                            TypeCombinations.UInt32_UInt32, _
                             TypeCombinations.UInt64_UInt64
                 Return 'Nothing to convert, both types are equal
             Case TypeCombinations.Object_Object
                 Dim tmpTo, tmpFrom As Mono.Cecil.TypeReference
                 If Info.IsExplicitConversion = False Then
                     'If TypeOf FromType Is TypeDescriptor Then
                     '    tmpFrom = DirectCast(FromType, TypeDescriptor).TypeInReflection
                     'Else
                     '    tmpFrom = FromType
                     'End If
                     tmpFrom = FromTypeOriginal
                     'If TypeOf ToTypeIn Is TypeDescriptor Then
                     '    tmpTo = DirectCast(ToType, TypeDescriptor).TypeInReflection
                     'Else
                     tmpTo = ToTypeOriginal
                     '               End If
                     If Helper.CompareType(tmpTo, tmpFrom) Then
                         converted = True
                     ElseIf Helper.IsAssignable(Info.Context, tmpFrom, tmpTo) Then
                         converted = True
                     Else
                         converted = True
                         Info.Compiler.Report.WriteLine(Report.ReportLevels.Debug, "The compiler supposes a conversion from " & tmpFrom.Name & " to " & tmpTo.Name & " is valid.")
                     End If
                 Else
                     Info.ILGen.Emit(OpCodes.Castclass, ToType)
                     'Emitter.EmitCastClass(Info, FromType, ToType)
                     converted = True
                 End If
                 ' ToSByte conversions
             Case TypeCombinations.Byte_SByte
                 If Info.IsExplicitConversion Then
                     If Info.IntegerOverflowChecks Then
                         Info.ILGen.Emit(OpCodes.Conv_Ovf_I1_Un) 
                     Else
                         Info.ILGen.Emit(OpCodes.Conv_I1)
                     End If
                 Else
                     Helper.Stop()
                 End If
             Case TypeCombinations.Int16_SByte
             Case TypeCombinations.UInt16_SByte
             Case TypeCombinations.Int32_SByte
                 If Info.IsExplicitConversion Then
                     If Info.IntegerOverflowChecks Then
                         Info.ILGen.Emit(OpCodes.Conv_Ovf_I1) 
                     Else
                         Info.ILGen.Emit(OpCodes.Conv_I1) 
                     End If
                 Else
                     Helper.Stop()
                 End If
             Case TypeCombinations.UInt32_SByte
             Case TypeCombinations.Int64_SByte
             Case TypeCombinations.UInt64_SByte
             Case TypeCombinations.Single_SByte
             Case TypeCombinations.Double_SByte
             Case TypeCombinations.Decimal_SByte
 
                 'ToByte conversions
             Case TypeCombinations.SByte_Byte, _
               TypeCombinations.Int16_Byte, _
               TypeCombinations.Int32_Byte, _
               TypeCombinations.Int64_Byte
                 If Info.IsExplicitConversion Then
                     If Info.IntegerOverflowChecks Then
                         Info.ILGen.Emit(OpCodes.Conv_Ovf_U1) 
                     Else
                         Info.ILGen.Emit(OpCodes.Conv_U1) 
                     End If
                 Else
                     Helper.Stop()
                 End If
             Case TypeCombinations.UInt16_Byte
             Case TypeCombinations.UInt32_Byte
             Case TypeCombinations.UInt64_Byte
             Case TypeCombinations.Single_Byte
             Case TypeCombinations.Double_Byte
             Case TypeCombinations.Decimal_Byte
 
                 'ToUInt64 conversions
             Case TypeCombinations.Byte_UInt16
                 Info.ILGen.Emit(OpCodes.Conv_U2)
                 converted = True
 
                 'ToInt16 conversions
             Case TypeCombinations.Byte_Int16, _
              TypeCombinations.SByte_Int16
                 Info.ILGen.Emit(OpCodes.Conv_I2)
                 converted = True
 
 
                 'ToUInt32 conversions
             Case TypeCombinations.Byte_UInt32, _
                TypeCombinations.UInt16_UInt32
                 Info.ILGen.Emit(OpCodes.Conv_U4)
                 converted = True
 
                 'ToInt32 conversions
             Case TypeCombinations.SByte_Int32, _
                  TypeCombinations.Byte_Int32, _
                  TypeCombinations.UInt16_Int32, _
                  TypeCombinations.Int16_Int32
                 Info.ILGen.Emit(OpCodes.Conv_I4)
                 converted = True
             Case TypeCombinations.Object_Int32
                 'Narrowing conversion
                 If Info.IsExplicitConversion = False Then
                     Helper.AddError(Info.Context)
                 Else
                     Emitter.EmitUnbox(Info, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int32))
                     Emitter.EmitLdobj(Info, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int32))
                     converted = True
                 End If
 
                 'ToInt64 conversions
             Case TypeCombinations.Byte_Int64, _
               TypeCombinations.SByte_Int64, _
                TypeCombinations.UInt16_Int64, _
                 TypeCombinations.Int16_Int64, _
                  TypeCombinations.UInt32_Int64, _
                   TypeCombinations.Int32_Int64
                 Info.ILGen.Emit(OpCodes.Conv_I8)
                 converted = True
 
                 'ToUInt64 conversions
             Case TypeCombinations.Byte_UInt64, _
                   TypeCombinations.UInt16_UInt64, _
                    TypeCombinations.UInt32_UInt64
                 Info.ILGen.Emit(OpCodes.Conv_U8)
                 converted = True
 
                 'ToSingle conversions
             Case TypeCombinations.SByte_Single, _
                   TypeCombinations.Byte_Single, _
                    TypeCombinations.UInt16_Single, _
                     TypeCombinations.Int16_Single, _
                      TypeCombinations.UInt32_Single, _
                       TypeCombinations.Int32_Single, _
                        TypeCombinations.UInt64_Single, _
                         TypeCombinations.Int64_Single
                 Info.ILGen.Emit(OpCodes.Conv_R4)
                 converted = True
             Case TypeCombinations.Decimal_Single
                 Info.ILGen.Emit(OpCodes.Call, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Convert__ToSingle_Decimal))
                 converted = True
 
                 'ToDouble conversions
             Case TypeCombinations.Decimal_Double
                 Info.ILGen.Emit(OpCodes.Call, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Convert__ToDouble_Decimal))
                 converted = True
             Case TypeCombinations.SByte_Double, _
                   TypeCombinations.Byte_Double, _
                    TypeCombinations.UInt16_Double, _
                     TypeCombinations.Int16_Double, _
                      TypeCombinations.UInt32_Double, _
                       TypeCombinations.Int32_Double, _
                        TypeCombinations.UInt64_Double, _
                         TypeCombinations.Int64_Double, _
                          TypeCombinations.Single_Double
                 Info.ILGen.Emit(OpCodes.Conv_R8)
                 converted = True
 
                 'ToDecimal conversions
             Case TypeCombinations.Byte_Decimal, _
              TypeCombinations.SByte_Decimal, _
              TypeCombinations.Int16_Decimal
                 Info.ILGen.Emit(OpCodes.Conv_I4)
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int32))
                 converted = True
             Case TypeCombinations.UInt16_Decimal, _
                TypeCombinations.UInt32_Decimal
                 Info.ILGen.Emit(OpCodes.Conv_I8)
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int64))
                 converted = True
             Case TypeCombinations.Int32_Decimal
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int32))
                 converted = True
             Case TypeCombinations.UInt64_Decimal
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_UInt64))
                 converted = True
             Case TypeCombinations.Int64_Decimal
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int64))
                 converted = True
 
                 'ToObject conversions
             Case TypeCombinations.SByte_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_SByte))
                 converted = True
             Case TypeCombinations.Byte_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Byte))
                 converted = True
             Case TypeCombinations.Int16_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int16))
                 converted = True
             Case TypeCombinations.UInt16_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_UInt16))
                 converted = True
             Case TypeCombinations.Int32_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int32))
                 converted = True
             Case TypeCombinations.UInt32_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_UInt32))
                 converted = True
             Case TypeCombinations.Int64_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int64))
                 converted = True
             Case TypeCombinations.UInt64_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_UInt64))
                 converted = True
             Case TypeCombinations.Single_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Single))
                 converted = True
             Case TypeCombinations.Double_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Double))
                 converted = True
             Case TypeCombinations.String_Object
                 converted = True
             Case TypeCombinations.Decimal_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal))
                 converted = True
             Case TypeCombinations.DateTime_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_DateTime))
                 converted = True
             Case TypeCombinations.Boolean_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Boolean))
                 converted = True
             Case TypeCombinations.Char_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Char))
                 converted = True
             Case TypeCombinations.DBNull_Object
                 converted = True 'Nothing to object
             Case TypeCombinations.Object_String
                 Emitter.EmitCastClass(Info, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Object), Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_String))
                 converted = True
             Case TypeCombinations.Int32_Boolean
                 'Nothing to do here
                 converted = True
             Case Else
                 Info.Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Missed option
                 Info.Compiler.Report.WriteLine(Report.ReportLevels.Debug, Info.Method.Location.ToString(Info.Compiler))
                 Helper.Stop()
         End Select
 
         If Not converted Then
             Info.Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Skipped option
             Helper.Stop()
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="826" endline="835"><![CDATA[
 
     ''' <summary>
     ''' Loads Me onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadMe(ByVal Info As EmitInfo, ByVal TypeOfMe As Mono.Cecil.TypeReference)
         TypeOfMe = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeOfMe)
         Info.ILGen.Emit(OpCodes.Ldarg_0)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="836" endline="866"><![CDATA[
 
     Shared Sub EmitCall(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Dim OriginalMethod As Mono.Cecil.MethodReference = Method
 
         Helper.Assert(Method IsNot Nothing, "The method Is Nothing")
 
         Dim minfo As Mono.Cecil.MethodReference
         Dim mD As Mono.Cecil.MethodDefinition
 
         minfo = SwitchVersionedMethods(Info, Method)
         minfo = Helper.GetMethodOrMethodReference(Info.Compiler, minfo)
 
         If minfo.OriginalMethod Is Nothing Then
             minfo.OriginalMethod = Method.OriginalMethod
         End If
 
         mD = CecilHelper.FindDefinition(minfo)
 
         minfo = CecilHelper.MakeEmittable(minfo)
 
         If mD Is Nothing Then
             Info.ILGen.Emit(OpCodes.Callvirt, minfo)
         ElseIf mD.IsStatic Then
             Info.ILGen.Emit(OpCodes.Call, minfo)
         ElseIf CecilHelper.IsValueType(Method.DeclaringType) Then
             Info.ILGen.Emit(OpCodes.Call, minfo)
         Else
             Info.ILGen.Emit(OpCodes.Call, minfo)
         End If
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="867" endline="878"><![CDATA[
 
     Shared Sub EmitCallOrCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Helper.Assert(Method IsNot Nothing)
         Dim mD As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(Method)
         If mD Is Nothing AndAlso TypeOf Method.DeclaringType Is Mono.Cecil.ArrayType AndAlso (Method.Name = "Get" OrElse Method.Name = "Set") Then
             EmitCall(Info, Method)
         ElseIf mD.IsStatic OrElse CecilHelper.IsValueType(Method.DeclaringType) Then
             EmitCall(Info, Method)
         Else
             EmitCallVirt(Info, Method)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="879" endline="884"><![CDATA[
 
     Shared Sub EmitLoadToken(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Type = Helper.GetTypeOrTypeBuilder(Info.Compiler, Type)
         Helper.Assert(Type IsNot Nothing)
         Info.ILGen.Emit(OpCodes.Ldtoken, Type)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="885" endline="893"><![CDATA[
 
 
     Shared Sub EmitConstrained(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Dim OriginalType As Mono.Cecil.TypeReference = Type
 
         Type = Helper.GetTypeOrTypeBuilder(Info.Compiler, Type)
 
         Info.ILGen.Emit(OpCodes.Constrained, Type)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="894" endline="910"><![CDATA[
 
     ''' <summary>
     ''' Emits a constrained callvirt instructions. 
     ''' Throws an exception if the method is a shared method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitConstrainedCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference, ByVal ConstrainedType As Mono.Cecil.TypeReference)
         Dim OriginalMethod As Mono.Cecil.MethodReference = Method
 
         Helper.Assert(Method IsNot Nothing)
         Helper.Assert(ConstrainedType IsNot Nothing)
 
         EmitConstrained(Info, ConstrainedType)
         EmitCallVirt(Info, Method)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="911" endline="930"><![CDATA[
 
     ''' <summary>
     ''' Emits a callvirt instructions. 
     ''' Throws an exception if the method is a shared method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Dim OriginalMethod As Mono.Cecil.MethodReference = Method
         Dim mD As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then
             Method = Helper.GetMethodOrMethodReference(Info.Compiler, Method)
             Method = SwitchVersionedMethods(Info, Method)
             Method = CecilHelper.MakeEmittable(Method)
         End If
 
         Info.ILGen.EmitCall(OpCodes.Callvirt, Method, Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="931" endline="935"><![CDATA[
 
     Shared Sub EmitNewArr(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Type = Helper.GetTypeOrTypeBuilder(Info.Compiler, Type)
         Info.ILGen.Emit(OpCodes.Newarr, Type)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="936" endline="941"><![CDATA[
 
     Shared Sub EmitLoadElementAddress(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldelema, ElementType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="942" endline="974"><![CDATA[
 
     Shared Sub EmitLoadElement(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldelem_U1)
             Case TypeCode.SByte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldelem_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldelem_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldelem_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldelem_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldelem_I4)
             Case TypeCode.UInt64, TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldelem_R8)
             Case TypeCode.Object, TypeCode.String, TypeCode.DateTime, TypeCode.Decimal
                 If CecilHelper.IsValueType(ElementType) Then
                     Throw New InternalException("")
                 Else
                     Info.ILGen.Emit(OpCodes.Ldelem_Ref)
                 End If
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="975" endline="1007"><![CDATA[
 
     Shared Sub LoadElement(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldelem_U1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldelem_U2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldelem_U4)
             Case TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.SByte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldelem_I1)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldelem_I2)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldelem_I4)
             Case TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldelem_R8)
             Case TypeCode.DateTime, TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Ldelema, ElementType)
                 Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Ldelem_Ref)
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1008" endline="1048"><![CDATA[
 
 
     ''' <summary>
     ''' Type = the type of the element. (not of the array.)
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreElement(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Int32, TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Stelem_I4)
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Stelem_I1)
             Case TypeCode.Int16, TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Stelem_I2)
             Case TypeCode.Int64, TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Stelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Stelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Stelem_R8)
             Case TypeCode.DateTime, TypeCode.Decimal
                 EmitStoreObject(Info, ElementType)
                 Return
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Stelem_Ref)
             Case TypeCode.Object
                 If CecilHelper.IsValueType(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stobj, ElementType)
                 ElseIf CecilHelper.IsGenericParameter(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stelem_Any, ElementType)
                 Else
                     Info.ILGen.Emit(OpCodes.Stelem_Ref)
                 End If
             Case Else
                 Helper.Stop()
         End Select
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1049" endline="1059"><![CDATA[
 
     ''' <summary>
     ''' Emits a Stobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Stobj, ElementType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1060" endline="1070"><![CDATA[
 
     ''' <summary>
     ''' Emits a Ldobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1071" endline="1082"><![CDATA[
     ''' <summary>
     ''' Creates a new array and the new array reference is loaded at the top of the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <param name="Elements"></param>
     ''' <remarks></remarks>
     Shared Sub CreateArray(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal Elements As Integer)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         EmitLoadValue(Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32), Elements)
         EmitNewArr(Info, ElementType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1083" endline="1088"><![CDATA[
 
 
     Shared Sub EmitLoadI8Value(ByVal Info As EmitInfo, ByVal I As ULong, ByVal TypeToPushOnStack As Mono.Cecil.TypeReference)
         TypeToPushOnStack = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeToPushOnStack)
         EmitLoadI8Value(Info, BitConverter.ToInt64(BitConverter.GetBytes(I), 0), TypeToPushOnStack)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1089" endline="1092"><![CDATA[
 
     Shared Sub EmitLoadI8Value(ByVal Info As EmitInfo, ByVal I As ULong)
         EmitLoadI8Value(Info, BitConverter.ToInt64(BitConverter.GetBytes(I), 0), Info.Compiler.TypeCache.System_UInt64)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1093" endline="1096"><![CDATA[
 
     Shared Sub EmitLoadI8Value(ByVal Info As EmitInfo, ByVal I As Long)
         Info.ILGen.Emit(OpCodes.Ldc_I8, I)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1097" endline="1101"><![CDATA[
 
     Shared Sub EmitLoadI8Value(ByVal Info As EmitInfo, ByVal I As Long, ByVal TypeToPushOnStack As Mono.Cecil.TypeReference)
         TypeToPushOnStack = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeToPushOnStack)
         Info.ILGen.Emit(OpCodes.Ldc_I8, I)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1102" endline="1105"><![CDATA[
 
     Shared Sub EmitLoadR8Value(ByVal Info As EmitInfo, ByVal I As Double)
         Info.ILGen.Emit(OpCodes.Ldc_R8, I)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1106" endline="1110"><![CDATA[
 
     Shared Sub EmitLoadR8Value(ByVal Info As EmitInfo, ByVal I As Double, ByVal TypeToPushOnStack As Mono.Cecil.TypeReference)
         TypeToPushOnStack = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeToPushOnStack)
         Info.ILGen.Emit(OpCodes.Ldc_R8, I)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1111" endline="1114"><![CDATA[
 
     Shared Sub EmitLoadR4Value(ByVal Info As EmitInfo, ByVal I As Single)
         Info.ILGen.Emit(OpCodes.Ldc_R4, I)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1115" endline="1145"><![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Integer, ByVal TypeToPushOnStack As Mono.Cecil.TypeReference)
         TypeToPushOnStack = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeToPushOnStack)
         Select Case I
             Case -1
                 Info.ILGen.Emit(OpCodes.Ldc_I4_M1)
             Case 0
                 Info.ILGen.Emit(OpCodes.Ldc_I4_0)
             Case 1
                 Info.ILGen.Emit(OpCodes.Ldc_I4_1)
             Case 2
                 Info.ILGen.Emit(OpCodes.Ldc_I4_2)
             Case 3
                 Info.ILGen.Emit(OpCodes.Ldc_I4_3)
             Case 4
                 Info.ILGen.Emit(OpCodes.Ldc_I4_4)
             Case 5
                 Info.ILGen.Emit(OpCodes.Ldc_I4_5)
             Case 6
                 Info.ILGen.Emit(OpCodes.Ldc_I4_6)
             Case 7
                 Info.ILGen.Emit(OpCodes.Ldc_I4_7)
             Case 8
                 Info.ILGen.Emit(OpCodes.Ldc_I4_8)
             Case SByte.MinValue To SByte.MaxValue
                 Dim sbit As SByte = CSByte(I)
                 Info.ILGen.Emit(OpCodes.Ldc_I4_S, sbit)
             Case Else
                 Info.ILGen.Emit(OpCodes.Ldc_I4, I)
         End Select
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1146" endline="1149"><![CDATA[
     Shared Sub EmitLoadR4Value(ByVal Info As EmitInfo, ByVal I As Single, ByVal TypeToPushOnStack As Mono.Cecil.TypeReference)
         TypeToPushOnStack = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeToPushOnStack)
         Info.ILGen.Emit(OpCodes.Ldc_R4, I)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1150" endline="1157"><![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Boolean)
         If I Then
             EmitLoadI4Value(Info, -1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1158" endline="1161"><![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As UInteger)
         EmitLoadI4Value(Info, BitConverter.ToInt32(BitConverter.GetBytes(I), 0), Info.Compiler.TypeCache.System_UInt32)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1162" endline="1166"><![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As UInteger, ByVal TypeToPushOnStack As Mono.Cecil.TypeReference)
         TypeToPushOnStack = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeToPushOnStack)
         EmitLoadI4Value(Info, BitConverter.ToInt32(BitConverter.GetBytes(I), 0), TypeToPushOnStack)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1167" endline="1170"><![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Integer)
         EmitLoadI4Value(Info, I, Info.Compiler.TypeCache.System_Int32)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1171" endline="1221"><![CDATA[
 
     ''' <summary>
     ''' Loads an value of the desired type onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Integer) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim tmp As EmitInfo = Info
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
 
         Select Case DesiredTypeCode
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Boolean
                 EmitLoadI4Value(Info, Value, Info.DesiredType)
                 Return True
             Case TypeCode.Int64
                 EmitLoadI8Value(Info, Value, Info.DesiredType)
                 Return True
             Case TypeCode.Byte, TypeCode.UInt16
                 EmitLoadI4Value(Info, CUInt(Value), Info.DesiredType)
                 Return True
             Case TypeCode.UInt32
                 If Value <= UInteger.MaxValue AndAlso Value >= UInteger.MinValue Then
                     EmitLoadI4Value(Info, CUInt(Value), Info.DesiredType)
                     Return True
                 End If
             Case TypeCode.UInt64
                 If Value <= ULong.MaxValue AndAlso Value >= ULong.MinValue Then
                     EmitLoadValue(tmp, CULng(Value))
                     Return True
                 End If
             Case TypeCode.Single
                 EmitLoadR4Value(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadR8Value(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadDecimalValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Object
                 EmitLoadI4Value(tmp, Value)
                 'EmitBox(Info, Info.Compiler.TypeCache.System_Int32)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1222" endline="1244"><![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Long) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
             Return EmitLoadValue(Info, CInt(Value))
         End If
 
         Dim tmp As EmitInfo = Info.Clone(Info.Context, CType(Nothing, Mono.Cecil.TypeReference))
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
         End Select
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1245" endline="1274"><![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As ULong) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         'If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
         '    Helper.NotImplemented() 'Return EmitLoadValue(Info, CInt(Value))
         'ElseIf Value <= Long.MaxValue AndAlso Value >= Long.MinValue Then
         '    Return EmitLoadValue(Info, CLng(Value))
         'End If
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Int64, TypeCode.UInt64
                 EmitLoadI8Value(Info, Value)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1275" endline="1300"><![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Decimal) As Boolean
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Helper.Assert(Info.DesiredType IsNot Nothing)
         If Math.Truncate(Value) = Value Then
             If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
                 Return EmitLoadValue(Info, CInt(Value))
             ElseIf Value <= Long.MaxValue AndAlso Value >= Long.MinValue Then
                 Return EmitLoadValue(Info, CLng(Value))
             ElseIf Value <= ULong.MaxValue AndAlso Value >= Long.MinValue Then
                 Return EmitLoadValue(Info, CULng(Value))
             End If
         End If
 
         Dim tmp As EmitInfo = Info.Clone(Info.Context, CType(Nothing, Mono.Cecil.TypeReference))
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
         End Select
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1301" endline="1315"><![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Double) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 If Value <= Single.MaxValue AndAlso Value >= Single.MinValue Then
                     EmitLoadValue(tmp, CSng(Value))
                     Return True
                 End If
         End Select
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1316" endline="1325"><![CDATA[
 
     ''' <summary>
     ''' Loads the integer onto the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Overloads Shared Sub EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As String)
         Info.ILGen.Emit(OpCodes.Ldstr, Value)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1326" endline="1339"><![CDATA[
 
     ''' <summary>
     ''' Loads the boolean value onto the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Overloads Shared Sub EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Boolean)
         If Value Then
             EmitLoadI4Value(Info, 1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1340" endline="1353"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadValueAddress(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(CecilHelper.IsByRef(Info.DesiredType))
         EmitLoadValue(Info.Clone(Info.Context, CecilHelper.GetElementType(Info.DesiredType)), Value)
         Dim local As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Info.Compiler, CecilHelper.GetElementType(Info.DesiredType)))
         EmitStoreVariable(Info, local)
         EmitLoadVariableLocation(Info, local)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1354" endline="1362"><![CDATA[
 
     Shared Sub EmitLoadValueConstantOrValueAddress(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(Info.DesiredType IsNot Nothing, "EmitInfo.DesiredType must be set!")
         If CecilHelper.IsByRef(Info.DesiredType) Then
             EmitLoadValueAddress(Info, Value)
         Else
             EmitLoadValue(Info, Value)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1363" endline="1438"><![CDATA[
 
     ''' <summary>
     ''' Loads a constant value onto the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value">The value to emit. Set to DBNull.Value to emit a nothing value.</param>
     ''' <remarks></remarks>
     Overloads Shared Sub EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(Info.IsRHS, "Not RHS")
         Helper.Assert(Info.DesiredType IsNot Nothing, "No desired type")
 
         If Value Is Nothing Then Value = DBNull.Value
 
         Dim ActualType As Mono.Cecil.TypeReference = CecilHelper.GetType(Info.Compiler, Value)
         Dim ActualTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, ActualType)
         Dim DesiredType As Mono.Cecil.TypeReference = Info.DesiredType
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, DesiredType)
 
 #If EXTENDEDDEBUG Then
         Info.Compiler.Report.WriteLine(String.Format("Emitter.EmitLoadValue (EmitInfo, Object)
 #End If
 
         Select Case ActualTypeCode
             Case TypeCode.DBNull
                 EmitLoadNull(Info)
                 Return
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32
                 EmitLoadValue(Info, CInt(Value))
                 Return
             Case TypeCode.Int64
                 EmitLoadI8Value(Info, CLng(Value))
                 Return
             Case TypeCode.Single
                 Emitter.EmitLoadR4Value(Info, CSng(Value))
                 Return
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldc_R8, CDbl(Value))
                 Return
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Ldstr, CStr(Value))
                 Return
             Case TypeCode.Byte
                 EmitLoadI4Value(Info, CInt(Value), Info.Compiler.TypeCache.System_Byte)
                 Return
             Case TypeCode.UInt16
                 EmitLoadI4Value(Info, CInt(Value), Info.Compiler.TypeCache.System_UInt16)
                 Return
             Case TypeCode.UInt32
                 EmitLoadI4Value(Info, CUInt(Value))
                 Return
             Case TypeCode.UInt64
                 EmitLoadI8Value(Info, CULng(Value))
                 Return
             Case TypeCode.Decimal
                 EmitLoadDecimalValue(Info, CDec(Value))
                 Return
             Case TypeCode.DateTime
                 EmitLoadDateValue(Info, CDate(Value))
                 Return
             Case TypeCode.Char
                 EmitLoadI4Value(Info, Microsoft.VisualBasic.AscW(CChar(Value)), Info.Compiler.TypeCache.System_Char)
                 Return
             Case TypeCode.Boolean
                 If CBool(Value) Then
                     EmitLoadI4Value(Info, 1, Info.Compiler.TypeCache.System_Boolean)
                 Else
                     EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
                 End If
                 Return
             Case Else
                 Info.Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Missed case
                 Helper.Stop()
         End Select
 
         Helper.Stop()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1439" endline="1493"><![CDATA[
 
     ''' <summary>
     ''' Loads a nothing constant expression according to the desired type.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadNull(ByVal Info As EmitInfo)
         Helper.Assert(Info.DesiredType IsNot Nothing)
         If CecilHelper.IsGenericParameter(Info.DesiredType) Then ' TypeOf Info.DesiredType Is GenericTypeParameterBuilder OrElse TypeOf Info.DesiredType Is TypeParameterDescriptor Then
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = DeclareLocal(Info, Info.DesiredType)
             EmitLoadVariableLocation(Info, local)
             EmitInitObj(Info, Info.DesiredType)
             EmitLoadVariable(Info, local)
             'Info.Stack.Push(Info.DesiredType)
             FreeLocal(local)
         ElseIf CecilHelper.IsByRef(Info.DesiredType) Then
             Dim local As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, CecilHelper.GetElementType(Info.DesiredType))
             Info.ILGen.Emit(OpCodes.Ldnull)
             EmitStoreVariable(Info, local)
             EmitLoadVariableLocation(Info, local)
             FreeLocal(local)
         ElseIf CecilHelper.IsClass(Info.DesiredType) OrElse CecilHelper.IsInterface(Info.DesiredType) Then
             Info.ILGen.Emit(OpCodes.Ldnull)
         ElseIf CecilHelper.IsValueType(Info.DesiredType) Then
             Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
             Select Case DesiredTypeCode
                 Case TypeCode.Boolean
                     EmitLoadI4Value(Info, CInt(False), Info.DesiredType)
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32
                     EmitLoadI4Value(Info, 0, Info.DesiredType)
                 Case TypeCode.Int64, TypeCode.UInt64
                     EmitLoadI8Value(Info, 0, Info.DesiredType)
                 Case TypeCode.Char
                     EmitLoadI4Value(Info, 0, Info.DesiredType)
                 Case TypeCode.Single
                     EmitLoadR4Value(Info, CSng(0), Info.DesiredType)
                 Case TypeCode.Double
                     EmitLoadR8Value(Info, CDbl(0), Info.DesiredType)
                 Case TypeCode.Object, TypeCode.DateTime, TypeCode.Decimal
                     Dim local As Mono.Cecil.Cil.VariableDefinition
                     local = DeclareLocal(Info, Info.DesiredType)
                     EmitLoadVariable(Info, local)
                     FreeLocal(local)
                 Case TypeCode.String
                     Info.ILGen.Emit(OpCodes.Ldnull)
                 Case Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
             End Select
         ElseIf Helper.CompareType(Info.DesiredType, Info.Compiler.TypeCache.System_Enum) Then
             Info.ILGen.Emit(OpCodes.Ldnull)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1494" endline="1504"><![CDATA[
 
     ''' <summary>
     ''' Load a constant date value on the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadDateValue(ByVal Info As EmitInfo, ByVal DateValue As Date)
         Dim emitLong As EmitInfo = Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Int64)
         EmitLoadI8Value(emitLong, DateValue.Ticks)
         Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_DateTime__ctor_Int64))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1505" endline="1514"><![CDATA[
 
     ''' <summary>
     ''' Load a constant decimal value on to the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="decimalValue"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadDecimalValue(ByVal Info As EmitInfo, ByVal decimalValue As Decimal)
         EmitLoadDecimalValue(Info, New DecimalFields(decimalValue))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1515" endline="1536"><![CDATA[
 
     ''' <summary>
     ''' Load a constant decimal value on to the evaluation stack.
     ''' </summary>
     ''' <param name="decimalValue"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadDecimalValue(ByVal Info As EmitInfo, ByVal decimalValue As DecimalFields)
         If decimalValue.Value = -1 Then
             Info.ILGen.Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__MinusOne))
         ElseIf decimalValue.Value = 0 Then
             Info.ILGen.Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__Zero))
         ElseIf decimalValue.Value = 1 Then
             Info.ILGen.Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__One))
          Else
             EmitLoadI4Value(Info, decimalValue.Lo)
             EmitLoadI4Value(Info, decimalValue.Mid)
             EmitLoadI4Value(Info, decimalValue.Hi)
             EmitLoadI4Value(Info, CInt(decimalValue.SignAsBit), Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Boolean))
             EmitLoadI4Value(Info, CInt(decimalValue.Scale), Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Byte))
             Emitter.EmitNew(Info, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int32_Int32_Int32_Boolean_Byte))
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1537" endline="1561"><![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             Dim emittableField As Mono.Cecil.FieldReference = Helper.GetFieldOrFieldReference(Info.Compiler, Variable.FieldInfo)
             If Variable.InstanceExpression IsNot Nothing Then
                 Dim result As Boolean
                 result = Variable.InstanceExpression.GenerateCode(Info)
                 Helper.Assert(result)
                 'Helper.Assert(Variable.FieldInfo.IsStatic = False)
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             Else
                 Helper.Assert(CecilHelper.IsStatic(Variable.FieldInfo))
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             End If
          ElseIf Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(Variable.InstanceExpression Is Nothing)
             EmitLoadParameterAddress(Info, Variable.ParameterInfo)
         ElseIf Variable.Method IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.Method.DefaultReturnVariable)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1562" endline="1573"><![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitLoadVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1574" endline="1577"><![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.Cil.VariableDefinition)
         Info.ILGen.Emit(OpCodes.Ldloca, Variable)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1578" endline="1595"><![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim emittableField As Mono.Cecil.FieldReference
         Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(Field)
 
         emittableField = Emitter.GetFieldRef(Field)
         emittableField = Helper.GetFieldOrFieldBuilder(Info.Compiler, emittableField)
 
         If fD.IsLiteral Then
             EmitLoadValueAddress(Info, fD.Constant)
         Else
             If fD.IsStatic Then
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             Else
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             End If
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1596" endline="1610"><![CDATA[
 
     ''' <summary>
     ''' Loads the address of the parameter.
     ''' Just loads the value if it is a byref parameter.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Variable"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         If CecilHelper.IsByRef(Variable.ParameterType) Then
             EmitLoadParameter(Info, Variable)
         Else
             Info.ILGen.Emit(OpCodes.Ldarga, CShort(GetParameterPosition(Info, Variable)))
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1611" endline="1626"><![CDATA[
 
     ''' <summary>
     ''' Calculates the actual parameter position of the parameter.
     ''' Ready to send to ILGenerator.Emit(...)
     ''' </summary>
     ''' <param name="Parameter"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetParameterPosition(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition) As Integer
         Dim position As Integer = Parameter.Index
         Dim member As IMethodSignature = Parameter.Method
         If member.HasThis Then
             position += 1
         End If
         Return position
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1627" endline="1651"><![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified parameter.
     ''' If it is a byref parameter, the passed-in address is loaded.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Parameter"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadParameter(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Parameter)
         Select Case position
             Case 0
                 Info.ILGen.Emit(OpCodes.Ldarg_0)
             Case 1
                 Info.ILGen.Emit(OpCodes.Ldarg_1)
             Case 2
                 Info.ILGen.Emit(OpCodes.Ldarg_2)
             Case 3
                 Info.ILGen.Emit(OpCodes.Ldarg_3)
             Case Is <= 255
                 Info.ILGen.Emit(OpCodes.Ldarg_S, CByte(position))
             Case Else
                 Info.ILGen.Emit(OpCodes.Ldarg, position)
         End Select
    End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1652" endline="1667"><![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified parameter.
     ''' If it is a byref parameter, the passed-in address is loaded.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Parameter"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadParameterAddress(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Parameter)
         If position <= 255 Then
             Info.ILGen.Emit(OpCodes.Ldarga_S, CByte(position))
         Else
             Info.ILGen.Emit(OpCodes.Ldarga, position)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1668" endline="1681"><![CDATA[
 
     ''' <summary>
     ''' Loads the value of the parameter.
     ''' Gets the value of byref parameters, not the passed-in address.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Variable"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         EmitLoadParameter(Info, Variable)
         If CecilHelper.IsByRef(Variable.ParameterType) AndAlso CecilHelper.IsByRef(Info.DesiredType) = False Then
             EmitLoadIndirect(Info, Variable.ParameterType)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1682" endline="1732"><![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified address.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ByRefType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadIndirect(ByVal Info As EmitInfo, ByVal ByRefType As Mono.Cecil.TypeReference)
         ByRefType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ByRefType)
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ByRefType)
         Select Case Helper.GetTypeCode(Info.Compiler, elementtype)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldind_U1)
             Case TypeCode.SByte
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldind_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldind_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldind_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldind_I4)
             Case TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldind_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldind_R8)
             Case TypeCode.String, TypeCode.DBNull
                 Info.ILGen.Emit(OpCodes.Ldind_Ref)
             Case TypeCode.Object
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.ILGen.Emit(OpCodes.Ldind_Ref)
                 End If
             Case TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Ldobj, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal))
             Case Else
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
                 End If
         End Select
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1733" endline="1764"><![CDATA[
 
     ''' <summary>
     ''' Returns true if a leave instruction is necessary to jump from one statement to the other.
     ''' If ToStatement is nothing then it is assumed a ret instruction is about to be emitted.
     ''' </summary>
     ''' <param name="FromStatement"></param>
     ''' <param name="ToStatement"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsLeaveNecessary(ByVal FromStatement As Statement, ByVal ToStatement As Statement) As Boolean
         Dim result As Boolean
 
         If ToStatement Is Nothing Then
             result = FromStatement.FindParentCodeBlock.UpmostBlock.HasUnstructuredExceptionHandling
         End If
 
         If result = False Then
             Dim parentStmt As Statement = FromStatement
             Do Until parentStmt Is ToStatement OrElse parentStmt Is Nothing
                 result = result OrElse TypeOf parentStmt Is TryStatement
                 result = result OrElse TypeOf parentStmt Is SyncLockStatement
                 result = result OrElse TypeOf parentStmt Is ForEachStatement
                 result = result OrElse TypeOf parentStmt Is UsingStatement
                 result = result OrElse TypeOf parentStmt Is CatchStatement
 
                 If result Then Exit Do
 
                 parentStmt = parentStmt.Parent.FindFirstParent(Of Statement)()
             Loop
             Do Until parentStmt Is ToStatement OrElse parentStmt Is Nothing
                 result = result OrElse TypeOf parentStmt Is TryStatement
                 result = result OrElse TypeOf parentStmt Is SyncLockStatement
                 result = result OrElse TypeOf parentStmt Is ForEachStatement
                 result = result OrElse TypeOf parentStmt Is UsingStatement
                 result = result OrElse TypeOf parentStmt Is CatchStatement
 
                 If result Then Exit Do
 
                 parentStmt = parentStmt.Parent.FindFirstParent(Of Statement)()
             Loop
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1765" endline="1779"><![CDATA[
 
     Shared Sub EmitRetOrLeave(ByVal Info As EmitInfo, ByVal CurrentStatement As Statement, ByVal HasReturnValue As Boolean)
         Dim emitLeave As Boolean
 
         emitLeave = IsLeaveNecessary(CurrentStatement, Nothing)
 
         If emitLeave Then
             If HasReturnValue Then
                 Emitter.EmitStoreVariable(Info, Info.Method.DefaultReturnVariable)
             End If
             Emitter.EmitLeave(Info, CurrentStatement.FindParentCodeBlock.UpmostBlock.EndOfMethodLabel)
         Else
             Emitter.EmitRet(Info)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1780" endline="1783"><![CDATA[
 
     Shared Sub EmitRet(ByVal Info As EmitInfo)
         Info.ILGen.Emit(OpCodes.Ret)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1784" endline="1787"><![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.Cil.VariableDefinition)
         Info.ILGen.Emit(OpCodes.Ldloc, Variable)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1788" endline="1791"><![CDATA[
 
     Shared Sub EmitNop(ByVal Info As EmitInfo)
         Info.ILGen.Emit(OpCodes.Nop)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1792" endline="1805"><![CDATA[
 
     Private Shared Function GetFieldRef(ByVal field As Mono.Cecil.FieldReference) As Mono.Cecil.FieldReference
         Dim gFD As Mono.Cecil.FieldDefinition = TryCast(field, Mono.Cecil.FieldDefinition)
 
         If gFD IsNot Nothing AndAlso gFD.DeclaringType.GenericParameters.Count > 0 Then
             Dim declType As Mono.Cecil.GenericInstanceType
             declType = New Mono.Cecil.GenericInstanceType(gFD.DeclaringType)
             For i As Integer = 0 To gFD.DeclaringType.GenericParameters.Count - 1
                 declType.GenericArguments.Add(gFD.DeclaringType.GenericParameters(i))
             Next
             Return New Mono.Cecil.FieldReference(field.Name, field.FieldType, declType)
         End If
         Return field
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1806" endline="1821"><![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.FieldReference)
         Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(Variable)
 
         Variable = Emitter.GetFieldRef(Variable)
         Variable = Helper.GetFieldOrFieldReference(Info.Compiler, Variable)
         If fD.IsStatic Then
             If fD.IsLiteral Then
                 Emitter.EmitLoadValue(Info.Clone(Info.Context, True, False, Variable.FieldType), fD.Constant)
             Else
                 Info.ILGen.Emit(OpCodes.Ldsfld, Variable)
             End If
         Else
             Info.ILGen.Emit(OpCodes.Ldfld, Variable)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1822" endline="1825"><![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.Cil.VariableDefinition)
         Info.ILGen.Emit(OpCodes.Stloc, Variable)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1826" endline="1837"><![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitStoreVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitStoreField(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitStoreVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1838" endline="1868"><![CDATA[
 
     Shared Sub EmitStoreIndirect(ByVal Info As EmitInfo, ByVal ByRefType As Mono.Cecil.TypeReference)
         ByRefType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ByRefType)
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ByRefType)
         Select Case Helper.GetTypeCode(Info.Compiler, elementtype)
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Stind_I1)
             Case TypeCode.Int16, TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Stind_I2)
             Case TypeCode.Int32, TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Stind_I4)
             Case TypeCode.Int64, TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Stind_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Stind_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Stind_R8)
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Stind_Ref)
             Case TypeCode.DateTime, TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Stobj, elementtype)
             Case TypeCode.Object
                 If CecilHelper.IsValueType(elementtype) Then
                     Info.ILGen.Emit(OpCodes.Stobj, elementtype)
                 Else
                     Info.ILGen.Emit(OpCodes.Stind_Ref)
                 End If
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1869" endline="1881"><![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Variable)
         If CecilHelper.IsByRef(Variable.ParameterType) Then
             If CecilHelper.IsGenericParameter(CecilHelper.GetElementType(Variable.ParameterType)) Then
                 EmitStoreObject(Info, CecilHelper.GetElementType(Variable.ParameterType))
             Else
                 EmitStoreIndirect(Info, Variable.ParameterType)
             End If
         Else
             Info.ILGen.Emit(OpCodes.Starg, position)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1882" endline="1885"><![CDATA[
 
     Shared Sub EmitSwitch(ByVal Info As EmitInfo, ByVal Labels() As Label)
         Info.ILGen.Emit(OpCodes.Switch, Labels)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1886" endline="1889"><![CDATA[
 
     Shared Sub EmitSwitch(ByVal Info As EmitInfo, ByVal Labels() As Mono.Cecil.Cil.Instruction)
         Info.ILGen.Emit(OpCodes.Switch, Labels)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1890" endline="1900"><![CDATA[
 
     Shared Sub EmitStoreField(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim Field2 As Mono.Cecil.FieldReference = Field
         Field2 = Emitter.GetFieldRef(Field2)
         Field2 = Helper.GetFieldOrFieldBuilder(Info.Compiler, Field2)
         If CecilHelper.IsStatic(Field) Then
             Info.ILGen.Emit(OpCodes.Stsfld, Field2)
         Else
             Info.ILGen.Emit(OpCodes.Stfld, Field2)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1901" endline="1911"><![CDATA[
 
     ''' <summary>
     ''' Emits a box instruction, no checks are done.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitBox(ByVal Info As EmitInfo, ByVal SourceType As Mono.Cecil.TypeReference)
         Dim OriginalDestinationType As Mono.Cecil.TypeReference = SourceType
         SourceType = Helper.GetTypeOrTypeBuilder(Info.Compiler, SourceType)
         Info.ILGen.Emit(OpCodes.Box, SourceType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1912" endline="1916"><![CDATA[
 
     Shared Sub EmitUnbox(ByVal Info As EmitInfo, ByVal ToType As Mono.Cecil.TypeReference)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Info.ILGen.Emit(OpCodes.Unbox, ToType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1917" endline="1921"><![CDATA[
 
     Shared Sub EmitUnbox_Any(ByVal Info As EmitInfo, ByVal ToType As Mono.Cecil.TypeReference)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Info.ILGen.Emit(OpCodes.Unbox_Any, ToType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1922" endline="1926"><![CDATA[
 
     Shared Sub EmitLdobj(ByVal Info As EmitInfo, ByVal SourceType As Mono.Cecil.TypeReference)
         SourceType = Helper.GetTypeOrTypeBuilder(Info.Compiler, SourceType)
         Info.ILGen.Emit(OpCodes.Ldobj, SourceType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1927" endline="1930"><![CDATA[
 
     Shared Sub EmitThrow(ByVal Info As EmitInfo)
         Info.ILGen.Emit(OpCodes.Throw)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1931" endline="1977"><![CDATA[
 
     Shared Function SwitchVersionedMethods(ByVal Info As EmitInfo, ByVal UnversionedMethod As Mono.Cecil.MethodReference) As Mono.Cecil.MethodReference
         If Info.Compiler.CommandLine.VBVersion <> CommandLine.VBVersions.V8 Then Return UnversionedMethod
 
         Dim tc As CecilTypeCache = Info.Compiler.TypeCache
         Dim check(4) As Mono.Cecil.MethodDefinition
         Dim replace(4) As Mono.Cecil.MethodDefinition
         Dim unv(4) As Mono.Cecil.MethodDefinition
 
         check(0) = tc.MS_VB_Information__IsNumeric
         check(1) = tc.MS_VB_Information__SystemTypeName
         check(2) = tc.MS_VB_Information__TypeName
         check(3) = tc.MS_VB_Information__VbTypeName
         check(4) = tc.MS_VB_Interaction__CallByName
 
         replace(0) = tc.MS_VB_CS_Versioned__IsNumeric
         replace(1) = tc.MS_VB_CS_Versioned__SystemTypeName
         replace(2) = tc.MS_VB_CS_Versioned__TypeName
         replace(3) = tc.MS_VB_CS_Versioned__VbTypeName
         replace(4) = tc.MS_VB_CS_Versioned__CallByName
 
         For i As Integer = 0 To check.Length - 1
             If check(i) Is UnversionedMethod Then Return replace(i)
         Next
 
         For i As Integer = 0 To check.Length - 1
             unv(i) = CecilHelper.FindDefinition(UnversionedMethod)
             If check(i) Is unv(i) Then Return replace(i)
         Next
 
         For i As Integer = 0 To check.Length - 1
             If unv(i) Is Nothing Then Continue For
             If check(i) Is Nothing Then Continue For
             If Helper.CompareName(unv(i).Name, check(i).Name) = False Then Continue For
             If Helper.CompareName(unv(i).DeclaringType.Name, check(i).DeclaringType.Name) = False Then Continue For
             If Helper.CompareName(unv(i).DeclaringType.Namespace, check(i).DeclaringType.Namespace) = False Then Continue For
             'There shouldn't be any need to check parameters, since these methods aren't overloaded
             Return replace(i)
         Next
 
 
         'Check if the object comparison above is true for cecil as well (that is if same method may have multiple object references)
         'This will assert while compiling the compiler if object comparison doesn't hold for cecil.
         Helper.Assert(UnversionedMethod.Name <> "IsNumeric")
 
         Return UnversionedMethod
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\Enums.vb" startline="115" endline="306"><![CDATA[
     Sub New()
     Friend strSpecial(KS.NumberOfItems) As String
 
     ''' <summary>
     ''' BinaryExpression 
     '''   AndAlsoExpression | AndExpression | BinaryAddExpression | BinarySubExpression |
     '''   ConcatExpression | EqualsExpression | ExponentExpression | GEExpression |
     '''   GTExpression | IntDivisionExpression | IsExpression | IsNotExpression |
     '''   LEExpression | LikeExpression | LShiftExpression | LTExpression |
     '''   ModExpression | MultExpression | NotEqualsExpression | OrElseExpression |
     '''   OrExpression | RealDivisionExpression | RShiftExpression | XOrExpression
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly BinaryOperators As KS() = {KS.AndAlso, KS.And, KS.Add, KS.Minus, KS.Concat, KS.Equals, KS.Power, KS.GE, KS.GT, KS.IntDivision, KS.Is, KS.IsNot, KS.LE, KS.Like, KS.ShiftLeft, KS.LT, KS.Mod, KS.Mult, KS.NotEqual, KS.OrElse, KS.Or, KS.RealDivision, KS.ShiftRight, KS.Xor}
 
     ''' <summary>
     ''' UnaryExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly UnaryOperators As KS() = {KS.Add, KS.Minus, KS.Not}
     ''' <summary>
     '''CastTarget  
     '''	"CBool" | "CByte" | "CChar" | "CDate" | "CDec" | "CDbl" | "CInt" | "CLng" | "CObj" | "CSByte" | "CShort" |
     '''	"CSng" | "CStr" | "CUInt" | "CULng" | "CUShort"
     '''     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly CastTargets As KS() = {KS.CBool, KS.CByte, KS.CChar, KS.CDate, KS.CDec, KS.CDbl, KS.CInt, KS.CLng, KS.CObj, KS.CSByte, KS.CShort, KS.CSng, KS.CStr, KS.CUInt, KS.CULng, KS.CUShort}
 
     ''' <summary>
     '''CastExpression  
     '''	"DirectCast" (...)
     '''	"TryCast" (...)
     '''	"CType" (...)
     '''	CastTarget  (...)
     '''CastTarget  
     '''	"CBool" | "CByte" | "CChar" | "CDate" | "CDec" | "CDbl" | "CInt" | "CLng" | "CObj" | "CSByte" | "CShort" |
     '''	"CSng" | "CStr" | "CUInt" | "CULng" | "CUShort"
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly CastExpressionTargets As KS() = {KS.CBool, KS.CByte, KS.CChar, KS.CDate, KS.CDec, KS.CDbl, KS.CInt, KS.CLng, KS.CObj, KS.CSByte, KS.CShort, KS.CSng, KS.CStr, KS.CUInt, KS.CULng, KS.CUShort, KS.DirectCast, KS.TryCast, KS.CType}
 
     ''' <summary>
     ''' CCUnaryOperator  
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly CCUnaryOperators As KS() = New KS() {KS.Add, KS.Minus, KS.Not}
 
     ''' <summary>
     ''' CCBinaryOperator  
     '''                        "&gt;=" | "&amp;" | "And" | "Or" | "Xor" | "AndAlso" | "OrElse" |  "&lt;&lt;" | "&gt;&gt;"
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly CCBinaryOperators As KS() = New KS() {KS.Add, KS.Minus, KS.Mult, KS.RealDivision, KS.IntDivision, KS.Mod, KS.Power, KS.Equals, KS.NotEqual, KS.LT, KS.GT, KS.LE, KS.GE, KS.Concat, KS.And, KS.Or, KS.Xor, KS.AndAlso, KS.OrElse, KS.ShiftLeft, KS.ShiftRight}
 
     ''' <summary>
     ''' BuiltInTypeName  
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly BuiltInTypeTypeNames As KS() = New KS() {KS.Boolean, KS.Byte, KS.SByte, KS.Short, KS.UShort, KS.Integer, KS.UInteger, KS.Long, KS.ULong, KS.Decimal, KS.Single, KS.Double, KS.Object, KS.Date, KS.String, KS.Char}
 
     ''' <summary>
     ''' FloatingPointTypeName  
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly FloatingPointTypeNames As KS() = New KS() {KS.Single, KS.Double}
 
     ''' <summary>
     ''' IntegralTypeName  
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly IntegralTypeNames As KS() = New KS() {KS.Byte, KS.SByte, KS.UShort, KS.Short, KS.UInteger, KS.Integer, KS.ULong, KS.Long}
 
     ''' <summary>
     ''' NumericTypeName  
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly NumericTypeNames As KS() = New KS() {KS.Single, KS.Double, KS.Byte, KS.SByte, KS.UShort, KS.Short, KS.UInteger, KS.Integer, KS.ULong, KS.Long, KS.Decimal}
 
     ''' <summary>
     ''' PrimitiveTypeName  
     ''' </summary>
     ''' <remarks></remarks>
     Public ReadOnly PrimitiveTypeNames As KS() = New KS() {KS.Single, KS.Double, KS.Byte, KS.SByte, KS.UShort, KS.Short, KS.UInteger, KS.Integer, KS.ULong, KS.Long, KS.Decimal, KS.String, KS.Boolean, KS.Date, KS.Char}
 
     Class KW
         Public KeywordL As String
         Public KS As KS
     End Class
 
     Public m_Keywords(12) As Generic.Dictionary(Of Char, Generic.List(Of KW))
 
     Sub New()
         strSpecial(KS.LT) = "<"
         strSpecial(KS.GT) = ">"
         strSpecial(KS.Equals) = "="
         strSpecial(KS.NotEqual) = "<>"
         strSpecial(KS.LE) = "<="
         strSpecial(KS.GE) = ">="
         strSpecial(KS.Exclamation) = "!"
         strSpecial(KS.Concat) = "&"
         strSpecial(KS.Mult) = "*"
         strSpecial(KS.Add) = "+"
         strSpecial(KS.Minus) = "-"
         strSpecial(KS.Power) = "^"
         strSpecial(KS.RealDivision) = "/"
         strSpecial(KS.IntDivision) = "\"
         strSpecial(KS.Numeral) = "#"
         strSpecial(KS.LBrace) = "{"
         strSpecial(KS.RBrace) = "}"
         strSpecial(KS.LParenthesis) = "("
         strSpecial(KS.RParenthesis) = ")"
         strSpecial(KS.Dot) = "."
         strSpecial(KS.Comma) = ","
         strSpecial(KS.Colon) = "
         strSpecial(KS.ShiftLeft) = "<<"
         strSpecial(KS.ShiftRight) = ">>"
         strSpecial(KS.ConcatAssign) = "&="
         strSpecial(KS.AddAssign) = "+="
         strSpecial(KS.MinusAssign) = "-="
         strSpecial(KS.RealDivAssign) = "/="
         strSpecial(KS.IntDivAssign) = "\="
         strSpecial(KS.PowerAssign) = "^="
         strSpecial(KS.MultAssign) = "*="
         strSpecial(KS.ShiftLeftAssign) = "<<="
         strSpecial(KS.ShiftRightAssign) = ">>="
 
         For i As Integer = 0 To 12
             m_Keywords(i) = New Generic.Dictionary(Of Char, Generic.List(Of KW))
         Next
 
         AddKeyword("Ansi", KS.Ansi)
         AddKeyword("Auto", KS.Auto)
         AddKeyword("ByRef", KS.ByRef)
         AddKeyword("ByVal", KS.ByVal)
         AddKeyword("Const", KS.Const)
         AddKeyword("Default", KS.Default)
         AddKeyword("Dim", KS.Dim)
         AddKeyword("Friend", KS.Friend)
         AddKeyword("Inherits", KS.Inherits)
         AddKeyword("Narrowing", KS.Narrowing)
         AddKeyword("MustInherit", KS.MustInherit)
         AddKeyword("MustOverride", KS.MustOverride)
         AddKeyword("NotInheritable", KS.NotInheritable)
         AddKeyword("NotOverridable", KS.NotOverridable)
         AddKeyword("Optional", KS.Optional)
         AddKeyword("Overloads", KS.Overloads)
         AddKeyword("Overridable", KS.Overridable)
         AddKeyword("Overrides", KS.Overrides)
         AddKeyword("Partial", KS.Partial)
         AddKeyword("ParamArray", KS.ParamArray)
         AddKeyword("Private", KS.Private)
         AddKeyword("Protected", KS.Protected)
         AddKeyword("Public", KS.Public)
         AddKeyword("ReadOnly", KS.ReadOnly)
         AddKeyword("Shadows", KS.Shadows)
         AddKeyword("Shared", KS.Shared)
         AddKeyword("Static", KS.Static)
         AddKeyword("Unicode", KS.Unicode)
         AddKeyword("Widening", KS.Widening)
         AddKeyword("WithEvents", KS.WithEvents)
         AddKeyword("WriteOnly", KS.WriteOnly)
         AddKeyword("AddHandler", KS.AddHandler)
         AddKeyword("AddressOf", KS.AddressOf)
         AddKeyword("AndAlso", KS.AndAlso)
         AddKeyword("Alias", KS.Alias)
         AddKeyword("And", KS.And)
         AddKeyword("As", KS.As)
         AddKeyword("Boolean", KS.Boolean)
         AddKeyword("Byte", KS.Byte)
         AddKeyword("Call", KS.Call)
         AddKeyword("Case", KS.Case)
         AddKeyword("Catch", KS.Catch)
         AddKeyword("CBool", KS.CBool)
         AddKeyword("CByte", KS.CByte)
         AddKeyword("CChar", KS.CChar)
         AddKeyword("CDate", KS.CDate)
         AddKeyword("CDec", KS.CDec)
         AddKeyword("CDbl", KS.CDbl)
         AddKeyword("Char", KS.Char)
         AddKeyword("CInt", KS.CInt)
         AddKeyword("Class", KS.Class)
         AddKeyword("CLng", KS.CLng)
         AddKeyword("CObj", KS.CObj)
         AddKeyword("Continue", KS.Continue)
         AddKeyword("CSByte", KS.CSByte)
         AddKeyword("CShort", KS.CShort)
         AddKeyword("CSng", KS.CSng)
         AddKeyword("CStr", KS.CStr)
         AddKeyword("CUInt", KS.CUInt)
         AddKeyword("CULng", KS.CULng)
         AddKeyword("CUShort", KS.CUShort)
         AddKeyword("CType", KS.CType)
         AddKeyword("Date", KS.Date)
         AddKeyword("Decimal", KS.Decimal)
         AddKeyword("Declare", KS.Declare)
         AddKeyword("Delegate", KS.Delegate)
         AddKeyword("DirectCast", KS.DirectCast)
         AddKeyword("Do", KS.Do)
         AddKeyword("Double", KS.Double)
         AddKeyword("Each", KS.Each)
         AddKeyword("Else", KS.Else)
         AddKeyword("ElseIf", KS.ElseIf)
         AddKeyword("End", KS.End)
         AddKeyword("Enum", KS.Enum)
         AddKeyword("Erase", KS.Erase)
         AddKeyword("Error", KS.Error)
         AddKeyword("Event", KS.Event)
         AddKeyword("Exit", KS.Exit)
         AddKeyword("False", KS.False)
         AddKeyword("Finally", KS.Finally)
         AddKeyword("For", KS.For)
         AddKeyword("Function", KS.Function)
         AddKeyword("Get", KS.Get)
         AddKeyword("GetType", KS.GetType)
         AddKeyword("Global", KS.Global)
         AddKeyword("GoTo", KS.GoTo)
         AddKeyword("Handles", KS.Handles)
         AddKeyword("If", KS.If)
         AddKeyword("Implements", KS.Implements)
         AddKeyword("Imports", KS.Imports)
         AddKeyword("In", KS.In)
         AddKeyword("Integer", KS.Integer)
         AddKeyword("Interface", KS.Interface)
         AddKeyword("Is", KS.Is)
         AddKeyword("IsNot", KS.IsNot)
         AddKeyword("Let", KS.Let)
         AddKeyword("Lib", KS.Lib)
         AddKeyword("Like", KS.Like)
         AddKeyword("Long", KS.Long)
         AddKeyword("Loop", KS.Loop)
         AddKeyword("Me", KS.Me)
         AddKeyword("Mod", KS.Mod)
         AddKeyword("Module", KS.Module)
         AddKeyword("MyBase", KS.MyBase)
         AddKeyword("MyClass", KS.MyClass)
         AddKeyword("Namespace", KS.Namespace)
         AddKeyword("New", KS.New)
         AddKeyword("Next", KS.Next)
         AddKeyword("Not", KS.Not)
         AddKeyword("Nothing", KS.Nothing)
         AddKeyword("Object", KS.Object)
         AddKeyword("Of", KS.Of)
         AddKeyword("On", KS.On)
         AddKeyword("Operator", KS.Operator)
         AddKeyword("Option", KS.Option)
         AddKeyword("Or", KS.Or)
         AddKeyword("OrElse", KS.OrElse)
         AddKeyword("Property", KS.Property)
         AddKeyword("RaiseEvent", KS.RaiseEvent)
         AddKeyword("ReDim", KS.ReDim)
         AddKeyword("REM", KS.[REM])
         AddKeyword("RemoveHandler", KS.RemoveHandler)
         AddKeyword("Resume", KS.Resume)
         AddKeyword("Return", KS.Return)
         AddKeyword("SByte", KS.SByte)
         AddKeyword("Select", KS.Select)
         AddKeyword("Set", KS.Set)
         AddKeyword("Short", KS.Short)
         AddKeyword("Single", KS.Single)
         AddKeyword("Step", KS.Step)
         AddKeyword("Stop", KS.Stop)
         AddKeyword("String", KS.String)
         AddKeyword("Structure", KS.Structure)
         AddKeyword("Sub", KS.Sub)
         AddKeyword("SyncLock", KS.SyncLock)
         AddKeyword("Then", KS.Then)
         AddKeyword("Throw", KS.Throw)
         AddKeyword("To", KS.To)
         AddKeyword("True", KS.True)
         AddKeyword("Try", KS.Try)
         AddKeyword("TryCast", KS.TryCast)
         AddKeyword("TypeOf", KS.TypeOf)
         AddKeyword("UInteger", KS.UInteger)
         AddKeyword("ULong", KS.ULong)
         AddKeyword("UShort", KS.UShort)
         AddKeyword("Using", KS.Using)
         AddKeyword("Until", KS.Until)
         AddKeyword("Variant", KS.Variant)
         AddKeyword("When", KS.When)
         AddKeyword("While", KS.While)
         AddKeyword("With", KS.With)
         AddKeyword("Xor", KS.Xor)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\Enums.vb" startline="307" endline="322"><![CDATA[
 
     Private Sub AddKeyword(ByVal keyword As String, ByVal ks As KS)
         Dim list As Generic.List(Of KW) = Nothing
         Dim kw As New KW()
         kw.KeywordL = keyword.ToLowerInvariant()
         kw.KS = ks
 
         If Not m_Keywords(keyword.Length - 2).TryGetValue(keyword(0), list) Then
             list = New Generic.List(Of KW)
             m_Keywords(keyword.Length - 2)(keyword(0)) = list
         End If
 
         list.Add(kw)
 
         strSpecial(ks) = keyword
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\Enums.vb" startline="323" endline="352"><![CDATA[
 
     Public Function GetKS(ByVal value As Char(), ByVal length As Integer) As KS
         Dim list As Generic.List(Of KW) = Nothing
         Dim ch0 As Char
 
         If length < 2 OrElse length > 14 Then Return KS.None
         ch0 = value(0)
         If ch0 >= "a"c AndAlso ch0 <= "z"c Then ch0 = VB.Chr(VB.Asc(ch0) - 32)
 
         If Not m_Keywords(length - 2).TryGetValue(ch0, list) Then Return KS.None
 
         If list Is Nothing Then Return KS.None
 
         For i As Integer = 0 To list.Count - 1
             Dim kwL As String = list(i).KeywordL
             For c As Integer = 1 To length - 1
                 Dim kc As Char = value(c)
 
                 If kc >= "A"c AndAlso kc <= "Z"c Then kc = VB.Chr(VB.Asc(kc) + 32)
 
                 If kwL(c) = kc Then
                     If c = length - 1 Then Return list(i).KS
                     Continue For
                 End If
                 Exit For
             Next
         Next
 
         Return KS.None
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="40" endline="41"><![CDATA[
     Private Shared m_Characters() As String = {"S", "US", "I", "UI", "L", "UL", "%", "&", "F", "R", "D", "!", "#", "@"}
     Private Shared m_Types() As BuiltInDataTypes = {BuiltInDataTypes.Short, BuiltInDataTypes.UShort, BuiltInDataTypes.Integer, BuiltInDataTypes.UInteger, BuiltInDataTypes.Long, BuiltInDataTypes.ULong, BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Single, BuiltInDataTypes.Double, BuiltInDataTypes.Decimal, BuiltInDataTypes.Single, BuiltInDataTypes.Double, BuiltInDataTypes.Decimal}
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="42" endline="45"><![CDATA[
 
     Shared Function IsIntegral(ByVal chr As LiteralTypeCharacters_Characters) As Boolean
         Return chr >= LiteralTypeCharacters_Characters.ShortCharacter AndAlso chr <= LiteralTypeCharacters_Characters.LongTypeCharacter
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="46" endline="49"><![CDATA[
 
     Private Sub New()
         'This class cannot be created.
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="50" endline="57"><![CDATA[
 
     Shared Function GetBuiltInType(ByVal chr As LiteralTypeCharacters_Characters) As BuiltInDataTypes
         If chr = LiteralTypeCharacters_Characters.None Then
             Throw New InternalException("")
         Else
             Return m_Types(chr - 1)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="58" endline="65"><![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As String) As LiteralTypeCharacters_Characters
         chr = chr.ToUpperInvariant
         For i As Integer = 0 To m_Characters.GetUpperBound(0)
             If m_Characters(i).Equals(chr, StringComparison.Ordinal) Then Return CType(i + 1, LiteralTypeCharacters_Characters)
         Next
         Return LiteralTypeCharacters_Characters.None
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="66" endline="73"><![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As LiteralTypeCharacters_Characters) As String
         If chr = LiteralTypeCharacters_Characters.None Then
             Return ""
         Else
             Return m_Characters(chr - 1)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="60" endline="60"><![CDATA[
     Private Shared m_DataTypes() As KS = {KS.None, KS.Integer, KS.Long, KS.Decimal, KS.Single, KS.Double, KS.String}
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="61" endline="79"><![CDATA[
 
     Shared Function TypeCharacterToType(ByVal Compiler As Compiler, ByVal TypeCharacter As TypeCharacters.Characters) As Mono.Cecil.TypeReference
         Select Case GetDataType(TypeCharacter)
             Case KS.Integer
                 Return Compiler.TypeCache.System_Int32
             Case KS.Long
                 Return Compiler.TypeCache.System_Int64
             Case KS.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case KS.Single
                 Return Compiler.TypeCache.System_Single
             Case KS.Double
                 Return Compiler.TypeCache.System_Double
             Case KS.String
                 Return Compiler.TypeCache.System_String
             Case Else
                 Throw New InternalException("Unknown typecharacter
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="80" endline="84"><![CDATA[
 
     Shared Function IsTypeCharacter(ByVal chr As Char, ByRef result As Characters) As Boolean
         result = GetTypeCharacter(chr)
         Return result <> Characters.None
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="85" endline="88"><![CDATA[
 
     Shared Function IsTypeCharacter(ByVal chr As Char) As Boolean
         Return GetTypeCharacter(chr) <> Characters.None
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="89" endline="92"><![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Char) As Characters
         Return CType(m_Characters.IndexOf(chr) + 1, Characters)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100"><![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="101" endline="104"><![CDATA[
 
     Shared Function GetDataType(ByVal TypeCharacter As Characters) As KS
         Return m_DataTypes(TypeCharacter)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="105" endline="112"><![CDATA[
 
     ''' <summary>
     ''' This class cannot be created.
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub New()
         '
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="45" endline="51"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="52" endline="55"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Expression.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="56" endline="59"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="60" endline="64"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="65" endline="68"><![CDATA[
 
     Sub Init(ByVal Expression As Expression)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="69" endline="72"><![CDATA[
 
     Sub Init(ByVal Method As MethodDeclaration, ByVal InstanceExpression As Expression)
         Classification = New MethodPointerClassification(Me, New MethodGroupClassification(Me, InstanceExpression, Nothing, Method))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="73" endline="76"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.AddressOf)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="77" endline="85"><![CDATA[
 
     Function Resolve(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.Resolve(DelegateType) AndAlso result
         m_ExpressionType = DelegateType
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="86" endline="105"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If Classification IsNot Nothing Then Return True
 
         result = m_Expression.ResolveExpression(New ResolveInfo(Info.Compiler, True)) AndAlso result
 
         If m_Expression.Classification.IsMethodGroupClassification Then
             Dim mpClassification As MethodPointerClassification
             mpClassification = New MethodPointerClassification(Me, m_Expression.Classification.AsMethodGroupClassification)
             Classification = mpClassification
 
             m_ExpressionType = Info.Compiler.TypeCache.DelegateUnresolvedType
         Else
             Helper.AddError(Me, Me.Location.ToString(Compiler))
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="106" endline="114"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             If MyBase.IsResolved Then
                 Return m_ExpressionType
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="29" endline="31"><![CDATA[
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="32" endline="41"><![CDATA[
     End Property
 
     Overridable ReadOnly Property AsString() As String
         Get
             If m_Expression Is Nothing Then
                 Return "Nothing"
             Else
                 Return m_Expression.AsString
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="42" endline="59"><![CDATA[
     End Property
 
     Overridable ReadOnly Property AsTypeString() As String
         Get
             If m_Expression Is Nothing Then
                 Return "Nothing"
             Else
                 If m_Expression.ExpressionType Is Nothing Then
                     Return "(Nothing)"
                 Else
                     If m_Expression.ExpressionType.FullName = "" Then
                         Return m_Expression.ExpressionType.Name
                     Else
                         Return m_Expression.ExpressionType.FullName
                     End If
                 End If
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="60" endline="64"><![CDATA[
     End Property
 
     Protected Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="65" endline="68"><![CDATA[
 
     Sub Init(ByVal Expression As Expression)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="69" endline="72"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return m_Expression.GenerateCode(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="73" endline="86"><![CDATA[
 
     Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal Destination As Mono.Cecil.ParameterDefinition) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.GenerateCode(Info) AndAlso result
         Else
             Helper.Assert(Destination IsNot Nothing)
             Helper.Assert(Destination.IsOptional)
             Emitter.EmitLoadValue(Info, Destination.Constant)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="87" endline="105"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
 
             If result AndAlso m_Expression.Classification.IsMethodGroupClassification Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             ElseIf result AndAlso m_Expression.Classification.IsPropertyGroupClassification Then
                 m_Expression = m_Expression.ReclassifyToPropertyAccessExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="106" endline="110"><![CDATA[
 
     Property Expression() As Expression
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="111" endline="113"><![CDATA[
         Set(ByVal value As Expression)
             m_Expression = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="114" endline="118"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Expression Is Nothing OrElse m_Expression.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="39" endline="41"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="42" endline="50"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="51" endline="57"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
         If Arguments IsNot Nothing Then
             m_Arguments.AddRange(Arguments)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="58" endline="61"><![CDATA[
 
     Sub Init(ByVal Arguments As BaseObjects(Of Argument))
         m_Arguments = Arguments
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="62" endline="66"><![CDATA[
 
     Sub ReplaceArguments(ByVal NewArguments As ArgumentList)
         m_Arguments.Clear()
         If NewArguments IsNot Nothing Then m_Arguments.AddRange(NewArguments.Arguments)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="67" endline="75"><![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="76" endline="84"><![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.PropertyReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="85" endline="88"><![CDATA[
 
     Function VerifyArguments(ByVal Method As Mono.Cecil.PropertyReference) As Boolean
         Return VerifyArguments(Method.Parameters)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="89" endline="92"><![CDATA[
 
     Function VerifyArguments(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Return VerifyArguments(Method.Parameters)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="93" endline="177"><![CDATA[
 
     ''' <summary>
     ''' This function only verifies the expression type of the argument,
     ''' it does not expand paramarray arguments nor optional arguments
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function VerifyArguments(ByVal parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         Dim result As Boolean = True
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(Me.Location.ToString & "
 #End If
         For i As Integer = 0 To m_Arguments.Count - 1
             Dim exp As Expression
             Dim arg As Argument = m_Arguments(i)
             Dim par As Mono.Cecil.ParameterDefinition = parameters(i)
 
             If Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.DelegateUnresolvedType) Then
                 Dim aoe As AddressOfExpression = TryCast(arg.Expression, AddressOfExpression)
                 Dim delegateType As Mono.Cecil.TypeReference = par.ParameterType
 
                 Helper.Assert(aoe IsNot Nothing)
                 Helper.Assert(delegateType IsNot Nothing)
 
                 result = aoe.Resolve(delegateType) AndAlso result
 
                 Dim del As DelegateOrObjectCreationExpression
                 del = New DelegateOrObjectCreationExpression(Me)
                 del.Init(delegateType, New ArgumentList(del, aoe))
                 result = del.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
                 m_Arguments(i).Expression = del
             End If
 
             If CecilHelper.IsByRef(par.ParameterType) AndAlso CecilHelper.IsByRef(arg.Expression.ExpressionType) = False AndAlso CecilHelper.IsValueType(CecilHelper.GetElementType(par.ParameterType)) = False Then
                 If arg.Expression.Classification.IsPropertyAccessClassification Then
                     Dim propRef As PropertyReference = arg.Expression.Classification.AsPropertyAccess.Property
                     Dim propDef As PropertyDefinition = CecilHelper.FindDefinition(propRef)
                     If propDef.GetMethod Is Nothing Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC30524, m_Arguments(i).Location, propDef.Name)
                     End If
                     exp = arg.Expression
                 ElseIf Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.Nothing) = False Then
                     exp = New GetRefExpression(Me, arg.Expression)
                 Else
                     exp = arg.Expression
                 End If
             ElseIf CecilHelper.IsByRef(par.ParameterType) AndAlso CecilHelper.IsByRef(arg.Expression.ExpressionType) AndAlso Helper.CompareType(CecilHelper.GetElementType(par.ParameterType), CecilHelper.GetElementType(arg.Expression.ExpressionType)) Then
                 exp = arg.Expression
             ElseIf CecilHelper.IsByRef(par.ParameterType) AndAlso Helper.CompareType(arg.Expression.ExpressionType, CecilHelper.GetElementType(par.ParameterType)) = False AndAlso (arg.Expression.Classification.IsVariableClassification OrElse arg.Expression.Classification.IsPropertyAccessClassification) Then
                 Dim varTmp As LocalVariableDeclaration
                 Dim assignA, assignB As AssignmentStatement
                 Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
                 Dim thisStatement As Statement = Me.FindFirstParent(Of Statement)()
 
                 varTmp = New LocalVariableDeclaration(Me.Parent)
                 varTmp.Init(Nothing, "VB$tmp", CecilHelper.GetElementType(par.ParameterType))
                 'result = varTmp.ResolveMember(ResolveInfo.Default(Compiler)) AndAlso result
 
                 assignA = New AssignmentStatement(Me.Parent)
                 assignA.Init(New VariableExpression(assignA, varTmp), arg.Expression)
                 result = assignA.ResolveStatement(ResolveInfo.Default(Compiler)) AndAlso result
 
                 assignB = New AssignmentStatement(Me.Parent)
                 assignB.Init(arg.Expression, New VariableExpression(assignB, varTmp))
                 result = assignB.ResolveStatement(ResolveInfo.Default(Compiler)) AndAlso result
 
                 block.AddVariable(varTmp)
                 block.AddStatementBefore(assignA, thisStatement)
                 block.AddStatementAfter(assignB, thisStatement)
 
                 exp = New GetRefExpression(Me, New VariableExpression(Me, varTmp))
             Else
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("VerifyArguments, needs convertion from " & arg.Expression.ExpressionType.FullName & " to " & par.ParameterType.FullName)
 #End If
                 exp = Helper.CreateTypeConversion(arg, arg.Expression, par.ParameterType, result)
             End If
                 If exp IsNot arg.Expression Then
                     m_Arguments(i) = New PositionalArgument(Me, i, exp)
                 End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="178" endline="206"><![CDATA[
 
     Function FillWithOptionalParameters(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
         Dim parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
 
         If Method Is Nothing Then Return False
 
         parameters = Helper.GetParameters(Compiler, Method)
 
         For i As Integer = 0 To parameters.Count - 1
             If i >= Me.Count OrElse m_Arguments(i).Expression Is Nothing Then
                 Helper.Assert(parameters(i).IsOptional)
 
                 Dim newExp As ConstantExpression
                 Dim newArg As PositionalArgument
 
                 newExp = New ConstantExpression(Me, parameters(i).Constant, parameters(i).ParameterType)
                 newArg = New PositionalArgument(Me, i, newExp)
 
                 If i >= Me.Count Then
                     Me.Arguments.Add(newArg)
                 Else
                     Me.Arguments(i) = newArg
                 End If
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="207" endline="218"><![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsString
                 sep = ", "
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="219" endline="231"><![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsTypeString
                 sep = ", "
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="232" endline="244"><![CDATA[
     End Property
 
     Function ToTypes() As Mono.Cecil.TypeReference()
         Dim result(m_Arguments.Count - 1) As Mono.Cecil.TypeReference
         For i As Integer = 0 To m_Arguments.Count - 1
             If m_Arguments(i).Expression Is Nothing Then
                 result(i) = New MissingType(Compiler)
             Else
                 result(i) = m_Arguments(i).Expression.ExpressionType
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="245" endline="265"><![CDATA[
 
     ''' <summary>
     ''' A list of the types of the arguments.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetTypes() As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
 
         Helper.Assert(Me.HasNamedArguments = False)
 
         For Each arg As PositionalArgument In m_Arguments
             If arg.Expression IsNot Nothing Then
                 result.Add(arg.Expression.ExpressionType)
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="266" endline="275"><![CDATA[
 
     ReadOnly Property HasNamedArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is NamedArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="276" endline="286"><![CDATA[
     End Property
 
     ReadOnly Property HasPositionalArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is PositionalArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="287" endline="292"><![CDATA[
     End Property
 
     ReadOnly Property Arguments() As Generic.List(Of Argument)
         Get
             Return m_Arguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="293" endline="297"><![CDATA[
     End Property
 
     <Obsolete("Use GenerateCode(EmitInfo, Type())")> Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return Helper.GenerateCodeCollection(m_Arguments, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="298" endline="307"><![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal Types() As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Types.Length = Me.Count)
 
         For i As Integer = 0 To Count - 1
             result = Item(i).GenerateCode(Info.Clone(Me, True, False, Types(i)), Nothing) AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="308" endline="324"><![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal params As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(params.Count >= Me.Count)
 
         For i As Integer = 0 To Count - 1
             result = Item(i).GenerateCode(Info.Clone(Me, True, False, params(i).ParameterType), params(i)) AndAlso result
         Next
 
         For i As Integer = Count To params.Count - 1
             Helper.Assert(params(i).IsOptional)
             Emitter.EmitLoadValue(Info.Clone(Me, params(i).ParameterType), params(i).Constant)
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="325" endline="332"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="333" endline="336"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return Helper.ResolveTypeReferencesCollection(m_Arguments)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="337" endline="341"><![CDATA[
 
     Default ReadOnly Property Item(ByVal Index As Integer) As Argument
         Get
             Return DirectCast(m_Arguments.Item(Index), Argument)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="342" endline="347"><![CDATA[
     End Property
 
     ReadOnly Property Length() As Integer
         Get
             Return Count
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="348" endline="353"><![CDATA[
     End Property
 
     ReadOnly Property Count() As Integer
         Get
             Return m_Arguments.Count
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="40" endline="42"><![CDATA[
         Get
             Return m_ArrayElementInitializer
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="43" endline="48"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="49" endline="59"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_ArrayElementInitializer IsNot Nothing Then result = m_ArrayElementInitializer.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="60" endline="63"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="64" endline="69"><![CDATA[
 
     Sub Init(ByVal NonArrayTypeName As NonArrayTypeName, ByVal ArrayNameModifier As ArrayNameModifier, ByVal ArrayElementInitializer As ArrayElementInitializer)
         m_NonArrayTypeName = NonArrayTypeName
         m_ArrayNameModifier = ArrayNameModifier
         m_ArrayElementInitializer = ArrayElementInitializer
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="70" endline="75"><![CDATA[
 
     Sub Init(ByVal ArrayType As Mono.Cecil.TypeReference, ByVal InitializerElements As Expression())
         m_ExpressionType = ArrayType
         m_ArrayElementInitializer = New ArrayElementInitializer(Me)
         m_ArrayElementInitializer.Init(InitializerElements)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="76" endline="93"><![CDATA[
 
     Sub Init(ByVal ArrayType As Mono.Cecil.TypeReference, ByVal ArrayBounds() As Expression, ByVal InitializerElements As Expression())
         m_ExpressionType = ArrayType
 
         If ArrayBounds IsNot Nothing Then
             m_ArrayNameModifier = New ArrayNameModifier(Me)
             Dim newSizes As New ArraySizeInitializationModifier(Me)
             Dim bounds As New BoundList(newSizes)
             bounds.Init(ArrayBounds)
             newSizes.Init(bounds, Nothing)
             m_ArrayNameModifier.Init(newSizes)
         End If
 
         If InitializerElements IsNot Nothing Then
             m_ArrayElementInitializer = New ArrayElementInitializer(Me)
             m_ArrayElementInitializer.Init(InitializerElements)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="94" endline="110"><![CDATA[
 
     Public Shared Sub EmitArrayCreation(ByVal Parent As ParsedObject, ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal asim As ArraySizeInitializationModifier)
         Dim Ranks As Integer = asim.BoundList.Expressions.Length
         For i As Integer = 0 To Ranks - 1
             Dim litexp As New ConstantExpression(Parent, 1, Parent.Compiler.TypeCache.System_Int32)
             Dim exp As Expression
 
             exp = New BinaryAddExpression(Parent, asim.BoundList.Expressions(i), litexp)
             exp = New CIntExpression(Parent, exp)
 
             If exp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) = False Then Throw New InternalException(Parent)
             If exp.GenerateCode(Info.Clone(Parent, True)) = False Then Throw New InternalException(Parent)
 
             'Emitter.EmitConversion(exp.ExpressionType, Parent.Compiler.TypeCache.System_Int32, Info)
         Next
         EmitArrayConstructor(Info, ArrayType, Ranks)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="111" endline="129"><![CDATA[
 
 
     ''' <summary>
     ''' Creates an array of the specified type and number of elements (and ranks)
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="arraytype"></param>
     ''' <param name="Elements"></param>
     ''' <remarks></remarks>
     Public Shared Sub EmitArrayCreation(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Elements As Generic.List(Of Integer))
         If Elements.Count = 0 Then
             Emitter.EmitLoadI4Value(Info, 0)
         Else
             For i As Integer = 0 To Elements.Count - 1
                 Emitter.EmitLoadI4Value(Info, Elements(i))
             Next
         End If
         EmitArrayConstructor(Info, ArrayType, Elements.Count)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="130" endline="150"><![CDATA[
 
     ''' <summary>
     ''' Emits the array constructor.
     ''' The number of elements for each rank must be emitted already.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ArrayType"></param>
     ''' <param name="Ranks"></param>
     ''' <remarks></remarks>
     Public Shared Sub EmitArrayConstructor(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Ranks As Integer)
         If Ranks <= 1 Then
             Emitter.EmitNewArr(Info, CecilHelper.GetElementType(ArrayType))
         Else
             Dim minfo As Mono.Cecil.MethodReference
             minfo = New Mono.Cecil.MethodReference(".ctor", ArrayType, Info.Compiler.TypeCache.System_Void, True, False, Mono.Cecil.MethodCallingConvention.Default)
             For i As Integer = 1 To Ranks
                 minfo.Parameters.Add(New Mono.Cecil.ParameterDefinition(Info.Compiler.TypeCache.System_Int32))
             Next
             Emitter.EmitNew(Info, minfo)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="151" endline="182"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim ArrayType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, ExpressionType())
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, ArrayType)
 
         If m_ArrayNameModifier Is Nothing OrElse m_ArrayNameModifier.IsArrayTypeModifiers Then
             EmitArrayCreation(Info, ArrayType, m_ArrayElementInitializer.Elements)
         ElseIf m_ArrayNameModifier.IsArraySizeInitializationModifier Then
             EmitArrayCreation(Me, Info, ArrayType, m_ArrayNameModifier.AsArraySizeInitializationModifier)
         Else
             Throw New InternalException(Me)
         End If
 
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         If m_ArrayElementInitializer IsNot Nothing AndAlso m_ArrayElementInitializer.Initializers IsNot Nothing Then
             With m_ArrayElementInitializer.Initializers
                 Dim indices As New Generic.List(Of Integer)
                 For i As Integer = 0 To .List.ToArray.GetUpperBound(0)
                     indices.Add(i)
                     result = EmitElementInitializer(Info, .List.ToArray()(i), 1, i, tmpVar, ArrayType, indices) AndAlso result
                     indices.RemoveAt(indices.Count - 1)
                 Next
             End With
         End If
 
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="183" endline="222"><![CDATA[
 
     Private Function EmitElementInitializer(ByVal Info As EmitInfo, ByVal Initializer As VariableInitializer, ByVal CurrentDepth As Integer, ByVal ElementIndex As Integer, ByVal ArrayVariable As Mono.Cecil.Cil.VariableDefinition, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Indices As Generic.List(Of Integer)) As Boolean
         Dim result As Boolean = True
         Dim vi As VariableInitializer = Initializer
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
 
         If vi.IsRegularInitializer Then
             Emitter.EmitLoadVariable(Info, ArrayVariable)
             For i As Integer = 0 To Indices.Count - 1
                 Emitter.EmitLoadValue(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32), Indices(i))
             Next
             If CecilHelper.IsValueType(elementType) AndAlso CecilHelper.IsPrimitive(Compiler, elementType) = False AndAlso Helper.IsEnum(Compiler, elementType) = False Then
                 Emitter.EmitLoadElementAddress(Info, elementType, ArrayType)
             End If
 
             result = vi.AsRegularInitializer.GenerateCode(Info.Clone(Me, True, False, elementType)) AndAlso result
             If CurrentDepth = 1 Then
                 Emitter.EmitStoreElement(Info, elementType, ArrayType)
             Else
                 Dim setmethod As Mono.Cecil.MethodReference
                 setmethod = New Mono.Cecil.MethodReference("Set", ArrayType, Compiler.TypeCache.System_Void, True, False, Mono.Cecil.MethodCallingConvention.Default)
                 For i As Integer = 0 To CurrentDepth - 1
                     setmethod.Parameters.Add(New Mono.Cecil.ParameterDefinition(Compiler.TypeCache.System_Int32))
                 Next
                 setmethod.Parameters.Add(New Mono.Cecil.ParameterDefinition(CecilHelper.GetElementType(ArrayType)))
                 'setmethod = CecilHelper.FindDefinition(ArrayType).Methods.GetMethod("Set", settypes)
                 Emitter.EmitCallOrCallVirt(Info, setmethod)
             End If
         ElseIf vi.IsArrayElementInitializer Then
             For i As Integer = 0 To vi.AsArrayElementInitializer.Initializers.List.ToArray.GetUpperBound(0)
                 Indices.Add(i)
                 result = EmitElementInitializer(Info, vi.AsArrayElementInitializer.Initializers.List.ToArray()(i), CurrentDepth + 1, i, ArrayVariable, ArrayType, Indices) AndAlso result
                 Indices.RemoveAt(Indices.Count - 1)
             Next
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="223" endline="255"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ExpressionType Is Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
             If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveCode(Info) AndAlso result
 
             Dim tmptp As Mono.Cecil.TypeReference = m_NonArrayTypeName.ResolvedType
             If m_ArrayNameModifier.IsArraySizeInitializationModifier Then
                 tmptp = m_ArrayNameModifier.AsArraySizeInitializationModifier.CreateArrayType(tmptp)
             ElseIf m_ArrayNameModifier.IsArrayTypeModifiers Then
                 tmptp = m_ArrayNameModifier.AsArrayTypeModifiers.CreateArrayType(tmptp)
             Else
                 Throw New InternalException(Me)
             End If
             m_ExpressionType = tmptp
         End If
 
         If m_ArrayElementInitializer IsNot Nothing Then
             Dim elementInfo As New ExpressionResolveInfo(Compiler, m_ExpressionType)
             result = m_ArrayElementInitializer.ResolveCode(elementInfo) AndAlso result
         End If
 
         If m_ArrayNameModifier IsNot Nothing Then
             Dim elementInfo As New ExpressionResolveInfo(Compiler, m_ExpressionType)
             result = m_ArrayNameModifier.ResolveCode(elementInfo) AndAlso result
         End If
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="256" endline="266"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             If Me.IsResolved Then
                 Return m_ExpressionType
             ElseIf m_ExpressionType IsNot Nothing Then
                 Return m_ExpressionType
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="25" endline="27"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     Private m_Initializers As New Expressions
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="28" endline="32"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Initializers As Expressions)
         MyBase.New(Parent)
     Private m_Initializers As New Expressions
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Initializers As Expressions)
         MyBase.New(Parent)
         m_Initializers = Initializers
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="33" endline="36"><![CDATA[
 
     Sub Init(ByVal Initializers As Expressions)
         m_Initializers = Initializers
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="37" endline="41"><![CDATA[
 
     Sub Init(ByVal Arguments As Generic.List(Of Argument))
 
         m_Initializers = Initializers
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="42" endline="46"><![CDATA[
 
     ReadOnly Property Initializers() As Expressions
         Get
             Return m_Initializers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="47" endline="57"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For Each exp As Expression In m_Initializers
             result = exp.ResolveExpression(Info) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="23" endline="70"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="71" endline="74"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="75" endline="79"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.AndAlso
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="80" endline="85"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="86" endline="102"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) AndAlso CBool(rvalue)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="24" endline="38"><![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="39" endline="62"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitAnd(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AndObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="63" endline="66"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="67" endline="71"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.And
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="72" endline="77"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="78" endline="136"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) AndAlso CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) And CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) And CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) And CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) And CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) And CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) And CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) And CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) And CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) And CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) And CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) And CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="23" endline="45"><![CDATA[
     Protected Overrides Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressions(Info) AndAlso result
 
         If result = False Then Return result
 
         Dim l, lS, r, rS As Boolean
         l = Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         r = Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         If l = False Then lS = Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_String)
         If r = False Then rS = Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_String)
 
         If (l AndAlso rS) Then 'DBNull + String
             m_LeftExpression = New NothingConstantExpression(Me)
             result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         ElseIf (lS AndAlso r) Then 'String + DBNull
             m_RightExpression = New NothingConstantExpression(Me)
             result = m_RightExpression.ResolveExpression(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="46" endline="74"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="75" endline="78"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="79" endline="83"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Add
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="84" endline="92"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean
 
         result = MyBase.ResolveExpressionInternal(Info)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="93" endline="97"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="98" endline="191"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) & CStr(rvalue)
                 End If
 
                 Dim csmallest As TypeCode
                 csmallest = vbnc.TypeConverter.GetBinaryAddResultType(clvalue, crvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Dim tmp As UShort = CUShort(lvalue) + CUShort(rvalue)
                         If tmp < Byte.MinValue OrElse tmp > Byte.MaxValue Then
                             Return tmp
                         Else
                             Return CByte(tmp)
                         End If
                     Case TypeCode.SByte
                         Dim tmp As Short = CShort(lvalue) + CShort(rvalue)
                         If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                             Return tmp
                         Else
                             Return CSByte(tmp)
                         End If
                     Case TypeCode.Int16
                         Dim tmp As Integer = CInt(lvalue) + CInt(rvalue)
                         If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                             Return tmp
                         Else
                             Return CShort(tmp)
                         End If
                     Case TypeCode.UInt16
                         Dim tmp As UInteger = CUInt(lvalue) + CUInt(rvalue)
                         If tmp > UShort.MaxValue Then
                             Return tmp
                         Else
                             Return CUShort(tmp)
                         End If
                     Case TypeCode.Int32
                         Dim tmp As Long = CLng(lvalue) + CLng(rvalue)
                         If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                             Return tmp
                         Else
                             Return CInt(tmp)
                         End If
                     Case TypeCode.UInt32
                         Dim tmp As ULong = CULng(lvalue) + CULng(rvalue)
                         If tmp > UInteger.MaxValue Then
                             Return tmp
                         Else
                             Return CUInt(tmp)
                         End If
                     Case TypeCode.Int64
                         Dim tmp As Double = CLng(lvalue) + CLng(rvalue)
                         If tmp < Long.MinValue OrElse tmp > Long.MaxValue Then
                             Return tmp
                         Else
                             Return CLng(tmp)
                         End If
                     Case TypeCode.UInt64
                         Dim tmp As Double = CULng(lvalue) + CULng(rvalue)
                         If tmp < ULong.MinValue OrElse tmp > ULong.MaxValue Then
                             Return tmp
                         Else
                             Return CULng(tmp)
                         End If
                     Case TypeCode.Double
                         Return CDbl(lvalue) + CDbl(rvalue) 'No overflow possible
                     Case TypeCode.Single
                         Return CSng(lvalue) + CSng(rvalue) 'No overflow possible
                     Case TypeCode.Decimal
                         Return CDec(lvalue) + CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="46" endline="48"><![CDATA[
         Get
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="49" endline="58"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveTypeReferences AndAlso result
         result = m_RightExpression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="59" endline="67"><![CDATA[
 
     Private Function GetValueType(ByVal tp As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(tp IsNot Nothing)
         If TypeOf tp Is ByReferenceType Then
             Return tp.GetElementType
         Else
             Return tp
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="68" endline="72"><![CDATA[
 
     ReadOnly Property LeftType() As Mono.Cecil.TypeReference
         Get
             Return GetValueType(m_LeftExpression.ExpressionType)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="73" endline="78"><![CDATA[
     End Property
 
     ReadOnly Property RightType() As Mono.Cecil.TypeReference
         Get
             Return GetValueType(m_RightExpression.ExpressionType)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="79" endline="84"><![CDATA[
     End Property
 
     ReadOnly Property LeftTypeCode() As TypeCode
         Get
             Return Helper.GetTypeCode(Compiler, LeftType)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="85" endline="90"><![CDATA[
     End Property
 
     ReadOnly Property RightTypeCode() As TypeCode
         Get
             Return Helper.GetTypeCode(Compiler, RightType)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="91" endline="95"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(Enums.BinaryOperators)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="96" endline="101"><![CDATA[
 
     Protected Sub ValidateBeforeGenerateCode(ByVal Info As EmitInfo)
         Helper.Assert(m_LeftExpression.Classification.CanBeValueClassification, "Left expression cannot be a value classification
         Helper.Assert(m_RightExpression.Classification.CanBeValueClassification, "Right expression cannot be a value classification
         Helper.Assert(Info.IsRHS, "Expression is not a right hand side expression.")
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="102" endline="106"><![CDATA[
 
     ReadOnly Property OperandType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeResolution.TypeCodeToType(OperandTypeCode)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="107" endline="116"><![CDATA[
     End Property
 
     ReadOnly Property OperandTypeCode() As TypeCode
         Get
             Dim result As TypeCode
 
             result = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, LeftType, RightType)
 
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="117" endline="135"><![CDATA[
     End Property
 
     Protected Overridable Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         result = m_RightExpression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return False
 
         If m_LeftExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_LeftExpression, Info) AndAlso result
         End If
 
         If m_RightExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_RightExpression, Info) AndAlso result
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="136" endline="235"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim operandType As TypeCode
         Dim rightOperandType As TypeCode
         Dim leftOperandType As TypeCode
 
         result = ResolveExpressions(Info) AndAlso result
 
         If result = False Then Return False
 
         If Helper.CompareType(m_LeftExpression.ExpressionType, m_RightExpression.ExpressionType) = False Then
             If Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.Nothing) Then
                 m_LeftExpression = New CTypeExpression(Me, m_LeftExpression, m_RightExpression.ExpressionType)
                 result = m_LeftExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             ElseIf Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.Nothing) Then
                 m_RightExpression = New CTypeExpression(Me, m_RightExpression, m_LeftExpression.ExpressionType)
                 result = m_RightExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             End If
         End If
 
         operandType = Me.OperandTypeCode
         rightOperandType = Me.RightOperandTypeCode
         leftOperandType = Me.LeftOperandTypeCode
 
         If operandType = TypeCode.Empty Then
             'Try operator overloading
             If DoOperatorOverloading() = False Then
                 If (Me.Keyword = KS.ShiftLeft OrElse Me.Keyword = KS.ShiftRight) AndAlso Helper.CompareType(Me.LeftType, Compiler.TypeCache.System_Char) = False AndAlso Helper.CompareType(Me.LeftType, Compiler.TypeCache.System_DateTime) = False Then
                     If Helper.CompareType(Me.RightType, Compiler.TypeCache.System_Char) Then
                         Compiler.Report.ShowMessage(Messages.VBNC32006, Location, Me.LeftType.Name)
                     ElseIf Helper.CompareType(Me.RightType, Compiler.TypeCache.System_DateTime) Then
                         Compiler.Report.ShowMessage(Messages.VBNC30311, Location, Me.LeftType.Name, Me.RightType.Name)
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30452, Location, Enums.strSpecial(Me.Keyword), Me.LeftType.Name, Me.RightType.Name)
                     End If
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC30452, Location, Enums.strSpecial(Me.Keyword), Me.LeftType.Name, Me.RightType.Name)
                 End If
                 result = False
             End If
         Else
             'If X and Y are both intrinsic types, look up the result type in our operator tables and use that.
             'If X is an intrinsic type, then
             '- Collect all of the intrinsic types that Y converts to.
             '- Choose the most encompassed type, T, from the list. If there is no single most encompassed type, then we don't consider an intrinsic operator.
             '- Lookup up the intrinsic operator for X and T, and call it O. If there is no intrinsic operator defined for those two types, then we don't consider an intrinsic operator.
             '- The set of operators to be considered is all the user-defined operators in Y, plus O, if it exists.
             'If Y is an intrinsic type, then perform the same steps as for X (obviously, both can't be intrinsic types at this point).
             'Do overload resolution on the set of operators to be considered.
             Dim isLeftIntrinsic As Boolean = Me.LeftTypeCode <> TypeCode.Object OrElse Helper.CompareType(Compiler.TypeCache.System_Object, Me.LeftType)
             Dim isRightIntrinsic As Boolean = Me.RightTypeCode <> TypeCode.Object OrElse Helper.CompareType(Compiler.TypeCache.System_Object, Me.RightType)
             Dim doOpOverloading As Boolean = False
 
             If isLeftIntrinsic AndAlso isRightIntrinsic OrElse IsOverloadable = False Then
                 Dim destinationType As Mono.Cecil.TypeReference
                 m_ExpressionType = Compiler.TypeResolution.TypeCodeToType(TypeConverter.GetBinaryResultType(Keyword, LeftTypeCode, RightTypeCode))
                 If LeftTypeCode <> leftOperandType Then
                     destinationType = Compiler.TypeResolution.TypeCodeToType(leftOperandType)
                     m_LeftExpression = Helper.CreateTypeConversion(Me, m_LeftExpression, destinationType, result)
                 End If
 
                 If RightTypeCode <> rightOperandType Then
                     destinationType = Compiler.TypeResolution.TypeCodeToType(rightOperandType)
                     m_RightExpression = Helper.CreateTypeConversion(Me, m_RightExpression, destinationType, result)
                 End If
                 Classification = New ValueClassification(Me)
             ElseIf isRightIntrinsic = False AndAlso isLeftIntrinsic = True Then
                 Dim convertsTo As TypeCode() = TypeResolution.GetIntrinsicTypesImplicitlyConvertibleFrom(Compiler, RightType)
                 convertsTo = Helper.GetMostEncompassedTypes(Compiler, convertsTo)
 
                 If convertsTo IsNot Nothing AndAlso convertsTo.Length = 1 Then
                     m_RightExpression = Helper.CreateTypeConversion(Me, m_RightExpression, Compiler.TypeResolution.TypeCodeToType(convertsTo(0)), result)
                     m_ExpressionType = Compiler.TypeResolution.TypeCodeToType(TypeConverter.GetBinaryResultType(Keyword, LeftTypeCode, RightTypeCode))
                     Classification = New ValueClassification(Me)
                 Else
                     doOpOverloading = True
                 End If
             ElseIf isRightIntrinsic = True AndAlso isLeftIntrinsic = False Then
                 Dim convertsTo As TypeCode() = TypeResolution.GetIntrinsicTypesImplicitlyConvertibleFrom(Compiler, LeftType)
                 convertsTo = Helper.GetMostEncompassedTypes(Compiler, convertsTo)
 
                 If convertsTo IsNot Nothing AndAlso convertsTo.Length = 1 Then
                     m_LeftExpression = Helper.CreateTypeConversion(Me, m_LeftExpression, Compiler.TypeResolution.TypeCodeToType(convertsTo(0)), result)
                     m_ExpressionType = Compiler.TypeResolution.TypeCodeToType(TypeConverter.GetBinaryResultType(Keyword, LeftTypeCode, RightTypeCode))
                     Classification = New ValueClassification(Me)
                 Else
                     doOpOverloading = True
                 End If
             Else
                 doOpOverloading = True
             End If
 
             If doOpOverloading Then
                 result = DoOperatorOverloading() AndAlso result
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="236" endline="260"><![CDATA[
 
     Function DoOperatorOverloading() As Boolean
         Dim result As Boolean = True
         Dim methods As New Generic.List(Of Mono.Cecil.MethodReference)
         Dim methodClassification As MethodGroupClassification
         methods = Helper.GetBinaryOperators(Compiler, CType(Me.Keyword, BinaryOperators), Me.LeftType)
         If Helper.CompareType(Me.LeftType, Me.RightType) = False Then
             Dim methods2 As New Generic.List(Of Mono.Cecil.MethodReference)
             methods2 = Helper.GetBinaryOperators(Compiler, CType(Me.Keyword, BinaryOperators), Me.RightType)
             For Each method As Mono.Cecil.MethodReference In methods2
                 If methods.Contains(method) = False Then methods.Add(method)
             Next
         End If
         If methods.Count = 0 Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30452, Me.Location, Enums.strSpecial(Me.Keyword), Me.LeftType.FullName, Me.RightType.FullName) AndAlso result
             If result = False Then Return result
         End If
         methodClassification = New MethodGroupClassification(Me, Nothing, Nothing, New Expression() {Me.m_LeftExpression, Me.m_RightExpression}, methods.ToArray)
         result = methodClassification.ResolveGroup(New ArgumentList(Me, Me.m_LeftExpression, m_RightExpression)) AndAlso result
         result = methodClassification.SuccessfullyResolved AndAlso result
         If result = False Then Return result
         m_ExpressionType = methodClassification.ResolvedMethodInfo.ReturnType
         Classification = methodClassification
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="261" endline="265"><![CDATA[
 
     Overridable ReadOnly Property RightOperandTypeCode() As TypeCode
         Get
             Return OperandTypeCode
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="266" endline="271"><![CDATA[
     End Property
 
     Overridable ReadOnly Property LeftOperandTypeCode() As TypeCode
         Get
             Return OperandTypeCode
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="272" endline="277"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_LeftExpression.IsConstant AndAlso m_RightExpression.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="278" endline="282"><![CDATA[
     End Property
 
     Protected Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="283" endline="290"><![CDATA[
 
     Protected Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent)
         m_LeftExpression = LExp
         m_LeftExpression.Parent = Me
         m_RightExpression = RExp
         m_RightExpression.Parent = Me
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="291" endline="295"><![CDATA[
 
     Protected Sub Init(ByVal LExp As Expression, ByVal RExp As Expression)
         m_LeftExpression = LExp
         m_RightExpression = RExp
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="296" endline="300"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="24" endline="48"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitSubOrSubOvfOrSubOvfUn(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitSub(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Subtract_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__SubtractObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="49" endline="53"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeResolution.TypeCodeToType(TypeConverter.GetBinarySubResultType(Helper.GetTypeCode(Compiler, m_LeftExpression.ExpressionType), Helper.GetTypeCode(Compiler, m_RightExpression.ExpressionType)))
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="54" endline="58"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="59" endline="63"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Minus
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="64" endline="69"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="70" endline="155"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = vbnc.TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, tlvalue, trvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         If CByte(lvalue) < CByte(rvalue) Then
                             Return CSByte(lvalue) - CSByte(rvalue)
                         Else
                             Return CByte(lvalue) - CByte(rvalue)
                         End If
                     Case TypeCode.SByte
                         Dim tmp As Short = CShort(lvalue) - CShort(rvalue)
                         If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                             Return tmp
                         Else
                             Return CSByte(tmp)
                         End If
                     Case TypeCode.Int16
                         Dim tmp As Integer = CInt(lvalue) - CInt(rvalue)
                         If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                             Return tmp
                         Else
                             Return CShort(tmp)
                         End If
                     Case TypeCode.UInt16
                         If CUShort(lvalue) < CUShort(rvalue) Then
                             Return CShort(lvalue) - CShort(rvalue)
                         Else
                             Return CUShort(lvalue) - CUShort(rvalue)
                         End If
                     Case TypeCode.Int32
                         Dim tmp As Long = CLng(lvalue) - CLng(rvalue)
                         If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                             Return tmp
                         Else
                             Return CInt(tmp)
                         End If
                     Case TypeCode.UInt32
                         If CUInt(lvalue) < CUInt(rvalue) Then
                             Return CInt(lvalue) - CInt(rvalue)
                         Else
                             Return CUInt(lvalue) - CUInt(rvalue)
                         End If
                     Case TypeCode.Int64
                         Dim tmp As Double = CLng(lvalue) - CLng(rvalue)
                         If tmp < Long.MinValue OrElse tmp > Long.MaxValue Then
                             Return tmp
                         Else
                             Return CLng(tmp)
                         End If
                     Case TypeCode.UInt64
                         If CULng(lvalue) < CULng(rvalue) Then
                             Return CLng(lvalue) - CLng(rvalue)
                         Else
                             Return CULng(lvalue) - CULng(rvalue)
                         End If
                     Case TypeCode.Double
                         Return CDbl(lvalue) - CDbl(rvalue) 'No overflow possible
                     Case TypeCode.Single
                         Return CSng(lvalue) - CSng(rvalue) 'No overflow possible
                     Case TypeCode.Decimal
                         Return CDec(lvalue) - CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="23" endline="58"><![CDATA[
     Protected Overrides Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressions(Info) AndAlso result
 
         If result = False Then Return result
 
         Dim l, r, other As Boolean
         l = Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         r = Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         If l AndAlso r = False Then 'DBNull & whatever
             m_LeftExpression = New NothingConstantExpression(Me)
             result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         ElseIf l = False AndAlso r Then 'whatever & DBNull
             m_RightExpression = New NothingConstantExpression(Me)
             result = m_RightExpression.ResolveExpression(Info) AndAlso result
         Else
             other = True
         End If
 
         If l = False Then
             If Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_Char_Array) Then
                 m_LeftExpression = New CStrExpression(Me, m_LeftExpression)
                 result = m_LeftExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If r = False Then
             If Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_Char_Array) Then
                 m_RightExpression = New CStrExpression(Me, m_RightExpression)
                 result = m_RightExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="59" endline="79"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConcatenateObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="80" endline="83"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="84" endline="88"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Concat
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="89" endline="95"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_LeftExpression.IsConstant AndAlso (Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_String) OrElse Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_Char)) _
               AndAlso m_RightExpression.IsConstant AndAlso (Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_String) OrElse Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_Char))
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="96" endline="108"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If IsConstant = False Then Throw New InternalException(Me)
 
             Dim rvalue, lvalue As String
 
             lvalue = CStr(m_LeftExpression.ConstantValue)
             rvalue = CStr(m_RightExpression.ConstantValue)
 
             Return lvalue & rvalue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" startline="23" endline="64"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Boolean, TypeCode.Char
                 Emitter.EmitEquals(Info, OperandType)
             Case TypeCode.DateTime
                 Helper.Assert(Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime IsNot Nothing, "Date_Compare__Date_Date Is Nothing")
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Helper.Assert(Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal IsNot Nothing, "Decimal_Compare__Decimal_Decimal Is Nothing")
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean IsNot Nothing, "MS_VB_CS_Operators_ConditionalCompareObjectEqual__Object_Object_Bool Is Nothing")
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 'Compiler.Report.WriteLine("MS_VB_CS_Operators_ConditionalCompareObjectEqual__Object_Object_Bool
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Helper.Assert(Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean IsNot Nothing, "MS_VB_CS_Operators_CompareString__String_String_Bool Is Nothing")
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 'Compiler.Report.WriteLine("MS_VB_CS_Operators_CompareString__String_String_Bool
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" startline="65" endline="68"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" startline="69" endline="73"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Equals
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" startline="74" endline="79"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" startline="80" endline="144"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) = CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) = CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) = CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) = CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) = CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) = CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) = CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) = CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) = CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) = CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) = CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) = CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) = CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) = CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) = CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) = CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" startline="23" endline="44"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Math__Pow_Double_Double)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ExponentObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" startline="45" endline="48"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" startline="49" endline="53"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Power
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" startline="54" endline="59"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" startline="60" endline="88"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
 
             If lvalue Is Nothing Then lvalue = 0
             If rvalue Is Nothing Then rvalue = 0
 
             Dim tlvalue, trvalue As Mono.Cecil.TypeReference
             Dim clvalue, crvalue As TypeCode
             tlvalue = CecilHelper.GetType(Compiler, lvalue)
             clvalue = Helper.GetTypeCode(Compiler, tlvalue)
             trvalue = CecilHelper.GetType(Compiler, rvalue)
             crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
             Helper.Assert(Compiler.TypeResolution.IsNumericType(tlvalue) AndAlso Compiler.TypeResolution.IsNumericType(trvalue))
 
             'An exponent operator always returns a double result.
             Select Case clvalue
                 Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, _
                  TypeCode.Int64, TypeCode.UInt64, TypeCode.Double, TypeCode.Single, TypeCode.Decimal
                     Return Math.Pow(CDbl(lvalue), CDbl(rvalue))
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="23" endline="62"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="63" endline="66"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="67" endline="71"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.GE
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="72" endline="77"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="78" endline="142"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) >= CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) >= CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) >= CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) >= CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) >= CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) >= CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) >= CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) >= CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) >= CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) >= CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) >= CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) >= CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) >= CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) >= CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) >= CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) >= CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" startline="23" endline="62"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" startline="63" endline="66"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" startline="67" endline="71"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.GT
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" startline="72" endline="77"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" startline="78" endline="142"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) > CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) > CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) > CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) > CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) > CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) > CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) > CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) > CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) > CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) > CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) > CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) > CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) > CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) > CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) > CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) > CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="23" endline="44"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitIntDiv(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__IntDivideObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="45" endline="48"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="49" endline="53"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.IntDivision
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="54" endline="59"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="60" endline="135"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
                 If CDbl(rvalue) = 0 Then
                     Helper.Stop() 'TODO
                 End If
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) \ CByte(rvalue)
                     Case TypeCode.SByte
                         If CSByte(lvalue) = SByte.MinValue AndAlso CSByte(rvalue) = -1 Then
                             Return CShort(lvalue) \ CShort(rvalue)
                         Else
                             Return CSByte(lvalue) \ CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         If CShort(lvalue) = Short.MinValue AndAlso CShort(rvalue) = -1 Then
                             Return CInt(lvalue) \ CInt(rvalue)
                         Else
                             Return CShort(lvalue) \ CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) \ CUShort(rvalue)
                     Case TypeCode.Int32
                         If CInt(lvalue) = Integer.MinValue AndAlso CInt(rvalue) = -1 Then
                             Return CLng(lvalue) \ CLng(rvalue)
                         Else
                             Return CInt(lvalue) \ CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) / CUInt(rvalue)
                     Case TypeCode.Int64
                         If CLng(lvalue) = Long.MinValue AndAlso CLng(rvalue) = -1 Then
                             'Return CDec(lvalue) \ CDec(rvalue)
                             Throw New InternalException(Me)
                         Else
                             Return CLng(lvalue) \ CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         Return CULng(lvalue) \ CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) \ CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) \ CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) \ CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="28" endline="30"><![CDATA[
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="31" endline="48"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If result AndAlso CecilHelper.IsGenericParameter(m_LeftExpression.ExpressionType) Then
             m_LeftExpression = New BoxExpression(Me, m_LeftExpression, m_LeftExpression.ExpressionType)
             m_DesiredNothingType = Compiler.TypeCache.System_Object
         End If
         If result AndAlso CecilHelper.IsGenericParameter(m_RightExpression.ExpressionType) Then
             m_RightExpression = New BoxExpression(Me, m_RightExpression, m_RightExpression.ExpressionType)
             m_DesiredNothingType = Compiler.TypeCache.System_Object
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="49" endline="90"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         If CecilHelper.IsValueType(m_LeftExpression.ExpressionType) Then
             Throw New InternalException(Me)
         End If
         If CecilHelper.IsValueType(m_RightExpression.ExpressionType) Then
             Throw New InternalException(Me)
         End If
 
         Dim desiredType As Mono.Cecil.TypeReference = m_DesiredNothingType
         If TypeOf m_LeftExpression Is NothingConstantExpression = False Then
             If desiredType Is Nothing Then desiredType = m_LeftExpression.ExpressionType
         ElseIf TypeOf m_RightExpression Is NothingConstantExpression = False Then
             If desiredType Is Nothing Then desiredType = m_LeftExpression.ExpressionType
         Else
             'If Nothing Is / IsNot Nothing Then...
             Emitter.EmitLoadValue(Info, m_Keyword = KS.Is)
             Return result
         End If
 
         If desiredType IsNot Nothing Then
             If CecilHelper.IsByRef(desiredType) Then desiredType = CecilHelper.GetElementType(desiredType)
             Info = Info.Clone(Me, True, False, desiredType)
         End If
 
         result = m_LeftExpression.GenerateCode(Info) AndAlso result
         result = m_RightExpression.GenerateCode(Info) AndAlso result
 
         If Keyword = KS.Is Then
             Emitter.EmitIs(Info)
         ElseIf Keyword = KS.IsNot Then
             Emitter.EmitIsNot(Info)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="91" endline="95"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Boolean
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="96" endline="102"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression, ByVal Keyword As KS)
         MyBase.New(Parent, LExp, RExp)
         m_Keyword = Keyword
         Helper.Assert(m_Keyword = KS.Is OrElse m_Keyword = KS.IsNot)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="103" endline="107"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="108" endline="114"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Helper.Assert(m_Keyword = KS.Is OrElse m_Keyword = KS.IsNot)
             Return m_Keyword
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="23" endline="62"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="63" endline="67"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeResolution.TypeCodeToType(TypeConverter.GetLEResultType(Helper.GetTypeCode(Compiler, m_LeftExpression.ExpressionType), Helper.GetTypeCode(Compiler, m_RightExpression.ExpressionType)))
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="68" endline="72"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="73" endline="77"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.LE
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="78" endline="83"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="84" endline="148"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <= CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <= CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <= CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <= CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <= CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <= CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <= CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <= CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <= CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <= CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <= CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <= CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <= CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <= CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <= CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <= CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LikeExpression.vb" startline="24" endline="52"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Dim cmInfo As EmitInfo = Info.Clone(Me, True, False, Compiler.TypeCache.MS_VB_CompareMethod)
         If Info.IsOptionCompareText Then
             Emitter.EmitLoadValue(cminfo, Microsoft.VisualBasic.CompareMethod.Text)
         Else
             Emitter.EmitLoadValue(cmInfo, Microsoft.VisualBasic.CompareMethod.Binary)
         End If
 
         Select Case MyBase.OperandTypeCode
             Case TypeCode.String
                 Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_LikeOperator__LikeString_String_String_CompareMethod)
             Case TypeCode.Object
                 'Helper.Assert(Helper.CompareType(ExpressionType, Compiler.TypeCache.Object))
                 Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_LikeOperator__LikeObject_Object_Object_CompareMethod)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LikeExpression.vb" startline="53" endline="56"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LikeExpression.vb" startline="57" endline="61"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LikeExpression.vb" startline="62" endline="67"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Like
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="23" endline="57"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitLShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__LeftShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="58" endline="66"><![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="67" endline="71"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="72" endline="76"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.ShiftLeft
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="77" endline="82"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="83" endline="134"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim shifts As Integer 'This needs to be an integer.
                 Dim tmpShifts As Object = Nothing
                 If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
                     Helper.Stop() 'Add error.
                 Else
                     shifts = CInt(tmpShifts)
                 End If
 
                 Dim tlvalue As Mono.Cecil.TypeReference
                 Dim clvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
                 Select Case clvalue
                     Case TypeCode.Byte
                         Return CByte(lvalue) << shifts
                     Case TypeCode.SByte
                         Return CSByte(lvalue) << shifts
                     Case TypeCode.Int16
                         Return CShort(lvalue) << shifts
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) << shifts
                     Case TypeCode.Int32
                         Return CInt(lvalue) << shifts
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) << shifts
                     Case TypeCode.Int64
                         Return CLng(lvalue) << shifts
                     Case TypeCode.UInt64
                         Return CULng(lvalue) << shifts
                     Case TypeCode.Double
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" startline="23" endline="62"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" startline="63" endline="66"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" startline="67" endline="71"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.LT
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" startline="72" endline="77"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" startline="78" endline="142"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) < CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) < CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) < CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) < CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) < CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) < CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) < CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) < CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) < CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) < CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) < CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) < CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) < CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) < CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) < CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) < CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="23" endline="48"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Remainder_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ModObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="49" endline="52"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="53" endline="57"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Mod
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="58" endline="63"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="64" endline="114"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
 
             If lvalue Is Nothing Then lvalue = 0
             If rvalue Is Nothing Then rvalue = 0
 
             Dim tlvalue, trvalue As Mono.Cecil.TypeReference
             Dim clvalue, crvalue As TypeCode
             tlvalue = CecilHelper.GetType(Compiler, lvalue)
             clvalue = Helper.GetTypeCode(Compiler, tlvalue)
             trvalue = CecilHelper.GetType(Compiler, rvalue)
             crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
             Dim smallest As Mono.Cecil.TypeReference
             Dim csmallest As TypeCode
             smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
             Helper.Assert(smallest IsNot Nothing)
             csmallest = Helper.GetTypeCode(Compiler, smallest)
 
             Select Case csmallest
                 Case TypeCode.Byte
                     Return CByte(lvalue) Mod CByte(rvalue)
                 Case TypeCode.SByte
                     Return CSByte(lvalue) Mod CSByte(rvalue)
                 Case TypeCode.Int16
                     Return CShort(lvalue) Mod CShort(rvalue)
                 Case TypeCode.UInt16
                     Return CUShort(lvalue) Mod CUShort(rvalue)
                 Case TypeCode.Int32
                     Return CInt(lvalue) Mod CInt(rvalue)
                 Case TypeCode.UInt32
                     Return CUInt(lvalue) Mod CUInt(rvalue)
                 Case TypeCode.Int64
                     Return CLng(lvalue) Mod CLng(rvalue)
                 Case TypeCode.UInt64
                     Return CULng(lvalue) Mod CULng(rvalue)
                 Case TypeCode.Double
                     Return CDbl(lvalue) Mod CDbl(rvalue)
                 Case TypeCode.Single
                     Return CSng(lvalue) Mod CSng(rvalue)
                 Case TypeCode.Decimal
                     Return CDec(lvalue) Mod CDec(rvalue)
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="23" endline="48"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMultOrMultOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMult(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Multiply_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__MultiplyObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="49" endline="52"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="53" endline="57"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Mult
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="58" endline="63"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'This is not quite true...
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="64" endline="156"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim lvalue, rvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing OrElse rvalue Is Nothing Then
                 Return Nothing
             Else
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, tlvalue, trvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Dim tmp As UShort = CUShort(lvalue) * CUShort(rvalue)
                         If tmp < Byte.MinValue OrElse tmp > Byte.MaxValue Then
                             Return tmp
                         Else
                             Return CByte(lvalue) * CByte(rvalue)
                         End If
                     Case TypeCode.SByte
                         Dim tmp As Short = CShort(lvalue) * CShort(rvalue)
                         If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                             Return tmp
                         Else
                             Return CSByte(lvalue) * CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         Dim tmp As Integer = CInt(lvalue) * CInt(rvalue)
                         If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                             Return tmp
                         Else
                             Return CShort(lvalue) * CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Dim tmp As UInteger = CUInt(lvalue) * CUInt(rvalue)
                         If tmp > UShort.MaxValue Then
                             Return tmp
                         Else
                             Return CUShort(lvalue) * CUShort(rvalue)
                         End If
                     Case TypeCode.Int32
                         Dim tmp As Long = CLng(lvalue) * CLng(rvalue)
                         If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                             Return tmp
                         Else
                             Return CInt(lvalue) * CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Dim tmp As ULong = CULng(lvalue) * CULng(rvalue)
                         If tmp > UInteger.MaxValue Then
                             Return tmp
                         Else
                             Return CUInt(lvalue) * CUInt(rvalue)
                         End If
                     Case TypeCode.Int64
                         Dim tmp As Double
                         If CLng(rvalue) < 0 Then
                             tmp = Long.MaxValue / -CLng(rvalue)
                         Else
                             tmp = Long.MaxValue / CLng(rvalue)
                         End If
                         If CLng(lvalue) < 0 AndAlso -CLng(lvalue) > tmp OrElse CLng(lvalue) > tmp Then
                             Return CDec(lvalue) * CDec(rvalue)
                         Else
                             Return CLng(lvalue) * CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         If CULng(lvalue) > ULong.MaxValue / CULng(rvalue) Then
                             Return CDec(lvalue) * CDec(rvalue)
                         Else
                             Return CULng(lvalue) * CULng(rvalue)
                         End If
                     Case TypeCode.Double
                         Return CDbl(lvalue) * CDbl(rvalue) 'No overflow possible
                     Case TypeCode.Single
                         Return CSng(lvalue) * CSng(rvalue) 'No overflow possible
                     Case TypeCode.Decimal
                         Return CDec(lvalue) * CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="23" endline="58"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Boolean, TypeCode.Char
                 Emitter.EmitNotEquals(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitNotEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitnotEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectNotEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitNotEquals(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="59" endline="63"><![CDATA[
 
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="64" endline="68"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.NotEqual
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="69" endline="74"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="75" endline="136"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <> CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <> CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <> CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 End If
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetNotEqualsOperandType(clvalue, crvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <> CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <> CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <> CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <> CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <> CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <> CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <> CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <> CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <> CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <> CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <> CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="23" endline="67"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadtrue, endexp As Label
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
           
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="68" endline="71"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="72" endline="76"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.OrElse
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="77" endline="82"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="83" endline="99"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) OrElse CBool(rvalue)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="24" endline="38"><![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="39" endline="62"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__OrObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="63" endline="66"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="67" endline="71"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Or
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="72" endline="77"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="78" endline="135"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) OrElse CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) Or CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) Or CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) Or CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) Or CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) Or CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) Or CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) Or CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) Or CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) Or CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) Or CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) Or CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RealDivisionExpression.vb" startline="23" endline="46"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitRealDiv(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Divide_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__DivideObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RealDivisionExpression.vb" startline="47" endline="50"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RealDivisionExpression.vb" startline="51" endline="55"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.RealDivision
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RealDivisionExpression.vb" startline="56" endline="61"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RealDivisionExpression.vb" startline="62" endline="132"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetRealDivResultType(clvalue, crvalue)
 
                 If CDbl(rvalue) = 0 Then
                     Helper.AddError(Me, "Divide by zero")
                     Return Double.NaN
                 End If
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) / CByte(rvalue)
                     Case TypeCode.SByte
                         If CSByte(lvalue) = SByte.MinValue AndAlso CSByte(rvalue) = -1 Then
                             Return CShort(lvalue) / CShort(rvalue)
                         Else
                             Return CSByte(lvalue) / CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         If CShort(lvalue) = Short.MinValue AndAlso CShort(rvalue) = -1 Then
                             Return CInt(lvalue) / CInt(rvalue)
                         Else
                             Return CShort(lvalue) / CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) / CUShort(rvalue)
                     Case TypeCode.Int32
                         If CInt(lvalue) = Integer.MinValue AndAlso CInt(rvalue) = -1 Then
                             Return CLng(lvalue) / CLng(rvalue)
                         Else
                             Return CInt(lvalue) / CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) / CUInt(rvalue)
                     Case TypeCode.Int64
                         If CLng(lvalue) = Long.MinValue AndAlso CLng(rvalue) = -1 Then
                             Return CDec(lvalue) / CDec(rvalue)
                         Else
                             Return CLng(lvalue) / CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         Return CULng(lvalue) / CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) / CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) / CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) / CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="23" endline="58"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitRShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__RightShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="59" endline="67"><![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="68" endline="72"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="73" endline="77"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.ShiftRight
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="78" endline="83"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="84" endline="135"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim shifts As Integer 'This needs to be an integer.
                 Dim tmpShifts As Object = Nothing
                 If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
                     Helper.Stop() 'Add error.
                 Else
                     shifts = CInt(tmpShifts)
                 End If
 
                 Dim tlvalue As Mono.Cecil.TypeReference
                 Dim clvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
                 Select Case clvalue
                     Case TypeCode.Byte
                         Return CByte(lvalue) >> shifts
                     Case TypeCode.SByte
                         Return CSByte(lvalue) >> shifts
                     Case TypeCode.Int16
                         Return CShort(lvalue) >> shifts
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) >> shifts
                     Case TypeCode.Int32
                         Return CInt(lvalue) >> shifts
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) >> shifts
                     Case TypeCode.Int64
                         Return CLng(lvalue) >> shifts
                     Case TypeCode.UInt64
                         Return CULng(lvalue) >> shifts
                     Case TypeCode.Double
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="23" endline="44"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitXOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__XorObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="45" endline="48"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent, LExp, RExp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="49" endline="53"><![CDATA[
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Or
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="54" endline="59"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return MyBase.IsConstant 'CHECK
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="60" endline="118"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) Xor CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) Xor CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) Xor CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) Xor CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) Xor CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) Xor CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) Xor CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) Xor CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) Xor CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) xor CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) xor CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) Xor CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="25" endline="27"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="28" endline="31"><![CDATA[
 
     Shadows Sub Init(ByVal Value As Boolean)
         m_Value = Value
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="32" endline="38"><![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New BooleanLiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="39" endline="44"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
 
             Return Compiler.TypeCache.System_Boolean
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="45" endline="50"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_Value
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BoxExpression.vb" startline="33" endline="49"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression, ByVal DestinationType As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         m_DestinationType = DestinationType
         m_Expression = Expression
 
         Helper.Assert(m_DestinationType IsNot Nothing)
         Helper.Assert(m_Expression IsNot Nothing)
         Helper.Assert(m_Expression.IsResolved)
         Helper.Assert(TypeOf Expression Is BoxExpression = False)
 
         Classification = New ValueClassification(Me, m_DestinationType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Compiler)) = False Then
             Helper.ErrorRecoveryNotImplemented(Me.Location)
         End If
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BoxExpression.vb" startline="50" endline="54"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BoxExpression.vb" startline="55" endline="59"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BoxExpression.vb" startline="60" endline="74"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim tp As TypeReference
 
         result = m_Expression.GenerateCode(Info) AndAlso result
 
         tp = m_Expression.ExpressionType
         If CecilHelper.IsByRef(tp) Then
             tp = CecilHelper.GetElementType(tp)
         End If
         Emitter.EmitBox(Info, tp)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BoxExpression.vb" startline="75" endline="79"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_DestinationType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BuiltInTypeExpression.vb" startline="25" endline="27"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BuiltInTypeExpression.vb" startline="28" endline="31"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BuiltInTypeExpression.vb" startline="32" endline="35"><![CDATA[
 
     Sub Init(ByVal Type As BuiltInDataTypes)
         m_Type = Type
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BuiltInTypeExpression.vb" startline="36" endline="40"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Classification = New TypeClassification(Me, ExpressionType)
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BuiltInTypeExpression.vb" startline="41" endline="47"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
 
             'Return New TypeDescriptor(TypeResolution.BuiltInTypeToType(m_Type))
             Return Compiler.TypeResolution.BuiltInTypeToType(m_Type)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BuiltInTypeExpression.vb" startline="48" endline="53"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="26" endline="29"><![CDATA[
     Sub New(ByVal Parent As Expression, ByVal Expression As Expression)
         MyBase.new(Parent)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="30" endline="43"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Local Is Nothing Then
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
             m_Local = Emitter.DeclareLocal(Info, m_Expression.ExpressionType)
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Emitter.EmitLoadVariable(Info, m_Local)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="44" endline="48"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_Expression.ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="49" endline="54"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="55" endline="69"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info)
         Else
             result = True
         End If
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CaseComparisonExpression.vb" startline="26" endline="30"><![CDATA[
     Sub New(ByVal Parent As CaseStatement, ByVal Test As Expression, ByVal [Operator] As KS)
         MyBase.New(Parent)
         m_Test = Test
         m_Operator = [Operator]
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CaseComparisonExpression.vb" startline="31" endline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CaseRangeExpression.vb" startline="26" endline="30"><![CDATA[
     Sub New(ByVal Parent As CaseStatement, ByVal [From] As Expression, ByVal [To] As Expression)
         MyBase.New(Parent)
         m_From = [From]
         m_To = [To]
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CaseRangeExpression.vb" startline="31" endline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="34" endline="36"><![CDATA[
     Shared Function CreateAndParseTo(ByRef result As Expression) As Boolean
         Return result.Compiler.Report.ShowMessage(Messages.VBNC99997, result.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="37" endline="40"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(Enums.CastExpressionTargets)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="49" endline="52"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="35" endline="37"><![CDATA[
         Get
             Return m_EventInfo
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="38" endline="49"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The type that contains the add_, remove_ and raise_ methods.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property EventType() As Mono.Cecil.TypeReference
         Get
             Return m_EventInfo.EventType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="50" endline="66"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the instance expression onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="67" endline="77"><![CDATA[
 
     ''' <summary>
     ''' The delegate type of the event handler.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             Return m_EventInfo.EventType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="78" endline="83"><![CDATA[
     End Property
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             Return m_InstanceExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="84" endline="90"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal EventInfo As Mono.Cecil.EventReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.new(Classifications.EventAccess, Parent)
         m_EventInfo = EventInfo
         m_InstanceExpression = InstanceExpression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="35" endline="37"><![CDATA[
         Get
             Return m_Parent
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="38" endline="43"><![CDATA[
     End Property
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Parent.Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="57" endline="66"><![CDATA[
     End Property
 
     Overridable ReadOnly Property ConstantValue() As Object
         Get
             'IsConstant should have been called before ConstantValue
             'and if a classification overrides IsConstant to return true,
             'it should also override ConstantValue
             Helper.StopIfDebugging()
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="67" endline="94"><![CDATA[
     End Property
 
     Overloads Function [GetType](ByVal ThrowIfNoType As Boolean) As Mono.Cecil.TypeReference
         Select Case m_Classification
             Case Classifications.Value
                 Return AsValueClassification.Type
             Case Classifications.Variable
                 Return AsVariableClassification.Type
             Case Classifications.MethodGroup
                 Return AsMethodGroupClassification.Type
             Case Classifications.MethodPointer
                 Return AsMethodPointerClassification.Type
             Case Classifications.PropertyAccess
                 Return AsPropertyAccess.Type
             Case Classifications.PropertyGroup
                 Return AsPropertyGroup.Type
             Case Classifications.Void
                 Return Compiler.TypeCache.System_Void
             Case Classifications.LateBoundAccess
                 Return AsLateBoundAccess.Type
             Case Else
                 If ThrowIfNoType Then
                     Throw New InternalException("No type was found")
                 Else
                     Return Nothing
                 End If
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="95" endline="99"><![CDATA[
 
     ReadOnly Property AsLateBoundAccess() As LateBoundAccessClassification
         Get
             Return DirectCast(Me, LateBoundAccessClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="100" endline="105"><![CDATA[
     End Property
 
     ReadOnly Property AsEventAccess() As EventAccessClassification
         Get
             Return DirectCast(Me, EventAccessClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="106" endline="111"><![CDATA[
     End Property
 
     ReadOnly Property AsMethodGroupClassification() As MethodGroupClassification
         Get
             Return DirectCast(Me, MethodGroupClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="112" endline="117"><![CDATA[
     End Property
 
     ReadOnly Property AsMethodPointerClassification() As MethodPointerClassification
         Get
             Return DirectCast(Me, MethodPointerClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="118" endline="123"><![CDATA[
     End Property
 
     ReadOnly Property AsNamespaceClassification() As NamespaceClassification
         Get
             Return DirectCast(Me, NamespaceClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="124" endline="129"><![CDATA[
     End Property
 
     ReadOnly Property AsPropertyAccess() As PropertyAccessClassification
         Get
             Return DirectCast(Me, PropertyAccessClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="130" endline="135"><![CDATA[
     End Property
 
     ReadOnly Property AsPropertyGroup() As PropertyGroupClassification
         Get
             Return DirectCast(Me, PropertyGroupClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="136" endline="141"><![CDATA[
     End Property
 
     ReadOnly Property AsTypeClassification() As TypeClassification
         Get
             Return DirectCast(Me, TypeClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="142" endline="147"><![CDATA[
     End Property
 
     ReadOnly Property AsValueClassification() As ValueClassification
         Get
             Return DirectCast(Me, ValueClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="148" endline="153"><![CDATA[
     End Property
 
     ReadOnly Property AsVariableClassification() As VariableClassification
         Get
             Return DirectCast(Me, VariableClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="154" endline="159"><![CDATA[
     End Property
 
     ReadOnly Property AsVoidClassification() As VoidClassification
         Get
             Return DirectCast(Me, VoidClassification)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="160" endline="165"><![CDATA[
     End Property
 
     ReadOnly Property IsLateBoundClassification() As Boolean
         Get
             Return m_Classification = Classifications.LateBoundAccess
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="166" endline="171"><![CDATA[
     End Property
 
     ReadOnly Property IsEventAccessClassification() As Boolean
         Get
             Return m_Classification = Classifications.EventAccess
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="172" endline="177"><![CDATA[
     End Property
 
     ReadOnly Property IsMethodGroupClassification() As Boolean
         Get
             Return m_Classification = Classifications.MethodGroup
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="178" endline="183"><![CDATA[
     End Property
 
     ReadOnly Property IsMethodPointerClassification() As Boolean
         Get
             Return m_Classification = Classifications.MethodPointer
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="184" endline="189"><![CDATA[
     End Property
 
     ReadOnly Property IsNamespaceClassification() As Boolean
         Get
             Return m_Classification = Classifications.Namespace
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="190" endline="195"><![CDATA[
     End Property
 
     ReadOnly Property IsPropertyAccessClassification() As Boolean
         Get
             Return m_Classification = Classifications.PropertyAccess
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="196" endline="201"><![CDATA[
     End Property
 
     ReadOnly Property IsPropertyGroupClassification() As Boolean
         Get
             Return m_Classification = Classifications.PropertyGroup
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="202" endline="207"><![CDATA[
     End Property
 
     ReadOnly Property IsTypeClassification() As Boolean
         Get
             Return m_Classification = Classifications.Type
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="208" endline="226"><![CDATA[
     End Property
 
     ReadOnly Property CanBeValueClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.Value, Classifications.Variable, _
                 Classifications.LateBoundAccess, Classifications.MethodGroup, _
                 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.PropertyGroup
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBeValueClassification
                 Case Classifications.Void, Classifications.Namespace, Classifications.EventAccess
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="227" endline="247"><![CDATA[
     End Property
 
     ReadOnly Property CanBePropertyAccessClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.PropertyGroup
                     Return True
                 Case Classifications.LateBoundAccess
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBePropertyAccessClassification
                 Case Classifications.Value, Classifications.Variable, Classifications.EventAccess, _
 Classifications.LateBoundAccess, Classifications.MethodGroup, _
 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.Void, Classifications.Namespace
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="248" endline="253"><![CDATA[
     End Property
 
     ReadOnly Property IsValueClassification() As Boolean
         Get
             Return m_Classification = Classifications.Value
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="254" endline="259"><![CDATA[
     End Property
 
     ReadOnly Property IsVariableClassification() As Boolean
         Get
             Return m_Classification = Classifications.Variable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="260" endline="265"><![CDATA[
     End Property
 
     ReadOnly Property IsVoidClassification() As Boolean
         Get
             Return m_Classification = Classifications.Void
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="266" endline="271"><![CDATA[
     End Property
 
     ReadOnly Property Classification() As Classifications
         Get
             Return m_Classification
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="272" endline="277"><![CDATA[
     End Property
 
     Protected Sub New(ByVal Classification As Classifications, ByVal Parent As ParsedObject)
         m_Parent = Parent 'MyBase.New(Parent)
         m_Classification = Classification
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="278" endline="281"><![CDATA[
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="39" endline="41"><![CDATA[
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="42" endline="47"><![CDATA[
     End Property
 
     Property Arguments() As ArgumentList
         Get
             Return m_Arguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="48" endline="50"><![CDATA[
         Set(ByVal value As ArgumentList)
             m_Arguments = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="51" endline="56"><![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="57" endline="62"><![CDATA[
     End Property
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             Return m_InstanceExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="63" endline="68"><![CDATA[
     End Property
 
     ReadOnly Property TypeArguments() As TypeArgumentList
         Get
             Return m_TypeArguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="69" endline="74"><![CDATA[
     End Property
 
     Property LateBoundType() As Mono.Cecil.TypeReference
         Get
             Return m_LateBoundType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="75" endline="77"><![CDATA[
         Set(ByVal value As Mono.Cecil.TypeReference)
             m_LateBoundType = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="78" endline="83"><![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Object
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="84" endline="98"><![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="InstanceExpression">May be Nothing</param>
     ''' <param name="TypeArguments">May be Nothing</param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Name As String)
         MyBase.New(Classifications.LateBoundAccess, Parent)
         m_InstanceExpression = InstanceExpression
         m_Name = Name
         m_TypeArguments = TypeArguments
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="71" endline="73"><![CDATA[
     Sub RevertResolveGroup()
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)(m_OriginalGroup)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="74" endline="78"><![CDATA[
 #End If
 
     <Diagnostics.Conditional("DEBUGMETHODRESOLUTION")> Sub LogResolutionMessage(ByVal msg As String)
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, msg)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="79" endline="83"><![CDATA[
 
     ReadOnly Property FinalArguments() As ArgumentList
         Get
             Return m_FinalArguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="84" endline="89"><![CDATA[
     End Property
 
     ReadOnly Property Parameters() As Expression()
         Get
             Return m_Parameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="90" endline="95"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="96" endline="106"><![CDATA[
     End Property
     ''' <summary>
     ''' Has ResolveGroup been called?
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Resolved() As Boolean
         Get
             Return m_Resolved
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="107" endline="123"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         If Info.IsRHS Then
             result = GenerateCodeAsValue(Info) AndAlso result
         ElseIf Info.IsLHS Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="124" endline="133"><![CDATA[
 
     Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, New ArgumentList(Parent, m_Parameters), ResolvedMethod)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="134" endline="148"><![CDATA[
 
     ''' <summary>
     ''' Reclassifies the method group to a value, at the same time the method
     ''' group might be resolved using an empty argument list.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function ReclassifyToValue() As ValueClassification
         Dim result As ValueClassification
         If m_Resolved = False Then
             Me.ResolveGroup(New ArgumentList(Me.Parent))
         End If
         result = New ValueClassification(Me)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="149" endline="159"><![CDATA[
 
     ''' <summary>
     ''' The instance expression of the method group.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Property InstanceExpression() As Expression
         Get
             Return m_InstanceExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="160" endline="162"><![CDATA[
         Set(ByVal value As Expression)
             m_InstanceExpression = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="163" endline="191"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The type of the method group, is the return type of the method.
     ''' If this method is a sub, the return type is System.Void.
     ''' If this is a constructor, the return type is nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             Dim m As Mono.Cecil.MethodReference = ResolvedMethodInfo
             If m Is Nothing Then
                 Dim c As Mono.Cecil.MethodReference = ResolvedConstructor
                 If c Is Nothing Then
                     Throw New InternalException(Me)
                 Else
                     Return Nothing
                 End If
             Else
                 If m.ReturnType Is Nothing Then
                     Return Compiler.TypeCache.System_Void
                 Else
                     Return m.ReturnType
                 End If
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="192" endline="207"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a methodinfo.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethodInfo() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="208" endline="224"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a constructorinfo.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedConstructor() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="225" endline="238"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns the resolved method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethod() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If m_Group.Count = 0 Then Return Nothing
             Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="239" endline="244"><![CDATA[
     End Property
 
     ReadOnly Property Resolver() As MethodResolver
         Get
             Return m_Resolver
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="245" endline="256"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns true if the method group has successfully been resolved.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property SuccessfullyResolved() As Boolean
         Get
             Return m_Resolved AndAlso (m_Group.Count = 1 OrElse m_Resolver.IsLateBound)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="257" endline="268"><![CDATA[
     End Property
 
     Private Sub SetMethods(ByVal lst As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="269" endline="279"><![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="280" endline="290"><![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MethodReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="291" endline="306"><![CDATA[
 
     ''' <summary>
     ''' The name of the method. (Any method actually, since they should all have the same name).
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property MethodName() As String
         Get
             For i As Integer = 0 To m_Group.Count - 1
                 If m_Group(i) IsNot Nothing Then
                     Return m_Group(i).Name
                 End If
             Next
             Throw New InternalException(Me)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="307" endline="318"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The group of methods.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Property [Group]() As Generic.List(Of Mono.Cecil.MemberReference)
         Get
             Return m_Group
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="319" endline="321"><![CDATA[
         Set(ByVal value As Generic.List(Of Mono.Cecil.MemberReference))
             m_Group = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="322" endline="365"><![CDATA[
     End Property
 
     Shared Function ResolveInterfaceGroup(ByVal grp As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal codedMember As IMember) As Mono.Cecil.MemberReference
         Helper.Assert(codedMember IsNot Nothing)
 
         Dim methodtypes() As Mono.Cecil.TypeReference
         Dim grptypes() As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.MemberReference = Nothing
 
         Select Case CecilHelper.GetMemberType(codedMember.MemberDescriptor)
             Case MemberTypes.Method
                 Dim method As IMethod = TryCast(codedMember, IMethod)
                 methodtypes = method.Signature.Parameters.ToTypeArray
             Case MemberTypes.Property
                 Dim prop As PropertyDeclaration = TryCast(codedMember, PropertyDeclaration)
                 methodtypes = prop.Signature.Parameters.ToTypeArray
             Case MemberTypes.Event
                 methodtypes = New Mono.Cecil.TypeReference() {}
             Case Else
                 methodtypes = Nothing
                 codedMember.Compiler.Report.ShowMessage(Messages.VBNC99997, codedMember.Location)
         End Select
 
         For Each member As Mono.Cecil.MemberReference In grp
             Select Case CecilHelper.GetMemberType(member)
                 Case MemberTypes.Method
                     grptypes = Helper.GetParameterTypes(codedMember.Parent, member)
                 Case MemberTypes.Property
                     grptypes = Helper.GetParameterTypes(Helper.GetParameters(codedMember.Compiler, DirectCast(member, Mono.Cecil.PropertyReference)))
                 Case MemberTypes.Event
                     grptypes = New Mono.Cecil.TypeReference() {}
                 Case Else
                     Throw New InternalException(codedMember)
             End Select
             If Helper.CompareTypes(methodtypes, grptypes) Then
                 Helper.Assert(result Is Nothing)
                 result = member
 #If Not DEBUG Then
                 Exit For
 #End If
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="366" endline="370"><![CDATA[
 
     ReadOnly Property IsLateBound() As Boolean
         Get
             Return m_Resolver IsNot Nothing AndAlso m_Resolved AndAlso m_Resolver.IsLateBound
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="371" endline="428"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Resolve this group with the specified parameters.
     ''' </summary>
     ''' <param name="SourceParameters"></param>
     ''' <remarks></remarks>
     Function ResolveGroup(ByVal SourceParameters As ArgumentList, Optional ByVal ShowErrors As Boolean = False) As Boolean
         Dim result As Boolean = True
         Dim FinalSourceArguments As ArgumentList = Nothing
 
         If SourceParameters Is Nothing Then Throw New InternalException("SourceParameters is nothing.")
         If Resolved Then
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Method group is beeing resolved more than once.")
         End If
         If m_Group.Count <= 0 Then Throw New InternalException("Nothing to resolve...")
 
         Dim resolvedGroup As New Generic.List(Of Mono.Cecil.MemberReference)
 
         If m_Resolver Is Nothing Then m_Resolver = New MethodResolver(Parent)
         m_Resolver.ShowErrors = ShowErrors
         m_Resolver.Init(m_Group, SourceParameters, m_TypeArguments)
         result = m_Resolver.Resolve AndAlso result
 
         If result Then
             If m_Resolver.IsLateBound = False Then
                 FinalSourceArguments = New ArgumentList(Me.Parent, m_Resolver.ResolvedCandidate.ExactArguments)
                 resolvedGroup.Add(m_Resolver.ResolvedMember)
             End If
         End If
 
         'result = Helper.ResolveGroup(Me.Parent, m_Group, resolvedGroup, SourceParameters, TypeArguments, FinalSourceArguments, ShowErrors) AndAlso result
 
         If result Then
             m_Group = resolvedGroup
             m_Resolved = True
             If IsLateBound = False AndAlso Helper.IsShared(ResolvedMethod) Then
                 'Helper.StopIfDebugging(m_InstanceExpression IsNot Nothing AndAlso TypeOf m_InstanceExpression Is MeExpression = False)
                 m_InstanceExpression = Nothing
             End If
 #If EXTENDEDDEBUG Then
         Else
             'Don't stop here since method resolution might fail correctly.
             Compiler.Report.WriteLine("")
             Compiler.Report.WriteLine(".......Method resolution failed, showing log.......")
             Dim tmp As Boolean = Helper.LOGMETHODRESOLUTION
             Helper.LOGMETHODRESOLUTION = True
             resolvedGroup.Clear()
             result = Helper.ResolveGroup(Me.Parent, m_Group, resolvedGroup, SourceParameters, TypeArguments, FinalSourceArguments) AndAlso result
             Helper.LOGMETHODRESOLUTION = tmp
             Compiler.Report.WriteLine("...................................................")
 #End If
         End If
 
         m_FinalArguments = FinalSourceArguments
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="429" endline="432"><![CDATA[
 
     Function IsAccessible(ByVal Caller As Mono.Cecil.TypeReference, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Return Helper.IsAccessible(Compiler, Caller, Method)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="433" endline="442"><![CDATA[
 
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Method As MethodDeclaration)
         MyBase.New(Classifications.MethodGroup, Parent)
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         m_Group.Add(Method.CecilBuilder)
         m_Resolved = True
         m_InstanceExpression = InstanceExpression
         m_TypeArguments = TypeArguments
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="443" endline="452"><![CDATA[
 
     Private Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression)
         MyBase.new(Classifications.MethodGroup, Parent)
         m_InstanceExpression = InstanceExpression
         m_CallingType = Parent.FindFirstParent(Of TypeDeclaration)()
         m_Parameters = Parameters
         m_TypeArguments = TypeArguments
         'Helper.Assert(m_CallingType IsNot Nothing)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="453" endline="459"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal ParamArray Methods As Mono.Cecil.MemberReference())
         Me.New(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(New Generic.List(Of Mono.Cecil.MemberReference)(Methods))
         Helper.Assert(Methods.Length > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="460" endline="466"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="467" endline="473"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="474" endline="478"><![CDATA[
 
     Shadows ReadOnly Property Parent() As ParsedObject
         Get
             Return DirectCast(MyBase.Parent, ParsedObject)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="479" endline="500"><![CDATA[
     End Property
 
     Function VerifyConstraints() As Boolean
         Dim result As Boolean = True
 
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim mit As GenericInstanceMethod
         Dim md As MethodDefinition
 
         mit = TryCast(ResolvedMethod, GenericInstanceMethod)
         md = CecilHelper.FindDefinition(mit)
 
         If mit Is Nothing OrElse md Is Nothing Then Return True
 
         parameters = md.GenericParameters
         arguments = mit.GenericArguments
 
         result = Helper.VerifyConstraints(Me.Parent, parameters, arguments)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="44" endline="46"><![CDATA[
         Get
             Return m_resolved
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="47" endline="78"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the method pointer onto the evalation stack.
     ''' Creates a new delegate of the specified type.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ResolvedMethod IsNot Nothing)
         Helper.Assert(m_DelegateType IsNot Nothing)
 
         If m_MethodGroup.InstanceExpression IsNot Nothing Then
             result = m_MethodGroup.InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_MethodGroup.InstanceExpression.ExpressionType)) AndAlso result
             Emitter.EmitDup(Info)
         Else
             Emitter.EmitLoadNull(Info.Clone(Parent, True, False, Compiler.TypeCache.System_Object))
         End If
 
         Emitter.EmitLoadVftn(Info, m_ResolvedMethod)
 
         Dim ctor As Mono.Cecil.MethodReference
         Dim dT As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(m_DelegateType)
         ctor = CecilHelper.FindConstructor(dT.Methods, False, New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Object, Compiler.TypeCache.System_IntPtr})
         ctor = CecilHelper.GetCorrectMember(ctor, m_DelegateType)
         Emitter.EmitNew(Info, ctor)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="79" endline="117"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Resolve(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(DelegateType IsNot Nothing)
 
         If Helper.CompareType(DelegateType, Compiler.TypeCache.DelegateUnresolvedType) Then
             m_DelegateType = DelegateType
             Return True
         End If
 
         If Helper.IsDelegate(Compiler, DelegateType) = False Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30581, Me.Parent.Location, DelegateType.FullName) AndAlso result
         End If
 
         If result = False Then Return result
 
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetDelegateArguments(Compiler, DelegateType)
         Dim paramtypes() As Mono.Cecil.TypeReference = Helper.GetParameterTypes(params)
 
         m_ResolvedMethod = CType(Helper.ResolveGroupExact(Me.Parent, m_MethodGroup.Group, paramtypes), Mono.Cecil.MethodReference)
         m_DelegateType = DelegateType
 
         If m_ResolvedMethod Is Nothing Then
             For i As Integer = 0 To m_MethodGroup.Group.Count - 1
                 Compiler.Report.ShowMessage(Messages.VBNC30408, Me.Parent.Location, Helper.ToString(Me.Parent, m_MethodGroup.Group(i)), Helper.ToString(Me.Parent, DelegateType))
             Next
             result = False
         End If
 
         m_Resolved = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="118" endline="122"><![CDATA[
 
     ReadOnly Property DelegateType() As Mono.Cecil.TypeReference
         Get
             Return m_DelegateType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="123" endline="128"><![CDATA[
     End Property
 
     ReadOnly Property MethodGroup() As MethodGroupClassification
         Get
             Return m_MethodGroup
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="129" endline="134"><![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_IntPtr
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="135" endline="140"><![CDATA[
     End Property
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             Return m_MethodGroup.InstanceExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="141" endline="146"><![CDATA[
     End Property
 
     ReadOnly Property Method() As Mono.Cecil.MethodReference
         Get
             Return DirectCast(m_ResolvedMethod, Mono.Cecil.MethodReference)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="147" endline="153"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As AddressOfExpression, ByVal MethodGroup As MethodGroupClassification)
         MyBase.new(Classifications.MethodPointer, Parent)
         Helper.Assert(MethodGroup IsNot Nothing)
         m_MethodGroup = MethodGroup
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\NamespaceClassification.vb" startline="31" endline="33"><![CDATA[
         Get
             Return m_Namespace
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\NamespaceClassification.vb" startline="34" endline="39"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As [Namespace])
         MyBase.New(Classifications.Namespace, Parent)
         m_Namespace = [Namespace]
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="42" endline="44"><![CDATA[
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="45" endline="53"><![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ArgumentList
         Get
             If m_Parameters Is Nothing AndAlso m_Classification IsNot Nothing Then
                 m_Parameters = m_Classification.Parameters
             End If
             Return m_Parameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="54" endline="59"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedProperty() As Mono.Cecil.PropertyReference
         Get
             Return m_Property
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="60" endline="135"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim method As Mono.Cecil.MethodReference
 
         If m_LateBoundExpression IsNot Nothing Then Return m_LateBoundExpression.GenerateCode(Info)
 
         Dim rside As EmitInfo
         rside = Info.Clone(Parent, True)
 
         If m_Classification IsNot Nothing Then
             m_InstanceExpression = m_Classification.InstanceExpression
             m_Property = m_Classification.ResolvedProperty
             m_Parameters = m_Classification.Parameters
         End If
 
         Helper.Assert(m_Property IsNot Nothing)
 
         If Info.IsLHS Then
             method = CecilHelper.GetCorrectMember(CecilHelper.FindDefinition(m_Property).SetMethod, m_Property.DeclaringType)
         Else
             method = CecilHelper.GetCorrectMember(CecilHelper.FindDefinition(m_Property).GetMethod, m_Property.DeclaringType)
         End If
 
         Helper.Assert(method IsNot Nothing)
 
         'If m_InstanceExpression IsNot Nothing Then
         '    rside = rside.Clone(m_Property.DeclaringType)
         '    result = m_InstanceExpression.GenerateCode(rside) AndAlso result
         'End If
 
         Dim exp As Expression()
         Dim args As ArgumentList
         Dim expCount As Integer
 
         If m_Parameters IsNot Nothing Then
             expCount = m_Parameters.Count
         End If
         If Info.IsLHS Then
             expCount += 1
         End If
         ReDim exp(expCount - 1)
 
         If m_Parameters IsNot Nothing Then
             'Dim params() As ParameterInfo = Helper.GetParameters(Compiler, method)
             'If Info.IsLHS Then
             '    'Remove the last parameter, it is a setter.
             '    Helper.Assert(params.GetUpperBound(0) >= 0)
             '    Dim tmpParameters As ParameterInfo()
             '    ReDim tmpParameters(params.GetUpperBound(0) - 1)
             '    Array.Copy(params, tmpParameters, tmpParameters.Length)
             '    params = tmpParameters
             'End If
             'result = m_Parameters.GenerateCode(rside, params) AndAlso result
 
             For i As Integer = 0 To m_Parameters.Count - 1
                 exp(i) = m_Parameters(i).Expression
             Next
         End If
 
         If Info.IsLHS Then
             ' rside = rside.Clone(m_Property.PropertyType)
             'result = Info.RHSExpression.GenerateCode(rside) AndAlso result
 
             exp(expCount - 1) = Info.RHSExpression
         End If
 
         'Emitter.EmitCallOrCallVirt(Info, method)
 
         args = New ArgumentList(Me.Parent, exp)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, args, method)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="136" endline="139"><![CDATA[
 
     <Obsolete()> Overloads Function ReclassifyToValue() As ValueClassification
         Return New ValueClassification(Me)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="140" endline="147"><![CDATA[
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             If m_InstanceExpression Is Nothing AndAlso m_Classification IsNot Nothing Then
                 m_InstanceExpression = m_Classification.InstanceExpression
             End If
             Return m_InstanceExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="148" endline="153"><![CDATA[
     End Property
 
     Property [Property]() As Mono.Cecil.PropertyReference
         Get
             Return m_Property
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="154" endline="156"><![CDATA[
         Set(ByVal value As Mono.Cecil.PropertyReference)
             m_Property = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="157" endline="168"><![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If m_Property Is Nothing Then
                 Helper.Assert(m_Classification IsNot Nothing)
                 Helper.Assert(m_Classification.IsResolved)
                 m_Property = m_Classification.ResolvedProperty
             End If
             Helper.Assert(m_Property IsNot Nothing)
             Return m_Property.PropertyType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="169" endline="176"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Property] As Mono.Cecil.PropertyReference, ByVal InstanceExpression As Expression, ByVal Parameters As ArgumentList)
         MyBase.New(Classifications.PropertyAccess, Parent)
         m_Property = [Property]
         m_InstanceExpression = InstanceExpression
         m_Parameters = Parameters
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="177" endline="182"><![CDATA[
 
     Sub New(ByVal Classification As PropertyGroupClassification)
         MyBase.New(Classifications.PropertyAccess, Classification.Parent)
         m_Classification = Classification
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="183" endline="187"><![CDATA[
 
     Sub New(ByVal Expression As LateBoundAccessToPropertyAccessExpression)
         MyBase.New(Classifications.PropertyAccess, Expression.Parent)
         m_LateBoundExpression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="43" endline="45"><![CDATA[
         Get
             Return m_FinalSourceArguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="46" endline="51"><![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ArgumentList
         Get
             Return m_Parameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="52" endline="57"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="58" endline="104"><![CDATA[
     End Property
 
     Function ResolveGroup(ByVal SourceParameters As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim destinationParameterTypes()() As Mono.Cecil.TypeReference
         Dim destinationParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim sourceParameterTypes() As Mono.Cecil.TypeReference
 
         ReDim destinationParameterTypes(m_Members.Count - 1)
         ReDim destinationParameters(m_Members.Count - 1)
         For i As Integer = 0 To m_Members.Count - 1
             destinationParameters(i) = m_Members(i).Parameters
             destinationParameterTypes(i) = Helper.GetTypes(destinationParameters(i))
         Next
 
         sourceParameterTypes = SourceParameters.ToTypes
 
         Dim resolvedGroup As New Generic.List(Of Mono.Cecil.MemberReference)
         Dim inputGroup As New Generic.List(Of Mono.Cecil.MemberReference)(m_Members.Count)
         For i As Integer = 0 To m_Members.Count - 1
             inputGroup.Add(DirectCast(m_Members(i), PropertyReference))
         Next
 
         If m_Resolver Is Nothing Then m_Resolver = New MethodResolver(Parent)
         m_Resolver.ShowErrors = False
         m_Resolver.Init(inputGroup, SourceParameters, Nothing)
         result = m_Resolver.Resolve AndAlso result
 
         If result Then
             If m_Resolver.IsLateBound = False Then
                 m_FinalSourceArguments = New ArgumentList(Me.Parent, m_Resolver.ResolvedCandidate.ExactArguments)
                 resolvedGroup.Add(m_Resolver.ResolvedMember)
             End If
         End If
 
         'result = Helper.ResolveGroup(Me.Parent, inputGroup, resolvedGroup, SourceParameters, Nothing, Nothing, False)
 
         If result Then
             m_ResolvedProperty = TryCast(resolvedGroup(0), Mono.Cecil.PropertyReference)
             result = m_ResolvedProperty IsNot Nothing AndAlso result
         End If
 
         m_Parameters = SourceParameters
         m_Resolved = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="105" endline="116"><![CDATA[
 
     ''' <summary>
     ''' If ResolveGroup has been called.
     ''' Does not say if the resolution was successful or not.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property IsResolved() As Boolean
         Get
             Return m_Resolved
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="117" endline="135"><![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If m_ResolvedProperty IsNot Nothing Then
                 Return m_ResolvedProperty.PropertyType
             ElseIf m_Members IsNot Nothing Then
                 If m_Members.Count = 1 Then
                     m_ResolvedProperty = m_Members(0)
                     Return m_Members(0).PropertyType
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                 End If
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
             Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="136" endline="141"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedProperty() As Mono.Cecil.PropertyReference
         Get
             Return m_ResolvedProperty
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="142" endline="155"><![CDATA[
     End Property
 
     Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim constant As Object = Nothing 'm_ResolvedProperty.GetConstantValue
         If constant IsNot Nothing Then
             Emitter.EmitLoadValue(Info, constant)
         Else
             Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, m_Parameters, CecilHelper.GetGetMethod(m_ResolvedProperty))
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="156" endline="159"><![CDATA[
 
     Overloads Function ReclassifyToValue() As ValueClassification
         Return New ValueClassification(Me)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="160" endline="164"><![CDATA[
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             Return m_InstanceExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="165" endline="170"><![CDATA[
     End Property
 
     Property [Group]() As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)
         Get
             Return m_Members
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="171" endline="174"><![CDATA[
         Set(ByVal value As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference))
             m_Members.Clear()
             m_Members.AddRange(value)
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="175" endline="179"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression)
         MyBase.New(Classifications.PropertyGroup, Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="180" endline="202"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         MyBase.New(Classifications.PropertyGroup, Parent)
         m_InstanceExpression = InstanceExpression
 
         m_Members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)(Members.Count)
         For i As Integer = 0 To Members.Count - 1
             Dim tmp As Mono.Cecil.PropertyReference = TryCast(Members(i), Mono.Cecil.PropertyReference)
             If tmp IsNot Nothing Then
                 m_Members.Add(tmp)
             Else
                 Throw New InternalException(Me)
             End If
         Next
 
 #If DEBUG Then
         For i As Integer = 0 To Members.Count - 1
             For j As Integer = i + 1 To Members.Count - 1
                 Helper.Assert(Members(i) IsNot Members(j))
             Next
         Next
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="203" endline="217"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference))
         MyBase.New(Classifications.PropertyGroup, Parent)
         m_InstanceExpression = InstanceExpression
 
         m_Members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)()
         m_Members.AddRange(Members)
 #If DEBUG Then
         For i As Integer = 0 To Members.Count - 1
             For j As Integer = i + 1 To Members.Count - 1
                 Helper.Assert(Members(i) IsNot Members(j))
             Next
         Next
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="34" endline="39"><![CDATA[
         Get
             If m_Group Is Nothing Then
                 If Not CanBeExpression() Then Return Nothing
             End If
             Return m_Group
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="40" endline="49"><![CDATA[
     End Property
 
     ReadOnly Property Expression() As Expression
         Get
             If m_Group Is Nothing Then
                 If Not CanBeExpression() Then Return Nothing
                 If m_Group Is Nothing Then Return Nothing
             End If
             Return m_Group.DefaultInstanceAlias
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="50" endline="72"><![CDATA[
     End Property
 
     Function CreateAliasExpression(ByVal SharedExpression As Expression, ByRef result As Expression) As Boolean
         Dim sne As SimpleNameExpression = TryCast(SharedExpression, SimpleNameExpression)
         Dim mae As MemberAccessExpression
         Dim maeIE As MemberAccessExpression
 
         If TypeOf SharedExpression.Parent Is Is_IsNotExpression Then
             Dim fieldLoad As New LoadFieldExpression(SharedExpression, DirectCast(m_Type.Annotations(Compiler), TypeDeclaration).MyGroupField.FieldBuilder, m_Group.DefaultInstanceAlias)
             result = fieldLoad
         Else
             If sne IsNot Nothing Then
                 maeIE = New MemberAccessExpression(SharedExpression.Parent)
                 maeIE.Init(Expression, New IdentifierOrKeyword(SharedExpression.Parent, Token.CreateIdentifierToken(sne.Location, sne.Identifier.Identifier)))
             Else
                 mae = TryCast(SharedExpression, MemberAccessExpression)
                 maeIE = New MemberAccessExpression(SharedExpression.Parent)
                 maeIE.Init(Expression, mae.SecondExpression)
             End If
             result = maeIE
         End If
         Return result.ResolveExpression(ResolveInfo.Default(SharedExpression.Compiler))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="73" endline="95"><![CDATA[
 
     ReadOnly Property CanBeExpression() As Boolean
         Get
             Dim result As Boolean = False
 
             If m_Group IsNot Nothing Then Return m_Group.DefaultInstanceAlias IsNot Nothing
 
             If Compiler.Assembly.GroupedClasses Is Nothing Then Return False
 
             If m_Type Is Nothing Then Return False
 
             For Each data As MyGroupData In Compiler.Assembly.GroupedClasses
                 If data.DefaultInstanceAlias Is Nothing Then Continue For
                 If data.TypeToCollect Is Nothing Then Continue For
                 If Helper.IsSubclassOf(data.TypeToCollect, m_Type) = False Then Continue For
 
                 m_Group = data
 
                 Return True
             Next
 
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="96" endline="101"><![CDATA[
     End Property
 
     ReadOnly Property IsTypeParameter() As Boolean
         Get
             Return m_TypeParameter IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="102" endline="107"><![CDATA[
     End Property
 
     Property Type() As Mono.Cecil.TypeDefinition 'Descriptor
         Get
             Return m_Type
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="108" endline="110"><![CDATA[
         Set(ByVal value As Mono.Cecil.TypeDefinition) 'Descriptor)
             m_Type = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="111" endline="116"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal Type As TypeDeclaration)
         MyBase.new(Classifications.Type, Parent)
         m_Type = Type.CecilType
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="117" endline="121"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal TypeParameter As TypeParameter)
         MyBase.New(Classifications.Type, Parent)
         m_TypeParameter = TypeParameter
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="122" endline="125"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Classifications.Type, Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="126" endline="140"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Type As Object)
         Me.new(Parent)
         If TypeOf Type Is Mono.Cecil.TypeDefinition Then
             m_Type = DirectCast(Type, Mono.Cecil.TypeDefinition)
             'ElseIf TypeOf Type Is Type Then
             '    m_Type = DirectCast(Type, Type) ' New TypeDescriptor(DirectCast(Type, Type))
         ElseIf TypeOf Type Is TypeDeclaration Then
             m_Type = DirectCast(Type, TypeDeclaration).CecilType
         ElseIf TypeOf Type Is TypeParameter Then
             m_TypeParameter = DirectCast(Type, TypeParameter)
         Else
             Throw New InternalException(Me)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="141" endline="145"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Type As Mono.Cecil.TypeDefinition)
         MyBase.New(Classifications.Type, Parent)
         m_Type = Type
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="39" endline="53"><![CDATA[
         Get
             Dim result As Boolean
             Static recursive As Boolean
             Helper.Assert(recursive = False)
             recursive = True
             If ReclassifiedClassification IsNot Nothing Then
                 result = ReclassifiedClassification.IsConstant
             ElseIf m_Value IsNot Nothing AndAlso m_Value.IsConstant Then
                 result = True
             Else
                 result = False
             End If
             recursive = False
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="54" endline="65"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If ReclassifiedClassification IsNot Nothing Then
                 Return ReclassifiedClassification.ConstantValue
             ElseIf m_Value IsNot Nothing Then
                 Return m_Value.ConstantValue
             Else
                 Return MyBase.ConstantValue
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="66" endline="101"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         If m_Value IsNot Nothing Then
             result = m_Value.GenerateCode(Info) AndAlso result
         ElseIf m_ConstantValue IsNot Nothing Then
             Emitter.EmitLoadValueConstantOrValueAddress(Info, m_ConstantValue)
         ElseIf m_Classification IsNot Nothing Then
             Select Case m_Classification.Classification
                 Case Classifications.Value
                     Throw New InternalException(Me)
                 Case Classifications.Variable
                     result = m_Classification.AsVariableClassification.GenerateCodeAsValue(Info) AndAlso result
                 Case Classifications.MethodPointer
                     If Info.DesiredType IsNot Nothing Then
                         result = m_Classification.AsMethodPointerClassification.GenerateCode(Info) AndAlso result
                     Else
                         Throw New InternalException(Me)
                     End If
                 Case Classifications.MethodGroup
                     result = m_Classification.AsMethodGroupClassification.GenerateCodeAsValue(Info) AndAlso result
                 Case Classifications.PropertyGroup
                     result = m_Classification.AsPropertyGroup.GenerateCodeAsValue(Info) AndAlso result
                 Case Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End Select
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="102" endline="106"><![CDATA[
 
     ReadOnly Property ReclassifiedClassification() As ExpressionClassification
         Get
             Return m_Classification
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="107" endline="112"><![CDATA[
     End Property
 
     ReadOnly Property Value_IsLiteralNothing() As Boolean
         Get
             Return m_IsLiteralNothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="113" endline="118"><![CDATA[
     End Property
 
     ReadOnly Property Value_ConstantValue() As Object
         Get
             Return m_ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="119" endline="124"><![CDATA[
     End Property
 
     ReadOnly Property Value_Constant() As ConstantDeclaration
         Get
             Return m_Constant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="125" endline="130"><![CDATA[
     End Property
 
     ReadOnly Property Value_EnumVariable() As EnumMemberDeclaration
         Get
             Return m_EnumVariable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="131" endline="136"><![CDATA[
     End Property
 
     ReadOnly Property Value_Field() As Mono.Cecil.FieldReference
         Get
             Return m_Field
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="137" endline="143"><![CDATA[
     End Property
 
     Property Type() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_Type IsNot Nothing)
             Return m_Type
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="144" endline="146"><![CDATA[
         Set(ByVal value As Mono.Cecil.TypeReference)
             m_Type = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="147" endline="151"><![CDATA[
     End Property
 
     Private Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Classifications.Value, Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="152" endline="159"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal EnumVariable As EnumMemberDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(EnumVariable IsNot Nothing)
         m_EnumVariable = EnumVariable
         m_Type = m_EnumVariable.FindFirstParent(Of EnumDeclaration).EnumConstantType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="160" endline="166"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Variable As VariableDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Variable IsNot Nothing)
         m_Classification = New VariableClassification(Me.Parent, Variable)
         m_Type = DirectCast(m_Classification, VariableClassification).Type
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="167" endline="174"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Variable As Mono.Cecil.FieldReference, ByVal InstanceExpression As Expression)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Variable IsNot Nothing)
         m_Classification = New VariableClassification(Me.Parent, Variable, InstanceExpression)
         m_Type = DirectCast(m_Classification, VariableClassification).Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="175" endline="182"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Constant As ConstantDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Constant IsNot Nothing)
         m_Constant = Constant
         m_Type = Constant.FieldType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="183" endline="189"><![CDATA[
 
     Sub New(ByVal ParentAndValue As Expression)
         Me.New(DirectCast(ParentAndValue, ParsedObject))
         m_Type = ParentAndValue.ExpressionType
         m_Value = ParentAndValue
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="190" endline="196"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Value As Expression)
         Me.New(DirectCast(Parent, ParsedObject))
         m_Type = Value.ExpressionType
         m_Value = Value
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="197" endline="202"><![CDATA[
     Sub New(ByVal ParentAndValue As Expression, ByVal ExpressionType As Mono.Cecil.TypeReference)
         Me.New(DirectCast(ParentAndValue, ParsedObject))
         m_Type = ExpressionType
         m_Value = ParentAndValue
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="203" endline="208"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Type As Mono.Cecil.TypeReference, ByVal Value As Object)
         Me.New(Parent)
         m_Type = Type
         m_ConstantValue = Value
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="209" endline="215"><![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="216" endline="222"><![CDATA[
 
     Sub New(ByVal Classification As PropertyGroupClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="223" endline="229"><![CDATA[
 
     Sub New(ByVal Classification As MethodGroupClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="230" endline="236"><![CDATA[
 
     Sub New(ByVal Classification As MethodPointerClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="237" endline="243"><![CDATA[
 
     Sub New(ByVal Classification As LateBoundAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="244" endline="250"><![CDATA[
 
     Sub New(ByVal Classification As PropertyAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="45" endline="47"><![CDATA[
         Get
             Return m_Method
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="48" endline="53"><![CDATA[
     End Property
 
     ReadOnly Property Expression() As Expression
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="54" endline="59"><![CDATA[
     End Property
 
     ReadOnly Property ArrayVariable() As Expression
         Get
             Return m_ArrayVariable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="60" endline="65"><![CDATA[
     End Property
 
     ReadOnly Property Arguments() As ArgumentList
         Get
             Return m_Arguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="66" endline="118"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             If Me.FieldInfo IsNot Nothing Then
                 If Me.FieldDefinition.IsLiteral Then
                     If Me.FieldDefinition.HasConstant = False OrElse Me.FieldDefinition.Constant Is Nothing Then
                         Dim field As IFieldMember = TryCast(Me.FieldInfo.Annotations(Compiler), IFieldMember)
                         Dim value As Object = Nothing
                         If field Is Nothing Then
                             'A field from an external assembly
                             Return Me.FieldDefinition.Constant
                         End If
                         If field.ResolveAndGetConstantValue(value) Then
                             Return value
                         Else
                             Helper.Stop()
                             Return Nothing
                         End If
                         Helper.Stop() 'Constant value hasn't been set yet
                         Return Nothing
                     Else
                         Return Me.FieldDefinition.Constant
                     End If
                 ElseIf Me.FieldDefinition.IsInitOnly Then
                     Dim dec As Decimal, dt As Date
                     Dim constant As ConstantDeclaration
                     Dim attrib As Object
 
                     attrib = FieldDefinition.Annotations(Compiler)
                     If attrib IsNot Nothing Then
                         constant = TryCast(attrib, ConstantDeclaration)
                         Return constant.ConstantValue
                     End If
 
                     If ConstantDeclaration.GetDecimalConstant(Compiler, FieldDefinition, dec) Then
                         Return dec
                     ElseIf ConstantDeclaration.GetDateConstant(Compiler, FieldDefinition, dt) Then
                         Return dt
                     Else
                         Helper.Stop() 'This shouldn't really happen (IsConstant should return false)
                         Return Nothing
                     End If
                 Else
                     Helper.Stop() 'This shouldn't really happen (IsConstant should return false)
                     Return Nothing
                 End If
             Else
                 Helper.Stop() 'This shouldn't really happen (IsConstant should return false)
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="119" endline="146"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If Me.FieldInfo IsNot Nothing Then
                 If FieldDefinition.IsLiteral Then
                     Return True
                 ElseIf FieldDefinition.IsInitOnly Then
                     Dim dec As Decimal, dt As Date
                     Dim attrib As Object
 
                     attrib = FieldDefinition.Annotations(Compiler)
                     If attrib IsNot Nothing Then Return TypeOf attrib Is ConstantDeclaration
 
                     If ConstantDeclaration.GetDecimalConstant(Compiler, FieldDefinition, dec) Then
                         Return True
                     ElseIf ConstantDeclaration.GetDateConstant(Compiler, FieldDefinition, dt) Then
                         Return True
                     Else
                         Return False
                     End If
                 Else
                     Return False
                 End If
             Else
                 Return False
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="147" endline="152"><![CDATA[
     End Property
 
     ReadOnly Property ParameterInfo() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterInfo
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="153" endline="162"><![CDATA[
     End Property
 
     ReadOnly Property LocalBuilder() As Mono.Cecil.Cil.VariableDefinition
         Get
             If m_LocalVariable IsNot Nothing Then
                 Return m_LocalVariable.LocalBuilder
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="163" endline="174"><![CDATA[
     End Property
 
     ReadOnly Property FieldDefinition() As Mono.Cecil.FieldDefinition
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return CecilHelper.FindDefinition(m_FieldInfo)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="175" endline="186"><![CDATA[
     End Property
 
     ReadOnly Property FieldInfo() As Mono.Cecil.FieldReference
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return m_FieldInfo
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="187" endline="242"><![CDATA[
     End Property
 
 
     ''' <summary>
     ''' Loads the value of the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info) AndAlso result
         End If
 
         If FieldInfo IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, FieldInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf LocalBuilder IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, LocalBuilder)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf ParameterInfo IsNot Nothing Then
             Helper.Assert(m_InstanceExpression Is Nothing)
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, ParameterInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf m_ArrayVariable IsNot Nothing Then
             result = Helper.EmitLoadArrayElement(Info, m_ArrayVariable, m_Arguments) AndAlso result
         ElseIf m_Expression IsNot Nothing Then
             result = m_Expression.GenerateCode(Info) AndAlso result
         Else
             Throw New InternalException(Me)
         End If
 
         If CecilHelper.IsByRef(Info.DesiredType) Then
             Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(Info.DesiredType)
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = Emitter.DeclareLocal(Info, elementType)
 
             Emitter.EmitStoreVariable(Info, local)
             Emitter.EmitLoadVariableLocation(Info, local)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="243" endline="383"><![CDATA[
 
     ''' <summary>
     ''' Stores at the address of the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             Return m_Expression.GenerateCode(Info)
         End If
 
         Helper.Assert(Info.IsRHS AndAlso Info.RHSExpression Is Nothing OrElse Info.IsLHS AndAlso Info.RHSExpression IsNot Nothing)
 
         If m_InstanceExpression IsNot Nothing Then
             Dim exp As Mono.Cecil.TypeReference = m_InstanceExpression.ExpressionType
             If CecilHelper.IsValueType(exp) AndAlso CecilHelper.IsByRef(exp) = False Then
                 exp = Compiler.TypeManager.MakeByRefType(Me.Parent, exp)
             End If
             result = m_InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, exp)) AndAlso result
         End If
 
         If FieldInfo IsNot Nothing Then
             If Info.IsRHS Then
                 If CecilHelper.IsByRef(Info.DesiredType) Then
                     Emitter.EmitLoadVariableLocation(Info, FieldInfo)
                 Else
                     Emitter.EmitLoadVariable(Info, FieldInfo)
                 End If
             Else
                 Dim rInfo As EmitInfo = Info.Clone(Parent, True, False, FieldInfo.FieldType)
 
                 Helper.Assert(Info.RHSExpression IsNot Nothing)
                 Helper.Assert(Info.RHSExpression.Classification.IsValueClassification)
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
 
                 Emitter.EmitConversion(Info.RHSExpression.ExpressionType, FieldInfo.FieldType, Info.Clone(Parent, Info.RHSExpression.ExpressionType))
                 Emitter.EmitStoreField(Info, FieldInfo)
             End If
         ElseIf LocalBuilder IsNot Nothing Then
             result = VariableExpression.Emit(Info, LocalBuilder) AndAlso result
         ElseIf ParameterInfo IsNot Nothing Then
             Dim isByRef As Boolean
             Dim isByRefStructure As Boolean
             Dim paramType As Mono.Cecil.TypeReference
             Dim paramElementType As Mono.Cecil.TypeReference = Nothing
 
             paramType = ParameterInfo.ParameterType
             isByRef = CecilHelper.IsByRef(paramType)
             If isByRef Then
                 paramElementType = CecilHelper.GetElementType(paramType)
                 isByRefStructure = CecilHelper.IsValueType(paramElementType)
             End If
 
             Helper.Assert(m_InstanceExpression Is Nothing)
 
             If Info.IsRHS Then
                 If isByRef Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                 Else
                     Emitter.EmitLoadVariable(Info, ParameterInfo)
                 End If
             Else
                 Dim rInfo As EmitInfo
                 Dim rhs As Expression = Info.RHSExpression
                 Dim paramConsumed As Boolean
 
                 If isByRefStructure Then
                     Emitter.EmitLoadVariable(Info.Clone(Parent, paramType), ParameterInfo)
                     If TypeOf rhs Is GetRefExpression Then rhs = DirectCast(rhs, GetRefExpression).Expression
                     'paramConsumed = TypeOf rhs Is NewExpression
                     If paramConsumed Then
                         rInfo = Info.Clone(Parent, True, False, paramType)
                     Else
                         rInfo = Info.Clone(Parent, True, False, paramElementType)
                     End If
                 ElseIf isByRef Then
                     Emitter.EmitLoadVariableLocation(Info, ParameterInfo)
                     rInfo = Info.Clone(Parent, True, False, paramElementType)
                 Else
                     rInfo = Info.Clone(Parent, True, False, paramType)
                 End If
 
                 Helper.Assert(rhs IsNot Nothing, "RHSExpression Is Nothing!")
                 Helper.Assert(rhs.Classification.IsValueClassification)
                 result = rhs.Classification.GenerateCode(rInfo) AndAlso result
 
                 If Not paramConsumed Then
                     If isByRef = False Then
                         Emitter.EmitConversion(rhs.ExpressionType, paramType, Info)
                     End If
                     If isByRefStructure Then
                         Emitter.EmitStoreIndirect(Info, paramType)
                     Else
                         Emitter.EmitStoreVariable(Info, ParameterInfo)
                     End If
                 End If
             End If
         ElseIf Me.m_Variable IsNot Nothing Then
             If Info.IsRHS Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Else
                 Dim rInfo As EmitInfo = Info.Clone(Parent, True, False, m_Variable.VariableType)
 
                 Helper.Assert(Info.RHSExpression IsNot Nothing)
                 Helper.Assert(Info.RHSExpression.Classification.IsValueClassification)
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
 
                 Emitter.EmitConversion(Info.RHSExpression.ExpressionType, m_Variable.VariableType, Info)
 
                 If Helper.CompareType(m_Variable.VariableType, Compiler.TypeCache.System_Object) AndAlso Helper.CompareType(Info.RHSExpression.ExpressionType, Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
 
                 Emitter.EmitStoreVariable(Info, LocalBuilder)
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf m_ArrayVariable IsNot Nothing Then
             If Info.IsRHS Then
                 result = Me.GenerateCodeAsValue(Info) AndAlso result
             Else
                 result = Helper.EmitStoreArrayElement(Info, m_ArrayVariable, m_Arguments) AndAlso result
 
             End If
         ElseIf m_Method IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, m_Method.DefaultReturnVariable)
             Else
                 Helper.Assert(Info.RHSExpression IsNot Nothing, "RHSExpression Is Nothing!")
                 Helper.Assert(Info.RHSExpression.Classification.IsValueClassification)
                 result = Info.RHSExpression.Classification.GenerateCode(Info.Clone(Parent, True, False, m_Method.DefaultReturnVariable.VariableType)) AndAlso result
                 Emitter.EmitStoreVariable(Info, m_Method.DefaultReturnVariable)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="384" endline="388"><![CDATA[
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             Return m_InstanceExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="389" endline="393"><![CDATA[
     End Property
 
     <Obsolete()> Overloads Function ReclassifyToValue() As ValueClassification
         Return New ValueClassification(Me)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="394" endline="406"><![CDATA[
 
     ''' <summary>
     ''' A variable declaration which refers to the implicitly declared local variable
     ''' for methods with return values (functions and get properties)
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="method"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal method As IMethod)
         MyBase.New(Classifications.Variable, Parent)
         Helper.Assert(TypeOf method Is FunctionDeclaration OrElse TypeOf method Is PropertyGetDeclaration)
         m_Method = method
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="407" endline="412"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal parameter As Parameter)
         MyBase.New(Classifications.Variable, Parent)
         m_Parameter = parameter
         m_ParameterInfo = parameter.CecilBuilder
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="413" endline="420"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal variable As VariableDeclaration, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.New(Classifications.Variable, Parent)
         m_Variable = variable
         m_LocalVariable = TryCast(m_Variable, LocalVariableDeclaration)
         m_TypeVariable = TryCast(m_Variable, TypeVariableDeclaration)
         m_InstanceExpression = InstanceExpression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="421" endline="426"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.new(Classifications.Variable, Parent)
         m_Expression = Expression
         m_ExpressionType = ExpressionType
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="427" endline="435"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal variable As Mono.Cecil.FieldReference, ByVal InstanceExpression As Expression)
         MyBase.New(Classifications.Variable, Parent)
         m_FieldInfo = variable
         m_InstanceExpression = InstanceExpression
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
         Helper.Assert((Helper.IsShared(variable) AndAlso m_InstanceExpression Is Nothing) OrElse (Helper.IsShared(variable) = False AndAlso m_InstanceExpression IsNot Nothing))
         Helper.Assert(variable IsNot Nothing AndAlso variable.FieldType IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="436" endline="449"><![CDATA[
 
     ''' <summary>
     ''' Creates a variable classification for an array access.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Arguments"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal ArrayVariableExpression As Expression, ByVal Arguments As ArgumentList)
         MyBase.New(Classifications.Variable, Parent)
         m_ArrayVariable = ArrayVariableExpression
         m_Arguments = Arguments
         Helper.Assert(ArrayVariable IsNot Nothing)
         Helper.Assert(Arguments IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="450" endline="475"><![CDATA[
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference 'Descriptor
         Get
             Dim result As Mono.Cecil.TypeReference
             If m_ExpressionType IsNot Nothing Then
                 result = m_ExpressionType
             ElseIf m_Method IsNot Nothing Then
                 result = m_Method.Signature.ReturnType
             ElseIf m_Variable IsNot Nothing Then
                 result = m_Variable.VariableType
             ElseIf m_FieldInfo IsNot Nothing Then
                 If Helper.IsEnum(Compiler, m_FieldInfo.DeclaringType) Then
                     result = m_FieldInfo.DeclaringType
                 Else
                     result = m_FieldInfo.FieldType
                 End If
             ElseIf m_Parameter IsNot Nothing Then
                 result = m_Parameter.ParameterType
             ElseIf m_ArrayVariable IsNot Nothing Then
                 result = CecilHelper.GetElementType(m_ArrayVariable.ExpressionType)
             Else
                 Throw New InternalException(Me)
             End If
             Helper.Assert(result IsNot Nothing)
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VoidClassification.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Classifications.Void, Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="28" endline="30"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return m_Delegate(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="31" endline="37"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal CodeGenerator As GenerateCodeDelegate, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         m_Delegate = CodeGenerator
         m_ExpressionType = ExpressionType
         MyBase.Classification = New ValueClassification(Me)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="38" endline="41"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="42" endline="46"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="47" endline="59"><![CDATA[
     End Property
 End Class
 
 Public Class LoadLocalExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="60" endline="80"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Local IsNot Nothing)
 
         If Info.IsRHS Then
             If CecilHelper.IsByRef(Info.DesiredType) Then
                 Emitter.EmitLoadVariableLocation(Info, m_Local)
             Else
                 Emitter.EmitLoadVariable(Info, m_Local)
             End If
         Else
             If Info.RHSExpression IsNot Nothing Then
                 result = Info.RHSExpression.GenerateCode(Info.Clone(Me, True, , m_Local.VariableType)) AndAlso result
             End If
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="81" endline="94"><![CDATA[
 End Class
 
 Public Class LoadElementExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     Private m_Index As Integer
 
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition, ByVal Index As Integer)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
         m_Index = Index
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="95" endline="106"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.IsRHS)
 
         Emitter.EmitLoadVariable(Info, m_Local)
         Emitter.EmitLoadI4Value(Info, m_Index)
         Emitter.EmitLoadElement(Info, m_Local.VariableType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="107" endline="115"><![CDATA[
 End Class
 
 Public Class ValueOnStackExpression
     Inherits CompilerGeneratedExpression
 
     Sub New(ByVal Parent As ParsedObject, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent, Nothing, ExpressionType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="116" endline="119"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="38" endline="45"><![CDATA[
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         If m_Value IsNot Nothing Then
             Classification = New ValueClassification(Me, m_ExpressionType, m_Value)
         Else
             Classification = New ValueClassification(Me, m_ExpressionType, DBNull.Value)
         End If
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="46" endline="50"><![CDATA[
 
     Protected Sub Init(ByVal Value As Object, ByVal ExpressionType As Mono.Cecil.TypeReference)
         m_Value = Value
         m_ExpressionType = ExpressionType
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="51" endline="55"><![CDATA[
 
     Protected Property Value() As Object
         Get
             Return m_Value
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="56" endline="58"><![CDATA[
         Set(ByVal value As Object)
             m_Value = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="59" endline="64"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_Value
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="65" endline="71"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
 
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="72" endline="76"><![CDATA[
     End Property
 
     Protected Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="77" endline="83"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Constant As Object, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
         m_Value = Constant
         m_ExpressionType = ExpressionType
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="84" endline="88"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="34" endline="88"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 'Nothing to do
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.SByte, TypeCode.Int16, TypeCode.Int32
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.Int64
                 Emitter.EmitLoadI8Value(Info, 0L, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.UInt64
                 Emitter.EmitLoadI8Value(Info, 0UL, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitLoadR8Value(Info, 0.0, expType)
                 Emitter.EmitEquals(Info, expType)
                 Emitter.EmitLoadI4Value(Info, 0I, Info.Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Info.Compiler.TypeCache.System_Boolean)
             Case TypeCode.Single
                 Emitter.EmitLoadR4Value(Info, 0.0!, expType)
                 Emitter.EmitEquals(Info, expType)
                 Emitter.EmitLoadI4Value(Info, 0I, Info.Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Info.Compiler.TypeCache.System_Boolean)
             Case TypeCode.Object
                 Helper.Assert(Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object IsNot Nothing, "MS_VB_CS_Conversions_ToBoolean__Object Is Nothing")
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Helper.Assert(Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_String IsNot Nothing, "MS_VB_CS_Conversions_ToBoolean__String Is Nothing")
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_String)
             Case TypeCode.Decimal
                 Helper.Assert(Info.Compiler.TypeCache.System_Convert__ToBoolean_Decimal IsNot Nothing, "System_Convert_ToBoolean__Decimal Is Nothing")
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToBoolean_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="89" endline="100"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127"><![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="128" endline="133"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             'CHECK
             Return Expression.IsConstant AndAlso Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.System_String) = False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="134" endline="152"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
                   TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Return CBool(originalValue) 'No range checking needed.
                 Case TypeCode.DBNull
                     Return CBool(Nothing)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return False
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="153" endline="158"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Boolean
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="44" endline="72"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="73" endline="124"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U1(Info, expType)
             Case TypeCode.Byte
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U1_Overflow(Info, expType)
             Case TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_U1_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U1_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U1_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToByte_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="125" endline="149"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte
                     Return CByte(originalValue) 'No range checking needed.
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CByte(0)
                     End If
                 Case TypeCode.DBNull
                     Return CByte(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CByte(0)
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="150" endline="157"><![CDATA[
     End Property
 
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
 
             Return Compiler.TypeCache.System_Byte
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="34" endline="67"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 'Nothing to do
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32007, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Double, TypeCode.DateTime, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToChar_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'Nothing to do
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToChar_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="68" endline="77"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="78" endline="109"><![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 'Nothing to do
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32007, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.String
                 'OK
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case Else
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="110" endline="115"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If Helper.CompareType(Compiler.TypeCache.Nothing, Me.Expression.ExpressionType) Then Return True
             Return Expression.IsConstant AndAlso (TypeOf Expression.ConstantValue Is Char OrElse (TypeOf Expression.ConstantValue Is String AndAlso CStr(Expression.ConstantValue).Length = 1))
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="116" endline="140"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.String
                     If CStr(originalValue).Length = 1 Then
                         Return CChar(originalValue)
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, ExpressionType.ToString)
                         Return New Char
                     End If
                 Case TypeCode.Char
                     Return CChar(originalValue)
                 Case TypeCode.DBNull
                     Return VB.ChrW(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, ExpressionType.ToString)
                     Return New Char
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="141" endline="147"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
 
             Return Compiler.TypeCache.System_Char
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="34" endline="70"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Info.Compiler.TypeCache.System_Double.Name, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Double
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30533, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_Object)
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="71" endline="80"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="81" endline="114"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Info.Compiler.TypeCache.System_Double.Name, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Double
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30533, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="115" endline="119"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return Expression.IsConstant AndAlso Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.System_DateTime)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="120" endline="128"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             Helper.Assert(TypeOf originalValue Is Date)
             Return originalValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="129" endline="135"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
 
             Return Compiler.TypeCache.System_DateTime
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="44" endline="73"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="74" endline="120"><![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Double
                 'Nothing to do
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToDouble_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="121" endline="125"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return Expression.IsConstant AndAlso Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.System_String) = False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="126" endline="144"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
                 TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Return CDbl(originalValue) 'No range checking needed.
                 Case TypeCode.DBNull
                     Return CDbl(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Double
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="145" endline="150"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Double
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="44" endline="70"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="71" endline="123"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Boolean)
             Case TypeCode.Decimal
                 'Nothing to do
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16
                 Emitter.EmitConv_I4_Overflow(Info, expType)
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int32)
             Case TypeCode.Int32
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int32)
             Case TypeCode.Int64
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int64)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_U8_Overflow_Underflow(Info, expType)
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_UInt64)
             Case TypeCode.Double
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Double)
             Case TypeCode.Single
                 If Expression.IsConstant Then
                     'VBC BUG? This seems to be a bug in vbc.exe.
                     Emitter.EmitLoadDecimalValue(Info, New Decimal(CDbl(Expression.ConstantValue)))
                 Else
                     'CORRECT CODE.
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Single)
                 End If
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="124" endline="146"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Decimal
                     Return CDec(originalValue) 'No range checking needed.
                 Case TypeCode.Single, TypeCode.Double, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Expression.Location, ExpressionType.ToString)
                         Return New Decimal
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Expression.Location, originalValue.ToString, ExpressionType.ToString)
                     Return New Decimal
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="147" endline="152"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Decimal
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="44" endline="73"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="74" endline="125"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I4(Info, expType)
             Case TypeCode.Int32
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I4_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I4_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I4_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I4_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt32_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="149" endline="154"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Int32
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="44" endline="73"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="74" endline="125"><![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I8(Info, expType)
             Case TypeCode.Int64
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I8_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt64_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="126" endline="148"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt32
                     Return CLng(originalValue) 'No range checking needed.
                 Case TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Long
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Long
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="149" endline="154"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Int64
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="30" endline="38"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Expression) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="39" endline="44"><![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Expression As Expression) As Boolean
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="45" endline="59"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Expression As Expression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             result = Expression.GenerateCode(Info.Clone(Expression, True, False, Expression.ExpressionType)) AndAlso result
             If CecilHelper.IsValueType(Expression.ExpressionType) OrElse CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
                 Emitter.EmitBox(Info, Expression.ExpressionType)
             End If
         Else
             Throw New InternalException(Expression)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="60" endline="63"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me.Expression, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="64" endline="68"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="69" endline="74"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Object
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="28" endline="30"><![CDATA[
         Get
             Return "CType (" & m_Expression.AsString & ", " & ExpressionType.FullName & ")"
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="31" endline="85"><![CDATA[
     End Property
 
     Shared Function GetTypeConversion(ByVal Parent As ParsedObject, ByVal fromExpr As Expression, ByVal DestinationType As Mono.Cecil.TypeReference) As Expression
 
         If Helper.CompareType(fromExpr.ExpressionType, DestinationType) Then
             Return fromExpr
         End If
 
         Select Case Helper.GetTypeCode(Parent.Compiler, DestinationType)
             Case TypeCode.Boolean
                 Return New CBoolExpression(Parent, fromExpr)
             Case TypeCode.Byte
                 Return New CByteExpression(Parent, fromExpr)
             Case TypeCode.Char
                 Return New CCharExpression(Parent, fromExpr)
             Case TypeCode.DateTime
                 Return New CDateExpression(Parent, fromExpr)
             Case TypeCode.Decimal
                 Return New CDecExpression(Parent, fromExpr)
             Case TypeCode.Double
                 Return New CDblExpression(Parent, fromExpr)
             Case TypeCode.Int16
                 Return New CShortExpression(Parent, fromExpr)
             Case TypeCode.Int32
                 Return New CIntExpression(Parent, fromExpr)
             Case TypeCode.Int64
                 Return New CLngExpression(Parent, fromExpr)
             Case TypeCode.SByte
                 Return New CSByteExpression(Parent, fromExpr)
             Case TypeCode.Single
                 Return New CSngExpression(Parent, fromExpr)
             Case TypeCode.String
                 Return New CStrExpression(Parent, fromExpr)
             Case TypeCode.UInt16
                 Return New CUShortExpression(Parent, fromExpr)
             Case TypeCode.UInt32
                 Return New CUIntExpression(Parent, fromExpr)
             Case TypeCode.UInt64
                 Return New CULngExpression(Parent, fromExpr)
             Case Else
                 If CecilHelper.IsByRef(DestinationType) AndAlso CecilHelper.IsByRef(fromExpr.ExpressionType) = False Then
                     Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(DestinationType)
                     Dim result As Boolean = True
                     Dim tmp As Expression
                     tmp = GetTypeConversion(Parent, fromExpr, elementType)
                     result = tmp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
                     tmp = New GetRefExpression(Parent, tmp)
                     result = tmp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
                     If result = False Then Throw New InternalException
                     Return tmp
                 Else
                     Return New CTypeExpression(Parent, fromExpr, DestinationType)
                 End If
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="86" endline="89"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Expression.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="90" endline="94"><![CDATA[
 
     ReadOnly Property Expression() As Expression
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="95" endline="100"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="101" endline="105"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent)
         Me.IsExplicit = IsExplicit
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="106" endline="109"><![CDATA[
 
     Sub Init(ByVal Expression As Expression)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="110" endline="125"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If m_Expression.IsConstant = False Then
                 Return False
             Else
                 Dim value As Object
                 value = m_Expression.ConstantValue
                 Dim result As Object = Nothing
                 If Compiler.TypeResolution.CheckNumericRange(value, result, ExpressionType) Then
                     Return True
                 Else
                     Return False
                 End If
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="126" endline="141"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
         End If
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="142" endline="150"><![CDATA[
 
     Public Shared Function SelectNarrowingConversionOperator(ByVal Compiler As Compiler, ByVal Type As TypeReference, ByVal ReturnType As TypeReference, ByRef ConversionMethod As MethodReference) As Boolean
         Dim methods As Generic.List(Of MethodReference)
 
         methods = TypeResolution.GetNarrowingConversionOperators(Compiler, Type, ReturnType)
         If methods Is Nothing OrElse methods.Count <> 1 Then Return False
         ConversionMethod = methods(0)
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="151" endline="169"><![CDATA[
 
     Protected Shared Function ValidateForNullable(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression, ByRef expTypeCode As TypeCode, ByRef expType As TypeReference) As Boolean
         Dim result As Boolean = True
         Dim ConversionMethod As MethodReference = Nothing
 
         expType = Conversion.Expression.ExpressionType
 
         If CecilHelper.IsNullable(expType) Then
             If SelectNarrowingConversionOperator(Info.Compiler, expType, Conversion.ExpressionType, ConversionMethod) = False Then
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Conversion.Expression.Location)
             End If
             expType = CecilHelper.GetNulledType(expType)
             Conversion.ConversionMethod = ConversionMethod
         End If
 
         expTypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="170" endline="187"><![CDATA[
 
     Protected Shared Function GenerateCodeForExpression(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo, ByRef expTypeCode As TypeCode, ByRef expType As TypeReference) As Boolean
         Dim result As Boolean = True
         Dim Expression As Expression = Conversion.Expression
 
         expType = Expression.ExpressionType
 
         result = Expression.Classification.GenerateCode(Info.Clone(Expression, expType)) AndAlso result
 
         If Conversion.ConversionMethod IsNot Nothing Then
             Emitter.EmitCall(Info, Conversion.ConversionMethod)
             expType = Conversion.ConversionMethod.ReturnType
         End If
 
         expTypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="188" endline="220"><![CDATA[
 
     Public Function FindUserDefinedConversionOperator(Optional ByVal ShowNoOperatorsError As Boolean = True) As Boolean
         Dim result As Boolean = True
         Dim expType As TypeReference = Expression.ExpressionType
         Dim destinationType As TypeReference = Me.ExpressionType
         Dim ops As Generic.List(Of MethodReference)
         Dim isNarrowing As Boolean
 
         ops = Helper.GetWideningConversionOperators(Compiler, expType, destinationType)
 
         If ops Is Nothing OrElse ops.Count = 0 Then
             ops = Helper.GetNarrowingConversionOperators(Compiler, expType, destinationType)
             isNarrowing = True
         End If
 
         If ops Is Nothing OrElse ops.Count = 0 Then
             If ShowNoOperatorsError = False Then Return True
             If CecilHelper.IsNullable(expType) AndAlso CecilHelper.IsNullable(destinationType) AndAlso Compiler.TypeResolver.IsExplicitlyConvertible(Compiler, Helper.GetTypeCode(Compiler, CecilHelper.GetNulledType(expType)), Helper.GetTypeCode(Compiler, CecilHelper.GetNulledType(destinationType))) Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC30512, Expression.Location, Helper.ToString(Me, expType), Helper.ToString(Me, ExpressionType))
             End If
             Return Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Me, expType), Helper.ToString(Me, ExpressionType))
         End If
 
         If ops.Count > 1 Then Return Compiler.Report.ShowMessage(Messages.VBNC30311, Me.Location, Helper.ToString(Me, expType), Helper.ToString(Me, ExpressionType))
 
         If isNarrowing AndAlso IsExplicit = False AndAlso Location.File(Compiler).IsOptionStrictOn Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30512, Me.Location, Helper.ToString(Me, expType), Helper.ToString(Me, ExpressionType)) AndAlso result
         End If
 
         ConversionMethod = ops(0)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="44" endline="73"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="74" endline="125"><![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I1(Info, expType)
             Case TypeCode.SByte
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I1_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I1_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I1_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I1_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToSByte_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="126" endline="148"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.SByte
                     Return CSByte(originalValue) 'No range checking needed.
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New SByte
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CSByte(0)
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="149" endline="154"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_SByte
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="44" endline="73"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="74" endline="125"><![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I2(Info, expType)
             Case TypeCode.Int16
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I2_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I2_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I2_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I2_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt16_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="126" endline="148"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16
                     Return CShort(originalValue) 'No range checking needed.
                 Case TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Short
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Short
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="149" endline="154"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Int16
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="44" endline="70"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="71" endline="114"><![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Single
                 'Nothing to do
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToSingle_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="115" endline="137"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Decimal
                     Return CSng(originalValue) 'No range checking needed.
                 Case TypeCode.Double, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Single
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Single
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="138" endline="143"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Single
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="34" endline="42"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="43" endline="68"><![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         Dim expType As Mono.Cecil.TypeReference = Expression.ExpressionType
         Dim expTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Select Case expTypeCode
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="69" endline="122"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Boolean)
             Case TypeCode.String
                 'Nothing to do
             Case TypeCode.Char
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Char)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_DateTime)
             Case TypeCode.SByte, TypeCode.Int16
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Int32)
             Case TypeCode.Int32
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Int32)
             Case TypeCode.Int64
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Int64)
             Case TypeCode.Byte
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Byte)
             Case TypeCode.UInt16, TypeCode.UInt32
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_UInt32)
             Case TypeCode.UInt64
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_UInt64)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Double)
             Case TypeCode.Single
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Single)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_String__ctor_Array)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'No conversion necessary
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_String__ctor_Array)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99999, Expression.Location, "Can't convert")
                 End If
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="123" endline="127"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return Expression.IsConstant AndAlso (Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.System_String) OrElse Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.System_Char) OrElse Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.Nothing))
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="128" endline="146"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
 
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Char, TypeCode.String
                     Return CStr(originalValue)
                 Case TypeCode.DBNull
                     Return DBNull.Value
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return False
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="147" endline="152"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_String
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="26" endline="38"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_DestinationType IsNot Nothing Then
             result = m_DestinationType.ResolveTypeReferences AndAlso result
             m_ResolvedDestinationType = m_DestinationType.ResolvedType
             Helper.Assert(CecilHelper.IsByRef(m_ResolvedDestinationType) = False)
         End If
 
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="39" endline="42"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="43" endline="48"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression, ByVal DestinationType As Mono.Cecil.TypeReference)
         MyBase.New(Parent, Expression)
         m_ResolvedDestinationType = DestinationType
         Helper.Assert(CecilHelper.IsByRef(m_ResolvedDestinationType) = False, "Can't create TypeConversion to byref type (trying to convert from " & Expression.ExpressionType.FullName & " to " & DestinationType.FullName)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="49" endline="53"><![CDATA[
 
     Shadows Sub Init(ByVal Expression As Expression, ByVal DestinationType As TypeName)
         MyBase.Init(Expression)
         m_DestinationType = DestinationType
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="54" endline="58"><![CDATA[
 
     Shadows Sub Init(ByVal Expression As Expression, ByVal DestinationType As Mono.Cecil.TypeReference)
         MyBase.Init(Expression)
         m_ResolvedDestinationType = DestinationType
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="59" endline="108"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Me.ExpressionType
         Dim expTypeCode As TypeCode = Helper.GetTypeCode(Compiler, expType)
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 CBoolExpression.GenerateCode(Me, Info)
             Case TypeCode.Byte
                 CByteExpression.GenerateCode(Me, Info)
             Case TypeCode.Char
                 CCharExpression.GenerateCode(Me, Info)
             Case TypeCode.DateTime
                 CDateExpression.GenerateCode(Me, Info)
             Case TypeCode.Decimal
                 CDecExpression.GenerateCode(Me, Info)
             Case TypeCode.Double
                 CDblExpression.GenerateCode(Me, Info)
             Case TypeCode.Int16
                 CShortExpression.GenerateCode(Me, Info)
             Case TypeCode.Int32
                 CIntExpression.GenerateCode(Me, Info)
             Case TypeCode.Int64
                 CLngExpression.GenerateCode(Me, Info)
             Case TypeCode.SByte
                 CSByteExpression.GenerateCode(Me, Info)
             Case TypeCode.Single
                 CSngExpression.GenerateCode(Me, Info)
             Case TypeCode.String
                 CStrExpression.GenerateCode(Me, Info)
             Case TypeCode.UInt16
                 CUShortExpression.GenerateCode(Me, Info)
             Case TypeCode.UInt32
                 CUIntExpression.GenerateCode(Me, Info)
             Case TypeCode.UInt64
                 CULngExpression.GenerateCode(Me, Info)
             Case TypeCode.Object, TypeCode.DBNull
                 If Helper.CompareType(expType, Compiler.TypeCache.System_Object) Then
                     CObjExpression.GenerateCode(Me.Expression, Info)
                 Else
                     result = GenerateCTypeCode(Info, expType, Me.Expression.ExpressionType)
                 End If
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="109" endline="117"><![CDATA[
 
     Private Function EmitStringToCharArray(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Expression.GenerateCode(Info.Clone(Info.Context, Compiler.TypeCache.System_String)) AndAlso result
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToCharArrayRankOne_String)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="118" endline="362"><![CDATA[
 
     Private Function GenerateCTypeCode(ByVal Info As EmitInfo, ByVal DestinationType As Mono.Cecil.TypeReference, ByVal SourceType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         If m_IsStringToCharArray Then
             Return EmitStringToCharArray(Info) AndAlso result
         End If
 
         result = Expression.Classification.GenerateCode(Info.Clone(Me, DestinationType)) AndAlso result
 
         If Helper.CompareType(Compiler.TypeCache.Nothing, SourceType) Then
             'There is nothing to do here
         ElseIf CecilHelper.IsGenericParameter(SourceType) Then
             If CecilHelper.IsGenericParameter(DestinationType) Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             ElseIf CecilHelper.IsArray(DestinationType) Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             ElseIf CecilHelper.IsClass(DestinationType) Then
                 DestinationType = Helper.GetTypeOrTypeBuilder(Compiler, DestinationType)
                 If Helper.IsTypeConvertibleToAny(Helper.GetGenericParameterConstraints(Me, SourceType), DestinationType) Then
                     'Emitter.EmitUnbox_Any(Info, DestinationType)
                     Emitter.EmitBox(Info, SourceType)
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 Else
                     Helper.AddError(Me)
                 End If
             ElseIf CecilHelper.IsValueType(DestinationType) Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             ElseIf Helper.IsInterface(Compiler, DestinationType) Then
                 Emitter.EmitBox(Info, SourceType)
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             Else
                 Throw New InternalException(Me)
             End If
         ElseIf CecilHelper.IsArray(SourceType) Then
             If CecilHelper.IsInterface(DestinationType) Then
                 If Helper.DoesTypeImplementInterface(Me, SourceType, DestinationType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf Helper.CompareType(SourceType, Compiler.TypeCache.System_Object_Array) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf CecilHelper.IsArray(DestinationType) AndAlso Helper.DoesTypeImplementInterface(Me, CecilHelper.GetElementType(SourceType), CecilHelper.GetElementType(DestinationType)) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Location, Helper.ToString(Expression, SourceType), Helper.ToString(Expression, DestinationType))
                     result = False
                 End If
             ElseIf Helper.CompareType(DestinationType, Compiler.TypeCache.System_Array) Then
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             ElseIf CecilHelper.IsArray(DestinationType) = False Then
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Location, Helper.ToString(Expression, SourceType), Helper.ToString(Expression, DestinationType))
                 result = False
             ElseIf CecilHelper.GetArrayRank(SourceType) <> CecilHelper.GetArrayRank(DestinationType) Then
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Location, Helper.ToString(Expression, SourceType), Helper.ToString(Expression, DestinationType))
                 result = False
             Else
                 Dim SourceElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(SourceType)
                 Dim DestinationElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(DestinationType)
                 'For any two reference types A and B, if A is a derived type of B or implements B, 
                 'a conversion exists from an array of type A to a compatible array of type B.
                 'A compatible array is an array of the same rank and type. 
                 'This relationship is known as array covariance. 
                 'Array covariance in particular means that an element of an array whose element type is B 
                 'may actually be an element of an array whose element type is A, 
                 'provided that both A and B are reference types and that B is a base type of A or is implemented by A. 
                 If Helper.CompareType(Compiler.TypeCache.System_Object, SourceElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf Helper.CompareType(SourceElementType, DestinationElementType) OrElse Helper.IsSubclassOf(DestinationElementType, SourceElementType) OrElse Helper.IsSubclassOf(SourceElementType, DestinationElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf Helper.DoesTypeImplementInterface(Me, SourceElementType, DestinationElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf Helper.IsInterface(Info.Compiler, DestinationElementType) AndAlso Helper.CompareType(Compiler.TypeCache.System_Object, SourceElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf helper.IsEnum(compiler, sourceelementtype)AndAlso Helper.CompareType(Helper.GetEnumType(Compiler, SourceElementType), DestinationElementType) Then
                     'Conversions also exist between an array of an enumerated type and an array of the enumerated type's underlying type of the same rank.
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf CecilHelper.IsGenericParameter(SourceElementType) AndAlso Helper.IsTypeConvertibleToAny(Helper.GetGenericParameterConstraints(Me, SourceElementType), DestinationElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf CecilHelper.IsGenericParameter(DestinationElementType) AndAlso Helper.IsTypeConvertibleToAny(SourceElementType, Helper.GetGenericParameterConstraints(Me, DestinationElementType)) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Me.Location, SourceType.Name, DestinationType.Name)
                     result = False
                 End If
 
             End If
         ElseIf CecilHelper.IsClass(SourceType) Then
             If CecilHelper.IsGenericParameter(DestinationType) Then
                 Dim methodD As New Mono.Cecil.GenericInstanceMethod(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.MS_VB_CS_Conversions__ToGenericParameter_Object))
                 methodD.GenericParameters.Add(DirectCast(CecilHelper.GetGenericArguments(Compiler.TypeCache.MS_VB_CS_Conversions__ToGenericParameter_Object)(0), Mono.Cecil.GenericParameter))
                 methodD.GenericArguments.Add(DestinationType)
 
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 Emitter.EmitCall(Info, methodD)
             ElseIf CecilHelper.IsClass(DestinationType) Then
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             ElseIf CecilHelper.IsInterface(DestinationType) Then
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             ElseIf CecilHelper.IsValueType(DestinationType) Then
                 Emitter.EmitUnbox(Info, DestinationType)
                 Emitter.EmitLdobj(Info, DestinationType)
             ElseIf Helper.IsEnum(Compiler, DestinationType) Then
                 Throw New InternalException(Me) 'This is an elemental conversion already covered.
             ElseIf CecilHelper.IsArray(DestinationType) Then
                 Throw New InternalException(Me) 'This is an IsClass case.
             Else
                 Throw New InternalException(Me)
             End If
         ElseIf CecilHelper.IsNullable(DestinationType) Then
             If CecilHelper.IsNullable(SourceType) Then
                 Dim nullable_src_type As GenericInstanceType
                 Dim nullable_dst_type As GenericInstanceType
                 Dim get_value As MethodReference
                 Dim has_value As MethodReference
                 Dim ctor As MethodReference
                 Dim localsrc, localdst As Mono.Cecil.Cil.VariableDefinition
                 Dim falseLabel As Label = Emitter.DefineLabel(Info)
                 Dim endLabel As Label = Emitter.DefineLabel(Info)
                 Dim vose As ValueOnStackExpression
                 Dim type_conversion As Expression
 
                 nullable_src_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_src_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(SourceType)))
                 has_value = New MethodReference("get_HasValue", nullable_src_type, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Boolean), True, False, MethodCallingConvention.Default)
                 get_value = New MethodReference("GetValueOrDefault", nullable_src_type, Compiler.TypeCache.System_Nullable1.GenericParameters(0), True, False, MethodCallingConvention.Default)
 
                 nullable_dst_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_dst_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(DestinationType)))
                 ctor = New MethodReference(".ctor", nullable_dst_type, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, MethodCallingConvention.Default)
                 ctor.Parameters.Add(New ParameterDefinition(Compiler.TypeCache.System_Nullable1.GenericParameters(0)))
 
                 'store in local
                 localsrc = Emitter.DeclareLocal(Info, SourceType)
                 Emitter.EmitStoreVariable(Info, localsrc)
 
                 'call Nullable`1.HasValue to check the condition
                 Emitter.EmitLoadVariableLocation(Info, localsrc)
                 Emitter.EmitCall(Info, has_value)
                 Emitter.EmitBranchIfFalse(Info, falseLabel)
 
                 localdst = Emitter.DeclareLocal(Info, DestinationType)
 
                 'true branch
                 Emitter.EmitLoadVariableLocation(Info, localdst)
                 Emitter.EmitLoadVariableLocation(Info, localsrc)
                 Emitter.EmitCall(Info, get_value)
 
                 'convert value
                 vose = New ValueOnStackExpression(Me, CecilHelper.GetNulledType(SourceType))
                 type_conversion = Helper.CreateTypeConversion(Me, vose, CecilHelper.GetNulledType(DestinationType), result)
                 result = type_conversion.GenerateCode(Info) AndAlso result
 
                 Emitter.EmitCall(Info, ctor)
                 Emitter.EmitLoadVariable(Info, localdst)
                 Emitter.EmitBranch(Info, endLabel)
 
                 'false branch
                 Emitter.MarkLabel(Info, falseLabel)
                 Emitter.EmitLoadVariableLocation(Info, localdst)
                 Emitter.EmitInitObj(Info, localdst.VariableType)
                 Emitter.EmitLoadVariable(Info, localdst)
 
                 'end
                 Emitter.MarkLabel(Info, endLabel)
             Else
                 Dim nullable_dst_type As GenericInstanceType
                 Dim ctor As MethodReference
                 Dim localsrc, localdst As Mono.Cecil.Cil.VariableDefinition
                 Dim falseLabel As Label = Emitter.DefineLabel(Info)
                 Dim endLabel As Label = Emitter.DefineLabel(Info)
                 Dim vose As ValueOnStackExpression
                 Dim type_conversion As Expression
 
                 nullable_dst_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_dst_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(DestinationType)))
                 ctor = New MethodReference(".ctor", nullable_dst_type, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, MethodCallingConvention.Default)
                 ctor.Parameters.Add(New ParameterDefinition(Compiler.TypeCache.System_Nullable1.GenericParameters(0)))
 
                 'store in local
                 localsrc = Emitter.DeclareLocal(Info, SourceType)
                 Emitter.EmitStoreVariable(Info, localsrc)
 
                 localdst = Emitter.DeclareLocal(Info, DestinationType)
 
                 Emitter.EmitLoadVariableLocation(Info, localdst)
                 Emitter.EmitLoadVariable(Info, localsrc)
 
                 'convert value
                 vose = New ValueOnStackExpression(Me, SourceType)
                 type_conversion = Helper.CreateTypeConversion(Me, vose, CecilHelper.GetNulledType(DestinationType), result)
                 result = type_conversion.GenerateCode(Info) AndAlso result
 
                 Emitter.EmitCall(Info, ctor)
                 Emitter.EmitLoadVariable(Info, localdst)
             End If
         ElseIf CecilHelper.IsValueType(SourceType) Then
             'A value type value can be converted to one of its base reference types or an interface type that it implements through a process called boxing
             If Helper.CompareType(DestinationType, Compiler.TypeCache.System_Object) Then
                 Throw New InternalException(Me) 'This is an elemental conversion already covered. 'Emitter.EmitBox(Info)
             ElseIf Helper.DoesTypeImplementInterface(Me, SourceType, DestinationType) Then
                 Emitter.EmitBox(Info, SourceType)
                 Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Object, DestinationType)
             ElseIf Helper.CompareType(DestinationType, Compiler.TypeCache.System_ValueType) Then
                 Emitter.EmitBox(Info, SourceType)
             ElseIf Helper.CompareType(CecilHelper.FindDefinition(SourceType).BaseType, DestinationType) Then
                 Emitter.EmitBox(Info, DestinationType)
             Else
                 Dim operators As Generic.List(Of Mono.Cecil.MethodReference)
                 operators = Helper.GetWideningConversionOperators(Info.Compiler, SourceType, DestinationType)
                 If operators Is Nothing OrElse operators.Count = 0 Then
                     Helper.AddWarning("using narrowing operators")
                     operators = Helper.GetNarrowingConversionOperators(Info.Compiler, SourceType, DestinationType)
                 End If
                 If operators IsNot Nothing AndAlso operators.Count > 0 Then
                     If operators.Count = 1 Then
                         Emitter.EmitCall(Info, operators(0))
                     Else
                         result = Compiler.Report.ShowMessage(Messages.VBNC30311, Me.Location, Expression.ExpressionType.FullName, ExpressionType.FullName) AndAlso result
                     End If
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC30311, Me.Location, Expression.ExpressionType.FullName, ExpressionType.FullName) AndAlso result
                 End If
             End If
         ElseIf Helper.IsInterface(Compiler, SourceType) Then
             If CecilHelper.IsGenericParameter(DestinationType) Then
                 Emitter.EmitUnbox_Any(Info, DestinationType)
             ElseIf Helper.DoesTypeImplementInterface(Me, DestinationType, SourceType) Then
                 If CecilHelper.IsValueType(DestinationType) Then
                     Emitter.EmitUnbox(Info, DestinationType)
                     Emitter.EmitLdobj(Info, DestinationType)
                 Else
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 End If
 
             ElseIf CecilHelper.IsClass(DestinationType) OrElse CecilHelper.IsInterface(DestinationType) Then
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             Else
                 'However, classes that represent COM classes may have interface implementations that are not known until run time. Consequently, a class type may also be converted to an interface type that it does not implement, an interface type may be converted to a class type that does not implement it, and an interface type may be converted to another interface type with which it has no inheritance relationship
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="363" endline="434"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedDestinationType Is Nothing Then
             result = m_DestinationType.ResolveTypeReferences AndAlso result
             m_ResolvedDestinationType = m_DestinationType.ResolvedType
         End If
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         Select Case Helper.GetTypeCode(Compiler, Me.ExpressionType)
             Case TypeCode.Boolean
                 result = CBoolExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Byte
                 result = CByteExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Char
                 result = CCharExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.DateTime
                 result = CDateExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Decimal
                 result = CDecExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Double
                 result = CDblExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Int16
                 result = CShortExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Int32
                 result = CIntExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Int64
                 result = CLngExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.SByte
                 result = CSByteExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Single
                 result = CSngExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.String
                 result = CStrExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.UInt16
                 result = CUShortExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.UInt32
                 result = CUIntExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.UInt64
                 result = CULngExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Object, TypeCode.DBNull
                 If Helper.CompareType(Me.ExpressionType, Compiler.TypeCache.System_Object) Then
                     result = CObjExpression.Validate(Info, Expression) AndAlso result
                 ElseIf Helper.CompareType(Me.ExpressionType, Compiler.TypeCache.System_Char_Array) AndAlso Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.System_String) Then
                     If Location.File(Compiler).IsOptionStrictOn Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC30512, Location, Helper.ToString(Expression, Expression.ExpressionType), Helper.ToString(Expression, Me.ExpressionType))
                     Else
                         m_IsStringToCharArray = True
                     End If
                 ElseIf Helper.CompareType(Me.Expression.ExpressionType, Compiler.TypeCache.Nothing) Then
                     'OK
                 ElseIf Helper.CompareType(Me.Expression.ExpressionType, Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Compiler.TypeResolver.IsImplicitlyConvertible(Me, Me.Expression.ExpressionType, Me.ExpressionType) Then
                     'OK
                 ElseIf Helper.CompareType(Compiler.TypeCache.System_Array, Me.Expression.ExpressionType) AndAlso CecilHelper.IsArray(Me.ExpressionType) Then
                     'System.Array -> array type OK
                 ElseIf CecilHelper.IsArray(Me.ExpressionType) AndAlso CecilHelper.IsArray(Me.Expression.ExpressionType) Then
                     'OKish
                 ElseIf Location.File(Compiler).IsOptionStrictOn = False AndAlso CecilHelper.IsInterface(Me.Expression.ExpressionType) Then
                     'OKish
                 Else
                     result = FindUserDefinedConversionOperator(Not IsExplicit) AndAlso result
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="435" endline="439"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ResolvedDestinationType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="440" endline="490"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If Helper.CompareType(Compiler.TypeCache.Nothing, Expression.ExpressionType) Then
                 Select Case Helper.GetTypeCode(Compiler, Me.ExpressionType)
                     Case TypeCode.Boolean
                         Return CBool(Nothing)
                     Case TypeCode.Byte
                         Return CByte(Nothing)
                     Case TypeCode.Char
                         Return CChar(Nothing)
                     Case TypeCode.DateTime
                         Return CDate(Nothing)
                     Case TypeCode.Decimal
                         Return CDec(Nothing)
                     Case TypeCode.Double
                         Return CDbl(Nothing)
                     Case TypeCode.Int16
                         Return CShort(Nothing)
                     Case TypeCode.Int32
                         Return CInt(Nothing)
                     Case TypeCode.Int64
                         Return CLng(Nothing)
                     Case TypeCode.SByte
                         Return CSByte(Nothing)
                     Case TypeCode.Single
                         Return CSng(Nothing)
                     Case TypeCode.UInt16
                         Return CUShort(Nothing)
                     Case TypeCode.UInt32
                         Return CUInt(Nothing)
                     Case TypeCode.UInt64
                         Return CULng(Nothing)
                     Case Else
                         Return Nothing
                 End Select
             End If
 
             Select Case Helper.GetTypeCode(Compiler, Me.ExpressionType)
                 Case TypeCode.String
                     Select Case Helper.GetTypeCode(Compiler, Me.Expression.ExpressionType)
                         Case TypeCode.Char
                             Return CStr(Expression.ConstantValue)
                         Case Else
                             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                     End Select
                 Case Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="491" endline="507"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If Expression.IsConstant Then
                 If m_ResolvedDestinationType IsNot Nothing AndAlso Helper.CompareType(m_ResolvedDestinationType, Compiler.TypeCache.System_String) AndAlso Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.System_Char) Then
                     Return True
                 ElseIf Helper.CompareType(Compiler.TypeCache.Nothing, Expression.ExpressionType) Then
                     Return True
                 Else
                     Return False
                 End If
             Else
                 Return False
             End If
             Return False 'TODO
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="508" endline="513"><![CDATA[
     End Property
 
     Protected Overridable ReadOnly Property GetKeyword() As KS
         Get
             Return KS.CType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="44" endline="74"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="75" endline="132"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U4(Info, expType)
             Case TypeCode.UInt32
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U4_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16
                 'nothing to do
                 'Emitter.EmitConv_U4_Overflow_Underflow(Info, expType)
             Case TypeCode.UInt32
                 'nothing to do
             Case TypeCode.UInt64
                 'nothing to do
                 Emitter.EmitConv_U4_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U4_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U4_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUInteger_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUInteger_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUInteger_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt32_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="133" endline="155"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32
                     Return CUInt(originalValue) 'No range checking needed.
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UInteger
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UInteger
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="156" endline="161"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_UInt32
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="44" endline="73"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="74" endline="125"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U8(Info, expType)
             Case TypeCode.uInt64
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U8_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_u8_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U8_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U8_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt64_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="126" endline="148"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                     Return CULng(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New ULong
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New ULong
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="149" endline="154"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_UInt64
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent, Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal IsExplicit As Boolean)
         MyBase.New(Parent, IsExplicit)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="30" endline="33"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="34" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="44" endline="73"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="74" endline="125"><![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U2(Info, expType)
             Case TypeCode.UInt16
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U2_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_u2_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_u2_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U2_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt16_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="126" endline="148"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16
                     Return CUShort(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UShort
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UShort
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="149" endline="154"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_UInt16
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\DirectCastExpression.vb" startline="22" endline="24"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent, True)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\DirectCastExpression.vb" startline="25" endline="28"><![CDATA[
 
     Shadows Sub Init(ByVal Expression As Expression, ByVal DestinationType As TypeName)
         MyBase.Init(Expression, DestinationType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\DirectCastExpression.vb" startline="29" endline="32"><![CDATA[
 
     Shadows Sub Init(ByVal Expression As Expression, ByVal DestinationType As Mono.Cecil.TypeReference)
         MyBase.Init(Expression, DestinationType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\DirectCastExpression.vb" startline="33" endline="70"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If CecilHelper.IsGenericParameter(ExpressionType) Then
             result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
             If Helper.CompareType(Expression.ExpressionType, ExpressionType) = False Then
                 Emitter.EmitUnbox_Any(Info, ExpressionType)
             End If
         Else
             If CecilHelper.IsValueType(Expression.ExpressionType) Then
                 If Helper.CompareType(ExpressionType, Expression.ExpressionType) Then
                     result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                 ElseIf Helper.IsEnum(Compiler, ExpressionType) Then
                     result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                     Emitter.EmitConversion(Expression.ExpressionType, Helper.GetEnumType(Compiler, ExpressionType), Info)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, ExpressionType.FullName & " - " & Expression.ExpressionType.FullName)
                 End If
             ElseIf CecilHelper.IsGenericParameter(ExpressionType) = False AndAlso CecilHelper.IsClass(Expression.ExpressionType) AndAlso CecilHelper.IsValueType(ExpressionType) Then
                 result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                 Emitter.EmitUnbox(Info, ExpressionType)
                 Emitter.EmitLoadObject(Info, ExpressionType)
             ElseIf CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
                 result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                 If Helper.CompareType(Expression.ExpressionType, ExpressionType) = False Then
                     Emitter.EmitBox(Info, Expression.ExpressionType)
                     Emitter.EmitCastClass(Info, Expression.ExpressionType, ExpressionType)
                 End If
             Else
                 result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                 If Helper.CompareType(Expression.ExpressionType, ExpressionType) = False Then
                     Emitter.EmitCastClass(Info, Expression.ExpressionType, ExpressionType)
                 End If
             End If
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\DirectCastExpression.vb" startline="71" endline="75"><![CDATA[
 
     Protected Overrides ReadOnly Property GetKeyword() As KS
         Get
             Return KS.DirectCast
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent, True)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="26" endline="29"><![CDATA[
 
     Shadows Sub Init(ByVal Expression As Expression, ByVal DestinationType As TypeName)
         MyBase.Init(Expression, DestinationType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="30" endline="43"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Expression.GenerateCode(Info.Clone(Me, ExpressionType)) AndAlso result
 
         If CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
             Emitter.EmitBox(Info, Expression.ExpressionType)
         End If
 
         Emitter.EmitIsInst(Info, Expression.ExpressionType, ExpressionType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="44" endline="48"><![CDATA[
 
     Protected Overrides ReadOnly Property GetKeyword() As KS
         Get
             Return KS.TryCast
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="44" endline="54"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = m_NonArrayTypeName.ResolvedType
         End If
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="55" endline="58"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="59" endline="66"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal DelegateType As Mono.Cecil.TypeReference, ByVal AddressOfExpression As AddressOfExpression)
         MyBase.New(Parent)
 
         m_IsDelegateCreationExpression = True
         m_ResolvedType = DelegateType
         m_ArgumentList = New ArgumentList(Me, AddressOfExpression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="67" endline="71"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal TypeName As NonArrayTypeName, ByVal ArgumentList As ArgumentList)
         MyBase.new(Parent)
         Me.Init(TypeName, ArgumentList)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="72" endline="76"><![CDATA[
 
     Sub Init(ByVal TypeName As NonArrayTypeName, ByVal ArgumentList As ArgumentList)
         m_NonArrayTypeName = TypeName
         m_ArgumentList = ArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="77" endline="81"><![CDATA[
 
     Sub Init(ByVal Type As Mono.Cecil.TypeReference, ByVal ArgumentList As ArgumentList)
         m_ResolvedType = Type
         m_ArgumentList = ArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="82" endline="86"><![CDATA[
 
     ReadOnly Property NonArrayTypeName() As NonArrayTypeName
         Get
             Return m_NonArrayTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="87" endline="92"><![CDATA[
     End Property
 
     ReadOnly Property IsDelegateCreationExpression() As Boolean
         Get
             Return m_IsDelegateCreationExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="93" endline="126"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsDelegateCreationExpression Then
             result = m_ArgumentList(0).Expression.Classification.AsMethodPointerClassification.GenerateCode(Info) AndAlso result
         ElseIf m_IsValueTypeInitializer Then
             If CecilHelper.IsByRef(Info.DesiredType) Then
                 Dim type As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, m_ResolvedType)
                 Emitter.EmitInitObj(Info, type)
             Else
                 Dim type As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, m_ResolvedType)
                 Dim local As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, type)
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitInitObj(Info, type)
                 Emitter.EmitLoadVariable(Info, local)
             End If
         ElseIf m_IsGenericConstructor Then
             Dim method As Mono.Cecil.MethodReference
             Dim args As Mono.Cecil.TypeReference() = New Mono.Cecil.TypeReference() {Helper.GetTypeOrTypeBuilder(Compiler, ExpressionType)}
             method = CecilHelper.MakeGenericMethod(Compiler.TypeCache.System_Activator__CreateInstance, args)
             Emitter.EmitCall(Info, method)
         Else
             Dim ctor As Mono.Cecil.MethodReference
             ctor = m_MethodClassification.ResolvedConstructor
 
             result = m_ArgumentList.GenerateCode(Info, ctor.Parameters) AndAlso result
 
             Emitter.EmitNew(Info, ctor)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="127" endline="131"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Classification.AsValueClassification.Type
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="132" endline="223"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then result = m_NonArrayTypeName.ResolveCode(Info) AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveCode(Info) AndAlso result
 
         Helper.Assert(m_ResolvedType IsNot Nothing)
         If m_IsDelegateCreationExpression = False Then
             If TypeOf m_ResolvedType Is Mono.Cecil.GenericParameter = False Then
                 m_IsDelegateCreationExpression = Helper.CompareType(CecilHelper.FindDefinition(m_ResolvedType).BaseType, Compiler.TypeCache.System_MulticastDelegate)
             End If
         End If
 
         If m_ArgumentList IsNot Nothing Then
             result = m_ArgumentList.ResolveCode(Info) AndAlso result
         Else
             m_ArgumentList = New ArgumentList(Me)
         End If
 
         If result = False Then Return result
 
         If m_IsDelegateCreationExpression Then
             Dim type As Mono.Cecil.TypeReference = m_ResolvedType
             If m_ArgumentList.Count <> 1 Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC32008, Me.Location, type.FullName) AndAlso result
             End If
             If result AndAlso m_ArgumentList(0).Expression.Classification.IsMethodPointerClassification = False Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC32008, Me.Location, type.FullName) AndAlso result
             End If
             If result Then
                 result = m_ArgumentList(0).Expression.ResolveAddressOfExpression(type) AndAlso result
                 Classification = New ValueClassification(Me, type)
             End If
         Else
             Dim resolvedType As Mono.Cecil.TypeReference = m_ResolvedType
             Dim isCoClass As Boolean = False
 
             If CecilHelper.IsInterface(resolvedType) Then
                 Dim coClass As TypeReference = Helper.GetCoClassType(Compiler, resolvedType)
                 If coClass Is Nothing Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30375, Me.Location)
                 Else
                     m_ResolvedType = coClass
                     resolvedType = m_ResolvedType
 
                     If CecilHelper.IsValueType(resolvedType) = False AndAlso CecilHelper.IsClass(resolvedType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC31094, Me.Location, resolvedType.Name)
                     End If
 
                     Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference)
                     ctors = CecilHelper.GetConstructors(resolvedType)
                     If ctors Is Nothing OrElse ctors.Count = 0 Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30251, Me.Location, resolvedType.Name)
                     End If
                     isCoClass = True
                 End If
             End If
 
             If isCoClass = False AndAlso CecilHelper.IsValueType(resolvedType) AndAlso m_ArgumentList.Count = 0 Then
                 'Nothing to resolve. A structure with no parameters can always be created.
                 m_IsValueTypeInitializer = True
             ElseIf CecilHelper.IsGenericParameter(resolvedType) Then
                 If m_ArgumentList.Count > 0 Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC32085, Me.Location)
                 End If
                 If (CecilHelper.GetGenericParameterAttributes(resolvedType) And Mono.Cecil.GenericParameterAttributes.DefaultConstructorConstraint) = 0 AndAlso (CecilHelper.GetGenericParameterAttributes(resolvedType) And Mono.Cecil.GenericParameterAttributes.NotNullableValueTypeConstraint) = 0 Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC32046, Me.Location)
                 End If
                 m_IsGenericConstructor = True
             ElseIf CecilHelper.IsClass(resolvedType) OrElse CecilHelper.IsValueType(resolvedType) Then
                 Dim ctors As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference)
 
                 ctors = CecilHelper.GetConstructors(resolvedType)
                 m_MethodClassification = New MethodGroupClassification(Me, Nothing, Nothing, Nothing, ctors)
                 result = m_MethodClassification.AsMethodGroupClassification.ResolveGroup(m_ArgumentList) AndAlso result
                 If result = False Then
                     'Show the error
                     result = m_MethodClassification.AsMethodGroupClassification.ResolveGroup(m_ArgumentList, True) AndAlso result
                 Else
                     result = m_ArgumentList.ReplaceAndVerifyArguments(m_MethodClassification.FinalArguments, m_MethodClassification.ResolvedMethod) AndAlso result
                 End If
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, String.Format("Delegate type {0} is neither ValueType, GenericParameter nor Class. This is a problem in the compiler, please file a bug report here
             End If
 
             Classification = New ValueClassification(Me, resolvedType)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="32" endline="45"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.new(Parent)
 
         Dim refType As ByReferenceType = TryCast(Expression.ExpressionType, ByReferenceType)
 
         If refType Is Nothing Then Throw New InternalException
 
         m_Expression = Expression
         m_ExpressionType = refType.ElementType
 
         Classification = New VariableClassification(Me, Expression, m_ExpressionType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then Helper.ErrorRecoveryNotImplemented(Me.Location)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="46" endline="50"><![CDATA[
 
     ReadOnly Property Expression() As Expression
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="51" endline="61"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
 
         Emitter.EmitLoadIndirect(Info, m_Expression.ExpressionType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="62" endline="67"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="68" endline="72"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="38" endline="40"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="41" endline="49"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_FirstPart IsNot Nothing Then result = m_FirstPart.ResolveTypeReferences AndAlso result
         If m_SecondPart IsNot Nothing Then result = m_SecondPart.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="50" endline="54"><![CDATA[
 
     Sub Init(ByVal FirstPart As Expression, ByVal SecondPart As IdentifierOrKeyword)
         m_FirstPart = FirstPart
         m_SecondPart = SecondPart
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="55" endline="60"><![CDATA[
     
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             If m_IsLateBound Then Return Compiler.TypeCache.System_Object
             Return m_DefaultProperty.PropertyType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="61" endline="94"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsLateBound Then
             Dim ie As Expression
             Dim lbaC As LateBoundAccessClassification
             If m_FirstPart Is Nothing Then
                 ie = New LoadLocalExpression(Me, m_WithStatement.WithVariable)
             Else
                 ie = m_FirstPart
             End If
             lbaC = New LateBoundAccessClassification(Me, ie, Nothing, Nothing)
             lbaC.Arguments = New ArgumentList(Me, New ConstantExpression(Me, m_SecondPart.Identifier, Compiler.TypeCache.System_String))
             result = LateBoundAccessToExpression.EmitLateIndexGet(Info, lbaC) AndAlso result
         Else
             If m_FirstPart IsNot Nothing Then
                 result = m_FirstPart.GenerateCode(Info) AndAlso result
             Else
                 Emitter.EmitLoadVariable(Info, m_WithStatement.WithVariable)
             End If
             Emitter.EmitLoadValue(Info, m_SecondPart.Identifier)
             If Info.IsRHS Then
                 Emitter.EmitCallOrCallVirt(Info, CecilHelper.FindDefinition(m_DefaultProperty).GetMethod)
             ElseIf Info.IsLHS Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="95" endline="134"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim firsttp As Mono.Cecil.TypeReference
         If m_FirstPart IsNot Nothing Then
             result = m_FirstPart.ResolveExpression(Info) AndAlso result
             firsttp = m_FirstPart.ExpressionType
         Else
             m_WithStatement = Me.FindFirstParent(Of WithStatement)()
             firsttp = m_WithStatement.WithVariableExpression.ExpressionType
         End If
 
         If Helper.CompareType(Compiler.TypeCache.System_Object, firsttp) Then
             If Location.File(Compiler).IsOptionStrictOn Then
                 Helper.AddError(Me)
                 Return False
             End If
             m_IsLateBound = True
             Classification = New ValueClassification(Me, Compiler.TypeCache.System_Object)
             Return True
         End If
         Dim attr As Mono.Cecil.CustomAttribute = Helper.GetDefaultMemberAttribute(Compiler, firsttp)
         If attr IsNot Nothing Then
             Dim name As String = DirectCast(attr.ConstructorArguments(0).Value, String)
             Dim props As Mono.Collections.Generic.Collection(Of PropertyDefinition) = CecilHelper.FindProperties(CecilHelper.FindDefinition(firsttp).Properties, name)
             If props IsNot Nothing AndAlso props.Count = 1 Then
                 m_DefaultProperty = props(0)
             End If
             If m_DefaultProperty IsNot Nothing Then
                 Classification = New ValueClassification(Me, m_DefaultProperty.PropertyType)
             Else
                 result = Helper.AddError(Me) AndAlso result
             End If
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="135" endline="138"><![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.Exclamation)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="139" endline="142"><![CDATA[
 
     Shared Function IsUnaryMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.Exclamation)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="143" endline="146"><![CDATA[
 
     Shared Function CreateAndParseTo(ByRef result As Expression) As Boolean
         Return result.Compiler.Report.ShowMessage(Messages.VBNC99997, result.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="26" endline="30"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal First As Expression, ByVal Second As Expression)
         MyBase.New(Parent)
         m_First = First
         m_Second = Second
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="31" endline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="89" endline="96"><![CDATA[
     Function FindFirstParentOfCodeBlock(Of T)() As T
         Dim cb As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         If cb IsNot Nothing Then
             Return cb.FindFirstParent(Of T)()
         Else
             Return Nothing
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="97" endline="117"><![CDATA[
 
     ''' <summary>
     ''' Get the parent code block. Might be nothing!
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindParentCodeBlock() As CodeBlock
         If TypeOf Parent Is CodeBlock Then
             Return DirectCast(Parent, CodeBlock)
         Else
             If TypeOf Parent Is Expression Then
                 Return DirectCast(Parent, Expression).FindParentCodeBlock
             ElseIf TypeOf Parent Is BlockStatement Then
                 Return DirectCast(Parent, BlockStatement).CodeBlock
             ElseIf TypeOf Parent Is Statement Then
                 Return DirectCast(Parent, Statement).FindParentCodeBlock
             Else
                 Return Nothing
             End If
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="118" endline="126"><![CDATA[
 
     ''' <summary>
     ''' The classification of this expression
     ''' </summary>
     ''' <remarks></remarks>
     Property Classification() As ExpressionClassification
         Get
             Return m_Classification
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="127" endline="129"><![CDATA[
         Set(ByVal value As ExpressionClassification)
             m_Classification = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="130" endline="141"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The type of the expression.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="142" endline="146"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="147" endline="156"><![CDATA[
 
     ''' <summary>
     ''' The default implementation returns false.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Return False 'm_Classification.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="157" endline="168"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The default implementation throws an internal exception.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Overridable ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(m_Classification IsNot Nothing)
             Return m_Classification.ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="169" endline="194"><![CDATA[
     End Property
 
     Friend NotOverridable Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Try
             If Me.IsConstant Then
                 If Helper.CompareType(Me.ExpressionType, Compiler.TypeCache.Nothing) Then
                     Emitter.EmitLoadValue(Info, Me.ConstantValue)
                 ElseIf Info.DesiredType IsNot Nothing AndAlso CecilHelper.IsByRef(Info.DesiredType) Then
                     Emitter.EmitLoadValueAddress(Info, Me.ConstantValue)
                 Else
                     Emitter.EmitLoadValue(Info.Clone(Me, Me.ExpressionType), Me.ConstantValue)
                 End If
             ElseIf TypeOf Me.Classification Is MethodGroupClassification Then
                 result = Me.Classification.AsMethodGroupClassification.GenerateCode(Info) AndAlso result
             Else
                 result = GenerateCodeInternal(Info) AndAlso result
             End If
         Catch ex As Exception
             Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Internal compiler error close to this location")
             Throw
         End Try
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="195" endline="198"><![CDATA[
 
     Protected Overridable Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="199" endline="233"><![CDATA[
 
 #Region "Resolution region"
     ''' <summary>
     ''' Has this expression been resolved?
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Resolved As Boolean
 
     ''' <summary>
     ''' Is this expression beeing resolved (in Resolve / DoResolve)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Resolving As Boolean
 
     Function ResolveExpression(ByVal ResolveInfo As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(ResolveInfo IsNot Nothing)
 
         StartResolve()
 
         Try
             result = ResolveExpressionInternal(ResolveInfo) AndAlso result
         Catch ex As Exception
             Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Internal compiler error close to this location")
             Throw
         End Try
 #If EXTENDEDDEBUG Then
         Helper.Assert(result = False OrElse m_Classification IsNot Nothing, "Classification is nothing! (type of expression = " & Me.GetType.ToString & ")")
         Helper.Assert(ResolveInfo.CanFail OrElse result = (Compiler.Report.Errors = 0))
 #End If
 
         EndResolve(result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="234" endline="237"><![CDATA[
 
     <Obsolete()> Function ResolveExpression() As Boolean
         Return ResolveExpression(ResolveInfo.Default(Parent.Compiler))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="238" endline="261"><![CDATA[
 
     ''' <summary>
     ''' Call StartResolve to enable check for recursive resolving.
     ''' Call EndResolve when finished resolving.
     ''' </summary>
     ''' <remarks></remarks>
     Protected Sub StartResolve()
         If m_Resolving Then
             'Recursive resolution.
             'TODO
             Throw New InternalException(Me)
         End If
         m_Resolving = True
 #If EXTENDEDDEBUG Then
         If Me.TypeReferencesResolved = False Then
             Compiler.Report.WriteLine("TypeReferences not resolved for expression  " & Me.ToString)
         End If
 #End If
 #If EXTENDEDDEBUG Then
         If m_Resolved Then
             Compiler.Report.WriteLine("Resolving expression " & Me.ToString & " more than once (Location
         End If
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="262" endline="271"><![CDATA[
 
     ''' <summary>
     ''' Is this expression beeing resolved (in Resolve)?
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsResolving() As Boolean
         Get
             Return m_Resolving
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="272" endline="282"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Is this constant resolved?
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Property IsResolved() As Boolean
         Get
             Return m_Resolved
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="283" endline="285"><![CDATA[
         Set(ByVal value As Boolean)
             m_Resolved = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="286" endline="297"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Call StartResolve to enable check for recursive resolving.
     ''' Call EndResolve when finished resolving.
     ''' </summary>
     ''' <remarks></remarks>
     Protected Sub EndResolve(ByVal result As Boolean)
         If Not m_Resolving Then Throw New InternalException(Me)
         m_Resolving = False
         m_Resolved = result
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="298" endline="301"><![CDATA[
 
     <Obsolete("Call ResolveExpression"), ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Never)> Public NotOverridable Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return ResolveExpression(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="302" endline="306"><![CDATA[
 
     Overridable Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="307" endline="310"><![CDATA[
 
     Protected Overridable Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="311" endline="323"><![CDATA[
 
     Function ResolveAddressOfExpression(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim aoe As AddressOfExpression = TryCast(Me, AddressOfExpression)
 
         If aoe Is Nothing Then
             result = False
         Else
             result = aoe.Resolve(DelegateType) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="324" endline="347"><![CDATA[
 
     Function GetObjectReference() As Expression
         Dim result As Expression
         If TypeOf Me Is GetRefExpression Then
             Return Me
         ElseIf TypeOf Me Is InstanceExpression Then
             Return Me
         ElseIf CecilHelper.IsValueType(ExpressionType) Then
             If TypeOf Me Is DeRefExpression Then
                 Dim derefExp As DeRefExpression = DirectCast(Me, DeRefExpression)
                 result = derefExp.Expression
             ElseIf Helper.CompareType(CecilHelper.FindDefinition(Me.ExpressionType).BaseType, Compiler.TypeCache.System_Enum) Then
                 result = New BoxExpression(Me, Me, CecilHelper.MakeByRefType(Me.ExpressionType))
                 'ElseIf Me.ExpressionType.IsValueType AndAlso Helper.IsNullableType(Compiler, Me.ExpressionType) = False Then
                 '    result = New BoxExpression(Me, Me, Me.ExpressionType)
             Else
                 result = New GetRefExpression(Me, Me)
             End If
         Else
             result = Me
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="348" endline="359"><![CDATA[
 
     Function DereferenceByRef() As Expression
         Dim result As Expression
 
         If CecilHelper.IsByRef(ExpressionType) Then
             result = New DeRefExpression(Me, Me)
         Else
             result = Me
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="360" endline="408"><![CDATA[
 
     ''' <summary>
     ''' The resulting expression is NOT resolved.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ReclassifyToPropertyAccessExpression() As Expression
         Dim result As Expression
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.PropertyGroup
                 Dim pgClass As PropertyGroupClassification = Me.Classification.AsPropertyGroup
                 result = New PropertyGroupToPropertyAccessExpression(Me, pgClass)
             Case ExpressionClassification.Classifications.Value
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Variable
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.EventAccess
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.LateBoundAccess
                 Return New LateBoundAccessToPropertyAccessExpression(Me, Me.Classification.AsLateBoundAccess)
             Case ExpressionClassification.Classifications.MethodGroup
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.MethodPointer
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.PropertyAccess
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Void
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Type
                 Dim exp As Expression = Nothing
                 If m_Classification.AsTypeClassification.CreateAliasExpression(Me, exp) = False Then
                     Throw New InternalException(Me)
                 End If
                 If exp.Classification.IsPropertyGroupClassification Then
                     exp = exp.ReclassifyToPropertyAccessExpression
                     If exp.ResolveExpression(ResolveInfo.Default(Compiler)) = False Then
                         Throw New InternalException(Me)
                     End If
                 End If
                 Helper.Assert(exp.Classification.IsPropertyAccessClassification)
                 Return exp
             Case ExpressionClassification.Classifications.Namespace
                 Throw New InternalException(Me)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="409" endline="419"><![CDATA[
 
     Function ReclassifyMethodPointerToValueExpression(ByVal DelegateType As Mono.Cecil.TypeReference) As Expression
         Dim result As Expression = Nothing
 
         Helper.Assert(Classification.IsMethodPointerClassification)
         Helper.Assert(TypeOf Me Is AddressOfExpression)
 
         result = New DelegateOrObjectCreationExpression(Me, DelegateType, DirectCast(Me, AddressOfExpression))
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="420" endline="462"><![CDATA[
 
     ''' <summary>
     ''' Reclassifies an expression.
     ''' The resulting expression is NOT resolved.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ReclassifyToValueExpression() As Expression
         Dim result As Expression = Nothing
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.Value
                 Return Me 'This expression is already a value expression.
             Case ExpressionClassification.Classifications.Variable
                 result = New VariableToValueExpression(Me, Me.Classification.AsVariableClassification)
             Case ExpressionClassification.Classifications.MethodGroup
                 result = New MethodGroupToValueExpression(Me, Me.Classification.AsMethodGroupClassification)
             Case ExpressionClassification.Classifications.PropertyAccess
                 result = New PropertyAccessToValueExpression(Me, Me.Classification.AsPropertyAccess)
             Case ExpressionClassification.Classifications.PropertyGroup
                 result = New PropertyGroupToValueExpression(Me, Me.Classification.AsPropertyGroup)
             Case ExpressionClassification.Classifications.LateBoundAccess
                 result = New LateBoundAccessToValueExpression(Me, Me.Classification.AsLateBoundAccess)
             Case ExpressionClassification.Classifications.MethodPointer
                 Throw New InternalException(Me, "Use the other overload.")
             Case ExpressionClassification.Classifications.EventAccess
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Void
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Type
                 Dim exp As Expression = Nothing
                 If m_Classification.AsTypeClassification.CreateAliasExpression(Me, exp) = False Then
                     Throw New InternalException(Me)
                 End If
                 Return exp
             Case ExpressionClassification.Classifications.Namespace
                 Throw New InternalException(Me)
             Case Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 Return Nothing
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="463" endline="480"><![CDATA[
 
     Function ReportReclassifyToValueErrorMessage() As Boolean
 
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.EventAccess
                 Compiler.Report.ShowMessage(Messages.VBNC32022, Me.Location)
             Case ExpressionClassification.Classifications.Type
                 Compiler.Report.ShowMessage(Messages.VBNC30108, Me.Location)
             Case ExpressionClassification.Classifications.Namespace
                 Compiler.Report.ShowMessage(Messages.VBNC30112, Me.Location)
             Case ExpressionClassification.Classifications.Void
                 Compiler.Report.ShowMessage(Messages.VBNC30491, Me.Location)
             Case Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="481" endline="487"><![CDATA[
 
 #End Region
 
     Overridable ReadOnly Property AsString() As String
         Get
             Return "<String representation of " & Me.GetType.FullName & " not implemented>"
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetRefExpression.vb" startline="31" endline="33"><![CDATA[
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetRefExpression.vb" startline="34" endline="51"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Automatically resolved.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Expression"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.new(Parent)
         m_Expression = Expression
         m_ExpressionType = Parent.Compiler.TypeManager.MakeByRefType(Parent, Expression.ExpressionType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Throw New InternalException(Me)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetRefExpression.vb" startline="52" endline="59"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetRefExpression.vb" startline="60" endline="164"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim refInfo As EmitInfo = Info.Clone(Me, Me.ExpressionType)
 
         Select Case m_Expression.Classification.Classification
             Case ExpressionClassification.Classifications.Variable
                 Dim varC As VariableClassification = m_Expression.Classification.AsVariableClassification
 
                 If varC.InstanceExpression IsNot Nothing Then
                     Dim desiredType As Mono.Cecil.TypeReference
                     desiredType = varC.InstanceExpression.ExpressionType
                     If CecilHelper.IsValueType(desiredType) AndAlso CecilHelper.IsByRef(desiredType) = False Then
                         desiredType = CecilHelper.MakeByRefType(desiredType)
                     End If
                     result = varC.InstanceExpression.GenerateCode(Info.Clone(Me, desiredType)) AndAlso result
                     'result = varC.InstanceExpression.GenerateCode(refInfo) AndAlso result
                 End If
 
                 If varC.LocalBuilder IsNot Nothing Then
                     Emitter.EmitLoadVariableLocation(refInfo, varC.LocalBuilder)
                 ElseIf varC.ParameterInfo IsNot Nothing Then
                     Emitter.EmitLoadVariableLocation(refInfo, varC.ParameterInfo)
                 ElseIf varC.FieldInfo IsNot Nothing Then
                     If varC.FieldDefinition.IsLiteral Then
                         Dim local As Mono.Cecil.Cil.VariableDefinition
                         local = Emitter.DeclareLocal(Info, varC.FieldInfo.FieldType)
                         Emitter.EmitLoadVariable(Info, varC.FieldInfo)
                         Emitter.EmitStoreVariable(Info, local)
                         Emitter.EmitLoadVariableLocation(refInfo, local)
                     Else
                         Emitter.EmitLoadVariableLocation(refInfo, varC.FieldInfo)
                     End If
                 ElseIf varC.ArrayVariable IsNot Nothing Then
                     Dim arrtype As Mono.Cecil.TypeReference = varC.ArrayVariable.ExpressionType
                     Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrtype)
                     Dim isnonprimitivevaluetype As Boolean = CecilHelper.IsPrimitive(Compiler, elementtype) = False AndAlso CecilHelper.IsValueType(elementtype)
 
                     result = varC.ArrayVariable.GenerateCode(Info.Clone(Me, True, False, arrtype)) AndAlso result
 
                     Dim methodtypes As New Generic.List(Of Mono.Cecil.TypeReference)
 
                     Dim elementInfo As EmitInfo = Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)
                     For i As Integer = 0 To varC.Arguments.Count - 1
                         result = varC.Arguments(i).GenerateCode(elementInfo) AndAlso result
                         Emitter.EmitConversion(varC.Arguments(i).Expression.ExpressionType, Compiler.TypeCache.System_Int32, Info)
                         methodtypes.Add(Compiler.TypeCache.System_Int32)
                     Next
 
                     Dim rInfo As EmitInfo = Info.Clone(Me, True, False, elementtype)
                     methodtypes.Add(elementtype)
 
                     If CecilHelper.GetArrayRank(arrtype) = 1 Then
                         If isnonprimitivevaluetype Then
                             Emitter.EmitLoadElementAddress(Info, elementtype, arrtype)
                             'result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                             'Emitter.EmitStoreObject(Info, elementtype)
                         Else
                             Emitter.EmitLoadElementAddress(Info, elementtype, arrtype)
                             'result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                             'Emitter.EmitStoreElement(Info, elementtype, arrtype)
                         End If
                     Else
                         Dim method As Mono.Cecil.MethodReference = ArrayElementInitializer.GetAddressMethod(Compiler, arrtype)
                         Emitter.EmitCallVirt(Info, method)
                     End If
                 ElseIf varC.Expression IsNot Nothing Then
                     If TypeOf varC.Expression Is MeExpression Then
                         Dim local As Mono.Cecil.Cil.VariableDefinition
                         local = Emitter.DeclareLocal(Info, varC.Expression.ExpressionType)
                         Emitter.EmitLoadMe(Info, varC.Expression.ExpressionType)
                         Emitter.EmitStoreVariable(Info, local)
                         Emitter.EmitLoadVariableLocation(refInfo, local)
                     ElseIf TypeOf varC.Expression Is GetRefExpression AndAlso varC.Expression IsNot Me Then
                         result = varC.Expression.GenerateCode(Info) AndAlso result
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                     End If
                 ElseIf varC.Method IsNot Nothing Then
                     If varC.Method.DefaultReturnVariable Is Nothing Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                     Else
                         Emitter.EmitLoadVariableLocation(refInfo, varC.Method.DefaultReturnVariable)
                     End If
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                 End If
             Case ExpressionClassification.Classifications.Value
                 result = m_Expression.GenerateCode(Info.Clone(Me, m_Expression.ExpressionType)) AndAlso result
 
                 Dim local As Mono.Cecil.Cil.VariableDefinition
                 local = Emitter.DeclareLocal(Info, m_Expression.ExpressionType)
                 Emitter.EmitStoreVariable(Info, local)
                 Emitter.EmitLoadVariableLocation(Info, local)
             Case ExpressionClassification.Classifications.PropertyAccess
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Case ExpressionClassification.Classifications.MethodPointer
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetRefExpression.vb" startline="165" endline="169"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="29" endline="31"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_TypeName.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="32" endline="35"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="36" endline="39"><![CDATA[
 
     Sub Init(ByVal TypeName As GetTypeTypeName)
         m_TypeName = TypeName
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="40" endline="48"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadToken(Info, m_TypeName.ResolvedType)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="49" endline="57"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="58" endline="62"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_TypeName.ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="63" endline="70"><![CDATA[
     End Property
 
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Dim attrib As Attribute = Me.FindFirstParent(Of Attribute)()
             Return attrib IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="71" endline="76"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Type
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GlobalExpression.vb" startline="25" endline="27"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GlobalExpression.vb" startline="28" endline="31"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GlobalExpression.vb" startline="32" endline="35"><![CDATA[
 
     Shadows Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As GlobalExpression
         Return New GlobalExpression(NewParent)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GlobalExpression.vb" startline="36" endline="42"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
 
         Classification = New NamespaceClassification(Me, New GlobalNamespace(Me))
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GlobalExpression.vb" startline="43" endline="47"><![CDATA[
 
     Public Overrides ReadOnly Property AsString() As String
         Get
             Return "Global"
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="34" endline="36"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="37" endline="45"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If ThirdPart Is Nothing AndAlso TypeOf Condition Is NothingConstantExpression AndAlso TypeOf SecondPart Is NothingConstantExpression Then Return True
             If Not Condition.IsConstant Then Return False
             If Not SecondPart.IsConstant Then Return False
             If ThirdPart IsNot Nothing AndAlso Not ThirdPart.IsConstant Then Return False
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="46" endline="137"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Condition.ResolveExpression(Info) AndAlso result
         result = SecondPart.ResolveExpression(Info) AndAlso result
 
         If ThirdPart IsNot Nothing Then
             result = ThirdPart.ResolveExpression(Info) AndAlso result
         End If
 
         If Not result Then Return result
 
         If ThirdPart IsNot Nothing Then
             If Compiler.TypeResolution.IsImplicitlyConvertible(Me, Condition.ExpressionType, Compiler.TypeCache.System_Boolean) = False AndAlso Location.File(Compiler).IsOptionStrictOn Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30512, Condition.Location, Condition.ExpressionType.Name, Compiler.TypeCache.System_Boolean.Name) AndAlso result
             Else
                 Condition = Helper.CreateTypeConversion(Me, Condition, Compiler.TypeCache.System_Boolean, result)
             End If
 
             If Helper.CompareType(SecondPart.ExpressionType, ThirdPart.ExpressionType) = False Then
                 If Compiler.TypeResolution.IsImplicitlyConvertible(Me, SecondPart.ExpressionType, ThirdPart.ExpressionType) Then
                     m_ExpressionType = ThirdPart.ExpressionType
                     SecondPart = Helper.CreateTypeConversion(Me, SecondPart, m_ExpressionType, result)
                 ElseIf Compiler.TypeResolution.IsImplicitlyConvertible(Me, ThirdPart.ExpressionType, SecondPart.ExpressionType) Then
                     m_ExpressionType = SecondPart.ExpressionType
                     ThirdPart = Helper.CreateTypeConversion(Me, ThirdPart, m_ExpressionType, result)
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC33106, Me.Location) AndAlso result
                 End If
             Else
                 m_ExpressionType = SecondPart.ExpressionType
             End If
 
             If Condition.IsConstant AndAlso SecondPart.IsConstant AndAlso ThirdPart.IsConstant Then
                 m_ConstantValue = If(CBool(Condition.ConstantValue), SecondPart.ConstantValue, ThirdPart.ConstantValue)
                 'We checked that the conversion is possible above
                 result = TypeConverter.ConvertTo(Me, m_ConstantValue, m_ExpressionType, m_ConstantValue) AndAlso result
             End If
         Else
             If Condition.ExpressionType.IsValueType AndAlso CecilHelper.IsNullable(Condition.ExpressionType) = False Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC33107, Condition.Location) AndAlso result
             End If
 
             If TypeOf SecondPart Is NothingConstantExpression Then
                 If TypeOf Condition Is NothingConstantExpression Then
                     m_ConstantValue = Nothing
                     m_ExpressionType = Compiler.TypeCache.System_Object
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30512, Condition.Location, Condition.ExpressionType.Name, "Integer")
                 End If
             ElseIf TypeOf Condition Is NothingConstantExpression Then
                 If Helper.CompareType(SecondPart.ExpressionType, Compiler.TypeCache.System_Int32) Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC33110, Me.Location)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30512, Condition.Location, SecondPart.ExpressionType.Name, "Integer")
                 End If
             Else
                 If Helper.CompareType(SecondPart.ExpressionType, Condition.ExpressionType) = False Then
                     Dim condType As TypeReference = Condition.ExpressionType
 
                     If CecilHelper.IsNullable(Condition.ExpressionType) AndAlso Not CecilHelper.IsNullable(SecondPart.ExpressionType) Then
                         condType = CecilHelper.GetNulledType(condType)
                     End If
 
                     If Compiler.TypeResolution.IsImplicitlyConvertible(Me, SecondPart.ExpressionType, condType) Then
                         m_ExpressionType = condType
                         SecondPart = Helper.CreateTypeConversion(Me, SecondPart, m_ExpressionType, result)
                     ElseIf Compiler.TypeResolution.IsImplicitlyConvertible(Me, condType, SecondPart.ExpressionType) Then
                         m_ExpressionType = SecondPart.ExpressionType
                     Else
                         result = Compiler.Report.ShowMessage(Messages.VBNC33110, Me.Location) AndAlso result
                     End If
                 Else
                     m_ExpressionType = SecondPart.ExpressionType
                 End If
 
                 If Condition.IsConstant AndAlso SecondPart.IsConstant Then
                     m_ConstantValue = If(Condition.ConstantValue, SecondPart.ConstantValue)
                     'We checked that the conversion is possible above
                     result = TypeConverter.ConvertTo(Me, m_ConstantValue, m_ExpressionType, m_ConstantValue) AndAlso result
                 End If
             End If
         End If
 
         If result Then
             Me.Classification = New ValueClassification(Me, Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="138" endline="230"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim falseLabel As Label = Emitter.DefineLabel(Info)
         Dim endLabel As Label = Emitter.DefineLabel(Info)
         Dim local As Mono.Cecil.Cil.VariableDefinition
         Dim vose As ValueOnStackExpression
         Dim type_conversion As Expression
         Dim nullable_type As GenericInstanceType = Nothing
         Dim has_value As MethodReference
         Dim get_value As MethodReference
         
         If ThirdPart IsNot Nothing Then
             result = Condition.GenerateCode(Info) AndAlso result
             Emitter.EmitBranchIfFalse(Info, falseLabel)
             result = SecondPart.GenerateCode(Info) AndAlso result
             Emitter.EmitBranch(Info, endLabel)
             Emitter.MarkLabel(Info, falseLabel)
             result = ThirdPart.GenerateCode(Info) AndAlso result
         Else
             'Emit condition, and store the result in a local variable
             local = Emitter.DeclareLocal(Info, Condition.ExpressionType)
             result = Condition.GenerateCode(Info) AndAlso result
             Emitter.EmitStoreVariable(Info, local)
 
             'If the first operand (condition) is nullable and the second is not, the result is the dominant type 
             'between the nulled type of the first operand and the type of the second operand.
             'This means that for this case
             ' - True condition
             ' - False condition
             'For the normal case
             ' - Both conditions
 
             'conditions
             If CecilHelper.IsNullable(Condition.ExpressionType) Then
                 nullable_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(Condition.ExpressionType)))
 
                 'Call Nullable`1.HasValue to check the condition
                 has_value = New MethodReference("get_HasValue", Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Boolean))
                 has_value.DeclaringType = nullable_type
                 has_value.HasThis = True
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitCall(Info, has_value)
                 Emitter.EmitBranchIfFalse(Info, falseLabel)
             Else
                 Emitter.EmitLoadVariable(Info, local)
                 Emitter.EmitBranchIfFalse(Info, falseLabel)
             End If
 
             'true branch
             If CecilHelper.IsNullable(Condition.ExpressionType) AndAlso CecilHelper.IsNullable(m_ExpressionType) = False Then
                 'denullify
                 get_value = New MethodReference("GetValueOrDefault", Compiler.TypeCache.System_Nullable1.GenericParameters(0))
                 get_value.DeclaringType = nullable_type
                 get_value.HasThis = True
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitCall(Info, get_value)
                 'convert to proper type
                 vose = New ValueOnStackExpression(Me, CecilHelper.GetNulledType(Condition.ExpressionType))
             Else
                 Emitter.EmitLoadVariable(Info, local)
                 vose = New ValueOnStackExpression(Me, Condition.ExpressionType)
             End If
             type_conversion = Helper.CreateTypeConversion(Me, vose, m_ExpressionType, result)
             result = type_conversion.GenerateCode(Info) AndAlso result
             Emitter.EmitBranch(Info, endLabel)
 
             'false branch
             Emitter.MarkLabel(Info, falseLabel)
             result = SecondPart.GenerateCode(Info) AndAlso result
             If CecilHelper.IsNullable(SecondPart.ExpressionType) AndAlso CecilHelper.IsNullable(m_ExpressionType) = False Then
                 nullable_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(SecondPart.ExpressionType)))
 
                 'denullify
                 get_value = New MethodReference("GetValueOrDefault", Compiler.TypeCache.System_Nullable1.GenericParameters(0))
                 get_value.DeclaringType = nullable_type
                 get_value.HasThis = True
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitCall(Info, get_value)
                 'convert to proper type
                 vose = New ValueOnStackExpression(Me, CecilHelper.GetNulledType(SecondPart.ExpressionType))
             Else
                 vose = New ValueOnStackExpression(Me, SecondPart.ExpressionType)
             End If
             type_conversion = Helper.CreateTypeConversion(Me, vose, m_ExpressionType, result)
             result = type_conversion.GenerateCode(Info) AndAlso result
         End If
         Emitter.MarkLabel(Info, endLabel)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="231" endline="235"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="236" endline="241"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="31" endline="33"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="34" endline="37"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.Me, KS.MyBase, KS.MyClass)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="38" endline="43"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_ExpressionType IsNot Nothing)
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="44" endline="56"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim tp As TypeDeclaration
         tp = Me.FindFirstParent(Of TypeDeclaration)()
         m_ExpressionType = tp.CecilType
 
         '        Classification = New ValueClassification(Me, m_ExpressionType)
         'SPECBUG
         Classification = New VariableClassification(Me, Me, m_ExpressionType)
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="57" endline="69"><![CDATA[
 
     ReadOnly Property Name() As String
         Get
             If TypeOf Me Is MeExpression Then
                 Return KS.Me.ToString
             ElseIf TypeOf Me Is MyBaseExpression Then
                 Return KS.MyBase.ToString
             ElseIf TypeOf Me Is MyClassExpression Then
                 Return KS.MyClass.ToString
             Else
                 Throw New InternalException("Invalid instance expression.")
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="70" endline="74"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="67" endline="69"><![CDATA[
         Get
             Return m_IsLateBoundArray
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="70" endline="75"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property AsString() As String
         Get
             Return m_Expression.AsString & "(" & m_ArgumentList.AsString & ")"
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="76" endline="80"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="81" endline="85"><![CDATA[
 
     Shadows Sub Init(ByVal Expression As Expression, ByVal ArgumentList As ArgumentList)
         m_Expression = Expression
         m_ArgumentList = ArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="86" endline="117"><![CDATA[
 
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If m_ConstantValue IsNot Nothing Then Return True
             If m_AscWExpression IsNot Nothing Then
                 If m_AscWExpression.IsConstant Then
                     m_ConstantValue = Microsoft.VisualBasic.AscW(CChar(m_AscWExpression.ConstantValue))
                     Return True
                 Else
                     Return False
                 End If
             End If
             If m_ArgumentList.Count <> 1 Then Return False
             If m_Expression.Classification.IsMethodGroupClassification Then
                 Dim param As Object
                 Dim mgc As MethodGroupClassification = m_Expression.Classification.AsMethodGroupClassification
                 If mgc.IsLateBound Then Return False
 
                 Dim mi As Mono.Cecil.MethodReference = mgc.ResolvedMethodInfo
 
                 If mi Is Nothing Then Return False
                 If Not (m_ArgumentList(0).Expression IsNot Nothing AndAlso m_ArgumentList(0).Expression.IsConstant) Then Return False
 
                 param = m_ArgumentList(0).Expression.ConstantValue
                 If Compiler.NameResolver.IsConstantMethod(mi, param, m_ConstantValue) = False Then Return False
 
                 Return True
             Else
                 Return False
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="118" endline="127"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If Me.IsConstant Then 'Necessary, since the property loads the constant value if it is a constant.
                 Return m_ConstantValue
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="128" endline="133"><![CDATA[
     End Property
 
     ReadOnly Property Expression() As Expression
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="134" endline="140"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_ExpressionType IsNot Nothing)
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="141" endline="219"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_AscWExpression IsNot Nothing Then
             result = m_AscWExpression.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Char)) AndAlso result
          
             Return result
         End If
 
         If m_InvocationMethod IsNot Nothing Then
             result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_Expression, m_ArgumentList, m_InvocationMethod) AndAlso result
             Return True
         End If
 
         If m_IsLateBoundArray Then
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             Return True
         End If
 
         If Classification.IsLateBoundClassification Then
             result = LateBoundAccessToExpression.EmitLateCall(Info, Classification.AsLateBoundAccess) AndAlso result
         Else
             Select Case m_Expression.Classification.Classification
                 Case ExpressionClassification.Classifications.MethodGroup
                     With m_Expression.Classification.AsMethodGroupClassification
                         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, .InstanceExpression, m_ArgumentList, .ResolvedMethod)
                     End With
                 Case ExpressionClassification.Classifications.Value
                     If Info.IsRHS Then
                         If Me.Classification.IsVariableClassification Then
                             result = Me.Classification.GenerateCode(Info) AndAlso result
                         ElseIf Me.Classification.IsPropertyAccessClassification Then
                             result = Me.Classification.AsPropertyAccess.GenerateCode(Info) AndAlso result
                         Else
                             result = m_Expression.GenerateCode(Info) AndAlso result
                         End If
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 Case ExpressionClassification.Classifications.PropertyAccess
                     If Info.IsRHS Then
                         If Me.Classification.IsVariableClassification Then
                             result = Me.Classification.GenerateCode(Info) AndAlso result
                         Else
                             result = m_Expression.GenerateCode(Info) AndAlso result
                         End If
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 Case ExpressionClassification.Classifications.PropertyGroup
                     'Helper.NotImplemented()
                     Dim pgC As PropertyGroupClassification
                     pgC = m_Expression.Classification.AsPropertyGroup
                     result = pgC.GenerateCodeAsValue(Info) AndAlso result
                 Case ExpressionClassification.Classifications.Variable
                     If Info.IsRHS Then
                         If Classification.IsValueClassification Then
                             result = Classification.AsValueClassification.GenerateCode(Info) AndAlso result
                         ElseIf Classification.IsPropertyGroupClassification Then
                             result = Classification.AsPropertyGroup.GenerateCodeAsValue(Info) AndAlso result
                         ElseIf Classification.IsPropertyAccessClassification Then
                             result = Classification.AsPropertyAccess.GenerateCode(Info) AndAlso result
                         Else
                             result = Classification.AsVariableClassification.GenerateCodeAsValue(Info) AndAlso result
                         End If
                     Else
                         result = Classification.GenerateCode(Info) AndAlso result
                     End If
                 Case ExpressionClassification.Classifications.LateBoundAccess
                     result = LateBoundAccessToExpression.EmitLateCall(Info, Classification.AsLateBoundAccess) AndAlso result
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="220" endline="223"><![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.LParenthesis)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="224" endline="227"><![CDATA[
 
     Shared Function CreateAndParseTo(ByRef result As Expression) As Boolean
         Return result.Compiler.Report.ShowMessage(Messages.VBNC99997, result.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="228" endline="236"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="237" endline="331"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(New ResolveInfo(Info.Compiler, True, , False)) AndAlso result
         If result = False Then Return False
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If result = False Then Return False
         'Check the classification of the arguments, can be value, variable, propertyaccess
         For i As Integer = 0 To m_ArgumentList.Count - 1
             If m_ArgumentList(i).Expression IsNot Nothing Then
                 Select Case m_ArgumentList(i).Expression.Classification.Classification
                     Case ExpressionClassification.Classifications.Value
                         'ok
                     Case ExpressionClassification.Classifications.Variable
                         'ok
                     Case ExpressionClassification.Classifications.PropertyAccess
                         'ok
                     Case ExpressionClassification.Classifications.MethodPointer
                         'ok?
                     Case ExpressionClassification.Classifications.PropertyGroup
                         m_ArgumentList(i).Expression = m_ArgumentList(i).Expression.ReclassifyToPropertyAccessExpression
                         result = m_ArgumentList(i).Expression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                     Case Else
                         'reclassify to value
                         If m_ArgumentList(i).Expression.Classification.CanBeValueClassification Then
                             m_ArgumentList(i).Expression = m_ArgumentList(i).Expression.ReclassifyToValueExpression
                             result = m_ArgumentList(i).Expression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                         Else
                             Helper.AddError(Me)
                         End If
                 End Select
             End If
         Next
 
         If result = False Then Return result
 
         Select Case m_Expression.Classification.Classification
             Case ExpressionClassification.Classifications.LateBoundAccess
                 Dim lae As LateBoundAccessClassification = m_Expression.Classification.AsLateBoundAccess
                 lae.Arguments = m_ArgumentList
                 Classification = lae
             Case ExpressionClassification.Classifications.MethodGroup
                 'This is an invocation expression.
                 result = ResolveMethodInvocation() AndAlso result
 
             Case ExpressionClassification.Classifications.Value
                 If CecilHelper.IsArray(m_Expression.ExpressionType) Then
                     result = ResolveArrayInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 Else
                     result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 End If
             Case ExpressionClassification.Classifications.PropertyAccess
                 If CecilHelper.IsArray(m_Expression.ExpressionType) Then
                     result = ResolveArrayInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 Else
                     result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 End If
             Case ExpressionClassification.Classifications.PropertyGroup
                 result = ResolvePropertyGroupInvocation() AndAlso result
             Case ExpressionClassification.Classifications.Variable
                 'This is an index expression.
 
                 '                An index expression results in an array element or reclassifies a property group into a property access. An index expression consists of, in order, an expression, an opening parenthesis, an index argument list, and a closing parenthesis. The target of the index expression must be classified as either a property group or a value. An index expression is processed as follows
                 '	If the target expression is classified as a value and if its type is not an array type, Object, or System.Array, the type must have a default property. The index is performed on a property group that represents all of the default properties of the type. Although it is not valid to declare a parameterless default property in Visual Basic, other languages may allow declaring such a property. Consequently, indexing a property with no arguments is allowed.
                 '	If the expression results in a value of an array type, the number of arguments in the argument list must be the same as the rank of the array type and may not include named arguments. If any of the indexes are invalid at run time, a System.IndexOutOfRangeException exception is thrown. Each expression must be implicitly convertible to type Integer. The result of the index expression is the variable at the specified index and is classified as a variable.
                 '	If the expression is classified as a property group, overload resolution is used to determine whether one of the properties is applicable to the index argument list. If the property group only contains one property that has a Get accessor and if that accessor takes no arguments, then the property group is interpreted as an index expression with an empty argument list. The result is used as the target of the current index expression. If no properties are applicable, then a compile-time error occurs. Otherwise, the expression results in a property access with the associated instance expression (if any) of the property group.
                 '	If the expression is classified as a late-bound property group or as a value whose type is Object or System.Array, the processing of the index expression is deferred until run time and the indexing is late-bound. The expression results in a late-bound property access typed as Object. The associated instance expression is either the target expression, if it is a value, or the associated instance expression of the property group. At run time the expression is processed as follows
                 '	If the expression is classified as a late-bound property group, the expression may result in a method group, a property group, or a value (if the member is an instance or shared variable). If the result is a method group or property group, overload resolution is applied to the group to determine the correct method for the argument list. If overload resolution fails, a System.Reflection.AmbiguousMatchException exception is thrown. Then the result is processed either as a property access or as an invocation and the result is returned. If the invocation is of a subroutine, the result is Nothing.
                 '	If the run-time type of the target expression is an array type or System.Array, the result of the index expression is the value of the variable at the specified index. 
                 '	Otherwise, the run-time type of the expression must have a default property and the index is performed on the property group that represents all of the default properties on the type. If the type has no default property, then a System.MissingMemberException exception is thrown.
 
                 Dim varexp As VariableClassification = m_Expression.Classification.AsVariableClassification
                 Dim expType As Mono.Cecil.TypeReference = varexp.Type
                 If CecilHelper.IsByRef(expType) Then
                     m_Expression = m_Expression.DereferenceByRef
                     expType = m_Expression.ExpressionType
                 End If
 
                 result = ResolveIndexInvocation(Me, expType) AndAlso result
             Case Else
                 Helper.AddError(Me, "Some error...")
         End Select
 
         If result = False Then Return result
 
         If m_ExpressionType Is Nothing Then
             m_ExpressionType = Classification.GetType(True)
         End If
 
         Helper.Assert(m_ExpressionType IsNot Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="332" endline="363"><![CDATA[
 
     Private Function ResolveIndexInvocation(ByVal Context As ParsedObject, ByVal VariableType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim Compiler As Compiler = Context.Compiler
 
         Dim defaultProperties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference) = Nothing
 
         If CecilHelper.IsArray(VariableType) Then
             result = ResolveArrayInvocation(Context, VariableType) AndAlso result
         ElseIf Helper.CompareType(VariableType, Compiler.TypeCache.System_Array) Then
             result = ResolveLateboundArrayInvocation(Context) AndAlso result
         ElseIf Helper.IsDelegate(Compiler, VariableType) Then
             'This is an invocation expression (the classification can be reclassified as value and the expression is a delegate expression)
             result = ResolveDelegateInvocation(Context, VariableType)
         ElseIf Helper.HasDefaultProperty(Me, VariableType, defaultProperties) Then
             Dim propGroup As New PropertyGroupClassification(Me, m_Expression, defaultProperties)
             result = propGroup.ResolveGroup(m_ArgumentList)
             If result Then
                 m_ArgumentList.ReplaceAndVerifyArguments(propGroup.FinalArguments, propGroup.ResolvedProperty)
             End If
             Classification = New PropertyAccessClassification(propGroup)
             'Classification = propGroup
         ElseIf Helper.CompareType(VariableType, Compiler.TypeCache.System_Object) Then
             Dim lbaClass As New LateBoundAccessClassification(Me, m_Expression, Nothing, Nothing)
             lbaClass.Arguments = m_ArgumentList
             Classification = lbaClass
         Else
             result = Compiler.Report.ShowMessage(Messages.VBNC30471, Location) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="364" endline="373"><![CDATA[
 
     Private Function ResolveLateBoundArrayInvocation(ByVal Context As ParsedObject) As Boolean
         Dim result As Boolean = True
 
         Classification = New LateBoundAccessClassification(Me, Expression, Nothing, Nothing)
 
         m_IsLateBoundArray = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="374" endline="422"><![CDATA[
 
     Private Function ResolveArrayInvocation(ByVal Context As ParsedObject, ByVal ArrayType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(CecilHelper.IsArray(ArrayType))
 
         If m_ArgumentList.HasNamedArguments Then
             Compiler.Report.ShowMessage(Messages.VBNC30075, tm.CurrentLocation)
             Return False
         End If
 
         If CecilHelper.GetArrayRank(ArrayType) <> m_ArgumentList.Count Then
             Helper.AddError(Me, "Array dimensions are not correct.")
             Return False
         End If
 
         Dim isStrictOn As Boolean = Location.File(Compiler).IsOptionStrictOn
 
         For i As Integer = 0 To m_ArgumentList.Count - 1
             Dim arg As Argument = m_ArgumentList(i)
             Dim argtype As Mono.Cecil.TypeReference = arg.Expression.ExpressionType
 
             If Compiler.TypeResolution.IsImplicitlyConvertible(Context, argtype, Compiler.TypeCache.System_Int32) = False Then
                 If isStrictOn Then
                     Helper.AddError(Me, "Array argument must be implicitly convertible to Integer.")
                     Return False
                 End If
                 Dim exp As Expression
                 exp = Helper.CreateTypeConversion(Me, m_ArgumentList(i).Expression, Compiler.TypeCache.System_Int32, result)
                 If result = False Then Return result
                 m_ArgumentList(i).Expression = exp
             ElseIf Helper.CompareType(argtype, Compiler.TypeCache.System_Int32) = False Then
                 Dim exp As Expression
                 exp = Helper.CreateTypeConversion(Me, m_ArgumentList(i).Expression, Compiler.TypeCache.System_Int32, result)
                 If result = False Then Return result
                 If CecilHelper.IsByRef(exp.ExpressionType) Then
                     exp = New DeRefExpression(Me, exp)
                 End If
                 m_ArgumentList(i).Expression = exp
             End If
         Next
 
         Dim aT As Mono.Cecil.ArrayType = DirectCast(ArrayType, Mono.Cecil.ArrayType)
         m_ExpressionType = aT.ElementType
 
         Classification = New VariableClassification(Me, Me.m_Expression, m_ArgumentList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="423" endline="455"><![CDATA[
 
     Private Function ResolveDelegateInvocation(ByVal Context As ParsedObject, ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim invokeMethod As Mono.Cecil.MethodReference
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim argTypes As Generic.List(Of Mono.Cecil.TypeReference)
         Dim paramTypes() As Mono.Cecil.TypeReference
         Dim Compiler As Compiler = Context.Compiler
 
         invokeMethod = Helper.GetInvokeMethod(Compiler, DelegateType)
         params = Helper.GetParameters(Compiler, invokeMethod)
         paramTypes = Helper.GetTypes(params)
         argTypes = m_ArgumentList.GetTypes
 
         If argTypes.Count <> paramTypes.Length Then Return False
 
         For i As Integer = 0 To argTypes.Count - 1
             If Compiler.TypeResolution.IsImplicitlyConvertible(Context, argTypes(i), paramTypes(i)) = False Then
                 Helper.AddError(Me, "Cannot convert implicitly from '" & argTypes(i).Name & "' to '" & paramTypes(i).Name & "'")
                 Return False
             End If
         Next
 
         m_InvocationMethod = invokeMethod
 
         If invokeMethod.ReturnType IsNot Nothing Then
             Classification = New ValueClassification(Me, invokeMethod.ReturnType)
         Else
             Classification = New VoidClassification(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="456" endline="477"><![CDATA[
 
     Private Function ResolvePropertyGroupInvocation() As Boolean
         Dim result As Boolean = True
         Dim propGroup As PropertyGroupClassification = m_Expression.Classification.AsPropertyGroup
         Dim tmpResult As Boolean
 
         tmpResult = propGroup.ResolveGroup(m_ArgumentList)
 
         If tmpResult = False Then
             tmpResult = ResolveReclassifyToValueThenIndex()
 
             Helper.StopIfDebugging(tmpResult = False)
 
             Return tmpResult
         Else
             result = m_ArgumentList.ReplaceAndVerifyArguments(propGroup.FinalArguments, propGroup.ResolvedProperty) AndAlso result
         End If
 
         Classification = New PropertyAccessClassification(propGroup)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="478" endline="499"><![CDATA[
 
     Private Function ResolveReclassifyToValueThenIndex() As Boolean
         Dim result As Boolean = True
         Dim tmpExp As Expression
         Dim oldExp As Expression
 
         tmpExp = m_Expression.ReclassifyToValueExpression
         result = tmpExp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
 
         If result = False Then
             Helper.AddError(Me)
             Return False
         End If
 
         oldExp = m_Expression
         m_Expression = tmpExp
         result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
 
         Helper.StopIfDebugging(result = False)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="500" endline="579"><![CDATA[
 
     Private Function ResolveMethodInvocation() As Boolean
         Dim result As Boolean = True
         Dim mgc As MethodGroupClassification = m_Expression.Classification.AsMethodGroupClassification
 
         'If the method group only contains one method and that method takes no arguments and is a function, 
         'then the method group is interpreted as an invocation expression 
         'with an empty argument list and the result is used as the target of an index expression.
 
         Dim reclassifyToIndex As Boolean
         If mgc.Group.Count = 1 AndAlso m_ArgumentList.Count > 0 Then
             Dim method As Mono.Cecil.MethodReference = TryCast(mgc.Group(0), Mono.Cecil.MethodReference)
 
             reclassifyToIndex = method IsNot Nothing
             reclassifyToIndex = reclassifyToIndex AndAlso method.ReturnType IsNot Nothing
             reclassifyToIndex = reclassifyToIndex AndAlso Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Void) = False
             reclassifyToIndex = reclassifyToIndex AndAlso Helper.GetParameters(Compiler, method).Count = 0
 
         End If
 
         If reclassifyToIndex Then
             Return ResolveReclassifyToValueThenIndex()
         Else
             result = mgc.ResolveGroup(m_ArgumentList)
             If result Then
                 If mgc.IsLateBound = False Then
                     m_ArgumentList.ReplaceAndVerifyArguments(mgc.FinalArguments, mgc.ResolvedMethod)
                 End If
                 result = mgc.VerifyConstraints AndAlso result
                 If result = False Then Return False
             Else
                 mgc.ResolveGroup(m_ArgumentList, True)
                 Return False
             End If
         End If
 
         Helper.StopIfDebugging(result = False)
 
         If mgc.IsLateBound Then
             Dim lba As LateBoundAccessClassification = New LateBoundAccessClassification(Me, mgc.InstanceExpression, Nothing, mgc.Resolver.MethodName)
             lba.LateBoundType = mgc.Resolver.MethodDeclaringType
             lba.Arguments = m_ArgumentList
             Classification = lba
         ElseIf mgc.ResolvedMethodInfo IsNot Nothing Then
             Dim methodInfo As Mono.Cecil.MethodReference = mgc.ResolvedMethodInfo
 
             If String.IsNullOrEmpty(Compiler.CommandLine.VBRuntime) AndAlso Compiler.Assembly.IsDefinedHere(methodInfo) AndAlso CecilHelper.FindDefinition(methodInfo).IsStatic AndAlso Helper.CompareName(methodInfo.Name, "AscW") Then
                 Dim methodParameters As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetParameters(Compiler, methodInfo)
 
                 If methodParameters.Count <> 0 AndAlso Helper.CompareType(methodParameters(0).ParameterType, Compiler.TypeCache.System_Char) Then
                     m_AscWExpression = ArgumentList(0).Expression
                     m_ExpressionType = Compiler.TypeCache.System_Int32
                     Classification = New ValueClassification(Me, m_ExpressionType)
 
                     Return result
                 End If
             End If
 
             If mgc.InstanceExpression Is Nothing AndAlso CecilHelper.IsStatic(methodInfo) = False Then
                 Dim mae As MemberAccessExpression = TryCast(m_Expression, MemberAccessExpression)
                 If mae IsNot Nothing AndAlso mae.FirstExpression.Classification.IsTypeClassification AndAlso mae.FirstExpression.Classification.AsTypeClassification.CanBeExpression Then
                     Dim exp As Expression = Nothing
                     result = mae.FirstExpression.Classification.AsTypeClassification.CreateAliasExpression(mae.FirstExpression, exp) AndAlso result
                     mgc.InstanceExpression = exp
                 End If
             End If
 
             If methodInfo.ReturnType Is Nothing OrElse Helper.CompareType(methodInfo.ReturnType, Compiler.TypeCache.System_Void) Then
                 Classification = New VoidClassification(Me)
             Else
                 Classification = New ValueClassification(Me, methodInfo.ReturnType)
             End If
         ElseIf mgc.ResolvedConstructor IsNot Nothing Then
             Classification = New VoidClassification(Me)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="580" endline="589"><![CDATA[
     ''' <summary>
     ''' Returns the list of arguments for this expression.
     ''' Might be nothing.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property ArgumentList() As ArgumentList
         Get
             Return m_ArgumentList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="26" endline="28"><![CDATA[
         Get
             Return m_LateBoundAccess
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="29" endline="34"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="35" endline="40"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Throw New InternalException("A late bound expression does not have a constant value.")
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal LateBoundAccessClassification As LateBoundAccessClassification)
         MyBase.new(Parent)
         m_LateBoundAccess = LateBoundAccessClassification
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="47" endline="54"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="55" endline="59"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Object
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="60" endline="64"><![CDATA[
     End Property
 
     Protected Function EmitLateIndexGet(ByVal Info As EmitInfo) As Boolean
         Return EmitLateIndexGet(Info, LateBoundAccess)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="65" endline="68"><![CDATA[
 
     Protected Function EmitLateGet(ByVal Info As EmitInfo) As Boolean
         Return EmitLateGet(Info, LateBoundAccess)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="69" endline="72"><![CDATA[
 
     Protected Function EmitLateIndexSet(ByVal Info As EmitInfo) As Boolean
         Return EmitLateIndexSet(Info, LateBoundAccess)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="73" endline="76"><![CDATA[
 
     Protected Function EmitLateSet(ByVal Info As EmitInfo) As Boolean
         Return EmitLateSet(Info, LateBoundAccess)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="77" endline="165"><![CDATA[
 
     ''' <summary>
     ''' Creates an object array (always).
     ''' - initializes it with the arguments (if any). 
     ''' - adds the rhs expression (if supplied).
     ''' Leaves a reference to the object array on the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="LateBoundAccess"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function EmitArguments(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification, ByRef arguments As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
 
         Dim argCount As Integer
         Dim elementCount As Integer
         Dim args As ArgumentList
 
         Dim namedCount As Integer
 
         args = LateBoundAccess.Arguments
         If args IsNot Nothing Then argCount = args.Count
 
         elementCount = argCount
         If Info.RHSExpression IsNot Nothing Then elementCount += 1
 
         arguments = Emitter.DeclareLocal(Info, Info.Compiler.TypeCache.System_Object_Array)
 
         Emitter.EmitLoadI4Value(Info, elementCount)
         Emitter.EmitNewArr(Info, Info.Compiler.TypeCache.System_Object)
 
         Emitter.EmitStoreVariable(Info, arguments)
 
         For i As Integer = 0 To argCount - 1
             Dim arg As Argument = args.Arguments(i)
             If TypeOf arg Is NamedArgument Then namedCount += 1
             Emitter.EmitLoadVariable(Info, arguments)
             Emitter.EmitLoadI4Value(Info, i)
             If arg.Expression Is Nothing Then
                 Emitter.EmitLoadVariable(Info, Info.Compiler.TypeCache.System_Reflection_Missing__Value)
             Else
                 result = arg.GenerateCode(Info.Clone(Info.Context, True, False, arg.Expression.ExpressionType)) AndAlso result
                 If CecilHelper.IsValueType(arg.Expression.ExpressionType) Then
                     Emitter.EmitBox(Info, arg.Expression.ExpressionType)
                 End If
             End If
             Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_Object, Info.Compiler.TypeCache.System_Object_Array)
         Next
 
         If elementCount <> argCount Then
             Emitter.EmitLoadVariable(Info, arguments)
             Emitter.EmitLoadI4Value(Info, elementCount - 1)
             result = Info.RHSExpression.GenerateCode(Info.Clone(Info.Context, True, False, Info.RHSExpression.ExpressionType)) AndAlso result
             If CecilHelper.IsValueType(Info.RHSExpression.ExpressionType) Then
                 Emitter.EmitBox(Info, Info.RHSExpression.ExpressionType)
             End If
             Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_Object, Info.Compiler.TypeCache.System_Object_Array)
         End If
 
         Emitter.EmitLoadVariable(Info, arguments)
 
         If namedCount > 0 Then
             Dim namedArguments As Mono.Cecil.Cil.VariableDefinition
             namedArguments = Emitter.DeclareLocal(Info, Info.Compiler.TypeCache.System_String_Array)
             Emitter.EmitLoadI4Value(Info, namedCount)
             Emitter.EmitNewArr(Info, Info.Compiler.TypeCache.System_String)
             Emitter.EmitStoreVariable(Info, namedArguments)
 
             Dim iNamed As Integer
             For i As Integer = 0 To argCount - 1
                 Dim arg As NamedArgument = TryCast(args.Arguments(i), NamedArgument)
                 If arg Is Nothing Then Continue For
 
                 Emitter.EmitLoadVariable(Info, namedArguments)
                 Emitter.EmitLoadI4Value(Info, iNamed)
                 Emitter.EmitLoadValue(Info, arg.Name)
                 Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_String, Info.Compiler.TypeCache.System_String_Array)
 
                 iNamed += 1
             Next
 
             Emitter.EmitLoadVariable(Info, namedArguments)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_String_Array))
         End If
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="166" endline="240"><![CDATA[
 
     ''' <summary>
     ''' If there's anything to copy back, creates a boolean array with
     ''' - true if the value can be copied back (the argument is assignable, that is
     ''' Otherwise just loads a null value.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="LateBoundAccess"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function EmitCopyBacks(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification, ByRef copyBackHints As Boolean(), ByRef copyBacks As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
         Dim args As ArgumentList
 
         args = LateBoundAccess.Arguments
 
         If args Is Nothing OrElse args.Count = 0 Then
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Boolean_Array))
         Else
             copyBackHints = New Boolean(args.Count - 1) {}
             copyBacks = Emitter.DeclareLocal(Info, Info.Compiler.TypeCache.System_Boolean_Array)
 
             Emitter.EmitLoadI4Value(Info, args.Count)
             Emitter.EmitNewArr(Info, Info.Compiler.TypeCache.System_Boolean)
             Emitter.EmitStoreVariable(Info, copyBacks)
             For i As Integer = 0 To args.Count - 1
                 Dim arg As Argument
                 Dim exp As Expression
                 Dim copyBack As Boolean
 
                 arg = args.Arguments(i)
                 exp = arg.Expression
 
                 Emitter.EmitLoadVariable(Info, copyBacks) ' Emitter.EmitDup(Info)
                 Emitter.EmitLoadI4Value(Info, i)
                 If exp Is Nothing Then
                     copyBack = False
                 Else
                     Select Case exp.Classification.Classification
                         Case ExpressionClassification.Classifications.Variable
                             Dim varC As VariableClassification = exp.Classification.AsVariableClassification
                             If varC.LocalBuilder IsNot Nothing Then
                                 copyBack = True
                             ElseIf varC.FieldInfo IsNot Nothing Then
                                 Dim fD As IFieldMember = TryCast(varC.FieldInfo.Annotations(Info.Compiler), IFieldMember)
                                 If fD IsNot Nothing Then
                                     'TODO
                                     copyBack = varC.FieldDefinition.IsLiteral = False AndAlso fD.Modifiers.Is(ModifierMasks.ReadOnly) = False
                                 Else
                                     copyBack = varC.FieldDefinition.IsLiteral = False
                                 End If
                             Else
                                 copyBack = False
                             End If
                         Case ExpressionClassification.Classifications.Value
                             copyBack = False
                         Case ExpressionClassification.Classifications.PropertyAccess
                             copyBack = CecilHelper.FindDefinition(exp.Classification.AsPropertyAccess.ResolvedProperty).SetMethod IsNot Nothing '.CanWrite
                         Case Else
                             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
                     End Select
                 End If
                 copyBackHints(i) = copyBack
                 If copyBack Then
                     Emitter.EmitLoadI4Value(Info, 1)
                 Else
                     Emitter.EmitLoadI4Value(Info, 0)
                 End If
                 Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_Boolean, Info.Compiler.TypeCache.System_Boolean_Array)
             Next
             Emitter.EmitLoadVariable(Info, copyBacks)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="241" endline="290"><![CDATA[
 
     Private Shared Function EmitStoreBacks(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification, ByVal CopyBacks As Boolean(), ByVal array As Mono.Cecil.Cil.VariableDefinition, ByVal arguments As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
         Dim args As ArgumentList
 
         If CopyBacks Is Nothing OrElse CopyBacks.Length = 0 Then Return result
 
         args = LateBoundAccess.Arguments
 
         For i As Integer = 0 To CopyBacks.Length - 1
             Dim branch As Label
 
             If CopyBacks(i) = False Then Continue For
 
             Dim arg As Argument
             Dim exp As Expression
 
             arg = args.Arguments(i)
             exp = arg.Expression
 
             branch = Emitter.DefineLabel(Info)
             Emitter.EmitLoadVariable(Info, array)
             Emitter.EmitLoadI4Value(Info, i)
             Emitter.EmitLoadElement(Info, Info.Compiler.TypeCache.System_Boolean_Array)
             Emitter.EmitBranchIfFalse(Info, branch)
 
             Dim tmpVar As Mono.Cecil.Cil.VariableDefinition
             tmpVar = Emitter.DeclareLocal(Info, exp.ExpressionType)
 
             Emitter.EmitLoadVariable(Info, arguments)
             Emitter.EmitLoadI4Value(Info, i)
             Emitter.EmitLoadElement(Info, Info.Compiler.TypeCache.System_Object_Array)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
             Emitter.EmitLoadToken(Info, exp.ExpressionType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ChangeType_Object_Type)
 
             Dim vosExp As New ValueOnStackExpression(exp, Info.Compiler.TypeCache.System_Object)
             Dim convExp As DirectCastExpression
             convExp = New DirectCastExpression(exp)
             convExp.Init(vosExp, exp.ExpressionType)
             result = convExp.GenerateCode(Info) AndAlso result
             Emitter.EmitStoreVariable(Info, tmpVar)
             result = exp.GenerateCode(Info.Clone(Info.Context, New LoadLocalExpression(exp, tmpVar))) AndAlso result
 
             Emitter.MarkLabel(Info, branch)
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="291" endline="337"><![CDATA[
 
     Public Shared Function EmitLateGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateGet
 
         If LateBoundAccess.InstanceExpression Is Nothing Then
             '1 - the instance expression (none in this case)
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
             '2 - Type 
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         Else
             '1 - the instance expression
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
             '2 - Type  - we have the instance, so no need to pass the type here.
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="338" endline="356"><![CDATA[
 
     Public Shared Function EmitLateIndexGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexGet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
         '2 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="357" endline="387"><![CDATA[
 
     Public Shared Function EmitLateSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - Type ??? - haven't found an example where this isn't nothing yet
         Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="388" endline="405"><![CDATA[
 
     Public Shared Function EmitLateIndexSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - The arguments
         '3 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="406" endline="455"><![CDATA[
 
     Public Shared Function EmitLateCall(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateCall
 
         '1 - the instance expression
         If LateBoundAccess.InstanceExpression IsNot Nothing Then
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Object))
         End If
 
         '2 - Type
         If LateBoundAccess.LateBoundType Is Nothing Then
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         Else
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         '8 - Ignore return
         Emitter.EmitLoadI4Value(Info, 1)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean)
 
         Emitter.EmitPop(Info, Info.Compiler.TypeCache.System_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal LateBoundAccessClassification As LateBoundAccessClassification)
         MyBase.new(Parent, LateBoundAccessClassification)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="26" endline="33"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New PropertyAccessClassification(Me)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="34" endline="53"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsLHS Then
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateindexSet(Info) AndAlso result
             Else
                 result = EmitLateSet(Info) AndAlso result
             End If
         Else
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateIndexGet(Info) AndAlso result
             Else
                 result = EmitLateGet(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal LateBoundAccessClassification As LateBoundAccessClassification)
         MyBase.new(Parent, LateBoundAccessClassification)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="26" endline="33"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="34" endline="46"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.LateBoundAccess.Name Is Nothing Then
             result = EmitLateIndexGet(Info) AndAlso result
         Else
             result = EmitLateGet(Info) AndAlso result
         End If
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="37" endline="43"><![CDATA[
         Get
             If TypeOf m_Value.LiteralValue Is String Then
                 Return """" & m_Value.LiteralValue.ToString & """"
             Else
                 Return m_Value.LiteralValue.ToString()
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="44" endline="48"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="49" endline="53"><![CDATA[
 
     Shadows Sub Init(ByVal Value As Token)
         MyBase.Init(Value.LiteralValue, CecilHelper.GetType(Compiler, Value.LiteralValue))
         m_Value = Value
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="54" endline="70"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             Helper.Assert(Me.Classification.IsValueClassification)
             If Me.Classification.CanBeValueClassification Then
                 result = Me.Classification.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="71" endline="74"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.IsLiteral
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="75" endline="78"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="79" endline="84"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Helper.Assert(ConstantValue IsNot Nothing)
         Classification = New ValueClassification(Me, ExpressionType, ConstantValue)
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="85" endline="91"><![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New LiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="27" endline="29"><![CDATA[
         Get
             Return m_Field
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="30" endline="38"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal Field As Mono.Cecil.FieldReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.New(Parent)
 
         m_Field = Field
         m_InstanceExpression = InstanceExpression
         Me.Classification = New ValueClassification(Me, m_Field.FieldType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="39" endline="43"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_Field.FieldType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="44" endline="54"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.Classification IsNot Nothing Then
             Me.Classification = New ValueClassification(Me, m_Field.FieldType)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="55" endline="66"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info) AndAlso result
         End If
 
         Emitter.EmitLoadVariable(Info, m_Field)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MeExpression.vb" startline="28" endline="30"><![CDATA[
         Get
             Return "Me"
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MeExpression.vb" startline="31" endline="35"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MeExpression.vb" startline="36" endline="43"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Emitter.EmitLoadMe(Info, Me.FindFirstParent(Of IType).CecilType)
         If CecilHelper.IsValueType(Info.DesiredType) AndAlso CecilHelper.IsByRef(Info.DesiredType) = False Then
             Emitter.EmitLoadObject(Info, Info.DesiredType)
         End If
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="39" endline="45"><![CDATA[
         Get
             If m_First IsNot Nothing Then
                 Return m_First.AsString & "." & m_Second.Identifier
             Else
                 Return "." & m_Second.Identifier
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="46" endline="51"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return Classification.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="52" endline="57"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return Classification.ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="58" endline="69"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_First IsNot Nothing Then result = m_First.ResolveTypeReferences AndAlso result
         If m_Second IsNot Nothing Then result = m_Second.ResolveTypeReferences AndAlso result
 
         ' If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="70" endline="73"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="74" endline="78"><![CDATA[
 
     Sub Init(ByVal First As Expression, ByVal Second As IdentifierOrKeyword)
         m_First = First
         m_Second = Second
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="79" endline="95"><![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New MemberAccessExpression(NewParent)
 
         Dim m_First As Expression = Nothing
         Dim m_Second As IdentifierOrKeyword = Nothing
         '  Dim m_TypeArguments As TypeParameters
 
         If Me.m_First IsNot Nothing Then m_First = Me.m_First.Clone(result)
         If Me.m_Second IsNot Nothing Then m_Second = Me.m_Second.Clone(result)
         '  If Me.m_TypeArguments IsNot Nothing Then m_TypeArguments = Me.m_TypeArguments.Clone(result)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="96" endline="150"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Select Case Classification.Classification
             Case ExpressionClassification.Classifications.MethodGroup
                 If m_First Is Nothing Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 Else
                     With Classification.AsMethodGroupClassification
                         If Info.IsRHS Then
                             Dim tmp As ValueClassification = .ReclassifyToValue
                             result = tmp.GenerateCode(Info) AndAlso result
                         Else
                             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                         End If
                     End With
                 End If
             Case ExpressionClassification.Classifications.Variable
                 If m_First Is Nothing Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 Else
                     With Classification.AsVariableClassification
                         result = .GenerateCode(Info) AndAlso result
                     End With
                 End If
             Case ExpressionClassification.Classifications.Value
                 With Classification.AsValueClassification
                     result = .GenerateCode(Info) AndAlso result
                 End With
             Case ExpressionClassification.Classifications.PropertyGroup
                 With Classification.AsPropertyGroup
                     If Info.IsRHS Then
                         Dim tmp As ValueClassification = .ReclassifyToValue
                         result = tmp.GenerateCode(Info) AndAlso result
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 End With
             Case ExpressionClassification.Classifications.LateBoundAccess
                 If Info.IsLHS Then
                     If Info.RHSExpression Is Nothing Then
                         LateBoundAccessToExpression.EmitLateCall(Info, Me.Classification.AsLateBoundAccess)
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 End If
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="151" endline="155"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Classification.GetType(True)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="156" endline="736"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         '---------------------------------------------------------------------------------------------------------
         'A member access expression is used to access a member of an entity. A member access of the form E.I, 
         'where E is an expression, a built-in type, the keyword Global, or omitted and I is an identifier with an 
         'optional type argument list, is evaluated and classified as follows
         '---------------------------------------------------------------------------------------------------------
         '* If E is omitted, then the expression from the immediately containing With statement is substituted for 
         '  E and the member access is performed. If there is no containing With statement, a compile-time 
         '  error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If E is a type parameter, then a compile-time error results.
         '---------------------------------------------------------------------------------------------------------
         '* If E is the keyword Global, and I is the name of an accessible type in the global namespace, 
         '  then the result is that type.
         '---------------------------------------------------------------------------------------------------------
         '* If E is classified as a namespace and I is the name of an accessible member of that namespace, 
         '  then the result is that member. The result is classified as a namespace or a type depending on the member.
         '---------------------------------------------------------------------------------------------------------
         '* If E is a built-in type or an expression classified as a type, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New, then a compile-time error occurs.
         '** If I identifies a type, then the result is that type.
         '** If I identifies one or more methods, then the result is a method group with the associated 
         '   type argument list and no associated instance expression.
         '** If I identifies one or more properties, then the result is a property group with no associated 
         '   instance expression.
         '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
         '   outside the shared constructor of the type in which the variable is declared, then the result is the 
         '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
         '** If I identifies a shared event, the result is an event access with no associated instance expression.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If E is classified as a variable or value, the type of which is T, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
         '   a method group representing the instance constructors of the type of E with an associated 
         '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
         '** If I identifies one or more methods, then the result is a method group with the associated type 
         '   argument list and an associated instance expression of E.
         '** If I identifies one or more properties, then the result is a property group with an 
         '   associated instance expression of E.
         '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
         '   and the reference occurs outside a constructor of the class in which the variable is declared 
         '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
         '   variable I in the object referenced by E. If T is a reference type, then the result is the variable 
         '   I in the object referenced by E. Otherwise, if T is a value type and the expression E is classified 
         '   as a variable, the result is a variable; otherwise the result is a value.
         '** If I identifies an event, the result is an event access with an associated instance expression of E.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
         '   with an associated instance expression of E.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         'If the member access expression includes a type argument list, then only types or methods 
         'with the same arity as the type argument list are considered.
         'When a member access expression begins with the keyword Global, the keyword represents the outermost 
         'unnamed namespace, which is useful in situations where a declaration shadows an enclosing namespace. The 
         'Global keyword allows "escaping" out to the outermost namespace in that situation. 
         '---------------------------------------------------------------------------------------------------------
 
         Dim Name As String = m_Second.Name
         Dim typeArguments As TypeArgumentList = Nothing
 
         Dim iokwta As IdentifierOrKeywordWithTypeArguments = TryCast(m_Second, IdentifierOrKeywordWithTypeArguments)
         If iokwta IsNot Nothing Then
             typeArguments = iokwta.TypeArguments
         End If
         
         Helper.Assert(Name IsNot Nothing AndAlso Name <> "")
 
         If m_First IsNot Nothing Then
             result = m_First.ResolveExpression(New ResolveInfo(Info.Compiler, False, Info.CanFail, Info.CanBeImplicitSimpleName)) AndAlso result
         Else
             '* If E is omitted, then the expression from the immediately containing With statement is substituted for
             '  E and the member access is performed. If there is no containing With statement, a compile-time 
             '  error occurs.
             m_WithStatement = Me.FindFirstParentOfCodeBlock(Of WithStatement)()
             If m_WithStatement Is Nothing Then
                 Helper.AddError(Me)
                 Return False
             Else
                 m_First = m_WithStatement.WithVariableExpression
                 ' Helper.Assert(m_First.IsResolved)
             End If
         End If
 
         If result = False Then Return result
 
         '* If E is a type parameter, then a compile-time error results.
         If m_First.Classification.IsTypeClassification AndAlso m_First.Classification.AsTypeClassification.IsTypeParameter Then
             result = Compiler.Report.ShowMessage(Messages.VBNC32098, Me.Location) AndAlso result
             If result = False Then Return result
         End If
 
         '* If E is the keyword Global, and I is the name of an accessible type in the global namespace, 
         '  then the result is that type.
         If TypeOf m_First Is GlobalExpression Then
             Dim foundType As Mono.Cecil.TypeReference
             foundType = Compiler.TypeManager.GetTypesByNamespace("").Item(Name)
             If foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             ElseIf Compiler.TypeManager.Namespaces.ContainsKey(Name) Then
                 Classification = New NamespaceClassification(Me, Compiler.TypeManager.Namespaces(Name))
                 Return True
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC30456, Location, Name, "<Default>") AndAlso result
             End If
         End If
 
         '* If E is classified as a namespace and I is the name of an accessible member of that namespace, 
         '  then the result is that member. The result is classified as a namespace or a type depending on the member.
         If m_First.Classification.IsNamespaceClassification Then
             Dim nstypes As Generic.List(Of Mono.Cecil.TypeReference) = Nothing
             Dim ns As [Namespace] = m_First.Classification.AsNamespaceClassification.Namespace
             Dim nsname As String = ns.Name
             Dim foundns As [Namespace]
             Dim foundType As Mono.Cecil.TypeReference
 
             foundns = Compiler.TypeManager.Namespaces.Item(ns, Name)
             foundType = Compiler.TypeManager.TypesByNamespace(nsname).Item(Name)
 
             If foundns IsNot Nothing AndAlso foundType Is Nothing Then
                 Classification = New NamespaceClassification(Me, foundns)
                 Return True
             ElseIf foundns Is Nothing AndAlso foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             ElseIf foundns IsNot Nothing AndAlso nstypes IsNot Nothing Then
                 Helper.AddError(Me, "Found a namespace and a type with the same name.")
             End If
 
             'TODO
             Dim modules As TypeDictionary = Compiler.TypeManager.GetModulesByNamespace(ns.ToString)
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Helper.GetMembersOfTypes(Compiler, modules, Name)
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 Dim first As Object = members(0)
                 If Helper.IsMethodDeclaration(first) Then
                     Classification = New MethodGroupClassification(Me, Nothing, typeArguments, Nothing, members)
                     Return True
                 ElseIf Helper.IsTypeDeclaration(first) Then
                     If members.Count = 1 Then
                         Classification = New TypeClassification(Me, first)
                         Return True
                     Else
                         Helper.AddError(Me)
                     End If
                 ElseIf Helper.IsFieldDeclaration(first) Then
                     If members.Count = 1 Then
                         Classification = New VariableClassification(Me, DirectCast(first, Mono.Cecil.FieldReference), Nothing)
                         Return True
                     Else
                         Helper.AddError(Me)
                     End If
                 ElseIf Helper.IsPropertyDeclaration(first) Then
                     Classification = New PropertyGroupClassification(Me, Nothing, members)
                     Return True
                 Else
                     Helper.Stop()
                 End If
             End If
         End If
 
         '* If E is a built-in type or an expression classified as a type, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New, then a compile-time error occurs.
         '** If I identifies a type, then the result is that type.
         '** If I identifies one or more methods, then the result is a method group with the associated 
         '   type argument list and no associated instance expression.
         '** If I identifies one or more properties, then the result is a property group with no associated 
         '   instance expression.
         '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
         '   outside the shared constructor of the type in which the variable is declared, then the result is the 
         '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
         '** If I identifies a shared event, the result is an event access with no associated instance expression.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         If m_First.Classification.IsTypeClassification Then
             'If m_Second.IsKeyword AndAlso m_Second.Keyword = KS.New Then
             '    '** If I is the keyword New, then a compile-time error occurs.
             '    Helper.AddError(Me)
             'End If
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
             Dim entry As MemberCacheEntry
             'members = Helper.FilterByName(Helper.GetMembers(Compiler, m_First.Classification.AsTypeClassification.Type), Name)
             'members = Helper.FilterByName(Compiler.TypeManager.GetCache(m_First.Classification.AsTypeClassification.Type).FlattenedCache.GetAllMembers.ToArray, Name)
             entry = Compiler.TypeManager.GetCache(m_First.Classification.AsTypeClassification.Type).LookupFlattened(Name)
 
             If entry Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, m_First.Classification.AsTypeClassification.Type.FullName)
                 Return False
             End If			
 
             If entry IsNot Nothing Then
                 members = entry.Members
                 If typeArguments IsNot Nothing Then
                     members = Helper.FilterByTypeArguments(members, typeArguments)
                     'For i As Integer = 0 To members.Count - 1
                     '    Dim mR As Mono.Cecil.MethodReference = TryCast(members(i), Mono.Cecil.MethodReference)
                     '    If mR Is Nothing Then
                     '        Helper.StopIfDebugging()
                     '        Continue For
                     '    End If
                     '    members(i) = CecilHelper.GetCorrectMember(mR, withTypeArgs.TypeArguments.ArgumentCollection)
                     'Next
                 End If
                 members = Helper.FilterExternalInaccessible(Me.Compiler, members)
             End If
 
             Helper.StopIfDebugging(members Is Nothing OrElse members.Count = 0)
 
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 Dim first As Object = members(0)
                 '** If I identifies one or more methods, then the result is a method group with the associated 
                 '   type argument list and no associated instance expression.
                 If Helper.IsMethodDeclaration(first) Then
                     Classification = New MethodGroupClassification(Me, Nothing, typeArguments, Nothing, members)
                     Return True
                 End If
                 '** If I identifies one or more properties, then the result is a property group with no associated 
                 '   instance expression.
                 If Helper.IsPropertyDeclaration(first) Then
                     Dim instanceExpression As Expression = Nothing
                     If m_First.Classification.AsTypeClassification.CanBeExpression Then
                         'Ignore failures here, not sure if failures can actually happen for valid code
                         m_First.Classification.AsTypeClassification.CreateAliasExpression(m_First, instanceExpression)
                     End If
                     Classification = New PropertyGroupClassification(Me, instanceExpression, members)
                     Return True
                 End If
 
                 If members.Count > 1 Then Helper.Stop()
 
                 '** If I identifies a type, then the result is that type.
                 If Helper.IsTypeDeclaration(first) Then
                     Classification = New TypeClassification(Me, first)
                     Return True
                 End If
 
                 '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
                 '   outside the shared constructor of the type in which the variable is declared, then the result is the 
                 '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
                 If Helper.IsFieldDeclaration(first) Then
                     Dim fld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
                     If fld Is Nothing Then
                         Dim var As TypeVariableDeclaration = TryCast(first, TypeVariableDeclaration)
                         Helper.Assert(var IsNot Nothing)
                         fld = var.FieldBuilder
                     End If
                     Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
                     Dim instanceExpression As Expression = Nothing
 
                     If Not CecilHelper.IsStatic(fld) AndAlso m_First.Classification.IsTypeClassification AndAlso m_First.Classification.AsTypeClassification.CanBeExpression Then
                         result = m_First.Classification.AsTypeClassification.CreateAliasExpression(m_First, instanceExpression) AndAlso result
                     End If
 
                     If Helper.IsShared(fld) AndAlso CBool(CecilHelper.FindDefinition(fld).Attributes And Mono.Cecil.FieldAttributes.InitOnly) AndAlso (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) = False) Then
                         Classification = New ValueClassification(Me, fld, Nothing)
                         Return True
                     Else
                         Classification = New VariableClassification(Me, fld, instanceExpression)
                         Return True
                     End If
                 End If
 
                 '** If I identifies a shared event, the result is an event access with no associated instance expression.
                 If Helper.IsEventDeclaration(first) Then
                     Dim red As EventDeclaration = TryCast(first, EventDeclaration)
                     Dim red2 As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(TryCast(first, Mono.Cecil.EventReference))
                     If red IsNot Nothing AndAlso red.Modifiers.Is(ModifierMasks.Shared) Then
                         Classification = New EventAccessClassification(Me, red.EventDescriptor, Nothing)
                         Return True
                     ElseIf red2 IsNot Nothing AndAlso red2.AddMethod.IsStatic Then
                         Classification = New EventAccessClassification(Me, red2, Nothing)
                         Return True
                     End If
                 End If
 
                 '** If I identifies a constant, then the result is the value of that constant.
                 Dim c As ConstantDeclaration = TryCast(first, ConstantDeclaration)
                 If c IsNot Nothing Then
                     Classification = New ValueClassification(Me, c)
                     Return True
                 End If
 
                 '** If I identifies an enumeration member, then the result is the value of that enumeration member.
                 Dim enummember As EnumMemberDeclaration = TryCast(first, EnumMemberDeclaration)
                 If enummember IsNot Nothing Then
                     Classification = New ValueClassification(Me, enummember)
                     Return True
                 End If
 
                 '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
                 'Now we need to check for default instances
                 If m_First.Classification.AsTypeClassification.CanBeExpression Then
                     Dim aliasExpression As Expression = Nothing
                     m_First.Classification.AsTypeClassification.CreateAliasExpression(m_First, aliasExpression)
                     m_First = aliasExpression
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30469, Me.Location)
                 End If
             Else
                 Helper.AddError(Me, "Could not resolve name '" & Name & "'" & "," & Me.Location.ToString(Compiler))
             End If
         End If
 
 
         '* If E is classified as a variable or value, the type of which is T, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
         '   a method group representing the instance constructors of the type of E with an associated 
         '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
         '** If I identifies one or more methods, then the result is a method group with the associated type 
         '   argument list and an associated instance expression of E.
         '** If I identifies one or more properties, then the result is a property group with an 
         '   associated instance expression of E.
         '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
         '   and the reference occurs outside a constructor of the class in which the variable is declared 
         '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
         '   variable I in the object referenced by E. If T is a reference type, then the result is the variable 
         '   I in the object referenced by E. Otherwise, if T is a value type and the expression E is classified 
         '   as a variable, the result is a variable; otherwise the result is a value.
         '** If I identifies an event, the result is an event access with an associated instance expression of E.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
         '   with an associated instance expression of E.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         If m_First.Classification.IsValueClassification OrElse m_First.Classification.IsVariableClassification OrElse m_First.Classification.CanBeValueClassification Then
             Dim T As Mono.Cecil.TypeReference 'Descriptor
 
             If m_First.Classification.IsValueClassification Then
                 T = m_First.Classification.AsValueClassification.Type
             ElseIf m_First.Classification.IsVariableClassification Then
                 T = m_First.Classification.AsVariableClassification.Type
             ElseIf m_First.Classification.CanBeValueClassification Then
                 m_First = m_First.ReclassifyToValueExpression
                 result = m_First.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                 If result = False Then
                     If Info.IsEventResolution Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30506, Location)
                     Else
                         Helper.AddError(Compiler, Location, "Huh?")
                     End If
                 End If
                 Helper.Assert(m_First.Classification IsNot Nothing)
                 Helper.Assert(m_First.Classification.AsValueClassification IsNot Nothing)
                 T = m_First.Classification.AsValueClassification.Type
             Else
                 Throw New InternalException(Me)
             End If
 
             If CecilHelper.IsByRef(T) Then
                 m_First = m_First.DereferenceByRef()
                 T = m_First.ExpressionType
             End If
 
             '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
             '   a method group representing the instance constructors of the type of E with an associated 
             '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
             If m_Second.IsKeyword AndAlso m_Second.Keyword = KS.New Then
                 If TypeOf m_First Is InstanceExpression Then
                     Classification = New MethodGroupClassification(Me, m_First, typeArguments, Nothing, Helper.GetInstanceConstructors(T))
                     Return True
                 Else
                     Helper.AddError(Me)
                 End If
             End If
 
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Dim member As MemberCacheEntry
 
             member = Compiler.TypeManager.GetCache(T).LookupFlattened(Name, Me.FindFirstParent_IType.CecilType)
             If member Is Nothing Then
                 If Me.File.IsOptionStrictOn = False AndAlso Helper.CompareType(T, Compiler.TypeCache.System_Object) Then
                     Classification = New LateBoundAccessClassification(Me, m_First, Nothing, Name)
                     Return True
                 End If
 
                 member = Compiler.TypeManager.GetCache(T).LookupFlattened(Name, MemberVisibility.All)
                 If member Is Nothing OrElse member.Members.Count = 0 Then
                     If Helper.CompareType(T, Compiler.TypeCache.System_Object) Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30574, Me.Location) AndAlso result
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName) AndAlso result
                     End If
                 ElseIf member.Members.Count = 1 Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30390, Me.Location, Name, T.FullName, Helper.GetVisibilityString(member.Members(0))) AndAlso result
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30517, Me.Location, Name) AndAlso result
                 End If
             End If
 
             members = member.Members
             Dim withTypeArgs As IdentifierOrKeywordWithTypeArguments
             withTypeArgs = TryCast(m_Second, IdentifierOrKeywordWithTypeArguments)
             If withTypeArgs IsNot Nothing Then
                 members = Helper.FilterByTypeArguments(members, withTypeArgs.TypeArguments)
             End If
             members = Helper.FilterExternalInaccessible(Me.Compiler, members)
 
             If members.Count = 0 Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName) AndAlso result
                 If result = False Then Return result
             End If
 
             If members.Count > 0 Then
                 Dim first As Object = members(0)
                 '** If I identifies one or more methods, then the result is a method group with the associated type 
                 '   argument list and an associated instance expression of E.
                 If Helper.IsMethodDeclaration(first) Then
                     m_First = m_First.GetObjectReference
                     Classification = New MethodGroupClassification(Me, m_First, typeArguments, Nothing, members)
                     Return True
                 End If
                 '** If I identifies one or more properties, then the result is a property group with an 
                 '   associated instance expression of E.
                 If Helper.IsPropertyDeclaration(first) Then
                     m_First = m_First.GetObjectReference
                     Classification = New PropertyGroupClassification(Me, m_First, members)
                     Return True
                 End If
 
                 If members.Count > 1 Then Throw New InternalException(Me)
 
                 '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
                 '   and the reference occurs outside a constructor of the class in which the variable is declared 
                 '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
                 '   variable I in the object referenced by E. 
                 '   If T is a reference type, then the result is the variable I in the object referenced by E. 
                 '   Otherwise, if T is a value type and the expression E is classified as a variable, the result is 
                 '   a variable; otherwise the result is a value.
                 Dim var As VariableDeclaration = TryCast(first, VariableDeclaration)
                 Dim fld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
 
                 If var IsNot Nothing Then
                     Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
 
                     If var.Modifiers.Is(ModifierMasks.ReadOnly) AndAlso (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) <> var.Modifiers.Is(ModifierMasks.Shared)) Then
                         Classification = New ValueClassification(Me, var)
                         Return True
                     ElseIf CecilHelper.IsClass(T) Then
                         Classification = New VariableClassification(Me, var)
                         Return True
                     ElseIf CecilHelper.IsValueType(T) Then
                         If m_First.Classification.IsVariableClassification Then
                             Classification = New VariableClassification(Me, var)
                             Return True
                         ElseIf m_First.Classification.IsValueClassification Then
                             Classification = New ValueClassification(Me, var)
                             Return True
                         Else
                             Throw New InternalException(Me)
                         End If
                     Else
                         Throw New InternalException(Me)
                     End If
                 ElseIf fld IsNot Nothing Then
                     Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(fld)
                     If Helper.IsAccessible(Me, fD.Attributes, fld.DeclaringType, Me.FindFirstParent_IType.CecilType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30390, Location, fld.DeclaringType.FullName, fld.Name, Helper.ToString(fD.Attributes))
                     End If
 
                     Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
                     If fD.IsInitOnly AndAlso (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) <> fD.IsStatic) Then
                         If fD.IsStatic Then
                             Classification = New ValueClassification(Me, fld, Nothing)
                         Else
                             Classification = New ValueClassification(Me, fld, m_First)
                         End If
                         Return True
                     ElseIf CecilHelper.IsClass(T) Then
                         If fD.IsStatic Then
                             Classification = New VariableClassification(Me, fld, Nothing)
                         Else
                             Classification = New VariableClassification(Me, fld, m_First)
                         End If
                         Return True
                     ElseIf CecilHelper.IsValueType(T) Then
                         If m_First.Classification.IsVariableClassification Then
                             If Not TypeOf m_First Is InstanceExpression Then
                                 m_First = m_First.GetObjectReference
                             End If
                             If fD.IsStatic Then
                                 Classification = New VariableClassification(Me, fld, Nothing)
                             Else
                                 Classification = New VariableClassification(Me, fld, m_First)
                             End If
                             Return True
                         ElseIf m_First.Classification.IsValueClassification Then
                             If fD.IsStatic Then
                                 Classification = New ValueClassification(Me, fld, Nothing)
                             Else
                                 Classification = New ValueClassification(Me, fld, m_First)
                             End If
                             Return True
                         ElseIf m_First.Classification.CanBeValueClassification Then
                             m_First = m_First.ReclassifyToValueExpression
                             result = m_First.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
                             If fD.IsStatic Then
                                 Classification = New ValueClassification(Me, fld, Nothing)
                             Else
                                 Classification = New ValueClassification(Me, fld, m_First)
                             End If
                             Return True
                         Else
                             Throw New InternalException(Me)
                         End If
                     Else
                         Throw New InternalException(Me)
                     End If
                 End If
 
                 '** If I identifies an event, the result is an event access with an associated instance expression of E.
                 If Helper.IsEventDeclaration(first) Then
                     Dim red As EventDeclaration = TryCast(first, EventDeclaration)
                     If red Is Nothing AndAlso TypeOf first Is Mono.Cecil.EventReference Then
                         red = DirectCast(CecilHelper.FindDefinition(DirectCast(first, Mono.Cecil.EventReference)).Annotations(Compiler), EventDeclaration)
                     End If
                     If red IsNot Nothing Then
                         Classification = New EventAccessClassification(Me, red.EventDescriptor, m_First)
                         Return True
                     End If
                     Dim eInfo As Mono.Cecil.EventReference = TryCast(first, Mono.Cecil.EventReference)
                     If eInfo IsNot Nothing Then
                         Classification = New EventAccessClassification(Me, eInfo, m_First)
                         Return True
                     End If
                 End If
 
                 '** If I identifies a constant, then the result is the value of that constant.
                 Dim constant As ConstantDeclaration = TryCast(first, ConstantDeclaration)
                 If constant IsNot Nothing Then
                     Classification = New ValueClassification(Me, constant)
                     Return True
                 End If
 
                 '** If I identifies an enumeration member, then the result is the value of that enumeration member.
                 If Helper.IsEnumFieldDeclaration(Compiler, first) Then
                     Dim em As EnumMemberDeclaration = TryCast(first, EnumMemberDeclaration)
                     Dim emfld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
                     If em IsNot Nothing Then
                         Classification = New ValueClassification(Me, em)
                         Return True
                     ElseIf emfld IsNot Nothing Then
                         Classification = New ValueClassification(Me, emfld, Nothing)
                         Return True
                     End If
                 End If
 
                 '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
                 '   with an associated instance expression of E.
                 If T IsNot Nothing Then
                     'Dim td As TypeDescriptor = TryCast(T, TypeDescriptor)
                     Dim compresult As Boolean = Helper.CompareType(T, Compiler.TypeCache.System_Object)
                     If compresult Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 End If
                 '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
                 Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName)
                 result = False
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName)
                 result = False
             End If
         End If
 
         Compiler.Report.ShowMessage(Messages.VBNC30456, Location, Name, m_First.AsString)
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="737" endline="740"><![CDATA[
 
     Shared Function CreateAndParseTo(ByRef result As Expression) As Boolean
         Return result.Compiler.Report.ShowMessage(Messages.VBNC99997, result.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="741" endline="744"><![CDATA[
 
     Shared Function IsUnaryMe(ByVal Tm As tm) As Boolean
         Return Tm.CurrentToken.Equals(KS.Dot)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="745" endline="748"><![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.Dot)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="749" endline="753"><![CDATA[
 
     ReadOnly Property FirstExpression() As Expression
         Get
             Return m_First
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="754" endline="759"><![CDATA[
     End Property
 
     ReadOnly Property SecondExpression() As IdentifierOrKeyword
         Get
             Return m_Second
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="760" endline="765"><![CDATA[
     End Property
 
     ReadOnly Property CompleteName() As String
         Get
             Return m_First.ToString & "." & m_Second.Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="26" endline="29"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal MethodGroupClassification As MethodGroupClassification)
         MyBase.new(Parent)
         m_MethodGroup = MethodGroupClassification
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="30" endline="34"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_MethodGroup.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="35" endline="40"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_MethodGroup.ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="41" endline="78"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim arguments As ArgumentList = New ArgumentList(Me.Parent)
 
         If m_MethodGroup.Resolved = False Then
             result = m_MethodGroup.ResolveGroup(arguments) AndAlso result
         Else
             'm_FinalArguments = m_MethodGroup.
         End If
 
         If result = False Then
             result = m_MethodGroup.ResolveGroup(arguments, True) AndAlso result
             Return False
         End If
 
         Helper.Assert(m_MethodGroup.ResolvedMethod IsNot Nothing)
 
         If m_MethodGroup.ResolvedMethodInfo IsNot Nothing Then
             m_ExpressionType = m_MethodGroup.ResolvedMethodInfo.ReturnType
         ElseIf m_MethodGroup.ResolvedConstructor IsNot Nothing Then
             m_ExpressionType = m_MethodGroup.ResolvedConstructor.DeclaringType
         Else
             Throw New InternalException(Me)
         End If
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         If Helper.CompareType(Compiler.TypeCache.System_Void, m_ExpressionType) Then
             Me.Classification = New VoidClassification(Me)
             result = ReportReclassifyToValueErrorMessage()
         Else
             Me.Classification = New ValueClassification(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="79" endline="88"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_MethodGroup.Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_MethodGroup.InstanceExpression, m_MethodGroup.FinalArguments, Helper.GetMethodOrMethodReference(Compiler, m_MethodGroup.ResolvedMethod))
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="89" endline="93"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MissingExpression.vb" startline="27" endline="30"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Helper.Stop() 'A missing expression doesn't know how to emit itself.
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MissingExpression.vb" startline="31" endline="35"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return New MissingType(Me.Compiler)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MissingExpression.vb" startline="36" endline="40"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MissingExpression.vb" startline="41" endline="44"><![CDATA[
 
     Sub New(ByVal Parent As Expression)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="28" endline="30"><![CDATA[
         Get
             Return "MyBase"
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="31" endline="35"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="36" endline="43"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="44" endline="54"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim tpparent As IType = Me.FindFirstParent(Of IType)()
         m_ExpressionType = tpparent.BaseType
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyClassExpression.vb" startline="28" endline="30"><![CDATA[
         Get
             Return "MyClass"
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyClassExpression.vb" startline="31" endline="39"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyClassExpression.vb" startline="40" endline="43"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamedArgument.vb" startline="26" endline="28"><![CDATA[
         Get
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamedArgument.vb" startline="29" endline="34"><![CDATA[
     End Property
 
     Overrides ReadOnly Property AsString() As String
         Get
             Return m_Name & " 
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamedArgument.vb" startline="35" endline="39"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamedArgument.vb" startline="40" endline="44"><![CDATA[
 
     Shadows Sub Init(ByVal Name As String, ByVal Expression As Expression)
         MyBase.Init(Expression)
         m_Name = Name
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamedArgument.vb" startline="45" endline="49"><![CDATA[
 
     Public ReadOnly Property Name() As String
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamedArgument.vb" startline="50" endline="54"><![CDATA[
     End Property
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.IsIdentifierOrKeyword AndAlso tm.PeekToken = KS.Colon AndAlso tm.PeekToken(2) = KS.Equals
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamedArgument.vb" startline="55" endline="58"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return MyBase.ResolveTypeReferences()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamespaceExpression.vb" startline="30" endline="32"><![CDATA[
         Get
             Return m_NS
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamespaceExpression.vb" startline="33" endline="39"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal ns As [Namespace])
         MyBase.New(Parent)
         If ns Is Nothing Then Throw New InternalException(Me)
         m_NS = ns
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamespaceExpression.vb" startline="40" endline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="32" endline="34"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Expression.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="35" endline="38"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="39" endline="42"><![CDATA[
 
     Sub Init(ByVal Expression As Expression)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="43" endline="50"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info) AndAlso result 'Helper.NotImplemented()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="51" endline="54"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.[New])
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="55" endline="58"><![CDATA[
 
     Shared Function CreateAndParseTo(ByRef result As Expression) As Boolean
         Return result.Compiler.Report.ShowMessage(Messages.VBNC99997, result.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="59" endline="67"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
         Classification = m_Expression.Classification
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="68" endline="72"><![CDATA[
 
     ReadOnly Property IsArrayCreationExpression() As Boolean
         Get
             Return TypeOf m_Expression Is ArrayCreationExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="73" endline="78"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_Expression.ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NothingConstantExpression.vb" startline="23" endline="30"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Emitter.EmitLoadNull(Info)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NothingConstantExpression.vb" startline="31" endline="34"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent, Nothing, Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NothingConstantExpression.vb" startline="35" endline="39"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Classification = New ValueClassification(Me, Nothing, System.DBNull.Value)
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NothingConstantExpression.vb" startline="40" endline="44"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NothingConstantExpression.vb" startline="45" endline="50"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return System.DBNull.Value
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NothingConstantExpression.vb" startline="51" endline="56"><![CDATA[
     End Property
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Return New NothingConstantExpression(NewParent)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="34" endline="36"><![CDATA[
     Shared Function CreateAndParseTo(ByRef result As Expression) As Boolean
         Return result.Compiler.Report.ShowMessage(Messages.VBNC99997, result.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="37" endline="44"><![CDATA[
 
     Shared Function IsUnaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="45" endline="52"><![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="53" endline="60"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="61" endline="64"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="32" endline="34"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Expression.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="35" endline="38"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="39" endline="43"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.New(Parent)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="44" endline="47"><![CDATA[
 
     Sub Init(ByVal Expression As Expression)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="48" endline="63"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             If Me.Classification.IsValueClassification Then
                 result = m_Expression.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="64" endline="67"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.LParenthesis)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="68" endline="72"><![CDATA[
 
     ReadOnly Property Expression() As Expression
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="73" endline="87"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="88" endline="92"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_Expression.ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="93" endline="98"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_Expression.ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="99" endline="104"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_Expression.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PositionalArgument.vb" startline="35" endline="39"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Position As Integer, ByVal Expression As Expression)
         MyBase.New(Parent)
         MyBase.Init(Expression)
         m_Position = Position
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PositionalArgument.vb" startline="40" endline="48"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PositionalArgument.vb" startline="49" endline="58"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Position">0 based.</param>
     ''' <remarks></remarks>
     Shadows Sub Init(ByVal Position As Integer, ByVal Expression As Expression)
         MyBase.Init(Expression)
         m_Position = Position
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PositionalArgument.vb" startline="59" endline="67"><![CDATA[
 
     ''' <summary>
     ''' The position of the argument.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property Position() As Integer
         Get
             Return m_position
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PositionalArgument.vb" startline="68" endline="72"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return MyBase.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="27" endline="35"><![CDATA[
         Get
             Dim result As String = ""
             If m_PropertyAccess.InstanceExpression IsNot Nothing Then
                 result = m_PropertyAccess.InstanceExpression.AsString & "."
             End If
             result &= m_PropertyAccess.ResolvedProperty.Name
             result &= "(" & m_PropertyAccess.Parameters.AsString & ")"
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="36" endline="41"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_PropertyAccess.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="42" endline="47"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_PropertyAccess.ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="48" endline="53"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal PropertyAccess As PropertyAccessClassification)
         MyBase.new(Parent)
         m_PropertyAccess = PropertyAccess
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="54" endline="65"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_ExpressionType = m_PropertyAccess.Type
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="66" endline="77"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim propD As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(m_PropertyAccess.ResolvedProperty)
         Dim methodD As Mono.Cecil.MethodReference = propD.GetMethod
         Dim methodR As Mono.Cecil.MethodReference = CecilHelper.GetCorrectMember(methodD, m_PropertyAccess.ResolvedProperty.DeclaringType, True)
         Dim methodE As Mono.Cecil.MethodReference = Helper.GetMethodOrMethodReference(Compiler, methodR)
 
         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_PropertyAccess.InstanceExpression, m_PropertyAccess.Parameters, methodE) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="78" endline="82"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="27" endline="29"><![CDATA[
         Get
             Return m_PropertyGroup.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="30" endline="35"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_PropertyGroup.ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="36" endline="41"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal PropertyGroupClassification As PropertyGroupClassification)
         MyBase.new(Parent)
         m_PropertyGroup = PropertyGroupClassification
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="42" endline="67"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_PropertyGroup IsNot Nothing, "m_PropertyGroup Is Nothing")
 
         If m_PropertyGroup.IsResolved = False OrElse m_PropertyGroup.ResolvedProperty Is Nothing Then
             result = m_PropertyGroup.ResolveGroup(New ArgumentList(Me)) AndAlso result
 
             If result = False Then
                 Compiler.Report.WriteLine("Property group resolution failed (unrecoverably), showing log")
                 Helper.LOGMETHODRESOLUTION = True
                 m_PropertyGroup.ResolveGroup(New ArgumentList(Me))
                 Return Helper.AddError(Me, "Failed to resolve property group.")
             End If
         End If
 
         Helper.Assert(m_PropertyGroup.ResolvedProperty IsNot Nothing, "m_PropertyGroup.ResolvedProperty Is Nothing")
         m_ExpressionType = m_PropertyGroup.ResolvedProperty.PropertyType
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New PropertyAccessClassification(Me, m_PropertyGroup.ResolvedProperty, m_PropertyGroup.InstanceExpression, m_PropertyGroup.Parameters)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="68" endline="75"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="76" endline="80"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="27" endline="34"><![CDATA[
         Get
             Dim result As String = ""
             If m_PropertyGroup.InstanceExpression IsNot Nothing Then
                 result = m_PropertyGroup.InstanceExpression.AsString & "."
             End If
             result &= m_PropertyGroup.Group(0).Name
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="35" endline="40"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_PropertyGroup.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_PropertyGroup.ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="47" endline="52"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal PropertyGroupClassification As PropertyGroupClassification)
         MyBase.new(Parent)
         m_PropertyGroup = PropertyGroupClassification
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="53" endline="72"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_PropertyGroup.IsResolved = False OrElse m_PropertyGroup.ResolvedProperty Is Nothing Then
             result = m_PropertyGroup.ResolveGroup(New ArgumentList(Me)) AndAlso result
         End If
 
         If result = False Then
             Return False
         End If
 
         m_ExpressionType = m_PropertyGroup.ResolvedProperty.PropertyType
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="73" endline="84"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim method As Mono.Cecil.MethodReference
 
         method = CecilHelper.FindDefinition(m_PropertyGroup.ResolvedProperty).GetMethod
         method = CecilHelper.GetCorrectMember(method, m_PropertyGroup.ResolvedProperty.DeclaringType)
 
         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_PropertyGroup.InstanceExpression, m_PropertyGroup.Parameters, method) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="85" endline="89"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="32" endline="34"><![CDATA[
     Shared Function CreateAndParseTo(ByRef result As Expression) As Boolean
         Return result.Compiler.Report.ShowMessage(Messages.VBNC99997, result.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="35" endline="42"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         result = LiteralExpression.IsMe(tm) OrElse ParenthesizedExpression.IsMe(tm) OrElse InstanceExpression.IsMe(tm) OrElse SimpleNameExpression.IsMe(tm) OrElse AddressOfExpression.IsMe(tm)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="43" endline="50"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="51" endline="54"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="39" endline="41"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="42" endline="46"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal TypeArgumentList As TypeArgumentList)
         m_Identifier = Identifier
         m_TypeArgumentList = TypeArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="47" endline="51"><![CDATA[
 
     ReadOnly Property TypeArguments As TypeArgumentList
         Get
             Return m_TypeArgumentList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="52" endline="61"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property AsString() As String
         Get
             If m_TypeArgumentList Is Nothing OrElse m_TypeArgumentList.Count = 0 Then
                 Return m_Identifier.Identifier
             Else
                 Return m_Identifier.Identifier & "(Of <type arguments>)"
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="62" endline="74"><![CDATA[
     End Property
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleNameExpression(NewParent)
         If m_TypeArgumentList Is Nothing Then
             result.Init(m_Identifier, Nothing)
         Else
             result.Init(m_Identifier, m_TypeArgumentList.Clone(result))
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="75" endline="79"><![CDATA[
 
     Property Identifier() As Identifier
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="80" endline="82"><![CDATA[
         Set(ByVal value As Identifier)
             m_Identifier = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="83" endline="110"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Dim result As Mono.Cecil.TypeReference
             Select Case Classification.Classification
                 Case ExpressionClassification.Classifications.Value
                     result = Classification.AsValueClassification.Type
                 Case ExpressionClassification.Classifications.Variable
                     result = Classification.AsVariableClassification.Type
                 Case ExpressionClassification.Classifications.Type
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                     result = Nothing
                 Case ExpressionClassification.Classifications.Namespace
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                     result = Nothing
                 Case ExpressionClassification.Classifications.PropertyGroup
                     result = Classification.AsPropertyGroup.Type
                 Case ExpressionClassification.Classifications.PropertyAccess
                     result = Classification.AsPropertyAccess.Type
                 Case ExpressionClassification.Classifications.MethodGroup
                     result = Classification.AsMethodGroupClassification.Type
                 Case Else
                     Throw New InternalException(Me)
             End Select
             Helper.Assert(result IsNot Nothing)
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="120" endline="123"><![CDATA[
 
     Public Overrides Function ToString() As String
         Return m_Identifier.Identifier
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="124" endline="183"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing OrElse Info.RHSExpression IsNot Nothing)
 
         If Info.IsRHS Then
             If Info.DesiredType IsNot Nothing Then
                 If CecilHelper.IsGenericParameter(Info.DesiredType) AndAlso CecilHelper.IsGenericParameter(Me.ExpressionType) Then
                     Helper.Assert(Me.Classification.CanBeValueClassification)
                     Dim tmp As Expression
                     tmp = Me.ReclassifyToValueExpression()
                     result = tmp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                     result = tmp.GenerateCode(Info) AndAlso result
                 ElseIf CecilHelper.IsByRef(Info.DesiredType) = False AndAlso CecilHelper.IsGenericParameter(Me.ExpressionType) = False Then
                     If Me.Classification.CanBeValueClassification Then
                         Dim tmp As Expression
                         tmp = Me.ReclassifyToValueExpression()
                         result = tmp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                         result = tmp.Classification.GenerateCode(Info) AndAlso result
                     Else
                         Throw New InternalException(Me)
                     End If
                 Else
                     If Me.Classification.IsVariableClassification Then
                         If CecilHelper.IsByRef(Me.ExpressionType) OrElse CecilHelper.IsArray(Me.ExpressionType) Then
                             Emitter.EmitLoadVariable(Info, Me.Classification.AsVariableClassification)
                         Else
                             Emitter.EmitLoadVariableLocation(Info, Me.Classification.AsVariableClassification)
                         End If
                     Else
                         Throw New InternalException(Me)
                     End If
                 End If
             Else
                 If Me.Classification.CanBeValueClassification Then
                     Dim tmp As Expression
                     tmp = Me.ReclassifyToValueExpression()
                     result = tmp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                     result = tmp.GenerateCode(Info) AndAlso result
                 Else
                     Throw New InternalException(Me)
                 End If
             End If
         ElseIf Info.IsLHS Then
             If Me.Classification.IsVariableClassification Then
                 result = Me.Classification.AsVariableClassification.GenerateCode(Info) AndAlso result
             ElseIf Me.Classification.IsPropertyGroupClassification Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             ElseIf Me.Classification.IsValueClassification Then
                 Throw New InternalException(Me)
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="184" endline="188"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return Classification.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="189" endline="194"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return Classification.ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="195" endline="199"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.IsIdentifier
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="200" endline="564"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim Name As String = m_Identifier.Identifier
 
         If False Then
             Helper.Stop()
         End If
 
         '---------------------------------------------------------------------------------------------------------
         'A simple name expression consists of a single identifier followed by an optional type argument list. 
         'The name is resolved and classified as follows
         '---------------------------------------------------------------------------------------------------------
         '* Starting with the immediately enclosing block and continuing with each enclosing outer block (if any),
         '  if the identifier matches the name of a local variable, static variable, constant local, method type 
         '  parameter, or parameter, then the identifier refers to the matching entity. The expression is 
         '  classified as a variable if it is a local variable, static variable, or parameter. The expression 
         '  is classified as a type if it is a method type parameter. The expression is classified as a value 
         '  if it is a constant local with the following exception. If the local variable matched is the 
         '  implicit function or Get accessor return local variable, and the expression is part of an 
         '  invocation expression, invocation statement, or an AddressOf expression, then no match occurs and 
         '  resolution continues.
         '---------------------------------------------------------------------------------------------------------
         '* For each nested type containing the expression, starting from the innermost and going to the 
         '  outermost, if a lookup of the identifier in the type produces a match with an accessible member
         '** If the matching type member is a type parameter, then the result is classified as a type and 
         '   is the matching type parameter.
         '** Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
         '   type member, then the result is the same as a member access of the form Me.E, where E is 
         '   the identifier.
         '** Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
         '   type containing the matching member and E is the identifier. In this case, it is an error for the 
         '   identifier to refer to a non-shared member.
         '---------------------------------------------------------------------------------------------------------
         '* For each nested namespace, starting from the innermost and going to the outermost namespace, 
         '  do the following
         '** If the namespace contains an accessible namespace member with the given name, then the identifier
         '   refers to that member and, depending on the member, is classified as a namespace or a type.
         '** Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the 
         '   result is exactly the same as a member access of the form M.E, where M is the standard module 
         '   containing the matching member and E is the identifier. If the identifier matches accessible type 
         '   members in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If the source file has one or more import aliases, and the identifier matches the name of one of them,
         '   then the identifier refers to that namespace or type.
         '---------------------------------------------------------------------------------------------------------
         '* If the source file containing the name reference has one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name of 
         '   an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
         '   a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then 
         '   the result is exactly the same as a member access of the form M.E, where M is the standard 
         '   module containing the matching member and E is the identifier. If the identifier matches 
         '   accessible type members in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more import aliases, and the identifier matches 
         '  the name of one of them, then the identifier refers to that namespace or type.
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name 
         '   of an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than 
         '   one import, a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the result 
         '   is exactly the same as a member access of the form M.E, where M is the standard module containing 
         '   the matching member and E is the identifier. If the identifier matches accessible type members in 
         '   more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* Otherwise, the name given by the identifier is undefined and a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         'If a simple name with a type argument list resolves to anything other than a type or method, 
         'a compile time error occurs. If a type argument list is supplied, only types with the same arity as 
         'the type argument list are considered but type members, including methods with different arities, 
         'are still considered. This is because type inference can be used to fill in missing type arguments. 
         'As a result, names with type arguments may bind differently to types and methods
         '---------------------------------------------------------------------------------------------------------
 
         If m_TypeArgumentList IsNot Nothing Then If m_TypeArgumentList.ResolveCode(Info) = False Then Return False
 
         '* Starting with the immediately enclosing block and continuing with each enclosing outer block (if any),
         '  if the identifier matches the name of a local variable, static variable, constant local, method type 
         '  parameter, or parameter, then the identifier refers to the matching entity. 
         '  - The expression is classified as a variable if it is a local variable, static variable, or parameter.
         '  - The expression is classified as a type if it is a method type parameter. 
         '  - The expression is classified as a value if it is a constant local.
         '  * With the following exception
         '  If the local variable matched is the implicit function or Get accessor return local variable, 
         '  and the expression is part of an  invocation expression, invocation statement, 
         '  or an AddressOf expression, then no match occurs and resolution continues.
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         While block IsNot Nothing
             Dim var As IAttributableNamedDeclaration
             var = block.FindVariable(Name)
             If TypeOf var Is ConstantDeclaration Then
                 'The expression is classified as a value if it is a constant local (...)
                 Classification = New ValueClassification(Me, DirectCast(var, ConstantDeclaration))
                 Return True
             ElseIf TypeOf var Is VariableDeclaration Then
                 'The expression is classified as a variable if it is a local variable, static variable (...)
                 Dim varDecl As VariableDeclaration
                 varDecl = DirectCast(var, VariableDeclaration)
                 If varDecl.Modifiers.Is(ModifierMasks.Static) AndAlso varDecl.DeclaringMethod.IsShared = False Then
                     Classification = New VariableClassification(Me, varDecl, CreateMeExpression)
                 ElseIf varDecl.Modifiers.Is(ModifierMasks.Const) Then
                     Classification = New ValueClassification(Me, varDecl)
                 Else
                     Classification = New VariableClassification(Me, varDecl)
                 End If
                 Return True
             ElseIf var IsNot Nothing Then
                 Throw New InternalException(Me)
             End If
             block = block.FindFirstParent(Of CodeBlock)()
         End While
         While block IsNot Nothing
             Dim var As IAttributableNamedDeclaration
             var = block.FindVariable(Name)
             If TypeOf var Is ConstantDeclaration Then
                 'The expression is classified as a value if it is a constant local (...)
                 Classification = New ValueClassification(Me, DirectCast(var, ConstantDeclaration))
                 Return True
             ElseIf TypeOf var Is VariableDeclaration Then
                 'The expression is classified as a variable if it is a local variable, static variable (...)
                 Dim varDecl As VariableDeclaration
                 varDecl = DirectCast(var, VariableDeclaration)
                 If varDecl.Modifiers.Is(ModifierMasks.Static) AndAlso varDecl.DeclaringMethod.IsShared = False Then
                     Classification = New VariableClassification(Me, varDecl, CreateMeExpression)
                 ElseIf varDecl.Modifiers.Is(ModifierMasks.Const) Then
                     Classification = New ValueClassification(Me, varDecl)
                 Else
                     Classification = New VariableClassification(Me, varDecl)
                 End If
                 Return True
             ElseIf var IsNot Nothing Then
                 Throw New InternalException(Me)
             End If
             block = block.FindFirstParent(Of CodeBlock)()
         End While
 
         Dim method As IMethod
         method = Me.FindFirstParent(Of IMethod)()
         If method IsNot Nothing Then
             If method.Signature.TypeParameters IsNot Nothing Then
                 Dim typeparam As TypeParameter = method.Signature.TypeParameters.Parameters.Item(Name)
                 If typeparam IsNot Nothing Then
                     'The expression is classified as a type if it is a method type parameter. 
                     Classification = New TypeClassification(Me, typeparam)
                     Return True
                 End If
             End If
         End If
 
         If method IsNot Nothing Then
             If method.Signature.Parameters IsNot Nothing Then
                 Dim param As Parameter = method.Signature.Parameters.Item(Name)
                 If param IsNot Nothing Then
                     'The expression is classified as a variable if it is a (...) parameter
                     Classification = New VariableClassification(Me, param)
                     Return True
                 End If
             End If
         End If
 
         '  If the local variable matched is the implicit function or Get accessor return local variable, 
         '  and the expression is part of an  invocation expression, invocation statement, 
         '  or an AddressOf expression, then no match occurs and resolution continues.
         If method IsNot Nothing Then
             If method.HasReturnValue AndAlso Info.SkipFunctionReturnVariable = False Then
                 Dim pgd As PropertyGetDeclaration = TryCast(method, PropertyGetDeclaration)
                 If pgd IsNot Nothing AndAlso Helper.CompareName(pgd.PropertySignature.Name, Name) Then
                     'The expression is classified as a variable if it is a local variable, static variable (...)
                     Classification = New VariableClassification(Me, method)
                     Return True
                 ElseIf Helper.CompareName(method.Name, Name) Then
                     'The expression is classified as a variable if it is a local variable, static variable (...)
                     Classification = New VariableClassification(Me, method)
                     Return True
                 End If
             End If
         End If
 
         '* For each nested type containing the expression, starting from the innermost and going to the 
         '  outermost, if a lookup of the identifier in the type produces a match with an accessible member
         '** If the matching type member is a type parameter, then the result is classified as a type and 
         '   is the matching type parameter.
         '** Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
         '   type member, then the result is the same as a member access of the form Me.E, where E is 
         '   the identifier.
         '** Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
         '   type containing the matching member and E is the identifier. In this case, it is an error for the 
         '   identifier to refer to a non-shared member.
         Dim firstcontainer As IType = Me.FindFirstParent(Of IType)()
         Dim container As IType = firstcontainer
         While container IsNot Nothing
             Dim constructable As IConstructable = TryCast(container, IConstructable)
             If constructable IsNot Nothing AndAlso constructable.TypeParameters IsNot Nothing Then
                 Dim typeparam As TypeParameter = constructable.TypeParameters.Parameters.Item(Name)
                 If typeparam IsNot Nothing Then
                     'If the matching type member is a type parameter, then the result is classified 
                     'as a type and is the matching type parameter.
                     Classification = New TypeClassification(Me, typeparam)
                     Return True
                 End If
             End If
 
             Dim cache As MemberCacheEntry
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             cache = Compiler.TypeManager.GetCache(container.CecilType).LookupFlattened(Name)
             If cache Is Nothing Then
                 members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Else
                 members = cache.Members
                 members = Helper.FilterExternalInaccessible(Compiler, members)
             End If
 
 #If EXTENDEDDEBUG Then
             Compiler.Report.WriteLine("Found " & membersArray.Length & " members, after filtering by name it's " & members.Count & " members")
 #End If
 
             Helper.ApplyTypeArguments(Me, members, m_TypeArgumentList)
 
             If members.Count > 0 Then
                 'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
                 'type member, then the result is the same as a member access of the form Me.E, where E is 
                 'the identifier.
 
                 'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
                 'type containing the matching member and E is the identifier. In this case, it is an error for the 
                 'identifier to refer to a non-shared member.
 
                 'NOTE
                 '(it can resolve to a method group with several methods, some shared, some not. 
                 'So we create a classification with an instance expression, if the member is 
                 'shared, the instance expression should not be used.
                 Dim hasInstanceExpression As Boolean
                 Dim hasNotInstanceExpression As Boolean
 
                 For i As Integer = 0 To members.Count - 1
                     Dim member As Mono.Cecil.MemberReference = members(i)
                     If CecilHelper.GetMemberType(member) = MemberTypes.TypeInfo OrElse CecilHelper.GetMemberType(member) = MemberTypes.NestedType Then
                         hasNotInstanceExpression = True
                     ElseIf Helper.IsShared(member) Then
                         hasNotInstanceExpression = True
                     Else
                         hasInstanceExpression = True
                     End If
                 Next
 
                 If container Is firstcontainer AndAlso hasInstanceExpression Then
                     'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
                     'type member, then the result is the same as a member access of the form Me.E, where E is 
                     'the identifier.
                     Classification = GetMeClassification(members, firstcontainer)
                     Return True
                 Else
                     'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
                     'type containing the matching member and E is the identifier. In this case, it is an error for the                    
                     'identifier to refer to a non-shared member.
                     Classification = GetTypeClassification(members, firstcontainer)
                     Return True
                 End If
             End If
             container = DirectCast(container, BaseObject).FindFirstParent(Of IType)()
         End While
         While container IsNot Nothing
             Dim constructable As IConstructable = TryCast(container, IConstructable)
             If constructable IsNot Nothing AndAlso constructable.TypeParameters IsNot Nothing Then
                 Dim typeparam As TypeParameter = constructable.TypeParameters.Parameters.Item(Name)
                 If typeparam IsNot Nothing Then
                     'If the matching type member is a type parameter, then the result is classified 
                     'as a type and is the matching type parameter.
                     Classification = New TypeClassification(Me, typeparam)
                     Return True
                 End If
             End If
 
             Dim cache As MemberCacheEntry
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             cache = Compiler.TypeManager.GetCache(container.CecilType).LookupFlattened(Name)
             If cache Is Nothing Then
                 members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Else
                 members = cache.Members
                 members = Helper.FilterExternalInaccessible(Compiler, members)
             End If
 
 #If EXTENDEDDEBUG Then
             Compiler.Report.WriteLine("Found " & membersArray.Length & " members, after filtering by name it's " & members.Count & " members")
 #End If
 
             Helper.ApplyTypeArguments(Me, members, m_TypeArgumentList)
 
             If members.Count > 0 Then
                 'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
                 'type member, then the result is the same as a member access of the form Me.E, where E is 
                 'the identifier.
 
                 'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
                 'type containing the matching member and E is the identifier. In this case, it is an error for the 
                 'identifier to refer to a non-shared member.
 
                 'NOTE
                 '(it can resolve to a method group with several methods, some shared, some not. 
                 'So we create a classification with an instance expression, if the member is 
                 'shared, the instance expression should not be used.
                 Dim hasInstanceExpression As Boolean
                 Dim hasNotInstanceExpression As Boolean
 
                 For i As Integer = 0 To members.Count - 1
                     Dim member As Mono.Cecil.MemberReference = members(i)
                     If CecilHelper.GetMemberType(member) = MemberTypes.TypeInfo OrElse CecilHelper.GetMemberType(member) = MemberTypes.NestedType Then
                         hasNotInstanceExpression = True
                     ElseIf Helper.IsShared(member) Then
                         hasNotInstanceExpression = True
                     Else
                         hasInstanceExpression = True
                     End If
                 Next
 
                 If container Is firstcontainer AndAlso hasInstanceExpression Then
                     'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
                     'type member, then the result is the same as a member access of the form Me.E, where E is 
                     'the identifier.
                     Classification = GetMeClassification(members, firstcontainer)
                     Return True
                 Else
                     'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
                     'type containing the matching member and E is the identifier. In this case, it is an error for the                    
                     'identifier to refer to a non-shared member.
                     Classification = GetTypeClassification(members, firstcontainer)
                     Return True
                 End If
             End If
             container = DirectCast(container, BaseObject).FindFirstParent(Of IType)()
         End While
 
         '* For each nested namespace, starting from the innermost and going to the outermost namespace, 
         '  do the following
         '** If the namespace contains an accessible namespace member with the given name, then the identifier
         '   refers to that member and, depending on the member, is classified as a namespace or a type.
         '** Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the 
         '   result is exactly the same as a member access of the form M.E, where M is the standard module 
         '   containing the matching member and E is the identifier. If the identifier matches accessible type 
         '   members in more than one standard module, a compile-time error occurs.
         Dim currentNS As String = Nothing
         If firstcontainer IsNot Nothing Then currentNS = firstcontainer.Namespace
         While currentNS IsNot Nothing
             Dim foundType As Mono.Cecil.TypeReference
             foundType = Compiler.TypeManager.GetTypesByNamespace(currentNS).Item(Name)
             If foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             End If
             If currentNS <> "" Then
                 Dim foundNS As [Namespace]
                 foundNS = Compiler.TypeManager.Namespaces(currentNS & "." & Name)
                 If foundNS IsNot Nothing Then
                     Classification = New NamespaceClassification(Me, foundNS)
                     Return True
                 End If
             End If
 
             'Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
             'lookup of the identifier produces an accessible match in exactly one standard module, then the 
             'result is exactly the same as a member access of the form M.E, where M is the standard module 
             'containing the matching member and E is the identifier. If the identifier matches accessible type 
             'members in more than one standard module, a compile-time error occurs.
             Dim modulemembers As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             modulemembers = Helper.GetMembersOfTypes(Compiler, Compiler.TypeManager.GetModulesByNamespace(currentNS), Name)
             If modulemembers Is Nothing Then
                 'do nothing
             ElseIf modulemembers.Count >= 1 Then
                 'Check that they're all from the same module
                 For i As Integer = 1 To modulemembers.Count - 1
                     If Helper.CompareType(modulemembers(0).DeclaringType, modulemembers(i).DeclaringType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30562, Me.Location, Name, modulemembers(0).DeclaringType.Name, modulemembers(i).DeclaringType.Name)
                     End If
                 Next
                 Return SetClassificationOfModuleMembers(modulemembers)
             End If
 
             currentNS = Helper.GetNamespaceParent(currentNS)
         End While
         While currentNS IsNot Nothing
             Dim foundType As Mono.Cecil.TypeReference
             foundType = Compiler.TypeManager.GetTypesByNamespace(currentNS).Item(Name)
             If foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             End If
             If currentNS <> "" Then
                 Dim foundNS As [Namespace]
                 foundNS = Compiler.TypeManager.Namespaces(currentNS & "." & Name)
                 If foundNS IsNot Nothing Then
                     Classification = New NamespaceClassification(Me, foundNS)
                     Return True
                 End If
             End If
 
             'Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
             'lookup of the identifier produces an accessible match in exactly one standard module, then the 
             'result is exactly the same as a member access of the form M.E, where M is the standard module 
             'containing the matching member and E is the identifier. If the identifier matches accessible type 
             'members in more than one standard module, a compile-time error occurs.
             Dim modulemembers As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             modulemembers = Helper.GetMembersOfTypes(Compiler, Compiler.TypeManager.GetModulesByNamespace(currentNS), Name)
             If modulemembers Is Nothing Then
                 'do nothing
             ElseIf modulemembers.Count >= 1 Then
                 'Check that they're all from the same module
                 For i As Integer = 1 To modulemembers.Count - 1
                     If Helper.CompareType(modulemembers(0).DeclaringType, modulemembers(i).DeclaringType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30562, Me.Location, Name, modulemembers(0).DeclaringType.Name, modulemembers(i).DeclaringType.Name)
                     End If
                 Next
                 Return SetClassificationOfModuleMembers(modulemembers)
             End If
 
             currentNS = Helper.GetNamespaceParent(currentNS)
         End While
         If CheckOutermostNamespace(Name) Then Return True
 
         '* If the source file has one or more import aliases, and the identifier matches the name of one of them,
         '   then the identifier refers to that namespace or type.
         If ResolveAliasImports(Me.Location.File(Compiler).Imports, Name) Then Return True
 
         '* If the source file containing the name reference has one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name of 
         '   an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
         '   a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then 
         '   the result is exactly the same as a member access of the form M.E, where M is the standard 
         '   module containing the matching member and E is the identifier. If the identifier matches 
         '   accessible type members in more than one standard module, a compile-time error occurs.
         If ResolveImports(Me.Location.File(Compiler).Imports, Name) Then Return True
 
         '* If the compilation environment defines one or more import aliases, and the identifier matches 
         '  the name of one of them, then the identifier refers to that namespace or type.
         If ResolveAliasImports(Me.Compiler.CommandLine.Imports.Clauses, Name) Then Return True
 
         '* If the compilation environment defines one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name 
         '   of an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than 
         '   one import, a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the result 
         '   is exactly the same as a member access of the form M.E, where M is the standard module containing 
         '   the matching member and E is the identifier. If the identifier matches accessible type members in 
         '   more than one standard module, a compile-time error occurs.
         If ResolveImports(Me.Compiler.CommandLine.Imports.Clauses, Name) Then Return True
 
         If Location.File(Compiler).IsOptionExplicitOn = False AndAlso Info.CanBeImplicitSimpleName Then
             Dim parent_method As MethodBaseDeclaration
             parent_method = Me.FindFirstParent(Of MethodBaseDeclaration)()
 
             If method IsNot Nothing Then
                 Dim varD As LocalVariableDeclaration
                 Dim varType As Mono.Cecil.TypeReference
                 If m_Identifier.HasTypeCharacter Then
                     varType = TypeCharacters.TypeCharacterToType(Compiler, m_Identifier.TypeCharacter)
                 Else
                     varType = Compiler.TypeCache.System_Object
                 End If
                 varD = New LocalVariableDeclaration(parent_method.Code, Nothing, m_Identifier, False, Nothing, Nothing, Nothing)
                 varD.Init(Nothing, m_Identifier.Identifier, varType)
                 parent_method.Code.AddVariable(varD)
                 Me.Classification = New VariableClassification(Me, varD)
                 Return True
             End If
         End If
 
         'Check if Local Type Inference is enabled        
         If InferEnabled Then
             InferPossible = True
             Return False
         End If
 
         '* Otherwise, the name given by the identifier is undefined and a compile-time error occurs.
         Compiler.Report.ShowMessage(Messages.VBNC30451, Me.Location, Name)
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="565" endline="635"><![CDATA[
 
     Private Function GetTypeClassification(ByVal members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal type As IType) As ExpressionClassification
         'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
         'type containing the matching member and E is the identifier. In this case, it is an error for the 
         'identifier to refer to a non-shared member.
 
         Dim first As Mono.Cecil.MemberReference = members(0)
         '* If E is a built-in type or an expression classified as a type, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
 
         '** If I is the keyword New, then a compile-time error occurs.
         '(not applicable)
 
         '** If I identifies one or more methods, then the result is a method group with the associated 
         '   type argument list and no associated instance expression.
         If Helper.IsMethodDeclaration(first) Then
             Return New MethodGroupClassification(Me, Nothing, m_TypeArgumentList, Nothing, members)
         End If
 
         '** If I identifies one or more properties, then the result is a property group with no associated 
         '   instance expression.
         If Helper.IsPropertyDeclaration(first) Then
             Return New PropertyGroupClassification(Me, Nothing, members)
         End If
 
         If members.Count > 1 Then Throw New InternalException(Me)
 
         '** If I identifies a type, then the result is that type.
         If Helper.IsTypeDeclaration(first) Then
             Return New TypeClassification(Me, first)
         End If
 
         '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
         '   outside the shared constructor of the type in which the variable is declared, then the result is the 
         '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
         If Helper.IsFieldDeclaration(first) Then
             Dim var As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
             Dim varD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(var)
             Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
             If varD.IsStatic AndAlso varD.IsInitOnly AndAlso _
              (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) = False) Then
                 Return New ValueClassification(Me, var, Nothing)
             Else
                 Return New VariableClassification(Me, var, Nothing)
             End If
         End If
 
         '** If I identifies a shared event, the result is an event access with no associated instance expression.
         If Helper.IsEventDeclaration(first) Then
             Dim red As Mono.Cecil.EventReference = DirectCast(first, Mono.Cecil.EventReference)
             Dim redD As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(red)
             If redD.AddMethod.IsStatic OrElse redD.RemoveMethod.IsStatic Then
                 Return New EventAccessClassification(Me, red, Nothing)
             End If
         End If
 
         '** If I identifies a constant, then the result is the value of that constant.
         If CecilHelper.GetMemberType(first) = MemberTypes.Field AndAlso CecilHelper.FindDefinition(DirectCast(first, Mono.Cecil.FieldReference)).IsLiteral Then
             Return New ValueClassification(Me, DirectCast(first, Mono.Cecil.FieldReference), Nothing)
         End If
 
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         If Helper.IsEnumFieldDeclaration(Compiler, first) Then
             Return New ValueClassification(Me, DirectCast(first, Mono.Cecil.FieldReference), Nothing)
         End If
 
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         Helper.AddError(Me)
 
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="636" endline="641"><![CDATA[
 
     Private Function CreateMeExpression() As MeExpression
         Dim result As New MeExpression(Me)
         If result.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then Throw New InternalException(Me)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="642" endline="741"><![CDATA[
 
     Private Function GetMeClassification(ByVal members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal type As IType) As ExpressionClassification
         Dim result As ExpressionClassification
         Dim first As Mono.Cecil.MemberReference = members(0)
 
         'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
         'type member, then the result is the same as a member access of the form Me.E, where E is 
         'the identifier.
 
 
         '* If E is classified as a variable or value, the type of which is T, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
 
         '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
         '   a method group representing the instance constructors of the type of E with an associated 
         '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
         '(not applicable)
 
         '** If I identifies one or more methods, then the result is a method group with the associated type 
         '   argument list and an associated instance expression of E.
         If Helper.IsMethodDeclaration(first) Then
             result = New MethodGroupClassification(Me, CreateMeExpression, m_TypeArgumentList, Nothing, members)
             Return result
         End If
 
         '** If I identifies one or more properties, then the result is a property group with an 
         '   associated instance expression of E.
         If Helper.IsPropertyDeclaration(first) Then
             result = New PropertyGroupClassification(Me, CreateMeExpression, members)
             Return result
         End If
 
         If members.Count > 1 Then
             Compiler.Report.WriteLine("Found " & members.Count & " members for SimpleNameExpression = " & Me.ToString & ", " & Me.Location.ToString(Compiler))
             For i As Integer = 0 To members.Count - 1
                 Compiler.Report.WriteLine(">#" & (i + 1).ToString & ".MemberType=" & CecilHelper.GetMemberType(members(i)).ToString & ",DeclaringType=" & members(i).DeclaringType.FullName)
             Next
             Helper.Stop()
         End If
 
         '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
         '   and the reference occurs outside a constructor of the class in which the variable is declared 
         '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
         '   variable I in the object referenced by E. 
         '   If T is a reference type, then the result is the variable 
         '   I in the object referenced by E. 
         '   Otherwise, if T is a value type and the expression E is classified 
         '   as a variable, the result is a variable; otherwise the result is a value.
         If Helper.IsFieldDeclaration(first) Then
             Dim var As Mono.Cecil.FieldReference = DirectCast(first, Mono.Cecil.FieldReference)
             Dim varD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(var)
             Helper.Assert(Parent.FindFirstParent(Of EnumDeclaration)() Is Nothing)
 
             Dim ctorParent As ConstructorDeclaration
             Dim methodParent As IMethod
             Dim typeParent As TypeDeclaration
             Dim isNotInCtorAndReadOnly As Boolean
             ctorParent = FindFirstParent(Of ConstructorDeclaration)()
             methodParent = FindFirstParent(Of IMethod)()
             typeParent = FindFirstParent(Of TypeDeclaration)()
 
             isNotInCtorAndReadOnly = varD.IsInitOnly AndAlso (ctorParent Is Nothing OrElse ctorParent.Modifiers.Is(ModifierMasks.Shared) <> varD.IsStatic) AndAlso (typeParent Is Nothing OrElse typeParent.IsShared <> varD.IsStatic)
 
             If isNotInCtorAndReadOnly Then ' >?? (Parent.FindFirstParent(Of IMethod).Modifiers.Is(KS.Shared) <> var.IsStatic) Then
                 Return New ValueClassification(Me, var, CreateMeExpression)
             ElseIf TypeOf type Is ClassDeclaration Then
                 Return New VariableClassification(Me, var, CreateMeExpression)
             ElseIf TypeOf type Is StructureDeclaration Then
                 Return New VariableClassification(Me, var, CreateMeExpression)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         '** If I identifies an event, the result is an event access with an associated instance expression of E.
         If Helper.IsEventDeclaration(first) Then
             If TypeOf first Is Mono.Cecil.EventReference Then
                 Return New EventAccessClassification(Me, DirectCast(first, Mono.Cecil.EventReference), CreateMeExpression)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         '** If I identifies a constant, then the result is the value of that constant.
         If CecilHelper.GetMemberType(first) = MemberTypes.Field AndAlso CecilHelper.FindDefinition(DirectCast(first, Mono.Cecil.FieldReference)).IsLiteral Then
             Return New ValueClassification(Me, DirectCast(first, Mono.Cecil.FieldReference), Nothing)
         End If
 
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '(not applicable)
 
         '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
         '   with an associated instance expression of E.
         '(not applicable)
 
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         Helper.AddError(Me)
 
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="742" endline="791"><![CDATA[
 
     Private Function CheckOutermostNamespace(ByVal R As String) As Boolean
 
         '---------------------------------------------------------------------------------------------------------
         '* For each nested namespace, starting from the innermost and going to the outermost namespace, 
         '  do the following
         '** If the namespace contains an accessible namespace member with the given name, then the identifier
         '   refers to that member and, depending on the member, is classified as a namespace or a type.
         '** Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the 
         '   result is exactly the same as a member access of the form M.E, where M is the standard module 
         '   containing the matching member and E is the identifier. If the identifier matches accessible type 
         '   members in more than one standard module, a compile-time error occurs.
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '---------------------------------------------------------------------------------------------------------
         Dim foundNamespace As [Namespace] = Nothing
         Dim foundType As Mono.Cecil.TypeReference
 
         foundType = Compiler.TypeManager.TypesByNamespace("").Item(R)
         If foundType Is Nothing AndAlso Compiler.Assembly.Name <> "" Then
             foundType = Compiler.TypeManager.TypesByNamespace(Compiler.Assembly.Name).Item(R)
         End If
 
         foundNamespace = Compiler.TypeManager.Namespaces(R)
         If foundNamespace IsNot Nothing AndAlso foundType Is Nothing Then
             Classification = New NamespaceClassification(Me, foundNamespace)
             Return True
         ElseIf foundNamespace Is Nothing AndAlso foundType IsNot Nothing Then
             Classification = New TypeClassification(Me, foundType)
             Return True
         ElseIf foundNamespace IsNot Nothing AndAlso foundType IsNot Nothing Then
             Return Helper.AddError(Me)
         End If
 
         If foundNamespace Is Nothing Then Return False
 
         Dim modules As TypeDictionary
         Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         modules = Compiler.TypeManager.GetModulesByNamespace(foundNamespace.ToString)
         members = Helper.GetMembersOfTypes(Compiler, modules, R)
         If members.Count = 1 Then
             Helper.Assert(Helper.IsTypeDeclaration(members(0)))
             Classification = New TypeClassification(Me, members(0))
         ElseIf members.Count > 1 Then
             Return Helper.AddError(Me)
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="792" endline="809"><![CDATA[
 
     Private Function ResolveAliasImports(ByVal imps As ImportsClauses, ByVal Name As String) As Boolean
         Dim import As ImportsClause = imps.Item(Name)
         Dim nsimport As ImportsNamespaceClause
         If import IsNot Nothing Then
             nsimport = import.AsAliasClause.NamespaceClause
             If nsimport.IsNamespaceImport Then
                 Classification = New NamespaceClassification(Me, nsimport.NamespaceImported)
                 Return True
             ElseIf nsimport.IsTypeImport Then
                 Classification = New TypeClassification(Me, nsimport.TypeImported)
                 Return True
             Else
                 Throw New InternalException(Me)
             End If
         End If
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="810" endline="897"><![CDATA[
 
     Private Function ResolveImports(ByVal imps As ImportsClauses, ByVal Name As String) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* If the (source file / compilation environment) containing the name reference has one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name of 
         '   an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
         '   a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then 
         '   the result is exactly the same as a member access of the form M.E, where M is the standard 
         '   module containing the matching member and E is the identifier. If the identifier matches 
         '   accessible type members in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         Dim impmembers As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
         For Each imp As ImportsClause In imps
             If imp.IsNamespaceClause Then
                 If imp.AsNamespaceClause.IsNamespaceImport Then
                     'The specified name can only be a type.
                     If Compiler.TypeManager.TypesByNamespace.ContainsKey(imp.AsNamespaceClause.Name) Then
                         result = Compiler.TypeManager.GetTypesByNamespaceAndName(imp.AsNamespaceClause.Name, Name)
                         'Helper.FilterByName(Compiler.TypeManager.TypesByNamespace(imp.AsNamespaceClause.Name).ToTypeList, Name, result)
                     End If
                 ElseIf imp.AsNamespaceClause.IsTypeImport Then
                     'result.AddRange(Helper.FilterByName(imp.AsNamespaceClause.TypeImported.GetMembers, Name))
                     'result.AddRange(Compiler.TypeManager.GetCache(imp.AsNamespaceClause.TypeImported).LookupMembersFlattened(Name))
                     result = Compiler.TypeManager.GetCache(imp.AsNamespaceClause.TypeImported).LookupMembersFlattened(Name)
                 Else
                     Continue For 'This import was not resolved correctly, so don't use it.
                 End If
             End If
             If result IsNot Nothing AndAlso result.Count > 0 Then
                 If impmembers.Count > 0 Then
                     Return Helper.AddError(Me, "If the identifier matches the name of an accessible type or type member in more than one import, a compile-time error occurs.")
                 End If
                 impmembers.AddRange(result)
                 result = Nothing
             End If
         Next
 
         If impmembers.Count > 0 Then
             'If the identifier matches the name of an accessible type or type member in exactly one import, 
             'then the identifier refers to that type or type member. If the identifier matches the name of 
             'an accessible type or type member in more than one import, a compile-time error occurs.
             If Helper.IsMethodDeclaration(impmembers(0)) Then
                 Classification = New MethodGroupClassification(Me, Nothing, m_TypeArgumentList, Nothing, impmembers)
                 Return True
             End If
             If Helper.IsTypeDeclaration(impmembers(0)) Then
                 Classification = New TypeClassification(Me, impmembers(0))
                 Return True
             End If
             If Helper.IsFieldDeclaration(impmembers(0)) Then
                 Classification = New ValueClassification(Me, DirectCast(impmembers(0), Mono.Cecil.FieldReference), Nothing)
                 Return True
             End If
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
         End If
 
         Dim nsmembers As Generic.List(Of [Namespace])
         nsmembers = imps.GetNamespaces(Me, Name)
         If nsmembers.Count = 1 Then
             'If the identifier matches the name of a namespace in exactly one import, then the identifier 
             'refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
             'a compile-time error occurs.
             Classification = New NamespaceClassification(Me, nsmembers(0))
             Return True
         ElseIf nsmembers.Count > 1 Then
             Return Helper.AddError(Me)
         End If
 
         'Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         'lookup of the identifier produces an accessible match in exactly one standard module, then 
         'the result is exactly the same as a member access of the form M.E, where M is the standard 
         'module containing the matching member and E is the identifier. If the identifier matches 
         'accessible type members in more than one standard module, a compile-time error occurs.
         Dim modules As TypeList = imps.GetModules(Me)
         Dim found As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         found = Helper.GetMembersOfTypes(Compiler, modules, Name)
         If SetClassificationOfModuleMembers(found) Then
             Return True
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="898" endline="929"><![CDATA[
 
     Private Function SetClassificationOfModuleMembers(ByVal found As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)) As Boolean
         If found Is Nothing OrElse found.Count <= 0 Then
             Return False
         End If
 
         If Helper.IsMethodDeclaration(found(0)) Then
             Classification = New MethodGroupClassification(Me, Nothing, m_TypeArgumentList, Nothing, found)
             Return True
         End If
         If found.Count > 1 Then
             Return Helper.AddError(Me)
         End If
         If Helper.IsTypeDeclaration(found(0)) Then
             Classification = New TypeClassification(Me, found(0))
             Return True
         End If
         Dim first As Mono.Cecil.MemberReference = found(0)
         If Helper.IsFieldDeclaration(first) Then
             Dim var As Mono.Cecil.FieldReference = DirectCast(first, Mono.Cecil.FieldReference)
             Helper.Assert(Parent.FindFirstParent(Of EnumDeclaration)() Is Nothing)
 
             Classification = New VariableClassification(Me, var, Nothing)
             Return True
         End If
         If Helper.IsPropertyDeclaration(first) Then
             Classification = New PropertyGroupClassification(Me, Nothing, found)
             Return True
         End If
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeExpression.vb" startline="32" endline="34"><![CDATA[
     Shared Function IsUnaryMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.GetType, KS.TypeOf, KS.Is)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeExpression.vb" startline="35" endline="38"><![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.Is)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeExpression.vb" startline="39" endline="42"><![CDATA[
 
     Shared Function CreateAndParseTo(ByRef result As Expression) As Boolean
         Return result.Compiler.Report.ShowMessage(Messages.VBNC99997, result.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeExpression.vb" startline="43" endline="46"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeExpression.vb" startline="47" endline="50"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="36" endline="43"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="44" endline="47"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="48" endline="53"><![CDATA[
 
     Sub Init(ByVal Expression As Expression, ByVal [Is] As Boolean, ByVal Type As TypeName)
         m_Expression = Expression
         m_Is = [Is]
         m_Type = Type
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="54" endline="72"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
         If CecilHelper.IsGenericParameter(m_Expression.ExpressionType) Then
             Emitter.EmitBox(Info, m_Expression.ExpressionType)
         End If
         Emitter.EmitIsInst(Info, m_Expression.ExpressionType, m_Type.ResolvedType)
 
         Emitter.EmitLoadNull(Info.Clone(Me, True, False, Compiler.TypeCache.System_Object))
         If m_Is Then
             Emitter.EmitNotEquals(Info, m_Type.ResolvedType)
         Else
             Emitter.EmitEquals(Info, m_Type.ResolvedType)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="73" endline="91"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Classification = New ValueClassification(Me)
 
         If m_Expression.Classification.IsValueClassification Then
         ElseIf m_Expression.Classification.CanBeValueClassification Then
             m_Expression = m_Expression.ReclassifyToValueExpression()
             result = m_Expression.ResolveExpression(Info) AndAlso result
         Else
             result = Helper.AddError(Me) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="92" endline="96"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="97" endline="102"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Boolean
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\Expressions.vb" startline="23" endline="25"><![CDATA[
     Shadows Sub Add(ByVal value As Expression)
         MyBase.Add(value)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\Expressions.vb" startline="26" endline="30"><![CDATA[
 
     Default Shadows Property Item(ByVal Index As Integer) As Expression
         Get
             Return DirectCast(MyBase.Item(Index), Expression)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\Expressions.vb" startline="31" endline="33"><![CDATA[
         Set(ByVal value As Expression)
             MyBase.Item(Index) = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\Expressions.vb" startline="34" endline="41"><![CDATA[
     End Property
 
     Shadows Function ToArray() As Expression()
         Dim result As Expression()
         ReDim result(Count - 1)
         Array.Copy(MyBase.ToArray, result, Count)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\Expressions.vb" startline="42" endline="46"><![CDATA[
 
     ReadOnly Property Length() As Integer
         Get
             Return Count
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="31" endline="33"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Expression.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="34" endline="37"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="38" endline="41"><![CDATA[
 
     Sub Init(ByVal Expression As Expression)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="42" endline="46"><![CDATA[
 
     ReadOnly Property Expression() As Expression
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="47" endline="52"><![CDATA[
     End Property
 
     Protected Sub ValidateBeforeGenerateCode(ByVal Info As EmitInfo)
         Helper.Assert(Classification.IsValueClassification)
         Helper.Assert(Info.IsRHS)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="53" endline="61"><![CDATA[
 
 #If DEBUG Then
     Protected MustOverride Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
 #End If
     MustOverride ReadOnly Property Keyword() As KS
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(Enums.UnaryOperators)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="62" endline="66"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_Expression.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="67" endline="122"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim operandType As TypeCode
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return False
 
         If m_Expression.Classification.IsValueClassification = False Then
             If m_Expression.Classification.CanBeValueClassification Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             Else
                 result = Helper.AddError(Me, "Value must be value classification.") AndAlso result
             End If
         End If
 
         operandType = Me.OperandTypeCode
 
         If operandType = TypeCode.Empty Then
             Compiler.Report.ShowMessage(Messages.VBNC30487, Location, Enums.strSpecial(Me.Keyword), Helper.ToString(Expression, Expression.ExpressionType))
             result = False
         Else
             'If X is an intrinsic types, look up the result type in our operator tables and use that.
             'If X is not an intrinsic type, do overload resolution on the set of operators to be considered.
             Dim destinationType As Mono.Cecil.TypeReference
             Dim isRightIntrinsic As Boolean = Helper.GetTypeCode(Compiler, m_Expression.ExpressionType) <> TypeCode.Object OrElse Helper.CompareType(Compiler.TypeCache.System_Object, Me.m_Expression.ExpressionType)
 
             If isRightIntrinsic Then
                 m_ExpressionType = Compiler.TypeResolution.TypeCodeToType(Me.ExpressionTypeCode)
                 If Helper.GetTypeCode(Compiler, m_Expression.ExpressionType) <> operandType Then
                     Dim ctypeexp As CTypeExpression
                     destinationType = Compiler.TypeResolution.TypeCodeToType(operandType)
                     ctypeexp = New CTypeExpression(Me, m_Expression, destinationType)
                     result = ctypeexp.ResolveExpression(Info) AndAlso result
                     m_Expression = ctypeexp
                 End If
                 Classification = New ValueClassification(Me)
             Else
                 Dim methods As New Generic.List(Of Mono.Cecil.MethodReference)
                 Dim methodClassification As MethodGroupClassification
 
                 methods = Helper.GetUnaryOperators(Compiler, CType(Me.Keyword, UnaryOperators), Me.m_Expression.ExpressionType)
 
                 methodClassification = New MethodGroupClassification(Me, Nothing, Nothing, New Expression() {Me.m_Expression}, methods.ToArray)
                 result = methodClassification.ResolveGroup(New ArgumentList(Me, New Expression() {Me.m_Expression})) AndAlso result
                 result = methodClassification.SuccessfullyResolved AndAlso result
                 m_ExpressionType = methodClassification.ResolvedMethodInfo.ReturnType
                 Classification = methodClassification
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="123" endline="127"><![CDATA[
 
     ReadOnly Property ExpressionTypeCode() As TypeCode
         Get
             Return TypeConverter.GetUnaryResultType(Me.Keyword, Helper.GetTypeCode(Compiler, Expression.ExpressionType))
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="128" endline="133"><![CDATA[
     End Property
 
     ReadOnly Property OperandType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeResolution.TypeCodeToType(OperandTypeCode)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="134" endline="139"><![CDATA[
     End Property
 
     ReadOnly Property OperandTypeCode() As TypeCode
         Get
             Return TypeConverter.GetUnaryOperandType(Me.Keyword, ExpressionTypeCode)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="140" endline="145"><![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryMinusExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryMinusExpression.vb" startline="26" endline="29"><![CDATA[
 
     Shadows Sub Init(ByVal Expression As Expression)
         MyBase.Init(Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryMinusExpression.vb" startline="30" endline="63"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         Select Case OperandTypeCode
             Case TypeCode.Decimal
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Negate_Decimal)
             Case TypeCode.Single, TypeCode.Double
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitNeg(Info)
             Case TypeCode.SByte, TypeCode.Int16
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitNeg(Info)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 result = Me.Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__NegateObject_Object)
             Case TypeCode.Int32
                 Emitter.EmitLoadI4Value(Info, 0)
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitSubOvf(Info, OperandType)
             Case TypeCode.Int64
                 Emitter.EmitLoadI8Value(Info, 0)
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitSubOvf(Info, OperandType)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryMinusExpression.vb" startline="64" endline="95"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             Dim value As Object = Expression.ConstantValue
             Helper.Assert(value IsNot Nothing)
             Select Case Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))
                 Case TypeCode.SByte
                     Return -CSByte(value)
                 Case TypeCode.Int16
                     Return -CShort(value)
                 Case TypeCode.Int32
                     Return -CInt(value)
                 Case TypeCode.Int64
                     Return -CLng(value)
                 Case TypeCode.Byte
                 Case TypeCode.UInt16
                 Case TypeCode.UInt32
                 Case TypeCode.UInt64
                     Return -CULng(value)
                 Case TypeCode.Decimal
                     Return -CDec(value)
                 Case TypeCode.Double
                     Return -CDbl(value)
                 Case TypeCode.Single
                     Return -CSng(value)
                 Case Else
                     Helper.Stop()
             End Select
             Helper.Stop()
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryMinusExpression.vb" startline="96" endline="101"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Minus
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="26" endline="29"><![CDATA[
 
     Shadows Sub Init(ByVal Expression As Expression)
         MyBase.Init(Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="30" endline="53"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case Me.OperandTypeCode
 
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Boolean)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitNot(Info, OperandType)
             Case TypeCode.Object
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__NotObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="54" endline="58"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return Expression.IsConstant AndAlso Compiler.TypeResolution.IsIntegralType(Expression.ExpressionType)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="59" endline="90"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             Dim value As Object = Expression.ConstantValue
             Helper.Assert(value IsNot Nothing)
             Select Case Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))
                 Case TypeCode.SByte
                     Return Not CSByte(value)
                 Case TypeCode.Byte
                     Return Not CByte(value)
                 Case TypeCode.Int16
                     Return Not CShort(value)
                 Case TypeCode.Int32
                     Return Not CInt(value)
                 Case TypeCode.Int64
                     Return Not CLng(value)
                 Case TypeCode.UInt16
                     Return Not CUShort(value)
                 Case TypeCode.UInt32
                     Return Not CUInt(value)
                 Case TypeCode.UInt64
                     Return Not CULng(value)
                 Case TypeCode.Decimal, TypeCode.Double, TypeCode.Single
                     Throw New InternalException(Me)
                 Case Else
                     Throw New InternalException(Me)
             End Select
             Helper.Stop()
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="91" endline="96"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Not
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="26" endline="29"><![CDATA[
 
     Shadows Sub Init(ByVal Expression As Expression)
         MyBase.Init(Expression)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="30" endline="52"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Decimal
             Case TypeCode.Single, TypeCode.Double
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__PlusObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="53" endline="59"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             Dim value As Object = Expression.ConstantValue
             Return value
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="60" endline="65"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Return KS.Add
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableExpression.vb" startline="25" endline="30"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Variable As LocalVariableDeclaration)
         MyBase.New(Parent, Nothing, Variable.VariableType)
 
         m_Variable = Variable
         Classification = New VariableClassification(Me, m_Variable)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableExpression.vb" startline="31" endline="34"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Return Emit(Info, m_Variable.LocalBuilder)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableExpression.vb" startline="35" endline="58"><![CDATA[
 
     Shared Function Emit(ByVal Info As EmitInfo, ByVal LocalBuilder As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             Emitter.EmitLoadVariable(Info, LocalBuilder)
         Else
             Dim rInfo As EmitInfo = Info.Clone(Info.Context, True, False, LocalBuilder.VariableType)
 
             Helper.Assert(Info.RHSExpression IsNot Nothing, "RHSExpression Is Nothing!")
             Helper.Assert(Info.RHSExpression.Classification.IsValueClassification OrElse Info.RHSExpression.Classification.CanBeValueClassification)
             result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
 
             Emitter.EmitConversion(Info.RHSExpression.ExpressionType, LocalBuilder.VariableType, Info)
 
             If Helper.CompareType(LocalBuilder.VariableType, Info.Compiler.TypeCache.System_Object) AndAlso Helper.CompareType(Info.RHSExpression.ExpressionType, Info.Compiler.TypeCache.System_Object) Then
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
             End If
 
             Emitter.EmitStoreVariable(Info, LocalBuilder)
         End If
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="26" endline="29"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal VariableClassification As VariableClassification)
         MyBase.new(Parent)
         m_Variable = VariableClassification
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="30" endline="34"><![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_Variable.IsConstant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="35" endline="40"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Return m_Variable.ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="41" endline="57"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_ExpressionType = m_Variable.Type
 
         If m_ExpressionType IsNot Nothing AndAlso CecilHelper.IsByRef(m_ExpressionType) Then
             m_ExpressionType = CecilHelper.GetElementType(m_ExpressionType)
         End If
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="58" endline="113"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim isByRef As Boolean = CecilHelper.IsByRef(Info.DesiredType)
 
         If m_Variable.InstanceExpression IsNot Nothing Then
             Dim exp As Mono.Cecil.TypeReference = m_Variable.InstanceExpression.ExpressionType
             If CecilHelper.IsValueType(exp) AndAlso CecilHelper.IsByRef(exp) = False Then
                 exp = CecilHelper.MakeByRefType(exp)
             End If
             result = m_Variable.InstanceExpression.GenerateCode(Info.Clone(Me, exp)) AndAlso result
         End If
 
         If m_Variable.FieldInfo IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, m_Variable.FieldInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         ElseIf m_Variable.LocalBuilder IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, m_Variable.LocalBuilder)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         ElseIf m_Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(m_Variable.InstanceExpression Is Nothing)
             If Info.IsRHS Then
                 Emitter.EmitLoadParameter(Info, m_Variable.ParameterInfo)
                 If CecilHelper.IsByRef(m_Variable.ParameterInfo.ParameterType) Then
                     Emitter.EmitLoadIndirect(Info, m_Variable.ParameterInfo.ParameterType)
                 End If
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         ElseIf m_Variable.ArrayVariable IsNot Nothing Then
             result = Helper.EmitLoadArrayElement(Info, m_Variable.ArrayVariable, m_Variable.Arguments) AndAlso result
         ElseIf m_Variable.Expression IsNot Nothing Then
             result = m_Variable.Expression.GenerateCode(Info) AndAlso result
         ElseIf m_Variable.Method IsNot Nothing Then
             Emitter.EmitLoadVariable(Info, m_Variable.Method.DefaultReturnVariable)
         Else
             Throw New InternalException(Me)
         End If
 
         If CecilHelper.IsByRef(Info.DesiredType) Then
             Dim elementType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, CecilHelper.GetElementType(Info.DesiredType))
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = Emitter.DeclareLocal(Info, elementType)
 
             Emitter.EmitStoreVariable(Info, local)
             Emitter.EmitLoadVariableLocation(Info, local)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="114" endline="118"><![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Return m_ExpressionType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="50" endline="52"><![CDATA[
     Protected Sub New()
 
     End Sub
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject)
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="53" endline="70"><![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject)
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="71" endline="88"><![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="89" endline="98"><![CDATA[
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="99" endline="102"><![CDATA[
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="103" endline="115"><![CDATA[
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="116" endline="118"><![CDATA[
         Set(ByVal value As Span)
             m_Location = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="119" endline="124"><![CDATA[
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="125" endline="142"><![CDATA[
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="143" endline="147"><![CDATA[
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="148" endline="154"><![CDATA[
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="155" endline="164"><![CDATA[
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="165" endline="174"><![CDATA[
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="175" endline="186"><![CDATA[
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="187" endline="196"><![CDATA[
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="197" endline="200"><![CDATA[
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="201" endline="206"><![CDATA[
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="207" endline="222"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="223" endline="228"><![CDATA[
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="229" endline="252"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="253" endline="267"><![CDATA[
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="268" endline="284"><![CDATA[
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="285" endline="295"><![CDATA[
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="296" endline="302"><![CDATA[
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="303" endline="307"><![CDATA[
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="308" endline="312"><![CDATA[
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="313" endline="324"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="325" endline="333"><![CDATA[
 
     Private m_ObjectID As Integer = NewID()
     Public Shared ObjectIDStop As Integer
     Public Shared NextID As Integer
 
     ReadOnly Property ObjectID() As Integer Implements IBaseObject.ObjectID
         Get
             Return m_ObjectID
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="334" endline="343"><![CDATA[
     End Property
 
     Shared Function NewID() As Integer
         NextID += 1
         If ObjectIDStop = NextID Then
             Helper.StopIfDebugging()
         End If
 
         Return NextID
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="29" endline="33"><![CDATA[
     Sub SetParent(ByVal Parent As ParsedObject)
         For Each item As IBaseObject In Me
             item.Parent = Parent
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="34" endline="41"><![CDATA[
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Parent.Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="42" endline="53"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The parent of this list.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property Parent() As BaseObject
         Get
             Return m_Parent
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="54" endline="62"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a new baseobject collection for the specified parent.
     ''' </summary>
     Sub New(ByVal Parent As BaseObject)
         MyBase.New()
         m_Parent = Parent
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="63" endline="73"><![CDATA[
 
     Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To Count - 1
             Dim pO As BaseObject = TryCast(CObj(Item(i)), BaseObject)
             If pO IsNot Nothing Then
                 result = pO.ResolveCode(Info) AndAlso result
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="74" endline="82"><![CDATA[
 
     ''' <summary>
     ''' Calls GenerateCode on all the types in this collection.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return Helper.GenerateCodeCollection(Me, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="83" endline="86"><![CDATA[
 
     Function ResolveTypeReferences() As Boolean
         Return Helper.ResolveTypeReferencesCollection(Me)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="87" endline="90"><![CDATA[
 
     Sub Initialize(ByVal Parent As BaseObject)
         Helper.InitializeCollection(Me, Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="29" endline="32"><![CDATA[
     Public Shared Sub Test(ByVal file As String)
         Dim ass As AssemblyDefinition = AssemblyDefinition.ReadAssembly(file, New ReaderParameters(ReadingMode.Immediate))
         Console.WriteLine(ass.ToString())
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="33" endline="46"><![CDATA[
 #End If
 
     Public Shared Sub GetConstructors(ByVal Type As Mono.Cecil.TypeReference, ByVal result As Mono.Collections.Generic.Collection(Of MethodReference))
         Dim tD As Mono.Cecil.TypeDefinition = FindDefinition(Type)
         For Each item As Mono.Cecil.MethodDefinition In tD.Methods
             If Not item.IsConstructor Then Continue For
             If item.IsStatic Then Continue For
             If Helper.CompareType(item.DeclaringType, Type) = False Then
                 result.Add(GetCorrectMember(item, Type))
             Else
                 result.Add(item)
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="47" endline="52"><![CDATA[
 
     Public Shared Function GetConstructors(ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of MethodReference)
         Dim result As New Mono.Collections.Generic.Collection(Of MethodReference)
         GetConstructors(Type, result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="53" endline="58"><![CDATA[
 
     Private Shared Sub AddRange(ByVal C As Mono.Collections.Generic.Collection(Of MemberReference), ByVal C2 As Mono.Collections.Generic.Collection(Of MemberReference))
         For i As Integer = 0 To C2.Count - 1
             C.Add(C2(i))
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="59" endline="68"><![CDATA[
 
     Public Shared Function GetMembers(ByVal Type As Mono.Cecil.GenericParameter) As Mono.Collections.Generic.Collection(Of MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of MemberReference)()
 
         For i As Integer = 0 To Type.Constraints.Count - 1
             AddRange(result, GetMembers(Type.Constraints(i)))
         Next
         AddRange(result, GetMembers(BaseObject.m_Compiler.TypeCache.System_Object))
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="69" endline="124"><![CDATA[
 
     Public Shared Function GetMembers(ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of MemberReference)
         Dim tD As Mono.Cecil.TypeDefinition
         Dim result As Mono.Collections.Generic.Collection(Of MemberReference)
 
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, GenericParameter)
         If tG IsNot Nothing Then Return GetMembers(tG)
 
         Dim arr As Mono.Cecil.ArrayType = TryCast(Type, ArrayType)
         If arr IsNot Nothing Then
             result = New Mono.Collections.Generic.Collection(Of MemberReference)()
             For Each member As MemberReference In GetMembers(BaseObject.m_Compiler.TypeCache.System_Array)
                 'result.Add(GetCorrectMember(member, Type))
                 result.Add(member)
             Next
             Return result
         End If
 
         tD = FindDefinition(Type)
 
         result = New Mono.Collections.Generic.Collection(Of MemberReference)(tD.Events.Count + tD.Methods.Count + tD.Properties.Count + tD.NestedTypes.Count + tD.Fields.Count)
 
         For i As Integer = 0 To tD.Events.Count - 1
             Dim item As EventDefinition = tD.Events(i)
             'I don't think events need to call GetCorrectMember
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.Methods.Count - 1
             Dim item As MethodReference = tD.Methods(i)
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(item, Type)
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.Properties.Count - 1
             Dim pd As PropertyDefinition = tD.Properties(i)
             Dim item As PropertyReference = pd
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(pd, Type)
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.NestedTypes.Count - 1
             Dim item As TypeReference = tD.NestedTypes(i)
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(item, Type)
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.Fields.Count - 1
             Dim fd As FieldDefinition = tD.Fields(i)
             Dim item As FieldReference = fd
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(fd, Type)
             result.Add(item)
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="125" endline="136"><![CDATA[
 
     Public Shared Function IsValidType(ByVal type As TypeReference) As Boolean
         Dim arrayType As ArrayType
 
         If type Is Nothing Then Return True
         If TypeOf type Is PointerType Then Return False
 
         arrayType = TryCast(type, ArrayType)
         If arrayType IsNot Nothing AndAlso IsValidType(arrayType.ElementType) = False Then Return False
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="137" endline="157"><![CDATA[
 
 
     Public Shared Function GetCorrectMember(ByVal Member As TypeReference, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition = TryCast(Member, Mono.Cecil.TypeDefinition)
 
         If tD IsNot Nothing Then Return GetCorrectMember(tD, Type)
 
         Dim tG As Mono.Cecil.GenericInstanceType = TryCast(Member, Mono.Cecil.GenericInstanceType)
         If tG IsNot Nothing Then
             tD = TryCast(tG.ElementType, Mono.Cecil.TypeDefinition)
             If tD IsNot Nothing Then
                 Helper.Assert(tG.GenericParameters.Count = 0)
                 Return GetCorrectMember(tD, Type)
             End If
         End If
 
         tD = FindDefinition(Member)
         Return GetCorrectMember(tD, Type)
 
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="158" endline="194"><![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As Mono.Cecil.TypeDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.GenericInstanceType = Nothing
         Dim args As New Generic.List(Of Mono.Cecil.TypeReference)
         Dim any_change As Boolean
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
 
         If genericType Is Nothing Then Return Member
 
         result = New Mono.Cecil.GenericInstanceType(Member)
         result.DeclaringType = FindDefinition(Type)
 
         Dim tGI As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         If Member.DeclaringType IsNot Nothing AndAlso tGI IsNot Nothing AndAlso Helper.CompareType(Member.DeclaringType, tGI.ElementType) Then
             'Nested generic type
             For i As Integer = 0 To tGI.GenericArguments.Count - 1
                 result.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, tGI.GenericArguments(i)))
             Next
             Return result
         End If
 
         For i As Integer = 0 To Member.GenericParameters.Count - 1
             Dim found As Boolean = False
             For j As Integer = 0 To genericType.ElementType.GenericParameters.Count - 1
                 If genericType.ElementType.GenericParameters(j).Name = Member.GenericParameters(i).Name Then
                     result.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, genericType.GenericArguments(j)))
                     found = True
                     any_change = True
                     Exit For
                 End If
             Next
 
             If Not found Then Throw New NotImplementedException
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="195" endline="225"><![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As PropertyDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.PropertyReference
         Dim result As Mono.Cecil.PropertyDefinition
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim propertyType As Mono.Cecil.TypeReference
         Dim getMethod As Mono.Cecil.MethodReference = Nothing
         Dim setMethod As Mono.Cecil.MethodReference = Nothing
 
         If genericType Is Nothing Then Return Member
 
         propertyType = CecilHelper.ResolveType(Member.PropertyType, Member.DeclaringType.GenericParameters, genericType.GenericArguments)
         propertyType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, propertyType)
 
         If Member.GetMethod IsNot Nothing Then
             getMethod = GetCorrectMember(Member.GetMethod, Type)
         End If
 
         If Member.SetMethod IsNot Nothing Then
             setMethod = GetCorrectMember(Member.SetMethod, Type)
         End If
 
         'If propertyType Is Member.PropertyType AndAlso (getMethod Is Nothing OrElse Member.GetMethod Is getMethod) AndAlso (setMethod Is Nothing OrElse Member.SetMethod Is setMethod) Then
         'Return Member
         'End If
         result = New Mono.Cecil.PropertyDefinition(Member.Name, Member.Attributes, propertyType)
         result.DeclaringType = genericType
         result.SetMethod = setMethod
         result.GetMethod = getMethod
         result.Annotations.Add("OriginalProperty", Member)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="226" endline="270"><![CDATA[
 
     Public Shared Sub GetGenericArgsAndParams(ByVal Type As TypeReference, ByRef GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByRef GenericArguments As Mono.Collections.Generic.Collection(Of TypeReference))
         Dim declType As TypeReference = Nothing
         Dim genericType As GenericInstanceType
         Dim genericTypeDefinition As TypeDefinition
         Dim cloned As Boolean
 
         Do
             If declType Is Nothing Then
                 declType = Type
             Else
                 declType = declType.DeclaringType
             End If
 
             genericType = TryCast(declType, Mono.Cecil.GenericInstanceType)
 
             If genericType IsNot Nothing Then
                 genericTypeDefinition = CecilHelper.FindDefinition(genericType)
 
                 Helper.Assert(genericType.GenericArguments.Count = genericTypeDefinition.GenericParameters.Count)
 
                 If GenericArguments Is Nothing Then
                     GenericArguments = genericType.GenericArguments
                     GenericParameters = genericTypeDefinition.GenericParameters
                 Else
                     If cloned = False Then
                         Dim tmp1 As New Mono.Collections.Generic.Collection(Of TypeReference)
                         Dim tmp2 As New Mono.Collections.Generic.Collection(Of GenericParameter)
                         For i As Integer = 0 To GenericArguments.Count - 1
                             tmp1.Add(GenericArguments(i))
                             tmp2.Add(GenericParameters(i))
                         Next
                         GenericArguments = tmp1
                         GenericParameters = tmp2
                         cloned = True
                     End If
 
                     For i As Integer = 0 To genericType.GenericArguments.Count - 1
                         GenericArguments.Insert(i, genericType.GenericArguments(i))
                         GenericParameters.Insert(i, genericTypeDefinition.GenericParameters(i))
                     Next
                 End If
             End If
         Loop While declType.IsNested
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="271" endline="358"><![CDATA[
 
     Public Shared Function InflateType(ByVal original As TypeReference, ByVal container As TypeReference) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
         Dim originalDef As TypeDefinition = TryCast(original, TypeDefinition)
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim genericCollection As GenericInstanceType = TryCast(container, GenericInstanceType)
         Dim containerDef As TypeDefinition
 
         If genericCollection Is Nothing Then
             Return original
             Throw New ArgumentException("The type to inflate with isn't generic.")
         End If
 
         If originalDef IsNot Nothing Then
             If originalDef.GenericParameters.Count = 0 Then Return original
             Dim result As New GenericInstanceType(originalDef)
             For i As Integer = 0 To originalDef.GenericParameters.Count - 1
                 Dim tG As GenericParameter = originalDef.GenericParameters(i)
                 If tG.Owner Is originalDef Then
                     result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), container))
                 Else
                     result.GenericArguments.Add(originalDef.GenericParameters(i))
                 End If
             Next
             Return result
         End If
 
         containerDef = CecilHelper.FindDefinition(container)
 
         If containerDef IsNot Nothing Then
             parameters = containerDef.GenericParameters
         Else
             parameters = genericCollection.ElementType.GenericParameters
         End If
         arguments = genericCollection.GenericArguments
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         Dim genParam As GenericParameter = TryCast(original, GenericParameter)
         If genParam IsNot Nothing Then
             If Not TypeOf genParam.Owner Is TypeReference Then Return genParam
             Helper.Assert(genParam.Position < arguments.Count)
             Return arguments.Item(genParam.Position)
         End If
 
         If genericType IsNot Nothing Then
             Dim result As New GenericInstanceType(genericType.ElementType)
             'originalDef = CecilHelper.FindDefinition(original)
             'For i As Integer = 0 To originalDef.GenericParameters.Count - 1
             '    For j As Integer = 0 To parameters.Count - 1
             '        If parameters(j) Is originalDef.GenericParameters(i) Then
             '            result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), container))
             '            Exit For
             '        End If
             '    Next
             'Next
             For i As Integer = 0 To genericType.GenericArguments.Count - 1
                 result.GenericArguments.Add(InflateType(genericType.GenericArguments(i), container))
             Next
             'Helper.Assert(result.GenericArguments.Count = parameters.Count)
             Return result
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = InflateType(spec.ElementType, container)
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf reference IsNot Nothing Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         Else
             Return original
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="359" endline="427"><![CDATA[
 
     Public Shared Function InflateType(ByVal original As TypeReference, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
         Dim originalDef As TypeDefinition = TryCast(original, TypeDefinition)
 
         If parameters Is Nothing AndAlso arguments Is Nothing Then Return original
 
         If originalDef IsNot Nothing Then
             If originalDef.GenericParameters.Count = 0 Then Return original
             Dim result As New GenericInstanceType(originalDef)
             For i As Integer = 0 To originalDef.GenericParameters.Count - 1
                 Dim tG As GenericParameter = originalDef.GenericParameters(i)
                 If tG.Owner Is originalDef Then
                     result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), parameters, arguments))
                 Else
                     result.GenericArguments.Add(originalDef.GenericParameters(i))
                 End If
             Next
             Return result
         End If
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         Dim genParam As GenericParameter = TryCast(original, GenericParameter)
         If genParam IsNot Nothing Then
             If Not TypeOf genParam.Owner Is TypeReference Then
                 For i As Integer = 0 To parameters.Count - 1
                     If parameters(i).Owner Is genParam.Owner AndAlso parameters(i).Position = genParam.Position Then
                         Return arguments(i)
                     End If
                 Next
                 Return genParam
             End If
             Helper.Assert(genParam.Position < arguments.Count)
             Return arguments.Item(genParam.Position)
         End If
 
         If genericType IsNot Nothing Then
             Dim result As New GenericInstanceType(CecilHelper.FindDefinition(genericType.ElementType))
             For i As Integer = 0 To result.ElementType.GenericParameters.Count - 1
                 result.GenericArguments.Add(InflateType(genericType.GenericArguments(i), parameters, arguments))
             Next
             Return result
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = InflateType(spec.ElementType, parameters, arguments)
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf reference IsNot Nothing Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         Else
             Return original
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="428" endline="479"><![CDATA[
 
     Public Shared Function ResolveType(ByVal original As TypeReference, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = ResolveType(spec.ElementType, parameters, arguments)
 
             If genericType IsNot Nothing Then
                 Dim result As GenericInstanceType = New GenericInstanceType(genericType.ElementType)
                 For i As Integer = 0 To genericType.GenericArguments.Count - 1
                     Dim tg As Mono.Cecil.TypeReference = ResolveType(genericType.GenericArguments(i), parameters, arguments)
                     result.GenericArguments.Add(tg)
                 Next
                 Return result
             End If
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf (reference IsNot Nothing) Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         End If
 
         For i As Integer = 0 To parameters.Count - 1
             If parameters(i) Is original Then
                 Return arguments(i)
             End If
         Next
 
         If original.IsNested Then
             Dim parentType As TypeReference = InflateType(original.DeclaringType, parameters, arguments)
             If parentType IsNot original Then
                 Return Compiler.CurrentCompiler.ModuleBuilderCecil.Import(FindDefinition(original))
             End If
         End If
 
         Return original
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="480" endline="504"><![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As FieldDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim elementType As Mono.Cecil.TypeDefinition
         Dim fieldType As Mono.Cecil.TypeReference
 
         If genericType Is Nothing Then
             Return Member
         End If
 
         elementType = CecilHelper.FindDefinition(genericType.ElementType)
         fieldType = CecilHelper.ResolveType(Member.FieldType, elementType.GenericParameters, genericType.GenericArguments)
 
         'If fieldType IsNot Member.FieldType Then
         fieldType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, fieldType)
 
         result = New FieldReference(Member.Name, fieldType, Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, Member.DeclaringType))
         result.Annotations.Add("MemberInReflection", New FieldReference(Member.Name, Member.FieldType, genericType))
         Return result
         'Else
         '    Return Member
         'End If
 
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="505" endline="519"><![CDATA[
 
 
     '
     'Emittable
     ' - 1Declarations/GenericProperty1 shows one case where vbnc and cecil/cil wants different things (method return type shouldn't be inflated for cecil/cil)
     '
     '
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodReference, ByVal Type As TypeReference, Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim mD As MethodDefinition = TryCast(Member, MethodDefinition)
 
         If mD IsNot Nothing Then Return GetCorrectMember(mD, Type, Emittable)
 
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="520" endline="531"><![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodReference, ByVal Arguments As Mono.Collections.Generic.Collection(Of TypeReference), Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim mD As MethodDefinition = TryCast(Member, MethodDefinition)
 
         If mD IsNot Nothing Then Return GetCorrectMember(mD, Arguments, Emittable)
         If Member.OriginalMethod IsNot Nothing Then
             mD = TryCast(Member.OriginalMethod, MethodDefinition)
             If mD IsNot Nothing Then Return GetCorrectMember(mD, Arguments, Emittable)
         End If
 
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="532" endline="574"><![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Arguments As Mono.Collections.Generic.Collection(Of TypeReference), Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Member.GenericParameters
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
 
         If Member.GenericParameters.Count = 0 Then Return Member
 
         returnType = CecilHelper.ResolveType(Member.ReturnType, parameters, Arguments)
         returnType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, returnType)
         result = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         For i As Integer = 0 To Member.GenericParameters.Count - 1
             result.GenericParameters.Add(Member.GenericParameters(i))
             reflectableMember.GenericParameters.Add(Member.GenericParameters(i))
         Next
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, parameters, Arguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="575" endline="647"><![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Type As Mono.Cecil.TypeReference, Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
         Dim genericArguments As Mono.Collections.Generic.Collection(Of TypeReference) = Nothing
         Dim genericParameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Nothing
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
         Dim declType As TypeReference = Nothing
 
         GetGenericArgsAndParams(Type, genericParameters, genericArguments)
 
         'If genericType Is Nothing Then
         '    Dim declType As TypeReference = Type
         '    While declType.IsNested
         '        Dim genType As GenericInstanceType = TryCast(declType, Mono.Cecil.GenericInstanceType)
         '        If genType IsNot Nothing Then
         '            If genericArguments Is Nothing Then genericArguments = New GenericArgumentCollection(Nothing)
         '            For Each arg As TypeReference In genType.GenericArguments
         '                genericArguments.Add(arg)
         '            Next
         '        End If
         '    End While
         '    Return Member
         'Else
         '    genericArguments = genericType.GenericArguments
         '    genericParameters = tD.GenericParameters
         'End If
 
         If genericParameters Is Nothing AndAlso genericArguments Is Nothing AndAlso tD Is Type AndAlso tD.Module Is Compiler.CurrentCompiler.ModuleBuilderCecil Then
             Return Member
         End If
 
         If Emittable Then
             returnType = Member.ReturnType
         Else
             returnType = CecilHelper.InflateType(Member.ReturnType, genericParameters, genericArguments)
         End If
         result = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         'If Member.DeclaringType.GenericParameters.Count > 0 AndAlso Not False Then
         '    Dim tmp As New GenericInstanceType(Member.DeclaringType)
         '    For i As Integer = 0 To Member.DeclaringType.GenericParameters.Count - 1
         '        tmp.GenericArguments.Add(Member.DeclaringType.GenericParameters(i))
         '    Next
         '    result.DeclaringType = tmp
         'End If
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, genericParameters, genericArguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="648" endline="723"><![CDATA[
 
     Public Shared Function MakeEmittable(ByVal Method As MethodReference) As MethodReference
         Dim result As MethodReference
         Dim genM As GenericInstanceMethod = TryCast(Method, GenericInstanceMethod)
         Dim tG As GenericInstanceType = TryCast(Method.DeclaringType, GenericInstanceType)
 
         If genM Is Nothing AndAlso tG Is Nothing Then
             If Method.DeclaringType.GenericParameters.Count > 0 Then
                 tG = New GenericInstanceType(Method.DeclaringType)
                 For i As Integer = 0 To Method.DeclaringType.GenericParameters.Count - 1
                     tG.GenericArguments.Add(Method.DeclaringType.GenericParameters(i))
                 Next
 
                 Dim mR As New Mono.Cecil.MethodReference(Method.Name, tG, Method.ReturnType, Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
                 For i As Integer = 0 To Method.Parameters.Count - 1
                     Dim param As Mono.Cecil.ParameterDefinition
                     param = New Mono.Cecil.ParameterDefinition(Method.Parameters(i).ParameterType)
                     mR.Parameters.Add(param)
                 Next
                 Return mR
             End If
         End If
 
         Dim mD As MethodDefinition = FindDefinition(Method)
 
         If mD Is Nothing Then
             If TypeOf Method.DeclaringType Is ArrayType Then
                 Dim arrayType As TypeReference
                 arrayType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType)
                 result = New MethodReference(Method.Name, Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType), Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.ReturnType), Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
                 For i As Integer = 0 To Method.Parameters.Count - 1
                     Dim pType As Mono.Cecil.TypeReference
                     pType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.Parameters(i).ParameterType)
                     If pType Is Method.Parameters(i).ParameterType Then
                         result.Parameters.Add(Method.Parameters(i))
                     Else
                         result.Parameters.Add(New ParameterDefinition(pType))
                     End If
                 Next
                 Return result
             End If
             Helper.Assert(mD IsNot Nothing)
             Return Nothing
         End If
 
         If mD Is Method AndAlso mD.DeclaringType.Module Is Compiler.CurrentCompiler.ModuleBuilderCecil Then
             Return mD
         End If
 
         If genM IsNot Nothing Then
             Dim gimResult As New GenericInstanceMethod(Helper.GetMethodOrMethodReference(BaseObject.m_Compiler, mD))
             gimResult.OriginalMethod = mD
             gimResult.ReturnType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, mD.ReturnType)
             For i As Integer = 0 To genM.GenericArguments.Count - 1
                 gimResult.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, genM.GenericArguments(i)))
             Next
             Return gimResult
         End If
 
         result = New MethodReference(Method.Name, Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType), Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, mD.ReturnType), Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
         For i As Integer = 0 To mD.Parameters.Count - 1
             Dim pType As Mono.Cecil.TypeReference
             pType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, mD.Parameters(i).ParameterType)
             If pType Is mD.Parameters(i).ParameterType Then
                 result.Parameters.Add(mD.Parameters(i))
             Else
                 result.Parameters.Add(New ParameterDefinition(pType))
             End If
         Next
         If mD.GenericParameters IsNot Nothing AndAlso mD.GenericParameters.Count > 0 Then
             For i As Integer = 0 To mD.GenericParameters.Count - 1
                 result.GenericParameters.Add(mD.GenericParameters(i))
             Next
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="724" endline="733"><![CDATA[
 
     Public Shared Function GetAssemblyRef(ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.AssemblyNameReference
         Dim modDef As ModuleDefinition = TryCast(Type.Scope, ModuleDefinition)
         If modDef IsNot Nothing Then Return modDef.Assembly.Name
 
         Dim assemblyRef As Mono.Cecil.AssemblyNameReference = TryCast(Type.Scope, AssemblyNameReference)
         If assemblyRef IsNot Nothing Then Return assemblyRef
 
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="734" endline="737"><![CDATA[
 
     Public Shared Function MakeByRefType(ByVal Type As Mono.Cecil.TypeReference) As ByReferenceType
         Return New ByReferenceType(Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="738" endline="745"><![CDATA[
 
     Public Shared Function MakeGenericMethod(ByVal Method As MethodReference, ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.GenericInstanceMethod
         Dim result As New Mono.Cecil.GenericInstanceMethod(Method)
         For i As Integer = 0 To Types.Length - 1
             result.GenericArguments.Add(Types(i))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="746" endline="753"><![CDATA[
 
     Public Shared Function GetNestedType(ByVal Type As TypeReference, ByVal Name As String) As TypeReference
         Dim tD As TypeDefinition = FindDefinition(Type)
         For i As Integer = 0 To tD.NestedTypes.Count - 1
             If Helper.CompareName(tD.NestedTypes(i).Name, Name) Then Return tD.NestedTypes(i)
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="754" endline="757"><![CDATA[
 
     Public Shared Function GetNestedTypes(ByVal Type As TypeReference) As Mono.Collections.Generic.Collection(Of TypeDefinition)
         Return FindDefinition(Type).NestedTypes
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="758" endline="772"><![CDATA[
 
     Public Shared Function GetMemberType(ByVal member As Mono.Cecil.MemberReference) As MemberTypes
         If TypeOf member Is FieldReference Then Return MemberTypes.Field
         If TypeOf member Is TypeReference Then Return MemberTypes.TypeInfo
         If TypeOf member Is MethodReference Then
             If Helper.CompareNameOrdinal(member.Name, ".ctor") OrElse Helper.CompareNameOrdinal(member.Name, ".cctor") Then
                 Return MemberTypes.Constructor
             Else
                 Return MemberTypes.Method
             End If
         End If
         If TypeOf member Is EventReference Then Return MemberTypes.Event
         If TypeOf member Is PropertyReference Then Return MemberTypes.Property
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="773" endline="776"><![CDATA[
 
     Public Shared Function IsStatic(ByVal Field As Mono.Cecil.FieldReference) As Boolean
         Return FindDefinition(Field).IsStatic
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="777" endline="780"><![CDATA[
 
     Public Shared Function IsStatic(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Return FindDefinition(Method).IsStatic
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="781" endline="786"><![CDATA[
 
     Public Shared Function MakeArrayType(ByVal Type As Mono.Cecil.TypeReference, Optional ByVal Ranks As Integer = 1) As Mono.Cecil.ArrayType
         Dim result As ArrayType
         result = New Mono.Cecil.ArrayType(Type, Ranks)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="787" endline="826"><![CDATA[
 
     Public Overloads Shared Function [GetType](ByVal Compiler As Compiler, ByVal value As Object) As Mono.Cecil.TypeReference
         If value Is Nothing Then Throw New InternalException("'Nothing' doesn't have a type")
         Select Case Type.GetTypeCode(value.GetType)
             Case TypeCode.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case TypeCode.Byte
                 Return Compiler.TypeCache.System_Byte
             Case TypeCode.Char
                 Return Compiler.TypeCache.System_Char
             Case TypeCode.DateTime
                 Return Compiler.TypeCache.System_DateTime
             Case TypeCode.DBNull
                 Return Compiler.TypeCache.System_DBNull
             Case TypeCode.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case TypeCode.Double
                 Return Compiler.TypeCache.System_Double
             Case TypeCode.Int16
                 Return Compiler.TypeCache.System_Int16
             Case TypeCode.Int32
                 Return Compiler.TypeCache.System_Int32
             Case TypeCode.Int64
                 Return Compiler.TypeCache.System_Int64
             Case TypeCode.SByte
                 Return Compiler.TypeCache.System_SByte
             Case TypeCode.Single
                 Return Compiler.TypeCache.System_Single
             Case TypeCode.String
                 Return Compiler.TypeCache.System_String
             Case TypeCode.UInt16
                 Return Compiler.TypeCache.System_UInt16
             Case TypeCode.UInt32
                 Return Compiler.TypeCache.System_UInt32
             Case TypeCode.UInt64
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 Throw New InternalException(String.Format("No constant value can be of the type '{0}'", value.GetType.FullName))
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="827" endline="830"><![CDATA[
 
     Public Shared Function GetCustomAttributes(ByVal Type As Mono.Cecil.TypeDefinition, ByVal AttributeType As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Return GetCustomAttributes(Type.CustomAttributes, AttributeType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="831" endline="844"><![CDATA[
 
     Public Shared Function GetCustomAttributes(ByVal Attributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal AttributeType As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim result As Mono.Collections.Generic.Collection(Of CustomAttribute) = Nothing
 
         For i As Integer = 0 To Attributes.Count - 1
             Dim attrib As CustomAttribute = Attributes(i)
             If Helper.CompareType(AttributeType, attrib.Constructor.DeclaringType) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of CustomAttribute)()
                 result.Add(attrib)
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="845" endline="851"><![CDATA[
 
     Public Shared Function GetAttributeCtorString(ByVal Attrib As CustomAttribute, ByVal index As Integer) As String
         Dim result As String
         If Attrib.ConstructorArguments.Count - 1 < index Then Return Nothing
         result = TryCast(Attrib.ConstructorArguments(index).Value, String)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="852" endline="859"><![CDATA[
 
     Public Shared Function IsDefined(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Boolean
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then Return True
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="860" endline="871"><![CDATA[
 
     Public Shared Function GetAttributes(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim result As Mono.Collections.Generic.Collection(Of CustomAttribute) = Nothing
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of CustomAttribute)()
                 result.Add(Attribute)
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="872" endline="875"><![CDATA[
 
     Public Shared Function IsGenericParameter(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return TypeOf Type Is Mono.Cecil.GenericParameter
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="876" endline="883"><![CDATA[
 
     Public Shared Function IsGenericType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, GenericInstanceType)
         If genericType IsNot Nothing Then Return True
         If Type.GenericParameters Is Nothing OrElse Type.GenericParameters.Count = 0 Then Return False
         If Type.GenericParameters IsNot Nothing AndAlso Type.GenericParameters.Count > 0 Then Return True
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="884" endline="888"><![CDATA[
 
     Public Shared Function IsGenericTypeDefinition(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Dim tD As Mono.Cecil.TypeDefinition = TryCast(Type, Mono.Cecil.TypeDefinition)
         Return tD IsNot Nothing AndAlso tD.GenericParameters.Count > 0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="889" endline="892"><![CDATA[
 
     Public Shared Function ContainsGenericParameters(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="893" endline="900"><![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of GenericParameter)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="901" endline="908"><![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="909" endline="917"><![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tR As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         If tR Is Nothing Then
             Return GetTypes(Type.GenericParameters)
         Else
             Return GetTypes(tR.GenericArguments)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="918" endline="926"><![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Method As Mono.Cecil.MethodReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim mR As Mono.Cecil.GenericInstanceMethod = TryCast(Method, Mono.Cecil.GenericInstanceMethod)
         If mR Is Nothing Then
             Return GetTypes(Method.GenericParameters)
         Else
             Return GetTypes(mR.GenericArguments)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="927" endline="930"><![CDATA[
 
     Public Shared Function GetGenericTypeDefinition(ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeDefinition
         Return FindDefinition(Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="931" endline="934"><![CDATA[
 
     Public Shared Function GetGenericMethod(ByVal Method As Mono.Cecil.MethodReference) As Mono.Cecil.MethodReference
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="935" endline="941"><![CDATA[
 
     Public Shared Function IsGenericMethod(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         If TypeOf Method Is Mono.Cecil.GenericInstanceMethod Then Return True
         If Method.GenericParameters.Count > 0 Then Return True
         Return False
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="942" endline="946"><![CDATA[
 
     Public Shared Function IsGenericMethodDefinition(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Return Method.GenericParameters.Count > 0
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="947" endline="953"><![CDATA[
 
     'Cecil's ValueType property returns true for arrays of value types
     Public Shared Function IsValueType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If TypeOf Type Is ArrayType Then Return False
         If TypeOf Type Is ByReferenceType Then Return False
         Return Type.IsValueType
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="954" endline="967"><![CDATA[
 
     Public Shared Function IsNullable(ByVal Type As TypeReference) As Boolean
         Dim git As GenericInstanceType
 
         If Type Is Nothing Then Return False
         If Not Type.IsGenericInstance Then Return False
 
         If Helper.CompareNameOrdinal(Type.Name, "Nullable`1") = False Then Return False
 
         git = TryCast(Type, GenericInstanceType)
         If git Is Nothing Then Return False
 
         Return Helper.CompareType(Compiler.CurrentCompiler.TypeCache.System_Nullable1, git.ElementType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="968" endline="973"><![CDATA[
 
     Public Shared Function GetNulledType(ByVal Type As TypeReference) As TypeReference
         'No checking done, caller must call IsNullable first
         Dim git As GenericInstanceType = DirectCast(Type, GenericInstanceType)
         Return git.GenericArguments()(0)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="974" endline="977"><![CDATA[
 
     Public Shared Function IsByRef(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return TypeOf Type Is ByReferenceType
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="978" endline="981"><![CDATA[
 
     Public Shared Function IsArray(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return TypeOf Type Is Mono.Cecil.ArrayType
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="982" endline="1045"><![CDATA[
 
     Public Shared Function GetInterfaces(ByVal Type As Mono.Cecil.TypeReference, ByVal checkBase As Boolean) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim result As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tmp As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, Mono.Cecil.GenericParameter)
 
         If tG IsNot Nothing Then
             If tG.Constraints.Count = 0 Then Return Nothing
             result = New Mono.Collections.Generic.Collection(Of TypeReference)
             For i As Integer = 0 To tG.Constraints.Count - 1
                 For Each t As TypeReference In GetInterfaces(tG.Constraints(i), checkBase)
                     result.Add(t)
                 Next
             Next
             Return result
         End If
 
         Dim arrD As Mono.Cecil.ArrayType = TryCast(Type, Mono.Cecil.ArrayType)
         If arrD IsNot Nothing Then
             result = New Mono.Collections.Generic.Collection(Of TypeReference)
             For Each tp As TypeReference In GetInterfaces(BaseObject.m_Compiler.TypeCache.System_Array, False)
                 result.Add(tp)
             Next
             For Each tp As TypeDefinition In New TypeDefinition() {BaseObject.m_Compiler.TypeCache.System_Collections_Generic_ICollection1, BaseObject.m_Compiler.TypeCache.System_Collections_Generic_IEnumerable1, BaseObject.m_Compiler.TypeCache.System_Collections_Generic_IList1}
                 Dim newTP As New GenericInstanceType(tp)
                 newTP.GenericArguments.Add(arrD.ElementType)
                 result.Add(newTP)
             Next
             Return result
         End If
 
         tD = FindDefinition(Type)
 
         result = New Mono.Collections.Generic.Collection(Of TypeReference)
         For i As Integer = 0 To tD.Interfaces.Count - 1
             result.Add(InflateType(tD.Interfaces(i), Type))
         Next
 
         If genericType IsNot Nothing Then
             For i As Integer = 0 To result.Count - 1
                 tmp = CecilHelper.ResolveType(result(i), CecilHelper.FindDefinition(genericType).GenericParameters, genericType.GenericArguments)
                 result.Item(i) = tmp
             Next
         End If
 
         If checkBase Then
             Dim bT As Mono.Cecil.TypeReference
 
             bT = tD.BaseType
             If bT IsNot Nothing Then
                 If genericType IsNot Nothing Then
                     bT = CecilHelper.GetCorrectMember(bT, genericType)
                 End If
 
                 For Each t As Mono.Cecil.TypeReference In GetInterfaces(bT, checkBase)
                     result.Add(t)
                 Next
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1046" endline="1053"><![CDATA[
 
     Public Shared Function GetElementType(ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim rT As ByReferenceType = TryCast(Type, ByReferenceType)
         If rT IsNot Nothing Then Return rT.ElementType
         Dim aT As Mono.Cecil.ArrayType = TryCast(Type, Mono.Cecil.ArrayType)
         If aT IsNot Nothing Then Return aT.ElementType
         Throw New InternalException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1054" endline="1066"><![CDATA[
 
     Public Shared Function IsPrimitive(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Select Case Helper.GetTypeCode(Compiler, Type)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Char, TypeCode.Double, TypeCode.Single
                 Return True
             Case Else
                 If Helper.CompareType(Type, Compiler.TypeCache.System_IntPtr) Then
                     Return True
                 Else
                     Return False
                 End If
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1067" endline="1072"><![CDATA[
 
     Public Shared Function GetArrayRank(ByVal Type As Mono.Cecil.TypeReference) As Integer
         Dim aT As ArrayType = TryCast(Type, ArrayType)
         If aT Is Nothing Then Return 0
         Return aT.Rank
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1073" endline="1079"><![CDATA[
 
     Public Shared Function GetGetMethod(ByVal Prop As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.GetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1080" endline="1086"><![CDATA[
 
     Public Shared Function GetSetMethod(ByVal Prop As PropertyReference) As MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.SetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1087" endline="1105"><![CDATA[
 
     Public Shared Function IsClass(ByVal Type As TypeReference) As Boolean
         Dim tD As Mono.Cecil.TypeDefinition
         Dim tG As Mono.Cecil.GenericParameter
 
         If IsValueType(Type) Then Return False
         If TypeOf Type Is Mono.Cecil.ArrayType Then Return True
 
         tG = TryCast(Type, Mono.Cecil.GenericParameter)
         If tG IsNot Nothing Then
             If tG.HasReferenceTypeConstraint Then Return True
             If tG.HasNotNullableValueTypeConstraint Then Return False
             Return True
         End If
 
         tD = FindDefinition(Type)
 
         Return tD.IsClass
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1106" endline="1113"><![CDATA[
 
     Public Shared Function GetGenericParameterAttributes(ByVal Type As TypeReference) As GenericParameterAttributes
         Dim gt As Mono.Cecil.GenericParameter
 
         gt = DirectCast(Type, Mono.Cecil.GenericParameter)
 
         Return gt.Attributes
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1114" endline="1119"><![CDATA[
 
     Public Shared Function IsInterface(ByVal Type As TypeReference) As Boolean
         If TypeOf Type Is ArrayType Then Return False
         If TypeOf Type Is GenericParameter Then Return False
         Return FindDefinition(Type).IsInterface
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1120" endline="1123"><![CDATA[
 
     Public Shared Function FindDefinition(ByVal name As AssemblyNameReference) As AssemblyDefinition
         Return Compiler.CurrentCompiler.AssemblyResolver.Resolve(name)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1124" endline="1140"><![CDATA[
 
     Public Shared Function GetBaseType(ByVal Type As TypeReference) As TypeReference
         Dim result As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition
 
         tD = CecilHelper.FindDefinition(Type)
 
         If tD Is Nothing Then Return Nothing
 
         result = tD.BaseType
 
         If result Is Nothing Then Return Nothing
 
         result = CecilHelper.InflateType(result, Type)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1141" endline="1147"><![CDATA[
 
     Public Shared Function FindField(ByVal fields As Mono.Collections.Generic.Collection(Of FieldDefinition), ByVal name As String) As FieldDefinition
         For i As Integer = 0 To fields.Count - 1
             If Helper.CompareNameOrdinal(fields(i).Name, name) Then Return fields(i)
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1148" endline="1158"><![CDATA[
 
     Public Shared Function FindProperties(ByVal properties As Mono.Collections.Generic.Collection(Of PropertyDefinition), ByVal name As String) As Mono.Collections.Generic.Collection(Of PropertyDefinition)
         Dim result As Mono.Collections.Generic.Collection(Of PropertyDefinition) = Nothing
         For i As Integer = 0 To properties.Count - 1
             If Helper.CompareNameOrdinal(properties(i).Name, name) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of PropertyDefinition)
                 result.Add(properties(i))
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1159" endline="1172"><![CDATA[
 
     Public Shared Function FindConstructor(ByVal Methods As Mono.Collections.Generic.Collection(Of MethodDefinition), ByVal [Shared] As Boolean, ByVal parameters() As TypeReference) As MethodReference
         For i As Integer = 0 To Methods.Count - 1
             Dim mr As MethodDefinition = Methods(i)
 
             If mr.IsConstructor = False Then Continue For
             If mr.IsStatic Then
                 If [Shared] Then Return mr
                 Continue For
             End If
             If Helper.CompareTypes(Helper.GetParameterTypes(Compiler.CurrentCompiler, mr), parameters) Then Return mr
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1173" endline="1202"><![CDATA[
 
     Public Shared Function FindDefinition(ByVal type As TypeReference) As TypeDefinition
         If type Is Nothing Then Return Nothing
         Dim tD As TypeDefinition = TryCast(type, TypeDefinition)
         If tD IsNot Nothing Then Return tD
         type = type.GetElementType
         If TypeOf type Is TypeDefinition Then
             Return DirectCast(type, TypeDefinition)
         End If
         Dim reference As AssemblyNameReference = TryCast(type.Scope, AssemblyNameReference)
         If reference IsNot Nothing Then
             Dim assembly As AssemblyDefinition = FindDefinition(reference)
             If type.IsNested Then
                 Return assembly.MainModule.GetType(type.FullName)
             Else
                 Return assembly.MainModule.GetType(type.Namespace, type.Name)
             End If
         End If
         Dim moduledef As ModuleDefinition = TryCast(type.Scope, ModuleDefinition)
         If moduledef IsNot Nothing Then
             Dim fn As String
             If type.IsNested Then
                 fn = FindDefinition(type.DeclaringType).FullName + "/" + type.Name
                 Return moduledef.GetType(fn)
             Else
                 Return moduledef.GetType(type.Namespace, type.Name)
             End If
         End If
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1203" endline="1210"><![CDATA[
 
     Public Shared Function FindDefinition(ByVal field As FieldReference) As FieldDefinition
         If field Is Nothing Then Return Nothing
         Dim fD As FieldDefinition = TryCast(field, FieldDefinition)
         If fD IsNot Nothing Then Return fD
         Dim type As TypeDefinition = FindDefinition(field.DeclaringType)
         Return GetField(type.Fields, field)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1211" endline="1217"><![CDATA[
 
     Public Shared Function FindDefinition(ByVal param As ParameterReference) As ParameterDefinition
         If param Is Nothing Then Return Nothing
         Dim pD As ParameterDefinition = TryCast(param, ParameterDefinition)
         If pD IsNot Nothing Then Return pD
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1218" endline="1227"><![CDATA[
 
     Public Shared Function GetField(ByVal collection As ICollection, ByVal reference As FieldReference) As FieldDefinition
         For Each field As FieldDefinition In collection
             If Not Helper.CompareNameOrdinal(field.Name, reference.Name) Then
                 Continue For
             End If
             Return field
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1228" endline="1249"><![CDATA[
 
     Public Shared Function FindDefinition(ByVal method As MethodReference) As MethodDefinition
         If method Is Nothing Then Return Nothing
         Dim type As TypeDefinition
 
         If TypeOf method Is MethodDefinition Then Return DirectCast(method, MethodDefinition)
 
         'If TypeOf method.DeclaringType Is ArrayType Then
         '    type = Compiler.CurrentCompiler.TypeCache.System_Array
         'Else
         type = FindDefinition(method.DeclaringType)
         'End If
         If method.OriginalMethod IsNot Nothing Then
             method = method.OriginalMethod
         Else
             method = method.GetElementMethod
         End If
 
         If TypeOf method Is MethodDefinition Then Return DirectCast(method, MethodDefinition)
 
         Return GetMethod(type, method)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1250" endline="1271"><![CDATA[
 
     Public Shared Function FindDefinition(ByVal method As PropertyReference) As PropertyDefinition
         If method Is Nothing Then Return Nothing
         Dim pD As PropertyDefinition
 
         If method.Annotations.Contains("OriginalProperty") Then
             pD = DirectCast(method.Annotations("OriginalProperty"), PropertyDefinition)
             Return pD
         End If
 
         pD = TryCast(method, PropertyDefinition)
 
         If pD IsNot Nothing Then Return pD
 
         Dim type As TypeDefinition = FindDefinition(method.DeclaringType)
         'method = method.GetOriginalMethod
         'If Helper.CompareNameOrdinal(method.Name, MethodDefinition.Cctor) OrElse Helper.CompareNameOrdinal(method.Name, MethodDefinition.Ctor) Then
         '    Return GetMethod(type.Constructors, method)
         'Else
         Return GetProperty(type.Properties, method)
         'End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1272" endline="1282"><![CDATA[
 
     Public Shared Function FindDefinition(ByVal method As EventReference) As EventDefinition
         If method Is Nothing Then Return Nothing
         Dim type As TypeDefinition = FindDefinition(method.DeclaringType)
         'method = method.GetOriginalMethod
         'If Helper.CompareNameOrdinal(method.Name, MethodDefinition.Cctor) OrElse Helper.CompareNameOrdinal(method.Name, MethodDefinition.Ctor) Then
         '    Return GetMethod(type.Constructors, method)
         'Else
         Return GetEvent(type.Events, method)
         'End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1283" endline="1292"><![CDATA[
 
     Public Shared Function GetEvent(ByVal collection As ICollection, ByVal reference As EventReference) As EventDefinition
         For Each meth As EventDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1293" endline="1299"><![CDATA[
 
     Public Shared Function GetMethod(ByVal type As ICollection, ByVal reference As MethodReference) As MethodDefinition
         For Each item As Mono.Cecil.MethodDefinition In type
             If CecilHelper.AreSame(reference, item) Then Return item
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1300" endline="1311"><![CDATA[
 
     Public Shared Function GetMethod(ByVal type As TypeDefinition, ByVal reference As MethodReference) As MethodDefinition
         While type IsNot Nothing
             Dim method As MethodDefinition = GetMethod(type.Methods, reference)
             If method Is Nothing Then
                 type = FindDefinition(type.BaseType)
             Else
                 Return method
             End If
         End While
         While type IsNot Nothing
             Dim method As MethodDefinition = GetMethod(type.Methods, reference)
             If method Is Nothing Then
                 type = FindDefinition(type.BaseType)
             Else
                 Return method
             End If
         End While
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1312" endline="1327"><![CDATA[
 
     Public Shared Function GetProperty(ByVal collection As ICollection, ByVal reference As PropertyReference) As PropertyDefinition
         For Each meth As PropertyDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             If Not AreSame(meth.PropertyType, reference.PropertyType) Then
                 Continue For
             End If
             If Not AreSame(meth.Parameters, reference.Parameters) Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1328" endline="1333"><![CDATA[
 
     Public Shared Function AreSame(ByVal a As MethodReference, ByVal b As MethodReference) As Boolean
         If Helper.CompareNameOrdinal(a.Name, b.Name) = False Then Return False
         If a.GenericParameters.Count <> b.GenericParameters.Count Then Return False
         Return AreSame(a.Parameters, b.Parameters)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1334" endline="1342"><![CDATA[
 
     Public Shared Function AreSame(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         If a.Count = 0 Then Return True
         For i As Integer = 0 To a.Count - 1
             If Not AreSame(a(i).ParameterType, b(i).ParameterType) Then Return False
         Next
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1343" endline="1362"><![CDATA[
 
     Public Shared Function AreSame(ByVal a As TypeReference, ByVal b As TypeReference) As Boolean
         While TypeOf a Is TypeSpecification OrElse TypeOf b Is TypeSpecification
             If a.GetType IsNot b.GetType Then
                 Return False
             End If
             a = DirectCast(a, TypeSpecification).ElementType
             b = DirectCast(b, TypeSpecification).ElementType
         End While
         While TypeOf a Is TypeSpecification OrElse TypeOf b Is TypeSpecification
             If a.GetType IsNot b.GetType Then
                 Return False
             End If
             a = DirectCast(a, TypeSpecification).ElementType
             b = DirectCast(b, TypeSpecification).ElementType
         End While
         If TypeOf a Is GenericParameter OrElse TypeOf b Is GenericParameter Then
             If a.GetType IsNot b.GetType Then
                 Return False
             End If
             Dim pa As GenericParameter = DirectCast(a, GenericParameter)
             Dim pb As GenericParameter = DirectCast(b, GenericParameter)
 
             Return pa.Position = pb.Position
         End If
         Return Helper.CompareNameOrdinal(a.FullName, b.FullName)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="85" endline="93"><![CDATA[
         Get
             If m_SymbolDocument Is Nothing Then
                 m_SymbolDocument = New Mono.Cecil.Cil.Document(System.IO.Path.Combine(m_RelativePath.Replace("<"c, "["c).Replace(">"c, "]"c), m_FileName.Replace("<"c, "["c).Replace(">"c, "]"c)))
                 m_SymbolDocument.Language = Cil.DocumentLanguage.Basic
                 m_SymbolDocument.LanguageVendor = Cil.DocumentLanguageVendor.Microsoft
                 m_SymbolDocument.Type = Cil.DocumentType.Text
             End If
             Return m_SymbolDocument
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="94" endline="99"><![CDATA[
     End Property
 
     Sub AddConditionalConstants(ByVal Line As UInteger, ByVal Constants As ConditionalConstants)
         m_ConditionalConstants.Add(Constants.Clone)
         m_ConditionalConstantsLines.Add(Line)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="100" endline="116"><![CDATA[
 
     Function GetConditionalConstants(ByVal Line As UInteger) As ConditionalConstants
         If m_ConditionalConstantsLines.Count = 0 Then Return Nothing
 
         'If the first #const is after the line, no constants in this file at the line
         If m_ConditionalConstantsLines(0) > Line Then Return Nothing
 
         For i As Integer = 0 To m_ConditionalConstantsLines.Count - 1
             'If the current #const is after the line, the previous one corresponds to the line
             If m_ConditionalConstantsLines(i) > Line Then
                 Return m_ConditionalConstants(i - 1)
             End If
         Next
 
         'If no constants are after the line, the last is the one.
         Return m_ConditionalConstants(m_ConditionalConstants.Count - 1)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="117" endline="124"><![CDATA[
 
     Private Shared ReadOnly Property UTF8Throw() As System.Text.Encoding
         Get
             ' Use no preamble to let StreamReader use a non-throwing decoder
             ' when UTF-8 byte order mark found.
             If m_UTF8Throw Is Nothing Then m_UTF8Throw = New System.Text.UTF8Encoding(False, True)
             Return m_UTF8Throw
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="125" endline="130"><![CDATA[
     End Property
 
     Property RelativePath() As String
         Get
             Return m_RelativePath
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="131" endline="133"><![CDATA[
         Set(ByVal value As String)
             m_RelativePath = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="134" endline="138"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_Imports.ResolveCode(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="139" endline="143"><![CDATA[
 
     ReadOnly Property OptionExplicit() As OptionExplicitStatement
         Get
             Return m_OptionExplicit
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="144" endline="149"><![CDATA[
     End Property
 
     ReadOnly Property OptionStrict() As OptionStrictStatement
         Get
             Return m_OptionStrict
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="150" endline="155"><![CDATA[
     End Property
 
     ReadOnly Property OptionCompare() As OptionCompareStatement
         Get
             Return m_OptionCompare
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="156" endline="161"><![CDATA[
     End Property
 
     ReadOnly Property OptionInfer As OptionInferStatement
         Get
             Return m_OptionInfer
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="162" endline="171"><![CDATA[
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="172" endline="184"><![CDATA[
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="199" endline="212"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="213" endline="222"><![CDATA[
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="223" endline="232"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareText() As Boolean
         Get
             Return Not IsOptionCompareBinary
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="233" endline="241"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The imports clauses this file has.
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsClauses
         Get
             Return m_Imports
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="242" endline="261"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="262" endline="277"><![CDATA[
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
     Private m_ConditionalConstants As New Generic.List(Of ConditionalConstants)
     Private m_ConditionalConstantsLines As New Generic.List(Of UInteger)
 
     Private m_Code As String
 
     Public ReadOnly Property SymbolDocument() As Mono.Cecil.Cil.Document
         Get
             If m_SymbolDocument Is Nothing Then
                 m_SymbolDocument = New Mono.Cecil.Cil.Document(System.IO.Path.Combine(m_RelativePath.Replace("<"c, "["c).Replace(">"c, "]"c), m_FileName.Replace("<"c, "["c).Replace(">"c, "]"c)))
                 m_SymbolDocument.Language = Cil.DocumentLanguage.Basic
                 m_SymbolDocument.LanguageVendor = Cil.DocumentLanguageVendor.Microsoft
                 m_SymbolDocument.Type = Cil.DocumentType.Text
             End If
             Return m_SymbolDocument
         End Get
     End Property
 
     Sub AddConditionalConstants(ByVal Line As UInteger, ByVal Constants As ConditionalConstants)
         m_ConditionalConstants.Add(Constants.Clone)
         m_ConditionalConstantsLines.Add(Line)
     End Sub
 
     Function GetConditionalConstants(ByVal Line As UInteger) As ConditionalConstants
         If m_ConditionalConstantsLines.Count = 0 Then Return Nothing
 
         'If the first #const is after the line, no constants in this file at the line
         If m_ConditionalConstantsLines(0) > Line Then Return Nothing
 
         For i As Integer = 0 To m_ConditionalConstantsLines.Count - 1
             'If the current #const is after the line, the previous one corresponds to the line
             If m_ConditionalConstantsLines(i) > Line Then
                 Return m_ConditionalConstants(i - 1)
             End If
         Next
 
         'If no constants are after the line, the last is the one.
         Return m_ConditionalConstants(m_ConditionalConstants.Count - 1)
     End Function
 
     Private Shared ReadOnly Property UTF8Throw() As System.Text.Encoding
         Get
             ' Use no preamble to let StreamReader use a non-throwing decoder
             ' when UTF-8 byte order mark found.
             If m_UTF8Throw Is Nothing Then m_UTF8Throw = New System.Text.UTF8Encoding(False, True)
             Return m_UTF8Throw
         End Get
     End Property
 
     Property RelativePath() As String
         Get
             Return m_RelativePath
         End Get
         Set(ByVal value As String)
             m_RelativePath = value
         End Set
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_Imports.ResolveCode(Info)
     End Function
 
     ReadOnly Property OptionExplicit() As OptionExplicitStatement
         Get
             Return m_OptionExplicit
         End Get
     End Property
 
     ReadOnly Property OptionStrict() As OptionStrictStatement
         Get
             Return m_OptionStrict
         End Get
     End Property
 
     ReadOnly Property OptionCompare() As OptionCompareStatement
         Get
             Return m_OptionCompare
         End Get
     End Property
 
     ReadOnly Property OptionInfer As OptionInferStatement
         Get
             Return m_OptionInfer
         End Get
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareText() As Boolean
         Get
             Return Not IsOptionCompareBinary
         End Get
     End Property
 
     ''' <summary>
     ''' The imports clauses this file has.
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsClauses
         Get
             Return m_Imports
         End Get
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
         'Try to get the absolute path for all files.
         If FileName Is Nothing OrElse FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) >= 0 Then
             m_FileName = FileName
         Else
             m_FileName = IO.Path.GetFullPath(FileName)
         End If
         m_RelativePath = RelativePath
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="278" endline="282"><![CDATA[
 
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject, ByVal Code As String)
         Me.New(FileName, RelativePath, Parent)
         m_Code = Code
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="283" endline="303"><![CDATA[
 
     ReadOnly Property CodeStream() As IO.StreamReader
         Get
             Dim Stream As System.IO.Stream
             Dim StreamReader As System.IO.StreamReader
 
             Try
                 If m_Code IsNot Nothing Then
                     Stream = New System.IO.MemoryStream(Compiler.CommandLine.Encoding.GetBytes(m_Code))
                 Else
                     Stream = New System.IO.FileStream(FileName, IO.FileMode.Open, IO.FileAccess.Read, IO.FileShare.Read)
                 End If
 
                 StreamReader = New System.IO.StreamReader(Stream, Compiler.CommandLine.Encoding, True)
 
                 Return StreamReader
             Catch e As Exception
                 Compiler.Report.ShowMessage(Messages.VBNC31007, Span.CommandLineSpan, FileName)
                 Return Nothing
             End Try
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="304" endline="324"><![CDATA[
     End Property
 
     ''' <summary>
     ''' This function is only used for error reporting, no need to do things fast.
     ''' </summary>
     ''' <param name="LineNumber"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DoesLineEndWithLineContinuation(ByVal LineNumber As UInteger) As Boolean
         Dim lines() As String
         Using stream As IO.StreamReader = CodeStream
             lines = stream.ReadToEnd().Split(New String() {VB.vbCrLf, VB.vbCr, VB.vbLf}, StringSplitOptions.None)
         End Using
         If lines.Length < LineNumber Then Return False
 
         Dim line As String = lines(CInt(LineNumber - 1UI))
         Do While line.Length > 0 AndAlso Scanner.IsWhiteSpace(line(line.Length - 1))
             line = line.Substring(0, line.Length - 1)
         Loop
         Do While line.Length > 0 AndAlso Scanner.IsWhiteSpace(line(line.Length - 1))
             line = line.Substring(0, line.Length - 1)
         Loop
         Return line.EndsWith(" _")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="325" endline="334"><![CDATA[
 
     ''' <summary>
     ''' The Filename of the codefile.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property FileName() As String
         Get
             Return m_FileName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="335" endline="349"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The filename to report to the user in errors.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property FileNameToReport() As String
         Get
             If m_FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars) >= 0 Then
                 Return m_FileName
             End If
             Return System.IO.Path.Combine(m_RelativePath, System.IO.Path.GetFileName(m_FileName))
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFiles.vb" startline="26" endline="28"><![CDATA[
     Sub New(ByVal Compiler As Compiler)
         MyBase.new(Compiler)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFiles.vb" startline="29" endline="32"><![CDATA[
 
     Function Resolve(ByVal Info As ResolveInfo) As Boolean
         Return ResolveCode(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="105" endline="105"><![CDATA[
     Private Shared PATTERNCHARS As Char() = New Char() {"*"c, "?"c}
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="106" endline="138"><![CDATA[
 
     ''' <summary>
     ''' There can be many response files, including response files called
     ''' from a response file. Keep a list of them all to know when a
     ''' response file already has been parsed, to avoid stack problems 
     ''' (and a response file shouldn't be included twice anyway)
     ''' </summary>
     Private m_lstResponseFiles As New Specialized.StringCollection
 
     ''' <summary>
     ''' All files specified
     ''' </summary>s
     ''' <remarks></remarks>
     Private m_lstFileNames As CodeFiles
 
     ''' <summary>
     ''' A list of all the arguments parsed.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_lstAllArgs As New Specialized.StringCollection
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     Private m_Compiler As Compiler
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="139" endline="378"><![CDATA[
     End Property
 
 #Region "Properties"
 
     ' - OUTPUT FILE -
 
     ''' <summary>
     ''' /out
     ''' </summary>
     Private m_strOut As String
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     Private m_strTarget As Targets
 
     ''' <summary>
     ''' /doc[+|-]               Generates XML documentation file.
     ''' /doc
     ''' </summary>
     ''' <remarks></remarks>
     Private m_strDoc As String
 
     ' - INPUT FILES -
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     Private m_lstModules As New Specialized.StringCollection
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     Private m_lstRecurse As New Specialized.StringCollection
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     Private m_lstReferences As New Specialized.StringCollection
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     Private m_lstLinkResources As Resources
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     Private m_lstResources As Resources
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     Private m_strWin32Icon As String
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     Private m_strWin32Resource As String
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     Private m_bOptimize As Boolean
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     Private m_bRemoveIntChecks As Boolean
 
     ''' <summary>
     ''' /debug[+|-]             Emit debugging information.
     '''/debug
     '''/debug
     ''' According to #81054 vbc doesn't emit debug info unless /debug is specified.
     ''' </summary>
     Private m_eDebugInfo As DebugTypes = DebugTypes.None
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     Private m_bNoWarn As Boolean
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     Private m_bWarnAsError As Boolean
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     Private m_lstDefine As New Defines
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     Private m_lstImports As ImportsStatement
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     Private m_eOptionExplicit As OptionExplicitTypes = OptionExplicitTypes.On
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     Private m_eOptionStrict As OptionStrictTypes = OptionStrictTypes.Off
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_eOptionInfer As OptionInferTypes = OptionInferTypes.Off
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     Private m_strRootNamespace As String
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     Private m_eOptionCompare As OptionCompareTypes = OptionCompareTypes.Binary
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     Private m_bHelp As Boolean
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     Private m_bNoLogo As Boolean
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     Private m_bQuiet As Boolean
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     Private m_bVerbose As Boolean
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     Private m_bNoConfig As Boolean
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_bTrace As Boolean
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     Private m_strBaseAddress As String
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     Private m_strBugReport As String
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     Private m_Encoding As System.Text.Encoding
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     Private m_bDelaySign As Boolean
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     Private m_strKeyContainer As String
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     Private m_strKeyFile As String
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     Private m_lstLibPath As New Specialized.StringCollection
 
     ''' <summary>
     ''' /main
     ''' </summary>
     Private m_strMain As String
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     Private m_bNetCF As Boolean
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     Private m_strSDKPath As String
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     Private m_bUTF8Output As Boolean
 
     Private m_VBRuntime As String = "Microsoft.VisualBasic.dll"
 
     ''' <summary>
     ''' /vbversion
     ''' </summary>
     ''' <remarks></remarks>
     Private m_VBVersion As VBVersions = VBVersions.V8
     ' - OUTPUT FILE -
 
 
     ReadOnly Property VBVersion() As VBVersions
         Get
             Return m_VBVersion
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="379" endline="387"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /out
     ''' </summary>
     ReadOnly Property Out() As String
         Get
             Return m_strOut
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="388" endline="399"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     ReadOnly Property Target() As Targets
         Get
             Return m_strTarget
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="400" endline="410"><![CDATA[
     End Property
 
     ' - INPUT FILES - 
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     ReadOnly Property Modules() As Specialized.StringCollection
         Get
             Return m_lstModules
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="411" endline="419"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     ReadOnly Property Recurse() As Specialized.StringCollection
         Get
             Return m_lstRecurse
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="420" endline="428"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     ReadOnly Property References() As Specialized.StringCollection
         Get
             Return m_lstReferences
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="429" endline="439"><![CDATA[
     End Property
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     ReadOnly Property LinkResources() As Resources
         Get
             Return m_lstLinkResources
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="440" endline="448"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     ReadOnly Property Resources() As Resources
         Get
             Return m_lstResources
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="449" endline="457"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     ReadOnly Property Win32Icon() As String
         Get
             Return m_strWin32Icon
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="458" endline="466"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     ReadOnly Property Win32Resource() As String
         Get
             Return m_strWin32Resource
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="467" endline="477"><![CDATA[
     End Property
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     ReadOnly Property Optimize() As Boolean
         Get
             Return m_bOptimize
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="478" endline="486"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     ReadOnly Property RemoveIntChecks() As Boolean
         Get
             Return m_bRemoveIntChecks
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="487" endline="496"><![CDATA[
     End Property
 
     ''' <summary>
     '''/debug
     '''/debug
     ''' </summary>
     ReadOnly Property DebugInfo() As DebugTypes
         Get
             Return m_eDebugInfo
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="497" endline="507"><![CDATA[
     End Property
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     ReadOnly Property NoWarn() As Boolean
         Get
             Return m_bNoLogo
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="508" endline="516"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     ReadOnly Property WarnAsError() As Boolean
         Get
             Return m_bWarnAsError
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="517" endline="527"><![CDATA[
     End Property
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     ReadOnly Property Define() As Defines
         Get
             Return m_lstDefine
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="528" endline="536"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsStatement
         Get
             Return m_lstImports
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="537" endline="545"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     ReadOnly Property OptionExplicit() As OptionExplicitTypes
         Get
             Return m_eOptionExplicit
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="546" endline="554"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     ReadOnly Property OptionStrict() As OptionStrictTypes
         Get
             Return m_eOptionStrict
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="555" endline="563"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     ReadOnly Property RootNamespace() As String
         Get
             Return m_strRootNamespace
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="564" endline="573"><![CDATA[
     End Property
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     ReadOnly Property OptionCompare() As OptionCompareTypes
         Get
             Return m_eOptionCompare
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="574" endline="583"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property OptionInfer As OptionInferTypes
         Get
             Return m_eOptionInfer
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="584" endline="594"><![CDATA[
     End Property
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     ReadOnly Property Help() As Boolean
         Get
             Return m_bHelp
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="595" endline="603"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     ReadOnly Property NoLogo() As Boolean
         Get
             Return m_bNoLogo
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="604" endline="612"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     ReadOnly Property Quiet() As Boolean
         Get
             Return m_bQuiet
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="613" endline="621"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     ReadOnly Property Verbose() As Boolean
         Get
             Return m_bVerbose
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="622" endline="630"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     ReadOnly Property NoConfig() As Boolean
         Get
             Return m_bNoConfig
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="631" endline="642"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Trace As Boolean
         Get
             Return m_bTrace
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="643" endline="648"><![CDATA[
     End Property
 
     ReadOnly Property VBRuntime() As String
         Get
             Return m_VBRuntime
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="649" endline="659"><![CDATA[
     End Property
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     ReadOnly Property BaseAddress() As String
         Get
             Return m_strBaseAddress
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="660" endline="668"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     ReadOnly Property BugReport() As String
         Get
             Return m_strBugReport
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="669" endline="678"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     ReadOnly Property Encoding() As System.Text.Encoding
         Get
             If m_Encoding Is Nothing Then m_Encoding = System.Text.Encoding.Default
             Return m_Encoding
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="679" endline="687"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     ReadOnly Property DelaySign() As Boolean
         Get
             Return m_bDelaySign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="688" endline="696"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     ReadOnly Property KeyContainer() As String
         Get
             Return m_strKeyContainer
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="697" endline="705"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     ReadOnly Property KeyFile() As String
         Get
             Return m_strKeyFile
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="706" endline="714"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     ReadOnly Property LibPath() As Specialized.StringCollection
         Get
             Return m_lstLibPath
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="715" endline="723"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /main
     ''' </summary>
     ReadOnly Property Main() As String
         Get
             Return m_strMain
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="724" endline="732"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     ReadOnly Property NetCF() As Boolean
         Get
             Return m_bNetCF
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="733" endline="741"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     ReadOnly Property SDKPath() As String
         Get
             Return m_strSDKPath
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="742" endline="750"><![CDATA[
     End Property
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     ReadOnly Property UTF8Output() As Boolean
         Get
             Return m_bUTF8Output
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="751" endline="759"><![CDATA[
     End Property
 
     ''' <summary>
     ''' A list of all the response files specified on the command line.
     ''' </summary>
     ReadOnly Property ResponseFiles() As Specialized.StringCollection
         Get
             Return m_lstResponseFiles
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="760" endline="769"><![CDATA[
     End Property
 
 #End Region
 
     ReadOnly Property AllArgumentsAsArray() As String()
         Get
             Dim result(m_lstAllArgs.Count - 1) As String
             m_lstAllArgs.CopyTo(result, 0)
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="770" endline="781"><![CDATA[
     End Property
 
     ''' <summary>
     ''' This property returns the files the commandline parser found on the commandline,
     ''' this includes expanded wildcards.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Files() As CodeFiles
         Get
             Return m_lstFileNames
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="782" endline="795"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new commandline parser!
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
     Private m_lstResponseFiles As New Specialized.StringCollection
 
     ''' <summary>
     ''' All files specified
     ''' </summary>s
     ''' <remarks></remarks>
     Private m_lstFileNames As CodeFiles
 
     ''' <summary>
     ''' A list of all the arguments parsed.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_lstAllArgs As New Specialized.StringCollection
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     Private m_Compiler As Compiler
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
 #Region "Properties"
 
     ' - OUTPUT FILE -
 
     ''' <summary>
     ''' /out
     ''' </summary>
     Private m_strOut As String
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     Private m_strTarget As Targets
 
     ''' <summary>
     ''' /doc[+|-]               Generates XML documentation file.
     ''' /doc
     ''' </summary>
     ''' <remarks></remarks>
     Private m_strDoc As String
 
     ' - INPUT FILES -
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     Private m_lstModules As New Specialized.StringCollection
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     Private m_lstRecurse As New Specialized.StringCollection
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     Private m_lstReferences As New Specialized.StringCollection
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     Private m_lstLinkResources As Resources
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     Private m_lstResources As Resources
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     Private m_strWin32Icon As String
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     Private m_strWin32Resource As String
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     Private m_bOptimize As Boolean
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     Private m_bRemoveIntChecks As Boolean
 
     ''' <summary>
     ''' /debug[+|-]             Emit debugging information.
     '''/debug
     '''/debug
     ''' According to #81054 vbc doesn't emit debug info unless /debug is specified.
     ''' </summary>
     Private m_eDebugInfo As DebugTypes = DebugTypes.None
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     Private m_bNoWarn As Boolean
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     Private m_bWarnAsError As Boolean
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     Private m_lstDefine As New Defines
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     Private m_lstImports As ImportsStatement
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     Private m_eOptionExplicit As OptionExplicitTypes = OptionExplicitTypes.On
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     Private m_eOptionStrict As OptionStrictTypes = OptionStrictTypes.Off
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_eOptionInfer As OptionInferTypes = OptionInferTypes.Off
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     Private m_strRootNamespace As String
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     Private m_eOptionCompare As OptionCompareTypes = OptionCompareTypes.Binary
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     Private m_bHelp As Boolean
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     Private m_bNoLogo As Boolean
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     Private m_bQuiet As Boolean
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     Private m_bVerbose As Boolean
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     Private m_bNoConfig As Boolean
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_bTrace As Boolean
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     Private m_strBaseAddress As String
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     Private m_strBugReport As String
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     Private m_Encoding As System.Text.Encoding
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     Private m_bDelaySign As Boolean
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     Private m_strKeyContainer As String
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     Private m_strKeyFile As String
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     Private m_lstLibPath As New Specialized.StringCollection
 
     ''' <summary>
     ''' /main
     ''' </summary>
     Private m_strMain As String
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     Private m_bNetCF As Boolean
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     Private m_strSDKPath As String
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     Private m_bUTF8Output As Boolean
 
     Private m_VBRuntime As String = "Microsoft.VisualBasic.dll"
 
     ''' <summary>
     ''' /vbversion
     ''' </summary>
     ''' <remarks></remarks>
     Private m_VBVersion As VBVersions = VBVersions.V8
     ' - OUTPUT FILE -
 
 
     ReadOnly Property VBVersion() As VBVersions
         Get
             Return m_VBVersion
         End Get
     End Property
 
     ''' <summary>
     ''' /out
     ''' </summary>
     ReadOnly Property Out() As String
         Get
             Return m_strOut
         End Get
     End Property
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     ReadOnly Property Target() As Targets
         Get
             Return m_strTarget
         End Get
     End Property
 
     ' - INPUT FILES - 
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     ReadOnly Property Modules() As Specialized.StringCollection
         Get
             Return m_lstModules
         End Get
     End Property
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     ReadOnly Property Recurse() As Specialized.StringCollection
         Get
             Return m_lstRecurse
         End Get
     End Property
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     ReadOnly Property References() As Specialized.StringCollection
         Get
             Return m_lstReferences
         End Get
     End Property
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     ReadOnly Property LinkResources() As Resources
         Get
             Return m_lstLinkResources
         End Get
     End Property
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     ReadOnly Property Resources() As Resources
         Get
             Return m_lstResources
         End Get
     End Property
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     ReadOnly Property Win32Icon() As String
         Get
             Return m_strWin32Icon
         End Get
     End Property
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     ReadOnly Property Win32Resource() As String
         Get
             Return m_strWin32Resource
         End Get
     End Property
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     ReadOnly Property Optimize() As Boolean
         Get
             Return m_bOptimize
         End Get
     End Property
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     ReadOnly Property RemoveIntChecks() As Boolean
         Get
             Return m_bRemoveIntChecks
         End Get
     End Property
 
     ''' <summary>
     '''/debug
     '''/debug
     ''' </summary>
     ReadOnly Property DebugInfo() As DebugTypes
         Get
             Return m_eDebugInfo
         End Get
     End Property
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     ReadOnly Property NoWarn() As Boolean
         Get
             Return m_bNoLogo
         End Get
     End Property
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     ReadOnly Property WarnAsError() As Boolean
         Get
             Return m_bWarnAsError
         End Get
     End Property
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     ReadOnly Property Define() As Defines
         Get
             Return m_lstDefine
         End Get
     End Property
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsStatement
         Get
             Return m_lstImports
         End Get
     End Property
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     ReadOnly Property OptionExplicit() As OptionExplicitTypes
         Get
             Return m_eOptionExplicit
         End Get
     End Property
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     ReadOnly Property OptionStrict() As OptionStrictTypes
         Get
             Return m_eOptionStrict
         End Get
     End Property
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     ReadOnly Property RootNamespace() As String
         Get
             Return m_strRootNamespace
         End Get
     End Property
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     ReadOnly Property OptionCompare() As OptionCompareTypes
         Get
             Return m_eOptionCompare
         End Get
     End Property
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property OptionInfer As OptionInferTypes
         Get
             Return m_eOptionInfer
         End Get
     End Property
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     ReadOnly Property Help() As Boolean
         Get
             Return m_bHelp
         End Get
     End Property
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     ReadOnly Property NoLogo() As Boolean
         Get
             Return m_bNoLogo
         End Get
     End Property
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     ReadOnly Property Quiet() As Boolean
         Get
             Return m_bQuiet
         End Get
     End Property
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     ReadOnly Property Verbose() As Boolean
         Get
             Return m_bVerbose
         End Get
     End Property
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     ReadOnly Property NoConfig() As Boolean
         Get
             Return m_bNoConfig
         End Get
     End Property
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Trace As Boolean
         Get
             Return m_bTrace
         End Get
     End Property
 
     ReadOnly Property VBRuntime() As String
         Get
             Return m_VBRuntime
         End Get
     End Property
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     ReadOnly Property BaseAddress() As String
         Get
             Return m_strBaseAddress
         End Get
     End Property
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     ReadOnly Property BugReport() As String
         Get
             Return m_strBugReport
         End Get
     End Property
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     ReadOnly Property Encoding() As System.Text.Encoding
         Get
             If m_Encoding Is Nothing Then m_Encoding = System.Text.Encoding.Default
             Return m_Encoding
         End Get
     End Property
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     ReadOnly Property DelaySign() As Boolean
         Get
             Return m_bDelaySign
         End Get
     End Property
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     ReadOnly Property KeyContainer() As String
         Get
             Return m_strKeyContainer
         End Get
     End Property
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     ReadOnly Property KeyFile() As String
         Get
             Return m_strKeyFile
         End Get
     End Property
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     ReadOnly Property LibPath() As Specialized.StringCollection
         Get
             Return m_lstLibPath
         End Get
     End Property
 
     ''' <summary>
     ''' /main
     ''' </summary>
     ReadOnly Property Main() As String
         Get
             Return m_strMain
         End Get
     End Property
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     ReadOnly Property NetCF() As Boolean
         Get
             Return m_bNetCF
         End Get
     End Property
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     ReadOnly Property SDKPath() As String
         Get
             Return m_strSDKPath
         End Get
     End Property
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     ReadOnly Property UTF8Output() As Boolean
         Get
             Return m_bUTF8Output
         End Get
     End Property
 
     ''' <summary>
     ''' A list of all the response files specified on the command line.
     ''' </summary>
     ReadOnly Property ResponseFiles() As Specialized.StringCollection
         Get
             Return m_lstResponseFiles
         End Get
     End Property
 
 #End Region
 
     ReadOnly Property AllArgumentsAsArray() As String()
         Get
             Dim result(m_lstAllArgs.Count - 1) As String
             m_lstAllArgs.CopyTo(result, 0)
             Return result
         End Get
     End Property
 
     ''' <summary>
     ''' This property returns the files the commandline parser found on the commandline,
     ''' this includes expanded wildcards.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Files() As CodeFiles
         Get
             Return m_lstFileNames
         End Get
     End Property
 
     ''' <summary>
     ''' Create a new commandline parser!
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         m_lstImports = New ImportsStatement(Compiler)
         m_lstImports.Init(New ImportsClauses(m_lstImports))
         m_lstFileNames = New CodeFiles(m_Compiler)
         m_lstResources = New Resources(m_Compiler, False)
         m_lstLinkResources = New Resources(m_Compiler, True)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="796" endline="841"><![CDATA[
 
     ''' <summary>
     ''' Parse the specified arguments
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Parse(ByVal CommandLine As String()) As Boolean
         Dim result As Boolean = True
 
         Try
             result = ParseInternal(CommandLine) AndAlso result
 
             If m_bNoConfig = False Then
                 Dim defaultrspfile As String = Nothing
                 Dim compiler_path As String = System.Reflection.Assembly.GetExecutingAssembly.Location
                 If compiler_path = String.Empty Then
                     compiler_path = System.Reflection.Assembly.GetEntryAssembly.Location
                 End If
                 defaultrspfile = IO.Path.Combine(IO.Path.GetDirectoryName(compiler_path), "vbnc.rsp")
 
                 If defaultrspfile Is Nothing OrElse IO.File.Exists(defaultrspfile) = False Then
                     Try
                         Using resources As System.IO.Stream = Reflection.Assembly.GetExecutingAssembly.GetManifestResourceStream("vbnc.vbnc.rsp")
                             If resources IsNot Nothing Then
                                 Using reader As New IO.StreamReader(resources)
                                     Dim tmp As String = reader.ReadToEnd()
                                     IO.File.WriteAllText(defaultrspfile, tmp)
                                 End Using
                             End If
                         End Using
                     Catch ex As Exception
                         'Ignore any exceptions here.
                     End Try
                 End If
                 If IO.File.Exists(defaultrspfile) Then
                     result = ParseResponseFile(defaultrspfile) AndAlso result
                 Else
                     Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Default response file '" & defaultrspfile & "' was not loaded because it couldn't be found.")
                 End If
             End If
         Catch ex As Exception
             Helper.StopIfDebugging()
             Throw
         End Try
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="842" endline="892"><![CDATA[
 
     ''' <summary>
     ''' Reads the specified response file and sends the arguments to pParse.
     ''' </summary>
     Private Function ParseResponseFile(ByVal Filename As String) As Boolean
         If m_lstResponseFiles.Contains(Filename) Then
             Compiler.Report.ShowMessage(Messages.VBNC2014, Span.CommandLineSpan, Filename)
             Return False
         Else
             m_lstResponseFiles.Add(Filename)
         End If
 
         Dim lstArgs As New Specialized.StringCollection
         Dim strLines As String()
 
         If IO.File.Exists(Filename) Then
             'Do nothing
             Filename = IO.Path.GetFullPath(Filename)
         ElseIf IO.File.Exists(IO.Path.GetFullPath(Filename)) Then
             Filename = IO.Path.GetFullPath(Filename)
         Else
 #If DEBUG Then
             Compiler.Report.WriteLine("IO.File.Exists(" & Filename & ") => " & IO.File.Exists(Filename).ToString)
             Compiler.Report.WriteLine("IO.File.Exists(" & IO.Path.GetFullPath(Filename) & ") >= " & IO.File.Exists(IO.Path.GetFullPath(Filename)).ToString)
 #End If
             Compiler.Report.ShowMessage(Messages.VBNC2001, Span.CommandLineSpan, Filename)
             Return False
         End If
 
         Helper.Assert(IO.File.Exists(Filename))
 
         Try
             strLines = IO.File.ReadAllLines(Filename)
         Catch ex As IO.IOException
             Compiler.Report.ShowMessage(Messages.VBNC2007, Span.CommandLineSpan, Filename)
             Return False
         End Try
 
         'Read the file, line by line.
         For Each strLine As String In strLines
             If strLine.StartsWith("#") = False Then 'Skip comment lines
                 lstArgs.AddRange(Helper.ParseLine(strLine))    'Add the parsed elements of the line
             End If
         Next
 
         'Create a string array from the arraylist
         Dim strArgs(lstArgs.Count - 1) As String
         lstArgs.CopyTo(strArgs, 0)
         'Parse the arguments
         Return ParseInternal(strArgs)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="893" endline="913"><![CDATA[
 
     ''' <summary>
     ''' Add all the files corresponding to the specified pattern in the specified
     ''' directory to the list of code files, recursively.
     ''' </summary>
     Private Function AddFilesInDir(ByVal dir As String, ByVal relativepath As String, ByVal pattern As String) As Boolean
         Dim strFiles() As String
         Dim result As Boolean = True
 
         strFiles = IO.Directory.GetFiles(dir, pattern)
         For Each strFile As String In strFiles
             m_lstFileNames.Add(New CodeFile(strFile, relativepath, Me.Compiler))
         Next
         result = True
         strFiles = IO.Directory.GetDirectories(dir)
         For Each strDir As String In strFiles
             result = AddFilesInDir(strDir, IO.Path.Combine(relativepath, System.IO.Path.GetFileName(strDir)), pattern) AndAlso result
         Next
         'whoami()
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="914" endline="1136"><![CDATA[
 
     Private Function SetOption(ByVal strName As String, ByVal strValue As String) As Boolean
         Dim result As Boolean = True
         Select Case LCase(strName)
             ' - OUTPUT FILE -
             Case "out"
                 m_strOut = strValue
             Case "target", "t"
                 Select Case LCase(strValue)
                     Case "exe"
                         m_strTarget = Targets.Console
                     Case "winexe"
                         m_strTarget = Targets.Winexe
                     Case "library"
                         m_strTarget = Targets.Library
                     Case "module"
                         m_strTarget = Targets.Module
                     Case Else
                         Compiler.Report.SaveMessage(Messages.VBNC2019, Span.CommandLineSpan, "target", strValue)
                         result = False
                 End Select
                 ' - INPUT FILES -
             Case "addmodule"
                 m_lstModules.AddRange(Split(strValue, ","))
             Case "recurse"
                 'Add the files
                 Dim strPath As String = System.IO.Path.GetDirectoryName(strValue)
                 Dim strRelativePath As String = strPath
                 Dim strFileName As String
                 If strPath <> "" Then
                     strFileName = strValue.Substring(strPath.Length + 1)
                 Else
                     strPath = IO.Directory.GetCurrentDirectory()
                     strFileName = strValue
                 End If
                 result = AddFilesInDir(strPath, strRelativePath, strFileName) AndAlso result
             Case "reference", "r"
                 m_lstReferences.AddRange(Split(strValue, ","))
                 ' - RESOURCES -
             Case "linkresource", "linkres"
                 result = m_lstLinkResources.Add(strValue) AndAlso result
             Case "resource", "res"
                 result = m_lstResources.Add(strValue) AndAlso result
             Case "win32icon"
                 m_strWin32Icon = strValue
             Case "win32resource"
                 m_strWin32Resource = strValue
                 ' - CODE GENERATION -
             Case "optimize+", "optimize"
                 m_bOptimize = True
             Case "optimize-"
                 m_bOptimize = False
             Case "removeintchecks+", "removeintchecks"
                 m_bRemoveIntChecks = True
             Case "removeintchecks-"
                 m_bRemoveIntChecks = False
             Case "debug+"
                 m_eDebugInfo = DebugTypes.Full
             Case "debug-"
                 m_eDebugInfo = DebugTypes.None
             Case "debug"
                 Select Case LCase(strValue)
                     Case "full"
                         m_eDebugInfo = DebugTypes.Full
                     Case "pdbonly"
                         m_eDebugInfo = DebugTypes.PDB
                     Case ""
                         m_eDebugInfo = DebugTypes.Full
                     Case Else
                         'TODO
                         Compiler.Report.SaveMessage(Messages.VBNC2019, Span.CommandLineSpan, strName, strValue)
                         result = False
                 End Select
                 ' - ERRORS AND WARNINGS -
             Case "nowarn"
                 m_bNoWarn = True
             Case "warnaserror+", "warnaserror"
                 m_bWarnAsError = True
             Case "warnaserror-"
                 m_bWarnAsError = False
                 ' - LANGUAGE -
             Case "define", "d"
                 'FIXME
                 Dim strDefines() As String = Split(strValue, ",")
                 For Each str As String In strDefines
                     If str.Contains("=") = False Then str = str & "=True"
                     Dim strSplit() As String = Split(str, "=")
                     If strSplit.GetUpperBound(0) <> 1 Then
                         Compiler.Report.ShowMessage(Messages.VBNC90017, Span.CommandLineSpan, str)
                         result = False
                     Else
                         m_lstDefine.Add(New Define(Compiler, strSplit(0), strSplit(1)))
                     End If
                 Next
             Case "imports"
                 Dim imps As String()
                 imps = strValue.Split(","c)
                 For Each str As String In imps
                     If str <> "" Then
                         result = vbnc.Parser.ParseImportsStatement(m_lstImports, str) AndAlso result
                     End If
                 Next
             Case "optionexplicit+", "optionexplicit"
                 m_eOptionExplicit = OptionExplicitTypes.On
             Case "optionexplicit-"
                 m_eOptionExplicit = OptionExplicitTypes.Off
             Case "optionstrict+", "optionstrict"
                 m_eOptionStrict = OptionStrictTypes.On
             Case "optionstrict-"
                 Console.WriteLine("Warning
                 m_eOptionStrict = OptionStrictTypes.Off
             Case "optioninfer+", "optioninfer"
                 m_eOptionInfer = OptionInferTypes.On
             Case "optioninfer-"
                 m_eOptionInfer = OptionInferTypes.Off
             Case "rootnamespace"
                 m_strRootNamespace = strValue
             Case "optioncompare"
                 Select Case LCase(strValue)
                     Case "text"
                         m_eOptionCompare = OptionCompareTypes.Text
                     Case "binary"
                         m_eOptionCompare = OptionCompareTypes.Binary
                     Case Else
                         result = False
                         'TODO
                         Compiler.Report.SaveMessage(Messages.VBNC2019, Span.CommandLineSpan, strName, strValue)
                 End Select
                 ' - MISCELLANEOUS -
             Case "help", "?"
                 m_bHelp = True
             Case "nologo"
                 m_bNoLogo = True
             Case "quiet"
                 m_bQuiet = True
             Case "verbose", "verbose+"
                 m_bVerbose = True
             Case "verbose-"
                 m_bVerbose = False
             Case "noconfig"
                 m_bNoConfig = True
             Case "trace"
                 m_bTrace = True
                 ' - ADVANCED -
             Case "baseaddress"
                 m_strBaseAddress = strValue
             Case "bugreport"
                 m_strBugReport = strValue
             Case "codepage"
                 If strValue = "" Then
                     Compiler.Report.ShowMessage(Messages.VBNC2006, Span.CommandLineSpan, "codepage", "<number>")
                     result = False
                 Else
                     Try
                         m_Encoding = System.Text.Encoding.GetEncoding(Integer.Parse(strValue, Globalization.NumberStyles.AllowLeadingWhite Or Globalization.NumberStyles.AllowLeadingSign, System.Globalization.CultureInfo.InvariantCulture))
                     Catch
                         Compiler.Report.ShowMessage(Messages.VBNC2016, Span.CommandLineSpan, strValue)
                         result = False
                     End Try
                 End If
             Case "delaysign+"
                 m_bDelaySign = True
             Case "delaysign-"
                 m_bDelaySign = False
             Case "keycontainer"
                 m_strKeyContainer = strValue
             Case "keyfile"
                 Dim paths() As String
                 paths = Me.GetFullPaths(strValue)
                 If paths IsNot Nothing AndAlso paths.Length = 1 Then
                     m_strKeyFile = paths(0)
                 Else
                     Helper.AddError(Compiler, """")
                 End If
             Case "libpath"
                 m_lstLibPath.AddRange(Split(strValue, ","))
             Case "main"
                 m_strMain = strValue
             Case "netcf"
                 m_bNetCF = True
                 result = False
                 Compiler.Report.ShowMessage(Messages.VBNC90016, Span.CommandLineSpan, ".NET Compact Framework")
             Case "sdkpath"
                 m_strSDKPath = strValue
             Case "utf8output+", "utf8output"
                 m_bUTF8Output = True
             Case "utf8output-"
                 m_bUTF8Output = False
             Case "novbruntimeref"
                 m_VBRuntime = Nothing
             Case "vbruntime-"
                 m_VBRuntime = Nothing
             Case "vbruntime+"
                 m_VBRuntime = "Microsoft.VisualBasic.dll"
             Case "vbruntime"
                 m_VBRuntime = strValue
             Case "errorreport"
                 result = Compiler.Report.SaveMessage(Messages.VBNC99998, Span.CommandLineSpan, "/errorreport isn't implemented yet.") AndAlso result
             Case "vbversion"
                 Select Case strValue
                     Case "7"
                         m_VBVersion = VBVersions.V7
                     Case "7.1"
                         m_VBVersion = VBVersions.V7_1
                     Case "8"
                         m_VBVersion = VBVersions.V8
                     Case Else
                         Helper.AddWarning("Unknown vb version
                 End Select
             Case "doc-"
                 m_strDoc = Nothing
             Case "doc+"
                 m_strDoc = String.Empty
                 Compiler.Report.SaveMessage(Messages.VBNC99998, Span.CommandLineSpan, "Support for /doc+ has not been implemented. No documentation file will be generated.")
             Case "doc"
                 m_strDoc = strValue
                 Compiler.Report.SaveMessage(Messages.VBNC99998, Span.CommandLineSpan, "Support for /doc
             Case Else
                 'result = False 'OK since this is only a warning.
                 result = Compiler.Report.SaveMessage(Messages.VBNC2009, Span.CommandLineSpan, strName) AndAlso result
         End Select
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="1137" endline="1158"><![CDATA[
 
     Private Function AddFile(ByVal File As String) As Boolean
         Dim result As Boolean = True
 
         Dim strFile As String
         Dim strFiles As String()
 
         strFiles = GetFullPaths(File)
 
         If strFiles Is Nothing OrElse strFiles.Length = 0 Then
             If IsPattern(File) = False Then
                 result = Compiler.Report.SaveMessage(Messages.VBNC2001, Span.CommandLineSpan, File) AndAlso result
             End If
             Return result
         End If
 
         For Each strFile In strFiles
             m_lstFileNames.Add(New CodeFile(strFile, System.IO.Path.GetDirectoryName(File), Me.Compiler))
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="1159" endline="1207"><![CDATA[
 
     ''' <summary>
     ''' Parses the commandline
     ''' Returns false if no commandline found, or if there was an error parsing the commandline.
     ''' Messages here are saved, since they have to be shown after the logo is shown, but the 
     ''' showing of the logo can be cancelled on the commandline, so the entire commandline
     ''' has to the parsed before any messages are shown.
     ''' </summary>
     Private Function ParseInternal(ByVal Args() As String) As Boolean
         Dim result As Boolean = True
         m_lstAllArgs.AddRange(Args)
         For Each s As String In Args
             If s.StartsWith("@") Then
                 result = ParseResponseFile(s.Substring(1)) AndAlso result
                 Continue For
             End If
 
             Dim isOption As Boolean
 
             isOption = s.StartsWith("-"c)
             If isOption = False AndAlso s.StartsWith("/"c) Then
                 Dim idxSecond As Integer = s.IndexOf("/"c, 2)
                 Dim idxColon As Integer = s.IndexOf("
 
                 isOption = idxColon >= 0 OrElse idxSecond = -1
             End If
 
             If isOption Then
                 Dim strName As String = "", strValue As String = ""
                 'Find the colon which separates the values
                 Dim iColon As Integer = InStr(2, s, "
                 'If found, split it in a name and value pair
                 If iColon > 0 Then
                     strName = s.Substring(1, iColon - 2)
                     strValue = s.Substring(strName.Length + 2)
                 Else
                     'if not, the whole string is the name
                     strName = s.Substring(1)
                 End If
                 'find the option
                 result = SetOption(strName, strValue) AndAlso result
                 Continue For
             End If
 
             AddFile(s)
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="1208" endline="1245"><![CDATA[
 
     ''' <summary>
     ''' Shows an error if the filename(s) cannot be found.
     ''' If it returns an empty array something went wrong 
     ''' (the error message has already been shown).
     ''' </summary>
     ''' <param name="FileName">Can be a complete filename or a pattern.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetFullPaths(ByVal FileName As String) As String()
         Dim strPath As String = System.IO.Path.GetDirectoryName(FileName)
         Dim strFileName As String
 
         If strPath <> "" Then
             strFileName = FileName.Substring(strPath.Length + 1)
         Else
             strFileName = FileName
         End If
 
         Dim tmpPath As String
         If strPath = "" Then
             strPath = IO.Path.GetDirectoryName(IO.Path.GetFullPath(FileName))
         End If
         tmpPath = IO.Path.GetFullPath(strPath)
 
         If IO.Directory.Exists(tmpPath) = False Then Return Nothing
 
         If IsPattern(FileName) Then
             Return IO.Directory.GetFiles(tmpPath, strFileName)
         Else
             Dim file As String = IO.Path.Combine(tmpPath, strFileName)
             If IO.File.Exists(file) Then
                 Return New String() {file}
             Else
                 Return Nothing
             End If
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="1246" endline="1249"><![CDATA[
 
     Shared Function IsPattern(ByVal Filename As String) As Boolean
         Return Filename.IndexOfAny(PATTERNCHARS) >= 0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="1250" endline="1258"><![CDATA[
 
     ''' <summary>
     ''' Returns a collection of all the arguments parsed (included in 
     ''' response files).
     ''' </summary>
     ReadOnly Property AllArguments() As Specialized.StringCollection
         Get
             Return m_lstAllArgs
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="104" endline="107"><![CDATA[
     Sub New()
         MyBase.New(Nothing)
     Private m_Report As New Report(Me)
 
     ''' <summary>
     ''' A helper
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Helper As New Helper(Me)
 
     ''' <summary>
     ''' The parser
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Parser As Parser
 
     ''' <summary>
     ''' Represents the commandline passed on to the compiler
     ''' </summary>
     ''' <remarks></remarks>
     Private m_CommandLine As New CommandLine(Me)
 
     ''' <summary>
     ''' The scanner of the code
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Scanner As New Scanner(Me)
 
     ''' <summary>
     ''' The token manager.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_tm As tm
 
     ''' <summary>
     ''' Contains info about all the types and namespaces available.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TypeManager As New TypeManager(Me)
 
     ''' <summary>
     ''' The compiling assembly
     ''' </summary>
     ''' <remarks></remarks>
     Friend theAss As AssemblyDeclaration
 
     ''' <summary>
     ''' The created assembly
     ''' </summary>
     ''' <remarks></remarks>
     Public AssemblyBuilderCecil As Mono.Cecil.AssemblyDefinition
 
     ''' <summary>
     ''' The one and only module in the assembly
     ''' </summary>
     ''' <remarks></remarks>
     Public ModuleBuilderCecil As Mono.Cecil.ModuleDefinition
 
     Private m_TypeCache As CecilTypeCache
 
     Private m_TypeResolver As TypeResolution
     Private m_AssemblyResolver As DefaultAssemblyResolver
 
     Sub New()
         MyBase.New(Nothing)
         CurrentCompiler = Me
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="108" endline="123"><![CDATA[
 
     Public ReadOnly Property AssemblyResolver() As DefaultAssemblyResolver
         Get
             If m_AssemblyResolver Is Nothing Then
                 m_AssemblyResolver = New DefaultAssemblyResolver()
                 'We don't want any automatic assembly resolving
                 For Each dir As String In m_AssemblyResolver.GetSearchDirectories()
                     m_AssemblyResolver.RemoveSearchDirectory(dir)
                 Next
                 'Add or own search paths
                 For Each dir As String In CommandLine.LibPath
                     m_AssemblyResolver.AddSearchDirectory(dir)
                 Next
             End If
             Return m_AssemblyResolver
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="124" endline="136"><![CDATA[
     End Property
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal where As String)
         'Console.WriteLine("Verifying consistency
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, where & "
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="137" endline="147"><![CDATA[
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal Location As Span)
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, Location.AsString(Compiler) & " No errors, but compilation failed? ")
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="148" endline="153"><![CDATA[
 
 
     ReadOnly Property OutFileName() As String
         Get
             Return m_OutFilename
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="154" endline="159"><![CDATA[
     End Property
 
     ReadOnly Property TypeCache() As CecilTypeCache
         Get
             Return m_TypeCache
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="160" endline="169"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Contains info about all the types and namespaces available.
     ''' </summary>
     ''' <remarks></remarks>
     Friend ReadOnly Property TypeManager() As TypeManager
         Get
             Return m_TypeManager
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="170" endline="179"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The global reporting object
     ''' </summary>
     ''' <remarks></remarks>
     Friend Shadows ReadOnly Property Report() As Report
         Get
             Return m_Report
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="180" endline="185"><![CDATA[
     End Property
 
     Friend ReadOnly Property Parser() As Parser
         Get
             Return m_Parser
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="186" endline="195"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Represents the commandline passed on to the compiler
     ''' </summary>
     ''' <remarks></remarks>
     Friend Property CommandLine() As CommandLine
         Get
             Return m_CommandLine
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="196" endline="198"><![CDATA[
         Set(ByVal value As CommandLine)
             m_CommandLine = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="199" endline="208"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The scanner of the code
     ''' </summary>
     ''' <remarks></remarks>
     Friend ReadOnly Property Scanner() As Scanner
         Get
             Return m_Scanner
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="209" endline="214"><![CDATA[
     End Property
 
     Friend Overrides ReadOnly Property tm() As tm
         Get
             Return m_tm
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="215" endline="220"><![CDATA[
     End Property
 
     Friend ReadOnly Property Helper() As Helper
         Get
             Return m_Helper
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="221" endline="226"><![CDATA[
     End Property
 
     Friend ReadOnly Property TypeResolver() As TypeResolution
         Get
             Return m_TypeResolver
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="227" endline="232"><![CDATA[
     End Property
 
     Friend ReadOnly Property TypeResolution() As TypeResolution
         Get
             Return m_TypeResolver
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="233" endline="238"><![CDATA[
     End Property
 
     Friend ReadOnly Property NameResolver() As Helper
         Get
             Return m_Helper
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="239" endline="244"><![CDATA[
     End Property
 
     ReadOnly Property EmittingDebugInfo() As Boolean
         Get
             Return m_CommandLine.DebugInfo <> vbnc.CommandLine.DebugTypes.None
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="245" endline="255"><![CDATA[
     End Property
 
     Private Function CreateTestOutputFilename(ByVal Filename As String, ByVal TestType As String) As String
         Dim dir As String
         dir = IO.Path.GetDirectoryName(Filename)
         If dir = "" Then dir = Environment.CurrentDirectory
         'dir = IO.Path.Combine(IO.Path.GetDirectoryName(Filename), "testoutput")
 
         If IO.Directory.Exists(dir) = False Then IO.Directory.CreateDirectory(dir)
         Return IO.Path.Combine(dir, IO.Path.GetFileName(Filename) & "." & TestType & ".output.xml")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="256" endline="269"><![CDATA[
 
     Function Compile(ByVal CommandLine As String()) As Integer
         'Try
         If m_CommandLine.Parse(CommandLine) = False Then
             If m_CommandLine.NoLogo = False Then
                 ShowLogo()
             End If
             If Report.ShowSavedMessages() = False Then
                 ShowHelp()
             End If
             Return 1
         End If
         Return Compile()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="270" endline="274"><![CDATA[
 
     Friend Function Compile(ByVal Options As CommandLine) As Boolean
         m_CommandLine = Options
         Return Compile() = 0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="275" endline="299"><![CDATA[
 
     Function Compile_CalculateOutputFilename() As Boolean
         If CommandLine.Out = "" Then
             'Get the first filename
             m_OutFilename = CommandLine.Files(0).FileName
             'Strip the extension
             m_OutFilename = m_OutFilename.Substring(0, m_OutFilename.Length - IO.Path.GetExtension(m_OutFilename).Length)
 
             If m_OutFilename.EndsWith(".") = False Then m_OutFilename &= "."
             'Put on the correct extension
             If CommandLine.Target = vbnc.CommandLine.Targets.Console OrElse CommandLine.Target = vbnc.CommandLine.Targets.Winexe Then
                 m_OutFilename &= "exe"
             ElseIf CommandLine.Target = vbnc.CommandLine.Targets.Library Then
                 m_OutFilename &= "dll"
             ElseIf CommandLine.Target = vbnc.CommandLine.Targets.Module Then
                 m_OutFilename &= "netmodule"
             Else
                 Throw New InternalException(Me)
             End If
         Else
             m_OutFilename = CommandLine.Out
         End If
         m_OutFilename = IO.Path.GetFullPath(m_OutFilename)
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="300" endline="325"><![CDATA[
 
     Private Function Compile_CreateAssemblyAndModuleBuilders() As Boolean
         Dim kind As Mono.Cecil.ModuleKind
         Select Case CommandLine.Target
             Case vbnc.CommandLine.Targets.Console
                 kind = Mono.Cecil.ModuleKind.Console
             Case vbnc.CommandLine.Targets.Library
                 kind = Mono.Cecil.ModuleKind.Dll
             Case vbnc.CommandLine.Targets.Module
                 Report.ShowMessage(Messages.VBNC99999, Span.CommandLineSpan, "Compiling modules (-target
                 kind = Mono.Cecil.ModuleKind.NetModule
             Case vbnc.CommandLine.Targets.Winexe
                 kind = Mono.Cecil.ModuleKind.Windows
             Case Else
                 kind = Mono.Cecil.ModuleKind.Console
         End Select
 
         Dim an As AssemblyNameDefinition = New AssemblyNameDefinition("dummy", New Version())
         AssemblyBuilderCecil = AssemblyDefinition.CreateAssembly(an, IO.Path.GetFileNameWithoutExtension(OutFileName), kind)
         ModuleBuilderCecil = AssemblyBuilderCecil.MainModule
         ModuleBuilderCecil.Name = IO.Path.GetFileName(OutFileName)
         ModuleBuilderCecil.Runtime = TypeManager.Corlib.MainModule.Runtime
         ModuleBuilderCecil.AssemblyResolver = AssemblyResolver
         If CommandLine.Verbose Then Report.WriteLine(String.Format("Using runtime version
         Return Compiler.Report.Errors = 0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="326" endline="363"><![CDATA[
 
     Private Function Compile_Parse() As Boolean
         Dim result As Boolean = True
         Dim RootNamespace As String
 
         If CommandLine.RootNamespace = "" Then
             RootNamespace = "" '(IO.Path.GetFileNameWithoutExtension(m_OutFilename))
         Else
             RootNamespace = (CommandLine.RootNamespace)
         End If
 
         m_Scanner = New Scanner(Me)
         'm_ConditionalCompiler = New ConditionalCompiler(Me, m_Scanner)
         m_tm = New tm(Me, m_Scanner)
         m_Parser = New Parser(Me)
 
 
         Try
             theAss = New AssemblyDeclaration(Me)
             result = Parser.Parse(RootNamespace, theAss) AndAlso result
             theAss.Initialize(Me)
         Catch ex As TooManyErrorsException
             Throw
         Catch ex As vbncException
             Throw
         Catch ex As Exception
             If Token.IsSomething(tm.CurrentToken) Then
                 Report.ShowMessage(Messages.VBNC99999, tm.CurrentLocation, "vbnc crashed nearby this location in the source code.")
             End If
             Throw
         End Try
 
         m_tm = Nothing
 
         VerifyConsistency(result, "Parse")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="364" endline="397"><![CDATA[
 
     Private Function Compile_Resolve() As Boolean
         Dim result As Boolean = True
 
         result = CommandLine.Imports.ResolveCode(ResolveInfo.Default(Me)) AndAlso result
         VerifyConsistency(result, "ResolveCode")
         If result = False Then Return result
 
         result = CommandLine.Files.Resolve(ResolveInfo.Default(Me)) AndAlso result
         VerifyConsistency(result, "Resolve")
         If result = False Then Return result
 
         result = theAss.CreateImplicitTypes AndAlso result
         VerifyConsistency(result, "CreateImplicitTypes")
         If result = False Then Return result
 
         result = theAss.ResolveTypeReferences AndAlso result
         VerifyConsistency(result, "ResolveTypeReferences")
         If result = False Then Return result
 
         m_TypeCache.InitInternalVBMembers()
 
         result = theAss.CreateImplicitMembers AndAlso result
         VerifyConsistency(result, "CreateImplicitMembers")
         If result = False Then Return result
 
         result = theAss.ResolveMembers AndAlso result
         VerifyConsistency(result, "ResolveMembers")
         result = theAss.ResolveCode(ResolveInfo.Default(Me)) AndAlso result
 
         VerifyConsistency(result, "FinishedResolve")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="398" endline="406"><![CDATA[
 
     Function GenerateMy() As Boolean
         Dim result As Boolean = True
         Dim generator As New MyGenerator(Me)
 
         result = generator.Generate() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="407" endline="552"><![CDATA[
 
     ''' <summary>
     ''' Compile with the current options.
     ''' </summary>
     ''' <remarks></remarks>
     Function Compile() As Integer
         Dim result As Boolean = True
         BaseObject.ClearCache()
         Try
             'Show help if asked to
             If CommandLine.Help = True Then
                 If CommandLine.NoLogo = False Then
                     ShowLogo()
                 End If
                 ShowHelp()
                 Return 0
             End If
 
             'Show logo, unless asked not to
             If CommandLine.NoLogo = False Then ShowLogo()
 
             If Report.ShowSavedMessages Then
                 Return 1
             End If
 
             'Set the culture to en-us to enable correct parsing of numbers, dates, etc.
             Threading.Thread.CurrentThread.CurrentCulture = Globalization.CultureInfo.GetCultureInfo("en-us")
 
             'Exit if no source files were specified
             If m_CommandLine.Files.Count = 0 Then
                 Report.ShowMessage(Messages.VBNC2011, Span.CommandLineSpan)
                 Return 1
             End If
 
             'Set the library of the .net system dir
             m_CommandLine.LibPath.Add(GetSystemDir)
 
             'Load the referenced assemblies
             If Not CommandLine.References.Contains("mscorlib.dll") Then
                 CommandLine.References.Add("mscorlib.dll")
             End If
 
             If Not String.IsNullOrEmpty(CommandLine.VBRuntime) Then
                 CommandLine.References.Add(CommandLine.VBRuntime)
             End If
 
             m_Helper = New Helper(Me)
             m_Helper = New Helper(Me)
 
             'Calculate the output filename
             result = Compile_CalculateOutputFilename() AndAlso result
 
             'Load all the referenced assemblies and load all the types and namespaces into the type manager
             m_TypeCache = New CecilTypeCache(Me)
 
             result = GenerateMy() AndAlso result
 
             result = m_TypeManager.LoadReferenced AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             m_TypeResolver = New TypeResolution(Me)
 
             'Create the assembly and module builders
             result = Compile_CreateAssemblyAndModuleBuilders() AndAlso result
             VerifyConsistency(result, "CreateAssemblyAndModuleBuilders")
 
             'Parse the code into the type tree
             result = Compile_Parse() AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             m_TypeManager.LoadCompiledTypes()
 
             If String.IsNullOrEmpty(CommandLine.VBRuntime) Then
                 m_TypeCache.InitInternalVB()
             End If
 
             result = Compile_Resolve() AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             result = Me.Assembly.SetCecilName(AssemblyBuilderCecil.Name) AndAlso result
 
             result = AddResources() AndAlso result
             If result = False Then GoTo ShowErrors
 
             'Passed this step no errors should be found...
 
             result = theAss.DefineTypes AndAlso result
             VerifyConsistency(result, "DefineTypes")
 
             result = theAss.DefineTypeHierarchy AndAlso result
             VerifyConsistency(result, "DefineTypeHierarchy")
 
             result = theAss.DefineMembers AndAlso result
             VerifyConsistency(result, "DefineMembers")
 
             result = theAss.Emit AndAlso result
             VerifyConsistency(result, "Emit")
 
             'Set the main function / entry point
             result = SetMain() AndAlso result
             If result = False Then GoTo ShowErrors
 
             If result = False Then
                 Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Error creating the assembly!")
                 GoTo ShowErrors
             End If
 
             Dim writerParameters As New WriterParameters()
             writerParameters.WriteSymbols = EmittingDebugInfo
             AssemblyBuilderCecil.Write(m_OutFilename, writerParameters)
 
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, String.Format("Assembly '{0}' saved successfully to '{1}'.", AssemblyBuilderCecil.Name.FullName, m_OutFilename))
 
 ShowErrors
             VerifyConsistency(result, "ShowErrors")
 
             If Report.Errors > 0 Or Report.Warnings > 0 Then
                 Compiler.Report.WriteLine("There were " & Report.Errors.ToString & " errors and " & Report.Warnings.ToString & " warnings.")
             End If
             If Report.Errors = 0 Then
                 Compiler.Report.WriteLine("Compilation successful")
                 result = True
             Else
                 result = False
             End If
 
 EndOfCompilation
             result = Report.Errors = 0 AndAlso result
 
             If result Then
                 Return 0
             Else
                 Return 1
             End If
         Catch ex As TooManyErrorsException
             Report.ShowMessage(Messages.VBNC30041, Span.CommandLineSpan)
             Return 1
         Catch ex As Exception
             ShowExceptionInfo(ex)
             Return -1
         Finally
             BaseObject.ClearCache()
         End Try
         vbnc.Helper.Assert(False, "End of program reached!")
         Return 1
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="553" endline="600"><![CDATA[
 
     Sub ShowExceptionInfo(ByVal ex As Exception)
 #If DEBUG Then
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "-------------------------------------------------------------------------------------------------------------------------")
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Unhandled exception(" & ex.GetType.ToString & ")
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, ex.StackTrace)
         If ex.InnerException Is Nothing Then
             Compiler.Report.WriteLine("InnerException
         Else
             Compiler.Report.WriteLine("InnerException
         End If
         If ex.GetBaseException Is Nothing Then
             Compiler.Report.WriteLine("GetBaseException
         ElseIf ex IsNot ex.GetBaseException Then
             Compiler.Report.WriteLine("GetBaseException
         End If
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Data.Count
         'Find the line which caused the exception
         Dim strLines(), strLine As String
         If ex.StackTrace IsNot Nothing Then
             strLines = ex.StackTrace.Split(New Char() {VB.Chr(13), VB.Chr(10)}, StringSplitOptions.RemoveEmptyEntries)
             For i As Integer = 0 To strLines.GetUpperBound(0)
                 strLine = strLines(i)
                 'Remove -at-
                 strLine = strLine.Substring(strLine.IndexOf("en ") + 3)
                 If strLine.StartsWith("vbnc.", True, Nothing) OrElse strLine.Contains("Cecil") Then
                     strLine = strLine.Substring(strLine.IndexOf(" en ") + 4)
                     strLine = strLine.Replace("
                     strLine = strLine.Replace("
                     strLine &= ")
                     Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, strLine)
                 End If
             Next
         End If
 
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Commandline arguments
         Compiler.Report.Indent()
         For Each arg As String In CommandLine.AllArguments
             If arg.EndsWith(".vb") = False Then
                 Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, arg)
             End If
         Next
         Compiler.Report.Unindent()
         Compiler.Report.WriteLine(ex.Message)
 #Else
         Compiler.Report.ShowMessage(Messages.VBNC99999, Span.CommandLineSpan, "Unexpected error
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="601" endline="626"><![CDATA[
 
     ''' <summary>
     ''' Returns true if the specified MethodInfo is a valid candidate to a Main function.
     ''' </summary>
     ''' <param name="method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsMainMethod(ByVal method As Mono.Cecil.MethodDefinition) As Boolean
         'Only static methods
         If method.IsStatic = False Then Return False
         'Only non-private methods (or maybe only public?)
         If method.IsPrivate Then Return False
         'Only methods called 'Main'
         If vbnc.Helper.CompareName(method.Name, "Main") = False Then Return False
         'Only methods with no return type or Integer return type
         If Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Void) = False AndAlso Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Int32) = False Then Return False
 
         'Only methods with no parameters or methods with one String() parameter
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         params = method.Parameters
         If params.Count = 0 Then Return True
         If params.Count > 1 Then Return False
         If Helper.CompareType(params(0).ParameterType, Compiler.TypeCache.System_String_Array) AndAlso params(0).IsOptional = False AndAlso params(0).IsOut = False Then Return True
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="627" endline="664"><![CDATA[
 
     ReadOnly Property Logo() As String
         Get
             Dim result As New System.Text.StringBuilder
             Dim FileVersion As Diagnostics.FileVersionInfo = Nothing
             Dim Version As AssemblyInformationalVersionAttribute = Nothing
             Dim attrs() As Object = System.Reflection.Assembly.GetExecutingAssembly().GetCustomAttributes(GetType(AssemblyInformationalVersionAttribute), False)
             Dim msg As String = ""
 
             If System.Reflection.Assembly.GetExecutingAssembly.Location <> String.Empty Then
                 FileVersion = Diagnostics.FileVersionInfo.GetVersionInfo(System.Reflection.Assembly.GetExecutingAssembly.Location)
             End If
 
             If attrs IsNot Nothing AndAlso attrs.Length > 0 Then
                 Version = TryCast(attrs(0), AssemblyInformationalVersionAttribute)
             End If
 
             If FileVersion IsNot Nothing Then
                 msg = FileVersion.ProductName & " version " & FileVersion.FileVersion
             End If
             If Version IsNot Nothing Then
                 msg &= " (Mono " & Version.InformationalVersion & ")"
             End If
 
 #If DEBUG Then
             If FileVersion IsNot Nothing Then
                 msg &= " Last Write
             End If
 #End If
 
             result.AppendLine(msg)
             If FileVersion IsNot Nothing Then
                 result.AppendLine(FileVersion.LegalCopyright)
                 result.AppendLine()
             End If
 
             Return result.ToString
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="665" endline="733"><![CDATA[
     End Property
 
     ReadOnly Property Help() As String
         Get
             Dim result As New System.Text.StringBuilder
 
             result.AppendLine("")
             result.AppendLine("            Visual Basic Compiler Options          ")
             result.AppendLine("")
             result.AppendLine("                       >>> Output file options >>>")
             result.AppendLine("/out
             result.AppendLine("/target
             result.AppendLine("/target
             result.AppendLine("/target
             result.AppendLine("/target
             result.AppendLine("")
             result.AppendLine("                       >>> Input files options >>>")
             result.AppendLine("/addmodule
             result.AppendLine("/recurse
             result.AppendLine("/reference
             result.AppendLine("")
             result.AppendLine("                       >>> Resources options >>>")
             result.AppendLine("/linkresource
             result.AppendLine("/resource
             result.AppendLine("/win32icon
             result.AppendLine("/win32resource
             result.AppendLine("")
             result.AppendLine("                       >>> Debug and code generation options >>>")
             result.AppendLine("/optimize[+|-]         Enable optimizations.")
             result.AppendLine("/removeintchecks[+|-]  Remove integer checks. Default off.")
             result.AppendLine("/debug[+|-]            Emit debugging information.")
             result.AppendLine("/debug
             result.AppendLine("/debug
             result.AppendLine("")
             result.AppendLine("                       >>> Errors and warnings options >>>")
             result.AppendLine("/nowarn                Disable warnings.")
             result.AppendLine("/warnaserror[+|-]      Treat warnings as errors.")
             result.AppendLine("")
             result.AppendLine("                       >>> Language options >>>")
             result.AppendLine("/define
             result.AppendLine("/imports
             result.AppendLine("/optionexplicit[+|-]   Require explicit declaration of variables.")
             result.AppendLine("/optionstrict[+|-]     Enforce strict language semantics.")
             result.AppendLine("/rootnamespace
             result.AppendLine("/optioncompare
             result.AppendLine("/optioncompare
             result.AppendLine("")
             result.AppendLine("                       >>> Various options >>> ")
             result.AppendLine("/help                  Show this help message. (Also
             result.AppendLine("/nologo                Do not show the compiler copyright banner.")
             result.AppendLine("/quiet                 Specifies a quiet mode - only errors will be shown.")
             result.AppendLine("/verbose               Show verbose messages.")
             result.AppendLine("/noconfig              Disable the automatic inclusion of the vbnc.rsp response file.")
             result.AppendLine("")
             result.AppendLine("                       >>> Advanced options >>>")
             result.AppendLine("/baseaddress
             result.AppendLine("/bugreport
             result.AppendLine("/codepage
             result.AppendLine("/delaysign[+|-]        Specifies whether to delay-sign the assembly using only the public portion of the strong name key.")
             result.AppendLine("/keycontainer
             result.AppendLine("/keyfile
             result.AppendLine("/libpath
             result.AppendLine("/main
             result.AppendLine("/netcf                 Specifies the .NET Compact Framework as the target. *Not supported*.")
             result.AppendLine("/sdkpath
             result.AppendLine("/utf8output[+|-]       Emit the output from the compiler in UTF8 encoding. *Not supported yet*")
 
             Return result.ToString
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="734" endline="742"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Writes the logo of the compiler to the console.
     ''' </summary>
     ''' <remarks></remarks>
     Sub ShowLogo()
         Compiler.Report.Write(Logo)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="743" endline="750"><![CDATA[
 
     ''' <summary>
     ''' Writes the help of the compier to the console.
     ''' </summary>
     ''' <remarks></remarks>
     Sub ShowHelp()
         Compiler.Report.Write(Help)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="751" endline="813"><![CDATA[
 
     Private Function AddResources() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To CommandLine.Resources.Count - 1
             Dim r As Resource = CommandLine.Resources(i)
             Dim resourceDescription As String = ""
             Dim resourceFile As String = IO.Path.GetFileName(r.Filename)
             Dim resourceName As String = IO.Path.GetFileName(r.Filename)
             Dim attrib As System.Reflection.ResourceAttributes
 
             If r.Identifier <> String.Empty Then
                 resourceName = r.Identifier
             Else
                 resourceName = IO.Path.GetFileName(r.Filename)
             End If
 
             If r.Public Then
                 attrib = System.Reflection.ResourceAttributes.Public
             Else
                 attrib = System.Reflection.ResourceAttributes.Private
             End If
 
             Dim reader As System.Resources.IResourceReader
             Select Case IO.Path.GetExtension(r.Filename).ToLowerInvariant
                 Case ".resx"
                     reader = Nothing 'New System.Resources.ResXResourceReader(r.Filename)
                 Case ".resources"
                     Try
                         reader = New System.Resources.ResourceReader(r.Filename)
                     Catch ex As Exception
                         result = Compiler.Report.ShowMessage(Messages.VBNC31509, Span.CommandLineSpan, r.Filename, ex.Message) AndAlso result
                         Continue For
                     End Try
                 Case Else
                     reader = Nothing
             End Select
 
             'Report.WriteLine("Defining resource, FileName=" & r.Filename & ", Identifier=" & r.Identifier & ", reader is nothing=" & (reader Is Nothing).ToString())
             If reader IsNot Nothing Then
                 Dim cecilStream As New IO.MemoryStream()
                 Dim cecilWriter As New System.Resources.ResourceWriter(cecilStream)
 
                 For Each resource As System.Collections.DictionaryEntry In reader
                     'Report.WriteLine(">" & resource.Key.ToString & "=" & resource.Value.ToString)
                     cecilWriter.AddResource(resource.Key.ToString, resource.Value)
                 Next
                 reader.Dispose()
                 cecilWriter.Generate()
 
                 Dim cecilResource As New Mono.Cecil.EmbeddedResource(resourceName, Mono.Cecil.ManifestResourceAttributes.Public, cecilStream.ToArray()) 'FIXME
 
                 AssemblyBuilderCecil.MainModule.Resources.Add(cecilResource)
                 cecilWriter.Dispose()
                 cecilStream.Dispose()
             Else
                 'Report.WriteLine(">Writing ManifestResource")
                 'ModuleBuilder.DefineManifestResource(resourceName, New IO.FileStream(r.Filename, IO.FileMode.Open, IO.FileAccess.Read, IO.FileShare.Read), attrib)
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="814" endline="897"><![CDATA[
 
     ''' <summary>
     ''' Sets the entry point / Main function of the assembly
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function SetMain() As Boolean
         Dim result As Boolean = True
 
         Try
             If CommandLine.Target = vbnc.CommandLine.Targets.Library Then Return True
             If CommandLine.Target = vbnc.CommandLine.Targets.Module Then Return True
 
             'Find the main function
             Dim lstMethods As New Generic.List(Of Mono.Cecil.MethodDefinition)
             Dim mainClass As TypeDeclaration = Nothing
             Dim mainCecil As Mono.Cecil.MethodDefinition = Nothing
             Dim hasMainMethod As Boolean
 
             result = FindMainClass(mainClass) AndAlso result
             result = FindMainMethod(mainClass, lstMethods, hasMainMethod) AndAlso result
 
             If result = False Then Return result
 
             If lstMethods.Count = 0 AndAlso CommandLine.Target = vbnc.CommandLine.Targets.Winexe AndAlso mainClass IsNot Nothing AndAlso vbnc.Helper.IsSubclassOf(TypeCache.System_Windows_Forms_Form, mainClass.CecilType) Then
                 'In this case we need to create our own main method
                 'Dim mainBuilder As MethodBuilder
                 Dim formConstructor As ConstructorDeclaration
                 'Dim ilGen As ILGenerator
 
                 formConstructor = mainClass.DefaultInstanceConstructor
 
                 If formConstructor IsNot Nothing Then
                     mainCecil = New Mono.Cecil.MethodDefinition("Main", Mono.Cecil.MethodAttributes.Public Or Mono.Cecil.MethodAttributes.Static Or Mono.Cecil.MethodAttributes.HideBySig, Helper.GetTypeOrTypeReference(Me, TypeCache.System_Void))
                     mainCecil.Body.GetILProcessor.Emit(Mono.Cecil.Cil.OpCodes.Newobj, formConstructor.CecilBuilder)
                     mainCecil.Body.GetILProcessor.Emit(Mono.Cecil.Cil.OpCodes.Call, Helper.GetMethodOrMethodReference(Me, TypeCache.System_Windows_Forms_Application__Run))
                     mainCecil.Body.GetILProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret)
                     mainClass.CecilType.Methods.Add(mainCecil)
                     lstMethods.Add(mainCecil)
                 End If
             End If
 
             'Set the entry point of the assembly
             If lstMethods.Count > 1 Then
                 Dim name As String
                 If mainClass IsNot Nothing Then name = mainClass.Name Else name = AssemblyBuilderCecil.Name.Name
                 Report.ShowMessageNoLocation(Messages.VBNC30738, name)
                 Return False
             ElseIf lstMethods.Count = 0 Then
                 If hasMainMethod Then
                     Dim name As String
                     If mainClass IsNot Nothing Then name = mainClass.Name Else name = AssemblyBuilderCecil.Name.Name
                     Report.ShowMessageNoLocation(Messages.VBNC30737, name)
                     Return False
                 Else
                     Dim name As String
                     If mainClass IsNot Nothing Then name = mainClass.Name Else name = AssemblyBuilderCecil.Name.Name
                     Report.ShowMessageNoLocation(Messages.VBNC30420, name)
                     Return False
                 End If
             Else
                 Dim entryMethod As Mono.Cecil.MethodDefinition = lstMethods(0)
                 If mainCecil Is Nothing Then
                     mainCecil = entryMethod
                 End If
                 Dim foundSTAThreadAttribute As Boolean = False
                 For i As Integer = 0 To mainCecil.CustomAttributes.Count - 1
                     If Helper.CompareMethod(mainCecil.CustomAttributes(0).Constructor, TypeCache.System_STAThreadAttribute__ctor) = False Then
                         foundSTAThreadAttribute = True
                         Exit For
                     End If
                 Next
                 If foundSTAThreadAttribute = False Then
                     mainCecil.CustomAttributes.Add(New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, TypeCache.System_STAThreadAttribute__ctor)))
                 End If
                 AssemblyBuilderCecil.EntryPoint = entryMethod
             End If
 
         Catch ex As Exception
             Throw
         End Try
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="898" endline="920"><![CDATA[
 
     Function FindMainClass(ByRef Result As TypeDeclaration) As Boolean
         'Dim mainClasses As ArrayList
         Dim mainClass As TypeDeclaration
 
         If CommandLine.Main = "" Then
             Result = Nothing
             Return True
         End If
 
         mainClass = theAss.FindType(CommandLine.Main)
 
         If mainClass Is Nothing Then
             Report.ShowMessage(Messages.VBNC90013, Span.CommandLineSpan, CommandLine.Main, "0")
             Result = Nothing
             Return False
         End If
 
         'Result = DirectCast(mainClasses(0), TypeDescriptor)
         Result = mainClass
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="921" endline="940"><![CDATA[
 
     Function FindMainMethod(ByVal MainClass As TypeDeclaration, ByVal Result As Generic.List(Of Mono.Cecil.MethodDefinition), ByRef hasMainMethod As Boolean) As Boolean
         Dim tps() As TypeDeclaration
 
         If MainClass Is Nothing Then
             tps = theAss.Types
         Else
             tps = New TypeDeclaration() {MainClass}
         End If
 
         Result.Clear()
         For Each t As TypeDeclaration In tps
             For Each m As Mono.Cecil.MethodDefinition In t.CecilType.Methods
                 If hasMainMethod = False Then hasMainMethod = vbnc.Helper.CompareName(m.Name, "Main")
                 If IsMainMethod(m) Then Result.Add(m)
             Next
         Next
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="941" endline="968"><![CDATA[
 
     ''' <summary>
     ''' Returns the directory where the system assemblies are installed
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function GetSystemDir() As String
         Dim assemblies() As Reflection.Assembly
         Dim result As String
 
         If Not String.IsNullOrEmpty(CommandLine.SDKPath) Then
             If CommandLine.Verbose Then Report.WriteLine(string.Format ("Using alternate system path
             Return CommandLine.SDKPath
         End If
 
         assemblies = AppDomain.CurrentDomain.GetAssemblies
 
         For Each a As Reflection.Assembly In assemblies
             Dim codebase As String = a.Location
             If codebase.EndsWith("corlib.dll") Then
                 result = codebase.Substring(0, codebase.LastIndexOf(System.IO.Path.DirectorySeparatorChar))
                 If CommandLine.Verbose Then Report.WriteLine(String.Format("Using system path
                 Return result
             End If
         Next
         Throw New InternalException("Cannot compute the system directory.")
         Return ""
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="38" endline="40"><![CDATA[
         Get
             Return m_ObjectValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     ReadOnly Property ValueAsDouble() As Double
         Get
             Return CDbl(m_ObjectValue)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="47" endline="52"><![CDATA[
     End Property
 
     ReadOnly Property ValueAsString() As String
         Get
             Return CStr(m_ObjectValue)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="53" endline="58"><![CDATA[
     End Property
 
     ReadOnly Property ValueAsDate() As Date
         Get
             Return CDate(m_ObjectValue)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="59" endline="64"><![CDATA[
     End Property
 
     ReadOnly Property ValueAsBoolean() As Boolean
         Get
             Return CBool(m_ObjectValue)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="65" endline="73"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The symbol of this define.
     ''' </summary>
     ReadOnly Property Symbol() As String
         Get
             Return m_Symbol
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="74" endline="82"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The value of this define.
     ''' </summary>
     ReadOnly Property Value() As String
         Get
             Return m_Value
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="83" endline="94"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new define with the specified values.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Symbol As String, ByVal Value As String)
         Me.m_Symbol = Symbol
         Me.m_Value = Value
         Me.m_Compiler = Compiler
 
         Parse()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="95" endline="141"><![CDATA[
 
     ''' <summary>
     ''' Some decent parsing is needed here.
     ''' </summary>
     ''' <remarks></remarks>
     Sub Parse()
         If m_Value = String.Empty Then
             m_ObjectValue = Nothing
             Return
         End If
 
         If Helper.CompareName(m_Value, "Nothing") Then
             m_ObjectValue = Nothing
             Return
         ElseIf Helper.CompareName(m_Value, "True") Then
             m_ObjectValue = True
             Return
         ElseIf Helper.CompareName(m_Value, "False") Then
             m_ObjectValue = False
             Return
         End If
 
         If m_Value.StartsWith("#") Then
             If m_Value.EndsWith("#") Then
                 m_ObjectValue = DateTime.Parse(m_Value.Substring(1, m_Value.Length - 2))
                 Return
             Else
                 Helper.AddError(Compiler, Span.CommandLineSpan, "Invalid date constant
             End If
         End If
 
         If m_Value.StartsWith("""") Then
             If m_Value.EndsWith("""") Then
                 m_ObjectValue = m_Value.Substring(1, m_Value.Length - 2)
                 Return
             Else
                 Helper.AddError(Compiler, Span.CommandLineSpan, "Invalid string constant
             End If
         End If
 
         If True OrElse Microsoft.VisualBasic.IsNumeric(m_Value) Then
             m_ObjectValue = VB.Val(m_Value)
             Return
         End If
 
         Helper.AddError(Compiler, Span.CommandLineSpan, "Invalid constant
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="142" endline="146"><![CDATA[
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Defines.vb" startline="30" endline="32"><![CDATA[
         Get
             Return DirectCast(MyBase.Item(Index), Define)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Defines.vb" startline="33" endline="40"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Adds a new Define to the list.
     ''' </summary>
     Shadows Function Add(ByVal Define As Define) As Integer
         Return MyBase.Add(Define)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Defines.vb" startline="41" endline="55"><![CDATA[
 
     Function IsDefined(ByVal str As String) As Boolean
         Dim def As Define
         def = Item(str)
         If def Is Nothing Then Return False
 
         If def.Value <> "" Then
             Dim b As Boolean
             If Boolean.TryParse(def.Value, b) Then Return b
             If VB.IsNumeric(def.Value) Then Return CBool(CDbl(def.Value))
             Return False
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Defines.vb" startline="56" endline="65"><![CDATA[
 
     Default Shadows ReadOnly Property Item(ByVal Name As String) As Define
         Get
             For Each def As Define In Me
                 If Helper.CompareName(def.Symbol, Name) Then
                     Return def
                 End If
             Next
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\GlobalNamespace.vb" startline="23" endline="26"><![CDATA[
     Sub New(ByVal Parent As BaseObject)
         MyBase.New(Parent, "", True)
         m_Global = True
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\GlobalNamespace.vb" startline="27" endline="30"><![CDATA[
 
     Public Overrides Function ToString() As String
         Return "Global"
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="31" endline="36"><![CDATA[
     Public Shared StringComparer As System.StringComparer = System.StringComparer.OrdinalIgnoreCase
     Public Shared StringComparison As StringComparison = StringComparison.OrdinalIgnoreCase
 
     Private Shared m_SharedCompilers As New Generic.List(Of Compiler)
 
     Public Shared LOGMETHODRESOLUTION As Boolean = False
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="37" endline="80"><![CDATA[
 
 #Region "Helper"
 
     'Constant methods.
     'Private Shared m_Asc_Char As MethodInfo ', if the constant string is not empty
     'Private Shared m_Asc_String As MethodInfo ', if the constant string is not empty
     'Private Shared m_AscW_Char As MethodInfo ', if the constant string is not empty
     'Private Shared m_AscW_String As MethodInfo ', if the constant string is not empty
     'Private Shared m_Chr_Integer As MethodInfo ', if the constant value is between 0 and 128
     'Private Shared m_ChrW_Integer As MethodInfo
     'Private Shared m_AllConstantFunctions As ArrayList
 
     'A constant expression is an expression whose value can be fully evaluated at compile time. The type of a constant expression can be Byte, Short, Integer, Long, Char, Single, Double, Decimal, Boolean, String, or any enumeration type. The following constructs are permitted in constant expressions
     'Literals (including Nothing).
     'References to constant type members or constant locals.
     'References to members of enumeration types.
     'Parenthesized subexpressions.
     'Coercion expressions, provided the target type is one of the types listed above. Coercions to and from String are an exception to this rule and not allowed because String conversions are always done in the current culture of the execution environment at run time.
     'The +, - and Not unary operators.
     'The +, -, *, ^, Mod, /, \, <<, >>, &, And, Or, Xor, AndAlso, OrElse, =, <, >, <>, <=, and => binary operators, provided each operand is of a type listed above.
     'The following run-time functions
     'Microsoft.VisualBasic.Strings.ChrW
     'Microsoft.VisualBasic.Strings.Chr, if the constant value is between 0 and 128
     'Microsoft.VisualBasic.Strings.AscW, if the constant string is not empty
     'Microsoft.VisualBasic.Strings.Asc, if the constant string is not empty
 
     'Constant expressions of an integral type (Long, Integer, Short, Byte) can be implicitly converted to a narrower integral type, and constant expressions of type Double can be implicitly converted to Single, provided the value of the constant expression is within the range of the destination type. These narrowing conversions are allowed regardless of whether permissive or strict semantics are being used.
 
     Private Shared Function IsMethod(ByVal m1 As Mono.Cecil.MethodReference, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference, ByVal ReturnType As Mono.Cecil.TypeReference) As Boolean
         If CecilHelper.IsGenericMethod(m1) Then Return False
         If CecilHelper.IsGenericMethodDefinition(m1) Then Return False
 
         If CompareNameOrdinal(m1.Name, Name) = False Then Return False
 
         If Helper.CompareType(m1.ReturnType, ReturnType) = False Then Return False
 
         Dim p1 As Mono.Collections.Generic.Collection(Of Mono.Cecil.ParameterDefinition)
         p1 = m1.Parameters()
         If p1.Count <> 1 Then Return False
 
         If Helper.CompareType(p1(0).ParameterType, ParameterType) = False Then Return False
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="81" endline="117"><![CDATA[
 
     Public Function IsConstantMethod(ByVal Method As Mono.Cecil.MethodReference, ByVal Parameter As Object, ByRef Result As Object) As Boolean
         If Method.DeclaringType.Namespace IsNot Nothing AndAlso Not CompareNameOrdinal(Method.DeclaringType.Namespace, "Microsoft.VisualBasic") Then Return False
         If Not CompareNameOrdinal(Method.DeclaringType.Name, "Strings") Then Return False
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine("IsConstantMethod
 #End If
         Dim isConstant As Boolean
         If IsMethod(Method, "Chr", Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Char) Then
             If TypeOf Parameter Is Integer = False Then Return False
             Dim intParam As Integer = CInt(Parameter)
             'CHECK
             isConstant = intParam >= 0 AndAlso intParam < 128
             If isConstant Then Result = Microsoft.VisualBasic.Strings.Chr(intParam)
         ElseIf IsMethod(Method, "ChrW", Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Char) Then
             Helper.Assert(TypeOf Parameter Is Integer)
             isConstant = True
             Result = Microsoft.VisualBasic.Strings.ChrW(CInt(Parameter))
         ElseIf IsMethod(Method, "Asc", Compiler.TypeCache.System_Char, Compiler.TypeCache.System_Int32) Then
             isConstant = TypeOf Parameter Is Char
             If isConstant Then Result = Microsoft.VisualBasic.Asc(CChar(Parameter))
         ElseIf IsMethod(Method, "AscW", Compiler.TypeCache.System_Char, Compiler.TypeCache.System_Int32) Then
             isConstant = TypeOf Parameter Is Char
             If isConstant Then Result = Microsoft.VisualBasic.AscW(CChar(Parameter))
         ElseIf IsMethod(Method, "Asc", Compiler.TypeCache.System_String, Compiler.TypeCache.System_Int32) Then
             isConstant = TypeOf Parameter Is String AndAlso CStr(Parameter) <> ""
             If isConstant Then Result = Microsoft.VisualBasic.Asc(CStr(Parameter))
         ElseIf IsMethod(Method, "AscW", Compiler.TypeCache.System_String, Compiler.TypeCache.System_Int32) Then
             isConstant = TypeOf Parameter Is String AndAlso CStr(Parameter) <> ""
             If isConstant Then Result = Microsoft.VisualBasic.AscW(CStr(Parameter))
         Else
             Return False
         End If
 
         Return isConstant
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="118" endline="126"><![CDATA[
 #End Region
 
     Shared Function CreateList(ByVal types As System.Collections.IEnumerable) As TypeList
         Dim result As New TypeList
         For Each t As IType In types
             result.Add(t.CecilType)
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="127" endline="145"><![CDATA[
 
     Public Shared Function GetAttributes(ByVal m_Declaration As ConstructorDeclaration) As Mono.Cecil.MethodAttributes
         Dim flags As Mono.Cecil.MethodAttributes
         flags = Mono.Cecil.MethodAttributes.SpecialName Or Mono.Cecil.MethodAttributes.RTSpecialName
 
         'LAMESPEC
         'VBC
         If m_Declaration.Modifiers.IsAny(ModifierMasks.AccessModifiers) = False AndAlso m_Declaration.IsShared Then
             flags = flags Or Mono.Cecil.MethodAttributes.Private
         Else
             flags = flags Or m_Declaration.Modifiers.GetMethodAttributeScope
         End If
 
         If m_Declaration.IsShared Then
             flags = flags Or Mono.Cecil.MethodAttributes.Static
         End If
 
         Return flags
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="146" endline="224"><![CDATA[
 
     Public Shared Function GetAttributes(ByVal m_Declaration As MethodBaseDeclaration) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = m_Declaration.Modifiers.GetMethodAttributeScope
 
         'If Modifiers.IsNothing(m_Declaration.Modifiers) = False Then
         If m_Declaration.IsShared Then
             result = result Or Mono.Cecil.MethodAttributes.Static
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.MustOverride) Then
             If m_Declaration.Modifiers.Is(ModifierMasks.Overrides) = False Then
                 result = result Or Mono.Cecil.MethodAttributes.NewSlot
             End If
             result = result Or Mono.Cecil.MethodAttributes.Abstract Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.NotOverridable) Then
             result = result Or Mono.Cecil.MethodAttributes.Final
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Overridable) Then
             result = result Or Mono.Cecil.MethodAttributes.NewSlot Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Overrides) Then
             result = result Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Overloads) Then
             result = result Or Mono.Cecil.MethodAttributes.HideBySig
         End If
         'End If
 
         If TypeOf m_Declaration.Parent Is PropertyDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.SpecialName
         End If
 
         If TypeOf m_Declaration Is ExternalSubDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.Static
         End If
 
         If m_Declaration.HandlesOrImplements IsNot Nothing Then
             If m_Declaration.HandlesOrImplements.ImplementsClause IsNot Nothing Then
                 result = result Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
                 If m_Declaration.Modifiers.Is(ModifierMasks.Overrides) = False Then
                     result = result Or Mono.Cecil.MethodAttributes.NewSlot
                 End If
                 If m_Declaration.Modifiers.Is(ModifierMasks.Overridable) = False AndAlso m_Declaration.Modifiers.Is(ModifierMasks.MustOverride) = False AndAlso m_Declaration.Modifiers.Is(ModifierMasks.Overrides) = False Then
                     result = result Or Mono.Cecil.MethodAttributes.Final
                 End If
             End If
         End If
 
         If TypeOf m_Declaration.Parent Is EventDeclaration Then
             If DirectCast(m_Declaration.Parent, EventDeclaration).ImplementsClause IsNot Nothing Then
                 result = result Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.NewSlot Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride Or Mono.Cecil.MethodAttributes.Final
             End If
         End If
 
         If m_Declaration.DeclaringType.IsInterface Then
             result = result Or Mono.Cecil.MethodAttributes.Abstract Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride Or Mono.Cecil.MethodAttributes.NewSlot
         End If
         If TypeOf m_Declaration Is OperatorDeclaration OrElse TypeOf m_Declaration Is ConversionOperatorDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.SpecialName
         ElseIf TypeOf m_Declaration Is EventHandlerDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.SpecialName
         End If
 
         If m_Declaration.CustomAttributes IsNot Nothing AndAlso m_Declaration.CustomAttributes.IsDefined(m_Declaration.Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
             result = result Or Mono.Cecil.MethodAttributes.PInvokeImpl
         End If
 
         If TypeOf m_Declaration Is ExternalSubDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.PInvokeImpl
         End If
 
         If m_Declaration.HasSecurityCustomAttribute Then
             result = result Or Mono.Cecil.MethodAttributes.HasSecurity
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="225" endline="265"><![CDATA[
 
 
     Public Shared Function GetAttributes(ByVal Compiler As Compiler, ByVal m_Declaration As IFieldMember) As Mono.Cecil.FieldAttributes
         Dim result As Mono.Cecil.FieldAttributes
 
         If m_Declaration.Modifiers.Is(ModifierMasks.WithEvents) Then
             result = Mono.Cecil.FieldAttributes.Private
         Else
             result = m_Declaration.Modifiers.GetFieldAttributeScope(DirectCast(m_Declaration, BaseObject).FindFirstParent(Of TypeDeclaration))
         End If
 
         If m_Declaration.Modifiers.Is(ModifierMasks.Static) Then
             result = result Or Mono.Cecil.FieldAttributes.SpecialName
             If DirectCast(m_Declaration, BaseObject).FindFirstParent(Of IMethod).IsShared Then
                 result = result Or Mono.Cecil.FieldAttributes.Static
             End If
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Shared) OrElse m_Declaration.IsShared Then
             result = result Or Mono.Cecil.FieldAttributes.Static
         End If
         If TypeOf m_Declaration Is EnumMemberDeclaration Then
             result = result Or Mono.Cecil.FieldAttributes.Static Or Mono.Cecil.FieldAttributes.Literal
         End If
         If TypeOf m_Declaration Is ConstantDeclaration Then
             result = result Or Mono.Cecil.FieldAttributes.Static
             If m_Declaration.FieldType IsNot Nothing Then
                 If Helper.CompareType(m_Declaration.FieldType, Compiler.TypeCache.System_Decimal) Then
                     result = result Or Mono.Cecil.FieldAttributes.InitOnly
                 ElseIf Helper.CompareType(m_Declaration.FieldType, Compiler.TypeCache.System_DateTime) Then
                     result = result Or Mono.Cecil.FieldAttributes.InitOnly
                 Else
                     result = result Or Mono.Cecil.FieldAttributes.Literal Or Mono.Cecil.FieldAttributes.HasDefault
                 End If
             End If
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.ReadOnly) Then
             result = result Or Mono.Cecil.FieldAttributes.InitOnly
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="266" endline="269"><![CDATA[
 
     Shared Function IsOnMS() As Boolean
         Return Not IsOnMono()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="270" endline="279"><![CDATA[
 
     Shared Function IsOnMono() As Boolean
         Dim t As Type = GetType(Integer)
 
         If t.GetType().ToString = "System.MonoType" Then
             Return True
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="280" endline="294"><![CDATA[
 
     Shared Function VerifyValueClassification(ByRef Expression As Expression, ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         If Expression.Classification.IsValueClassification Then
             result = True
         ElseIf Expression.Classification.CanBeValueClassification Then
             Expression = Expression.ReclassifyToValueExpression
             result = Expression.ResolveExpression(Info) AndAlso result
             Helper.StopIfDebugging(result = False)
         Else
             Helper.AddError(Expression)
             result = False
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="295" endline="305"><![CDATA[
 
     Shared Function IsEmittableMember(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean
 
         If Member Is Nothing Then Return True
         If TypeOf Member Is Mono.Cecil.GenericParameter Then Return True
         If TypeOf Member Is Mono.Cecil.ArrayType Then Return True
         result = FindAssembly(Member) Is Compiler.AssemblyBuilderCecil
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="306" endline="312"><![CDATA[
 
     Shared Function FindAssembly(ByVal member As Mono.Cecil.MemberReference) As Mono.Cecil.AssemblyDefinition
         Helper.Assert(member IsNot Nothing)
         Dim type As Mono.Cecil.TypeReference = TryCast(member, Mono.Cecil.TypeReference)
         If type IsNot Nothing Then Return FindAssembly(type)
         Return FindAssembly(member.DeclaringType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="313" endline="333"><![CDATA[
 
     Shared Function FindAssembly(ByVal type As Mono.Cecil.TypeReference) As Mono.Cecil.AssemblyDefinition
         Helper.Assert(type IsNot Nothing)
 
         While type.DeclaringType IsNot Nothing
             If type.Module IsNot Nothing AndAlso type.Module.Assembly IsNot Nothing Then Return type.Module.Assembly
             type = type.DeclaringType
         End While
         While type.DeclaringType IsNot Nothing
             If type.Module IsNot Nothing AndAlso type.Module.Assembly IsNot Nothing Then Return type.Module.Assembly
             type = type.DeclaringType
         End While
         Dim tS As Mono.Cecil.TypeSpecification = TryCast(type, Mono.Cecil.TypeSpecification)
         While tS IsNot Nothing
             type = tS.ElementType
             tS = TryCast(type, Mono.Cecil.TypeSpecification)
         End While
         While tS IsNot Nothing
             type = tS.ElementType
             tS = TryCast(type, Mono.Cecil.TypeSpecification)
         End While
         'Helper.Assert(type IsNot Nothing AndAlso type.[Module] IsNot Nothing)
 
         If type Is Nothing OrElse type.Module Is Nothing Then
             Return Nothing
         Else
             Return type.Module.Assembly
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="334" endline="348"><![CDATA[
 
     Shared Function GetParameterTypes(ByVal Context As BaseObject, ByVal member As Mono.Cecil.MemberReference) As Mono.Cecil.TypeReference()
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = GetParameters(Context, member)
         Dim result() As Mono.Cecil.TypeReference
 
         If params Is Nothing Then Return Nothing
 
         ReDim result(params.Count - 1)
 
         For i As Integer = 0 To params.Count - 1
             result(i) = params(i).ParameterType
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="349" endline="361"><![CDATA[
 
     Shared Function GetGenericParameters(ByVal Member As MemberReference) As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim methodReference As MethodReference
         Dim typeReference As TypeReference
 
         methodReference = TryCast(Member, MethodReference)
         If methodReference IsNot Nothing Then Return CecilHelper.FindDefinition(methodReference).GenericParameters
 
         typeReference = TryCast(Member, TypeReference)
         If typeReference IsNot Nothing Then Return CecilHelper.FindDefinition(typeReference).GenericParameters
 
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="362" endline="371"><![CDATA[
 
     Shared Function GetGenericParameterConstraints(ByVal Context As BaseObject, ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, Mono.Cecil.GenericParameter)
 
         If tG IsNot Nothing Then Return tG.Constraints
 
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
         If CecilHelper.IsGenericParameter(Type) = False Then Throw New InternalException("")
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="372" endline="379"><![CDATA[
 
     Shared Function GetNames(ByVal List As IEnumerable) As String()
         Dim result As New Generic.List(Of String)
         For Each item As INameable In List
             result.Add(item.Name)
         Next
         Return result.ToArray
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="380" endline="419"><![CDATA[
 
     Shared Function GetTypeCode(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode
         If Helper.IsEnum(Compiler, Type) Then
             Return GetTypeCode(Compiler, Helper.GetEnumType(Compiler, Type))
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Byte) Then
             Return TypeCode.Byte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Boolean) Then
             Return TypeCode.Boolean
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Char) Then
             Return TypeCode.Char
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DateTime) Then
             Return TypeCode.DateTime
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DBNull) Then
             Return TypeCode.DBNull
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Decimal) Then
             Return TypeCode.Decimal
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Double) Then
             Return TypeCode.Double
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int16) Then
             Return TypeCode.Int16
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int32) Then
             Return TypeCode.Int32
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int64) Then
             Return TypeCode.Int64
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_SByte) Then
             Return TypeCode.SByte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Single) Then
             Return TypeCode.Single
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_String) Then
             Return TypeCode.String
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) Then
             Return TypeCode.UInt16
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) Then
             Return TypeCode.UInt32
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt64) Then
             Return TypeCode.UInt64
         Else
             Return TypeCode.Object
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="420" endline="432"><![CDATA[
 
     ''' <summary>
     ''' Compares two vb-names (case-insensitive)
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, StringComparison.OrdinalIgnoreCase)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="433" endline="436"><![CDATA[
 
     Shared Function CompareNameStart(ByVal Whole As String, ByVal Start As String) As Boolean
         Return String.Compare(Whole, 0, Start, 0, Start.Length, StringComparison.OrdinalIgnoreCase) = 0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="437" endline="451"><![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String, ByVal Ordinal As Boolean) As Boolean
         If Ordinal Then
             Return CompareNameOrdinal(Value1, Value2)
         Else
             Return CompareName(Value1, Value2)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="452" endline="464"><![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareNameOrdinal(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, System.StringComparison.Ordinal)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="465" endline="468"><![CDATA[
 
     Shared Function IsTypeDeclaration(ByVal first As Object) As Boolean
         Return TypeOf first Is IType OrElse TypeOf first Is Mono.Cecil.TypeDefinition
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="469" endline="472"><![CDATA[
 
     Shared Function IsFieldDeclaration(ByVal first As Object) As Boolean
         Return TypeOf first Is TypeVariableDeclaration OrElse TypeOf first Is Mono.Cecil.FieldReference
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="473" endline="489"><![CDATA[
 
     ''' <summary>
     ''' Intrinsic type
     ''' </summary>
     ''' <param name="Compiler"></param>
     ''' <param name="Type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsIntrinsicType(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Dim tC As TypeCode = GetTypeCode(Compiler, Type)
 
         If tC = TypeCode.Object Then
             Return Helper.CompareType(Type, Compiler.TypeCache.System_Object)
         Else
             Return True
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="490" endline="496"><![CDATA[
 
     Shared Function IsInterface(ByVal Context As BaseObject, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If TypeOf Type Is Mono.Cecil.GenericParameter Then Return False
         If TypeOf Type Is Mono.Cecil.ArrayType Then Return False
         If TypeOf Type Is ByReferenceType Then Return False
         Return CecilHelper.FindDefinition(Type).IsInterface
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="497" endline="502"><![CDATA[
 
     Shared Function IsEnum(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If TypeOf Type Is Mono.Cecil.GenericParameter Then Return False
         If TypeOf Type Is Mono.Cecil.ArrayType Then Return False
         Return CecilHelper.FindDefinition(Type).IsEnum
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="503" endline="508"><![CDATA[
 
     Shared Function IsEnumFieldDeclaration(ByVal Compiler As Compiler, ByVal first As Object) As Boolean
         If TypeOf first Is EnumMemberDeclaration Then Return True
         Dim fld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
         Return fld IsNot Nothing AndAlso Helper.IsEnum(Compiler, fld.DeclaringType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="509" endline="512"><![CDATA[
 
     Shared Function IsEventDeclaration(ByVal first As Object) As Boolean
         Return TypeOf first Is Mono.Cecil.EventReference
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="513" endline="516"><![CDATA[
 
     Shared Function IsPropertyDeclaration(ByVal first As Object) As Boolean
         Return TypeOf first Is RegularPropertyDeclaration OrElse TypeOf first Is Mono.Cecil.PropertyReference OrElse TypeOf first Is PropertyDeclaration
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="517" endline="520"><![CDATA[
 
     Shared Function IsMethodDeclaration(ByVal first As Object) As Boolean
         Return TypeOf first Is SubDeclaration OrElse TypeOf first Is FunctionDeclaration OrElse TypeOf first Is IMethod OrElse TypeOf first Is Mono.Cecil.MethodReference
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="521" endline="542"><![CDATA[
 
     ''' <summary>
     ''' Returns all the members in the types with the specified name.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetMembersOfTypes(ByVal Compiler As Compiler, ByVal Types As TypeDictionary, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
 
         If Types Is Nothing Then Return Nothing
 
         For Each type As Mono.Cecil.TypeReference In Types.Values
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             members = Compiler.TypeManager.GetCache(type).LookupFlattenedMembers(Name)
             If members IsNot Nothing Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                 result.AddRange(members)
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="543" endline="564"><![CDATA[
 
     ''' <summary>
     ''' Returns all the members in the types with the specified name.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetMembersOfTypes(ByVal Compiler As Compiler, ByVal Types As TypeList, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
 
         If Types Is Nothing Then Return Nothing
 
         For Each type As Mono.Cecil.TypeReference In Types
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             members = Compiler.TypeManager.GetCache(type).LookupFlattenedMembers(Name)
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                 result.AddRange(members)
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="565" endline="576"><![CDATA[
 
     Shared Function GetInstanceConstructors(ByVal type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference)
         Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference) = CecilHelper.GetConstructors(type)
 
         For i As Integer = 0 To ctors.Count - 1
             Dim ctor As Mono.Cecil.MethodReference = DirectCast(ctors(i), Mono.Cecil.MethodReference)
             If Helper.IsShared(ctor) = False Then result.Add(ctor)
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="577" endline="596"><![CDATA[
 
     ''' <summary>
     ''' Removes private members if they are from an external assembly.
     ''' </summary>
     ''' <param name="Members"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterExternalInaccessible(ByVal Compiler As Compiler, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
         For i As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(i)
             If (IsPrivate(member) OrElse IsFriend(member)) AndAlso Compiler.Assembly.IsDefinedHere(CecilHelper.FindDefinition(member.DeclaringType)) = False Then
                 Continue For
             End If
             result.Add(member)
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="597" endline="600"><![CDATA[
 
     Shared Function IsProtectedFriend(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Return GetAccessibility(Member) = (ModifierMasks.Protected Or ModifierMasks.Friend)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="601" endline="604"><![CDATA[
 
     Shared Function IsProtectedOrProtectedFriend(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Return (GetAccessibility(Member) And ModifierMasks.Protected) = ModifierMasks.Protected
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="605" endline="608"><![CDATA[
 
     Shared Function IsFriendOrProtectedFriend(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Return (GetAccessibility(Member) And ModifierMasks.Friend) = ModifierMasks.Friend
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="609" endline="618"><![CDATA[
 
     ''' <summary>
     ''' Checks if the member is Protected (not Protected Friend)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsProtected(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Return GetAccessibility(Member) = ModifierMasks.Protected
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="619" endline="638"><![CDATA[
 
     Shared Function GetVisibility(ByVal Attributes As Mono.Cecil.MethodAttributes) As ModifierMasks
         Dim attrib As Mono.Cecil.MethodAttributes = Attributes And Mono.Cecil.MethodAttributes.MemberAccessMask
         Select Case attrib
             Case Mono.Cecil.MethodAttributes.Private, Mono.Cecil.MethodAttributes.CompilerControlled
                 Return ModifierMasks.Private
             Case Mono.Cecil.MethodAttributes.FamANDAssem
                 Throw New NotImplementedException
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return ModifierMasks.Friend
             Case Mono.Cecil.MethodAttributes.Family
                 Return ModifierMasks.Protected
             Case Mono.Cecil.MethodAttributes.FamORAssem
                 Return ModifierMasks.Protected Or ModifierMasks.Friend
             Case Mono.Cecil.MethodAttributes.Public
                 Return ModifierMasks.Public
             Case Else
                 Throw New InternalException(String.Format("Attributes
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="639" endline="657"><![CDATA[
 
     Shared Function GetVisibility(ByVal Attributes As Mono.Cecil.FieldAttributes) As ModifierMasks
         Select Case Attributes And Mono.Cecil.FieldAttributes.FieldAccessMask
             Case Mono.Cecil.FieldAttributes.Private
                 Return ModifierMasks.Private
             Case Mono.Cecil.FieldAttributes.FamANDAssem
                 Throw New NotImplementedException
             Case Mono.Cecil.FieldAttributes.Assembly
                 Return ModifierMasks.Friend
             Case Mono.Cecil.FieldAttributes.Family
                 Return ModifierMasks.Protected
             Case Mono.Cecil.FieldAttributes.FamORAssem
                 Return ModifierMasks.Protected Or ModifierMasks.Friend
             Case Mono.Cecil.FieldAttributes.Public
                 Return ModifierMasks.Public
             Case Else
                 Throw New InternalException
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="658" endline="676"><![CDATA[
 
     Shared Function GetVisibility(ByVal Attributes As Mono.Cecil.TypeAttributes) As ModifierMasks
         Select Case Attributes And Mono.Cecil.TypeAttributes.VisibilityMask
             Case Mono.Cecil.TypeAttributes.NestedPrivate, Mono.Cecil.TypeAttributes.NotPublic
                 Return ModifierMasks.Private
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Throw New NotImplementedException
             Case Mono.Cecil.TypeAttributes.NestedAssembly
                 Return ModifierMasks.Friend
             Case Mono.Cecil.TypeAttributes.NestedFamily
                 Return ModifierMasks.Protected
             Case Mono.Cecil.TypeAttributes.NestedFamORAssem
                 Return ModifierMasks.Protected Or ModifierMasks.Friend
             Case Mono.Cecil.TypeAttributes.NestedPublic, Mono.Cecil.TypeAttributes.Public
                 Return ModifierMasks.Public
             Case Else
                 Throw New InternalException
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="677" endline="705"><![CDATA[
 
     ''' <summary>
     ''' Checks if the member is Friend (not Protected Friend)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetAccessibility(ByVal Member As Mono.Cecil.MemberReference) As ModifierMasks
         Helper.Assert(Member IsNot Nothing)
         If TypeOf Member Is Mono.Cecil.MethodReference Then
             Return GetVisibility(CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).Attributes)
         ElseIf TypeOf Member Is Mono.Cecil.TypeReference Then
             Return GetVisibility(CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.TypeReference)).Attributes)
         ElseIf TypeOf Member Is Mono.Cecil.EventReference Then
             Dim eD As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference))
             If eD.AddMethod IsNot Nothing Then Return GetVisibility(eD.AddMethod.Attributes)
             If eD.RemoveMethod IsNot Nothing Then Return GetVisibility(eD.RemoveMethod.Attributes)
             If eD.InvokeMethod IsNot Nothing Then Return GetVisibility(eD.InvokeMethod.Attributes)
             Return 0
         ElseIf TypeOf Member Is Mono.Cecil.FieldReference Then
             Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.FieldReference))
             Return GetVisibility(fD.Attributes)
         ElseIf TypeOf Member Is Mono.Cecil.PropertyReference Then
             Dim pD As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
             Return GetVisibility(GetPropertyAccess(pD))
         Else
             Throw New NotImplementedException
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="706" endline="715"><![CDATA[
 
     ''' <summary>
     ''' Checks if the member is Friend (not Protected Friend)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsFriend(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Return GetAccessibility(Member) = ModifierMasks.Friend
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="716" endline="719"><![CDATA[
 
     Shared Function IsPrivate(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Return GetAccessibility(Member) = ModifierMasks.Private
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="720" endline="733"><![CDATA[
 
     Shared Function IsPrivate(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="734" endline="747"><![CDATA[
 
     Shared Function IsFamilyOrAssembly(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="748" endline="751"><![CDATA[
 
     Shared Function IsPublic(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Return GetAccessibility(Member) = ModifierMasks.Public
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="752" endline="780"><![CDATA[
 
     Shared Function FilterByTypeArguments(ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal TypeArguments As TypeArgumentList) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim argCount As Integer
 
         If TypeArguments IsNot Nothing Then argCount = TypeArguments.Count
 
         For i As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(i)
 
             Dim minfo As Mono.Cecil.MethodReference = TryCast(member, Mono.Cecil.MethodReference)
             If minfo IsNot Nothing Then
                 If CecilHelper.GetGenericArguments(minfo).Count = argCount Then
                     If argCount > 0 Then
                         member = TypeArguments.Parent.Compiler.TypeManager.MakeGenericMethod(TypeArguments.Parent, minfo, CecilHelper.GetGenericArguments(minfo), TypeArguments.ArgumentCollection)
                         result.Add(member)
                     Else
                         result.Add(member)
                     End If
                 Else
                     'Helper.StopIfDebugging()
                 End If
             Else
                 result.Add(member)
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="781" endline="797"><![CDATA[
 
     Shared Function FilterByName(ByVal Context As BaseObject, ByVal collection As ICollection, ByVal Name As String) As ArrayList
         Dim result As New ArrayList
         Dim tmpname As String = ""
         For Each obj As Object In collection
             If TypeOf obj Is INameable Then
                 tmpname = DirectCast(obj, INameable).Name
             ElseIf TypeOf obj Is Mono.Cecil.MemberReference Then
                 tmpname = DirectCast(obj, Mono.Cecil.MemberReference).Name
             Else
                 Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
             End If
             If Helper.CompareName(Name, tmpname) Then result.Add(obj)
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="798" endline="807"><![CDATA[
 
     Shared Function FilterByName(ByVal collection As Generic.List(Of Type), ByVal Name As String) As Generic.List(Of Type)
         Dim result As New Generic.List(Of Type)
         Dim tmpname As String = ""
         For Each obj As Type In collection
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="808" endline="813"><![CDATA[
 
     Shared Sub FilterByName(ByVal collection As Mono.Collections.Generic.Collection(Of Mono.Cecil.TypeReference), ByVal Name As String, ByVal result As Generic.List(Of Mono.Cecil.MemberReference))
         For Each obj As Mono.Cecil.TypeReference In collection
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="814" endline="819"><![CDATA[
 
     Shared Sub FilterByName(ByVal collection As TypeDictionary, ByVal Name As String, ByVal result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         For Each obj As Mono.Cecil.TypeReference In collection.Values
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="820" endline="827"><![CDATA[
 
     Shared Function FilterByName(ByVal Types As TypeList, ByVal Name As String) As TypeList
         Dim result As New TypeList
         For Each obj As Mono.Cecil.TypeReference In Types
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="828" endline="835"><![CDATA[
 
     Shared Function FilterByName(ByVal Types As TypeDictionary, ByVal Name As String) As Mono.Cecil.TypeReference
         If Types.ContainsKey(Name) Then
             Return Types(Name)
         Else
             Return Nothing
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="836" endline="849"><![CDATA[
 
     ''' <summary>
     ''' Returns a list of type descriptors that only are modules.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterToModules(ByVal Compiler As Compiler, ByVal Types As TypeDictionary) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         For Each t As Mono.Cecil.TypeReference In Types.Values
             If IsModule(Compiler, t) Then result.Add(t)
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="850" endline="863"><![CDATA[
 
     Shared Function GetDefaultGenericConstructor(ByVal closedResolvedType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim candidates As Mono.Collections.Generic.Collection(Of MethodDefinition)
 
         candidates = CecilHelper.FindDefinition(closedResolvedType).Methods
         result = GetDefaultConstructor(candidates)
 
         If result IsNot Nothing Then
             result = CecilHelper.GetCorrectMember(result, closedResolvedType)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="864" endline="868"><![CDATA[
 
     Shared Function HasOnlyOptionalParameters(ByVal Constructor As Mono.Cecil.MethodDefinition) As Boolean
         Helper.Assert(HasParameters(Constructor))
         Return Constructor.Parameters(0).IsOptional
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="869" endline="878"><![CDATA[
 
     ''' <summary>
     ''' Returns true if this constructor has any parameter, default or normal parameter.
     ''' </summary>
     ''' <param name="Constructor"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function HasParameters(ByVal Constructor As Mono.Cecil.MethodDefinition) As Boolean
         Return Constructor.Parameters.Count > 0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="879" endline="897"><![CDATA[
 
     ''' <summary>
     ''' Finds a non-private, non-shared constructor with no parameters in the array.
     ''' If nothing found, returns nothing.
     ''' </summary>
     ''' <param name="Constructors"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetDefaultConstructor(ByVal Constructors As Mono.Collections.Generic.Collection(Of MethodDefinition)) As Mono.Cecil.MethodDefinition
         For i As Integer = 0 To Constructors.Count - 1
             If Not Constructors(i).IsConstructor Then Continue For
             If HasParameters(Constructors(i)) = False OrElse HasOnlyOptionalParameters(Constructors(i)) Then
                 If CecilHelper.IsStatic(Constructors(i)) = False AndAlso Helper.IsPrivate(Constructors(i)) = False Then
                     Return Constructors(i)
                 End If
             End If
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="898" endline="903"><![CDATA[
 
     Shared Function GetDefaultConstructor(ByVal tp As Mono.Cecil.TypeReference) As Mono.Cecil.MethodDefinition
         Dim td As TypeDefinition = CecilHelper.FindDefinition(tp)
         If td Is Nothing Then Return Nothing
         Return GetDefaultConstructor(td.Methods)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="904" endline="913"><![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Cecil.ParameterReference()) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Length - 1)
         For i As Integer = 0 To Parameters.GetUpperBound(0)
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="914" endline="923"><![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Count - 1)
         For i As Integer = 0 To Parameters.Count - 1
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="924" endline="940"><![CDATA[
 
     ''' <summary>
     ''' Checks if the specified type is a VB Module.
     ''' </summary>
     ''' <param name="type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsModule(ByVal Compiler As Compiler, ByVal type As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean
         Dim annotation As Object = type.Annotations(Compiler)
 
         If annotation IsNot Nothing AndAlso TypeOf annotation Is ModuleDeclaration Then Return True
 
         result = CecilHelper.IsClass(type) AndAlso Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute IsNot Nothing AndAlso CecilHelper.IsDefined(CecilHelper.FindDefinition(type).CustomAttributes, Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="941" endline="979"><![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As Expression()) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Length}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Length - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="980" endline="1018"><![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Count}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Count - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1019" endline="1062"><![CDATA[
 
     Shared Function EmitStoreArrayElement(ByVal Info As EmitInfo, ByVal ArrayVariable As Expression, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim ArrayType As Mono.Cecil.TypeReference = ArrayVariable.ExpressionType
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim isNonPrimitiveValueType As Boolean = CecilHelper.IsPrimitive(Info.Compiler, ElementType) = False AndAlso CecilHelper.IsValueType(ElementType)
         Dim isArraySetValue As Boolean = CecilHelper.GetArrayRank(ArrayType) > 1
         Dim newValue As Expression = Info.RHSExpression
 
         Helper.Assert(newValue IsNot Nothing)
         Helper.Assert(newValue.Classification.IsValueClassification)
 
         result = ArrayVariable.GenerateCode(Info.Clone(Info.Context, True, False, ArrayType)) AndAlso result
 
         If isArraySetValue Then
             result = newValue.GenerateCode(Info.Clone(Info.Context, True, False, ElementType)) AndAlso result
             If CecilHelper.IsValueType(ElementType) Then
                 Emitter.EmitBox(Info, ElementType)
             End If
             result = EmitIntegerArray(Info, Arguments) AndAlso result
             Emitter.EmitCallOrCallVirt(Info, Info.Compiler.TypeCache.System_Array__SetValue)
         Else
             Dim methodtypes As New Generic.List(Of Mono.Cecil.TypeReference)
             Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32)
             For i As Integer = 0 To Arguments.Count - 1
                 result = Arguments(i).GenerateCode(elementInfo) AndAlso result
                 Emitter.EmitConversion(Arguments(i).Expression.ExpressionType, Info.Compiler.TypeCache.System_Int32, Info)
                 methodtypes.Add(Info.Compiler.TypeCache.System_Int32)
             Next
 
             Dim rInfo As EmitInfo = Info.Clone(Info.Context, True, False, ElementType)
             methodtypes.Add(ElementType)
 
             If isNonPrimitiveValueType Then
                 Emitter.EmitLoadElementAddress(Info, ElementType, ArrayType)
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                 Emitter.EmitStoreObject(Info, ElementType)
             Else
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                 Emitter.EmitStoreElement(Info, ElementType, ArrayType)
             End If
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1063" endline="1107"><![CDATA[
 
     Shared Function EmitLoadArrayElement(ByVal Info As EmitInfo, ByVal ArrayVariable As Expression, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim ArrayType As Mono.Cecil.TypeReference = ArrayVariable.ExpressionType
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim isNonPrimitiveValueType As Boolean = CecilHelper.IsPrimitive(Info.Compiler, ElementType) = False AndAlso CecilHelper.IsValueType(ElementType)
         Dim isArrayGetValue As Boolean = CecilHelper.GetArrayRank(ArrayType) > 1
 
         result = ArrayVariable.GenerateCode(Info) AndAlso result
 
         If isArrayGetValue Then
             result = Arguments.GenerateCode(Info, Helper.CreateArray(Of Mono.Cecil.TypeReference)(Info.Compiler.TypeCache.System_Int32, Arguments.Length)) AndAlso result
             'result = EmitIntegerArray(Info, Arguments) AndAlso result
             Dim getMethod As Mono.Cecil.MethodReference
             getMethod = ArrayElementInitializer.GetGetMethod(Info.Compiler, ArrayType)
             Helper.Assert(getMethod IsNot Nothing, "getMethod for type " & ArrayType.FullName & " could not be found (" & ArrayType.GetType.Name & ")")
             Emitter.EmitCallVirt(Info, getMethod)
             'Emitter.EmitCallOrCallVirt(Info, Info.Compiler.TypeCache.Array_GetValue)
             'If ElementType.IsValueType Then
             '    Emitter.EmitUnbox(Info, ElementType)
             'Else
             '    Emitter.EmitCastClass(Info, Info.Compiler.TypeCache.Object, ElementType)
             'End If
         Else
             Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32)
             Dim methodtypes(Arguments.Count - 1) As Mono.Cecil.TypeReference
             For i As Integer = 0 To Arguments.Count - 1
                 Dim exp As Expression = Arguments(i).Expression
                 If Info.Compiler.TypeResolution.IsImplicitlyConvertible(Compiler.m_Compiler, exp.ExpressionType, Info.Compiler.TypeCache.System_Int32) = False Then
                     'TODO
                     exp = New CIntExpression(exp, exp)
                 End If
                 result = exp.GenerateCode(elementInfo) AndAlso result
                 methodtypes(i) = Info.Compiler.TypeCache.System_Int32
             Next
 
             If isNonPrimitiveValueType Then
                 Emitter.EmitLoadElementAddress(Info, ElementType, ArrayType)
                 Emitter.EmitLoadObject(Info, ElementType)
             Else
                 Emitter.EmitLoadElement(Info, ArrayType)
             End If
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1108" endline="1240"><![CDATA[
 
     ''' <summary>
     ''' Emits the instanceexpression (if any), the arguments (if any), the optional arguments (if any) and then calls the method (virt or not).
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="InstanceExpression"></param>
     ''' <param name="Arguments"></param>
     ''' <param name="Method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitArgumentsAndCallOrCallVirt(ByVal Info As EmitInfo, ByVal InstanceExpression As Expression, ByVal Arguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
         Dim needsConstrained As Boolean
         Dim constrainedLocal As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         needsConstrained = InstanceExpression IsNot Nothing AndAlso CecilHelper.IsGenericParameter(InstanceExpression.ExpressionType)
 
         Helper.Assert(Method IsNot Nothing)
 
         If InstanceExpression IsNot Nothing AndAlso CecilHelper.FindDefinition(Method).IsStatic = False Then
             Dim ieDesiredType As Mono.Cecil.TypeReference
             Dim ieInfo As EmitInfo
 
             If needsConstrained Then
                 ieDesiredType = InstanceExpression.ExpressionType
             Else
                 ieDesiredType = Method.DeclaringType
                 If CecilHelper.IsValueType(ieDesiredType) Then
                     ieDesiredType = Info.Compiler.TypeManager.MakeByRefType(CType(Info.Method, ParsedObject), ieDesiredType)
                 End If
             End If
 
             ieInfo = Info.Clone(Info.Context, True, False, ieDesiredType)
 
             Dim derefExp As DeRefExpression = TryCast(InstanceExpression, DeRefExpression)
             If needsConstrained AndAlso derefExp IsNot Nothing Then
                 result = derefExp.Expression.GenerateCode(Info.Clone(Info.Context, True, False, derefExp.Expression.ExpressionType)) AndAlso result
             Else
                 Dim getRef As GetRefExpression = TryCast(InstanceExpression, GetRefExpression)
                 If getRef IsNot Nothing AndAlso CecilHelper.IsValueType(getRef.Expression.ExpressionType) AndAlso Helper.CompareType(Method.DeclaringType, Info.Compiler.TypeCache.System_Object) Then
                     result = getRef.Expression.GenerateCode(ieInfo) AndAlso result
                     Emitter.EmitBox(Info, getRef.Expression.ExpressionType)
                 Else
                     result = InstanceExpression.GenerateCode(ieInfo) AndAlso result
                 End If
 
                 If needsConstrained Then
                     constrainedLocal = Emitter.DeclareLocal(Info, InstanceExpression.ExpressionType)
                     Emitter.EmitStoreVariable(Info, constrainedLocal)
                     Emitter.EmitLoadVariableLocation(Info, constrainedLocal)
                 End If
             End If
 
         End If
 
         Dim copyBacksA As Generic.List(Of Mono.Cecil.Cil.VariableDefinition) = Nothing
         Dim copyBacksB As Generic.List(Of Expression) = Nothing
 
         If Arguments IsNot Nothing Then
             Dim methodParameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
             methodParameters = Helper.GetParameters(Info.Compiler, Method)
 
             For i As Integer = 0 To methodParameters.Count - 1
                 Dim arg As Argument
                 Dim exp As Expression
                 Dim local As Mono.Cecil.Cil.VariableDefinition
                 Dim propAccess As PropertyAccessClassification
 
                 If CecilHelper.IsByRef(methodParameters(i).ParameterType) = False Then Continue For
 
                 arg = Arguments.Arguments(i)
                 exp = arg.Expression
 
                 If exp Is Nothing Then Continue For
 
                 If exp.Classification Is Nothing Then Continue For
                 If exp.Classification.IsPropertyAccessClassification = False Then Continue For
 
                 propAccess = exp.Classification.AsPropertyAccess
 
                 If copyBacksA Is Nothing Then
                     copyBacksA = New Generic.List(Of Mono.Cecil.Cil.VariableDefinition)
                     copyBacksB = New Generic.List(Of Expression)
                 End If
                 local = Emitter.DeclareLocal(Info, CecilHelper.GetElementType(methodParameters(i).ParameterType))
                 copyBacksA.Add(local)
                 If CecilHelper.FindDefinition(propAccess.Property).SetMethod Is Nothing Then
                     copyBacksB.Add(Nothing)
                 Else
                     copyBacksB.Add(exp)
                 End If
 
                 result = arg.GenerateCode(Info, methodParameters(i)) AndAlso result
                 Emitter.EmitStoreVariable(Info, local)
                 arg.Expression = New LoadLocalExpression(arg, local)
             Next
 
             result = Arguments.GenerateCode(Info, methodParameters) AndAlso result
         End If
 
         If needsConstrained Then
             Emitter.EmitConstrainedCallVirt(Info, Method, InstanceExpression.ExpressionType)
         ElseIf InstanceExpression IsNot Nothing AndAlso (TypeOf InstanceExpression Is MyClassExpression OrElse TypeOf InstanceExpression Is MyBaseExpression) Then
             Emitter.EmitCall(Info, Method)
         Else
             Emitter.EmitCallOrCallVirt(Info, Method)
         End If
 
         If copyBacksA IsNot Nothing Then
             For i As Integer = 0 To copyBacksA.Count - 1
                 Dim local As Mono.Cecil.Cil.VariableDefinition = copyBacksA(i)
                 Dim exp As Expression = copyBacksB(i)
 
                 If exp Is Nothing Then Continue For
 
                 result = exp.GenerateCode(Info.Clone(Info.Context, New LoadLocalExpression(exp, local))) AndAlso result
             Next
         End If
 
         If constrainedLocal IsNot Nothing Then
             Emitter.FreeLocal(constrainedLocal)
         End If
 
         If Info.DesiredType IsNot Nothing AndAlso CecilHelper.IsByRef(Info.DesiredType) Then
             Dim tmp As Mono.Cecil.Cil.VariableDefinition
             tmp = Emitter.DeclareLocal(Info, CecilHelper.GetElementType(Info.DesiredType))
             Emitter.EmitStoreVariable(Info, tmp)
             Emitter.EmitLoadVariableLocation(Info, tmp)
             Emitter.FreeLocal(tmp)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1241" endline="1250"><![CDATA[
 
     Shared Function GetInvokeMethod(ByVal Compiler As Compiler, ByVal DelegateType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Helper.Assert(IsDelegate(Compiler, DelegateType), "The type '" & DelegateType.FullName & "' is not a delegate.")
         Dim results As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Compiler.TypeManager.GetCache(DelegateType).Lookup(DelegateDeclaration.STR_Invoke, MemberVisibility.Public).Members
         If results IsNot Nothing AndAlso results.Count = 1 AndAlso TypeOf results(0) Is Mono.Cecil.MethodReference Then
             Return DirectCast(results(0), Mono.Cecil.MethodReference)
         Else
             Throw New NotImplementedException
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1251" endline="1254"><![CDATA[
 
     Shared Function IsDelegate(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.IsSubclassOf(Compiler.TypeCache.System_MulticastDelegate, Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1255" endline="1262"><![CDATA[
 
     Public Shared Function CompareParameterTypes(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         For i As Integer = 0 To a.Count - 1
             If Helper.CompareType(a(i).ParameterType, b(i).ParameterType) = False Then Return False
         Next
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1263" endline="1269"><![CDATA[
 
     Private Shared Sub AddPropertyUnlessSignatureMatches(ByVal properties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference), ByVal prop As Mono.Cecil.PropertyReference)
         For i As Integer = 0 To properties.Count - 1
             If Helper.CompareParameterTypes(prop.Parameters, properties(i).Parameters) = True Then Return
         Next
         properties.Add(prop)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1270" endline="1339"><![CDATA[
 
 
     ''' <summary>
     ''' Returns true if the type has a default property
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function HasDefaultProperty(ByVal Context As BaseObject, ByVal tp As Mono.Cecil.TypeReference, ByRef properties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim defaultName As String = Nothing
 
         If tp Is Nothing Then Return False
 
         If properties Is Nothing Then properties = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)
         members = Compiler.TypeManager.GetCache(tp).GetAllMembers()
 
         For i As Integer = 0 To members.Count - 1
             Dim p As Mono.Cecil.PropertyReference = TryCast(members(i), Mono.Cecil.PropertyReference)
             Dim pD As PropertyDeclaration
 
             If p Is Nothing Then Continue For
 
             If p.Annotations.Contains(Compiler) Then
                 pD = DirectCast(p.Annotations(Compiler), PropertyDeclaration)
                 If pD.Modifiers.Is(ModifierMasks.Default) Then
                     AddPropertyUnlessSignatureMatches(properties, p)
                 End If
                 Continue For
             End If
 
             Dim p2 As Mono.Cecil.PropertyReference = CecilHelper.FindDefinition(p)
             If p2.Annotations.Contains(Compiler) Then
                 pD = DirectCast(p2.Annotations(Compiler), PropertyDeclaration)
                 If pD.Modifiers.Is(ModifierMasks.Default) Then
                     AddPropertyUnlessSignatureMatches(properties, p)
                 End If
                 Continue For
             End If
 
             'OPTIMIZATION
             Dim pDef As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(p.DeclaringType)
             Dim defaultAttribute As Mono.Cecil.CustomAttribute = Helper.GetDefaultMemberAttribute(Compiler, pDef)
             If defaultAttribute Is Nothing Then Continue For
             If defaultAttribute.ConstructorArguments.Count <> 1 Then Continue For
             If TypeOf defaultAttribute.ConstructorArguments(0).Value Is String = False Then Continue For
             defaultName = DirectCast(defaultAttribute.ConstructorArguments(0).Value, String)
 
             If Helper.CompareNameOrdinal(p.Name, defaultName) Then
                 AddPropertyUnlessSignatureMatches(properties, p)
             End If
         Next
 
         If Helper.CompareType(Compiler.TypeCache.System_Object, tp) = False Then
             If CecilHelper.IsInterface(tp) Then
                 Dim interfaces As Mono.Collections.Generic.Collection(Of TypeReference) = CecilHelper.GetInterfaces(tp, False)
                 Dim result As Boolean
                 If interfaces IsNot Nothing Then
                     For i As Integer = 0 To interfaces.Count - 1
                         result = HasDefaultProperty(Context, interfaces(i), properties) OrElse result
                     Next
                 End If
                 Return properties.Count > 0
             Else
                 Return HasDefaultProperty(Context, CecilHelper.GetBaseType(tp), properties)
             End If
         End If
 
         Return properties.Count > 0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1340" endline="1353"><![CDATA[
 
     Shared Function GetDefaultMemberAttribute(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.CustomAttribute
         Dim attribs As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim attrib As Mono.Cecil.CustomAttribute = Nothing
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
 
         attribs = CecilHelper.GetCustomAttributes(tD, Compiler.TypeCache.System_Reflection_DefaultMemberAttribute)
 
         If attribs IsNot Nothing AndAlso attribs.Count = 1 Then
             attrib = attribs(0)
         End If
 
         Return attrib
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1354" endline="1374"><![CDATA[
 
     Shared Function IsShadows(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean = True
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).IsHideBySig = False
             Case MemberTypes.Property
                 Return CBool(Helper.GetPropertyAttributes(DirectCast(Member, Mono.Cecil.PropertyReference)) And Mono.Cecil.MethodAttributes.HideBySig) = False
             Case MemberTypes.Field
                 Return True
             Case MemberTypes.TypeInfo
                 Return True
             Case MemberTypes.NestedType
                 Return True
             Case MemberTypes.Event
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference)).AddMethod.IsHideBySig = False
             Case Else
                 Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         End Select
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1375" endline="1396"><![CDATA[
 
     Shared Function IsShared(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean = True
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).IsStatic
             Case MemberTypes.Property
                 Dim pInfo As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
                 Return CBool(Helper.GetPropertyAttributes(pInfo) And Mono.Cecil.MethodAttributes.Static)
             Case MemberTypes.Field
                 Dim fInfo As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.FieldReference))
                 Return fInfo.IsStatic
             Case MemberTypes.TypeInfo
                 Return False
             Case MemberTypes.NestedType
                 Return False
             Case MemberTypes.Event
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference)).AddMethod.IsStatic
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1397" endline="1407"><![CDATA[
 
     Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference = Nothing
 
         If Params Is Nothing Then Return result
         ReDim result(Params.Count - 1)
         For i As Integer = 0 To Params.Count - 1
             result(i) = Params(i).ParameterType
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1408" endline="1414"><![CDATA[
 
     Shared Function GetReturnType(ByVal Member As MemberReference) As TypeReference
         Dim mr As MethodReference = TryCast(Member, MethodReference)
         If mr IsNot Nothing Then Return mr.ReturnType
 
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1415" endline="1428"><![CDATA[
 
     Shared Function GetTypes(ByVal Arguments As Generic.List(Of Argument)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference = New Mono.Cecil.TypeReference() {}
 
         If Arguments Is Nothing Then Return result
         ReDim result(Arguments.Count - 1)
         For i As Integer = 0 To Arguments.Count - 1
             Helper.Assert(Arguments(i) IsNot Nothing)
             If Arguments(i) IsNot Nothing AndAlso Arguments(i).Expression IsNot Nothing Then
                 result(i) = Arguments(i).Expression.ExpressionType
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1429" endline="1432"><![CDATA[
 
     Shared Function GetTypeDefinition(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Return CecilHelper.FindDefinition(Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1433" endline="1467"><![CDATA[
 
     Shared Function GetTypeOrTypeReference(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Type Is Nothing Then Return Nothing
         If TypeOf Type Is Mono.Cecil.GenericParameter Then Return Type
 
         If Compiler.Assembly.IsDefinedHere(Type) Then
             Return Type
         ElseIf TypeOf Type Is ByReferenceType Then
             Dim refType As ByReferenceType = DirectCast(Type, ByReferenceType)
             Dim elementType As Mono.Cecil.TypeReference
             elementType = GetTypeOrTypeReference(Compiler, refType.ElementType)
             If elementType Is refType.ElementType Then Return Type
             Return New ByReferenceType(elementType)
         ElseIf TypeOf Type Is Mono.Cecil.ArrayType Then
             Dim arrType As Mono.Cecil.ArrayType = DirectCast(Type, Mono.Cecil.ArrayType)
             Dim elementType As Mono.Cecil.TypeReference
             elementType = GetTypeOrTypeReference(Compiler, arrType.ElementType)
             If elementType Is arrType.ElementType Then Return Type
             Dim result As Mono.Cecil.ArrayType = New Mono.Cecil.ArrayType(elementType, arrType.Rank)
             For i As Integer = 0 To arrType.Rank - 1
                 result.Dimensions(i) = arrType.Dimensions(i)
             Next
             Return result
         ElseIf TypeOf Type Is Mono.Cecil.GenericInstanceType Then
             Dim git As Mono.Cecil.GenericInstanceType = DirectCast(Type, Mono.Cecil.GenericInstanceType)
             Dim elementType As Mono.Cecil.TypeReference = GetTypeOrTypeReference(Compiler, git.ElementType)
             Dim result As New Mono.Cecil.GenericInstanceType(elementType)
             For i As Integer = 0 To git.GenericArguments.Count - 1
                 result.GenericArguments.Add(GetTypeOrTypeReference(Compiler, git.GenericArguments(i)))
             Next
             Return result
         Else
             Return Compiler.AssemblyBuilderCecil.MainModule.Import(CecilHelper.FindDefinition(Type))
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1468" endline="1471"><![CDATA[
 
     Private Shared Function GetTypeReference(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Return GetTypeOrTypeReference(Compiler, Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1472" endline="1481"><![CDATA[
 
     Shared Sub ApplyTypeArguments(ByVal Context As BaseObject, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal TypeArguments As TypeArgumentList)
         If TypeArguments Is Nothing OrElse TypeArguments.Count = 0 Then Return
 
         For i As Integer = Members.Count - 1 To 0 Step -1
             Members(i) = ApplyTypeArguments(Context, Members(i), TypeArguments)
             If Members(i) Is Nothing Then Members.RemoveAt(i)
         Next
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1482" endline="1503"><![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference, ByVal TypeArguments As TypeArgumentList) As Mono.Cecil.MemberReference
         Dim result As Mono.Cecil.MemberReference
         Dim minfo As Mono.Cecil.MethodReference
 
         minfo = TryCast(Member, Mono.Cecil.MethodReference)
         If minfo IsNot Nothing Then
             Dim args As Mono.Collections.Generic.Collection(Of Mono.Cecil.TypeReference)
             args = CecilHelper.GetGenericArguments(minfo)
 
             If args.Count = TypeArguments.Count Then
                 result = TypeArguments.Compiler.TypeManager.MakeGenericMethod(TypeArguments.Parent, minfo, args, TypeArguments.ArgumentCollection)
             Else
                 result = Nothing
             End If
         Else
             result = Nothing
             Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1504" endline="1563"><![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenType As Mono.Cecil.TypeReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Nothing
 
         If OpenType Is Nothing Then Return Nothing
 
         Helper.Assert(TypeParameters IsNot Nothing AndAlso TypeArguments IsNot Nothing)
         Helper.Assert(TypeParameters.Count = TypeArguments.Count)
 
         If CecilHelper.IsGenericParameter(OpenType) Then
             For i As Integer = 0 To TypeParameters.Count - 1
                 If Helper.CompareName(TypeParameters(i).Name, OpenType.Name) Then
                     result = TypeArguments(i)
                     Exit For
                 End If
             Next
             Helper.Assert(result IsNot Nothing)
         ElseIf CecilHelper.IsGenericType(OpenType) Then
             Dim typeParams As Mono.Collections.Generic.Collection(Of TypeReference)
             Dim typeArgs As New Mono.Collections.Generic.Collection(Of TypeReference)(Nothing)
 
             typeParams = CecilHelper.GetGenericArguments(OpenType)
 
             For i As Integer = 0 To typeParams.Count - 1
                 For j As Integer = 0 To TypeParameters.Count - 1
                     If Helper.CompareName(typeParams(i).Name, TypeParameters(j).Name) Then
                         typeArgs.Add(TypeArguments(j))
                         Exit For
                     End If
                 Next
                 If typeArgs.Count - 1 < i Then typeArgs.Add(typeParams(i))
             Next
 
             Helper.Assert(typeArgs.Count = typeParams.Count AndAlso typeArgs.Count > 0)
 
             result = Parent.Compiler.TypeManager.MakeGenericType(Parent, OpenType, typeArgs)
         ElseIf CecilHelper.IsGenericTypeDefinition(OpenType) Then
             Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         ElseIf CecilHelper.ContainsGenericParameters(OpenType) Then
             If CecilHelper.IsArray(OpenType) Then
                 Dim elementType As Mono.Cecil.TypeReference
                 elementType = CecilHelper.GetElementType(OpenType)
                 elementType = ApplyTypeArguments(Parent, elementType, TypeParameters, TypeArguments)
                 result = New Mono.Cecil.ArrayType(elementType, CecilHelper.GetArrayRank(OpenType))
             ElseIf CecilHelper.IsByRef(OpenType) Then
                 Dim elementType As Mono.Cecil.TypeReference
                 elementType = CecilHelper.GetElementType(OpenType)
                 elementType = ApplyTypeArguments(Parent, elementType, TypeParameters, TypeArguments)
                 result = Parent.Compiler.TypeManager.MakeByRefType(Parent, elementType)
             Else
                 Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         Else
             result = OpenType
         End If
 
         Helper.Assert(result IsNot Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1564" endline="1583"><![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenParameter As Mono.Cecil.ParameterReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.ParameterReference
         Dim result As Mono.Cecil.ParameterReference
 
         Helper.Assert(TypeParameters IsNot Nothing AndAlso TypeArguments IsNot Nothing)
         Helper.Assert(TypeParameters.Count = TypeArguments.Count)
 
         Dim paramType As Mono.Cecil.TypeReference
         paramType = ApplyTypeArguments(Parent, OpenParameter.ParameterType, TypeParameters, TypeArguments)
 
         If paramType Is OpenParameter.ParameterType Then
             result = OpenParameter
         Else
             result = Parent.Compiler.TypeManager.MakeGenericParameter(Parent, OpenParameter, paramType)
         End If
 
         Helper.Assert(result IsNot Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1584" endline="1593"><![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenParameters As Mono.Collections.Generic.Collection(Of ParameterReference), ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.ParameterReference()
         Dim result(OpenParameters.Count - 1) As Mono.Cecil.ParameterReference
 
         For i As Integer = 0 To result.Length - 1
             result(i) = ApplyTypeArguments(Parent, OpenParameters(i), TypeParameters, TypeArguments)
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1594" endline="1617"><![CDATA[
 
     Shared Function GetConversionOperators(ByVal Compiler As Compiler, ByVal Names As String(), ByVal Type As Mono.Cecil.TypeReference, ByVal ReturnType As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim ops As Generic.List(Of Mono.Cecil.MethodReference)
 
         ops = GetOperators(Compiler, Names, Type)
 
         If ops Is Nothing Then
             ops = GetOperators(Compiler, Names, ReturnType)
         Else
             ops.AddRange(GetOperators(Compiler, Names, ReturnType))
         End If
 
         If ops IsNot Nothing Then
             For i As Integer = ops.Count - 1 To 0 Step -1
                 If CompareType(ops(i).ReturnType, ReturnType) = False Then
                     ops.RemoveAt(i)
                 ElseIf CompareType(ops(i).Parameters(0).ParameterType, Type) = False Then
                     ops.RemoveAt(i)
                 End If
             Next
         End If
 
         Return ops
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1618" endline="1621"><![CDATA[
 
     Shared Function GetWideningConversionOperators(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference, ByVal ReturnType As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Return GetConversionOperators(Compiler, New String() {"op_Implicit"}, Type, ReturnType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1622" endline="1625"><![CDATA[
 
     Shared Function GetNarrowingConversionOperators(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference, ByVal ReturnType As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Return GetConversionOperators(Compiler, New String() {"op_Explicit"}, Type, ReturnType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1626" endline="1650"><![CDATA[
 
     Shared Function GetOperators(ByVal Compiler As Compiler, ByVal Names() As String, ByVal Type As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim result As New Generic.List(Of Mono.Cecil.MethodReference)
 
         'Dim members() As MemberInfo
         Dim members As Generic.List(Of Mono.Cecil.MemberReference)
         members = Compiler.TypeManager.GetCache(Type).GetAllFlattenedMembers(MemberVisibility.All)
 
         For i As Integer = 0 To Names.Length - 1
             Dim testName As String = Names(i)
             For m As Integer = 0 To members.Count - 1
                 Dim member As MemberReference = members(m)
                 Dim mR As Mono.Cecil.MethodReference = TryCast(member, Mono.Cecil.MethodReference)
                 If mR IsNot Nothing Then
                     Dim mD As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(mR)
                     If mD.IsSpecialName AndAlso Helper.CompareName(mD.Name, testName) AndAlso mD.IsStatic Then
                         result.Add(mR)
                     End If
                 End If
             Next
             If result.Count > 0 Then Exit For
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1651" endline="1665"><![CDATA[
 
     Shared Function GetUnaryOperators(ByVal Compiler As Compiler, ByVal Op As UnaryOperators, ByVal Type As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim opNameAlternatives As String() = Nothing
 
         Select Case Op
             Case UnaryOperators.Add
                 opNameAlternatives = New String() {"op_UnaryPlus"}
             Case UnaryOperators.Minus
                 opNameAlternatives = New String() {"op_UnaryNegation"}
             Case UnaryOperators.Not
                 opNameAlternatives = New String() {"op_OnesComplement", "op_LogicalNot"}
         End Select
 
         Return GetOperators(Compiler, opNameAlternatives, Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1666" endline="1719"><![CDATA[
 
     Shared Function GetBinaryOperators(ByVal Compiler As Compiler, ByVal Op As BinaryOperators, ByVal Type As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim opNameAlternatives As String() = Nothing
 
         Select Case Op
             Case BinaryOperators.And
                 opNameAlternatives = New String() {"op_BitwiseAnd", "op_LogicalAnd"}
             Case BinaryOperators.Like
                 opNameAlternatives = New String() {"op_Like"}
             Case BinaryOperators.Mod
                 opNameAlternatives = New String() {"op_Modulus"}
             Case BinaryOperators.Or
                 opNameAlternatives = New String() {"op_BitwiseOr", "op_LogicalOr"}
             Case BinaryOperators.XOr
                 opNameAlternatives = New String() {"op_ExclusiveOr"}
             Case BinaryOperators.LT
                 opNameAlternatives = New String() {"op_LessThan"}
             Case BinaryOperators.GT
                 opNameAlternatives = New String() {"op_GreaterThan"}
             Case BinaryOperators.Equals
                 opNameAlternatives = New String() {"op_Equality"}
             Case BinaryOperators.NotEqual
                 opNameAlternatives = New String() {"op_Inequality"}
             Case BinaryOperators.LE
                 opNameAlternatives = New String() {"op_LessThanOrEqual"}
             Case BinaryOperators.GE
                 opNameAlternatives = New String() {"op_GreaterThanOrEqual"}
             Case BinaryOperators.Concat
                 opNameAlternatives = New String() {"op_Concatenate"}
             Case BinaryOperators.Mult
                 opNameAlternatives = New String() {"op_Multiply"}
             Case BinaryOperators.Add
                 opNameAlternatives = New String() {"op_Addition"}
             Case BinaryOperators.Minus
                 opNameAlternatives = New String() {"op_Subtraction"}
             Case BinaryOperators.Power
                 opNameAlternatives = New String() {"op_Exponent"}
             Case BinaryOperators.RealDivision
                 opNameAlternatives = New String() {"op_Division"}
             Case BinaryOperators.IntDivision
                 opNameAlternatives = New String() {"op_IntegerDivision"}
             Case BinaryOperators.ShiftLeft
                 'See
                 opNameAlternatives = New String() {"op_LeftShift", "op_SignedRightShift"}
             Case BinaryOperators.ShiftRight
                 opNameAlternatives = New String() {"op_RightShift", "op_UnsignedRightShift"}
             Case BinaryOperators.IsTrue
                 opNameAlternatives = New String() {"op_True"}
             Case BinaryOperators.IsFalse
                 opNameAlternatives = New String() {"op_False"}
         End Select
 
         Return GetOperators(Compiler, opNameAlternatives, Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1720" endline="1747"><![CDATA[
 
     ''' <summary>
     ''' Finds the parent namespace of the specified namespace.
     ''' "NS1.NS2" => "NS1"
     ''' "NS1" => ""
     ''' "" => Nothing
     ''' Nothing =>InternalException()
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetNamespaceParent(ByVal [Namespace] As String) As String
         If [Namespace] Is Nothing Then
             Throw New InternalException("")
         ElseIf [Namespace] = String.Empty Then
             Return Nothing
         Else
             Dim dotIdx As Integer
             dotIdx = [Namespace].LastIndexOf("."c)
             If dotIdx > 0 Then
                 Return [Namespace].Substring(0, dotIdx)
             ElseIf dotIdx = 0 Then
                 Throw New InternalException("A namespace starting with a dot??")
             Else
                 Return String.Empty
             End If
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1748" endline="1758"><![CDATA[
 
     Shared Function IsAccessibleExternal(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         If Compiler.Assembly.IsDefinedHere(Member) Then Return True
 
         If IsPublic(Member) Then Return True
         If IsProtectedFriend(Member) Then Return True
         If IsPrivate(Member) Then Return False
         If IsFriend(Member) Then Return False
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1759" endline="1831"><![CDATA[
 
     ''' <summary>
     ''' Checks if the called type is accessible from the caller type.
     ''' </summary>
     ''' <param name="CalledType"></param>
     ''' <param name="CallerType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsAccessible(ByVal Compiler As Compiler, ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         Dim calledTypeD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(CalledType)
         Dim callerTypeD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(CallerType)
 
         If Not Compiler.Assembly.IsDefinedHere(CalledType) Then
             'The types are not in the same assembly, they can only be accessible if the
             'called type is public and all its declaring types are public.
             Dim declType As Mono.Cecil.TypeDefinition = calledTypeD
             Do Until declType Is Nothing
                 If declType.IsPublic = False AndAlso declType.IsNestedPublic = False Then Return False
                 declType = CecilHelper.FindDefinition(declType.DeclaringType)
             Loop
             Do Until declType Is Nothing
                 If declType.IsPublic = False AndAlso declType.IsNestedPublic = False Then Return False
                 declType = CecilHelper.FindDefinition(declType.DeclaringType)
             Loop
             Return True
         End If
 
         'If it is the same type they are obviously accessible.
         If CompareType(CalledType, CallerType) Then Return True
 
         'Now both types are in the same assembly.
 
         'If the called type is not a nested type it is accessible.
         If CalledType.DeclaringType Is Nothing Then Return True
 
         'The caller can descend once into a private type, check if that is the case
         If calledTypeD.IsNestedPrivate Then
             'don't fail here, because could be the private nesting is further up the hierarchy
             If Helper.CompareType(CalledType.DeclaringType, CallerType) Then
                 Return True
             End If
         End If
 
         'Add all the surrounding types of the caller type to a list.
         Dim callerHierarchy As New Generic.List(Of Mono.Cecil.TypeReference)
         Dim tmp As Mono.Cecil.TypeReference = CallerType.DeclaringType
         Do Until tmp Is Nothing
             callerHierarchy.Add(tmp)
             tmp = tmp.DeclaringType
         Loop
         Do Until tmp Is Nothing
             callerHierarchy.Add(tmp)
             tmp = tmp.DeclaringType
         Loop
 
         Dim tmpCaller As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(CalledType.DeclaringType)
         Do Until tmpCaller Is Nothing
             If callerHierarchy.Contains(tmpCaller) Then
                 'The caller can descend once into a private type, check that here.
                 If calledTypeD.IsNestedPrivate Then Return Helper.CompareType(CalledType.DeclaringType, tmpCaller)
 
                 'We've reached a common surrounding type.
                 'No matter what accessibility level this type has 
                 'it is accessible.
                 Return True
             End If
             If tmpCaller.IsNestedPrivate Then
                 'There is a private type here...
                 Return False
             End If
             tmpCaller = CecilHelper.FindDefinition(tmpCaller.DeclaringType)
         Loop
         Do Until tmpCaller Is Nothing
             If callerHierarchy.Contains(tmpCaller) Then
                 'The caller can descend once into a private type, check that here.
                 If calledTypeD.IsNestedPrivate Then Return Helper.CompareType(CalledType.DeclaringType, tmpCaller)
 
                 'We've reached a common surrounding type.
                 'No matter what accessibility level this type has 
                 'it is accessible.
                 Return True
             End If
             If tmpCaller.IsNestedPrivate Then
                 'There is a private type here...
                 Return False
             End If
             tmpCaller = CecilHelper.FindDefinition(tmpCaller.DeclaringType)
         Loop
 
         'If the called type is a private nested type and the above checks failed, it is inaccessible
         If calledTypeD.IsNestedPrivate Then Return Helper.CompareType(CalledType.DeclaringType, CallerType)
 
         'There is no common surrounding type, and the access level of all 
         'surrounding types of the called types are non-private, so the type
         'is accessible.
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1832" endline="1890"><![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal CalledMethodAccessability As Mono.Cecil.MethodAttributes, ByVal CalledType As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
 
         Helper.Assert(Compiler IsNot Nothing)
         Helper.Assert(CalledType IsNot Nothing)
 
         'Checks it the accessed method / type is accessible from the current compiling code
         '(for attributes that is not contained within a type)
 
         Dim testNested As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(CalledType)
         Dim compiledType As Boolean = Compiler.Assembly.IsDefinedHere(CalledType)
         Dim mostDeclaredType As Mono.Cecil.TypeDefinition = Nothing
 
         Do Until testNested Is Nothing
             mostDeclaredType = testNested
             'If it is a nested private type, it is not accessible.
             If testNested.IsNestedPrivate Then Return False
             'If it is not a nested public type in an external assembly, it is not accessible.
             If compiledType = False AndAlso testNested.IsNestedPublic = False AndAlso testNested.IsNested Then Return False
             testNested = CecilHelper.FindDefinition(testNested.DeclaringType)
         Loop
         Do Until testNested Is Nothing
             mostDeclaredType = testNested
             'If it is a nested private type, it is not accessible.
             If testNested.IsNestedPrivate Then Return False
             'If it is not a nested public type in an external assembly, it is not accessible.
             If compiledType = False AndAlso testNested.IsNestedPublic = False AndAlso testNested.IsNested Then Return False
             testNested = CecilHelper.FindDefinition(testNested.DeclaringType)
         Loop
 
         'If the most external type is not public then it is not accessible.
         If compiledType = False AndAlso mostDeclaredType.IsPublic = False Then Return False
 
         'The type is at least accessible now, check the method.
 
         Dim ac As Mono.Cecil.MethodAttributes = (CalledMethodAccessability And Mono.Cecil.MethodAttributes.MemberAccessMask)
         Dim isPrivate As Boolean = ac = Mono.Cecil.MethodAttributes.Private
         Dim isFriend As Boolean = ac = Mono.Cecil.MethodAttributes.Assembly OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isProtected As Boolean = ac = Mono.Cecil.MethodAttributes.Family OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isPublic As Boolean = ac = Mono.Cecil.MethodAttributes.Public
 
         'If the member is private, the member is not accessible
         '(to be accessible the types must be equal or the caller type must
         'be a nested type of the called type, cases already covered).
         If isPrivate Then Return False
 
         If isFriend AndAlso isProtected Then
             'Friend and Protected
             'If it is an external type it is not accessible.
             Return compiledType
         ElseIf isFriend Then
             'Friend, but not Protected
             'If it is an external type it is not accessible.
             Return compiledType
         ElseIf isProtected Then
             'Protected, but not Friend
             'It is not accessible.
             Return False
         ElseIf isPublic Then
             Return True
         End If
 
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location) '("No accessibility??")
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1891" endline="1942"><![CDATA[
 
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal CalledMethodAccessability As Mono.Cecil.MethodAttributes, ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         'If both types are equal everything is accessible.
         If CompareType(CalledType, CallerType) Then Return True
 
         'If the callertype is a nested class of the called type, then everything is accessible as well.
         If IsNested(CalledType, CallerType) Then Return True
 
         'If the called type is not accessible from the caller, the member cannot be accessible either.
         If IsAccessible(Context.Compiler, CalledType, CallerType) = False Then Return False
 
         Dim ac As Mono.Cecil.MethodAttributes = (CalledMethodAccessability And Mono.Cecil.MethodAttributes.MemberAccessMask)
         Dim isPrivate As Boolean = ac = Mono.Cecil.MethodAttributes.Private
         Dim isFriend As Boolean = ac = Mono.Cecil.MethodAttributes.Assembly OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isProtected As Boolean = ac = Mono.Cecil.MethodAttributes.Family OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isPublic As Boolean = ac = Mono.Cecil.MethodAttributes.Public
 
         'Public members are always accessible!
         If isPublic Then Return True
 
         'If the member is private, the member is not accessible
         '(to be accessible the types must be equal or the caller type must
         'be a nested type of the called type, cases already covered).
         'Catch
         If isPrivate Then Return Helper.IsEnum(Context.Compiler, CalledType)
 
         If isFriend AndAlso isProtected Then
             'Friend and Protected
             'Both types must be in the same assembly or CallerType must inherit from CalledType.
             Return Context.Compiler.Assembly.IsDefinedHere(CalledType) OrElse (Helper.IsSubclassOf(CalledType, CallerType))
         ElseIf isFriend Then
             'Friend, but not Protected
             'Both types must be in the same assembly
             Return Context.Compiler.Assembly.IsDefinedHere(CalledType)
         ElseIf isProtected Then
             'Protected, but not Friend
             'CallerType must inherit from CalledType.
             Return Helper.IsSubclassOf(CalledType, CallerType)
         End If
 
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location) '("No accessibility??")
 
         'private 	    = 1	= 0001
         'famandassembly = 2 = 0010
         'Assembly       = 3 = 0011
         'family         = 4 = 0100
         'famorassembly  = 5 = 0101
         'public 	    = 6	= 0110
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1943" endline="1959"><![CDATA[
 
     ''' <summary>
     ''' Returns true if CallerType is a nested class of CalledType.
     ''' Returns false if both types are equal.
     ''' </summary>
     ''' <param name="CalledType"></param>
     ''' <param name="CallerType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsNested(ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         Dim tmp As Mono.Cecil.TypeReference = CecilHelper.FindDefinition(CallerType).DeclaringType
         Do Until tmp Is Nothing
             If CompareType(CalledType, tmp) Then Return True
             tmp = CecilHelper.FindDefinition(tmp).DeclaringType
         Loop
         Do Until tmp Is Nothing
             If CompareType(CalledType, tmp) Then Return True
             tmp = CecilHelper.FindDefinition(tmp).DeclaringType
         Loop
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1960" endline="1964"><![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal FieldAccessability As Mono.Cecil.FieldAttributes, ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         'The fieldattributes for accessibility are the same as methodattributes.
         Return IsAccessible(Context, CType(FieldAccessability, Mono.Cecil.MethodAttributes), CalledType, CallerType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1965" endline="1969"><![CDATA[
 
     Shared Function CreateGenericTypename(ByVal Typename As Identifier, ByVal TypeArguments As TypeParameters) As Identifier
         If TypeArguments Is Nothing OrElse TypeArguments.Parameters.Count = 0 Then Return Typename
         Return New Identifier(Typename.Parent, CreateGenericTypename(Typename.Identifier, TypeArguments.Parameters.Count), Typename.Location, TypeCharacters.Characters.None)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1970" endline="1977"><![CDATA[
 
     Shared Function CreateGenericTypename(ByVal Typename As String, ByVal TypeArgumentCount As Integer) As String
         If TypeArgumentCount = 0 Then
             Return Typename
         Else
             Return String.Concat(Typename, "`", TypeArgumentCount.ToString)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1978" endline="1985"><![CDATA[
 
     Shared Function CreateArray(Of T)(ByVal Value As T, ByVal Length As Integer) As T()
         Dim result(Length - 1) As T
         For i As Integer = 0 To Length - 1
             result(i) = Value
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1986" endline="1990"><![CDATA[
 
     Shared Function GetDelegateArguments(ByVal Compiler As Compiler, ByVal delegateType As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim invoke As Mono.Cecil.MethodReference = GetInvokeMethod(Compiler, delegateType)
         Return GetParameters(Compiler, invoke)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1991" endline="2020"><![CDATA[
 
     ''' <summary>
     ''' Finds the member with the exact same signature.
     ''' </summary>
     ''' <param name="grp"></param>
     ''' <param name="params"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function ResolveGroupExact(ByVal Context As BaseObject, ByVal grp As Generic.List(Of Mono.Cecil.MemberReference), ByVal params() As Mono.Cecil.TypeReference) As Mono.Cecil.MemberReference
         Dim Compiler As Compiler = Context.Compiler
 
         For i As Integer = 0 To grp.Count - 1
             Dim member As Mono.Cecil.MemberReference = grp(i)
             Dim paramtypes As Mono.Cecil.TypeReference() = Helper.GetParameterTypes(Context, member)
             If Helper.CompareTypes(paramtypes, params) Then Return member
 
             If paramtypes.Length <> params.Length Then Continue For
 
             Dim found As Boolean = True
             For j As Integer = 0 To paramtypes.Length - 1
                 If Helper.IsSubclassOf(paramtypes(j), params(j)) = False Then
                     found = False
                     Exit For
                 End If
             Next
             If found Then Return member
         Next
 
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2021" endline="2028"><![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Cecil.TypeReference(), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Length - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(t, TypeToFind) Then Return True
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2029" endline="2036"><![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypeToSearch As Mono.Cecil.TypeReference, ByVal TypesToFind As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         For i As Integer = 0 To TypesToFind.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToFind(i)
             If Helper.CompareType(t, TypeToSearch) OrElse Helper.IsSubclassOf(TypeToSearch, t) Then Return True
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2037" endline="2044"><![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(TypeToFind, t) Then Return True
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2045" endline="2049"><![CDATA[
 
 
     Shared Function IsNothing(Of T)(ByVal Value As T) As Boolean
         Return Value Is Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2050" endline="2055"><![CDATA[
 
     <Diagnostics.Conditional("EXTENDEDDEBUG")> Sub AddCheck(ByVal Message As String)
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Skipped check
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2056" endline="2063"><![CDATA[
 
     Shared Function DefineCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.Define AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071"><![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2072" endline="2077"><![CDATA[
 
     Shared Sub InitializeCollection(ByVal Collection As IEnumerable, ByVal Parent As BaseObject)
         For Each obj As BaseObject In Collection
             obj.Initialize(Parent)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2078" endline="2086"><![CDATA[
 
     Shared Function ResolveTypeReferencesCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             result = obj.ResolveTypeReferences AndAlso result
             'vbnc.Helper.Assert(result = (obj.Compiler.Report.Errors = 0))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2087" endline="2094"><![CDATA[
 
     Shared Function ResolveTypeReferences(ByVal ParamArray Collection As ParsedObject()) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             If obj IsNot Nothing Then result = obj.ResolveTypeReferences AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2095" endline="2102"><![CDATA[
 
     Shared Function ResolveStatementCollection(ByVal Collection As IEnumerable, ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As Statement In Collection
             result = obj.ResolveStatement(Info) AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2103" endline="2110"><![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IEnumerable, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.GenerateCode(Info) AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2111" endline="2119"><![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IList, ByVal Info As EmitInfo, ByVal Types As Mono.Cecil.TypeReference()) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Collection.Count = Types.Length)
         For i As Integer = 0 To Collection.Count - 1
             result = DirectCast(Collection(i), IBaseObject).GenerateCode(Info.Clone(Info.Context, Info.IsRHS, Info.IsExplicitConversion, Types(i))) AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2120" endline="2129"><![CDATA[
 
     Shared Function CloneExpressionArray(ByVal Expressions() As Expression, ByVal NewParent As ParsedObject) As Expression()
         Dim result(Expressions.GetUpperBound(0)) As Expression
         For i As Integer = 0 To result.GetUpperBound(0)
             If Expressions(i) IsNot Nothing Then
                 result(i) = Expressions(i).Clone(NewParent)
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2130" endline="2134"><![CDATA[
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2135" endline="2150"><![CDATA[
     End Property
 
     ''' <summary>
     ''' If there is only one shared compiler, that one is returned, otherwise nothing is returned.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared ReadOnly Property SharedCompiler() As Compiler
         Get
             If m_SharedCompilers.Count = 1 Then
                 Return m_SharedCompilers(0)
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2151" endline="2158"><![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         If m_SharedCompilers.Contains(Compiler) = False Then
             m_SharedCompilers.Add(Compiler)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2159" endline="2168"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     <Diagnostics.Conditional("DEBUG")> _
     Shared Sub Assert(ByVal Condition As Boolean, ByVal Message As String)
         If Condition = False Then
             Diagnostics.Debug.WriteLine(Message)
             If SharedCompiler IsNot Nothing Then SharedCompiler.Report.WriteLine(Report.ReportLevels.Debug, Message)
         End If
         Assert(Condition)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2169" endline="2173"><![CDATA[
 
     <Diagnostics.Conditional("DEBUG")> _
     <Diagnostics.DebuggerHidden()> Shared Sub Assert(ByVal Condition As Boolean)
         If Condition = False Then Helper.Stop()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2174" endline="2179"><![CDATA[
 
     <Diagnostics.Conditional("DEBUG")> _
     <Diagnostics.DebuggerHidden()> Shared Sub AssertNotNothing(ByVal Value As Object)
         If Value Is Nothing Then Helper.Stop()
         If TypeOf Value Is IEnumerable Then AssertNotNothing(DirectCast(Value, IEnumerable))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2180" endline="2191"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     <Diagnostics.Conditional("DEBUG")> _
     Shared Sub AssertNotNothing(ByVal Value As IEnumerable)
         If Value Is Nothing Then
             Helper.Stop()
         Else
             For Each obj As Object In Value
                 If obj Is Nothing Then Helper.Stop()
             Next
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2192" endline="2197"><![CDATA[
 
     Shared Sub AssertType(Of T)(ByVal Collection As IEnumerable)
         For Each v As Object In Collection
             Assert(TypeOf v Is T)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2198" endline="2205"><![CDATA[
 
 
     <Diagnostics.DebuggerHidden()> Shared Function AddError(ByVal Compiler As Compiler, ByVal Location As Span, Optional ByVal Message As String = Nothing) As Boolean
         If Message Is Nothing Then
             Message = "<no message written yet>"
         End If
         Return Compiler.Report.ShowMessage(Messages.VBNC99999, Location, Message)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2206" endline="2212"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> Shared Function AddError(ByVal Context As BaseObject, Optional ByVal Message As String = Nothing) As Boolean
         If Message Is Nothing Then
             Message = "<no message written yet>"
         End If
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC99999, Context.Location, Message)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2213" endline="2224"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> Shared Sub AddWarning(Optional ByVal Message As String = "(No message provided)")
         Dim msg As String
         msg = "A warning message should have been shown
         Diagnostics.Debug.WriteLine(msg)
         Console.WriteLine(msg)
         If IsDebugging() Then
             'Helper.Stop()
         Else
             'Throw New NotImplementedException(msg)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2225" endline="2228"><![CDATA[
 
     Shared Function IsBootstrapping() As Boolean
         Return Reflection.Assembly.GetExecutingAssembly.Location.Contains("SelfCompile.exe")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2229" endline="2237"><![CDATA[
 
     Shared Function IsDebugging() As Boolean
         'Return False
         If Diagnostics.Debugger.IsAttached = False Then Return False
         If Reflection.Assembly.GetEntryAssembly Is Nothing Then Return False
         If Reflection.Assembly.GetEntryAssembly.FullName.Contains("rt") Then Return False
         If AppDomain.CurrentDomain.FriendlyName.Contains("rt") Then Return False
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2238" endline="2243"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Shared Sub ErrorRecoveryNotImplemented(ByVal Location As Span)
         Console.WriteLine("{0}
         Console.WriteLine(New System.Diagnostics.StackTrace().ToString())
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2244" endline="2247"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> Private Shared Sub IndirectedStop()
         Stop
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2248" endline="2261"><![CDATA[
 
     Class StopException
         Inherits Exception
 
         Sub New(ByVal Message As String)
             MyBase.New(Message)
         End Sub
     End Class
 
     <Diagnostics.DebuggerHidden()> Shared Sub StopIfDebugging(Optional ByVal Condition As Boolean = True)
         If Condition AndAlso IsDebugging() Then
             IndirectedStop()
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2262" endline="2269"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> Shared Sub [Stop](Optional ByVal Message As String = "")
         If IsDebugging() Then
             IndirectedStop()
         Else
             Throw New InternalException(Message)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2270" endline="2308"><![CDATA[
 
     ''' <summary>
     ''' This function takes a string as an argument and split it on the space character,
     ''' with the " as acceptable character.
     ''' </summary>
     Shared Function ParseLine(ByVal strLine As String) As String()
         Dim strs As New ArrayList
         Dim bInQuote As Boolean
         Dim iStart As Integer
         Dim builder As New System.Text.StringBuilder
 
         For i As Integer = 0 To strLine.Length - 1
             If strLine.Chars(i) = "\"c AndAlso i < strLine.Length - 1 AndAlso strLine.Chars(i + 1) = """"c Then
                 builder.Append(""""c)
                 i += 1
             ElseIf strLine.Chars(i) = """"c Then
                 If strLine.Length - 1 >= i + 1 AndAlso strLine.Chars(i + 1) = """"c Then
                     builder.Append(""""c)
                 Else
                     bInQuote = Not bInQuote
                 End If
             ElseIf bInQuote = False AndAlso strLine.Chars(i) = " "c Then
                 If builder.ToString.Trim() <> "" Then strs.Add(builder.ToString)
                 builder.Length = 0
                 iStart = i + 1
             Else
                 builder.Append(strLine.Chars(i))
             End If
         Next
         If builder.Length > 0 Then strs.Add(builder.ToString)
 
         'Add the strings to the return value
         Dim stt(strs.Count - 1) As String
         For i As Integer = 0 To strs.Count - 1
             stt(i) = DirectCast(strs(i), String)
         Next
 
         Return stt
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2309" endline="2361"><![CDATA[
 
     ''' <summary>
     ''' Get the type attribute from the scope
     ''' </summary>
     ''' <param name="Modifiers"></param>
     ''' <param name="isNested"></param>
     ''' <returns></returns>
     ''' <remarks>
     ''' Scope
     ''' Private = private
     ''' Protected = family
     ''' Protected Friend = famorassem
     ''' Friend = assembly
     ''' Public = public
     ''' </remarks>
     Shared Function getTypeAttributeScopeFromScope(ByVal Modifiers As Modifiers, ByVal isNested As Boolean) As Mono.Cecil.TypeAttributes
         If Not isNested Then
             'If vbnc.Modifiers.IsNothing(Modifiers) = False Then
             If Modifiers.Is(ModifierMasks.Public) Then
                 Return Mono.Cecil.TypeAttributes.Public
             Else
                 Return Mono.Cecil.TypeAttributes.NotPublic
             End If
             'Else
             '  Return TypeAttributes.NotPublic
             'End If
         Else
             'If vbnc.Modifiers.IsNothing(Modifiers) = False Then
             If Modifiers.Is(ModifierMasks.Public) Then
                 Return Mono.Cecil.TypeAttributes.NestedPublic
             ElseIf Modifiers.Is(ModifierMasks.Friend) Then
                 If Modifiers.Is(ModifierMasks.Protected) Then
                     Return Mono.Cecil.TypeAttributes.NestedFamORAssem
                     '0Return Reflection.TypeAttributes.NotPublic
                     'Return Reflection.TypeAttributes.VisibilityMask
                 Else
                     Return Mono.Cecil.TypeAttributes.NestedAssembly
                     'Return Reflection.TypeAttributes.NotPublic
                 End If
             ElseIf Modifiers.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.TypeAttributes.NestedFamily
                 'Return Reflection.TypeAttributes.NotPublic
             ElseIf Modifiers.Is(ModifierMasks.Private) Then
                 Return Mono.Cecil.TypeAttributes.NestedPrivate
             Else
                 'Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Default scope set to public...")
                 Return Mono.Cecil.TypeAttributes.NestedPublic
             End If
             ' Else
             'Return Reflection.TypeAttributes.NestedPublic
             'End If
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2362" endline="2365"><![CDATA[
 
     Shared Function DecToDbl(ByVal str As String) As Double
         Return Double.Parse(str, USCulture)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2366" endline="2370"><![CDATA[
 
     Shared ReadOnly Property USCulture() As Globalization.CultureInfo
         Get
             Return Globalization.CultureInfo.GetCultureInfo("en-US")
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2371" endline="2375"><![CDATA[
     End Property
 
     Shared Function DecToInt(ByVal str As String) As Decimal
         Return Decimal.Parse(str)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2376" endline="2422"><![CDATA[
 
     'TODO
     Shared Function HexToInt(ByVal str As String) As ULong
         Dim i, n As Integer
         Dim l As Integer = str.Length
         HexToInt = 0
         For i = l To 1 Step -1
             Select Case str.Chars(i - 1)
                 Case "0"c
                     n = 0
                 Case "1"c
                     n = 1
                 Case "2"c
                     n = 2
                 Case "3"c
                     n = 3
                 Case "4"c
                     n = 4
                 Case "5"c
                     n = 5
                 Case "6"c
                     n = 6
                 Case "7"c
                     n = 7
                 Case "8"c
                     n = 8
                 Case "9"c
                     n = 9
                 Case "a"c, "A"c
                     n = 10
                 Case "b"c, "B"c
                     n = 11
                 Case "c"c, "C"c
                     n = 12
                 Case "d"c, "D"c
                     n = 13
                 Case "e"c, "E"c
                     n = 14
                 Case "f"c, "F"c
                     n = 15
                 Case Else
                     Throw New ArgumentOutOfRangeException("str", str, "Invalid hex number
             End Select
 
             HexToInt += CULng(n * (16 ^ (l - i)))
         Next
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2423" endline="2426"><![CDATA[
 
     Shared Function IntToHex(ByVal Int As ULong) As String
         Return Microsoft.VisualBasic.Hex(Int)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2427" endline="2439"><![CDATA[
 
     Shared Function IntToBin(ByVal Int As ULong) As String
         If Int = 0 Then Return "0"
         IntToBin = ""
         Do Until Int = 0
             If CBool(Int And 1UL) Then
                 IntToBin = "1" & IntToBin
             Else
                 IntToBin = "0" & IntToBin
             End If
             Int >>= 1
         Loop
         Do Until Int = 0
             If CBool(Int And 1UL) Then
                 IntToBin = "1" & IntToBin
             Else
                 IntToBin = "0" & IntToBin
             End If
             Int >>= 1
         Loop
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2440" endline="2443"><![CDATA[
 
     Shared Function IntToOct(ByVal Int As ULong) As String
         Return Microsoft.VisualBasic.Oct(Int)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2444" endline="2473"><![CDATA[
 
     'TODO
     Shared Function OctToInt(ByVal str As String) As ULong
         Dim i, n As Integer
         Dim l As Integer = str.Length
         OctToInt = 0
         For i = l To 1 Step -1
             Select Case str.Chars(i - 1)
                 Case "0"c
                     n = 0
                 Case "1"c
                     n = 1
                 Case "2"c
                     n = 2
                 Case "3"c
                     n = 3
                 Case "4"c
                     n = 4
                 Case "5"c
                     n = 5
                 Case "6"c
                     n = 6
                 Case "7"c
                     n = 7
                 Case Else
                     Throw New ArgumentOutOfRangeException("str", str, "Invalid octal number
             End Select
             OctToInt += CULng(n * (8 ^ (l - i)))
         Next
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2474" endline="2484"><![CDATA[
 
     ''' <summary>
     ''' Returns a sequence number, incremented in 1 on every call
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetSequenceNumber() As Integer
         Static number As Integer
         number += 1
         Return number
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2485" endline="2505"><![CDATA[
 
     ''' <summary>
     ''' Converts the value into how it would look in a source file. 
     ''' I.E
     ''' </summary>
     ''' <param name="Value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function ValueToCodeConstant(ByVal Value As Object) As String
         If TypeOf Value Is String Then
             Return """" & Value.ToString.Replace("""", """""") & """"
         ElseIf TypeOf Value Is Char Then
             Return """" & Value.ToString.Replace("""", """""") & """c"
         ElseIf TypeOf Value Is Date Then
             Return "#" & Value.ToString & "#"
         ElseIf Value Is Nothing Then
             Return KS.Nothing.ToString
         Else
             Return Value.ToString
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2506" endline="2515"><![CDATA[
 
     ''' <summary>
     ''' If the argument is a typedescriptor, looks up the 
     ''' </summary>
     ''' <param name="Type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetTypeOrTypeBuilder(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Return GetTypeOrTypeReference(Compiler, Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2516" endline="2537"><![CDATA[
 
     Shared Function GetMethodOrMethodReference(ByVal Compiler As Compiler, ByVal Method As Mono.Cecil.MethodReference) As Mono.Cecil.MethodReference
         Helper.Assert(Method IsNot Nothing)
         Helper.Assert(Method.DeclaringType IsNot Nothing)
 
         If Method.Annotations.Contains("MemberInReflection") Then
             Return GetMethodOrMethodReference(Compiler, DirectCast(Method.Annotations("MemberInReflection"), Mono.Cecil.MethodReference))
         End If
 
         Dim upper As Mono.Cecil.TypeReference
         upper = Method.DeclaringType
         While upper.DeclaringType IsNot Nothing
             upper = upper.DeclaringType
         End While
         While upper.DeclaringType IsNot Nothing
             upper = upper.DeclaringType
         End While
         Helper.Assert(upper.Module IsNot Nothing)
         Helper.Assert(upper.Module.Assembly IsNot Nothing)
         If Compiler.AssemblyBuilderCecil Is upper.Module.Assembly Then
             Return Method
         Else
             Return CecilHelper.MakeEmittable(Method)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2538" endline="2547"><![CDATA[
 
     Shared Function GetFieldOrFieldReference(ByVal Compiler As Compiler, ByVal field As Mono.Cecil.FieldReference) As Mono.Cecil.FieldReference
         If field.Annotations.Contains("MemberInReflection") Then
             Return DirectCast(field.Annotations("MemberInReflection"), Mono.Cecil.FieldReference)
         ElseIf Compiler.AssemblyBuilderCecil Is field.DeclaringType.Module.Assembly Then
             Return field
         Else
             Return Compiler.AssemblyBuilderCecil.MainModule.Import(field)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2548" endline="2555"><![CDATA[
 
     Shared Function GetPropertyOrPropertyBuilder(ByVal Compiler As Compiler, ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.PropertyReference
         If Compiler.Assembly.IsDefinedHere([Property]) Then
             Return [Property]
         Else
             Return [Property]
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2556" endline="2559"><![CDATA[
 
     Shared Function GetFieldOrFieldBuilder(ByVal Compiler As Compiler, ByVal Field As Mono.Cecil.FieldReference) As Mono.Cecil.FieldReference
         Return GetFieldOrFieldReference(Compiler, Field)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2560" endline="2565"><![CDATA[
 
     Shared Sub GetFieldOrFieldBuilder(ByVal Compiler As Compiler, ByVal Fields As Generic.List(Of Mono.Cecil.FieldReference))
         For i As Integer = 0 To Fields.Count - 1
             Fields(i) = GetFieldOrFieldBuilder(Compiler, Fields(i))
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2566" endline="2573"><![CDATA[
 
     Shared Sub SetTypeOrTypeBuilder(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference())
         If Type Is Nothing Then Return
         For i As Integer = 0 To Type.Length - 1
             Helper.Assert(Type(i) IsNot Nothing)
             Type(i) = GetTypeOrTypeBuilder(Compiler, Type(i))
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2574" endline="2590"><![CDATA[
 
     Shared Function GetTypeOrTypeBuilders(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference(), Optional ByVal OnlySuccessful As Boolean = False) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         If Type Is Nothing Then Return Nothing
 
         ReDim result(Type.GetUpperBound(0))
         For i As Integer = 0 To Type.GetUpperBound(0)
             Dim tmp As Mono.Cecil.TypeReference
             tmp = GetTypeOrTypeBuilder(Compiler, Type(i))
             If tmp Is Nothing AndAlso OnlySuccessful Then
                 result(i) = Type(i)
             Else
                 result(i) = tmp
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2591" endline="2686"><![CDATA[
 
     Shared Function IsAssignable(ByVal Context As BaseObject, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         'If TypeOf FromType Is TypeDescriptor Then FromType = FromType.UnderlyingSystemType
         'If TypeOf ToType Is TypeDescriptor Then ToType = ToType.UnderlyingSystemType
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine("IsAssignable (FromType 
 #End If
         If FromType Is ToType Then
             Return True
         ElseIf Helper.CompareType(FromType, Compiler.TypeCache.Nothing) Then
             Return True
         ElseIf Helper.CompareType(FromType, ToType) Then
             Return True
         ElseIf CecilHelper.IsArray(FromType) = True AndAlso CecilHelper.IsArray(ToType) = True AndAlso FromType.FullName Is Nothing AndAlso ToType.FullName Is Nothing AndAlso FromType.Name.Equals(ToType.Name, StringComparison.Ordinal) Then
             Return True
         ElseIf CompareType(ToType, Compiler.TypeCache.System_Object) Then
             Return True
             'ElseIf TypeOf ToType Is GenericTypeParameterBuilder AndAlso TypeOf FromType Is Type Then
             '    Return ToType.Name = FromType.Name
             'ElseIf ToType.GetType Is Compiler.TypeCache.System_Reflection_Emit_TypeBuilderInstantiation Then
             '    'ElseIf ToType.GetType.Name = "TypeBuilderInstantiation" Then
             '    If Helper.CompareType(Helper.GetTypeOrTypeBuilder(FromType), ToType) Then
             '        Return True
             '    Else
             '        Return False
             '    End If
             '    Return True
             '    'ElseIf TypeOf ToType Is TypeDescriptor = False AndAlso TypeOf FromType Is TypeDescriptor = False AndAlso ToType.IsAssignableFrom(FromType) Then
             '    '    Return True
         ElseIf TypeOf FromType Is GenericParameter Then
             Dim gp As GenericParameter = DirectCast(FromType, GenericParameter)
             If gp.HasConstraints Then
                 For i As Integer = 0 To gp.Constraints.Count - 1
                     If Helper.IsAssignable(Context, gp.Constraints(i), ToType) Then Return True
                 Next
             End If
             Return False
         ElseIf IsInterface(Context, ToType) Then
             Dim ifaces As Mono.Collections.Generic.Collection(Of TypeReference) = CecilHelper.GetInterfaces(FromType, True)
             If ifaces IsNot Nothing Then
                 For i As Integer = 0 To ifaces.Count - 1
                     Dim iface As Mono.Cecil.TypeReference = ifaces(i)
                     If Helper.CompareType(iface, ToType) Then Return True
                     If Helper.IsAssignable(Context, iface, ToType) Then Return True
                     If Helper.IsSubclassOf(ToType, iface) Then Return True
                 Next
             End If
             If IsInterface(Context, FromType) AndAlso CecilHelper.IsGenericType(FromType) AndAlso CecilHelper.IsGenericType(ToType) Then
                 Dim baseFromI, baseToI As Mono.Cecil.TypeReference
                 baseFromI = CecilHelper.GetGenericTypeDefinition(FromType)
                 baseToI = CecilHelper.GetGenericTypeDefinition(ToType)
                 If Helper.CompareType(baseFromI, baseToI) Then
                     Dim fromArgs, toArgs As Mono.Collections.Generic.Collection(Of TypeReference)
                     fromArgs = CecilHelper.GetGenericArguments(FromType)
                     toArgs = CecilHelper.GetGenericArguments(ToType)
                     If fromArgs.Count = toArgs.Count Then
                         For i As Integer = 0 To toArgs.Count - 1
                             If Helper.IsAssignable(Context, fromArgs(i), toArgs(i)) = False Then Return False
                         Next
                         Return True
                     End If
                 End If
             End If
             Return False
         ElseIf Helper.IsEnum(Compiler, FromType) AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Context, GetEnumType(Compiler, FromType), ToType) Then
             Return True
         ElseIf ToType.FullName IsNot Nothing AndAlso FromType.FullName IsNot Nothing AndAlso ToType.FullName.Equals(FromType.FullName, StringComparison.Ordinal) Then
             Return True
         ElseIf Helper.CompareType(Compiler.TypeCache.System_UInt32, ToType) AndAlso Helper.CompareType(Compiler.TypeCache.System_UInt16, FromType) Then
             Return True
         ElseIf Helper.CompareType(FromType, Compiler.TypeCache.System_Object) Then
             Return False
         ElseIf TypeOf FromType Is Mono.Cecil.ArrayType AndAlso Helper.Compare(ToType, Compiler.TypeCache.System_Array) Then
             Return True
         ElseIf CecilHelper.IsArray(FromType) AndAlso CecilHelper.IsArray(ToType) Then
             Dim fromArray As ArrayType = DirectCast(FromType, ArrayType)
             Dim toArray As ArrayType = DirectCast(ToType, ArrayType)
             Dim fromElement As Mono.Cecil.TypeReference = CecilHelper.GetElementType(FromType)
             Dim toElement As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ToType)
             If CecilHelper.IsValueType(fromElement) Xor CecilHelper.IsValueType(toElement) Then
                 Return False
             ElseIf fromArray.Rank <> toArray.Rank Then
                 Return False
             Else
                 Return Helper.IsAssignable(Context, fromElement, toElement)
             End If
         ElseIf Helper.IsSubclassOf(ToType, FromType) Then
             Return True
         ElseIf Helper.IsSubclassOf(FromType, ToType) Then
             Return False
         Else
             'Helper.NotImplementedYet("Don't know if it possible to convert from " & FromType.Name & " to " & ToType.Name)
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2687" endline="2730"><![CDATA[
 
     Shared Function GetMostEncompassedType(ByVal Compiler As Compiler, ByVal Types As Generic.List(Of TypeReference)) As TypeReference
         Dim result() As Boolean
 
         '?	If an intrinsic widening conversion exists from a type A to a type B, and if neither A nor B are interfaces, then A is encompassed by B, and B encompasses A.
         '?	The most encompassing type in a set of types is the one type that encompasses all other types in the set. 
         '   If no single type encompasses all other types, then the set has no most encompassing type. 
         '   In intuitive terms, the most encompassing type is the ?largest? type in the set?the one type to 
         '   which each of the other types can be converted through a widening conversion.
         '?	The most encompassed type in a set of types is the one type that is encompassed by all other types in the set. 
         '   If no single type is encompassed by all other types, then the set has no most encompassed type. 
         '   In intuitive terms, the most encompassed type is the ?smallest? type in the set?the one type that 
         '   can be converted to each of the other types through a narrowing conversion.
 
         If Types Is Nothing OrElse Types.Count = 0 Then Return Nothing
         If Types.Count = 1 Then Return Types(0)
 
         ReDim result(Types.Count - 1)
         For i As Integer = 0 To result.Length - 1
             result(i) = True
         Next
 
         For i As Integer = 0 To result.Length - 1
             For j As Integer = i + 1 To result.Length - 1
                 If result(j) AndAlso IsFirstEncompassingSecond(Compiler, Types(i), Types(j)) Then
                     result(j) = False
                 ElseIf result(i) AndAlso IsFirstEncompassingSecond(Compiler, Types(j), Types(i)) Then
                     result(i) = False
                 End If
             Next
         Next
 
         Dim count As Integer
         Dim index As Integer
         For i As Integer = 0 To result.Length - 1
             If result(i) Then
                 count += 1
                 index = i
             End If
         Next
 
         If count <> 1 Then Return Nothing
         Return Types(index)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2731" endline="2735"><![CDATA[
 
     Shared Function IsFirstEncompassingSecond(ByVal Compiler As Compiler, ByVal First As TypeReference, ByVal Second As TypeReference) As Boolean
         If First Is Second Then Return False
         Return Compiler.TypeResolution.IsImplicitlyConvertible(Compiler, Second, First)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2736" endline="2762"><![CDATA[
 
     Shared Function GetMostEncompassedTypes(ByVal Compiler As Compiler, ByVal Types() As TypeCode) As TypeCode()
         Dim result As Generic.List(Of TypeCode)
 
         If Types Is Nothing Then Return Nothing
         If Types.Length <= 1 Then Return Types
 
         result = New Generic.List(Of TypeCode)(Types)
 
         If result.Count <= 1 Then Return result.ToArray
 
         Dim didSomething As Boolean = False
         Do
             didSomething = False
             For i As Integer = result.Count - 2 To 0 Step -1
                 If IsFirstEncompassingSecond(Compiler, result(i), result(i + 1)) Then
                     result.RemoveAt(i)
                     didSomething = True
                 ElseIf IsFirstEncompassingSecond(Compiler, result(i + 1), result(i)) Then
                     result.RemoveAt(i + 1)
                     didSomething = True
                 End If
             Next
         Loop While didSomething
 
         Return result.ToArray
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2763" endline="2767"><![CDATA[
 
     Shared Function IsFirstEncompassingSecond(ByVal Compiler As Compiler, ByVal First As TypeCode, ByVal Second As TypeCode) As Boolean
         If First = Second Then Return False
         Return Compiler.TypeResolution.IsImplicitlyConvertible(Compiler, Second, First)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2768" endline="2777"><![CDATA[
 
     Shared Function IsNullableType(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If CecilHelper.IsValueType(Type) = False Then Return False
         If CompareType(Type, Compiler.TypeCache.System_Nullable1) Then Return True
 
         If CecilHelper.IsGenericTypeDefinition(Type) Then Return False
         If CecilHelper.IsGenericParameter(Type) Then Return False
         If CecilHelper.IsGenericType(Type) = False Then Return False
         Return Helper.CompareType(CecilHelper.GetGenericTypeDefinition(Type), Compiler.TypeCache.System_Nullable1)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2778" endline="2791"><![CDATA[
 
     Shared Function IsSubclassOf(ByVal BaseClass As Mono.Cecil.TypeReference, ByVal DerivedClass As Mono.Cecil.TypeReference) As Boolean
         If TypeOf BaseClass Is Mono.Cecil.GenericParameter Xor TypeOf DerivedClass Is Mono.Cecil.GenericParameter Then Return False
         If TypeOf BaseClass Is Mono.Cecil.ArrayType Or TypeOf DerivedClass Is Mono.Cecil.ArrayType Then Return False
         Dim base As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(BaseClass)
         Dim derived As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(DerivedClass)
         Dim current As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(derived.BaseType)
 
         Do While current IsNot Nothing
             If Helper.CompareType(current, base) Then Return True
             current = CecilHelper.FindDefinition(CecilHelper.FindDefinition(current).BaseType)
         Loop
         Do While current IsNot Nothing
             If Helper.CompareType(current, base) Then Return True
             current = CecilHelper.FindDefinition(CecilHelper.FindDefinition(current).BaseType)
         Loop
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2792" endline="2801"><![CDATA[
 
     Shared Function DoesTypeImplementInterface(ByVal Context As BaseObject, ByVal Type As Mono.Cecil.TypeReference, ByVal [Interface] As Mono.Cecil.TypeReference) As Boolean
         Dim ifaces As Mono.Collections.Generic.Collection(Of TypeReference)
         ifaces = CecilHelper.GetInterfaces(Type, True)
         For Each iface As Mono.Cecil.TypeReference In ifaces
             If Helper.IsAssignable(Context, iface, [Interface]) Then Return True
         Next
         Return False
         '        Return Array.IndexOf(CecilHelper.GetInterfaces(Type), [Interface]) >= 0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2802" endline="2815"><![CDATA[
 
     Shared Function GetEnumType(ByVal Compiler As Compiler, ByVal EnumType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim tp As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(EnumType)
         Dim fInfo As Mono.Cecil.FieldReference
 
         Helper.Assert(Helper.IsEnum(Compiler, EnumType))
 
         tp = CecilHelper.FindDefinition(EnumType)
         fInfo = CecilHelper.FindField(tp.Fields, EnumDeclaration.EnumTypeMemberName)
 
         Helper.Assert(fInfo IsNot Nothing)
 
         Return fInfo.FieldType
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2816" endline="2909"><![CDATA[
 
     ''' <summary>
     ''' Creates a CType expression containing the specified FromExpression if necessary.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="FromExpression"></param>
     ''' <param name="DestinationType"></param>
     ''' <param name="result"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CreateTypeConversion(ByVal Parent As ParsedObject, ByVal FromExpression As Expression, ByVal DestinationType As Mono.Cecil.TypeReference, ByRef result As Boolean) As Expression
         Dim fromExpr As Expression
 
         Helper.Assert(FromExpression IsNot Nothing)
 
         fromExpr = FromExpression
 
         Dim fromType As Mono.Cecil.TypeReference
         fromType = FromExpression.ExpressionType
 
 #If EXTENDEDDEBUG Then
         Parent.Compiler.Report.WriteLine("Creating type conversion, from " & fromType.FullName & " to " & DestinationType.FullName)
         If DestinationType.IsByRef Then
             Parent.Compiler.Report.WriteLine(">DestinationType.ElementType = " & DestinationType.GetElementType.FullName)
             Parent.Compiler.Report.WriteLine(">IsAssignable to DestinationType.ElementType = " & IsAssignable(Parent.Compiler, fromType, DestinationType.GetElementType))
         End If
 #End If
 
         Helper.Assert(fromType IsNot Nothing)
 
         If Helper.CompareType(fromType, DestinationType) Then
             'do nothing
         ElseIf CecilHelper.IsByRef(fromExpr.ExpressionType) AndAlso IsAssignable(Parent, CecilHelper.GetElementType(fromType), DestinationType) Then
             'do nothing
             If CecilHelper.IsValueType(CecilHelper.GetElementType(fromType)) AndAlso CecilHelper.IsValueType(DestinationType) = False Then
                 fromExpr = New BoxExpression(Parent, fromExpr, DestinationType)
             End If
         ElseIf CecilHelper.IsByRef(DestinationType) AndAlso IsAssignable(Parent, fromExpr.ExpressionType, CecilHelper.GetElementType(DestinationType)) Then
 #If EXTENDEDDEBUG Then
             Parent.Compiler.Report.WriteLine(">3")
 #End If
             If CecilHelper.IsByRef(fromExpr.ExpressionType) = False AndAlso Helper.CompareType(fromExpr.ExpressionType, CecilHelper.GetElementType(DestinationType)) = False Then
                 fromExpr = New CTypeExpression(Parent, fromExpr, CecilHelper.GetElementType(DestinationType))
                 result = fromExpr.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
             End If
             'do nothing
         ElseIf CecilHelper.IsByRef(DestinationType) AndAlso Parent.Compiler.TypeResolution.IsImplicitlyConvertible(Parent, fromExpr.ExpressionType, CecilHelper.GetElementType(DestinationType)) Then
             Dim tmpExp As Expression
             tmpExp = CreateTypeConversion(Parent, fromExpr, CecilHelper.GetElementType(DestinationType), result)
             If result = False Then Return fromExpr
 
             fromExpr = tmpExp
         ElseIf CompareType(fromExpr.ExpressionType, Parent.Compiler.TypeCache.Nothing) Then
             'do nothing
         ElseIf CompareType(DestinationType, Parent.Compiler.TypeCache.System_Enum) AndAlso Helper.IsEnum(Parent.Compiler, fromExpr.ExpressionType) Then
             fromExpr = New BoxExpression(Parent, fromExpr, DestinationType)
         ElseIf CompareType(fromExpr.ExpressionType, DestinationType) = False AndAlso IsAssignable(Parent, fromExpr.ExpressionType, DestinationType) = False Then
             Dim CTypeExp As Expression
 
             If CecilHelper.IsByRef(fromExpr.ExpressionType) Then
                 fromExpr = New DeRefExpression(fromExpr, fromExpr)
             End If
 
             CTypeExp = ConversionExpression.GetTypeConversion(Parent, fromExpr, DestinationType)
             result = CTypeExp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
             fromExpr = CTypeExp
         ElseIf CompareType(DestinationType, Parent.Compiler.TypeCache.System_Object) AndAlso CecilHelper.IsValueType(fromExpr.ExpressionType) Then
             fromExpr = New BoxExpression(Parent, fromExpr, DestinationType)
         ElseIf CompareType(DestinationType, Parent.Compiler.TypeCache.System_Object) AndAlso CecilHelper.IsGenericParameter(fromExpr.ExpressionType) Then
             fromExpr = New BoxExpression(Parent, fromExpr, DestinationType)
         ElseIf CecilHelper.IsGenericType(fromExpr.ExpressionType) Then
             'fromExpr = New BoxExpression(Parent, fromExpr, fromExpr.ExpressionType)
             fromExpr = New CTypeExpression(Parent, fromExpr, DestinationType)
             result = fromExpr.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
         ElseIf fromExpr.Compiler.TypeResolution.IsImplicitlyConvertible(fromExpr, fromExpr.ExpressionType, DestinationType) AndAlso DestinationType.IsValueType AndAlso fromExpr.ExpressionType.IsValueType Then
             Dim CTypeExp As Expression
 
             CTypeExp = ConversionExpression.GetTypeConversion(Parent, fromExpr, DestinationType)
             result = CTypeExp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
             fromExpr = CTypeExp
         ElseIf CompareType(DestinationType, Parent.Compiler.TypeCache.System_ValueType) AndAlso fromExpr.ExpressionType.IsValueType Then
             fromExpr = New BoxExpression(Parent, fromExpr, fromExpr.ExpressionType)
         ElseIf TypeOf fromExpr.ExpressionType Is GenericParameter Then
             fromExpr = New CTypeExpression(Parent, fromExpr, DestinationType)
         End If
 
 #If EXTENDEDDEBUG Then
         If fromType IsNot FromExpression Then
             Parent.Compiler.Report.WriteLine(Report.ReportLevels.Debug, "Created type conversion from '" & FromExpression.ExpressionType.Name & "' to '" & DestinationType.Name & "'")
         End If
 #End If
 
         Return fromExpr
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2910" endline="2928"><![CDATA[
 
     ''' <summary>
     ''' Returns true if all types in both arrays are the exact same types.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareTypes(ByVal Types1() As Mono.Cecil.TypeReference, ByVal Types2() As Mono.Cecil.TypeReference) As Boolean
         If Types1 Is Nothing AndAlso Types2 Is Nothing Then
             Return True
         ElseIf Types1 Is Nothing Xor Types2 Is Nothing Then
             Return False
         Else
             If Types1.Length <> Types2.Length Then Return False
             For i As Integer = 0 To Types1.Length - 1
                 If Helper.CompareType(Types1(i), Types2(i)) = False Then Return False
             Next
             Return True
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2929" endline="2960"><![CDATA[
 
     Shared Function CompareMethod(ByVal m1 As Mono.Cecil.MethodReference, ByVal m2 As Mono.Cecil.MethodReference) As Boolean
         Dim g1 As Mono.Cecil.GenericInstanceMethod
         Dim g2 As Mono.Cecil.GenericInstanceMethod
 
         If m1 Is Nothing AndAlso m2 Is Nothing Then Return True
         If m1 Is Nothing Xor m2 Is Nothing Then Return False
 
         If m1 Is m2 Then Return True
         If Helper.CompareNameOrdinal(m1.Name, m2.Name) = False Then Return False
         If m1.Parameters.Count <> m2.Parameters.Count Then Return False
         If m1.GenericParameters.Count <> m2.GenericParameters.Count Then Return False
         If Helper.Compare(m1.DeclaringType, m2.DeclaringType) = False Then Return False
 
         For i As Integer = 0 To m1.Parameters.Count - 1
             If Helper.CompareType(m1.Parameters(i).ParameterType, m2.Parameters(i).ParameterType) = False Then Return False
         Next
 
         g1 = TryCast(m1, Mono.Cecil.GenericInstanceMethod)
         g2 = TryCast(m2, Mono.Cecil.GenericInstanceMethod)
 
         If g1 IsNot Nothing AndAlso g2 IsNot Nothing Then
             If g1.GenericArguments.Count <> g2.GenericArguments.Count Then Return False
             For i As Integer = 0 To g1.GenericArguments.Count - 1
                 If Helper.CompareType(g1.GenericArguments(i), g2.GenericArguments(i)) = False Then Return False
             Next
         ElseIf g1 IsNot Nothing Xor g2 IsNot Nothing Then
             Return False
         End If
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2961" endline="3032"><![CDATA[
 
     Shared Function CompareType(ByVal t1 As Mono.Cecil.TypeReference, ByVal t2 As Mono.Cecil.TypeReference) As Boolean
         If t1 Is t2 Then Return True
         If t1 Is Nothing OrElse t2 Is Nothing Then Return False
 
         Dim g1 As Mono.Cecil.GenericParameter = TryCast(t1, Mono.Cecil.GenericParameter)
         Dim g2 As Mono.Cecil.GenericParameter = TryCast(t2, Mono.Cecil.GenericParameter)
 
         If g1 IsNot Nothing AndAlso g2 IsNot Nothing Then
             Return Helper.CompareNameOrdinal(g1.Name, g2.Name) AndAlso Helper.Compare(g1.Owner, g2.Owner)
         ElseIf g1 IsNot Nothing Xor g2 IsNot Nothing Then
             Return False
         End If
 
         Dim gi1 As Mono.Cecil.GenericInstanceType = TryCast(t1, Mono.Cecil.GenericInstanceType)
         Dim gi2 As Mono.Cecil.GenericInstanceType = TryCast(t2, Mono.Cecil.GenericInstanceType)
 
         If gi1 IsNot Nothing AndAlso gi2 IsNot Nothing Then
             If gi1 Is gi2 Then Return True
             If Not Helper.CompareType(gi1.GetElementType, gi2.GetElementType) Then Return False
             If gi1.GenericArguments.Count <> gi2.GenericArguments.Count Then Return False
             For i As Integer = 0 To gi1.GenericArguments.Count - 1
                 If Helper.CompareType(gi1.GenericArguments(i), gi2.GenericArguments(i)) = False Then
                     Return False
                 End If
             Next
             Helper.Assert(gi1.FullName = gi2.FullName)
             Return True
         ElseIf gi1 IsNot Nothing Xor gi2 IsNot Nothing Then
             Return False
         End If
 
         Dim a1 As Mono.Cecil.ArrayType = TryCast(t1, Mono.Cecil.ArrayType)
         Dim a2 As Mono.Cecil.ArrayType = TryCast(t2, Mono.Cecil.ArrayType)
         If a1 IsNot Nothing AndAlso a2 IsNot Nothing Then
             If a1.Dimensions.Count <> a2.Dimensions.Count Then Return False
             For i As Integer = 0 To a1.Dimensions.Count - 1
                 If a1.Dimensions(i).LowerBound.HasValue Xor a2.Dimensions(i).LowerBound.HasValue Then Return False
                 If a1.Dimensions(i).UpperBound.HasValue Xor a2.Dimensions(i).UpperBound.HasValue Then Return False
 
                 If a1.Dimensions(i).LowerBound.HasValue AndAlso a2.Dimensions(i).LowerBound.HasValue Then
                     If a1.Dimensions(i).LowerBound.Value <> a2.Dimensions(i).LowerBound.Value Then Return False
                 End If
 
                 If a1.Dimensions(i).UpperBound.HasValue AndAlso a2.Dimensions(i).UpperBound.HasValue Then
                     If a1.Dimensions(i).UpperBound.Value <> a2.Dimensions(i).UpperBound.Value Then Return False
                 End If
             Next
             Return CompareType(a1.ElementType, a2.ElementType)
         ElseIf a1 IsNot Nothing Xor a2 IsNot Nothing Then
             'Only one of them is an array
             Return False
         End If
 
         Dim r1 As ByReferenceType = TryCast(t1, ByReferenceType)
         Dim r2 As ByReferenceType = TryCast(t2, ByReferenceType)
         If r1 IsNot Nothing AndAlso r2 IsNot Nothing Then
             Return Helper.CompareType(r1.ElementType, r2.ElementType)
         ElseIf r1 IsNot Nothing Xor r2 IsNot Nothing Then
             Return False
         End If
 
         If t1.IsNested AndAlso t2.IsNested AndAlso CompareType(t1.DeclaringType, t2.DeclaringType) = False Then
             Return False
         End If
 
         If CecilHelper.FindDefinition(t1) Is CecilHelper.FindDefinition(t2) Then Return True
         If t1.FullName IsNot Nothing AndAlso t2.FullName IsNot Nothing AndAlso Helper.CompareNameOrdinal(t1.FullName, t2.FullName) Then Return True
         Helper.Assert(t1.FullName.Equals(t2.FullName) = False)
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3033" endline="3053"><![CDATA[
 
     Shared Function Compare(ByVal g1 As Mono.Cecil.IGenericParameterProvider, ByVal g2 As Mono.Cecil.IGenericParameterProvider) As Boolean
         Helper.Assert(g1 IsNot Nothing AndAlso g2 IsNot Nothing)
         Dim m1 As Mono.Cecil.MethodReference = TryCast(g1, Mono.Cecil.MethodReference)
         Dim m2 As Mono.Cecil.MethodReference = TryCast(g2, Mono.Cecil.MethodReference)
 
         If m1 IsNot Nothing AndAlso m2 IsNot Nothing Then
             Return m1 Is m2
         ElseIf m1 IsNot Nothing Xor m2 IsNot Nothing Then
             Return False
         End If
 
         Dim t1 As Mono.Cecil.TypeReference = TryCast(g1, Mono.Cecil.TypeReference)
         Dim t2 As Mono.Cecil.TypeReference = TryCast(g2, Mono.Cecil.TypeReference)
 
         If t1 IsNot Nothing AndAlso t2 IsNot Nothing Then
             Return Helper.CompareType(t1, t2)
         End If
 
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3054" endline="3085"><![CDATA[
 
     ''' <summary>
     ''' Creates a vb-like representation of the parameters
     ''' </summary>
     ''' <param name="Params"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Params As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         For i As Integer = 0 To Params.Count - 1
             Dim t As Mono.Cecil.ParameterDefinition = Params(i)
             Dim tmp As String
             If CecilHelper.IsByRef(t.ParameterType) Then
                 tmp = "ByRef " & CecilHelper.GetElementType(t.ParameterType).ToString
             Else
                 tmp = t.ParameterType.ToString
             End If
             If t.IsOptional Then
                 tmp = "Optional " & tmp
             End If
             If Helper.IsParamArrayParameter(Context, t) Then
                 tmp = "ParamArray " & tmp
             End If
             result = result & sep & tmp
             sep = ", "
         Next
 
         Return "(" & result & ")"
 
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3086" endline="3093"><![CDATA[
 
     Shared Function IsParamArrayParameter(ByVal Context As BaseObject, ByVal Parameter As Mono.Cecil.ParameterReference) As Boolean
         Dim result As Boolean
         Dim pD As Mono.Cecil.ParameterDefinition = CecilHelper.FindDefinition(Parameter)
         result = CecilHelper.IsDefined(pD.CustomAttributes, Context.Compiler.TypeCache.System_ParamArrayAttribute)
         LogResolutionMessage(Context.Compiler, "IsParamArrayParameter
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3094" endline="3108"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Mono.Cecil.TypeReference()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         If Types IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In Types
                 Helper.Assert(t IsNot Nothing)
                 result &= sep & t.ToString
                 sep = ", "
             Next
         End If
 
         Return "{" & result & "}"
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3109" endline="3121"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Type()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         For Each t As Type In Types
             Helper.Assert(t IsNot Nothing)
             result &= sep & t.ToString
             sep = ", "
         Next
 
         Return "{" & result & "}"
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3122" endline="3138"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As ModifierMasks) As String
         Select Case Accessibility
             Case ModifierMasks.Protected Or ModifierMasks.Friend
                 Return "Protected Friend"
             Case ModifierMasks.Protected
                 Return "Protected"
             Case ModifierMasks.Friend
                 Return "Friend"
             Case ModifierMasks.Public
                 Return "Public"
             Case ModifierMasks.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3139" endline="3158"><![CDATA[
 
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.FieldAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.FieldAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.FieldAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.FieldAttributes.Public
                 Return "Public"
             Case Mono.Cecil.FieldAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3159" endline="3177"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.MethodAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.MethodAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3178" endline="3196"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.TypeAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.TypeAttributes.NestedFamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Return "Protected"
             Case Mono.Cecil.TypeAttributes.NestedAssembly, Mono.Cecil.TypeAttributes.NotPublic
                 Return "Friend"
             Case Mono.Cecil.TypeAttributes.NestedPublic, Mono.Cecil.TypeAttributes.Public
                 Return "Public"
             Case Mono.Cecil.TypeAttributes.NestedPrivate
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3197" endline="3270"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Member As MethodReference) As String
         Dim builder As New Text.StringBuilder()
         Dim isSub As Boolean = Helper.CompareType(Member.ReturnType, Context.Compiler.TypeCache.System_Void)
 
         If Helper.CompareNameOrdinal(Member.Name, ".ctor") Then
             builder.Append("Sub New(")
             builder.Append(Helper.ToString(Context, Helper.GetParameters(Context, Member)))
             builder.Append(")")
         Else
             If isSub Then
                 builder.Append("Sub ")
             Else
                 builder.Append("Function ")
             End If
             builder.Append(Member.Name)
             If Member.HasGenericParameters Then
                 builder.Append("(Of ")
                 For i As Integer = 0 To Member.GenericParameters.Count - 1
                     Dim gp As GenericParameter = Member.GenericParameters(i)
                     Dim constraints As New Text.StringBuilder
                     Dim constraintCount As Integer
 
                     If i > 0 Then builder.Append(", ")
                     builder.Append(gp.Name)
 
                     If gp.HasNotNullableValueTypeConstraint Then
                         If constraintCount > 0 Then constraints.Append(", ")
                         constraints.Append("Structure")
                         constraintCount += 1
                     End If
                     If gp.HasDefaultConstructorConstraint AndAlso gp.HasNotNullableValueTypeConstraint = False Then
                         If constraintCount > 0 Then constraints.Append(", ")
                         constraints.Append("New")
                         constraintCount += 1
                     End If
                     If gp.HasReferenceTypeConstraint Then
                         If constraintCount > 0 Then constraints.Append(", ")
                         constraints.Append("Class")
                         constraintCount += 1
                     End If
                     For c As Integer = 0 To gp.Constraints.Count - 1
                         If Helper.CompareType(Context.Compiler.TypeCache.System_ValueType, gp.Constraints(i)) Then Continue For
                         If constraintCount > 0 Then constraints.Append(", ")
                         constraints.Append(gp.Constraints(i).Name)
                         constraintCount += 1
                     Next
                     If constraintCount > 0 Then
                         builder.Append(" As ")
                         If constraintCount > 1 Then builder.Append("{")
                         builder.Append(constraints)
                         If constraintCount > 1 Then builder.Append("}")
                     End If
                 Next
                 builder.Append(")")
             End If
             builder.Append("(")
             For i As Integer = 0 To Member.Parameters.Count - 1
                 If i > 0 Then builder.Append(", ")
                 Dim param As ParameterDefinition = Member.Parameters(i)
                 If CecilHelper.IsByRef(param.ParameterType) Then builder.Append("ByRef ")
                 builder.Append(param.Name)
                 builder.Append(" As ")
                 builder.Append(Helper.ToString(Context, param.ParameterType))
             Next
             builder.Append(")")
             If isSub = False Then
                 builder.Append(" As ")
                 builder.Append(Helper.ToString(Context, Member.ReturnType))
             End If
         End If
 
         Return builder.ToString()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3271" endline="3330"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Member As TypeReference) As String
         Dim typeDefinition As TypeDefinition
 
         If Member Is Nothing Then Return "Nothing"
 
         typeDefinition = TryCast(Member, TypeDefinition)
         If typeDefinition IsNot Nothing AndAlso Helper.IsDelegate(Context.Compiler, typeDefinition) Then
             Dim builder As New Text.StringBuilder()
             Dim delegateType As Mono.Cecil.TypeDefinition = DirectCast(Member, Mono.Cecil.TypeDefinition)
             Dim invoke As Mono.Cecil.MethodReference = GetInvokeMethod(Context.Compiler, delegateType)
 
             builder.Append("Delegate ")
             builder.Append(ToString(Context, invoke))
             If Helper.CompareType(invoke.ReturnType, Context.Compiler.TypeCache.System_Void) Then
                 builder.Replace("Delegate Sub " + invoke.Name + "(", "Delegate Sub " + delegateType.Name + "(")
             Else
                 builder.Replace("Delegate Function " + invoke.Name + "(", "Delegate Function " + delegateType.Name + "(")
             End If
             Return builder.ToString()
         ElseIf CecilHelper.IsNullable(Member) Then
             Return ToString(Context, CecilHelper.GetNulledType(Member)) & "?"
         Else
             If Helper.CompareType(Member, Context.Compiler.TypeCache.System_Byte) Then
                 Return "Byte"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Boolean) Then
                 Return "Boolean"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Char) Then
                 Return "Char"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_DateTime) Then
                 Return "Date"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_DBNull) Then
                 Return "DBNull"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Decimal) Then
                 Return "Decimal"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Double) Then
                 Return "Double"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Int16) Then
                 Return "Short"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Int32) Then
                 Return "Integer"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Int64) Then
                 Return "Long"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_SByte) Then
                 Return "SByte"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Single) Then
                 Return "Single"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_String) Then
                 Return "String"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_UInt16) Then
                 Return "UShort"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_UInt32) Then
                 Return "UInteger"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_UInt64) Then
                 Return "ULong"
             Else
                 Return Member.ToString()
             End If
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3331" endline="3349"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As String
         Dim methodReference As MethodReference
         Dim propertyReference As PropertyReference
         Dim typeReference As TypeReference
 
         methodReference = TryCast(Member, MethodReference)
         If methodReference IsNot Nothing Then Return ToString(Context, methodReference)
 
         propertyReference = TryCast(Member, PropertyReference)
         If propertyReference IsNot Nothing Then Return Member.Name & "(" & Helper.ToString(Context, Helper.GetParameters(Context, Member)) & ")"
 
         typeReference = TryCast(Member, TypeReference)
         If typeReference IsNot Nothing Then Return ToString(Context, DirectCast(Member, TypeReference))
 
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
 
         Return String.Empty
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3350" endline="3355"><![CDATA[
 
     <Diagnostics.Conditional("DEBUGMETHODRESOLUTION")> Shared Sub LogResolutionMessage(ByVal Compiler As Compiler, ByVal msg As String)
         If LOGMETHODRESOLUTION Then
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, msg)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3356" endline="3361"><![CDATA[
 
     <Diagnostics.Conditional("DEBUGMETHODADD")> Shared Sub LogAddMessage(ByVal Compiler As Compiler, ByVal msg As String, Optional ByVal condition As Boolean = True)
         If True AndAlso condition Then
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, msg)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3362" endline="3397"><![CDATA[
 
     ''' <summary>
     ''' Creates the expression that is to be emitted for an optional parameter.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Parameter"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetOptionalValueExpression(ByVal Parent As ParsedObject, ByVal Parameter As Mono.Cecil.ParameterDefinition) As Expression
         Dim result As Expression
         If Helper.CompareType(Parameter.ParameterType, Parent.Compiler.TypeCache.System_Object) AndAlso Helper.IsOnMS AndAlso Parameter.Constant Is DBNull.Value Then
             'Mono hasn't implemented ParameterInfo.RawDefaultValue yet.
 
             'If an Object parameter does not specify a default value, then the expression 
             'System.Reflection.Missing.Value is used. 
             result = New LoadFieldExpression(Parent, Parent.Compiler.TypeCache.System_Reflection_Missing__Value)
         ElseIf Helper.CompareType(Parameter.ParameterType, Parent.Compiler.TypeCache.System_Int32) AndAlso CecilHelper.IsDefined(Parameter.CustomAttributes, Parent.Compiler.TypeCache.MS_VB_CS_OptionCompareAttribute) Then
             'If an optional Integer parameter 
             'has the Microsoft.VisualBasic.CompilerServices.OptionCompareAttribute attribute, 
             'then the literal 1 is supplied for text comparisons and the literal 0 otherwise
             Dim cExp As ConstantExpression
             If Parent.Location.File(Parent.Compiler).IsOptionCompareText Then
                 cExp = New ConstantExpression(Parent, 1I, Parent.Compiler.TypeCache.System_Int32)
             Else
                 cExp = New ConstantExpression(Parent, 0I, Parent.Compiler.TypeCache.System_Int32)
             End If
             result = cExp
         Else
             'If optional parameters remain, the default value 
             'specified in the optional parameter declaration is matched to the parameter. 
             Dim cExp As ConstantExpression
             cExp = New ConstantExpression(Parent, Parameter.Constant, Parameter.ParameterType)
             result = cExp
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3398" endline="3407"><![CDATA[
 
     Shared Function ArgumentsToExpressions(ByVal Arguments As Generic.List(Of Argument)) As Expression()
         Dim result(Arguments.Count - 1) As Expression
 
         For i As Integer = 0 To Arguments.Count - 1
             result(i) = Arguments(i).Expression
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3408" endline="3487"><![CDATA[
 
     Shared Function IsFirstMoreApplicable(ByVal Context As BaseObject, ByVal Arguments As Generic.List(Of Argument), ByVal MTypes As Mono.Cecil.TypeReference(), ByVal NTypes() As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         Dim result As Boolean = True
         'A member M is considered more applicable than N if their signatures are different and, 
         'for each pair of parameters Mj and Nj that matches an argument Aj, 
         'one of the following conditions is true
         '*	Mj and Nj have identical types, or
         '*	There exists a widening conversion from the type of Mj to the type Nj, or
         '*	Aj is the literal 0, Mj is a numeric type and Nj is an enumerated type, or
         '*	Mj is Byte and Nj is SByte, or
         '*  Mj is Short and Nj is UShort, or
         '*	Mj is Integer and Nj is UInteger, or 
         '*	Mj is Long and Nj is ULong.
 
         'LAMESPEC?
         'I've found that the previous section must be
         '*	Mj is Byte and Nj is SByte, or
         '*  Mj is Short/Byte and Nj is UShort, or
         '*	Mj is Integer/Short/Byte and Nj is UInteger, or 
         '*	Mj is Long/Integer/Short/Byte and Nj is ULong.
         'example that doesn't work otherwise
         ' Two methods with parameter types Int32 and UInt64 which is passed in a UInt16.
 
         'A member M is considered more applicable than N if their signatures are different 
         If Helper.CompareTypes(MTypes, NTypes) Then
             'Signatures are not different so none is more applicable
             Return False
         End If
 
         For i As Integer = 0 To Arguments.Count - 1
             Dim is1stMoreApplicable As Boolean
             Dim isEqual, isWidening, isLiteral0 As Boolean
             Dim isMByte, isMShort, isMInteger, isMLong As Boolean
             Dim isNByte, isNShort, isNInteger, isNLong As Boolean
             'Dim isMSigned, isNUnsigned As Boolean 'Names are not accurate for Byte/SByte
 
             If MTypes.Length - 1 < i OrElse NTypes.Length - 1 < i Then Exit For
 
             '*	Mj and Nj have identical types, or
             isEqual = Helper.CompareType(MTypes(i), NTypes(i))
 
             '*	There exists a widening conversion from the type of Mj to the type Nj, or
             isWidening = Compiler.TypeResolution.IsImplicitlyConvertible(Context, MTypes(i), NTypes(i))
 
             '*	Aj is the literal 0, Mj is a numeric type and Nj is an enumerated type, or
             isLiteral0 = IsLiteral0Expression(Compiler, Arguments(i).Expression) AndAlso Compiler.TypeResolution.IsNumericType(MTypes(i)) AndAlso Helper.IsEnum(Compiler, NTypes(i))
 
             isMByte = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Byte)
             isMShort = isMByte = False AndAlso Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int16)
             isMInteger = isMByte = False AndAlso isMShort = False AndAlso Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int32)
             isMLong = isMByte = False AndAlso isMShort = False AndAlso isMInteger = False AndAlso Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int64)
 
             isNByte = Helper.CompareType(NTypes(i), Compiler.TypeCache.System_SByte)
             isNShort = isNByte = False AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt16)
             isNInteger = isNByte = False AndAlso isNShort = False AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt32)
             isNLong = isNByte = False AndAlso isNShort = False AndAlso isNInteger = False AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt64)
 
             ''*	Mj is Byte and Nj is SByte, or
             'isByte = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Byte) AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_SByte)
 
             ''*	Mj is Short and Nj is UShort, or
             'isShort = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int16) AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt16)
 
             ''*	Mj is Integer and Nj is UInteger, or 
             'isInteger = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int32) AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt32)
 
             ''*	Mj is Long and Nj is ULong.
             'isLong = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int64) AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt64)
 
             is1stMoreApplicable = isEqual OrElse isWidening OrElse isLiteral0
             is1stMoreApplicable = is1stMoreApplicable OrElse (isMByte AndAlso isNByte)
             is1stMoreApplicable = is1stMoreApplicable OrElse ((isMByte OrElse isMShort) AndAlso isNShort)
             is1stMoreApplicable = is1stMoreApplicable OrElse ((isMByte OrElse isMShort OrElse isMInteger) AndAlso isNInteger)
             is1stMoreApplicable = is1stMoreApplicable OrElse ((isMByte OrElse isMShort OrElse isMInteger OrElse isMLong) AndAlso isNLong)
             result = is1stMoreApplicable AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3488" endline="3497"><![CDATA[
 
     Shared Function IsLiteral0Expression(ByVal Compiler As Compiler, ByVal exp As Expression) As Boolean
         If exp Is Nothing Then Return False
         Dim litExp As LiteralExpression = TryCast(exp, LiteralExpression)
         If litExp Is Nothing Then Return False
         If litExp.ConstantValue Is Nothing Then Return False
         If Compiler.TypeResolution.IsIntegralType(CecilHelper.GetType(Compiler, litExp.ConstantValue)) = False Then Return False
         If CDbl(litExp.ConstantValue) = 0.0 Then Return True
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3498" endline="3506"><![CDATA[
 
     Shared Function IsFirstLessGeneric(ByVal Context As BaseObject) As Boolean
         'A member M is determined to be less generic than a member N using the following steps
         '-	If M has fewer method type parameters than N, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the method, or Mj is less generic with respect to type parameters on the method, and at least one Mj is less generic than Nj, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the type, or Mj is less generic with respect to type parameters on the type, and at least one Mj is less generic than Nj, then M is less generic than N.
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3507" endline="3514"><![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         If Caller Is Nothing Then
             Return Helper.IsAccessible(Context, CecilHelper.FindDefinition(Method).Attributes, Method.DeclaringType)
         Else
             Return Helper.IsAccessible(Context, CecilHelper.FindDefinition(Method).Attributes, Method.DeclaringType, Caller)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3515" endline="3522"><![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal [Property] As Mono.Cecil.PropertyReference) As Boolean
         If Caller Is Nothing Then
             Return Helper.IsAccessible(Context, GetPropertyAccess([Property]), [Property].DeclaringType)
         Else
             Return Helper.IsAccessible(Context, GetPropertyAccess([Property]), [Property].DeclaringType, Caller)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3523" endline="3540"><![CDATA[
 
     Shared Function GetMethodAccessibilityString(ByVal Attributes As Mono.Cecil.MethodAttributes) As String
         Attributes = Attributes And Mono.Cecil.MethodAttributes.MemberAccessMask
         Select Case Attributes
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Mono.Cecil.MethodAttributes.FamANDAssem, Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Else
                 Return "Public"
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3541" endline="3551"><![CDATA[
 
     Shared Function GetMethodAttributes(ByVal Member As Mono.Cecil.MemberReference) As Mono.Cecil.MethodAttributes
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).Attributes
             Case MemberTypes.Property
                 Return GetPropertyAttributes(DirectCast(Member, Mono.Cecil.PropertyReference))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3552" endline="3575"><![CDATA[
 
     Shared Function GetVisibility(ByVal Compiler As Compiler, ByVal CallerType As Mono.Cecil.TypeReference, ByVal CalledType As Mono.Cecil.TypeReference) As MemberVisibility
         Helper.Assert(CallerType IsNot Nothing)
         Helper.Assert(CalledType IsNot Nothing)
         Helper.Assert(Compiler.Assembly.IsDefinedHere(CallerType))
 
         If Helper.CompareType(CallerType, CalledType) Then Return MemberVisibility.All
 
         If Compiler.Assembly.IsDefinedHere(CalledType) Then
             If Helper.IsNested(CalledType, CallerType) Then
                 Return MemberVisibility.All
             ElseIf Helper.IsSubclassOf(CalledType, CallerType) Then
                 Return MemberVisibility.PublicProtectedFriend
             Else
                 Return MemberVisibility.PublicFriend
             End If
         Else
             If Helper.IsSubclassOf(CalledType, CallerType) Then
                 Return MemberVisibility.PublicProtected
             Else
                 Return MemberVisibility.Public
             End If
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3576" endline="3579"><![CDATA[
 
     Shared Function GetVisibilityString(ByVal Member As Mono.Cecil.MemberReference) As String
         Return ToString(GetAccessibility(Member))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3580" endline="3610"><![CDATA[
 
     Shared Function GetPropertyAttributes(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
         Dim getA, setA As Mono.Cecil.MethodAttributes
         Dim getM, setM As Mono.Cecil.MethodDefinition
         Dim prop As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition([Property])
 
         getM = CecilHelper.FindDefinition(prop.GetMethod)
         setM = CecilHelper.FindDefinition(prop.SetMethod)
 
         Helper.Assert(getM IsNot Nothing OrElse setM IsNot Nothing)
 
         If getM IsNot Nothing Then
             getA = getM.Attributes
         End If
 
         If setM IsNot Nothing Then
             setA = setM.Attributes
         End If
 
         result = setA Or getA
 
         Dim visibility As Mono.Cecil.MethodAttributes
         visibility = result And Mono.Cecil.MethodAttributes.MemberAccessMask
         If visibility = Mono.Cecil.MethodAttributes.MemberAccessMask Then
             visibility = Mono.Cecil.MethodAttributes.Public
             result = (result And (Not Mono.Cecil.MethodAttributes.MemberAccessMask)) Or visibility
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3611" endline="3639"><![CDATA[
 
     Shared Function GetEventAttributes(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim ev As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition([Event])
         Dim result As Mono.Cecil.MethodAttributes
         Dim getA, setA, raiseA As Mono.Cecil.MethodAttributes
         Dim getM, setM, raiseM As Mono.Cecil.MethodDefinition
 
         getM = ev.AddMethod
         setM = ev.RemoveMethod
         raiseM = ev.InvokeMethod
 
         Helper.Assert(getM IsNot Nothing OrElse setM IsNot Nothing OrElse raiseM IsNot Nothing)
 
         If getM IsNot Nothing Then
             getA = getM.Attributes
         End If
 
         If setM IsNot Nothing Then
             setA = setM.Attributes
         End If
 
         If raiseM IsNot Nothing Then
             raiseA = raiseM.Attributes
         End If
 
         result = setA Or getA Or raiseA
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3640" endline="3648"><![CDATA[
 
     Shared Function GetPropertyAccess(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetPropertyAttributes([Property])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3649" endline="3657"><![CDATA[
 
     Shared Function GetEventAccess(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetEventAttributes([Event])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3658" endline="3668"><![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Constructor, MemberTypes.Method
                 Return IsAccessible(Context, Caller, DirectCast(Member, Mono.Cecil.MethodReference))
             Case MemberTypes.Property
                 Return IsAccessible(Context, Caller, DirectCast(Member, Mono.Cecil.PropertyReference))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3669" endline="3687"><![CDATA[
 
     Overloads Shared Function GetParameters(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return mR.ResolvedParameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3688" endline="3712"><![CDATA[
 
     ''' <summary>
     ''' Gets the parameters in the definition (not inflated)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function GetOriginalParameters(ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return CecilHelper.FindDefinition(mR).Parameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3713" endline="3716"><![CDATA[
 
     Overloads Shared Function GetParameters(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MethodReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Return Member.ResolvedParameters
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3717" endline="3836"><![CDATA[
 
     ''' <summary>
     ''' Adds all the members to the derived class members, unless they are shadowed or overridden
     ''' </summary>
     ''' <param name="DerivedClassMembers"></param>
     ''' <param name="BaseClassMembers"></param>
     ''' <remarks></remarks>
     Shared Sub AddMembers(ByVal Compiler As Compiler, ByVal Type As Type, ByVal DerivedClassMembers As Generic.List(Of Mono.Cecil.MemberReference), ByVal BaseClassMembers As Mono.Cecil.MemberReference())
         Dim shadowed As New Generic.List(Of String)
         Dim overridden As New Generic.List(Of String)
 
         If BaseClassMembers.Length = 0 Then Return
 
         Helper.Assert(Type IsNot Nothing)
         Dim logging As Boolean
 
         If Type.BaseType IsNot Nothing Then
             logging = False 'Type.BaseType.Name = "Form"
         End If
 
         LogAddMessage(Compiler, "", logging)
 
         If Type.BaseType IsNot Nothing Then
             LogAddMessage(Compiler, String.Format("Adding members to type '{0}' from its base type '{1}'", Type.Name, Type.BaseType.Name), logging)
         Else
             LogAddMessage(Compiler, String.Format("Adding members to type '{0}' from its unknown base type", Type.Name), logging)
         End If
 
         For Each member As Mono.Cecil.MemberReference In DerivedClassMembers
             Select Case CecilHelper.GetMemberType(member)
                 Case MemberTypes.Constructor
                     'Constructors are not added.
                 Case MemberTypes.Event
                     'Events can only be shadows
                     shadowed.Add(member.Name)
                 Case MemberTypes.Field
                     shadowed.Add(member.Name)
                 Case MemberTypes.Method
                     Dim mInfo As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(DirectCast(member, Mono.Cecil.MethodReference))
                     If mInfo.IsHideBySig Then
                         overridden.AddRange(GetOverloadableSignatures(Compiler, mInfo))
                     Else
                         shadowed.Add(mInfo.Name)
                     End If
                 Case MemberTypes.NestedType
                     shadowed.Add(member.Name)
                 Case MemberTypes.Property
                     Dim pInfo As Mono.Cecil.PropertyReference = DirectCast(member, Mono.Cecil.PropertyReference)
                     If CBool(Helper.GetPropertyAttributes(pInfo) And Mono.Cecil.MethodAttributes.HideBySig) Then
                         overridden.AddRange(GetOverloadableSignatures(Compiler, pInfo))
                     Else
                         shadowed.Add(pInfo.Name)
                     End If
                 Case MemberTypes.TypeInfo
                     shadowed.Add(member.Name)
                 Case Else
                     Throw New InternalException("")
             End Select
         Next
 
         For i As Integer = 0 To shadowed.Count - 1
             LogAddMessage(Compiler, "Shadows
             shadowed(i) = shadowed(i).ToLowerInvariant
         Next
         For i As Integer = 0 To overridden.Count - 1
             LogAddMessage(Compiler, "Overridden
             overridden(i) = overridden(i).ToLowerInvariant
         Next
 
         For Each member As Mono.Cecil.MemberReference In BaseClassMembers
             Dim name As String = member.Name.ToLowerInvariant
 
             If shadowed.Contains(name) Then
                 LogAddMessage(Compiler, "Discarded (shadowed)
                 Continue For
             End If
 
 
             Select Case CecilHelper.GetMemberType(member)
                 Case MemberTypes.Constructor
                     LogAddMessage(Compiler, "Discarded (constructor)
                     Continue For 'Constructors are not added
                 Case MemberTypes.Method, MemberTypes.Property
                     Dim signatures As String()
                     Dim found As Boolean
 
                     If IsAccessibleExternal(Compiler, member) = False Then
                         LogAddMessage(Compiler, "Discarted (not accessible)
                         Continue For
                     End If
 
                     found = False
                     signatures = GetOverloadableSignatures(Compiler, member)
                     For Each signature As String In signatures
                         name = signature.ToLowerInvariant
                         If overridden.Contains(name) Then
                             found = True
                             Exit For
                         End If
                     Next
                     If found = True Then
                         LogAddMessage(Compiler, "Discarded (overridden, " & CecilHelper.GetMemberType(member).ToString() & ")
                         Continue For
                     End If
                 Case MemberTypes.Event, MemberTypes.Field, MemberTypes.NestedType, MemberTypes.TypeInfo
                     If IsAccessibleExternal(Compiler, member) = False Then
                         LogAddMessage(Compiler, "Discarted (not accessible)
                         Continue For
                     End If
                 Case Else
                     Throw New InternalException("")
             End Select
 
             'Not shadowed nor overriden
             LogAddMessage(Compiler, "Added (" & CecilHelper.GetMemberType(member).ToString & ")
             DerivedClassMembers.Add(member)
         Next
 
         LogAddMessage(Compiler, "", logging)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3837" endline="3853"><![CDATA[
 
     Shared Function IsHideBySig(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Constructor
                 Return False
             Case MemberTypes.Event, MemberTypes.Field, MemberTypes.NestedType, MemberTypes.TypeInfo
                 Return False
             Case MemberTypes.Property
                 Dim pInfo As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
                 Return CBool(GetPropertyAttributes(pInfo) And Mono.Cecil.MethodAttributes.HideBySig)
             Case MemberTypes.Method
                 Dim mInfo As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference))
                 Return mInfo.IsHideBySig
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3854" endline="3877"><![CDATA[
 
     Shared Function GetOverloadableSignatures(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As String()
         Dim result As New Generic.List(Of String)
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim types() As Mono.Cecil.TypeReference
         Dim sep As String = ""
 
         params = Helper.GetParameters(Compiler, Member)
         types = Helper.GetTypes(params)
 
         Dim signature As String = ""
         For i As Integer = 0 To types.Length - 1
             If CecilHelper.IsByRef(types(i)) Then types(i) = CecilHelper.GetElementType(types(i))
             If params(i).IsOptional Then
                 result.Add(Member.Name & "(" & signature & ")")
             End If
             signature &= sep & types(i).Namespace & "." & types(i).Name
             sep = ", "
         Next
 
         result.Add(Member.Name & "(" & signature & ")")
 
         Return result.ToArray
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3878" endline="3881"><![CDATA[
 
     Shared Function GetCombination(ByVal tp1 As TypeCode, ByVal tp2 As TypeCode) As TypeCombinations
         Return CType(CInt(tp1) << TypeCombinations.SHIFT Or CInt(tp2), TypeCombinations)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3882" endline="3900"><![CDATA[
 
 
     Shared Function ShowClassificationError(ByVal Compiler As Compiler, ByVal Location As Span, ByVal ActualClassification As ExpressionClassification, ByVal Expected As String) As Boolean
         Select Case ActualClassification.Classification
             Case ExpressionClassification.Classifications.Type
                 Dim tp As Mono.Cecil.TypeReference = ActualClassification.AsTypeClassification.Type
                 Return Compiler.Report.ShowMessage(Messages.VBNC30691, Location, tp.Name, tp.Namespace)
             Case ExpressionClassification.Classifications.Value
                 Dim vC As ValueClassification = ActualClassification.AsValueClassification
                 If vC.IsConstant Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30074, Location)
                 Else
                     Helper.AddError(Compiler, Location, "Expected " & Expected & " got " & ActualClassification.Classification.ToString())
                 End If
             Case Else
                 Helper.AddError(Compiler, Location, "Expected " & Expected & " got " & ActualClassification.Classification.ToString())
         End Select
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3901" endline="3916"><![CDATA[
 
     Shared Function GetCoClassType(ByVal Compiler As Compiler, ByVal Type As TypeReference) As TypeReference
         Dim td As TypeDefinition = CecilHelper.FindDefinition(Type)
         Dim result As TypeReference = Nothing
 
         For i As Integer = 0 To td.CustomAttributes.Count - 1
             Dim attrib As CustomAttribute = td.CustomAttributes(i)
             If Helper.CompareType(attrib.AttributeType, Compiler.TypeCache.System_Runtime_InteropServices_CoClassAttribute) = False Then Continue For
             If attrib.Constructor Is Nothing Then Continue For
             If attrib.ConstructorArguments.Count <> 1 Then Continue For
             result = TryCast(attrib.ConstructorArguments(0).Value, TypeReference)
             If result IsNot Nothing Then Exit For
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3917" endline="3962"><![CDATA[
 
     Shared Function GetDominantType(ByVal Compiler As Compiler, ByVal types As Generic.List(Of TypeReference)) As TypeReference
         Dim implicit() As Boolean
         Dim count As Integer
         Dim index As Integer
 
         'Given a set of types, it is often necessary in situations such as type inference to determine the dominant type of the set. 
 
         If types Is Nothing OrElse types.Count = 0 Then Return Nothing
         If types.Count = 1 Then Return types(0)
 
         ReDim implicit(types.Count - 1)
 
         For i As Integer = 0 To implicit.Length - 1
             implicit(i) = True
         Next
 
         'The dominant type of a set of types is determined by first removing any types that one or more other types do not have an implicit conversion to. 
         For i As Integer = 0 To types.Count - 1
             For j As Integer = 0 To types.Count - 1
                 If i = j Then Continue For
                 If Compiler.TypeResolution.IsImplicitlyConvertible(Compiler, types(i), types(j)) = False Then
                     implicit(j) = False
                     Exit For
                 End If
             Next
         Next
 
         count = 0
         For i As Integer = 0 To implicit.Length - 1
             If implicit(i) Then
                 index = i
                 count += 1
             End If
         Next
 
         'If there are no types left at this point, there is no dominant type. 
         If count = 0 Then Return Nothing
 
         'The dominant type is then the most encompassed of the remaining types. 
         If count = 1 Then Return types(index)
 
         'The dominant type is then the most encompassed of the remaining types. 
         'If there is more than one type that is most encompassed, then there is no dominant type. 
         Return GetMostEncompassedType(Compiler, types)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3963" endline="4054"><![CDATA[
 
     Public Shared Function VerifyConstraints(ByVal Context As ParsedObject, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Math.Min(parameters.Count, arguments.Count) - 1
             Dim param As GenericParameter = parameters(i)
             Dim arg As TypeReference = arguments(i)
             Dim gt As GenericParameter = TryCast(arg, GenericParameter)
 
             If param.HasDefaultConstructorConstraint Then
                 If gt IsNot Nothing Then
                     If gt.HasDefaultConstructorConstraint = False AndAlso gt.HasNotNullableValueTypeConstraint = False Then
                         Dim tr As TypeReference = TryCast(param.Owner, TypeReference)
                         If Helper.CompareType(tr, Context.Compiler.TypeCache.System_Nullable1) Then
                             result = Context.Compiler.Report.ShowMessage(Messages.VBNC33101, Context.Location, Helper.ToString(Context, arg))
                         Else
                             result = Context.Compiler.Report.ShowMessage(Messages.VBNC32084, Context.Location, Helper.ToString(Context, arg), param.Name)
                         End If
                         Continue For
                     End If
                 Else
                     Dim ctor As MethodReference = Helper.GetDefaultConstructor(arg)
                     If (ctor Is Nothing OrElse Helper.IsPublic(ctor) = False) AndAlso CecilHelper.IsValueType(arg) = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32083, Context.Location, Helper.ToString(Context, arg), param.Name)
                         Continue For
                     End If
                 End If
             End If
 
             If param.HasNotNullableValueTypeConstraint Then
                 If gt Is Nothing Then
                     If CecilHelper.IsValueType(arg) = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32105, Context.Location, Helper.ToString(Context, arg), param.Name)
                     End If
                 Else
                     If gt.HasNotNullableValueTypeConstraint = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32105, Context.Location, Helper.ToString(Context, arg), param.Name)
                     End If
                 End If
             End If
 
             If param.HasReferenceTypeConstraint Then
                 If gt IsNot Nothing Then
                     If gt.HasReferenceTypeConstraint = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32106, Context.Location, Helper.ToString(Context, arg), param.Name)
                     End If
                 Else
                     If CecilHelper.IsClass(arg) = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32106, Context.Location, Helper.ToString(Context, arg), param.Name)
                     End If
                 End If
             End If
 
             If param.HasConstraints Then
                 For c As Integer = 0 To param.Constraints.Count - 1
                     Dim constr As TypeReference = param.Constraints(i)
 
                     If param.HasNotNullableValueTypeConstraint AndAlso Helper.CompareType(constr, Context.Compiler.TypeCache.System_ValueType) Then Continue For
                     If Helper.CompareType(constr, arg) Then Continue For
 
                     If gt Is Nothing Then
                         If Helper.IsInterface(Context, constr) Then
                             If Helper.DoesTypeImplementInterface(Context, arg, constr) = False Then
                                 result = Context.Compiler.Report.ShowMessage(Messages.VBNC32044, Context.Location, Helper.ToString(Context, arg), Helper.ToString(Context, constr))
                             End If
                         Else
                             If Helper.IsSubclassOf(constr, arg) = False Then
                                 result = Context.Compiler.Report.ShowMessage(Messages.VBNC32044, Context.Location, Helper.ToString(Context, arg), Helper.ToString(Context, constr))
                             End If
                         End If
                     Else
                         Dim found As Boolean = False
 
                         For c2 As Integer = 0 To gt.Constraints.Count - 1
                             If Helper.CompareType(constr, gt.Constraints(c2)) Then
                                 found = True
                                 Exit For
                             End If
                             If Helper.DoesTypeImplementInterface(Context, gt.Constraints(c2), constr) Then
                                 found = True
                                 Exit For
                             End If
                         Next
                         If found = False Then
                             result = Context.Compiler.Report.ShowMessage(Messages.VBNC32044, Context.Location, Helper.ToString(Context, arg), Helper.ToString(Context, constr))
                         End If
                     End If
                 Next
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="27" endline="29"><![CDATA[
     Public Sub New(ByVal Parent As ParsedObject)
     Private m_lstCollections As New Generic.Dictionary(Of String, IndexList)(Helper.StringComparer)
 
     Public Sub New(ByVal Parent As ParsedObject)
         m_Parent = Parent
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="30" endline="34"><![CDATA[
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Parent.Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="35" endline="43"><![CDATA[
     End Property
 
     Public Function GetAllNames() As String()
         Dim result() As String
         ReDim result(m_lstCollections.Count - 1)
         m_lstCollections.Keys.CopyTo(result, 0)
         Array.Sort(result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="44" endline="61"><![CDATA[
 
     Shadows Sub Add(ByVal Base As INameable)
         Dim idxList As IndexList
         'Does name exist already?
         Dim name As String = Base.Name
 
         If name Is Nothing Then Throw New InternalException("Got nothing for base type = " & CObj(Base).GetType().FullName)
 
         If m_lstCollections.ContainsKey(name) Then
             idxList = DirectCast(m_lstCollections.Item(name), IndexList)
         Else 'If not, create a new indexlist
             idxList = New IndexList()
             idxList.Name = name
             m_lstCollections.Add(idxList.Name, idxList)
         End If
         'Add the value
         idxList.Values.Add(Base)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="62" endline="78"><![CDATA[
 
     ''' <summary>
     ''' Looks an list of all TypeBase objects which has the specified Name. 
     '''	If no TypeBase found, returns nothing
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <remarks></remarks>
     Shadows ReadOnly Property Item(ByVal Name As String) As Generic.List(Of INameable)
         Get
             'Name = Name.ToLower
             If m_lstCollections.ContainsKey(Name) Then
                 Return m_lstCollections.Item(Name).Values
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="79" endline="89"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns true if the specified Name is found in this index
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shadows Function ContainsName(ByVal Name As String) As Boolean
         Return m_lstCollections.ContainsKey(Name)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="90" endline="98"><![CDATA[
 
     ReadOnly Property GetAllTypeBases() As ArrayList
         Get
             Dim result As New ArrayList
             For Each i As IndexList In m_lstCollections.Values
                 result.AddRange(i.Values)
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="30" endline="32"><![CDATA[
         Get
             Return m_Message
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="33" endline="38"><![CDATA[
     End Property
 
     Sub New()
         m_Message = "There has been an internal error in the compiler."
         StopOnInternalException()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="39" endline="49"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Location As Span)
         MyBase.new()
         'If Location IsNot Nothing Then
         m_Message = "There has been an internal error in the compiler caused by the line
         'Else
         'm_Message = "There has been an internal error in the compiler."
         'End If
         StopOnInternalException()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="50" endline="60"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As IBaseObject)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="61" endline="71"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As ExpressionClassification)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="72" endline="78"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal InnerException As Exception)
         MyBase.New("", InnerException)
         m_Message = "There has been an internal error in the compiler
 StopOnInternalException()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="79" endline="88"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As BaseObject, ByVal strMsg As String)
         MyBase.new()
         m_Message = "There has been an internal error in the compiler
         If Obj IsNot Nothing Then
             m_Message &= " caused by the line
         End If
 StopOnInternalException()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="89" endline="95"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal strMsg As String)
         MyBase.new()
         m_Message = "There has been an internal error in the compiler
         StopOnInternalException()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="96" endline="105"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub StopOnInternalException()
 #If DEBUG Then
         If recursive Then Return
         recursive = True
         Helper.StopIfDebugging(True)
         recursive = False
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Main.vb" startline="27" endline="96"><![CDATA[
     Shared Function Main(ByVal CmdArgs() As String) As Integer
         Dim start As Date = Date.Now
         Try
             Dim result As Integer = -2
             Dim Compiler As Compiler
 
 #If DEBUG Then
             Try
                 System.Console.SetWindowSize(150, 50)
                 System.Console.ForegroundColor = ConsoleColor.Green
                 System.Console.WriteLine(VB.vbNewLine & New String(" "c, 50) & "DEBUG RUN" & VB.vbNewLine)
                 System.Console.ResetColor()
                 System.Console.SetBufferSize(150, 3000)
             Catch
                 'Ignore all exceptions.
             End Try
 #End If
 
             Compiler = New Compiler()
 
 #If DEBUG Then
             Dim debugwriter As New IO.StringWriter()
             Compiler.Report.Listeners.Add(New System.Diagnostics.TextWriterTraceListener(debugwriter))
 #End If
 
             result = Compiler.Compile(CmdArgs)
 
 #If DEBUG Then
             Global.System.Diagnostics.Debug.WriteLine("")
             Global.System.Diagnostics.Debug.WriteLine( _
             "***************************************** Console output
             Global.System.Diagnostics.Debug.WriteLine(debugwriter.ToString)
             Global.System.Diagnostics.Debug.WriteLine( _
             "*************************************************************************************************** ")
 #End If
 
             Console.WriteLine("Compilation took " & (Date.Now.Subtract(start)).ToString())
             System.Diagnostics.Debug.WriteLine("Compilation took " & (Date.Now.Subtract(start)).ToString())
 #If DEBUG Then
             'Console.WriteLine("With " & GC.CollectionCount(0) & " 0 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(1) & " 1 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(2) & " 2 gen collections")
             'System.Diagnostics.Debug.WriteLine("With " & GC.CollectionCount(0) & " 0 gen collections")
             'System.Diagnostics.Debug.WriteLine("With " & GC.CollectionCount(1) & " 1 gen collections")
             'System.Diagnostics.Debug.WriteLine("With " & GC.CollectionCount(2) & " 2 gen collections")
             '#End If
 #End If
             Return result
         Catch ex As TooManyErrorsException
             Return 1 'An appropiate message has already been shown to the user
         Catch ex As vbncException
             Console.WriteLine(ex.Message & VB.vbNewLine & ex.StackTrace)
             Console.WriteLine("Failed compilation took " & (Date.Now.Subtract(start)).ToString())
             System.Diagnostics.Debug.WriteLine("Failed compilation took " & (Date.Now.Subtract(start)).ToString())
             'Console.WriteLine("With " & GC.CollectionCount(0) & " 0 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(1) & " 1 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(2) & " 2 gen collections")
             Return 1 'The exception has already been shown to the user.
         Catch ex As Exception
             Console.WriteLine(ex.Message & VB.vbNewLine & ex.StackTrace)
             Console.WriteLine("Failed compilation took " & (Date.Now.Subtract(start)).ToString())
             System.Diagnostics.Debug.WriteLine("Failed compilation took " & (Date.Now.Subtract(start)).ToString())
             'Console.WriteLine("With " & GC.CollectionCount(0) & " 0 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(1) & " 1 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(2) & " 2 gen collections")
             Return 1
         End Try
         Helper.Assert(False, "End of program reached!")
         Return 1
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="63" endline="69"><![CDATA[
     Sub New(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference)
     Private m_CacheInsensitive(MemberVisibility.All) As MemberCacheEntries
     Private m_FlattenedCacheInsensitive(MemberVisibility.All) As MemberCacheEntries
     Private m_ShadowedInterfaceMembers As Generic.List(Of Mono.Cecil.MemberReference)
     Private m_Type As Mono.Cecil.TypeReference
     Private m_Types As List(Of Mono.Cecil.TypeReference)
     Private m_Members As List(Of Mono.Collections.Generic.Collection(Of MemberReference))
     Private m_Bases As List(Of MemberCache)
     Private m_LoadedNames(MemberVisibility.All) As System.Collections.Generic.Dictionary(Of String, String)
     Private m_LoadedAll(MemberVisibility.All) As Boolean
 
     Sub New(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference)
         m_Compiler = Compiler
         m_Type = Type
 
         Compiler.TypeManager.MemberCache.Add(Type, Me)
         ClearAll()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="70" endline="92"><![CDATA[
 
 #If DEBUG Then
     Sub DumpFlattenedCache()
         Console.WriteLine("Cache for
         For i As Integer = 0 To m_FlattenedCacheInsensitive.Length - 1
             Dim entries As MemberCacheEntries = m_FlattenedCacheInsensitive(i)
             Dim access As MemberVisibility = CType(i, MemberVisibility)
             If entries Is Nothing Then
                 Console.WriteLine(" Access
             Else
                 Console.WriteLine(" Access
             End If
             Dim keys As New Generic.List(Of String)(entries.Keys)
             keys.Sort()
             For Each str As String In keys
                 Console.WriteLine("  {0}", str)
                 Dim entry As MemberCacheEntry = entries(str)
                 For Each member As Mono.Cecil.MemberReference In entry.Members
                     Console.WriteLine("   " & CecilHelper.GetMemberType(member).ToString & "
                 Next
             Next
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="93" endline="127"><![CDATA[
 #End If
 
     Public Sub ClearAll()
         Dim tG As Mono.Cecil.GenericParameter
 
         If m_Types Is Nothing Then
             m_Types = New List(Of Mono.Cecil.TypeReference)
         Else
             m_Types.Clear()
         End If
 
         tG = TryCast(m_Type, Mono.Cecil.GenericParameter)
         If tG IsNot Nothing Then
             If tG.Constraints.Count = 0 Then
                 m_Types.Add(Compiler.TypeCache.System_Object)
             Else
                 m_Types.AddRange(tG.Constraints)
             End If
         Else
             m_Types.Add(m_Type)
         End If
 
         If m_Members Is Nothing Then
             m_Members = New List(Of Mono.Collections.Generic.Collection(Of MemberReference))
         Else
             m_Members.Clear()
         End If
         For i As Integer = 0 To m_Types.Count - 1
             m_Members.Add(CecilHelper.GetMembers(m_Types(i)))
         Next
 
         For i As Integer = 0 To MemberVisibility.All - 1
             Clear(CType(i, MemberVisibility))
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="128" endline="135"><![CDATA[
 
     Public Sub Clear(ByVal Visibility As MemberVisibility)
         m_CacheInsensitive(Visibility) = Nothing
         m_FlattenedCacheInsensitive(Visibility) = Nothing
         m_LoadedNames(Visibility) = Nothing
         m_LoadedAll(Visibility) = False
         m_ShadowedInterfaceMembers = Nothing
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="136" endline="140"><![CDATA[
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             Return m_Type
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="141" endline="146"><![CDATA[
     End Property
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="147" endline="151"><![CDATA[
     End Property
 
     Public Function GetAllMembers() As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Return m_Members(0)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="152" endline="156"><![CDATA[
 
     Public Function GetAllFlattenedMembers(ByVal Visibility As MemberVisibility) As Generic.List(Of Mono.Cecil.MemberReference)
         If m_LoadedAll(Visibility) = False Then Load(Nothing, Visibility)
         Return m_FlattenedCacheInsensitive(Visibility).GetAllMembers()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="157" endline="183"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Name">Load every member if Name is nothing</param>
     ''' <remarks></remarks>
     Private Sub Load(ByVal Name As String, ByVal Visibility As MemberVisibility)
         If m_LoadedAll(Visibility) Then
             Return
         ElseIf m_LoadedNames(Visibility) Is Nothing Then
             m_LoadedNames(Visibility) = New Dictionary(Of String, String)(Helper.StringComparer)
         ElseIf Name IsNot Nothing AndAlso m_LoadedNames(Visibility).ContainsKey(Name) Then
             Return
         End If
 
         If Name Is Nothing Then Clear(Visibility)
 
         If Name IsNot Nothing Then m_LoadedNames(Visibility).Add(Name, Name)
 
         For i As Integer = 0 To m_Types.Count - 1
             Load(m_Types(i), m_Members(i), Name, Visibility)
         Next
 
         Flatten(Name, Visibility)
 
         If Name Is Nothing Then m_LoadedAll(Visibility) = True
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="184" endline="239"><![CDATA[
 
     Private Sub Load(ByVal Type As Mono.Cecil.TypeReference, ByVal Members As Mono.Collections.Generic.Collection(Of MemberReference), ByVal Name As String, ByVal Visibility As MemberVisibility)
         Dim entries As MemberCacheEntries = Nothing
         Dim isDefinedHere As Boolean = Compiler.Assembly.IsDefinedHere(Type)
         Dim addTo As Boolean
 
         entries = m_CacheInsensitive(Visibility)
         If entries Is Nothing Then
             entries = New MemberCacheEntries()
             m_CacheInsensitive(Visibility) = entries
         End If
 
         For m As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(m)
             Dim cache As MemberCacheEntry = Nothing
             Dim isPublic, isFriend, isProtected, isPrivate As Boolean
 
             If Name IsNot Nothing AndAlso Not Helper.CompareName(Name, member.Name) Then
                 Continue For
             End If
 
             isPublic = Helper.IsPublic(member)
             isPrivate = Helper.IsPrivate(member)
             isFriend = Helper.IsFriendOrProtectedFriend(member)
             isProtected = Helper.IsProtectedOrProtectedFriend(member)
 
             If isDefinedHere = False AndAlso isPublic = False AndAlso isProtected = False Then
                 'Don't load private and friend members in other assemblies.
                 Continue For
             End If
 
             addTo = False
             Select Case Visibility
                 Case MemberVisibility.All
                     addTo = True
                 Case MemberVisibility.Public
                     addTo = isPublic
                 Case MemberVisibility.PublicFriend
                     addTo = isPublic OrElse isFriend
                 Case MemberVisibility.PublicProtected
                     addTo = isPublic OrElse isProtected
                 Case MemberVisibility.PublicProtectedFriend
                     addTo = isPublic OrElse isProtected OrElse isFriend
             End Select
 
             If addTo = False Then
                 Continue For
             End If
 
             If entries.TryGetValue(member.Name, cache) Then
                 cache.Members.Add(member)
             Else
                 entries.Add(New MemberCacheEntry(member))
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="240" endline="251"><![CDATA[
 
     Private Sub Flatten(ByVal Name As String, ByVal Visibility As MemberVisibility)
         Dim bases As List(Of MemberCache) = GetBaseCache()
 
         If bases.Count = 0 Then
             Flatten(Name, Nothing, Visibility)
         Else
             For i As Integer = 0 To bases.Count - 1
                 Flatten(Name, bases(i), Visibility)
             Next
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="252" endline="286"><![CDATA[
 
     Private Sub Flatten(ByVal Name As String, ByVal base As MemberCache, ByVal Visibility As MemberVisibility)
         If base Is Nothing Then
             If Helper.IsInterface(Compiler, m_Type) AndAlso CecilHelper.IsGenericParameter(m_Type) = False Then
                 Dim ifaces As Mono.Collections.Generic.Collection(Of TypeReference)
                 Dim icaches() As MemberCache
 
                 ifaces = CecilHelper.GetInterfaces(m_Type, True)
 
                 ReDim icaches(ifaces.Count - 1)
                 m_ShadowedInterfaceMembers = New Generic.List(Of Mono.Cecil.MemberReference)
 
                 For i As Integer = 0 To ifaces.Count - 1
                     icaches(i) = m_Compiler.TypeManager.GetCache(ifaces(i))
                     icaches(i).Load(Nothing, Visibility)
                     m_ShadowedInterfaceMembers.AddRange(icaches(i).m_ShadowedInterfaceMembers)
                 Next
 
                 For i As Integer = 0 To ifaces.Count - 1
                     FlattenWith(Name, icaches(i), Visibility)
                 Next
                 Dim system_object As MemberCache = m_Compiler.TypeManager.GetCache(Compiler.TypeCache.System_Object)
                 system_object.Load(Name, Visibility)
                 FlattenWith(Name, system_object, Visibility)
             Else
                 m_FlattenedCacheInsensitive = m_CacheInsensitive
             End If
 
             Return
         End If
 
         base.Load(Name, Visibility)
 
         FlattenWith(Name, base, Visibility)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="287" endline="317"><![CDATA[
 
     Private Shared Sub AddToFlattenedCache(ByVal FlattenedCache As MemberCacheEntries, ByVal Name As String, ByVal MemberCache As MemberCache, ByVal Cache As MemberCacheEntries, ByVal Visibility As MemberVisibility)
         Dim cache_entry As MemberCacheEntry = Nothing
         If Name Is Nothing Then
             For Each obj As KeyValuePair(Of String, MemberCacheEntry) In Cache
                 If Not FlattenedCache.TryGetValue(obj.Key, cache_entry) Then
                     cache_entry = New MemberCacheEntry(obj.Value.Name)
                     FlattenedCache.Add(cache_entry)
                 End If
                 For i As Integer = 0 To obj.Value.Members.Count - 1
                     Dim m As MemberReference = obj.Value.Members(i)
                     If cache_entry.Members.Contains(m) = False Then
                         cache_entry.Members.Add(m)
                     End If
                 Next
             Next
         Else
             Dim value As MemberCacheEntry = Nothing
             If Not Cache.TryGetValue(Name, value) Then Return
             If Not FlattenedCache.TryGetValue(Name, cache_entry) Then
                 cache_entry = New MemberCacheEntry(Name)
                 FlattenedCache.Add(cache_entry)
             End If
             For i As Integer = 0 To value.Members.Count - 1
                 Dim m As MemberReference = value.Members(i)
                 If cache_entry.Members.Contains(m) = False Then
                     cache_entry.Members.Add(m)
                 End If
             Next
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="318" endline="383"><![CDATA[
 
     Private Sub AddToCache(ByVal cache As MemberCacheEntry, ByVal Visibility As MemberVisibility, ByVal cache_entries As MemberCacheEntries)
         For i As Integer = 0 To cache.Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = cache.Members(i)
             Dim isPublic, isFriend, isProtected, isPrivate As Boolean
             Dim isHidden As Boolean
             Dim cacheentry As MemberCacheEntry = Nothing
             Dim method As Mono.Cecil.MethodReference
 
             isHidden = False
             If m_ShadowedInterfaceMembers IsNot Nothing AndAlso m_ShadowedInterfaceMembers.Contains(member) Then
                 isHidden = True
             ElseIf Me.IsHidden(member, Visibility) Then
                 isHidden = True
                 If m_ShadowedInterfaceMembers IsNot Nothing Then m_ShadowedInterfaceMembers.Add(member)
             End If
 
             If isHidden Then Continue For
 
             isPublic = Helper.IsPublic(member)
             isPrivate = Helper.IsPrivate(member)
             isFriend = Helper.IsFriendOrProtectedFriend(member)
             isProtected = Helper.IsProtectedOrProtectedFriend(member)
 
             isHidden = True
             Select Case Visibility
                 Case MemberVisibility.All
                     isHidden = False
                 Case MemberVisibility.Public
                     isHidden = Not (isPublic)
                 Case MemberVisibility.PublicFriend
                     isHidden = Not (isPublic OrElse isFriend)
                 Case MemberVisibility.PublicProtected
                     isHidden = Not (isPublic OrElse isProtected)
                 Case MemberVisibility.PublicProtectedFriend
                     isHidden = Not (isPublic OrElse isProtected OrElse isFriend)
             End Select
 
             If isHidden Then Continue For
 
             If cache_entries.TryGetValue(cache.Name, cacheentry) = False Then
                 cache_entries.Add(New MemberCacheEntry(member))
             ElseIf cacheentry.Members.Contains(member) = False Then
                 Dim found As Boolean = False
                 For k As Integer = 0 To cacheentry.Members.Count - 1
                     If cacheentry.Members(k) Is member Then
                         found = True
                         Exit For
                     End If
                 Next
 
                 method = TryCast(member, Mono.Cecil.MethodReference)
                 If Not found AndAlso method IsNot Nothing Then
                     For k As Integer = 0 To cacheentry.Members.Count - 1
                         If Helper.CompareMethod(TryCast(cacheentry.Members(k), Mono.Cecil.MethodReference), method) Then
                             found = True
                             Exit For
                         End If
                     Next
                 End If
                 If Not found Then
                     cacheentry.Members.Add(member)
                 End If
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="384" endline="410"><![CDATA[
 
     Private Sub FlattenWith(ByVal Name As String, ByVal MemberCache As MemberCache, ByVal Visibility As MemberVisibility)
         Dim cache_entries As MemberCacheEntries = Nothing
 
         'Console.WriteLine("{0} FlattenWith
 
         cache_entries = m_FlattenedCacheInsensitive(Visibility)
         If cache_entries Is Nothing Then
             cache_entries = New MemberCacheEntries()
             m_FlattenedCacheInsensitive(Visibility) = cache_entries
         End If
 
         AddToFlattenedCache(cache_entries, Name, MemberCache, m_CacheInsensitive(Visibility), Visibility)
 
         Dim cache2 As MemberCacheEntries
         cache2 = MemberCache.m_FlattenedCacheInsensitive(Visibility)
 
         If Name Is Nothing Then
             For Each cache As MemberCacheEntry In cache2.Values
                 AddToCache(cache, Visibility, cache_entries)
             Next
         Else
             Dim entry As MemberCacheEntry = Nothing
             If Not cache2.TryGetValue(Name, entry) Then Return
             AddToCache(cache2(Name), Visibility, cache_entries)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="411" endline="453"><![CDATA[
 
     Private Function IsHidden(ByVal baseMember As Mono.Cecil.MemberReference, ByVal Visibility As MemberVisibility) As Boolean
         Dim current As MemberCacheEntry
         Dim memberParameterTypes As Mono.Cecil.TypeReference() = Nothing
 
         current = Lookup(baseMember.Name, Visibility, True)
 
         If current Is Nothing Then
             Return False
         End If
 
         For i As Integer = 0 To current.Members.Count - 1
             Dim thisMember As Mono.Cecil.MemberReference = current.Members(i)
             If CecilHelper.GetMemberType(thisMember) <> CecilHelper.GetMemberType(baseMember) Then
                 Return True
             End If
 
             Select Case CecilHelper.GetMemberType(thisMember)
                 Case MemberTypes.Constructor, MemberTypes.Event, MemberTypes.Field, MemberTypes.NestedType, MemberTypes.TypeInfo
                     Return True
                 Case MemberTypes.Property, MemberTypes.Method
                     Dim methodAttributes As Mono.Cecil.MethodAttributes
                     Dim isHideBySig, isVirtual, isNewSlot As Boolean
                     Dim isOverrides As Boolean
 
                     methodAttributes = Helper.GetMethodAttributes(thisMember)
                     isHideBySig = CBool(methodAttributes And Reflection.MethodAttributes.HideBySig)
                     isVirtual = CBool(methodAttributes And Reflection.MethodAttributes.Virtual)
                     isNewSlot = CBool(methodAttributes And Reflection.MethodAttributes.NewSlot)
                     isOverrides = isVirtual AndAlso isNewSlot = False
                     If isHideBySig = False AndAlso isOverrides = False Then
                         Return True
                     End If
                     If memberParameterTypes Is Nothing Then memberParameterTypes = Helper.GetTypes(Helper.GetParameters(m_Compiler, baseMember))
                     If Helper.CompareTypes(Helper.GetTypes(Helper.GetParameters(m_Compiler, thisMember)), memberParameterTypes) Then
                         Return True
                     End If
                 Case Else
                     Throw New InternalException("")
             End Select
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="454" endline="479"><![CDATA[
 
     Private Function GetBaseCache() As List(Of MemberCache)
         Dim base As Mono.Cecil.TypeReference
         Dim cache As MemberCache
 
         If m_Bases IsNot Nothing Then Return m_Bases
 
         m_Bases = New List(Of MemberCache)
 
         For i As Integer = 0 To m_Types.Count - 1
             base = CecilHelper.FindDefinition(m_Types(i)).BaseType
 
             If base Is Nothing Then Continue For
 
             base = CecilHelper.InflateType(base, m_Type)
 
             If m_Compiler.TypeManager.MemberCache.ContainsKey(base) = False Then
                 cache = New MemberCache(m_Compiler, base)
             Else
                 cache = m_Compiler.TypeManager.MemberCache(base)
             End If
             m_Bases.Add(cache)
         Next
 
         Return m_Bases
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="480" endline="490"><![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the flattened cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattened(ByVal Name As String, ByVal From As Mono.Cecil.TypeReference) As MemberCacheEntry
         Return LookupFlattened(Name, Helper.GetVisibility(Compiler, From, m_Type))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="491" endline="499"><![CDATA[
 
     Public Function LookupFlattened(ByVal Name As String, ByVal Visibility As MemberVisibility) As MemberCacheEntry
         Dim result As MemberCacheEntry = Nothing
 
         Load(Name, Visibility)
 
         m_FlattenedCacheInsensitive(Visibility).TryGetValue(Name, result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="500" endline="510"><![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the flattened cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattened(ByVal Name As String) As MemberCacheEntry
         Return LookupFlattened(Name, MemberVisibility.All)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="511" endline="521"><![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function Lookup(ByVal Name As String, ByVal Visibility As MemberVisibility) As MemberCacheEntry
         Return Lookup(Name, Visibility, False)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="522" endline="538"><![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function Lookup(ByVal Name As String, ByVal Visibility As MemberVisibility, ByVal PreventLoad As Boolean) As MemberCacheEntry
         Dim cache_insensitive As MemberCacheEntries = Nothing
         Dim result As MemberCacheEntry = Nothing
 
         If Not PreventLoad Then Load(Name, Visibility)
 
         m_CacheInsensitive(Visibility).TryGetValue(Name, result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="539" endline="550"><![CDATA[
 
     ''' <summary>
     ''' This function returns the members list in the cache, or nothing
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattenedMembers(ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim cache As MemberCacheEntry = LookupFlattened(Name)
         If cache Is Nothing Then Return Nothing
         Return cache.Members
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="551" endline="569"><![CDATA[
 
     ''' <summary>
     ''' This function returns a COPY of the members list in the cache.
     ''' To be avoided if possible.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupMembersFlattened(ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim tmp As MemberCacheEntry
 
         tmp = LookupFlattened(Name)
         If tmp IsNot Nothing Then
             result.AddRange(tmp.Members)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="570" endline="578"><![CDATA[
 
 End Class
 
 Public Class MemberCacheEntries
     Inherits Generic.Dictionary(Of String, MemberCacheEntry)
 
     Overloads Sub Add(ByVal Entry As MemberCacheEntry)
         MyBase.Add(Entry.Name, Entry)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="579" endline="582"><![CDATA[
 
     Sub New()
         MyBase.New(Helper.StringComparer)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="583" endline="590"><![CDATA[
 
     Function GetAllMembers() As Generic.List(Of Mono.Cecil.MemberReference)
         Dim result As New Generic.List(Of Mono.Cecil.MemberReference)
         For Each item As MemberCacheEntry In Me.Values
             result.AddRange(item.Members)
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="591" endline="600"><![CDATA[
 
 End Class
 
 Public Class MemberCacheEntry
     Public Name As String
     Public Members As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
     Sub New(ByVal Name As String)
     Public Members As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
     Sub New(ByVal Name As String)
         Me.Name = Name
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="601" endline="605"><![CDATA[
 
     Sub New(ByVal Member As Mono.Cecil.MemberReference)
     Public Members As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
     Sub New(ByVal Name As String)
         Me.Name = Name
     End Sub
 
     Sub New(ByVal Member As Mono.Cecil.MemberReference)
         Me.Name = Member.Name
         Me.Members.Add(Member)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="61" endline="65"><![CDATA[
         Get
             Dim attr As MessageAttribute
             attr = DirectCast(System.Attribute.GetCustomAttribute(GetType(Messages).GetField(m_Message(0).ToString), GetType(MessageAttribute)), MessageAttribute)
             Return attr.Level
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="66" endline="76"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The actual message itself.
     ''' Might be several messages if this is a multiline message.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property Message() As Messages()
         Get
             Return m_Message
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="77" endline="86"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The location of the code corresponding to the the message.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property Location() As Span
         Get
             Return m_Location
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="87" endline="95"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The parameters of the message(s)
     ''' </summary>
     ReadOnly Property Parameters() As String()()
         Get
             Return m_Parameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="96" endline="108"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     ''' <param name="Message"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = New Messages() {Message}
         Me.m_Location = Location
         Me.m_Parameters = New String()() {}
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="109" endline="118"><![CDATA[
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages(), ByVal Parameters()() As String, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = Message
         Me.m_Location = Location
         Me.m_Parameters = Parameters
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="119" endline="132"><![CDATA[
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages, ByVal Parameters() As String, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = New Messages() {Message}
         Me.m_Location = Location
         If Parameters Is Nothing Then
             Me.m_Parameters = New String()() {New String() {}}
         Else
             Me.m_Parameters = New String()() {Parameters}
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="133" endline="137"><![CDATA[
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="138" endline="178"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Formats the message to a string.
     ''' The returned string might have several lines.
     ''' </summary>
     Overrides Function ToString() As String
         Dim strMessages(), strMessage, strLocation As String
         Dim result As String
 
         Helper.Assert(m_Message IsNot Nothing, "m_Message Is Nothing")
         Helper.Assert(m_Parameters IsNot Nothing, "m_Parameters Is Nothing")
 
         'Get the message string and format it with the message parameters.
         ReDim strMessages(m_Message.GetUpperBound(0))
         For i As Integer = 0 To m_Message.GetUpperBound(0)
             strMessages(i) = Report.LookupErrorCode(m_Message(i))
             Helper.Assert(m_Parameters(i) IsNot Nothing, "m_Parameters(" & i.ToString & ") Is Nothing")
 			If m_Parameters IsNot Nothing AndAlso m_Parameters.Length > i Then
             	strMessages(i) = String.Format(strMessages(i), m_Parameters(i))
 			End If
             If i = 0 Then strMessages(i) = m_Message(i).ToString & "
         Next
         strMessage = Microsoft.VisualBasic.Join(strMessages, Microsoft.VisualBasic.vbNewLine)
 
         'Get the location string
         If Location.HasFile Then
             strLocation = Location.ToString(Compiler)
             result = MESSAGEFORMATWITHLOCATION
         Else
             strLocation = ""
             result = MESSAGEFORMAT
         End If
 
         'Format the entire message.
         result = result.Replace("%LOCATION%", strLocation)
         result = result.Replace("%MESSAGE%", strMessage)
         result = result.Replace("%MESSAGELEVEL%", Level.ToString)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MessageAttribute.vb" startline="36" endline="38"><![CDATA[
         Get
             Return m_Level
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MessageAttribute.vb" startline="39" endline="46"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a new message attribute with the specified message level.
     ''' </summary>
     Sub New(ByVal Level As MessageLevel)
         m_Level = Level
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="38" endline="41"><![CDATA[
     Protected Sub New(ByVal Parent As TypeDeclaration)
         MyBase.new(Parent)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="42" endline="46"><![CDATA[
 
     Protected Sub New(ByVal Parent As PropertyDeclaration)
         MyBase.new(Parent)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="47" endline="51"><![CDATA[
 
     Protected Sub New(ByVal Parent As EventDeclaration)
         MyBase.new(Parent)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="52" endline="58"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Signature IsNot Nothing Then m_Signature.Initialize(Me)
         If m_Code IsNot Nothing Then m_Code.Initialize(Me)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="59" endline="64"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature)
         MyBase.Init(Modifiers, Signature.Name)
         m_Signature = Signature
         Helper.Assert(m_Signature IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="65" endline="70"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature, ByVal Code As CodeBlock)
         Me.Init(Modifiers, Signature)
         m_Code = Code
         Helper.Assert(m_Signature IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="71" endline="97"><![CDATA[
 
     Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_CecilBuilder Is Nothing Then
             m_CecilBuilder = New Mono.Cecil.MethodDefinition(Name, 0, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void))
             m_CecilBuilder.Annotations.Add(Compiler, Me)
         End If
         m_CecilBuilder.Name = Name
         m_CecilBuilder.HasThis = Not Me.IsShared
 
         If Signature IsNot Nothing AndAlso Signature.Parameters IsNot Nothing Then
             ReturnType = m_Signature.ReturnType
             If Signature.Parameters IsNot Nothing Then
                 For i As Integer = 0 To Signature.Parameters.Count - 1
                     Signature.Parameters(i).UpdateDefinition()
                 Next
             End If
         End If
 
         MethodAttributes = Helper.GetAttributes(Me)
         If IsExternalDeclaration Then
             MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.PreserveSig
         Else
             MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="98" endline="108"><![CDATA[
 
     Public ReadOnly Property IsExternalDeclaration() As Boolean
         Get
             If TypeOf Me Is ExternalSubDeclaration Then Return True
             If CustomAttributes Is Nothing Then Return False
             For i As Integer = 0 To CustomAttributes.Count - 1
                 If CustomAttributes(i).ResolvedType Is Nothing Then Continue For
                 If Helper.CompareType(CustomAttributes(i).ResolvedType, Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then Return True
             Next
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="109" endline="174"><![CDATA[
     End Property
 
     Private Function DefineSecurityDeclarations() As Boolean
         Dim result As Boolean = True
         Dim checkedAll As Boolean = True
 
         If m_DefinedSecurityDeclarations Then Return True
 
         If CustomAttributes Is Nothing Then Return True
 
 
         For i As Integer = 0 To CustomAttributes.Count - 1
             If CustomAttributes(i).ResolvedType Is Nothing Then
                 checkedAll = False
                 Exit For
             End If
         Next
 
         If Not checkedAll Then Return True
 
         For i As Integer = CustomAttributes.Count - 1 To 0 Step -1
             Dim attrib As Attribute = CustomAttributes(i)
 
             If Not Helper.IsSubclassOf(Compiler.TypeCache.System_Security_Permissions_SecurityAttribute, attrib.ResolvedType) Then Continue For
 
             Try
                 Dim sec As Mono.Cecil.SecurityDeclaration
                 Dim secAtt As Mono.Cecil.SecurityAttribute
                 Dim attribInstantiation As Object = Nothing
                 Dim attribInstance As SecurityAttribute
                 Dim attribAction As Mono.Cecil.SecurityAction
                 Dim attribPermissionSetAttribute As PermissionSetAttribute
 
                 If attrib.Instantiate(Messages.VBNC30128, attribInstantiation) = False Then
                     'Attribute.Instantiate prints an error message
                     result = False
                     Continue For
                 End If
 
                 attribInstance = TryCast(attribInstantiation, SecurityAttribute)
                 If attribInstance Is Nothing Then
                     Compiler.Report.ShowMessage(Messages.VBNC30128, attrib.Location, "Security attribute does not inherit from System.Security.Permissions.SecurityAttribute")
                     result = False
                     Continue For
                 End If
 
                 attribAction = CType(attribInstance.Action, Mono.Cecil.SecurityAction)
                 attribPermissionSetAttribute = TryCast(attribInstance, PermissionSetAttribute)
 
                 sec = New Mono.Cecil.SecurityDeclaration(attribAction)
                 secAtt = attrib.GetSecurityAttribute()
                 sec.SecurityAttributes.Add(secAtt)
                 CecilBuilder.SecurityDeclarations.Add(sec)
                 CustomAttributes.Remove(attrib)
                 CecilBuilder.CustomAttributes.Remove(attrib.CecilBuilder)
             Catch ex As Exception
                 Compiler.Report.ShowMessage(Messages.VBNC30128, attrib.Location, ex.Message)
                 result = False
             End Try
 
         Next
 
         m_DefinedSecurityDeclarations = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="175" endline="196"><![CDATA[
 
     ReadOnly Property HasSecurityCustomAttribute() As Boolean
         Get
             Dim checkedAll As Boolean = True
 
             If CustomAttributes Is Nothing Then Return False
 
             If m_HasSecurityCustomAttribute.HasValue Then Return m_HasSecurityCustomAttribute.Value
 
             For i As Integer = 0 To CustomAttributes.Count - 1
                 If CustomAttributes(i).ResolvedType Is Nothing Then
                     checkedAll = False
                 ElseIf Helper.IsSubclassOf(Compiler.TypeCache.System_Security_Permissions_SecurityAttribute, CustomAttributes(i).ResolvedType) Then
                     m_HasSecurityCustomAttribute = True
                     Return True
                 End If
             Next
 
             If checkedAll Then m_HasSecurityCustomAttribute = False
 
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="197" endline="202"><![CDATA[
     End Property
 
     Property ReturnType() As Mono.Cecil.TypeReference
         Get
             Return m_CecilBuilder.ReturnType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="203" endline="205"><![CDATA[
         Set(ByVal value As Mono.Cecil.TypeReference)
             m_CecilBuilder.ReturnType = Helper.GetTypeOrTypeReference(Compiler, value)
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="206" endline="211"><![CDATA[
     End Property
 
     Property MethodAttributes() As Mono.Cecil.MethodAttributes
         Get
             Return m_CecilBuilder.Attributes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="212" endline="218"><![CDATA[
         Set(ByVal value As Mono.Cecil.MethodAttributes)
             If (value And Mono.Cecil.MethodAttributes.MemberAccessMask) = 0 Then
                 m_CecilBuilder.Attributes = value Or m_CecilBuilder.Attributes
             Else
                 m_CecilBuilder.Attributes = value Or (m_CecilBuilder.Attributes And Not Mono.Cecil.MethodAttributes.MemberAccessMask)
             End If
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="219" endline="224"><![CDATA[
     End Property
 
     Property MethodImplAttributes() As Mono.Cecil.MethodImplAttributes Implements IMethod.MethodImplementationFlags
         Get
             Return m_CecilBuilder.ImplAttributes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="225" endline="227"><![CDATA[
         Set(ByVal value As Mono.Cecil.MethodImplAttributes)
             m_CecilBuilder.ImplAttributes = value Or m_CecilBuilder.ImplAttributes
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="228" endline="233"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property MemberDescriptor() As Mono.Cecil.MemberReference
         Get
             Return Me.CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="234" endline="239"><![CDATA[
     End Property
 
     Property Code() As CodeBlock
         Get
             Return m_Code
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="240" endline="242"><![CDATA[
         Set(ByVal value As CodeBlock)
             m_Code = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="243" endline="248"><![CDATA[
     End Property
 
     Public ReadOnly Property DefaultReturnVariable() As Mono.Cecil.Cil.VariableDefinition Implements IMethod.DefaultReturnVariable
         Get
             Return m_DefaultReturnVariable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="249" endline="256"><![CDATA[
     End Property
 
     Public ReadOnly Property GetParameters() As Mono.Cecil.ParameterDefinition() Implements IMethod.GetParameters
         Get
             Helper.Assert(m_Signature IsNot Nothing)
             Helper.Assert(m_Signature.Parameters IsNot Nothing)
             Return m_Signature.Parameters.AsParameterInfo
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="257" endline="262"><![CDATA[
     End Property
 
     Public Overridable ReadOnly Property HandlesOrImplements() As HandlesOrImplements Implements IMethod.HandlesOrImplements
         Get
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="263" endline="268"><![CDATA[
     End Property
 
     Public ReadOnly Property HasReturnValue() As Boolean Implements IMethod.HasReturnValue
         Get
             Return TypeOf m_Signature Is FunctionSignature
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="269" endline="274"><![CDATA[
     End Property
 
     Public ReadOnly Property CecilBuilder() As Mono.Cecil.MethodDefinition Implements IMethod.CecilBuilder
         Get
             Return m_CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="275" endline="292"><![CDATA[
     End Property
 
     ReadOnly Property HasMethodBody() As Boolean
         Get
             Dim result As Boolean
 
             If TypeOf Me Is ExternalSubDeclaration Then Return False
 
             result = CBool(MethodAttributes And Mono.Cecil.MethodAttributes.Abstract) = False AndAlso CBool(MethodImplAttributes And Mono.Cecil.MethodImplAttributes.Runtime) = False
 
             If result Then
                 If Me.CustomAttributes IsNot Nothing AndAlso Me.CustomAttributes.IsDefined(Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
                     result = False
                 End If
             End If
 
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="293" endline="298"><![CDATA[
     End Property
 
     Public ReadOnly Property Signature() As SubSignature Implements IMethod.Signature
         Get
             Return m_Signature
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="299" endline="314"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences AndAlso result
         If result = False Then Return result
 
         ReturnType = m_Signature.ReturnType
 
         If m_Code IsNot Nothing Then result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="315" endline="322"><![CDATA[
 
     Public Overridable Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         result = m_Signature.Parameters.ResolveParameters(Info, True) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="323" endline="336"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         result = ResolveOverrides() AndAlso result
         result = m_Signature.ResolveCode(Info) AndAlso result
 
         If m_Code IsNot Nothing Then
             result = m_Code.ResolveCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344"><![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="345" endline="366"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = DefineOverrides() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Me.IsPropertyHandlesHandler Then
             result = GeneratePropertyHandlers() AndAlso result
         ElseIf Me.HasMethodBody Then
             Helper.Assert(m_Code IsNot Nothing)
 
             'Create the default return variable
             If Me.HasReturnValue Then
                 m_DefaultReturnVariable = Emitter.DeclareLocal(Info, ReturnType)
             End If
 
             result = m_Code.GenerateCode(Me) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="367" endline="371"><![CDATA[
 
     ReadOnly Property MethodOverride() As Mono.Cecil.MethodReference
         Get
             Return m_MethodOverrides
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="372" endline="378"><![CDATA[
     End Property
 
     Overridable Function ResolveOverrides() As Boolean
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="379" endline="388"><![CDATA[
 
     Overridable Function DefineOverrides() As Boolean
         Dim result As Boolean = True
 
         If m_MethodOverrides IsNot Nothing Then
             Throw New NotImplementedException
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="389" endline="396"><![CDATA[
 
     Private Function IsPropertyHandlesHandler() As Boolean
         Dim propD As PropertyDeclaration
 
         propD = TryCast(Parent, PropertyDeclaration)
         If propD Is Nothing Then Return False
         Return propD.HandlesField IsNot Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="397" endline="459"><![CDATA[
 
     Private Function GeneratePropertyHandlers() As Boolean
         Dim result As Boolean = True
         Dim propD As PropertyDeclaration
 
         propD = DirectCast(Parent, PropertyDeclaration)
 
         Dim isGet As Boolean
         Dim isSet As Boolean
         isGet = TypeOf Me Is PropertyGetDeclaration
         isSet = TypeOf Me Is PropertySetDeclaration
 
         Helper.Assert(isGet Xor isSet)
 
         Dim info As New EmitInfo(Me)
         Dim meType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, Me.FindFirstParent(Of TypeDeclaration).CecilType)
         If isGet Then
             If Me.IsShared = False Then
                 Emitter.EmitLoadMe(info, meType)
             End If
             Emitter.EmitLoadVariable(info, propD.HandlesField.FieldBuilder)
             Emitter.EmitRet(info)
         Else
             Dim endRemoveLabel As Label
             Dim endAddLabel As Label
 
             endRemoveLabel = Emitter.DefineLabel(info)
             endAddLabel = Emitter.DefineLabel(info)
 
             'Remove old handlers
             If Me.IsShared = False Then
                 Emitter.EmitLoadMe(info, meType)
             End If
             Emitter.EmitLoadVariable(info, propD.HandlesField.FieldBuilder)
             Emitter.EmitBranchIfFalse(info, endRemoveLabel)
             For Each item As AddOrRemoveHandlerStatement In propD.Handlers
                 result = item.GenerateCode(info, False) AndAlso result
             Next
             Emitter.MarkLabel(info, endRemoveLabel)
 
             'Store the variable
             If Me.IsShared = False Then
                 Emitter.EmitLoadMe(info, meType)
             End If
             Emitter.EmitLoadParameter(info, Me.GetParameters()(0))
             Emitter.EmitStoreField(info, propD.HandlesField.FieldBuilder)
 
             'Add new handlers
             If Me.IsShared = False Then
                 Emitter.EmitLoadMe(info, meType)
             End If
             Emitter.EmitLoadVariable(info, propD.HandlesField.FieldBuilder)
             Emitter.EmitBranchIfFalse(info, endAddLabel)
             For Each item As AddOrRemoveHandlerStatement In propD.Handlers
                 result = item.GenerateCode(info, True) AndAlso result
             Next
             Emitter.MarkLabel(info, endAddLabel)
 
             Emitter.EmitRet(info)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="27" endline="29"><![CDATA[
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="30" endline="34"><![CDATA[
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="35" endline="41"><![CDATA[
     End Property
 
     ReadOnly Property Code() As System.Text.StringBuilder
         Get
             If m_Code Is Nothing Then m_Code = New System.Text.StringBuilder()
             Return m_Code
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="42" endline="48"><![CDATA[
     End Property
 
     ReadOnly Property ProjectCode() As System.Text.StringBuilder
         Get
             If m_ProjectCode Is Nothing Then m_ProjectCode = New System.Text.StringBuilder
             Return m_ProjectCode
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="49" endline="154"><![CDATA[
     End Property
 
     Function Generate() As Boolean
         Dim result As Boolean = True
         Dim _MyTypeDefine As Define
         Dim _MyType As String
 
         If String.IsNullOrEmpty(Compiler.CommandLine.VBRuntime) Then Return result
 
         _MyTypeDefine = Compiler.CommandLine.Define("_MYTYPE")
         If _MyTypeDefine Is Nothing Then
             _MyType = String.Empty
         Else
             _MyType = _MyTypeDefine.ValueAsString
         End If
 
         If _MyType = String.Empty Then
             m_MyType = MyTypes.Windows
         ElseIf [Enum].IsDefined(GetType(MyTypes), _MyType) Then
             m_MyType = CType([Enum].Parse(GetType(MyTypes), _MyType, False), MyTypes)
         Else
             m_MyType = MyTypes.Empty
         End If
 
         If m_MyType = MyTypes.Empty Then
             Return True
         End If
 
         If Compiler.CommandLine.RootNamespace <> "" Then
             m_GlobalMy = "Global." & Compiler.CommandLine.RootNamespace & ".My"
         Else
             m_GlobalMy = "Global" & ".My"
         End If
 
         result = GenerateMyApplication() AndAlso result
         result = GenerateMyComputer() AndAlso result
         result = GenerateMyForms() AndAlso result
         result = GenerateMyLog() AndAlso result
         result = GenerateMyRequest() AndAlso result
         result = GenerateMyResources() AndAlso result
         result = GenerateMyResponse() AndAlso result
         result = GenerateMySettings() AndAlso result
         result = GenerateMyUser() AndAlso result
         result = GenerateMyWebServices() AndAlso result
 
         If Code.Length > 0 OrElse m_MyType = MyTypes.Custom Then
             Dim projectPrepend As New System.Text.StringBuilder()
             projectPrepend.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
             projectPrepend.AppendLine("    <Global.Microsoft.VisualBasic.HideModuleName> _")
             projectPrepend.AppendLine("    Friend Module MyProject")
             projectPrepend.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
             projectPrepend.AppendLine("        <Global.System.Runtime.InteropServices.ComVisible(False)> _")
             projectPrepend.AppendLine("        Friend NotInheritable Class ThreadSafeObjectProvider(Of T As New)")
             projectPrepend.AppendLine("            ")
             projectPrepend.AppendLine("            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
             projectPrepend.AppendLine("            <Global.System.Diagnostics.DebuggerHidden> _")
             projectPrepend.AppendLine("            Public Sub New()")
             projectPrepend.AppendLine("            End Sub")
             projectPrepend.AppendLine("            ")
             If Compiler.CommandLine.Target = CommandLine.Targets.Library Then
                 projectPrepend.AppendLine("            Private ReadOnly m_Context As New Global.Microsoft.VisualBasic.MyServices.Internal.ContextValue(Of T)")
                 projectPrepend.AppendLine("            Friend ReadOnly Property GetInstance As T")
                 projectPrepend.AppendLine("                Get")
                 projectPrepend.AppendLine("                    Dim tmp as T = m_Context.Value")
                 projectPrepend.AppendLine("                    If tmp Is Nothing Then")
                 projectPrepend.AppendLine("                        tmp = Global.System.Activator.CreateInstance(Of T)")
                 projectPrepend.AppendLine("                        m_Context.Value = tmp")
                 projectPrepend.AppendLine("                    End If")
                 projectPrepend.AppendLine("                    Return tmp")
                 projectPrepend.AppendLine("                End Get")
                 projectPrepend.AppendLine("            End Property")
             Else
                 projectPrepend.AppendLine("            <Global.System.Runtime.CompilerServices.CompilerGenerated> _")
                 projectPrepend.AppendLine("            <Global.System.ThreadStatic> _")
                 projectPrepend.AppendLine("            Private Shared m_ThreadStaticValue As T")
                 projectPrepend.AppendLine("            ")
                 projectPrepend.AppendLine("            Friend ReadOnly Property GetInstance As T")
                 projectPrepend.AppendLine("                Get")
                 projectPrepend.AppendLine("                    If (m_ThreadStaticValue Is Nothing) Then")
                 projectPrepend.AppendLine("                        m_ThreadStaticValue = Global.System.Activator.CreateInstance(Of T)")
                 projectPrepend.AppendLine("                    End If")
                 projectPrepend.AppendLine("                    Return m_ThreadStaticValue")
                 projectPrepend.AppendLine("                End Get")
                 projectPrepend.AppendLine("            End Property")
             End If
             projectPrepend.AppendLine("        End Class")
             ProjectCode.Insert(0, projectPrepend)
             ProjectCode.AppendLine("    End Module")
 
             Code.Insert(0, "Namespace My" & Environment.NewLine)
             Code.Append(ProjectCode)
             Code.AppendLine("End Namespace")
 
             Code.Replace("$GLOBALMY$", m_GlobalMy)
 
 #If DEBUG AndAlso False Then
             Dim counter As Integer = 1
             For Each line As String In VB.Split(Code.ToString, VB.vbNewLine)
                 Compiler.Report.WriteLine(counter & "
                 counter += 1
             Next
 #End If
             Compiler.CommandLine.Files.Add(New CodeFile("<MyGenerator>", "<MyGenerator>", Compiler, Code.ToString))
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="155" endline="216"><![CDATA[
 
     Function GenerateMyApplication() As Boolean
         Dim result As Boolean = True
         Dim _MyApplicationDefine As Define
         Dim _MyApplication As String
 
         _MyApplicationDefine = Compiler.CommandLine.Define("_MYAPPLICATIONTYPE")
         If _MyApplicationDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain
                     _MyApplication = "Console"
                 Case MyTypes.Windows
                     _MyApplication = "Windows"
                 Case MyTypes.WindowsForms
                     _MyApplication = "WindowsForms"
                 Case Else
                     _MyApplication = String.Empty
             End Select
         Else
             _MyApplication = _MyApplicationDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyApplication
             Case "Console"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.ApplicationBase"
             Case "WindowsForms"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase"
             Case Else
                 Return True
         End Select
 
         Code.AppendLine("    <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
         Code.AppendLine("    Friend Class MyApplication")
         Code.Append("        Inherits ") 
         'Code.AppendLine("        Public Sub New()")
         'Code.AppendLine("        End Sub")
         If Compiler.CommandLine.Target = CommandLine.Targets.Winexe AndAlso baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" Then
             Code.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _")
             Code.AppendLine("        <Global.System.Diagnostics.DebuggerHidden()> _")
             Code.AppendLine("        <Global.System.STAThread()> _")
             Code.AppendLine("        Friend Shared Sub Main(ByVal Args As String())")
             Code.AppendLine("            Global.System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering)")
             Code.AppendLine("            $GLOBALMY$.MyProject.Application.Run(Args)")
             Code.AppendLine("        End Sub")
         End If
         Code.AppendLine("    End Class")
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_AppObjectProvider As ThreadSafeObjectProvider(Of $GLOBALMY$.MyApplication) = New ThreadSafeObjectProvider(Of $GLOBALMY$.MyApplication)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Application As $GLOBALMY$.MyApplication")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_AppObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="217" endline="256"><![CDATA[
 
     Function GenerateMyUser() As Boolean
         Dim result As Boolean = True
         Dim _MyUserDefine As Define
         Dim _MyUser As String
 
         _MyUserDefine = Compiler.CommandLine.Define("_MYUSERTYPE")
         If _MyUserDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms
                     _MyUser = "Windows"
                 Case MyTypes.Web, MyTypes.WebControl
                     _MyUser = "Web"
                 Case Else
                     _MyUser = String.Empty
             End Select
         Else
             _MyUser = _MyUserDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyUser
             Case "Web"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WebUser"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.User"
             Case Else
                 Return True
         End Select
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_UserObjectProvider As ThreadSafeObjectProvider(Of Z) = New ThreadSafeObjectProvider(Of Z)".Replace("Z", baseClass))
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.User"")> _")
         ProjectCode.Append("        Friend Shared ReadOnly Property User As ") 
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_UserObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="257" endline="354"><![CDATA[
 
     Function GenerateMyForms() As Boolean
         Dim result As Boolean = True
         Dim _MyFormsDefine As Define
         Dim _MyForms As Boolean
 
         _MyFormsDefine = Compiler.CommandLine.Define("_MYFORMS")
         If _MyFormsDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.WindowsFormsWithCustomSubMain, MyTypes.WindowsForms
                     _MyForms = True
                 Case Else
                     _MyForms = False
             End Select
         Else
             _MyForms = CBool(_MyFormsDefine.Value)
         End If
 
         If Not _MyForms Then Return True
 
         Compiler.CommandLine.References.Add("System.Windows.Forms.dll")
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Windows.Forms.Form"", ""Create__Instance__"", ""Dispose__Instance__"", ""My.MyProject.Forms"")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyForms" & VB.vbNewLine & _
        "            <Global.System.ThreadStatic> _" & VB.vbNewLine & _
        "            Private Shared m_FormBeingCreated As Global.System.Collections.Hashtable" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As {Global.System.Windows.Forms.Form, New})(ByVal Instance As T) As T" & VB.vbNewLine & _
        "                If Instance IsNot Nothing AndAlso Instance.IsDisposed = False" & VB.vbNewLine & _
        "                    Return Instance" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                Dim TType As Type = GetType(T)" & VB.vbNewLine & _
        "                If m_FormBeingCreated Is Nothing Then" & VB.vbNewLine & _
        "                    m_FormBeingCreated = New Global.System.Collections.Hashtable()" & VB.vbNewLine & _
        "                ElseIf m_FormBeingCreated.ContainsKey(TType) Then" & VB.vbNewLine & _
        "                    Throw New InvalidOperationException(""There is a reference to a default instance from the constructor of a form, which leads to infinite recursion. Please refer to the form itself using 'Me' from within the constructor."")" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                m_FormBeingCreated.Add(TType, Nothing)" & VB.vbNewLine & _
        "                Try" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)()" & VB.vbNewLine & _
        "                Catch ex As Global.System.Reflection.TargetInvocationException" & VB.vbNewLine & _
        "                    Throw New Global.System.InvalidOperationException(""See inner exception"", ex.InnerException)" & VB.vbNewLine & _
        "                Finally" & VB.vbNewLine & _
        "                    m_FormBeingCreated.Remove(TType)" & VB.vbNewLine & _
        "                End Try" & VB.vbNewLine & _
        "                Return Nothing" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T As Global.System.Windows.Forms.Form)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance.Dispose()" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyForms)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared m_MyFormsObjectProvider As ThreadSafeObjectProvider(Of MyForms) = New ThreadSafeObjectProvider(Of MyForms)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Forms"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Forms As MyForms")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyFormsObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="355" endline="434"><![CDATA[
 
     Function GenerateMyWebServices() As Boolean
         Dim result As Boolean = True
         Dim _MyWebServicesDefine As Define
         Dim _MyWebServices As Boolean
 
         _MyWebServicesDefine = Compiler.CommandLine.Define("_MYWEBSERVICES")
         If _MyWebServicesDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms, MyTypes.WebControl
                     _MyWebServices = True
                 Case Else
                     _MyWebServices = False
             End Select
         Else
             _MyWebServices = CBool(_MyWebServicesDefine.Value)
         End If
 
         If Not _MyWebServices Then Return True
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Web.Services.Protocols.SoapHttpClientProtocol"", ""Create__Instance__"", ""Dispose__Instance__"", """")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyWebServices" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As New)(ByVal instance As T) As T" & VB.vbNewLine & _
        "                If (instance Is Nothing) Then" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                Return instance" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyWebServices)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_MyWebServicesObjectProvider As ThreadSafeObjectProvider(Of MyWebServices) = New ThreadSafeObjectProvider(Of MyWebServices)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.WebServices"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property WebServices As MyWebServices")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyWebServicesObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="435" endline="485"><![CDATA[
 
     Sub GenerateGroupCollectionClass(ByVal TypeName As String, ByVal TypeToCollect As String)
         Dim code As String = VB.vbNewLine & _
         "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "        <Global.Microsoft.VisualBasic.MyGroupCollection(""{1}"", ""Create__Instance__"", ""Dispose__Instance__"", """")> _" & VB.vbNewLine & _
         "        Friend NotInheritable Class {0}" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            Public Sub New()" & VB.vbNewLine & _
         "            End Sub" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            Private Shared Function Create__Instance__(Of T As New)(ByVal instance As T) As T" & VB.vbNewLine & _
         "                If (instance Is Nothing) Then" & VB.vbNewLine & _
         "                    Return Global.System.Activator.CreateInstance(Of T)" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "                Return instance" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            Private Sub Dispose__Instance__(Of T)(ByRef instance As T)" & VB.vbNewLine & _
         "                instance = CType(Nothing, T)" & VB.vbNewLine & _
         "            End Sub" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
         "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
         "             Return MyBase.GetHashCode" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
         "                Return GetType(MyWebServices)" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
         "                Return MyBase.ToString" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "        End Class" & VB.vbNewLine & _
         ""
         ProjectCode.Append(String.Format(code, TypeName, TypeToCollect))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="486" endline="507"><![CDATA[
 
     Function GenerateMyLog() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        Private Shared ReadOnly m_LogObjectProvider As ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog) = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)" & VB.vbNewLine & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application.Log"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Log As Global.Microsoft.VisualBasic.Logging.AspLog" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Return MyProject.m_LogObjectProvider.GetInstance" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         'ProjectCodeCctor.AppendLine("            m_LogObjectProvider = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="508" endline="558"><![CDATA[
 
     Function GenerateMyComputer() As Boolean
         Dim result As Boolean = True
         Dim _MyComputerDefine As Define
         Dim _MyComputer As String
 
         _MyComputerDefine = Compiler.CommandLine.Define("_MYCOMPUTERTYPE")
         If _MyComputerDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms
                     _MyComputer = "Windows"
                 Case MyTypes.Web, MyTypes.WebControl
                     _MyComputer = "Web"
                 Case Else
                     _MyComputer = String.Empty
             End Select
         Else
             _MyComputer = _MyComputerDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyComputer
             Case "Web"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.ServerComputer"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.Computer"
             Case Else
                 Return True
         End Select
 
         Code.AppendLine("    <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
         Code.AppendLine("    Friend Class MyComputer")
         Code.Append("        Inherits ") 
         Code.AppendLine("        <Global.System.Diagnostics.DebuggerHidden()> _")
         Code.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("        Public Sub New()")
         Code.AppendLine("        End Sub")
         Code.AppendLine("    End Class")
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_ComputerObjectProvider As ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer) = New ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Computer"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Computer As $GLOBALMY$.MyComputer")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_ComputerObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="559" endline="583"><![CDATA[
 
     Function GenerateMyRequest() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Request"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Request As Global.System.Web.HttpRequest" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Request" & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="584" endline="589"><![CDATA[
 
     Function GenerateMyResources() As Boolean
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="590" endline="614"><![CDATA[
 
     Function GenerateMyResponse() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Response"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Response As Global.System.Web.HttpResponse" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Response    " & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="615" endline="620"><![CDATA[
 
     Function GenerateMySettings() As Boolean
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="28" endline="30"><![CDATA[
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="31" endline="33"><![CDATA[
         Set(ByVal value As String)
             m_Name = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="34" endline="39"><![CDATA[
     End Property
 
     ReadOnly Property [Global]() As Boolean
         Get
             Return m_Global
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="40" endline="44"><![CDATA[
     End Property
 
     Protected Sub New(ByVal Parent As BaseObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="45" endline="57"><![CDATA[
 
     Sub New(ByVal Parent As BaseObject, ByVal Previous As [Namespace], ByVal Name As String)
         MyBase.New(Parent)
         If Previous Is Nothing Then Throw New ArgumentNullException("Namespace")
 
         If TypeOf Previous Is GlobalNamespace Then
             m_Name = Name
             m_Global = True
         Else
             m_Name = Previous.Name & "." & Name
             m_Global = Previous.Global
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="58" endline="64"><![CDATA[
 
     Sub New(ByVal Parent As BaseObject, ByVal Name As String, ByVal [Global] As Boolean)
         MyBase.New(Parent)
         If Name = "" AndAlso [Global] = False Then Throw New ArgumentNullException("Name")
         m_Name = Name
         m_Global = [Global]
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="65" endline="72"><![CDATA[
 
     Overrides Function ToString() As String
         If m_Global Then
             Return "Global." & m_Name
         Else
             Return m_Name
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="73" endline="81"><![CDATA[
 
     Shared Operator &(ByVal ns As [Namespace], ByVal str As String) As [Namespace]
         If ns Is Nothing Then Throw New InternalException("")
         If TypeOf ns Is GlobalNamespace Then
             Return New [Namespace](ns.Parent, str, True)
         Else
             Return New [Namespace](ns.Parent, ns, str)
         End If
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="82" endline="89"><![CDATA[
 
     Shared Operator &(ByVal str As String, ByVal ns As [Namespace]) As [Namespace]
         If ns.Global Then
             Throw New InternalException("")
         Else
             Return New [Namespace](ns.Parent, str & "." & ns.ToString, False)
         End If
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="90" endline="104"><![CDATA[
 
     Function StartsWith(ByVal str As String) As Boolean
         Helper.Assert(m_Name IsNot Nothing AndAlso m_Name <> "")
         Helper.Assert(str IsNot Nothing AndAlso str <> "")
         If str.Length <= m_Name.Length Then
             If m_Global AndAlso IsGlobal(str) Then
                 str = RemoveGlobal(str)
                 Return Helper.CompareName(str, m_Name.Substring(0, str.Length))
             Else
                 Return Helper.CompareName(str, m_Name.Substring(0, str.Length))
             End If
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="105" endline="111"><![CDATA[
 
     Overloads Function Equals(ByVal A As String, ByVal B As String) As Boolean
         If A.Length + B.Length + 1 <> m_Name.Length Then Return False
         If m_Name.StartsWith(A, Helper.StringComparison) = False Then Return False
         If m_Name.EndsWith(B, Helper.StringComparison) = False Then Return False
         Return m_Name(A.Length) = "."c
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="112" endline="123"><![CDATA[
 
     Overloads Function Equals(ByVal str As String) As Boolean
         If IsGlobal(str) Then
             If Me.Global = False Then
                 Return False
             Else
                 Return Helper.CompareName(RemoveGlobal(str), Me.Name)
             End If
         Else
             Return Helper.CompareName(str, Me.Name)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="124" endline="127"><![CDATA[
 
     Shared Operator =(ByVal ns As [Namespace], ByVal str As String) As Boolean
         Return ns.Equals(str)
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="128" endline="131"><![CDATA[
 
     Shared Operator <>(ByVal ns As [Namespace], ByVal str As String) As Boolean
         Return Not ns = str
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="132" endline="140"><![CDATA[
 
     Shared Function RemoveGlobal(ByVal ns As String) As String
         If IsGlobal(ns) Then
             Return ns.Substring(7)
         Else
             Helper.Assert(ns.StartsWith("Global.", Helper.StringComparison) = False)
             Return ns
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="141" endline="144"><![CDATA[
 
     Shared Function IsGlobal(ByVal ns As String) As Boolean
         Return ns.Length > 7 AndAlso Helper.CompareNameStart(ns, "Global.")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="23" endline="25"><![CDATA[
     Sub New()
         MyBase.new(Helper.StringComparer)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="26" endline="32"><![CDATA[
 
     Sub AddType(ByVal Type As Mono.Cecil.TypeReference)
         Dim [namespace] As String = Type.Namespace
 
         If [namespace] Is Nothing Then [namespace] = String.Empty
         GetTypes([namespace]).Add(Type)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="33" endline="39"><![CDATA[
 
     Function GetTypes(ByVal [Namespace] As String) As TypeDictionary
         If Me.ContainsKey([Namespace]) = False Then
             Return Me.AddNamespace([Namespace])
         End If
         Return MyBase.Item([Namespace])
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="40" endline="46"><![CDATA[
 
     Function AddNamespace(ByVal [Namespace] As String) As TypeDictionary
         Dim result As New TypeDictionary()
         Helper.Assert(MyBase.ContainsKey([Namespace]) = False)
         MyBase.Add([Namespace], result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="47" endline="62"><![CDATA[
 
     ''' <summary>
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal [Namespace] As String) As TypeDictionary
         Get
             If MyBase.ContainsKey([Namespace]) Then
                 Return MyBase.Item([Namespace])
             Else
                 Return TypeDictionary.EmptyDictionary
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="63" endline="69"><![CDATA[
     End Property
 
     Function GetAllDictionaries() As Generic.List(Of TypeDictionary)
         Dim result As New Generic.List(Of TypeDictionary)
         result.AddRange(Values)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="35" endline="37"><![CDATA[
     Function ContainsKey(ByVal Name As String) As Boolean
         Return m_Hashed.ContainsKey(Name)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="38" endline="54"><![CDATA[
 
     ''' <summary>
     ''' Loops up the namespace of the specified namespace.
     ''' Returns nothing if nothing is found.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Overloads ReadOnly Property Item(ByVal Name As String) As [Namespace]
         Get
             If ContainsKey(Name) Then
                 Return m_Hashed(Name)
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="55" endline="62"><![CDATA[
     End Property
 
     Function FindNamespace(ByVal A As String, ByVal B As String) As [Namespace]
         For i As Integer = 0 To Count - 1
             If Item(i).Equals(A, B) Then Return Item(i)
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="63" endline="81"><![CDATA[
 
     ''' <summary>
     ''' Looks up the specified child of the namespace.
     ''' Returns nothing if nothing is found.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Child"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Overloads ReadOnly Property Item(ByVal Parent As [Namespace], ByVal Child As String) As [Namespace]
         Get
             Dim name As String = Parent.Name & "." & Child
             If ContainsKey(name) Then
                 Return Item(name)
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="82" endline="98"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a string array with all the namespaces.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property NamespacesAsString() As String()
         Get
             Dim result(Count - 1) As String
             Dim tmp() As [Namespace] = Me.ToArray
             For i As Integer = 0 To Count - 1
                 result(i) = tmp(i).Name
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="99" endline="104"><![CDATA[
     End Property
 
     Overloads Sub Add(ByVal Parent As BaseObject, ByVal ns As String, ByVal IsGlobal As Boolean)
         If ns = "" Then Return
         Add(New [Namespace](Parent, ns, IsGlobal))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="105" endline="132"><![CDATA[
 
     ''' <summary>
     ''' Adds a namespace and all its variants
     ''' (i.e. for System.Xml it adds System and System.Xml)
     ''' </summary>
     ''' <param name="ns"></param>
     ''' <param name="IsGlobal"></param>
     ''' <remarks></remarks>
     Sub AddAllNamespaces(ByVal Parent As BaseObject, ByVal ns As String, ByVal IsGlobal As Boolean)
         If ns = String.Empty Then Return
 
         If Me.ContainsKey(ns) Then Return
 
         Add(Parent, ns, IsGlobal)
 
         Dim idx As Integer = ns.LastIndexOf("."c)
         If idx < 0 Then Return
 
         Dim tmp As String = ns
         Do
             tmp = tmp.Substring(0, idx)
             If Me.ContainsKey(tmp) Then Return
 
             Add(Parent, tmp, IsGlobal)
 
             idx = tmp.LastIndexOf("."c)
         Loop While idx >= 0
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="133" endline="139"><![CDATA[
 
     Overloads Sub Add(ByVal ns As [Namespace])
         If Not ContainsKey(ns.Name) Then
             MyBase.Add(ns)
             m_Hashed.Add(ns.Name, ns)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="140" endline="145"><![CDATA[
 
     Overloads Sub AddRange(ByVal Parent As BaseObject, ByVal Namespaces As String(), ByVal IsGlobal As Boolean)
         For Each ns As String In Namespaces
             Add(Parent, ns, IsGlobal)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="146" endline="149"><![CDATA[
 
     Sub New()
         m_Hashed = New Generic.Dictionary(Of String, [Namespace])(Helper.StringComparer)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="150" endline="168"><![CDATA[
 
     ''' <summary>
     ''' Searches the namespaces of the current compiling assembly / referenced assemblies to check
     ''' if the name is a namespace.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsNamespace(ByVal Name As String, ByVal onlyExact As Boolean) As Boolean
         Name = vbnc.Namespace.RemoveGlobal(Name)
         If ContainsKey(Name) Then
             Return True
         ElseIf onlyExact = False Then
             For Each strNS As [Namespace] In Me
                 If strNS.StartsWith(Name) Then Return True
             Next
         End If
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="169" endline="176"><![CDATA[
 
     Function IsNamespaceExact(ByVal A As String, ByVal B As String) As Boolean
         For i As Integer = 0 To Me.Count - 1
             Dim ns As [Namespace] = Me.Item(i)
             If ns.Equals(A, B) Then Return True
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="98" endline="100"><![CDATA[
         Get
             Return m_Listeners
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="101" endline="107"><![CDATA[
     End Property
 
     Sub Write(ByVal Level As ReportLevels, Optional ByVal Value As String = "")
         If Level <= m_ReportLevel Then
             Write(Value)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="108" endline="114"><![CDATA[
 
     Sub Write(Optional ByVal Value As String = "")
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.Write(Value)
         Next
         Console.Write(Value)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="115" endline="120"><![CDATA[
 
     Sub Indent()
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.IndentLevel += 1
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="121" endline="126"><![CDATA[
 
     Sub Unindent()
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.IndentLevel -= 1
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="127" endline="130"><![CDATA[
 
     Sub WriteLine(ByVal Level As ReportLevels, Optional ByVal Value As String = "")
         Write(Level, Value & VB.vbNewLine)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="131" endline="134"><![CDATA[
 
     Sub WriteLine(Optional ByVal Value As String = "")
         Write(Value & VB.vbNewLine)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="135" endline="142"><![CDATA[
 
     ''' <summary>
     ''' The executing compiler.
     ''' </summary>
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="143" endline="157"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a new default report.
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
     Private m_MessageCount(MessageLevel.Error) As Integer
 
     ''' <summary>
     ''' The max number of errors before quit compiling.
     ''' </summary>
     ''' <remarks></remarks>
     Const MAXERRORS As Integer = 50
 
     ''' <summary>
     ''' The resource manager for this report.
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared m_Resources As ResourceManager
 
     ''' <summary>
     ''' A list of all the errors / warnings shown.
     ''' Messages are not added until they are shown
     ''' (if they are saved).
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Messages As New ArrayList
 
     ''' <summary>
     ''' A list of all the saved errors / warnings to show.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_SavedMessages As New ArrayList
 
     ''' <summary>
     ''' The executing compiler.
     ''' </summary>
     Private m_Compiler As Compiler
 
 
     Enum ReportLevels
         ''' <summary>
         ''' Always show the message.
         ''' </summary>
         ''' <remarks></remarks>
         Always
         ''' <summary>
         ''' Only show if verbose
         ''' </summary>
         ''' <remarks></remarks>
         Verbose
         ''' <summary>
         ''' Only show in debug builds
         ''' </summary>
         ''' <remarks></remarks>
         Debug
     End Enum
 
     Private m_ReportLevel As ReportLevels = ReportLevels.Debug
     Private m_Listeners As New Generic.List(Of Diagnostics.TraceListener)
 
     ''' <summary>
     ''' The listeners who will receive text output.
     ''' A console writer is here by default.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Listeners() As Generic.List(Of Diagnostics.TraceListener)
         Get
             Return m_Listeners
         End Get
     End Property
 
     Sub Write(ByVal Level As ReportLevels, Optional ByVal Value As String = "")
         If Level <= m_ReportLevel Then
             Write(Value)
         End If
     End Sub
 
     Sub Write(Optional ByVal Value As String = "")
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.Write(Value)
         Next
         Console.Write(Value)
     End Sub
 
     Sub Indent()
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.IndentLevel += 1
         Next
     End Sub
 
     Sub Unindent()
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.IndentLevel -= 1
         Next
     End Sub
 
     Sub WriteLine(ByVal Level As ReportLevels, Optional ByVal Value As String = "")
         Write(Level, Value & VB.vbNewLine)
     End Sub
 
     Sub WriteLine(Optional ByVal Value As String = "")
         Write(Value & VB.vbNewLine)
     End Sub
 
     ''' <summary>
     ''' The executing compiler.
     ''' </summary>
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     ''' <summary>
     ''' Creates a new default report.
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         'm_Listeners.Add(New System.Diagnostics.TextWriterTraceListener(Console.Out))
 #If DEBUG Then
         For Each i As Diagnostics.TraceListener In System.Diagnostics.Debug.Listeners
             m_Listeners.Add(i)
         Next
 #End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="158" endline="181"><![CDATA[
 
     ''' <summary>
     ''' Looks up the specified error code and returns the string
     ''' </summary>
     ''' <param name="ErrorCode"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function LookupErrorCode(ByVal ErrorCode As Integer) As String
         Dim result As Object
 
         If m_Resources Is Nothing Then
             m_Resources = New ResourceManager("vbnc.Errors", System.Reflection.Assembly.GetExecutingAssembly())
         End If
 
         result = m_Resources.GetObject(ErrorCode.ToString)
 
         If result Is Nothing Then
             Console.WriteLine("Could not find the error message corresponding with the error code
             Return ErrorCode.ToString
         Else
             Return result.ToString
         End If
 
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="182" endline="189"><![CDATA[
 
     ''' <summary>
     ''' The number of messages shown for the specified message level
     ''' </summary>
     ReadOnly Property MessageCount(ByVal Level As MessageLevel) As Integer
         Get
             Return m_MessageCount(Level)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="190" endline="200"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The number of errors so far.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Errors() As Integer
         Get
             Return m_MessageCount(MessageLevel.Error)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="201" endline="211"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The number of warnings so far.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Warnings() As Integer
         Get
             Return m_MessageCount(MessageLevel.Warning)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="212" endline="228"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Show the saved messages. Returns true if any error messages have been shown.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ShowSavedMessages() As Boolean
         Dim result As Boolean = False
 
         For Each msg As Message In m_SavedMessages
             ShowMessage(False, msg) 'Compiler.Report.WriteLine(str)
             If msg.Level >= MessageLevel.Error Then result = True
         Next
         m_SavedMessages.Clear()
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="229" endline="252"><![CDATA[
 
     ''' <summary>
     ''' Helper to construct a message for a multiline message when every line after the first one
     ''' is the same message. Message() must be an array with two elements, FirstParameters() is applied
     ''' to the first one, then the second element is multiplied by the number of SubsequentParameters()
     ''' and then a message is created with the corresponding SubsequentParameters() for every line after the 
     ''' first one.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Sub ShowMessageHelper(ByVal Message() As Messages, ByVal Location As Span, ByVal FirstParameters() As String, ByVal SubsequentParameters() As String)
         Dim msg() As Messages
         Dim params()() As String
 
         ReDim msg(SubsequentParameters.Length)
         ReDim params(SubsequentParameters.Length)
         msg(0) = Message(0)
         params(0) = FirstParameters
         For i As Integer = 1 To msg.GetUpperBound(0)
             msg(i) = Message(1)
             params(i) = New String() {SubsequentParameters(i - 1)}
         Next
 
         ShowMessage(msg, Location, params)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="253" endline="260"><![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="261" endline="269"><![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessageNoLocation(ByVal Message As Messages, ByVal ParamArray Parameters() As String) As Boolean
         Dim Location As Span = Nothing
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="270" endline="277"><![CDATA[
 
     ''' <summary>
     ''' Shows the multiline message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message() As Messages, ByVal Location As Span, ByVal ParamArray Parameters()() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="278" endline="285"><![CDATA[
 
     ''' <summary>
     ''' Saves the message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function SaveMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(True, New Message(Compiler, Message, Parameters, Location))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="286" endline="325"><![CDATA[
 
     ''' <summary>
     ''' Shows the specified message. Can optionally save it (not show it)
     ''' to show it later with ShowSavedMessages()
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Private Function ShowMessage(ByVal SaveIt As Boolean, ByVal Message As Message) As Boolean
         Dim isOnlyWarning As Boolean = False
 
         isOnlyWarning = Message.Level <= MessageLevel.Warning
 
         If SaveIt Then
             m_SavedMessages.Add(Message)
         Else
             m_Messages.Add(Message)
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Always, Message.ToString())
             m_MessageCount(Message.Level) += 1
             If m_MessageCount(MessageLevel.Error) > MAXERRORS Then
                 Throw New TooManyErrorsException()
             End If
         End If
 
 #If TRACEMESSAGES Then
         Console.WriteLine(Environment.StackTrace)
 #End If
 
 #If STOPONERROR Then
         If Helper.IsDebugging AndAlso Message.Level = MessageLevel.Error Then
             Helper.Stop()
         ElseIf Helper.IsBootstrapping Then
             Throw New InternalException(Message.ToString)
         End If
 #ElseIf STOPONWARNING Then
         If Debugger.IsAttached AndAlso Message.Level = MessageLevel.Warning Then
             Helper.Stop()
         End If
 #End If
 
         Return isOnlyWarning
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="326" endline="337"><![CDATA[
 
     Public Sub Trace(ByVal format As String, ByVal ParamArray args() As Object)
         If Compiler.CommandLine.Trace = False Then Return
         If args IsNot Nothing Then
             For i As Integer = 0 To args.Length - 1
                 If TypeOf args(i) Is Span Then
                     args(i) = DirectCast(args(i), Span).ToString(Compiler)
                 End If
             Next
         End If
         Console.WriteLine(format, args)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resource.vb" startline="43" endline="45"><![CDATA[
         Get
             Return m_Filename
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resource.vb" startline="46" endline="54"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The name of the resource.
     ''' </summary>
     ReadOnly Property Identifier() As String
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resource.vb" startline="55" endline="63"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Is this resource public?
     ''' </summary>
     ReadOnly Property [Public]() As Boolean
         Get
             Return m_Public
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resource.vb" startline="64" endline="73"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a new resource with the specified values.
     ''' </summary>
     Sub New(ByVal Filename As String, ByVal Identifier As String, Optional ByVal [Public] As Boolean = True)
         Me.m_Filename = Filename
         Me.m_Identifier = Identifier
         Me.m_Public = [Public]
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resources.vb" startline="38" endline="40"><![CDATA[
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resources.vb" startline="41" endline="49"><![CDATA[
     End Property
 
     ''' <summary>
     ''' A new resource list.
     ''' </summary>	
     Sub New(ByVal Compiler As Compiler, ByVal LinkedResources As Boolean)
         m_Compiler = Compiler
         m_IsLinkedResources = LinkedResources
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resources.vb" startline="50" endline="98"><![CDATA[
 
     ''' <summary>
     ''' Add a new resource. Parses the string and verifies it.
     ''' If there are any messages, they are saved, not shown.
     ''' </summary>
     Overloads Function Add(ByVal str As String) As Boolean
         Dim strItems() As String = Split(str, ",")
         Dim files As String()
         Dim isPublic As Boolean = True
         Dim identifier As String = ""
 
         Select Case strItems.Length
             Case 1
                 files = Compiler.CommandLine.GetFullPaths(strItems(0))
             Case 2
                 files = Compiler.CommandLine.GetFullPaths(strItems(0))
                 identifier = strItems(1)
             Case 3
                 files = Compiler.CommandLine.GetFullPaths(strItems(0))
                 identifier = strItems(1)
                 Select Case strItems(2).ToLower()
                     Case "public"
                         isPublic = True
                     Case "private"
                         isPublic = False
                     Case Else
                         Compiler.Report.SaveMessage(Messages.VBNC2019, Span.CommandLineSpan, "resource", strItems(2))
                         Return False
                 End Select
             Case Else
                 Compiler.Report.SaveMessage(Messages.VBNC2009, Span.CommandLineSpan, str)
                 Return False
         End Select
 
         If files Is Nothing OrElse files.Length = 0 Then
             If m_IsLinkedResources Then
                 Compiler.Report.SaveMessage(Messages.VBNC30145, Span.CommandLineSpan, String.Format("The file '{0}' does not exist.", strItems(0)))
             Else
                 Compiler.Report.SaveMessage(Messages.VBNC31027, Span.CommandLineSpan, strItems(0))
             End If
             Return False
         End If
 
         For Each file As String In files
             Add(New Resource(file, identifier, isPublic))
         Next
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141"><![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="142" endline="164"><![CDATA[
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="165" endline="172"><![CDATA[
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="173" endline="178"><![CDATA[
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="179" endline="190"><![CDATA[
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="191" endline="194"><![CDATA[
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="195" endline="230"><![CDATA[
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="231" endline="262"><![CDATA[
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="263" endline="293"><![CDATA[
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="294" endline="311"><![CDATA[
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="312" endline="325"><![CDATA[
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="326" endline="334"><![CDATA[
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="335" endline="354"><![CDATA[
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="355" endline="365"><![CDATA[
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="366" endline="413"><![CDATA[
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="414" endline="424"><![CDATA[
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="425" endline="434"><![CDATA[
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="435" endline="455"><![CDATA[
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="456" endline="503"><![CDATA[
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="504" endline="509"><![CDATA[
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="510" endline="516"><![CDATA[
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="517" endline="519"><![CDATA[
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="520" endline="533"><![CDATA[
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="534" endline="540"><![CDATA[
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="541" endline="560"><![CDATA[
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="561" endline="566"><![CDATA[
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="567" endline="572"><![CDATA[
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="573" endline="577"><![CDATA[
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="578" endline="581"><![CDATA[
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="582" endline="586"><![CDATA[
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="587" endline="600"><![CDATA[
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="601" endline="605"><![CDATA[
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="606" endline="620"><![CDATA[
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="621" endline="633"><![CDATA[
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="634" endline="645"><![CDATA[
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="646" endline="650"><![CDATA[
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="651" endline="670"><![CDATA[
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="671" endline="682"><![CDATA[
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="683" endline="686"><![CDATA[
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="687" endline="690"><![CDATA[
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="691" endline="694"><![CDATA[
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="695" endline="698"><![CDATA[
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="699" endline="721"><![CDATA[
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="722" endline="739"><![CDATA[
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="740" endline="743"><![CDATA[
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="744" endline="755"><![CDATA[
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="756" endline="765"><![CDATA[
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="766" endline="796"><![CDATA[
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="797" endline="800"><![CDATA[
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="801" endline="804"><![CDATA[
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="805" endline="818"><![CDATA[
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="819" endline="884"><![CDATA[
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="885" endline="925"><![CDATA[
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="926" endline="1127"><![CDATA[
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1128" endline="1158"><![CDATA[
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1159" endline="1173"><![CDATA[
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1174" endline="1184"><![CDATA[
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1185" endline="1199"><![CDATA[
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1200" endline="1210"><![CDATA[
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1211" endline="1225"><![CDATA[
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1226" endline="1236"><![CDATA[
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1237" endline="1240"><![CDATA[
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1241" endline="1245"><![CDATA[
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1246" endline="1251"><![CDATA[
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1252" endline="1275"><![CDATA[
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1276" endline="1280"><![CDATA[
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1281" endline="1289"><![CDATA[
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1290" endline="1297"><![CDATA[
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1298" endline="1306"><![CDATA[
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1307" endline="1316"><![CDATA[
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1317" endline="1326"><![CDATA[
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1327" endline="1541"><![CDATA[
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1542" endline="1548"><![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1549" endline="1558"><![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)()
         Dim cf As New CodeFile("<Internal>", "", Compiler, Code)
         m_Files.Enqueue(cf)
         Compiler.CommandLine.Files.Add(cf)
         NextFile()
         LoadProjectConstants()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1559" endline="1582"><![CDATA[
 
     Private Sub NextFile()
         m_TotalLineCount += m_CurrentLine
         'm_TotalCharCount += m_Code.Length
 
         m_CurrentLine = 1
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
         m_CurrentChar = Nothing
         m_PreviousChar = Nothing
         m_EndOfFile = False
         m_PeekedChars.Clear()
 
         If m_Files.Count > 0 Then
             m_CodeFile = m_Files.Dequeue()
             m_CodeFileIndex = CUShort(Compiler.CommandLine.Files.IndexOf(m_CodeFile))
             m_Reader = m_CodeFile.CodeStream
             NextChar()
         Else
             m_CodeFile = Nothing
             'm_Code = Nothing
             m_Reader = Nothing
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1583" endline="1617"><![CDATA[
 
     Public Sub NextUnconditionally()
 
         If Token.IsSomething(m_Peeked) Then
             m_Current = m_Peeked
             m_Peeked = Nothing
             Return
         End If
 
         If Token.IsSomething(m_Current) AndAlso m_Current.IsEndOfFile Then
             NextFile()
         End If
 
         If m_CodeFile Is Nothing Then
             m_Current = Token.CreateEndOfCodeToken
             Return
         End If
 
         m_CurrentTypeCharacter = TypeCharacters.Characters.None
         m_Current = GetNextToken()
 
         'Console.WriteLine("Scanned token
 
         'If m_Current.IsEndOfFile() Then
         '    If Token.IsSomething(m_Current) AndAlso Not m_Current.IsEndOfLineOnly Then
         '        m_Peeked = m_Current
         '        m_Current = Token.CreateEndOfLineToken(Me.GetCurrentLocation)
         '    End If
         '    'NextFile()
         'End If
 
         m_CurrentTokenType = m_Current.m_TokenType
         m_CurrentData = m_Current.m_TokenObject
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1618" endline="1622"><![CDATA[
 
     Public ReadOnly Property Current() As Token
         Get
             Return m_Current
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1623" endline="1628"><![CDATA[
     End Property
 
     Public ReadOnly Property CurrentTypeCharacter() As TypeCharacters.Characters
         Get
             Return m_CurrentTypeCharacter
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1629" endline="1634"><![CDATA[
     End Property
 
     Public ReadOnly Property GetLocation() As Span
         Get
             Return Me.GetCurrentLocation
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1635" endline="1640"><![CDATA[
     End Property
 
     Public ReadOnly Property TokenData() As Object
         Get
             Return m_CurrentData
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1641" endline="1646"><![CDATA[
     End Property
 
     Public ReadOnly Property TokenType() As TokenType
         Get
             Return m_CurrentTokenType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="26" endline="30"><![CDATA[
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="31" endline="64"><![CDATA[
     End Property
 
 #If DEBUG Then
     'This method will generate the other partial TypeCache class.
     Shared Sub Generate()
         Dim path As String = "..\source\General\"
         Dim file As String = path & "TypeCache.in"
         Dim filename As String = IO.Path.GetFullPath(file)
         Dim content As String = IO.File.ReadAllText(filename)
         Dim lines As String() = content.Split(New String() {VB.vbCr, VB.vbLf, VB.vbCrLf}, StringSplitOptions.RemoveEmptyEntries)
 
         Dim cecil As New System.Text.StringBuilder
         Dim all As New System.Text.StringBuilder
 
         all.AppendLine(VB.Join(content.Substring(0, content.IndexOf("''") - 1).Split(New String() {VB.vbCr, VB.vbLf, VB.vbCrLf}, StringSplitOptions.RemoveEmptyEntries), Environment.NewLine))
 
         cecil.AppendLine("Public Partial Class CecilTypeCache")
         cecil.AppendLine(Generate(lines))
         cecil.AppendLine("End Class")
 
         all.AppendLine(cecil.ToString)
 
         IO.File.WriteAllText(path & "TypeCache.Generated.vb", all.ToString)
 
         IO.File.Copy(IO.Path.Combine(path, "TypeCache.vb"), IO.Path.Combine(path, "TypeCache.vb.old"), True)
 
         Dim oldContents As String = IO.File.ReadAllText(IO.Path.Combine(path, "TypeCache.vb"))
         Dim iStart As Integer = oldContents.IndexOf("'START" & " SRE") + ("'START " & "SRE").Length + 2
         Dim iEnd As Integer = oldContents.IndexOf("'END SRE", iStart) - 2
         oldContents = oldContents.Remove(iStart, iEnd - iStart)
         oldContents = oldContents.Insert(iStart, all.ToString())
         IO.File.WriteAllText(IO.Path.Combine(path, "TypeCache.vb"), oldContents)
         System.Diagnostics.Debug.WriteLine("Written TypeCache.vb, saved to TypeCache.vb.old")
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="65" endline="210"><![CDATA[
 
     Shared Function Generate(ByVal Lines As String()) As String
         Dim variables As New System.Text.StringBuilder
         Dim getters As New System.Text.StringBuilder
         Dim vbtypes As New System.Text.StringBuilder
         Dim vbmembers As New System.Text.StringBuilder
 
         'Turns out using public fields instead of private fields with property getters is about 10% faster during bootstrapping.
         'Quite possibly because there's quite more code to compile with the properties
         Dim publicfields As Boolean = True
 
         If publicfields Then
             getters.AppendLine("    Protected Overrides Sub InitInternal ()")
         End If
 
         vbtypes.AppendLine("    Public Overrides Sub InitInternalVB()")
         vbmembers.AppendLine("    Public Overrides Sub InitInternalVBMembers()")
 
         For Each line As String In Lines
             If line.StartsWith("'") Then Continue For
             If line.Trim = "" Then Continue For
 
             Dim splitted() As String = line.Split(New Char() {" "c}, StringSplitOptions.RemoveEmptyEntries)
             Dim name, type, find, parameters As String
             Dim param As Integer = Integer.MaxValue
             Dim noparaminname As Boolean = False
             Dim isVB As Boolean = False
             Dim isVBMember As Boolean = False
 
             parameters = Nothing
 
             Select Case splitted(0)
                 Case "vbtype"
                     name = splitted(1)
                     name = name.Replace("Microsoft.VisualBasic.CompilerServices.", "MS_VB_CS_")
                     name = name.Replace("Microsoft.VisualBasic.", "MS_VB_")
                     name = name.Replace("""", "").Replace(".", "_").Replace("`", "").Replace("+", "_")
                     type = "Mono.Cecil.TypeDefinition"
                     find = "GetVBType"
                     parameters = splitted(1)
                     isVB = True
                 Case "type"
                     name = splitted(2).Replace("""", "").Replace(".", "_").Replace("`", "").Replace("+", "_")
                     type = "Mono.Cecil.TypeDefinition"
                     find = "[GetType]"
                     parameters = splitted(1) & ", " & splitted(2)
 
                     If splitted(2).IndexOf("+"c) > 0 Then
                         Dim declaringtype As String = splitted(2).Substring(0, splitted(2).LastIndexOf("+"c)).Replace(".", "_").Replace("""", "")
                         Dim nestedtype As String = """" & splitted(2).Substring(splitted(2).LastIndexOf("+"c) + 1)
                         parameters = declaringtype & ", " & nestedtype
                     End If
 
                 Case "array"
                     name = splitted(1).Replace("""", "").Replace(".", "_").Replace("`", "") & "_Array"
                     type = "Mono.Cecil.TypeReference"
                     find = "GetArrayType"
                     parameters = splitted(1)
                 Case "byref"
                     name = splitted(1).Replace("""", "").Replace(".", "_").Replace("`", "") & "_ByRef"
                     type = "Mono.Cecil.TypeReference"
                     find = "GetByRefType"
                     parameters = splitted(1)
                 Case "method", "method2"
                     name = splitted(1) & "__" & splitted(2).Replace("""", "").Replace(".", "_").Replace("`", "")
                     type = "Mono.Cecil.MethodDefinition"
                     If splitted(0) <> "method" Then noparaminname = True
                     param = 3
                     find = "GetMethod"
                     parameters = splitted(1) & ", " & splitted(2)
                     isVBMember = splitted(1).StartsWith("MS_")
                 Case "property"
                     name = splitted(1) & "__" & splitted(2).Replace("""", "").Replace(".", "_").Replace("`", "")
                     type = "Mono.Cecil.PropertyDefinition"
                     param = 3
                     find = "GetProperty"
                     parameters = splitted(1) & ", " & splitted(2)
                     isVBMember = splitted(1).StartsWith("MS_")
                 Case "field"
                     name = splitted(1) & "__" & splitted(2).Replace("""", "").Replace(".", "_").Replace("`", "")
                     type = "Mono.Cecil.FieldDefinition"
                     find = "GetField"
                     parameters = splitted(1) & ", " & splitted(2)
                     isVBMember = splitted(1).StartsWith("MS_")
                 Case "ctor"
                     name = splitted(1) & "__ctor"
                     type = "Mono.Cecil.MethodDefinition"
                     param = 2
                     find = "GetConstructor"
                     parameters = splitted(1)
                     isVBMember = splitted(1).StartsWith("MS_")
                 Case Else
                     Helper.Stop()
                     Throw New NotImplementedException(splitted(0))
             End Select
 
             For i As Integer = param To splitted.GetUpperBound(0)
                 If noparaminname = False Then
                     Dim lastUScore As Integer
                     Dim p As String = splitted(i)
                     p = splitted(i)
                     p = p.Replace("_ByRef", "")
                     lastUScore = p.LastIndexOf("_"c) + 1
                     name &= "_" & p.Substring(lastUScore)
                 End If
                 If parameters IsNot Nothing Then parameters &= ", "
                 parameters &= splitted(i)
             Next
 
             If publicfields Then
                 variables.AppendLine(String.Format("    Public {0} As {1}", name, type))
             Else
                 variables.AppendLine(String.Format("    Private m_{0} As {1}", name, type))
             End If
 
             Dim text As String
             If publicfields Then
                 text = String.Format("        {0} = {1}({2})", name, find, parameters)
                 If isVB Then
                     vbtypes.AppendLine(text)
                 ElseIf isVBMember Then
                     vbmembers.AppendLine(text)
                 Else
                     getters.AppendLine(text)
                 End If
             Else
                 getters.AppendLine(String.Format("    Public ReadOnly Property {0} As {1}", name, type))
                 getters.AppendLine(String.Format("        Get"))
                 getters.AppendLine(String.Format("            If m_{0} Is Nothing Then", name))
                 getters.AppendLine(String.Format("                m_{0} = {1}({2})", name, find, parameters))
                 getters.AppendLine(String.Format("            End If"))
                 getters.AppendLine(String.Format("            Return m_{0}", name))
                 getters.AppendLine(String.Format("        End Get"))
                 getters.AppendLine(String.Format("    End Property"))
             End If
         Next
 
         If publicfields Then
             getters.AppendLine("    End Sub")
         End If
 
         vbtypes.AppendLine("    End Sub")
         vbmembers.AppendLine("    End Sub")
 
         Return variables.ToString & Environment.NewLine & getters.ToString & Environment.NewLine & vbtypes.ToString & Environment.NewLine & vbmembers.ToString
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="211" endline="226"><![CDATA[
 #End If
 
     Protected Overloads Function [GetType](ByVal Assembly As Mono.Cecil.AssemblyDefinition, ByVal FullName As String) As Mono.Cecil.TypeDefinition
         If Assembly Is Nothing Then Return Nothing
         Dim result As Mono.Cecil.TypeDefinition = Nothing
         Dim split As String() = FullName.Split("+"c)
         For i As Integer = 0 To split.Length - 1
             If result Is Nothing Then
                 result = Assembly.MainModule.GetType(split(i))
             Else
                 result = Me.GetType(result, split(i))
             End If
         Next
         If result Is Nothing Then Compiler.Report.WriteLine(String.Format("Could not load the type '{0}' from the assembly '{1}'", FullName, Assembly.Name.FullName))
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="227" endline="239"><![CDATA[
 
     Protected Overloads Function [GetType](ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String) As Mono.Cecil.TypeDefinition
         If Type Is Nothing Then Return Nothing
         Dim result As Mono.Cecil.TypeDefinition = Nothing
         For Each item As Mono.Cecil.TypeDefinition In Type.NestedTypes
             If Helper.CompareNameOrdinal(item.Name, Name) Then
                 result = item
                 Exit For
             End If
         Next
         If result Is Nothing Then Compiler.Report.WriteLine(String.Format("Could not load the nested type '{0}' from the type '{1}'", Name, Type.FullName))
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="240" endline="243"><![CDATA[
 
     Protected Function GetByRefType(ByVal Type As Mono.Cecil.TypeDefinition) As Mono.Cecil.TypeReference
         Return New ByReferenceType(Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="244" endline="247"><![CDATA[
 
     Protected Function GetArrayType(ByVal Type As Mono.Cecil.TypeDefinition) As Mono.Cecil.TypeReference
         Return New Mono.Cecil.ArrayType(Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="248" endline="261"><![CDATA[
 
     Protected Function GetProperty(ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String, ByVal ParamArray Types() As Mono.Cecil.TypeReference) As Mono.Cecil.PropertyDefinition
         If Type Is Nothing Then Return Nothing
         Dim properties As Mono.Collections.Generic.Collection(Of PropertyDefinition)
         properties = CecilHelper.FindProperties(Type.Properties, Name)
         For i As Integer = 0 To properties.Count - 1
             Dim prop As Mono.Cecil.PropertyDefinition = properties(i)
             Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = prop.Parameters
 
             If IsMatch(Types, params) Then Return prop
         Next
 
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="262" endline="270"><![CDATA[
 
     Private Function IsMatch(ByVal Types As Mono.Cecil.TypeReference(), ByVal Parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If Parameters.Count = 0 AndAlso (Types Is Nothing OrElse Types.Length = 0) Then Return True
         If Parameters.Count <> Types.Length Then Return False
         For j As Integer = 0 To Parameters.Count - 1
             If Helper.CompareType(Parameters(j).ParameterType, Types(j)) = False Then Return False
         Next
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="271" endline="274"><![CDATA[
 
     Protected Function GetConstructor(ByVal Type As Mono.Cecil.TypeDefinition, ByVal ParamArray Types() As Mono.Cecil.TypeReference) As Mono.Cecil.MethodDefinition
         Return GetMethod(Type, ".ctor", Types)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="275" endline="299"><![CDATA[
 
     Protected Function GetMethod(ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String, ByVal ParamArray Types() As Mono.Cecil.TypeReference) As Mono.Cecil.MethodDefinition
         Dim result As Mono.Cecil.MethodDefinition = Nothing
         If Type Is Nothing Then
 #If DEBUG Then
             Compiler.Report.WriteLine("Could not load the method '" & Name & "', the specified type was Nothing.")
 #End If
             Return Nothing
         End If
 
         For i As Integer = 0 To Type.Methods.Count - 1
             Dim md As MethodDefinition = Type.Methods(i)
             If Helper.CompareNameOrdinal(md.Name, Name) = False Then Continue For
             If Helper.CompareTypes(Helper.GetTypes(md.Parameters), Types) = False Then Continue For
             result = md
             Exit For
         Next
 #If DEBUG Then
         If result Is Nothing Then
             Compiler.Report.WriteLine(Report.ReportLevels.Debug, "Could not find the method '" & Name & "' on the type '" & Type.FullName)
         End If
 #End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="300" endline="304"><![CDATA[
 
     Protected Function GetField(ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String) As Mono.Cecil.FieldDefinition
         If Type Is Nothing Then Return Nothing
         Return CecilHelper.FindField(Type.Fields, Name)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="305" endline="311"><![CDATA[
 
     Sub Init()
         InitOptimizations()
         InitAssemblies()
         InitInternal()
         InitVBNCTypes()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="312" endline="325"><![CDATA[
 
     Protected MustOverride Sub InitInternal()
 
     Protected MustOverride Sub InitOptimizations()
 
     Protected MustOverride Sub InitAssemblies()
 
     Protected MustOverride Sub InitVBNCTypes()
 
     Public MustOverride Sub InitInternalVB()
 
     Public Overridable Sub InitInternalVBMembers()
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="326" endline="349"><![CDATA[
 
 End Class
 
 Public Class CecilTypeCache
     Inherits TypeCacheBase
 
     Public vbruntime As Mono.Cecil.AssemblyDefinition
     Public mscorlib As Mono.Cecil.AssemblyDefinition
     Public winforms As Mono.Cecil.AssemblyDefinition
 
     'Special vbnc types
     Public [Nothing] As Mono.Cecil.TypeDefinition
     Public DelegateUnresolvedType As Mono.Cecil.TypeDefinition
 
     'Stupid MS type system with some optimizations requires this
     Public System_MonoType As Mono.Cecil.TypeDefinition
     Public System_RuntimeType As Mono.Cecil.TypeDefinition
     Public System_Reflection_Emit_TypeBuilder As Mono.Cecil.TypeDefinition
     Public System_Reflection_Emit_TypeBuilderInstantiation As Mono.Cecil.TypeDefinition
     Public System_Reflection_Emit_SymbolType As Mono.Cecil.TypeDefinition
 
     Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="350" endline="376"><![CDATA[
 
     Protected Function GetVBType(ByVal Name As String) As Mono.Cecil.TypeDefinition
         Dim result As Mono.Cecil.TypeDefinition = Nothing
 
         If String.IsNullOrEmpty(Compiler.CommandLine.VBRuntime) AndAlso vbruntime Is Nothing Then
             Dim tps As Generic.List(Of Mono.Cecil.TypeReference)
             tps = Compiler.TypeManager.GetType(Name, True)
 
             If tps.Count = 1 Then
                 result = CecilHelper.FindDefinition(tps(0))
 #If DEBUG Then
             ElseIf tps.Count > 1 Then
                 Compiler.Report.WriteLine("Found " & tps.Count & " types with the name " & Name)
 #End If
             End If
         Else
             result = [GetType](vbruntime, Name)
         End If
 
 #If DEBUG Then
         If result Is Nothing Then
             Compiler.Report.WriteLine("Could not load VB Type
         End If
 #End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="377" endline="388"><![CDATA[
 
     Protected Overrides Sub InitAssemblies()
         For Each a As Mono.Cecil.AssemblyDefinition In Compiler.TypeManager.CecilAssemblies
             If a.Name.Name = "Microsoft.VisualBasic" Then
                 vbruntime = a 
             ElseIf a.Name.Name = "mscorlib" Then
                 mscorlib = a 
             ElseIf a.Name.Name = "System.Windows.Forms" Then
                 winforms = a 
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="389" endline="400"><![CDATA[
 
     Protected Overrides Sub InitOptimizations()
         If Helper.IsOnMono Then
             System_MonoType = Me.GetType(mscorlib, "System.MonoType")
         Else
             System_RuntimeType = Me.GetType(mscorlib, "System.RuntimeType")
             System_Reflection_Emit_TypeBuilderInstantiation = Me.GetType(mscorlib, "System.Reflection.Emit.TypeBuilderInstantiation")
             System_Reflection_Emit_SymbolType = Me.GetType(mscorlib, "System.Reflection.Emit.SymbolType")
         End If
         System_Reflection_Emit_TypeBuilder = Me.GetType(mscorlib, "System.Reflection.Emit.TypeBuilder")
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="401" endline="405"><![CDATA[
 
     Protected Overrides Sub InitVBNCTypes()
         [Nothing] = New Mono.Cecil.TypeDefinition("Nothing", "vbnc", Mono.Cecil.TypeAttributes.Public Or Mono.Cecil.TypeAttributes.Class, Me.System_Object)
         DelegateUnresolvedType = New Mono.Cecil.TypeDefinition("DelegateUnresolvedType", "vbnc", Mono.Cecil.TypeAttributes.Public Or Mono.Cecil.TypeAttributes.Class, Me.System_Object)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="406" endline="840"><![CDATA[
 
 End Class
 
 'START SRE
 '' 
 ' Visual Basic.Net Compiler
 ' Copyright (C) 2004 - 2010 Rolf Bjarne Kvinge, RKvinge@novell.com
 ' 
 ' This library is free software; you can redistribute it and/or
 ' modify it under the terms of the GNU Lesser General Public
 ' License as published by the Free Software Foundation; either
 ' version 2.1 of the License, or (at your option) any later version.
 ' 
 ' This library is distributed in the hope that it will be useful,
 ' but WITHOUT ANY WARRANTY; without even the implied warranty of
 ' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ' Lesser General Public License for more details.
 ' 
 ' You should have received a copy of the GNU Lesser General Public
 ' License along with this library; if not, write to the Free Software
 ' Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 ' 
 Public Partial Class CecilTypeCache
     Public System_Boolean As Mono.Cecil.TypeDefinition
     Public System_Boolean_Array As Mono.Cecil.TypeReference
     Public System_Byte As Mono.Cecil.TypeDefinition
     Public System_Byte_Array As Mono.Cecil.TypeReference
     Public System_Char As Mono.Cecil.TypeDefinition
     Public System_Char_Array As Mono.Cecil.TypeReference
     Public System_DateTime As Mono.Cecil.TypeDefinition
     Public System_Decimal As Mono.Cecil.TypeDefinition
     Public System_Double As Mono.Cecil.TypeDefinition
     Public System_Int32 As Mono.Cecil.TypeDefinition
     Public System_Int64 As Mono.Cecil.TypeDefinition
     Public System_Object As Mono.Cecil.TypeDefinition
     Public System_Object_Array As Mono.Cecil.TypeReference
     Public System_Object_ByRef As Mono.Cecil.TypeReference
     Public System_Int16 As Mono.Cecil.TypeDefinition
     Public System_Single As Mono.Cecil.TypeDefinition
     Public System_String As Mono.Cecil.TypeDefinition
     Public System_String_ByRef As Mono.Cecil.TypeReference
     Public System_String_Array As Mono.Cecil.TypeReference
     Public System_String__ctor_Array As Mono.Cecil.MethodDefinition
     Public System_SByte As Mono.Cecil.TypeDefinition
     Public System_UInt16 As Mono.Cecil.TypeDefinition
     Public System_UInt32 As Mono.Cecil.TypeDefinition
     Public System_UInt64 As Mono.Cecil.TypeDefinition
     Public System_Int32_Array As Mono.Cecil.TypeReference
     Public System_Enum As Mono.Cecil.TypeDefinition
     Public System_ValueType As Mono.Cecil.TypeDefinition
     Public System_Delegate As Mono.Cecil.TypeDefinition
     Public System_MulticastDelegate As Mono.Cecil.TypeDefinition
     Public System_AsyncCallback As Mono.Cecil.TypeDefinition
     Public System_IAsyncResult As Mono.Cecil.TypeDefinition
     Public System_Collections_IEnumerator As Mono.Cecil.TypeDefinition
     Public System_Collections_IEnumerator__get_Current As Mono.Cecil.MethodDefinition
     Public System_Collections_IEnumerator__MoveNext As Mono.Cecil.MethodDefinition
     Public System_Collections_IEnumerable As Mono.Cecil.TypeDefinition
     Public System_Collections_IEnumerable__GetEnumerator As Mono.Cecil.MethodDefinition
     Public System_IDisposable As Mono.Cecil.TypeDefinition
     Public System_IDisposable__Dispose As Mono.Cecil.MethodDefinition
     Public System_RuntimeTypeHandle As Mono.Cecil.TypeDefinition
     Public System_Type As Mono.Cecil.TypeDefinition
     Public System_Type_Array As Mono.Cecil.TypeReference
     Public System_Type__GetTypeFromHandle_RuntimeTypeHandle As Mono.Cecil.MethodDefinition
     Public System_Void As Mono.Cecil.TypeDefinition
     Public System_Exception As Mono.Cecil.TypeDefinition
     Public System_Array As Mono.Cecil.TypeDefinition
     Public System_DBNull As Mono.Cecil.TypeDefinition
     Public System_SerializableAttribute As Mono.Cecil.TypeDefinition
     Public System_Array__SetValue As Mono.Cecil.MethodDefinition
     Public System_Array__GetValue As Mono.Cecil.MethodDefinition
     Public System_Array__CreateInstance As Mono.Cecil.MethodDefinition
     Public System_Activator As Mono.Cecil.TypeDefinition
     Public System_Activator__CreateInstance As Mono.Cecil.MethodDefinition
     Public System_ArgumentException As Mono.Cecil.TypeDefinition
     Public System_Collections_Generic_IList1 As Mono.Cecil.TypeDefinition
     Public System_Collections_Generic_ICollection1 As Mono.Cecil.TypeDefinition
     Public System_Collections_Generic_IEnumerable1 As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyVersionAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyProductAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyCompanyAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyCopyrightAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyTrademarkAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyKeyNameAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyKeyFileAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyDelaySignAttribute As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_ConditionalAttribute As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_DebuggableAttribute As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_DebuggableAttribute_DebuggingModes As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_DebuggableAttribute__ctor_DebuggingModes As Mono.Cecil.MethodDefinition
     Public System_ParamArrayAttribute As Mono.Cecil.TypeDefinition
     Public System_ParamArrayAttribute__ctor As Mono.Cecil.MethodDefinition
     Public System_Nullable1 As Mono.Cecil.TypeDefinition
     Public System_Nullable1__get_HasValue As Mono.Cecil.MethodDefinition
     Public System_Nullable1__GetValueOrDefault As Mono.Cecil.MethodDefinition
     Public System_Runtime_CompilerServices_RuntimeHelpers As Mono.Cecil.TypeDefinition
     Public System_STAThreadAttribute As Mono.Cecil.TypeDefinition
     Public System_STAThreadAttribute__ctor As Mono.Cecil.MethodDefinition
     Public System_IntPtr As Mono.Cecil.TypeDefinition
     Public System_Runtime_CompilerServices_DateTimeConstantAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor_Int64 As Mono.Cecil.MethodDefinition
     Public System_DateTime__ctor_Int64 As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Int32 As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Int64 As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Double As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Single As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_UInt64 As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Int32_Int32_Int32_Boolean_Byte As Mono.Cecil.MethodDefinition
     Public System_Decimal__Zero As Mono.Cecil.FieldDefinition
     Public System_Decimal__One As Mono.Cecil.FieldDefinition
     Public System_Decimal__MinusOne As Mono.Cecil.FieldDefinition
     Public System_Runtime_CompilerServices_DecimalConstantAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_UInt32_UInt32_UInt32 As Mono.Cecil.MethodDefinition
     Public System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_Int32_Int32_Int32 As Mono.Cecil.MethodDefinition
     Public System_Runtime_CompilerServices_AccessedThroughPropertyAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_CompilerServices_AccessedThroughPropertyAttribute__ctor_String As Mono.Cecil.MethodDefinition
     Public System_Decimal__Compare_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_DateTime__Compare_DateTime_DateTime As Mono.Cecil.MethodDefinition
     Public System_Decimal__Add_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Subtract_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Divide_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Multiply_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Remainder_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Negate_Decimal As Mono.Cecil.MethodDefinition
     Public System_Reflection_DefaultMemberAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_DefaultMemberAttribute__ctor_String As Mono.Cecil.MethodDefinition
     Public System_Convert As Mono.Cecil.TypeDefinition
     Public System_Convert__ToSingle_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToDouble_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToBoolean_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToByte_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToSByte_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToInt16_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToUInt16_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToInt32_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToUInt32_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToInt64_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToUInt64_Decimal As Mono.Cecil.MethodDefinition
     Public System_String__Concat_String_String As Mono.Cecil.MethodDefinition
     Public System_Diagnostics_Debugger As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_Debugger__Break As Mono.Cecil.MethodDefinition
     Public System_Reflection_Missing As Mono.Cecil.TypeDefinition
     Public System_Reflection_Missing__Value As Mono.Cecil.FieldDefinition
     Public System_Threading_Monitor As Mono.Cecil.TypeDefinition
     Public System_Threading_Monitor__Enter_Object As Mono.Cecil.MethodDefinition
     Public System_Threading_Monitor__Exit_Object As Mono.Cecil.MethodDefinition
     Public System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object As Mono.Cecil.MethodDefinition
     Public System_Math As Mono.Cecil.TypeDefinition
     Public System_Math__Round_Double As Mono.Cecil.MethodDefinition
     Public System_Math__Pow_Double_Double As Mono.Cecil.MethodDefinition
     Public System_Runtime_InteropServices_DllImportAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_InteropServices_MarshalAsAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_InteropServices_StructLayoutAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_InteropServices_FieldOffsetAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_InteropServices_CoClassAttribute As Mono.Cecil.TypeDefinition
     Public System_Security_Permissions_SecurityAttribute As Mono.Cecil.TypeDefinition
     Public System_Windows_Forms_Form As Mono.Cecil.TypeDefinition
     Public System_Windows_Forms_Application As Mono.Cecil.TypeDefinition
     Public System_Windows_Forms_Application__Run As Mono.Cecil.MethodDefinition
     Public System_Delegate__Combine As Mono.Cecil.MethodDefinition
     Public System_Delegate__Remove As Mono.Cecil.MethodDefinition
     Public MS_VB_CompareMethod As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_Conversions As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_ProjectData As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_LikeOperator As Mono.Cecil.TypeDefinition
     Public MS_VB_Strings As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_StringType As Mono.Cecil.TypeDefinition
     Public MS_VB_MyGroupCollectionAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CallType As Mono.Cecil.TypeDefinition
     Public MS_VB_Information As Mono.Cecil.TypeDefinition
     Public MS_VB_Information__IsNumeric As Mono.Cecil.MethodDefinition
     Public MS_VB_Information__SystemTypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_Information__TypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_Information__VbTypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_Interaction As Mono.Cecil.TypeDefinition
     Public MS_VB_Interaction__CallByName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_Versioned__IsNumeric As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned__SystemTypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned__TypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned__VbTypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned__CallByName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_StandardModuleAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_Operators As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_ObjectFlowControl As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_Utils As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_OptionCompareAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_OptionTextAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_StaticLocalInitFlag As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_StaticLocalInitFlag__State As Mono.Cecil.FieldDefinition
     Public MS_VB_CS_StaticLocalInitFlag__ctor As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_DesignerGeneratedAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_IncompleteInitialization As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_NewLateBinding As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_LateBinding As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_IncompleteInitialization__ctor As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__EndApp As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__CreateProjectError_Int32 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__ClearProjectError As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__SetProjectError_Exception As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__SetProjectError_Exception_Int32 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToBoolean_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToChar_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDate_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToByte_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToSByte_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToShort_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToUShort_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToInteger_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToUInteger_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToLong_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToULong_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToSingle_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDouble_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDecimal_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToBoolean_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToChar_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDate_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToByte_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToSByte_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToShort_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToUShort_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToInteger_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToUInteger_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToLong_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToULong_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToSingle_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDouble_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDecimal_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDecimal_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Decimal As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Char As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_DateTime As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Byte As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Int32 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_UInt32 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Int64 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_UInt64 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Single As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Double As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToGenericParameter_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ChangeType_Object_Type As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToCharArrayRankOne_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_LikeOperator__LikeString_String_String_CompareMethod As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_LikeOperator__LikeObject_Object_Object_CompareMethod As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_StringType__MidStmtStr_String_Int32_Int32_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl__CheckForSyncLockOnValueType_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForLoopInitObj_Object_Object_Object_Object_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckDec_Decimal_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckObj_Object_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR4_Single_Single_Single As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR8_Double_Double_Double As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Utils__CopyArray_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectNotEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareString_String_String_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConcatenateObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__AddObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__AndObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__DivideObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ExponentObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__IntDivideObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__LeftShiftObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ModObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__MultiplyObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__NegateObject_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__NotObject_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__OrObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__PlusObject_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__RightShiftObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__SubtractObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__XorObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__LikeObject_Object_Object_CompareMethod As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__LikeString_String_String_CompareMethod As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectNotEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectGreater_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectGreaterEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectLess_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectLessEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
 
     Protected Overrides Sub InitInternal ()
         System_Boolean = [GetType](mscorlib, "System.Boolean")
         System_Boolean_Array = GetArrayType(System_Boolean)
         System_Byte = [GetType](mscorlib, "System.Byte")
         System_Byte_Array = GetArrayType(System_Byte)
         System_Char = [GetType](mscorlib, "System.Char")
         System_Char_Array = GetArrayType(System_Char)
         System_DateTime = [GetType](mscorlib, "System.DateTime")
         System_Decimal = [GetType](mscorlib, "System.Decimal")
         System_Double = [GetType](mscorlib, "System.Double")
         System_Int32 = [GetType](mscorlib, "System.Int32")
         System_Int64 = [GetType](mscorlib, "System.Int64")
         System_Object = [GetType](mscorlib, "System.Object")
         System_Object_Array = GetArrayType(System_Object)
         System_Object_ByRef = GetByRefType(System_Object)
         System_Int16 = [GetType](mscorlib, "System.Int16")
         System_Single = [GetType](mscorlib, "System.Single")
         System_String = [GetType](mscorlib, "System.String")
         System_String_ByRef = GetByRefType(System_String)
         System_String_Array = GetArrayType(System_String)
         System_String__ctor_Array = GetConstructor(System_String, System_Char_Array)
         System_SByte = [GetType](mscorlib, "System.SByte")
         System_UInt16 = [GetType](mscorlib, "System.UInt16")
         System_UInt32 = [GetType](mscorlib, "System.UInt32")
         System_UInt64 = [GetType](mscorlib, "System.UInt64")
         System_Int32_Array = GetArrayType(System_Int32)
         System_Enum = [GetType](mscorlib, "System.Enum")
         System_ValueType = [GetType](mscorlib, "System.ValueType")
         System_Delegate = [GetType](mscorlib, "System.Delegate")
         System_MulticastDelegate = [GetType](mscorlib, "System.MulticastDelegate")
         System_AsyncCallback = [GetType](mscorlib, "System.AsyncCallback")
         System_IAsyncResult = [GetType](mscorlib, "System.IAsyncResult")
         System_Collections_IEnumerator = [GetType](mscorlib, "System.Collections.IEnumerator")
         System_Collections_IEnumerator__get_Current = GetMethod(System_Collections_IEnumerator, "get_Current")
         System_Collections_IEnumerator__MoveNext = GetMethod(System_Collections_IEnumerator, "MoveNext")
         System_Collections_IEnumerable = [GetType](mscorlib, "System.Collections.IEnumerable")
         System_Collections_IEnumerable__GetEnumerator = GetMethod(System_Collections_IEnumerable, "GetEnumerator")
         System_IDisposable = [GetType](mscorlib, "System.IDisposable")
         System_IDisposable__Dispose = GetMethod(System_IDisposable, "Dispose")
         System_RuntimeTypeHandle = [GetType](mscorlib, "System.RuntimeTypeHandle")
         System_Type = [GetType](mscorlib, "System.Type")
         System_Type_Array = GetArrayType(System_Type)
         System_Type__GetTypeFromHandle_RuntimeTypeHandle = GetMethod(System_Type, "GetTypeFromHandle", System_RuntimeTypeHandle)
         System_Void = [GetType](mscorlib, "System.Void")
         System_Exception = [GetType](mscorlib, "System.Exception")
         System_Array = [GetType](mscorlib, "System.Array")
         System_DBNull = [GetType](mscorlib, "System.DBNull")
         System_SerializableAttribute = [GetType](mscorlib, "System.SerializableAttribute")
         System_Array__SetValue = GetMethod(System_Array, "SetValue", System_Object, System_Int32_Array)
         System_Array__GetValue = GetMethod(System_Array, "GetValue", System_Int32_Array)
         System_Array__CreateInstance = GetMethod(System_Array, "CreateInstance", System_Type, System_Int32_Array)
         System_Activator = [GetType](mscorlib, "System.Activator")
         System_Activator__CreateInstance = GetMethod(System_Activator, "CreateInstance")
         System_ArgumentException = [GetType](mscorlib, "System.ArgumentException")
         System_Collections_Generic_IList1 = [GetType](mscorlib, "System.Collections.Generic.IList`1")
         System_Collections_Generic_ICollection1 = [GetType](mscorlib, "System.Collections.Generic.ICollection`1")
         System_Collections_Generic_IEnumerable1 = [GetType](mscorlib, "System.Collections.Generic.IEnumerable`1")
         System_Reflection_AssemblyVersionAttribute = [GetType](mscorlib, "System.Reflection.AssemblyVersionAttribute")
         System_Reflection_AssemblyProductAttribute = [GetType](mscorlib, "System.Reflection.AssemblyProductAttribute")
         System_Reflection_AssemblyCompanyAttribute = [GetType](mscorlib, "System.Reflection.AssemblyCompanyAttribute")
         System_Reflection_AssemblyCopyrightAttribute = [GetType](mscorlib, "System.Reflection.AssemblyCopyrightAttribute")
         System_Reflection_AssemblyTrademarkAttribute = [GetType](mscorlib, "System.Reflection.AssemblyTrademarkAttribute")
         System_Reflection_AssemblyKeyNameAttribute = [GetType](mscorlib, "System.Reflection.AssemblyKeyNameAttribute")
         System_Reflection_AssemblyKeyFileAttribute = [GetType](mscorlib, "System.Reflection.AssemblyKeyFileAttribute")
         System_Reflection_AssemblyDelaySignAttribute = [GetType](mscorlib, "System.Reflection.AssemblyDelaySignAttribute")
         System_Diagnostics_ConditionalAttribute = [GetType](mscorlib, "System.Diagnostics.ConditionalAttribute")
         System_Diagnostics_DebuggableAttribute = [GetType](mscorlib, "System.Diagnostics.DebuggableAttribute")
         System_Diagnostics_DebuggableAttribute_DebuggingModes = [GetType](System_Diagnostics_DebuggableAttribute, "DebuggingModes")
         System_Diagnostics_DebuggableAttribute__ctor_DebuggingModes = GetConstructor(System_Diagnostics_DebuggableAttribute, System_Diagnostics_DebuggableAttribute_DebuggingModes)
         System_ParamArrayAttribute = [GetType](mscorlib, "System.ParamArrayAttribute")
         System_ParamArrayAttribute__ctor = GetConstructor(System_ParamArrayAttribute)
         System_Nullable1 = [GetType](mscorlib, "System.Nullable`1")
         System_Nullable1__get_HasValue = GetMethod(System_Nullable1, "get_HasValue")
         System_Nullable1__GetValueOrDefault = GetMethod(System_Nullable1, "GetValueOrDefault")
         System_Runtime_CompilerServices_RuntimeHelpers = [GetType](mscorlib, "System.Runtime.CompilerServices.RuntimeHelpers")
         System_STAThreadAttribute = [GetType](mscorlib, "System.STAThreadAttribute")
         System_STAThreadAttribute__ctor = GetConstructor(System_STAThreadAttribute)
         System_IntPtr = [GetType](mscorlib, "System.IntPtr")
         System_Runtime_CompilerServices_DateTimeConstantAttribute = [GetType](mscorlib, "System.Runtime.CompilerServices.DateTimeConstantAttribute")
         System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor_Int64 = GetConstructor(System_Runtime_CompilerServices_DateTimeConstantAttribute, System_Int64)
         System_DateTime__ctor_Int64 = GetConstructor(System_DateTime, System_Int64)
         System_Decimal__ctor_Int32 = GetConstructor(System_Decimal, System_Int32)
         System_Decimal__ctor_Int64 = GetConstructor(System_Decimal, System_Int64)
         System_Decimal__ctor_Double = GetConstructor(System_Decimal, System_Double)
         System_Decimal__ctor_Single = GetConstructor(System_Decimal, System_Single)
         System_Decimal__ctor_UInt64 = GetConstructor(System_Decimal, System_UInt64)
         System_Decimal__ctor_Int32_Int32_Int32_Boolean_Byte = GetConstructor(System_Decimal, System_Int32, System_Int32, System_Int32, System_Boolean, System_Byte)
         System_Decimal__Zero = GetField(System_Decimal, "Zero")
         System_Decimal__One = GetField(System_Decimal, "One")
         System_Decimal__MinusOne = GetField(System_Decimal, "MinusOne")
         System_Runtime_CompilerServices_DecimalConstantAttribute = [GetType](mscorlib, "System.Runtime.CompilerServices.DecimalConstantAttribute")
         System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_UInt32_UInt32_UInt32 = GetConstructor(System_Runtime_CompilerServices_DecimalConstantAttribute, System_Byte, System_Byte, System_UInt32, System_UInt32, System_UInt32)
         System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_Int32_Int32_Int32 = GetConstructor(System_Runtime_CompilerServices_DecimalConstantAttribute, System_Byte, System_Byte, System_Int32, System_Int32, System_Int32)
         System_Runtime_CompilerServices_AccessedThroughPropertyAttribute = [GetType](mscorlib, "System.Runtime.CompilerServices.AccessedThroughPropertyAttribute")
         System_Runtime_CompilerServices_AccessedThroughPropertyAttribute__ctor_String = GetConstructor(System_Runtime_CompilerServices_AccessedThroughPropertyAttribute, System_String)
         System_Decimal__Compare_Decimal_Decimal = GetMethod(System_Decimal, "Compare", System_Decimal, System_Decimal)
         System_DateTime__Compare_DateTime_DateTime = GetMethod(System_DateTime, "Compare", System_DateTime, System_DateTime)
         System_Decimal__Add_Decimal_Decimal = GetMethod(System_Decimal, "Add", System_Decimal, System_Decimal)
         System_Decimal__Subtract_Decimal_Decimal = GetMethod(System_Decimal, "Subtract", System_Decimal, System_Decimal)
         System_Decimal__Divide_Decimal_Decimal = GetMethod(System_Decimal, "Divide", System_Decimal, System_Decimal)
         System_Decimal__Multiply_Decimal_Decimal = GetMethod(System_Decimal, "Multiply", System_Decimal, System_Decimal)
         System_Decimal__Remainder_Decimal_Decimal = GetMethod(System_Decimal, "Remainder", System_Decimal, System_Decimal)
         System_Decimal__Negate_Decimal = GetMethod(System_Decimal, "Negate", System_Decimal)
         System_Reflection_DefaultMemberAttribute = [GetType](mscorlib, "System.Reflection.DefaultMemberAttribute")
         System_Reflection_DefaultMemberAttribute__ctor_String = GetConstructor(System_Reflection_DefaultMemberAttribute, System_String)
         System_Convert = [GetType](mscorlib, "System.Convert")
         System_Convert__ToSingle_Decimal = GetMethod(System_Convert, "ToSingle", System_Decimal)
         System_Convert__ToDouble_Decimal = GetMethod(System_Convert, "ToDouble", System_Decimal)
         System_Convert__ToBoolean_Decimal = GetMethod(System_Convert, "ToBoolean", System_Decimal)
         System_Convert__ToByte_Decimal = GetMethod(System_Convert, "ToByte", System_Decimal)
         System_Convert__ToSByte_Decimal = GetMethod(System_Convert, "ToSByte", System_Decimal)
         System_Convert__ToInt16_Decimal = GetMethod(System_Convert, "ToInt16", System_Decimal)
         System_Convert__ToUInt16_Decimal = GetMethod(System_Convert, "ToUInt16", System_Decimal)
         System_Convert__ToInt32_Decimal = GetMethod(System_Convert, "ToInt32", System_Decimal)
         System_Convert__ToUInt32_Decimal = GetMethod(System_Convert, "ToUInt32", System_Decimal)
         System_Convert__ToInt64_Decimal = GetMethod(System_Convert, "ToInt64", System_Decimal)
         System_Convert__ToUInt64_Decimal = GetMethod(System_Convert, "ToUInt64", System_Decimal)
         System_String__Concat_String_String = GetMethod(System_String, "Concat", System_String, System_String)
         System_Diagnostics_Debugger = [GetType](mscorlib, "System.Diagnostics.Debugger")
         System_Diagnostics_Debugger__Break = GetMethod(System_Diagnostics_Debugger, "Break")
         System_Reflection_Missing = [GetType](mscorlib, "System.Reflection.Missing")
         System_Reflection_Missing__Value = GetField(System_Reflection_Missing, "Value")
         System_Threading_Monitor = [GetType](mscorlib, "System.Threading.Monitor")
         System_Threading_Monitor__Enter_Object = GetMethod(System_Threading_Monitor, "Enter", System_Object)
         System_Threading_Monitor__Exit_Object = GetMethod(System_Threading_Monitor, "Exit", System_Object)
         System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object = GetMethod(System_Runtime_CompilerServices_RuntimeHelpers, "GetObjectValue", System_Object)
         System_Math = [GetType](mscorlib, "System.Math")
         System_Math__Round_Double = GetMethod(System_Math, "Round", System_Double)
         System_Math__Pow_Double_Double = GetMethod(System_Math, "Pow", System_Double, System_Double)
         System_Runtime_InteropServices_DllImportAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.DllImportAttribute")
         System_Runtime_InteropServices_MarshalAsAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.MarshalAsAttribute")
         System_Runtime_InteropServices_StructLayoutAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.StructLayoutAttribute")
         System_Runtime_InteropServices_FieldOffsetAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.FieldOffsetAttribute")
         System_Runtime_InteropServices_CoClassAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.CoClassAttribute")
         System_Security_Permissions_SecurityAttribute = [GetType](mscorlib, "System.Security.Permissions.SecurityAttribute")
         System_Windows_Forms_Form = [GetType](winforms, "System.Windows.Forms.Form")
         System_Windows_Forms_Application = [GetType](winforms, "System.Windows.Forms.Application")
         System_Windows_Forms_Application__Run = GetMethod(System_Windows_Forms_Application, "Run", System_Windows_Forms_Form)
         System_Delegate__Combine = GetMethod(System_Delegate, "Combine", System_Delegate, System_Delegate)
         System_Delegate__Remove = GetMethod(System_Delegate, "Remove", System_Delegate, System_Delegate)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="841" endline="873"><![CDATA[
 
     Public Overrides Sub InitInternalVB()
         MS_VB_CompareMethod = GetVBType("Microsoft.VisualBasic.CompareMethod")
         MS_VB_CS_Conversions = GetVBType("Microsoft.VisualBasic.CompilerServices.Conversions")
         MS_VB_CS_ProjectData = GetVBType("Microsoft.VisualBasic.CompilerServices.ProjectData")
         MS_VB_CS_LikeOperator = GetVBType("Microsoft.VisualBasic.CompilerServices.LikeOperator")
         MS_VB_Strings = GetVBType("Microsoft.VisualBasic.Strings")
         MS_VB_CS_StringType = GetVBType("Microsoft.VisualBasic.CompilerServices.StringType")
         MS_VB_MyGroupCollectionAttribute = GetVBType("Microsoft.VisualBasic.MyGroupCollectionAttribute")
         MS_VB_CallType = GetVBType("Microsoft.VisualBasic.CallType")
         MS_VB_Information = GetVBType("Microsoft.VisualBasic.Information")
         MS_VB_Interaction = GetVBType("Microsoft.VisualBasic.Interaction")
         MS_VB_CS_Versioned = GetVBType("Microsoft.VisualBasic.CompilerServices.Versioned")
         MS_VB_CS_StandardModuleAttribute = GetVBType("Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute")
         MS_VB_CS_Operators = GetVBType("Microsoft.VisualBasic.CompilerServices.Operators")
         MS_VB_CS_ObjectFlowControl = GetVBType("Microsoft.VisualBasic.CompilerServices.ObjectFlowControl")
         If MS_VB_CS_ObjectFlowControl IsNot Nothing Then
             For i As Integer = 0 To MS_VB_CS_ObjectFlowControl.NestedTypes.Count - 1
                 If MS_VB_CS_ObjectFlowControl.NestedTypes(i).Name = "ForLoopControl" Then
                     MS_VB_CS_ObjectFlowControl_ForLoopControl = MS_VB_CS_ObjectFlowControl.NestedTypes(i)
                     Exit For
                 End If
             Next
         End If
         MS_VB_CS_Utils = GetVBType("Microsoft.VisualBasic.CompilerServices.Utils")
         MS_VB_CS_OptionCompareAttribute = GetVBType("Microsoft.VisualBasic.CompilerServices.OptionCompareAttribute")
         MS_VB_CS_OptionTextAttribute = GetVBType("Microsoft.VisualBasic.CompilerServices.OptionTextAttribute")
         MS_VB_CS_StaticLocalInitFlag = GetVBType("Microsoft.VisualBasic.CompilerServices.StaticLocalInitFlag")
         MS_VB_CS_DesignerGeneratedAttribute = GetVBType("Microsoft.VisualBasic.CompilerServices.DesignerGeneratedAttribute")
         MS_VB_CS_IncompleteInitialization = GetVBType("Microsoft.VisualBasic.CompilerServices.IncompleteInitialization")
         MS_VB_CS_NewLateBinding = GetVBType("Microsoft.VisualBasic.CompilerServices.NewLateBinding")
         MS_VB_CS_LateBinding = GetVBType("Microsoft.VisualBasic.CompilerServices.LateBinding")
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="874" endline="984"><![CDATA[
 
     Public Overrides Sub InitInternalVBMembers()
         MS_VB_Information__IsNumeric = GetMethod(MS_VB_Information, "IsNumeric", System_Object)
         MS_VB_Information__SystemTypeName = GetMethod(MS_VB_Information, "SystemTypeName", System_String)
         MS_VB_Information__TypeName = GetMethod(MS_VB_Information, "TypeName", System_Object)
         MS_VB_Information__VbTypeName = GetMethod(MS_VB_Information, "VbTypeName", System_String)
         MS_VB_Interaction__CallByName = GetMethod(MS_VB_Interaction, "CallByName", System_Object, System_String, MS_VB_CallType, System_Object_Array)
         MS_VB_CS_Versioned__IsNumeric = GetMethod(MS_VB_CS_Versioned, "IsNumeric", System_Object)
         MS_VB_CS_Versioned__SystemTypeName = GetMethod(MS_VB_CS_Versioned, "SystemTypeName", System_String)
         MS_VB_CS_Versioned__TypeName = GetMethod(MS_VB_CS_Versioned, "TypeName", System_Object)
         MS_VB_CS_Versioned__VbTypeName = GetMethod(MS_VB_CS_Versioned, "VbTypeName", System_String)
         MS_VB_CS_Versioned__CallByName = GetMethod(MS_VB_CS_Versioned, "CallByName", System_Object, System_String, MS_VB_CallType, System_Object_Array)
         MS_VB_CS_StaticLocalInitFlag__State = GetField(MS_VB_CS_StaticLocalInitFlag, "State")
         MS_VB_CS_StaticLocalInitFlag__ctor = GetConstructor(MS_VB_CS_StaticLocalInitFlag)
         MS_VB_CS_IncompleteInitialization__ctor = GetConstructor(MS_VB_CS_IncompleteInitialization)
         MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateGet", System_Object, System_Type, System_String, System_Object_Array, System_String_Array, System_Type_Array, System_Boolean_Array)
         MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateSet", System_Object, System_Type, System_String, System_Object_Array, System_String_Array, System_Type_Array)
         MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateIndexGet", System_Object, System_Object_Array, System_String_Array)
         MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateIndexSet", System_Object, System_Object_Array, System_String_Array)
         MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean = GetMethod(MS_VB_CS_NewLateBinding, "LateCall", System_Object, System_Type, System_String, System_Object_Array, System_String_Array, System_Type_Array, System_Boolean_Array, System_Boolean)
         MS_VB_CS_ProjectData__EndApp = GetMethod(MS_VB_CS_ProjectData, "EndApp")
         MS_VB_CS_ProjectData__CreateProjectError_Int32 = GetMethod(MS_VB_CS_ProjectData, "CreateProjectError", System_Int32)
         MS_VB_CS_ProjectData__ClearProjectError = GetMethod(MS_VB_CS_ProjectData, "ClearProjectError")
         MS_VB_CS_ProjectData__SetProjectError_Exception = GetMethod(MS_VB_CS_ProjectData, "SetProjectError", System_Exception)
         MS_VB_CS_ProjectData__SetProjectError_Exception_Int32 = GetMethod(MS_VB_CS_ProjectData, "SetProjectError", System_Exception, System_Int32)
         MS_VB_CS_Conversions__ToBoolean_Object = GetMethod(MS_VB_CS_Conversions, "ToBoolean", System_Object)
         MS_VB_CS_Conversions__ToChar_Object = GetMethod(MS_VB_CS_Conversions, "ToChar", System_Object)
         MS_VB_CS_Conversions__ToDate_Object = GetMethod(MS_VB_CS_Conversions, "ToDate", System_Object)
         MS_VB_CS_Conversions__ToByte_Object = GetMethod(MS_VB_CS_Conversions, "ToByte", System_Object)
         MS_VB_CS_Conversions__ToSByte_Object = GetMethod(MS_VB_CS_Conversions, "ToSByte", System_Object)
         MS_VB_CS_Conversions__ToShort_Object = GetMethod(MS_VB_CS_Conversions, "ToShort", System_Object)
         MS_VB_CS_Conversions__ToUShort_Object = GetMethod(MS_VB_CS_Conversions, "ToUShort", System_Object)
         MS_VB_CS_Conversions__ToInteger_Object = GetMethod(MS_VB_CS_Conversions, "ToInteger", System_Object)
         MS_VB_CS_Conversions__ToUInteger_Object = GetMethod(MS_VB_CS_Conversions, "ToUInteger", System_Object)
         MS_VB_CS_Conversions__ToLong_Object = GetMethod(MS_VB_CS_Conversions, "ToLong", System_Object)
         MS_VB_CS_Conversions__ToULong_Object = GetMethod(MS_VB_CS_Conversions, "ToULong", System_Object)
         MS_VB_CS_Conversions__ToSingle_Object = GetMethod(MS_VB_CS_Conversions, "ToSingle", System_Object)
         MS_VB_CS_Conversions__ToDouble_Object = GetMethod(MS_VB_CS_Conversions, "ToDouble", System_Object)
         MS_VB_CS_Conversions__ToDecimal_Object = GetMethod(MS_VB_CS_Conversions, "ToDecimal", System_Object)
         MS_VB_CS_Conversions__ToBoolean_String = GetMethod(MS_VB_CS_Conversions, "ToBoolean", System_String)
         MS_VB_CS_Conversions__ToChar_String = GetMethod(MS_VB_CS_Conversions, "ToChar", System_String)
         MS_VB_CS_Conversions__ToDate_String = GetMethod(MS_VB_CS_Conversions, "ToDate", System_String)
         MS_VB_CS_Conversions__ToByte_String = GetMethod(MS_VB_CS_Conversions, "ToByte", System_String)
         MS_VB_CS_Conversions__ToSByte_String = GetMethod(MS_VB_CS_Conversions, "ToSByte", System_String)
         MS_VB_CS_Conversions__ToShort_String = GetMethod(MS_VB_CS_Conversions, "ToShort", System_String)
         MS_VB_CS_Conversions__ToUShort_String = GetMethod(MS_VB_CS_Conversions, "ToUShort", System_String)
         MS_VB_CS_Conversions__ToInteger_String = GetMethod(MS_VB_CS_Conversions, "ToInteger", System_String)
         MS_VB_CS_Conversions__ToUInteger_String = GetMethod(MS_VB_CS_Conversions, "ToUInteger", System_String)
         MS_VB_CS_Conversions__ToLong_String = GetMethod(MS_VB_CS_Conversions, "ToLong", System_String)
         MS_VB_CS_Conversions__ToULong_String = GetMethod(MS_VB_CS_Conversions, "ToULong", System_String)
         MS_VB_CS_Conversions__ToSingle_String = GetMethod(MS_VB_CS_Conversions, "ToSingle", System_String)
         MS_VB_CS_Conversions__ToDouble_String = GetMethod(MS_VB_CS_Conversions, "ToDouble", System_String)
         MS_VB_CS_Conversions__ToDecimal_String = GetMethod(MS_VB_CS_Conversions, "ToDecimal", System_String)
         MS_VB_CS_Conversions__ToDecimal_Boolean = GetMethod(MS_VB_CS_Conversions, "ToDecimal", System_Boolean)
         MS_VB_CS_Conversions__ToString_Decimal = GetMethod(MS_VB_CS_Conversions, "ToString", System_Decimal)
         MS_VB_CS_Conversions__ToString_Boolean = GetMethod(MS_VB_CS_Conversions, "ToString", System_Boolean)
         MS_VB_CS_Conversions__ToString_Char = GetMethod(MS_VB_CS_Conversions, "ToString", System_Char)
         MS_VB_CS_Conversions__ToString_DateTime = GetMethod(MS_VB_CS_Conversions, "ToString", System_DateTime)
         MS_VB_CS_Conversions__ToString_Byte = GetMethod(MS_VB_CS_Conversions, "ToString", System_Byte)
         MS_VB_CS_Conversions__ToString_Int32 = GetMethod(MS_VB_CS_Conversions, "ToString", System_Int32)
         MS_VB_CS_Conversions__ToString_UInt32 = GetMethod(MS_VB_CS_Conversions, "ToString", System_UInt32)
         MS_VB_CS_Conversions__ToString_Int64 = GetMethod(MS_VB_CS_Conversions, "ToString", System_Int64)
         MS_VB_CS_Conversions__ToString_UInt64 = GetMethod(MS_VB_CS_Conversions, "ToString", System_UInt64)
         MS_VB_CS_Conversions__ToString_Single = GetMethod(MS_VB_CS_Conversions, "ToString", System_Single)
         MS_VB_CS_Conversions__ToString_Double = GetMethod(MS_VB_CS_Conversions, "ToString", System_Double)
         MS_VB_CS_Conversions__ToString_Object = GetMethod(MS_VB_CS_Conversions, "ToString", System_Object)
         MS_VB_CS_Conversions__ToGenericParameter_Object = GetMethod(MS_VB_CS_Conversions, "ToGenericParameter", System_Object)
         MS_VB_CS_Conversions__ChangeType_Object_Type = GetMethod(MS_VB_CS_Conversions, "ChangeType", System_Object, System_Type)
         MS_VB_CS_Conversions__ToCharArrayRankOne_String = GetMethod(MS_VB_CS_Conversions, "ToCharArrayRankOne", System_String)
         MS_VB_CS_LikeOperator__LikeString_String_String_CompareMethod = GetMethod(MS_VB_CS_LikeOperator, "LikeString", System_String, System_String, MS_VB_CompareMethod)
         MS_VB_CS_LikeOperator__LikeObject_Object_Object_CompareMethod = GetMethod(MS_VB_CS_LikeOperator, "LikeObject", System_Object, System_Object, MS_VB_CompareMethod)
         MS_VB_CS_StringType__MidStmtStr_String_Int32_Int32_String = GetMethod(MS_VB_CS_StringType, "MidStmtStr", System_String_ByRef, System_Int32, System_Int32, System_String)
         MS_VB_CS_ObjectFlowControl__CheckForSyncLockOnValueType_Object = GetMethod(MS_VB_CS_ObjectFlowControl, "CheckForSyncLockOnValueType", System_Object)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForLoopInitObj_Object_Object_Object_Object_Object_Object = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForLoopInitObj", System_Object, System_Object, System_Object, System_Object, System_Object_ByRef, System_Object_ByRef)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckDec_Decimal_Decimal_Decimal = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckDec", System_Decimal, System_Decimal, System_Decimal)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckObj_Object_Object_Object = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckObj", System_Object, System_Object, System_Object_ByRef)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR4_Single_Single_Single = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckR4", System_Single, System_Single, System_Single)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR8_Double_Double_Double = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckR8", System_Double, System_Double, System_Double)
         MS_VB_CS_Utils__CopyArray_Array_Array = GetMethod(MS_VB_CS_Utils, "CopyArray", System_Array, System_Array)
         MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectNotEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectNotEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectGreater", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectGreaterEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectLess", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectLessEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareString_String_String_Boolean = GetMethod(MS_VB_CS_Operators, "CompareString", System_String, System_String, System_Boolean)
         MS_VB_CS_Operators__ConcatenateObject_Object_Object = GetMethod(MS_VB_CS_Operators, "ConcatenateObject", System_Object, System_Object)
         MS_VB_CS_Operators__AddObject_Object_Object = GetMethod(MS_VB_CS_Operators, "AddObject", System_Object, System_Object)
         MS_VB_CS_Operators__AndObject_Object_Object = GetMethod(MS_VB_CS_Operators, "AndObject", System_Object, System_Object)
         MS_VB_CS_Operators__DivideObject_Object_Object = GetMethod(MS_VB_CS_Operators, "DivideObject", System_Object, System_Object)
         MS_VB_CS_Operators__ExponentObject_Object_Object = GetMethod(MS_VB_CS_Operators, "ExponentObject", System_Object, System_Object)
         MS_VB_CS_Operators__IntDivideObject_Object_Object = GetMethod(MS_VB_CS_Operators, "IntDivideObject", System_Object, System_Object)
         MS_VB_CS_Operators__LeftShiftObject_Object_Object = GetMethod(MS_VB_CS_Operators, "LeftShiftObject", System_Object, System_Object)
         MS_VB_CS_Operators__ModObject_Object_Object = GetMethod(MS_VB_CS_Operators, "ModObject", System_Object, System_Object)
         MS_VB_CS_Operators__MultiplyObject_Object_Object = GetMethod(MS_VB_CS_Operators, "MultiplyObject", System_Object, System_Object)
         MS_VB_CS_Operators__NegateObject_Object = GetMethod(MS_VB_CS_Operators, "NegateObject", System_Object)
         MS_VB_CS_Operators__NotObject_Object = GetMethod(MS_VB_CS_Operators, "NotObject", System_Object)
         MS_VB_CS_Operators__OrObject_Object_Object = GetMethod(MS_VB_CS_Operators, "OrObject", System_Object, System_Object)
         MS_VB_CS_Operators__PlusObject_Object = GetMethod(MS_VB_CS_Operators, "PlusObject", System_Object)
         MS_VB_CS_Operators__RightShiftObject_Object_Object = GetMethod(MS_VB_CS_Operators, "RightShiftObject", System_Object, System_Object)
         MS_VB_CS_Operators__SubtractObject_Object_Object = GetMethod(MS_VB_CS_Operators, "SubtractObject", System_Object, System_Object)
         MS_VB_CS_Operators__XorObject_Object_Object = GetMethod(MS_VB_CS_Operators, "XorObject", System_Object, System_Object)
         MS_VB_CS_Operators__LikeObject_Object_Object_CompareMethod = GetMethod(MS_VB_CS_Operators, "LikeObject", System_Object, System_Object, MS_VB_CompareMethod)
         MS_VB_CS_Operators__LikeString_String_String_CompareMethod = GetMethod(MS_VB_CS_Operators, "LikeString", System_String, System_String, MS_VB_CompareMethod)
         MS_VB_CS_Operators__CompareObjectEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectNotEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectNotEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectGreater_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectGreater", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectGreaterEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectGreaterEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectLess_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectLess", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectLessEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectLessEqual", System_Object, System_Object, System_Boolean)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="42" endline="335"><![CDATA[
     Public Shared LikeDefinedTypes As String = "S"
     Public Shared LikeResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBBBBBBBBBBBBBB-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "-------------------" & _
             "XBXDDDDDDDDDDDDDD-D"
     Public Shared LikeOperandType As String = "" & _
                 "XXXXXXXXXXXXXXXXX-X" & _
                 "XBXBBBBBBBBBBBBBB-B" & _
                 "XXXXXXXXXXXXXXXXX-X" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "-------------------" & _
                 "XBXSSSSSSSSSSSSSS-S"
 
     Public Shared ConcatResultType As String = LikeOperandType
     Public Shared ConcatDefinedTypes As String = "S"
     Public Shared ConcatOperandType As String = LikeOperandType
 
     Public Shared ModResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLPNOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLPNOPX-O" & _
             "XBXHXHGHIJKLMNOPX-O" & _
             "XBXHXHHHJJLLPNOPX-O" & _
             "XBXJXJIJIJKLMNOPX-O" & _
             "XBXJXJJJJJLLPNOPX-O" & _
             "XBXLXLKLKLKLMNOPX-O" & _
             "XBXLXLLLLLLLPNOPX-O" & _
             "XBXPXPMPMPMPMNOPX-O" & _
             "XBXNXNNNNNNNNNOPX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXPXPPPPPPPPPOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXOXOOOOOOOOOOOX-O"
     Public Shared ModDefinedTypes As String = "FGHIJKLMNOP"
 
     Public Shared IntDivResultTypes As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXHHJJJLLLLLLX-L" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXHXGHJJJLLLLLLX-L" & _
             "XBXHXHHIIJKLMLLLX-L" & _
             "XBXJXJIIJJLLLLLLX-L" & _
             "XBXJXJIJIJKLMLLLX-L" & _
             "XBXJXJJJJJLLLLLLX-L" & _
             "XBXLXLKLKLKLMLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLMLMLMLMLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXLXLLLLLLLLLLLX-L"
     Public Shared IntDivDefinedTypes As String = "FGHIJKLM"
 
     Public Shared RealDivResultTypes As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXOXOOOOOOOONOOX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXOXOOOOOOOONOOX-O" & _
             "XBXOXOOOOOOOONOOX-O" & _
             "XBXOXOOOOOOOONOOX-O" & _
             "XBXOXOOOOOOOONOOX-O" & _
             "XBXOXOOOOOOOONOOX-O" & _
             "XBXOXOOOOOOOONOOX-O" & _
             "XBXOXOOOOOOOONOOX-O" & _
             "XBXOXOOOOOOOONOOX-O" & _
             "XBXNXNNNNNNNNNOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXOXOOOOOOOOOOOX-O"
     Public Shared RealDivDefinedTypes As String = "NOP"
 
     Public Shared AddResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBBBBBBBBBBBBBB-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLPNOPX-O" & _
             "XBXXSXXXXXXXXXXXX-S" & _
             "XBXFXFHHJJLLPNOPX-O" & _
             "XBXHXHGHIJKLMNOPX-O" & _
             "XBXHXHHHJJLLPNOPX-O" & _
             "XBXJXJIJIJKLMNOPX-O" & _
             "XBXJXJJJJJLLPNOPX-O" & _
             "XBXLXLKLKLKLMNOPX-O" & _
             "XBXLXLLLLLLLPNOPX-O" & _
             "XBXPXPMPMPMPMNOPX-O" & _
             "XBXNXNNNNNNNNNOPX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXPXPPPPPPPPPOPX-O" & _
             "XBXXXXXXXXXXXXXXX-S" & _
             "-------------------" & _
             "XBXOSOOOOOOOOOOOS-S"
     Public Shared AddDefinedTypes As String = "FGHIJKLMNOPS"
 
     Public Shared SubResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLPNOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLPNOPX-O" & _
             "XBXHXHGHIJKLMNOPX-O" & _
             "XBXHXHHHJJLLPNOPX-O" & _
             "XBXJXJIJIJKLMNOPX-O" & _
             "XBXJXJJJJJLLPNOPX-O" & _
             "XBXLXLKLKLKLMNOPX-O" & _
             "XBXLXLLLLLLLPNOPX-O" & _
             "XBXPXPMPMPMPMNOPX-O" & _
             "XBXNXNNNNNNNNNOPX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXPXPPPPPPPPPOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXOXOOOOOOOOOOOX-O"
     Public Shared SubDefinedTypes As String = "FGHIJKLMNOP"
 
     Public Shared MultResultType As String = SubResultType
     Public Shared MultDefinedTypes As String = "FGHIJKLMNOP"
 
     Public Shared ShortcircuitResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXDXDDDDDDDDDDDX-D"
     Public Shared ShortcircuitDefinedTypes As String = "D"
 
     Public Shared LogicalOperatorResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDXFHHJJLLLLLLX-D" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLLLLLX-L" & _
             "XBXHXHGHIJKLMLLLX-L" & _
             "XBXHXHHHJJLLLLLLX-L" & _
             "XBXJXJIJIJKLMLLLX-L" & _
             "XBXJXJJJJJLLLLLLX-L" & _
             "XBXLXLKLKLKLMLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLMLMLMLMLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXDXLLLLLLLLLLLX-L"
     Public Shared LogicalDefinedTypes As String = "DFGHIJKLM"
 
     Public Shared RelationalOperandTypes As String = _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBBBBBBBBBBBBBB-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDXFHHJJPLPNOPX-D" & _
             "XBXXEXXXXXXXXXXXX-S" & _
             "XBXFXFHHJJPLPNOPX-O" & _
             "XBXHXHGHIJKLMNOPX-O" & _
             "XBXHXHHHJJPLPNOPX-O" & _
             "XBXIXJIJIJKLMNOPX-O" & _
             "XBXJXJJJJJPLPNOPX-O" & _
             "XBXPXPKPKPKLMNOPX-O" & _
             "XBXLXLLLLLLLPNOPX-O" & _
             "XBXPXPMPMPMPMNOPX-O" & _
             "XBXNXNNNNNNNNNOPX-O" & _
             "XBXOXOOOOOOOOOOPX-O" & _
             "XBXPXPPPPPPPPPPPX-O" & _
             "XBXXXXXXXXXXXXXXQ-Q" & _
             "-------------------" & _
             "XBXDSOOOOOOOOOOOQ-S"
     Public Shared RelationalDefinedTypes As String = "DEFGHIJKLMNOPQS"
 
 
     Public Shared ExponentResultTypes As String = _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXOXOOOOOOOOOOOX-O"
     Public Shared ExponentDefinedTypes As String = "O"
 
     Public Shared NotOperatorResultType As String = "XBXDXFGHIJKLMLLLX-L"
     Public Shared NotDefinedTypes As String = "DFGHIJKLM"
 
     Public Shared UnaryPlusResultType As String = "XBXFXFGHIJKLMNOPX-O"
     Public Shared UnaryPlusDefinedTypes As String = "FGHIJKLMNOP"
 
     Public Shared UnaryMinusResultType As String = "XBXFXFHHJJLLPNOPX-O"
     Public Shared UnaryMinusDefinedTypes As String = "FHJLNOP"
 
     Public Shared ShiftDefinedTypes As String = "FGHIJKLM"
     Public Shared ShiftResultType As String = _
  "XXXXXXXXXXXXXXXXX-X" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XXXXXXXXXXXXXXXXX-X" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XXXXXXXXXXXXXXXXX-X" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XBXFXFGHIJKLMLLLX-L" & _
  "XXXXXXXXXXXXXXXXX-X" & _
  "-------------------" & _
  "XBXFXFGHIJKLMLLLX-L"
 
 
     ''' <summary>
     ''' X=?
     ''' I=Implicit ok
     ''' 0=Explicit ok
     ''' 1=30311
     ''' 2=32007
     ''' 3=30533
     ''' 4=32006
     ''' 5=30532
     ''' 6=30533
     ''' A=30311, only explicit
     ''' </summary>
     ''' <remarks></remarks>
     Public Shared ConversionResultType As String = _
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="336" endline="372"><![CDATA[
             "XXXXXXXXXXXXXXXXX-X" & _
             "X0X00000000000000-0" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XIXI1000000000001-0" & _
             "XIX1I222222221111-0" & _
             "XIX04I00000000001-0" & _
             "XIX040I0000000001-0" & _
             "XIX0400I000000001-0" & _
             "XIX04000I00000001-0" & _
             "XIX040000I0000001-0" & _
             "XIX0400000I000001-0" & _
             "XIX04000000I00001-0" & _
             "XIX040000000I0001-0" & _
             "XIX0100000000I001-0" & _
             "XIX01000000000I05-0" & _
             "XIX010000000000I1-0" & _
             "XIX1111111111161I-0" & _
             "-------------------" & _
             "XIX00000000000000-I"
 
     Shared Function GetErrorNumberForBinaryOperation(ByVal op As KS, ByVal left As TypeCode, ByVal right As TypeCode) As Integer
         If op = KS.ShiftLeft OrElse op = KS.ShiftRight Then
             If left = TypeCode.Object AndAlso (right = TypeCode.DateTime OrElse right = TypeCode.Char) Then Return 0
             If left <> TypeCode.DateTime AndAlso left <> TypeCode.Char Then
                 If right = TypeCode.DateTime Then Return 30311
                 If right = TypeCode.Char Then Return 32006
             End If
         ElseIf (op = KS.Add OrElse op = KS.Minus) AndAlso left = TypeCode.DateTime AndAlso right = TypeCode.DateTime Then
             Return 0
         End If
 
         Dim resultType As TypeCode
         resultType = TypeConverter.GetBinaryResultType(op, left, right)
 
         If resultType = TypeCode.Empty Then Return 30452
         Return 0
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="373" endline="397"><![CDATA[
 
     Shared Function GetErrorNumberForConversion(ByVal tp1 As TypeCode, ByVal tp2 As TypeCode, ByVal Implicit As Boolean) As Integer
         Select Case GetConversionResultType(tp1, tp2)
             Case "X"c
                 Throw New NotImplementedException
             Case "I"c
                 Return 0
             Case "0"c
                 Return 0
             Case "1"c
                 Return 30311
             Case "2"c
                 Return 32007
             Case "3"c
                 Return 30533
             Case "4"c
                 Return 32006
             Case "5"c
                 Return 30532
             Case "6"c
                 Return 30533
             Case Else
                 Throw New NotImplementedException
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="398" endline="401"><![CDATA[
 
     Shared Function GetConversionResultType(ByVal tp1 As TypeCode, ByVal tp2 As TypeCode) As Char
         Return GetArrayChar(tp1, tp2, ConversionResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="402" endline="405"><![CDATA[
 
     Shared Function GetExpOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetExpResultType(op1, op2)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="406" endline="409"><![CDATA[
 
     Shared Function GetEqualsOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, RelationalOperandTypes)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="410" endline="413"><![CDATA[
 
     Shared Function GetLTOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, RelationalOperandTypes)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="414" endline="417"><![CDATA[
 
     Shared Function GetGTOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, RelationalOperandTypes)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="418" endline="421"><![CDATA[
 
     Shared Function GetLEOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, RelationalOperandTypes)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="422" endline="425"><![CDATA[
 
     Shared Function GetGEOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, RelationalOperandTypes)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="426" endline="429"><![CDATA[
 
     Shared Function GetNotEqualsOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, RelationalOperandTypes)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="430" endline="433"><![CDATA[
 
     Shared Function GetShiftResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, ShiftResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="434" endline="437"><![CDATA[
 
     Shared Function GetModResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, ModResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="438" endline="441"><![CDATA[
 
     Shared Function GetLikeResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, LikeResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="442" endline="445"><![CDATA[
 
     Shared Function GetLikeOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, LikeOperandType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="446" endline="449"><![CDATA[
 
     Shared Function GetConcatResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, ConcatResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="450" endline="453"><![CDATA[
 
     Shared Function GetConcatOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, ConcatOperandType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="454" endline="457"><![CDATA[
 
     Shared Function GetRealDivResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, RealDivResultTypes)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="458" endline="461"><![CDATA[
 
     Shared Function GetIntDivResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, IntDivResultTypes)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="462" endline="465"><![CDATA[
 
     Shared Function GetExpResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, ExponentResultTypes)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="466" endline="470"><![CDATA[
 
     Shared Function GetEqualsResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         If GetEqualsOperandType(op1, op2) = TypeCode.Empty Then Return TypeCode.Empty
         Return TypeCode.Boolean
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="471" endline="475"><![CDATA[
 
     Shared Function GetLTResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         If GetLTOperandType(op1, op2) = TypeCode.Empty Then Return TypeCode.Empty
         Return TypeCode.Boolean
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="476" endline="480"><![CDATA[
 
     Shared Function GetGTResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         If GetGTOperandType(op1, op2) = TypeCode.Empty Then Return TypeCode.Empty
         Return TypeCode.Boolean
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="481" endline="485"><![CDATA[
 
     Shared Function GetLEResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         If GetLEOperandType(op1, op2) = TypeCode.Empty Then Return TypeCode.Empty
         Return TypeCode.Boolean
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="486" endline="490"><![CDATA[
 
     Shared Function GetGEResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         If GetGEOperandType(op1, op2) = TypeCode.Empty Then Return TypeCode.Empty
         Return TypeCode.Boolean
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="491" endline="495"><![CDATA[
 
     Shared Function GetNotEqualsResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         If GetNotEqualsOperandType(op1, op2) = TypeCode.Empty Then Return TypeCode.Empty
         Return TypeCode.Boolean
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="496" endline="499"><![CDATA[
 
     Shared Function GetUnaryMinusResultType(ByVal op1 As TypeCode) As TypeCode
         Return GetResultType(op1, UnaryMinusResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="500" endline="503"><![CDATA[
 
     Shared Function GetUnaryPlusResultType(ByVal op1 As TypeCode) As TypeCode
         Return GetResultType(op1, UnaryPlusResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="504" endline="507"><![CDATA[
 
     Shared Function GetAndResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, LogicalOperatorResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="508" endline="511"><![CDATA[
 
     Shared Function GetOrResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, LogicalOperatorResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="512" endline="515"><![CDATA[
 
     Shared Function GetXorResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, LogicalOperatorResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="516" endline="519"><![CDATA[
 
     Shared Function GetUnaryNotResultType(ByVal op1 As TypeCode) As TypeCode
         Return GetResultType(op1, NotOperatorResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="520" endline="523"><![CDATA[
 
     Shared Function GetOrElseResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, ShortcircuitResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="524" endline="527"><![CDATA[
 
     Shared Function GetAndAlsoResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, ShortcircuitResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="528" endline="531"><![CDATA[
 
     Shared Function GetMultResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, MultResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="532" endline="535"><![CDATA[
 
     Shared Function GetBinaryAddResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, AddResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="536" endline="539"><![CDATA[
 
     Shared Function GetBinarySubResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return GetResultType(op1, op2, SubResultType)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="540" endline="543"><![CDATA[
 
     Shared Function GetIsIsNotOperandType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return TypeCode.Object
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="544" endline="547"><![CDATA[
 
     Shared Function GetIsIsNotResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Return TypeCode.Boolean
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="548" endline="560"><![CDATA[
 
     Shared Function GetUnaryResultType(ByVal op As KS, ByVal op1 As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(op1)
             Case KS.Minus
                 Return GetUnaryMinusResultType(op1)
             Case KS.Not
                 Return GetUnaryNotResultType(op1)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="561" endline="611"><![CDATA[
 
     Shared Function GetBinaryResultType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatResultType(op1, op2)
             Case KS.GE
                 Return GetGEResultType(op1, op2)
             Case KS.GT
                 Return GetGTResultType(op1, op2)
             Case KS.LE
                 Return GetLEResultType(op1, op2)
             Case KS.LT
                 Return GetLTResultType(op1, op2)
             Case KS.Equals
                 Return GetEqualsResultType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsResultType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeResultType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotResultType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="612" endline="624"><![CDATA[
 
     Shared Function GetUnaryOperandType(ByVal op As KS, ByVal operand As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(operand)
             Case KS.Minus
                 Return GetUnaryMinusResultType(operand)
             Case KS.Not
                 Return GetUnaryNotResultType(operand)
             Case Else
                 Throw New NotImplementedException
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="625" endline="672"><![CDATA[
 
     Shared Function GetBinaryOperandType(ByVal Compiler As Compiler, ByVal op As KS, ByVal op1 As Mono.Cecil.TypeReference, ByVal op2 As Mono.Cecil.TypeReference) As TypeCode
         Dim result As TypeCode
 
         result = GetBinaryOperandType(op, Helper.GetTypeCode(Compiler, op1), Helper.GetTypeCode(Compiler, op2))
 
         If result = TypeCode.Object Then
             Dim isIntrinsic1, isIntrinsic2 As Boolean
             Dim conv1, conv2 As TypeCode()
             Dim defs As String
 
             isIntrinsic1 = Helper.IsIntrinsicType(Compiler, op1)
             isIntrinsic2 = Helper.IsIntrinsicType(Compiler, op2)
 
             If isIntrinsic1 = isIntrinsic2 Then Return result
 
             defs = GetBinaryOperandDefinedTypes(op)
 
             Dim conversions As New Generic.List(Of TypeCode)
             If isIntrinsic1 = False Then
                 conv1 = TypeResolution.GetIntrinsicTypesImplicitlyConvertibleFrom(Compiler, op1)
                 If conv1 IsNot Nothing Then
                     For i As Integer = 0 To conv1.Length - 1
                         Dim chr As Char = GetCharOfTypeCode(conv1(i))
                         If defs.IndexOf(chr) >= 0 Then conversions.Add(conv1(i))
                     Next
                     If conversions.Count = 1 Then
                         result = GetBinaryOperandType(op, conversions(0), Helper.GetTypeCode(Compiler, op2))
                     End If
                 End If
             End If
             If isIntrinsic2 = False Then
                 conv2 = TypeResolution.GetIntrinsicTypesImplicitlyConvertibleFrom(Compiler, op2)
                 If conv2 IsNot Nothing Then
                     For i As Integer = 0 To conv2.Length - 1
                         Dim chr As Char = GetCharOfTypeCode(conv2(i))
                         If defs.IndexOf(chr) >= 0 Then conversions.Add(conv2(i))
                     Next
                     If conversions.Count = 1 Then
                         result = GetBinaryOperandType(op, Helper.GetTypeCode(Compiler, op1), conversions(0))
                     End If
                 End If
             End If
 
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="673" endline="723"><![CDATA[
 
     Shared Function GetBinaryOperandDefinedTypes(ByVal op As KS) As String
         Select Case op
             Case KS.And
                 Return LogicalDefinedTypes
             Case KS.AndAlso
                 Return ShortcircuitDefinedTypes
             Case KS.Or
                 Return LogicalDefinedTypes
             Case KS.OrElse
                 Return ShortcircuitDefinedTypes
             Case KS.Xor
                 Return LogicalDefinedTypes
             Case KS.Add
                 Return AddDefinedTypes
             Case KS.Minus
                 Return SubDefinedTypes
             Case KS.Mult
                 Return MultDefinedTypes
             Case KS.RealDivision
                 Return RealDivDefinedTypes
             Case KS.IntDivision
                 Return IntDivDefinedTypes
             Case KS.Power
                 Return ExponentDefinedTypes
             Case KS.Concat
                 Return ConcatDefinedTypes
             Case KS.GE
                 Return RelationalDefinedTypes
             Case KS.GT
                 Return RelationalDefinedTypes
             Case KS.LE
                 Return RelationalDefinedTypes
             Case KS.LT
                 Return RelationalDefinedTypes
             Case KS.Equals
                 Return RelationalDefinedTypes
             Case KS.NotEqual
                 Return RelationalDefinedTypes
             Case KS.ShiftLeft, KS.ShiftRight
                 Return ShiftDefinedTypes
             Case KS.Mod
                 Return ModDefinedTypes
             Case KS.Like
                 Return LikeDefinedTypes
             Case KS.Is, KS.IsNot
                 Return String.Empty
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="724" endline="774"><![CDATA[
 
     Private Shared Function GetBinaryOperandType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatOperandType(op1, op2)
             Case KS.GE
                 Return GetGEOperandType(op1, op2)
             Case KS.GT
                 Return GetGTOperandType(op1, op2)
             Case KS.LE
                 Return GetLEOperandType(op1, op2)
             Case KS.LT
                 Return GetLTOperandType(op1, op2)
             Case KS.Equals
                 Return GetEqualsOperandType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsOperandType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeOperandType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotOperandType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="775" endline="778"><![CDATA[
 
     Private Shared Function GetArrayChar(ByVal op1 As TypeCode, ByVal op2 As TypeCode, ByVal array As String) As Char
         Return array.Chars(op1 + op2 * 19)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="779" endline="788"><![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="789" endline="792"><![CDATA[
 
     Private Shared Function GetTypeCodeOfChar(ByVal chr As Char) As TypeCode
         Return CType(Microsoft.VisualBasic.Asc(chr) - Microsoft.VisualBasic.Asc("A"c), TypeCode)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="793" endline="796"><![CDATA[
 
     Private Shared Function GetCharOfTypeCode(ByVal code As TypeCode) As Char
         Return Microsoft.VisualBasic.Chr(code + Microsoft.VisualBasic.Asc("A"c))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="797" endline="806"><![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1 + op2 * 19)
         If chr = "X"c Then
             Return Nothing
         Else
             Return CType(Microsoft.VisualBasic.Asc(chr) - Microsoft.VisualBasic.Asc("A"), TypeCode)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="807" endline="877"><![CDATA[
 
     ''' <summary>
     ''' Converts the source to the destination type. Compiletime conversions are the only ones that succeeds.
     ''' Returns nothing if no conversion possible.
     ''' </summary>
     ''' <param name="Source"></param>
     ''' <param name="Destination"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Shared Function ConvertTo(ByVal Context As ParsedObject, ByVal Source As Object, ByVal Destination As Mono.Cecil.TypeReference, ByRef result As Object) As Boolean
         If Destination Is Nothing OrElse Source Is Nothing Then
             result = Source
             Return True
         End If
 
         Helper.Assert(Source IsNot Nothing)
         Helper.Assert(Destination IsNot Nothing)
 
         If TypeOf Destination Is ByReferenceType Then
             Destination = DirectCast(Destination, ByReferenceType).ElementType
         End If
 
         Dim dtc As TypeCode = Helper.GetTypeCode(Context.Compiler, Destination)
         Dim stc As TypeCode = Helper.GetTypeCode(Context.Compiler, CecilHelper.GetType(Context.Compiler, Source))
 
         'Console.WriteLine("ConvertTo
 
         If dtc = stc Then
             result = Source
             Return True
         End If
 
         Select Case dtc
             Case TypeCode.Boolean
                 Return ConvertToBoolean(Context, Source, stc, result)
             Case TypeCode.Byte
                 Return ConvertToByte(Context, Source, stc, result)
             Case TypeCode.Char
                 Return ConvertToChar(Context, Source, stc, result)
             Case TypeCode.DateTime
                 Return ConvertToDateTime(Context, Source, stc, result)
             Case TypeCode.Decimal
                 Return ConvertToDecimal(Context, Source, stc, result)
             Case TypeCode.Double
                 Return ConvertToDouble(Context, Source, stc, result)
             Case TypeCode.Int16
                 Return ConvertToInt16(Context, Source, stc, result)
             Case TypeCode.Int32
                 Return ConvertToInt32(Context, Source, stc, result)
             Case TypeCode.Int64
                 Return ConvertToInt64(Context, Source, stc, result)
             Case TypeCode.SByte
                 Return ConvertToSByte(Context, Source, stc, result)
             Case TypeCode.Single
                 Return ConvertToSingle(Context, Source, stc, result)
             Case TypeCode.String
                 Return ConvertToString(Context, Source, stc, result)
             Case TypeCode.UInt16
                 Return ConvertToUInt16(Context, Source, stc, result)
             Case TypeCode.UInt32
                 Return ConvertToUInt32(Context, Source, stc, result)
             Case TypeCode.UInt64
                 Return ConvertToUInt64(Context, Source, stc, result)
             Case TypeCode.Object
                 result = Source
                 Return True
             Case Else
                 'This should never happen 
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, CObj(dtc).ToString())
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="878" endline="928"><![CDATA[
 
     Public Shared Function ConvertToBoolean(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = Source
                 Return True
             Case TypeCode.Byte
                 result = CBool(DirectCast(Source, Byte))
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Boolean")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Boolean")
             Case TypeCode.Decimal
                 result = CBool(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 result = CBool(DirectCast(Source, Double))
                 Return True
             Case TypeCode.Int16
                 result = CBool(DirectCast(Source, Short))
                 Return True
             Case TypeCode.Int32
                 result = CBool(DirectCast(Source, Integer))
                 Return True
             Case TypeCode.Int64
                 result = CBool(DirectCast(Source, Long))
                 Return True
             Case TypeCode.SByte
                 result = CBool(DirectCast(Source, SByte))
                 Return True
             Case TypeCode.Single
                 result = CBool(DirectCast(Source, Single))
                 Return True
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.UInt16
                 result = CBool(DirectCast(Source, UShort))
                 Return True
             Case TypeCode.UInt32
                 result = CBool(DirectCast(Source, UInteger))
                 Return True
             Case TypeCode.UInt64
                 result = CBool(DirectCast(Source, ULong))
                 Return True
             Case TypeCode.DBNull
                 result = CBool(Nothing)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Boolean")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="929" endline="1010"><![CDATA[
 
     Public Shared Function ConvertToByte(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CByte(i)
                 Return True
             Case TypeCode.Byte
                 result = Source
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, "Byte")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Byte")
             Case TypeCode.Decimal
                 Dim i As Decimal = DirectCast(Source, Decimal)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Int16
                 Dim i As Short = DirectCast(Source, Short)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Int32
                 Dim i As Integer = DirectCast(Source, Integer)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Int64
                 Dim i As Long = DirectCast(Source, Long)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.SByte
                 Dim i As SByte = DirectCast(Source, SByte)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.UInt16
                 Dim i As UShort = DirectCast(Source, UShort)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.UInt32
                 Dim i As UInteger = DirectCast(Source, UInteger)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.UInt64
                 Dim i As ULong = DirectCast(Source, ULong)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.DBNull
                 result = CByte(0)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Byte")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1011" endline="1056"><![CDATA[
 
     Public Shared Function ConvertToChar(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Boolean", "Char")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Byte")
             Case TypeCode.Char
                 result = Source
                 Return True
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "DateTime", "Char")
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Decimal", "Char")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Double", "Char")
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Short")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Integer")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Long")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "SByte")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Single", "Char")
             Case TypeCode.String
                 Dim str As String = DirectCast(Source, String)
                 If str.Length >= 1 Then
                     result = str(0)
                 Else
                     result = CChar(Nothing)
                 End If
                 Return True
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "UShort")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "UInteger")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "ULong")
             Case TypeCode.DBNull
                 result = VB.Chr(0)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Char")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1057" endline="1096"><![CDATA[
 
     Public Shared Function ConvertToDateTime(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Boolean", "Date")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Byte", "Date")
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Date")
             Case TypeCode.DateTime
                 result = Source
                 Return True
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Decimal", "Date")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30533, Context.Location)
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Short", "Date")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Integer", "Date")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Long", "Date")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "SByte", "Date")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Single", "Date")
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Date")
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UShort", "Date")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UInteger", "Date")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "ULong", "Date")
             Case TypeCode.DBNull
                 result = New Date()
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Date")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1097" endline="1136"><![CDATA[
 
     Public Shared Function ConvertToDecimal(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CDec(i)
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Decimal")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Decimal")
             Case TypeCode.Decimal
                 result = Source
                 Return True
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Decimal.MinValue AndAlso i <= Decimal.MaxValue Then
                     result = CDec(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CDec(CLng(Source))
                 Return True
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= Decimal.MinValue AndAlso i <= Decimal.MaxValue Then
                     result = CDec(i)
                     Return True
                 End If
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Decimal")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CDec(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0D
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Decimal")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1137" endline="1169"><![CDATA[
 
     Public Shared Function ConvertToDouble(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = CDbl(DirectCast(Source, Boolean))
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Double")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30532, Context.Location)
             Case TypeCode.Decimal
                 result = CDbl(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 result = Source
                 Return True
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CDbl(CLng(Source))
                 Return True
             Case TypeCode.Single
                 result = CDbl(DirectCast(Source, Single))
                 Return True
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Double")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CDbl(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0.0R
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Double")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1170" endline="1214"><![CDATA[
 
     Public Shared Function ConvertToInt16(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Short"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CShort(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0S
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1215" endline="1259"><![CDATA[
 
     Public Shared Function ConvertToInt32(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Integer"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CInt(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0I
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1260" endline="1304"><![CDATA[
 
     Public Shared Function ConvertToInt64(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Long"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CLng(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0L
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1305" endline="1386"><![CDATA[
 
     Public Shared Function ConvertToSByte(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CSByte(i)
                 Return True
             Case TypeCode.Byte
                 Dim i As Byte = DirectCast(Source, Byte)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, "SByte")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "SByte")
             Case TypeCode.Decimal
                 Dim i As Decimal = DirectCast(Source, Decimal)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int16
                 Dim i As Short = DirectCast(Source, Short)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int32
                 Dim i As Integer = DirectCast(Source, Integer)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int64
                 Dim i As Long = DirectCast(Source, Long)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.SByte
                 result = Source
                 Return True
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "SByte", "String")
             Case TypeCode.UInt16
                 Dim i As UShort = DirectCast(Source, UShort)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.UInt32
                 Dim i As UInteger = DirectCast(Source, UInteger)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.UInt64
                 Dim i As ULong = DirectCast(Source, ULong)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.DBNull
                 result = CSByte(0)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "SByte")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1387" endline="1422"><![CDATA[
 
     Public Shared Function ConvertToSingle(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = CSng(DirectCast(Source, Boolean))
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Single")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Single")
             Case TypeCode.Decimal
                 result = CSng(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Single.MinValue AndAlso i <= Single.MaxValue Then
                     result = CSng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CSng(CLng(Source))
                 Return True
             Case TypeCode.Single
                 result = Source
                 Return True
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Single")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CSng(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0.0!
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Single")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1423" endline="1463"><![CDATA[
 
     Public Shared Function ConvertToString(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Boolean", "String")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.Char
                 result = CStr(DirectCast(Source, Char))
                 Return True
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Date", "String")
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Decimal", "String")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Double", "String")
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Short", "String")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Integer", "String")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Long", "String")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "SByte", "String")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Single", "String")
             Case TypeCode.String
                 result = Source
                 Return True
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UShort", "String")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UInteger", "String")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "ULong", "String")
             Case TypeCode.DBNull
                 result = Nothing
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "String")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1464" endline="1508"><![CDATA[
 
     Public Shared Function ConvertToUInt16(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "UShort"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CUShort(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0US
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1509" endline="1553"><![CDATA[
 
     Public Shared Function ConvertToUInt32(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "UInteger"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CUInt(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0UI
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1554" endline="1598"><![CDATA[
 
     Public Shared Function ConvertToUInt64(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "ULong"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CULng(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0UL
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="23" endline="23"><![CDATA[
     Public Shared ReadOnly EmptyDictionary As New TypeDictionary()
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="24" endline="27"><![CDATA[
 
     Sub New()
         MyBase.new(Helper.StringComparer)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="28" endline="36"><![CDATA[
 
     Shadows Sub Add(ByVal Type As Mono.Cecil.TypeReference)
         Dim name As String = Type.Name
         If MyBase.ContainsKey(name) Then
             'System.Console.WriteLine("Already added type
         Else
             MyBase.Add(name, Type)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="37" endline="42"><![CDATA[
 
     Shadows Sub AddRange(ByVal Types As Generic.IEnumerable(Of Mono.Cecil.TypeReference))
         For Each Type As Mono.Cecil.TypeReference In Types
             Add(Type)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="43" endline="49"><![CDATA[
 
     Function TypesAsArray() As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         ReDim result(Me.Count - 1)
         MyBase.Values.CopyTo(result, 0)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="50" endline="55"><![CDATA[
 
     Function ToTypeList() As TypeList
         Dim result As New TypeList()
         result.AddRange(Me.Values)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="56" endline="71"><![CDATA[
 
     ''' <summary>
     ''' Returns nothing if the specified key is not found.
     ''' </summary>
     ''' <param name="key"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal key As String) As Mono.Cecil.TypeReference
         Get
             If MyBase.ContainsKey(key) Then
                 Return MyBase.Item(key)
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="57" endline="57"><![CDATA[
     Private Shared m_GenericTypeCache As New Generic.Dictionary(Of String, Mono.Cecil.GenericInstanceType)(vbnc.Helper.StringComparer)
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="58" endline="67"><![CDATA[
 
     Public MemberCache As New Generic.Dictionary(Of Mono.Cecil.TypeReference, MemberCache)(New TypeComparer)
 
     ReadOnly Property Corlib As AssemblyDefinition
         Get
             For i As Integer = 0 To m_CecilAssemblies.Count - 1
                 If Helper.CompareNameOrdinal(m_CecilAssemblies(i).Name.Name, "mscorlib") Then Return m_CecilAssemblies(i)
             Next
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="68" endline="79"><![CDATA[
     End Property
 
     Function FindAssemblyDefinition(ByVal Fullname As String) As Mono.Cecil.AssemblyDefinition
         For i As Integer = 0 To m_CecilAssemblies.Count - 1
             Dim a As Mono.Cecil.AssemblyDefinition
             a = m_CecilAssemblies(i)
             If Helper.CompareNameOrdinal(a.Name.FullName, Fullname) Then
                 Return a
             End If
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="80" endline="87"><![CDATA[
 
     Function GetCache(ByVal Type As Mono.Cecil.TypeReference) As MemberCache
         If MemberCache.ContainsKey(Type) Then
             Return MemberCache(Type)
         Else
             Return New MemberCache(Compiler, Type)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="88" endline="91"><![CDATA[
 
     Function ContainsCache(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return MemberCache.ContainsKey(Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="92" endline="96"><![CDATA[
 
     ReadOnly Property CecilAssemblies() As Generic.List(Of Mono.Cecil.AssemblyDefinition)
         Get
             Return m_CecilAssemblies
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="97" endline="106"><![CDATA[
     End Property
 
     ''' <summary>
     ''' All the non-nested types available.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property Types() As TypeList
         Get
             Return m_CecilTypes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="107" endline="116"><![CDATA[
     End Property
 
     ''' <summary>
     ''' All the non-nested  types indexed by namespace.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property TypesByNamespace() As NamespaceDictionary
         Get
             Return m_CecilTypesByNamespace
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="117" endline="130"><![CDATA[
     End Property
 
     Function GetTypesByNamespaceAndName(ByVal [Namespace] As String, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim key As String = String.Concat([Namespace], "?", Name)
         If m_TypesByNamespaceAndName.ContainsKey(key) Then
             result = m_TypesByNamespaceAndName(key)
         Else
             result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Helper.FilterByName(TypesByNamespace([Namespace]), Name, result)
             m_TypesByNamespaceAndName.Add(key, result)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="131" endline="139"><![CDATA[
 
     ''' <summary>
     ''' All the namespaces available.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property Namespaces() As Namespaces
         Get
             Return m_Namespaces
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="140" endline="149"><![CDATA[
     End Property
 
     ''' <summary>
     ''' All the non-nested types that are modules.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property ModuleTypes() As TypeList
         Get
             Return m_ModuleTypes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="150" endline="155"><![CDATA[
     End Property
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="156" endline="161"><![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler)
         MyBase.New()
     Private m_CecilAssemblies As New Generic.List(Of Mono.Cecil.AssemblyDefinition)
     Private m_CecilTypes As New TypeList
     Private m_CecilModuleTypes As New TypeList
     Private m_CecilTypesByNamespace As New NamespaceDictionary
     
     Private m_TypesByNamespaceAndName As New Generic.Dictionary(Of String, Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
 
     ''' <summary>
     ''' All the modules indexed by namespace.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_CecilModulesByNamespace As New NamespaceDictionary
 
     ''' <summary>
     ''' All the namespaces available.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Namespaces As New Namespaces
 
     ''' <summary>
     ''' All the types that are modules.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ModuleTypes As New TypeList
 
     Private m_Compiler As Compiler
 
     Private Shared m_GenericTypeCache As New Generic.Dictionary(Of String, Mono.Cecil.GenericInstanceType)(vbnc.Helper.StringComparer)
 
     Public MemberCache As New Generic.Dictionary(Of Mono.Cecil.TypeReference, MemberCache)(New TypeComparer)
 
     ReadOnly Property Corlib As AssemblyDefinition
         Get
             For i As Integer = 0 To m_CecilAssemblies.Count - 1
                 If Helper.CompareNameOrdinal(m_CecilAssemblies(i).Name.Name, "mscorlib") Then Return m_CecilAssemblies(i)
             Next
             Return Nothing
         End Get
     End Property
 
     Function FindAssemblyDefinition(ByVal Fullname As String) As Mono.Cecil.AssemblyDefinition
         For i As Integer = 0 To m_CecilAssemblies.Count - 1
             Dim a As Mono.Cecil.AssemblyDefinition
             a = m_CecilAssemblies(i)
             If Helper.CompareNameOrdinal(a.Name.FullName, Fullname) Then
                 Return a
             End If
         Next
         Return Nothing
     End Function
 
     Function GetCache(ByVal Type As Mono.Cecil.TypeReference) As MemberCache
         If MemberCache.ContainsKey(Type) Then
             Return MemberCache(Type)
         Else
             Return New MemberCache(Compiler, Type)
         End If
     End Function
 
     Function ContainsCache(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return MemberCache.ContainsKey(Type)
     End Function
 
     ReadOnly Property CecilAssemblies() As Generic.List(Of Mono.Cecil.AssemblyDefinition)
         Get
             Return m_CecilAssemblies
         End Get
     End Property
 
     ''' <summary>
     ''' All the non-nested types available.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property Types() As TypeList
         Get
             Return m_CecilTypes
         End Get
     End Property
 
     ''' <summary>
     ''' All the non-nested  types indexed by namespace.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property TypesByNamespace() As NamespaceDictionary
         Get
             Return m_CecilTypesByNamespace
         End Get
     End Property
 
     Function GetTypesByNamespaceAndName(ByVal [Namespace] As String, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim key As String = String.Concat([Namespace], "?", Name)
         If m_TypesByNamespaceAndName.ContainsKey(key) Then
             result = m_TypesByNamespaceAndName(key)
         Else
             result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Helper.FilterByName(TypesByNamespace([Namespace]), Name, result)
             m_TypesByNamespaceAndName.Add(key, result)
         End If
         Return result
     End Function
 
     ''' <summary>
     ''' All the namespaces available.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property Namespaces() As Namespaces
         Get
             Return m_Namespaces
         End Get
     End Property
 
     ''' <summary>
     ''' All the non-nested types that are modules.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property ModuleTypes() As TypeList
         Get
             Return m_ModuleTypes
         End Get
     End Property
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Sub New(ByVal Compiler As Compiler)
         MyBase.New()
         m_Compiler = Compiler
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="162" endline="175"><![CDATA[
 
 
     ''' <summary>
     ''' Searches for the type with the specified name.
     ''' </summary>
     ''' <param name="Name">The type's name to search for. Not case-sensitive.</param>
     ''' <param name="OnlyCreatedTypes">Specifes whether to search in all types, or only in types compiled now.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function [GetType](ByVal Name As String, ByVal OnlyCreatedTypes As Boolean) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         result.AddRange(Me.GetType(Name, Types, OnlyCreatedTypes))
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="176" endline="195"><![CDATA[
 
     Overloads Function [GetType](ByVal Name As String, ByVal InList As IEnumerable, ByVal OnlyCreatedTypes As Boolean) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         For Each tp As Mono.Cecil.TypeReference In InList
             Dim tpD As Mono.Cecil.TypeDefinition = TryCast(tp, Mono.Cecil.TypeDefinition)
             If OnlyCreatedTypes AndAlso tpD Is Nothing Then Continue For
             If Helper.CompareName(tp.Name, Name) OrElse Helper.CompareName(tp.FullName, Name) Then
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("Found type
 #End If
                 result.Add(tp)
             Else
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("Discarded type
 #End If
             End If
             result.AddRange(Me.GetType(Name, CecilHelper.GetNestedTypes(tp), OnlyCreatedTypes))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="196" endline="238"><![CDATA[
 
     ''' <summary>
     ''' Loads all the referenced assemblies.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function LoadReferencedAssemblies() As Boolean
         Dim result As Boolean = True
         Dim refAssembly As Mono.Cecil.AssemblyDefinition
         Dim loadedFiles As New Generic.List(Of String)
         Dim loaded As Boolean
         Dim fullPath As String = Nothing
 
         For Each strFile As String In Compiler.CommandLine.References
             If loadedFiles.Contains(strFile) Then Continue For
             loadedFiles.Add(strFile)
 
             refAssembly = LoadAssembly(strFile, fullPath)
             If refAssembly Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC2017, Span.CommandLineSpan, strFile)
                 Return False
             End If
 
             loaded = False
             For a As Integer = 0 To CecilAssemblies.Count - 1
                 If Helper.CompareNameOrdinal(CecilAssemblies(a).Name.FullName, refAssembly.Name.FullName) Then
                     loaded = True
                     Exit For
                 End If
             Next
             If loaded Then Continue For
 
             If Compiler.CommandLine.Verbose Then
                 Compiler.Report.WriteLine(String.Format("Loaded {0} => {1}", fullPath, refAssembly.Name))
             End If
             m_CecilAssemblies.Add(refAssembly)
             Compiler.AssemblyResolver.RegisterAssembly(refAssembly)
         Next
 
         Compiler.TypeCache.Init()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="239" endline="282"><![CDATA[
 
     ''' <summary>
     ''' Loads all the types (referenced and compiled) and all the namespaces as well.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function LoadReferenced() As Boolean
         Dim result As Boolean = True
 
         result = LoadReferencedAssemblies() AndAlso result
         If result = False Then Return result
 
         For Each ass As Mono.Cecil.AssemblyDefinition In CecilAssemblies
             If Helper.CompareNameOrdinal(ass.Name.Name, "Microsoft.VisualBasic") Then
                 Compiler.TypeCache.InitInternalVB()
                 Exit For
             End If
         Next
 
         result = LoadReferencedTypes() AndAlso result
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(String.Format("{0} assemblies were loaded.", Assemblies.Count.ToString))
         If Compiler.CommandLine.Verbose Then
             For i As Integer = 0 To Assemblies.Count - 1
                 Compiler.Report.WriteLine("#" & (i + 1).ToString & "
             Next
         End If
         Compiler.Report.WriteLine(String.Format("{0} namespaces were loaded.", Namespaces.Count))
         If Compiler.CommandLine.Verbose Then
             Dim ns As String() = Namespaces.NamespacesAsString
             For i As Integer = 0 To ns.Length - 1
                 Compiler.Report.WriteLine("#" & (i + 1).ToString & "
             Next
         End If
         Compiler.Report.WriteLine(String.Format("{0} types were loaded.", Types.Count))
         If Compiler.CommandLine.Verbose Then
             For i As Integer = 0 To Types.Count - 1
                 'Compiler.Report.WriteLine("#" & (i + 1).ToString & "
             Next
         End If
 #End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="283" endline="319"><![CDATA[
 
     ''' <summary>
     ''' Tries to load the specified file as an assembly.
     ''' </summary>
     ''' <param name="Filename"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function LoadAssembly(ByVal Filename As String, ByRef FullPath As String) As Mono.Cecil.AssemblyDefinition
         Dim refAss As Mono.Cecil.AssemblyDefinition
         Dim readerParameters As New ReaderParameters(ReadingMode.Deferred)
         readerParameters.AssemblyResolver = Compiler.AssemblyResolver
 
         FullPath = Nothing
 
         '  Try
         If IO.File.Exists(Filename) Then
             refAss = Mono.Cecil.AssemblyDefinition.ReadAssembly(Filename, readerParameters)
             FullPath = Filename
             Return refAss
         End If
 
         '  Catch ex As IO.FileNotFoundException
         For Each strPath As String In Compiler.CommandLine.LibPath
             Dim strFullPath As String = IO.Path.Combine(strPath, Filename)
             Try
                 If IO.File.Exists(strFullPath) Then
                     refAss = Mono.Cecil.AssemblyDefinition.ReadAssembly(strFullPath, readerParameters)
                     FullPath = strFullPath
                     Return refAss
                 End If
             Catch ex2 As Exception
                 'Do nothing, just keep on trying
             End Try
         Next
         '  End Try
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="320" endline="344"><![CDATA[
 
     ''' <summary>
     ''' Load the type into the various lists.
     ''' </summary>
     ''' <param name="Type"></param>
     ''' <remarks></remarks>
     Private Sub LoadType(ByVal Type As Mono.Cecil.TypeDefinition)
         'Add the type to the list of all types.
         Me.Types.Add(Type)
 
         'Add the namespace to the list of all namespaces.
         Me.Namespaces.AddAllNamespaces(Compiler, Type.Namespace, True)
 
         'Add the type to the list of types by namespace.
         m_CecilTypesByNamespace.AddType(Type)
 
         'If it is a module add it to the list of all modules and to the list of modules by namespace.
         If Helper.IsModule(Compiler, Type) Then
             m_CecilModuleTypes.Add(Type)
             m_CecilModulesByNamespace.AddType(Type)
         Else
             Helper.Assert(Type.Annotations(Compiler) Is Nothing OrElse Not TypeOf Type.Annotations(Compiler) Is ModuleDeclaration)
         End If
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="345" endline="363"><![CDATA[
 
     ''' <summary>
     ''' Finds all the public non-nested types in the referenced assemblies and loads them into the lists.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function LoadReferencedTypes() As Boolean
         For Each ass As Mono.Cecil.AssemblyDefinition In CecilAssemblies
             Dim types As Mono.Collections.Generic.Collection(Of TypeDefinition) = ass.MainModule.Types
             For i As Integer = 0 To types.Count - 1
                 Dim type As TypeDefinition = types(i)
                 If Type.IsPublic Then
                     LoadType(Type)
                 End If
             Next
         Next
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="364" endline="373"><![CDATA[
 
     ''' <summary>
     ''' Finds all the non-nested types in the compiling code and loads them into the lists.
     ''' </summary>
     ''' <remarks></remarks>
     Public Sub LoadCompiledTypes()
         For Each t As TypeDeclaration In Compiler.theAss.Types
             LoadType(t.CecilType)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="374" endline="393"><![CDATA[
 
     ''' <summary>
     ''' Returns all the modules within the specified namespace.
     ''' Never returns nothing and never throws an exception.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetModulesByNamespace(ByVal [Namespace] As String) As TypeDictionary
         Dim result As TypeDictionary = Nothing
 
         If [Namespace] Is Nothing Then [Namespace] = ""
         If [Namespace].StartsWith("Global.") Then [Namespace] = [Namespace].Substring(7)
 
         If m_CecilModulesByNamespace.TryGetValue([Namespace], result) Then
             Return result
         Else
             Return Nothing
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="394" endline="409"><![CDATA[
 
     ''' <summary>
     ''' Returns all the types within the specified namespace.
     ''' Never returns nothing and never throws an exception.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetTypesByNamespace(ByVal [Namespace] As String) As TypeDictionary
         If [Namespace] Is Nothing Then [Namespace] = ""
         If m_CecilTypesByNamespace.ContainsKey([Namespace]) Then
             Return m_CecilTypesByNamespace([Namespace])
         Else
             Return New TypeDictionary()
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417"><![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="418" endline="445"><![CDATA[
 
     ''' <summary>
     ''' Creates a closed method of an open generic method.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="OpenMethod"></param>
     ''' <param name="TypeParameters"></param>
     ''' <param name="TypeArguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function MakeGenericMethod(ByVal Parent As ParsedObject, ByVal OpenMethod As Mono.Cecil.MethodReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim genM As Mono.Cecil.GenericInstanceMethod
 
         result = CecilHelper.GetCorrectMember(OpenMethod, TypeArguments)
 
         If OpenMethod.GenericParameters.Count = 0 Then Return result
 
         Helper.Assert(OpenMethod.GenericParameters.Count = TypeArguments.Count)
 
         genM = New Mono.Cecil.GenericInstanceMethod(result)
         genM.OriginalMethod = CecilHelper.FindDefinition(OpenMethod)
         For i As Integer = 0 To OpenMethod.GenericParameters.Count - 1
             genM.GenericArguments.Add(Helper.GetTypeOrTypeReference(Parent.Compiler, TypeArguments(i)))
         Next
 
         Return genM
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="446" endline="454"><![CDATA[
 
     Function MakeGenericParameter(ByVal Parent As ParsedObject, ByVal OpenParameter As Mono.Cecil.ParameterReference, ByVal ParameterType As Mono.Cecil.TypeReference) As Mono.Cecil.ParameterReference
         Dim result As Mono.Cecil.ParameterReference
 
         'result = New GenericParameterDescriptor(Parent, ParameterType, OpenParameter)
         result = Nothing 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="455" endline="481"><![CDATA[
 
     Function MakeGenericType(ByVal Parent As ParsedObject, ByVal OpenType As Mono.Cecil.TypeReference, ByVal GenericArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.GenericInstanceType
 
         result = New Mono.Cecil.GenericInstanceType(Helper.GetTypeOrTypeReference(Parent.Compiler, OpenType))
 
         For i As Integer = 0 To GenericArguments.Count - 1
             result.GenericArguments.Add(Helper.GetTypeOrTypeReference(Parent.Compiler, GenericArguments(i)))
         Next
 
         'Needs to add this to a cache, otherwise two otherwise equal types might be created with two different 
         'type instances, which is not good as any type comparison would fail.
         Dim key As String = result.FullName
         Helper.Assert(key IsNot Nothing AndAlso key <> "")
         If m_GenericTypeCache.ContainsKey(key) Then
             'Revert to the cached type if it has already been created.
             result = m_GenericTypeCache(key)
         Else
             Dim addToCache As Boolean = True
             For Each item As Mono.Cecil.TypeReference In GenericArguments
                 If CecilHelper.IsGenericParameter(item) Then addToCache = False 
             Next
             If addToCache Then m_GenericTypeCache.Add(key, result)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="482" endline="489"><![CDATA[
 
     Function MakeByRefType(ByVal Parent As ParsedObject, ByVal ElementType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference
 
         result = New ByReferenceType(ElementType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="490" endline="497"><![CDATA[
 
     Function MakeArrayType(ByVal Parent As ParsedObject, ByVal ElementType As Mono.Cecil.TypeReference, ByVal Ranks As Integer) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.ArrayType
 
         result = New Mono.Cecil.ArrayType(ElementType, Ranks)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="498" endline="502"><![CDATA[
 
     ReadOnly Property GenericTypeCache() As Generic.Dictionary(Of String, Mono.Cecil.GenericInstanceType)
         Get
             Return m_GenericTypeCache
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="37" endline="53"><![CDATA[
     Shared Function GetIntrinsicTypesImplicitlyConvertibleFrom(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode()
         Dim result As TypeCode() = Nothing
 
         If m_ImplicitlyConvertedIntrinsicTypes.TryGetValue(Type, result) Then
             Return result
         End If
 
         If Helper.CompareType(Type, Compiler.TypeCache.System_Char_Array) Then
             result = New TypeCode() {TypeCode.String}
         End If
 
         If result IsNot Nothing Then
             m_ImplicitlyConvertedIntrinsicTypes.Add(Type, result)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="54" endline="90"><![CDATA[
 
     Shared Sub New()
     Private Shared m_ImplicitlyConvertedIntrinsicTypes As New Generic.Dictionary(Of Mono.Cecil.TypeReference, TypeCode())
 
     Shared Function GetIntrinsicTypesImplicitlyConvertibleFrom(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode()
         Dim result As TypeCode() = Nothing
 
         If m_ImplicitlyConvertedIntrinsicTypes.TryGetValue(Type, result) Then
             Return result
         End If
 
         If Helper.CompareType(Type, Compiler.TypeCache.System_Char_Array) Then
             result = New TypeCode() {TypeCode.String}
         End If
 
         If result IsNot Nothing Then
             m_ImplicitlyConvertedIntrinsicTypes.Add(Type, result)
         End If
 
         Return result
     End Function
 
     Shared Sub New()
         Dim highest As Integer
 
         Dim tmp As Array = System.Enum.GetValues(GetType(TypeCode))
         highest = CInt(tmp.GetValue(tmp.GetUpperBound(0)))
 
         ReDim Conversion(highest, highest)
         For i As Integer = 0 To highest
             For j As Integer = 0 To highest
                 Conversion(i, j) = New TypeConversionInfo
                 If j = TypeCode.Object OrElse j = i Then
                     Conversion(i, j).Conversion = ConversionType.Implicit
                 ElseIf i = TypeCode.Char Then
                     Conversion(i, j).Conversion = ConversionType.None
                 Else
                     Conversion(i, j).Conversion = ConversionType.Explicit
                 End If
             Next
         Next
 
         setImplicit(TypeCode.SByte, New TypeCode() {TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Byte, New TypeCode() {TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int16, New TypeCode() {TypeCode.Int32, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt16, New TypeCode() {TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int32, New TypeCode() {TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt32, New TypeCode() {TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int64, New TypeCode() {TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt64, New TypeCode() {TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Decimal, New TypeCode() {TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Single, New TypeCode() {TypeCode.Double})
         setImplicit(TypeCode.Double, New TypeCode() {})
         setImplicit(TypeCode.Char, New TypeCode() {TypeCode.String})
 
         Conversion(TypeCode.Byte, TypeCode.Byte).BinaryAddResult = TypeCode.Byte
         Conversion(TypeCode.Boolean, TypeCode.Boolean).BinaryAddResult = TypeCode.SByte
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="91" endline="114"><![CDATA[
 
     Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
     Friend BuiltInTypes As New Generic.List(Of Mono.Cecil.TypeReference)(New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Boolean, Compiler.TypeCache.System_Byte, Compiler.TypeCache.System_Char, Compiler.TypeCache.System_DateTime, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_int64, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_int16, Compiler.TypeCache.System_Single, Compiler.TypeCache.System_String, Compiler.TypeCache.System_SByte, Compiler.TypeCache.System_UInt16, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_Uint64})
     Friend NumericTypes As New Generic.List(Of Mono.Cecil.TypeReference)(New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Byte, Compiler.TypeCache.System_SByte, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single, Compiler.TypeCache.System_int16, Compiler.TypeCache.System_UInt16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_int64, Compiler.TypeCache.System_Uint64})
     Friend IntegralTypes As New Generic.List(Of Mono.Cecil.TypeReference)(New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Byte, Compiler.TypeCache.System_SByte, Compiler.TypeCache.System_int16, Compiler.TypeCache.System_Uint16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_int64, Compiler.TypeCache.System_Uint64})
 
     Private valCanBeContainBy(15)() As Mono.Cecil.TypeReference
 
     Public Shared Conversion As TypeConversionInfo(,)
 
     Private Shared m_ImplicitlyConvertedIntrinsicTypes As New Generic.Dictionary(Of Mono.Cecil.TypeReference, TypeCode())
 
     Shared Function GetIntrinsicTypesImplicitlyConvertibleFrom(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode()
         Dim result As TypeCode() = Nothing
 
         If m_ImplicitlyConvertedIntrinsicTypes.TryGetValue(Type, result) Then
             Return result
         End If
 
         If Helper.CompareType(Type, Compiler.TypeCache.System_Char_Array) Then
             result = New TypeCode() {TypeCode.String}
         End If
 
         If result IsNot Nothing Then
             m_ImplicitlyConvertedIntrinsicTypes.Add(Type, result)
         End If
 
         Return result
     End Function
 
     Shared Sub New()
         Dim highest As Integer
 
         Dim tmp As Array = System.Enum.GetValues(GetType(TypeCode))
         highest = CInt(tmp.GetValue(tmp.GetUpperBound(0)))
 
         ReDim Conversion(highest, highest)
         For i As Integer = 0 To highest
             For j As Integer = 0 To highest
                 Conversion(i, j) = New TypeConversionInfo
                 If j = TypeCode.Object OrElse j = i Then
                     Conversion(i, j).Conversion = ConversionType.Implicit
                 ElseIf i = TypeCode.Char Then
                     Conversion(i, j).Conversion = ConversionType.None
                 Else
                     Conversion(i, j).Conversion = ConversionType.Explicit
                 End If
             Next
         Next
 
         setImplicit(TypeCode.SByte, New TypeCode() {TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Byte, New TypeCode() {TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int16, New TypeCode() {TypeCode.Int32, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt16, New TypeCode() {TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int32, New TypeCode() {TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt32, New TypeCode() {TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int64, New TypeCode() {TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt64, New TypeCode() {TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Decimal, New TypeCode() {TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Single, New TypeCode() {TypeCode.Double})
         setImplicit(TypeCode.Double, New TypeCode() {})
         setImplicit(TypeCode.Char, New TypeCode() {TypeCode.String})
 
         Conversion(TypeCode.Byte, TypeCode.Byte).BinaryAddResult = TypeCode.Byte
         Conversion(TypeCode.Boolean, TypeCode.Boolean).BinaryAddResult = TypeCode.SByte
     End Sub
 
     Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
 
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Boolean)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Byte)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Byte, Compiler.TypeCache.System_Int16, Compiler.TypeCache.System_UInt16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_UInt64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Char)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Date)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Decimal)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Double)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Double}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Integer)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Long)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Object)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.[SByte])) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_SByte, Compiler.TypeCache.System_Int16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Short)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Int16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Single)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.String)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.[UInteger])) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_UInt64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.[ULong])) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_UInt64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.[UShort])) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_UInt16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_UInt64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
 
 
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="115" endline="125"><![CDATA[
 
     ''' <summary>
     ''' Returns the type of the builtin type.
     ''' If it isn't a builtin type, then it returns nothing,
     ''' </summary>
     ''' <param name="tp"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function BuiltInTypeToType(ByVal tp As BuiltInDataTypes) As Mono.Cecil.TypeReference
         Return KeywordToType(CType(tp, KS))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="126" endline="129"><![CDATA[
 
     Function IsBuiltInType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return BuiltInTypes.Contains(Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="130" endline="172"><![CDATA[
 
     Shared Function TypeCodeToBuiltInType(ByVal tp As TypeCode) As BuiltInDataTypes
         Select Case tp
             Case TypeCode.Boolean
                 Return BuiltInDataTypes.Boolean
             Case TypeCode.Byte
                 Return BuiltInDataTypes.Byte
             Case TypeCode.Char
                 Return BuiltInDataTypes.Char
             Case TypeCode.DateTime
                 Return BuiltInDataTypes.Date
             Case TypeCode.DBNull
                 Throw New InternalException("")
             Case TypeCode.Decimal
                 Return BuiltInDataTypes.Decimal
             Case TypeCode.Double
                 Return BuiltInDataTypes.Double
             Case TypeCode.Empty
                 Throw New InternalException("")
             Case TypeCode.Int16
                 Return BuiltInDataTypes.Short
             Case TypeCode.Int32
                 Return BuiltInDataTypes.Integer
             Case TypeCode.Int64
                 Return BuiltInDataTypes.Long
             Case TypeCode.Object
                 Return BuiltInDataTypes.Object
             Case TypeCode.SByte
                 Return BuiltInDataTypes.SByte
             Case TypeCode.Single
                 Return BuiltInDataTypes.Single
             Case TypeCode.String
                 Return BuiltInDataTypes.String
             Case TypeCode.UInt16
                 Return BuiltInDataTypes.UShort
             Case TypeCode.UInt32
                 Return BuiltInDataTypes.UInteger
             Case TypeCode.UInt64
                 Return BuiltInDataTypes.ULong
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="173" endline="211"><![CDATA[
 
     Shared Function BuiltInTypeToTypeCode(ByVal Type As BuiltInDataTypes) As TypeCode
         Select Case Type
             Case BuiltInDataTypes.Boolean
                 Return TypeCode.Boolean
             Case BuiltInDataTypes.Byte
                 Return TypeCode.Byte
             Case BuiltInDataTypes.Char
                 Return TypeCode.Char
             Case BuiltInDataTypes.Date
                 Return TypeCode.DateTime
             Case BuiltInDataTypes.Decimal
                 Return TypeCode.Decimal
             Case BuiltInDataTypes.Double
                 Return TypeCode.Double
             Case BuiltInDataTypes.Integer
                 Return TypeCode.Int32
             Case BuiltInDataTypes.Long
                 Return TypeCode.Int64
             Case BuiltInDataTypes.Object
                 Return TypeCode.Object
             Case BuiltInDataTypes.SByte
                 Return TypeCode.SByte
             Case BuiltInDataTypes.Short
                 Return TypeCode.Int16
             Case BuiltInDataTypes.Single
                 Return TypeCode.Single
             Case BuiltInDataTypes.String
                 Return TypeCode.String
             Case BuiltInDataTypes.UInteger
                 Return TypeCode.UInt32
             Case BuiltInDataTypes.ULong
                 Return TypeCode.UInt64
             Case BuiltInDataTypes.UShort
                 Return TypeCode.UInt16
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="212" endline="215"><![CDATA[
 
     Function TypeCodeToTypeDescriptor(ByVal Code As TypeCode) As Mono.Cecil.TypeReference
         Return TypeCodeToType(Code)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="216" endline="258"><![CDATA[
 
     Function TypeCodeToType(ByVal Code As TypeCode) As Mono.Cecil.TypeReference
         Select Case Code
             Case TypeCode.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case TypeCode.Byte
                 Return Compiler.TypeCache.System_Byte
             Case TypeCode.Char
                 Return Compiler.TypeCache.System_Char
             Case TypeCode.DateTime
                 Return Compiler.TypeCache.System_DateTime
             Case TypeCode.DBNull
                 Throw New InternalException("")
             Case TypeCode.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case TypeCode.Double
                 Return Compiler.TypeCache.System_Double
             Case TypeCode.Empty
                 Throw New InternalException("")
             Case TypeCode.Int16
                 Return Compiler.TypeCache.System_Int16
             Case TypeCode.Int32
                 Return Compiler.TypeCache.System_Int32
             Case TypeCode.Int64
                 Return Compiler.TypeCache.System_Int64
             Case TypeCode.Object
                 Return Compiler.TypeCache.System_Object
             Case TypeCode.SByte
                 Return Compiler.TypeCache.System_SByte
             Case TypeCode.Single
                 Return Compiler.TypeCache.System_Single
             Case TypeCode.String
                 Return Compiler.TypeCache.System_String
             Case TypeCode.UInt16
                 Return Compiler.TypeCache.System_UInt16
             Case TypeCode.UInt32
                 Return Compiler.TypeCache.System_UInt32
             Case TypeCode.UInt64
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="259" endline="297"><![CDATA[
 
     Private Shared Function getTypeIndex(ByVal special As BuiltInDataTypes) As Integer
         Select Case special
             Case BuiltInDataTypes.Boolean
                 Return 0
             Case BuiltInDataTypes.Byte
                 Return 1
             Case BuiltInDataTypes.Char
                 Return 2
             Case BuiltInDataTypes.Date
                 Return 3
             Case BuiltInDataTypes.Decimal
                 Return 4
             Case BuiltInDataTypes.Double
                 Return 5
             Case BuiltInDataTypes.Integer
                 Return 6
             Case BuiltInDataTypes.Long
                 Return 7
             Case BuiltInDataTypes.Object
                 Return 8
             Case BuiltInDataTypes.[SByte]
                 Return 9
             Case BuiltInDataTypes.Short
                 Return 10
             Case BuiltInDataTypes.Single
                 Return 11
             Case BuiltInDataTypes.String
                 Return 12
             Case BuiltInDataTypes.[UInteger]
                 Return 13
             Case BuiltInDataTypes.[ULong]
                 Return 14
             Case BuiltInDataTypes.[UShort]
                 Return 15
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="298" endline="336"><![CDATA[
 
     Shared Function KeywordToTypeCode(ByVal Keyword As KS) As TypeCode
         Select Case Keyword
             Case KS.Boolean
                 Return TypeCode.Boolean
             Case KS.Byte
                 Return TypeCode.Byte
             Case KS.Char
                 Return TypeCode.Char
             Case KS.Date
                 Return TypeCode.DateTime
             Case KS.Decimal
                 Return TypeCode.Decimal
             Case KS.Double
                 Return TypeCode.Double
             Case KS.Integer
                 Return TypeCode.Int32
             Case KS.Long
                 Return TypeCode.Int64
             Case KS.Object
                 Return TypeCode.Object
             Case KS.Single
                 Return TypeCode.Single
             Case KS.Short
                 Return TypeCode.Int16
             Case KS.String
                 Return TypeCode.String
             Case KS.SByte
                 Return TypeCode.SByte
             Case KS.UShort
                 Return TypeCode.UInt16
             Case KS.UInteger
                 Return TypeCode.UInt32
             Case KS.ULong
                 Return TypeCode.UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="337" endline="383"><![CDATA[
 
     ''' <summary>
     ''' Returns the type of the specified keyword. Throws an internalexception if the keyword isn't a type.
     ''' </summary>
     ''' <param name="Keyword"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ''' 
     Function KeywordToType(ByVal Keyword As KS) As Mono.Cecil.TypeReference
         Select Case Keyword
             Case KS.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case KS.Byte
                 Return Compiler.TypeCache.System_Byte
             Case KS.Char
                 Return Compiler.TypeCache.System_Char
             Case KS.Date
                 Return Compiler.TypeCache.System_DateTime
             Case KS.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case KS.Double
                 Return Compiler.TypeCache.System_Double
             Case KS.Integer
                 Return Compiler.TypeCache.System_Int32
             Case KS.Long
                 Return Compiler.TypeCache.System_Int64
             Case KS.Object
                 Return Compiler.TypeCache.System_Object
             Case KS.Single
                 Return Compiler.TypeCache.System_Single
             Case KS.Short
                 Return Compiler.TypeCache.System_Int16
             Case KS.String
                 Return Compiler.TypeCache.System_String
             Case KS.[SByte]
                 Return Compiler.TypeCache.System_SByte
             Case KS.[UShort]
                 Return Compiler.TypeCache.System_UInt16
             Case KS.[UInteger]
                 Return Compiler.TypeCache.System_UInt32
             Case KS.[ULong]
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 'Throw New InternalException("Don't know if this can actually happen, though. KS = " & Keyword.ToString)
                 Return Nothing
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="384" endline="421"><![CDATA[
 
     Function TypeToKeyword(ByVal Type As Mono.Cecil.TypeReference) As KS
         If Helper.CompareType(Type, Compiler.TypeCache.System_Boolean) Then
             Return KS.Boolean
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Byte) Then
             Return KS.Byte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Char) Then
             Return KS.Char
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DateTime) Then
             Return KS.Date
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Decimal) Then
             Return KS.Decimal
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Double) Then
             Return KS.Double
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int32) Then
             Return KS.Integer
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int64) Then
             Return KS.Long
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Object) Then
             Return KS.Object
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int16) Then
             Return KS.Short
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Single) Then
             Return KS.Single
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_String) Then
             Return KS.String
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_SByte) Then
             Return KS.[SByte]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) Then
             Return KS.[UShort]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) Then
             Return KS.[UInteger]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt64) Then
             Return KS.[ULong]
         Else
             Return KS.None
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="422" endline="446"><![CDATA[
 
     'Function IsImplicitlyConvertible(ByVal Context As BaseObject, ByVal FromType As TypeDescriptor, ByVal ToType As TypeDescriptor) As Boolean
     '    Return IsImplicitlyConvertible(Context, FromType.TypeInReflection, ToType.TypeInReflection)
     'End Function
 
     Function IsImplicitlyConvertible(ByVal Context As BaseObject, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         Dim tpFrom, tpTo As TypeCode
         If Helper.CompareType(Compiler.TypeCache.Nothing, FromType) Then Return True
         If CecilHelper.IsByRef(FromType) Then FromType = CecilHelper.GetElementType(FromType)
         If CecilHelper.IsByRef(ToType) Then ToType = CecilHelper.GetElementType(ToType)
         If CecilHelper.IsNullable(FromType) Then FromType = CecilHelper.GetNulledType(FromType)
         If CecilHelper.IsNullable(ToType) Then ToType = CecilHelper.GetNulledType(ToType)
         tpFrom = Helper.GetTypeCode(Compiler, FromType)
         tpTo = Helper.GetTypeCode(Compiler, ToType)
         If tpTo = TypeCode.Object Then
             Return Helper.IsAssignable(Context, FromType, ToType) ' ToType.IsAssignableFrom(FromType)
         ElseIf Helper.IsEnum(Compiler, ToType) AndAlso Helper.IsEnum(Compiler, FromType) = False Then
             Return False
         ElseIf Helper.IsEnum(Compiler, ToType) AndAlso Helper.IsEnum(Compiler, FromType) Then
             Return Helper.CompareType(ToType, FromType)
         Else
             Return IsImplicitlyConvertible(Compiler, tpFrom, tpTo)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="447" endline="452"><![CDATA[
 
     Function IsImplicitlyConvertible(ByVal Compiler As Compiler, ByVal tpFrom As TypeCode, ByVal tpTo As TypeCode) As Boolean
         Dim result As Boolean
         result = Conversion(tpFrom, tpTo).Conversion = ConversionType.Implicit
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="453" endline="470"><![CDATA[
 
     ''' <summary>
     ''' If explicitly or implicitly convertible.
     ''' </summary>
     ''' <param name="Compiler"></param>
     ''' <param name="tpFrom"></param>
     ''' <param name="tpTo"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsExplicitlyConvertible(ByVal Compiler As Compiler, ByVal tpFrom As TypeCode, ByVal tpTo As TypeCode) As Boolean
         Dim result As Boolean
         Dim ct As ConversionType
 
         ct = Conversion(tpFrom, tpTo).Conversion
         result = ct = ConversionType.Implicit OrElse ct = ConversionType.Explicit
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="471" endline="477"><![CDATA[
 
     Function IsNumericType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In NumericTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="478" endline="484"><![CDATA[
 
     Function IsIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In IntegralTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="485" endline="491"><![CDATA[
 
     Function IsIntegralType(ByVal Type As TypeCode) As Boolean
         For Each t As Mono.Cecil.TypeReference In IntegralTypes
             If Helper.GetTypeCode(Compiler, t) = Type Then Return True
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="492" endline="495"><![CDATA[
 
     Function IsIntegralType(ByVal Type As BuiltInDataTypes) As Boolean
         Return IsIntegralType(BuiltInTypeToTypeCode(Type))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="496" endline="502"><![CDATA[
 
     Function IsSignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_SByte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int64)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="503" endline="509"><![CDATA[
 
     Function IsUnsignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_Byte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt64)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="510" endline="529"><![CDATA[
 
     ''' <summary>
     ''' If the type is an enum type returns the base (integral type),
     ''' otherwise returns the same type.
     ''' </summary>
     ''' <param name="tp"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetIntegralType(ByVal Compiler As Compiler, ByVal tp As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(tp IsNot Nothing, "tp Is Nothing")
         If Helper.IsEnum(Compiler, tp) Then
             Dim field As Mono.Cecil.FieldDefinition
             field = CecilHelper.FindField(CecilHelper.FindDefinition(tp).Fields, EnumDeclaration.EnumTypeMemberName)
             Helper.Assert(field IsNot Nothing, "field '" & EnumDeclaration.EnumTypeMemberName & "' Is Nothing of Type '" & tp.FullName & "'")
             Return field.FieldType
         Else
             Helper.Assert(IsIntegralType(tp))
             Return tp
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="530" endline="567"><![CDATA[
 
     ''' <summary>
     ''' Finds the smallest type that can hold both specified types.
     ''' If tp1 = Integer and tp2 = Long would return Long
     ''' </summary>
     ''' <param name="tp1"></param>
     ''' <param name="tp2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetSmallestIntegralType(ByVal tp1 As Mono.Cecil.TypeReference, ByVal tp2 As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim cont1(), cont2() As Mono.Cecil.TypeReference
 
         Helper.Assert(tp1 IsNot Nothing, "tp1 Is Nothing")
         Helper.Assert(tp2 IsNot Nothing, "tp2 Is Nothing")
 
         Dim itp1, itp2 As Mono.Cecil.TypeReference
         itp1 = GetIntegralType(Compiler, tp1)
         itp2 = GetIntegralType(Compiler, tp2)
         cont1 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp1), BuiltInDataTypes)))
         cont2 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp2), BuiltInDataTypes)))
 
         If cont1 Is Nothing Or cont2 Is Nothing Then Return Nothing
 
         Dim found As New ArrayList
         For Each t1 As Mono.Cecil.TypeReference In cont1
             For Each t2 As Mono.Cecil.TypeReference In cont2
                 If Helper.CompareType(t1, t2) Then
                     found.Add(t1)
                 End If
             Next
         Next
 
         If found.Count = 0 Then
             Return Nothing
         Else
             Return CType(found(0), Mono.Cecil.TypeReference)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="568" endline="620"><![CDATA[
 
     Public Function GetWidestType(ByVal tp1 As TypeReference, ByVal tp2 As TypeReference, ByVal tp3 As TypeReference) As TypeReference
         Dim cont1(), cont2(), cont3() As Mono.Cecil.TypeReference
 
         Helper.Assert(tp1 IsNot Nothing, "tp1 Is Nothing")
         Helper.Assert(tp2 IsNot Nothing, "tp2 Is Nothing")
 
         If tp1 Is tp2 Then
             If tp3 Is Nothing Then Return tp1
             If tp1 Is tp3 Then Return tp2
         End If
 
         Dim itp1, itp2, itp3 As Mono.Cecil.TypeReference
         itp1 = GetIntegralType(Compiler, tp1)
         itp2 = GetIntegralType(Compiler, tp2)
 
         cont1 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp1), BuiltInDataTypes)))
         cont2 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp2), BuiltInDataTypes)))
 
         If tp3 Is Nothing Then
             itp3 = Nothing
             cont3 = Nothing
         Else
             itp3 = GetIntegralType(Compiler, tp3)
             cont3 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp3), BuiltInDataTypes)))
         End If
 
         If cont1 Is Nothing Or cont2 Is Nothing Then Return Nothing
 
         For i As Integer = 0 To cont1.Length - 1
             For j As Integer = 0 To cont2.Length - 1
                 If Not cont2(j) Is cont1(i) Then Continue For
 
                 If itp3 Is Nothing Then
                     'We've found a type that can contain both input types
                     If cont2(j) Is itp1 Then Return tp1
                     If cont2(j) Is itp2 Then Return tp2
                     'Continue looking, the type we want is neither of the two input types
                 Else
                     For k As Integer = 0 To cont3.Length - 1
                         If Not cont3(k) Is cont2(j) Then Continue For
                         'We've found a type that can contain all three input types
                         If cont3(k) Is itp1 Then Return tp1
                         If cont3(k) Is itp2 Then Return tp2
                         If cont3(k) Is itp3 Then Return tp3
                         'Continue looking, the type we want is neither of the three input types
                     Next
                 End If
             Next
         Next
 
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="621" endline="626"><![CDATA[
 
     Private Shared Sub setImplicit(ByVal type As TypeCode, ByVal implicit() As TypeCode)
         For i As Integer = 0 To VB.UBound(implicit)
             Conversion(type, implicit(i)).Conversion = ConversionType.Implicit
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="627" endline="632"><![CDATA[
 
     Private Shared Sub setNone(ByVal type As TypeCode, ByVal explicit() As TypeCode)
         For i As Integer = 0 To explicit.Length - 1
             Conversion(type, explicit(i)).Conversion = ConversionType.None
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="633" endline="928"><![CDATA[
 
     ''' <summary>
     ''' Tries to convert the value into the desired type. Returns true if successful, 
     ''' returns false otherwise. 
     ''' </summary>
     ''' <param name="value"></param>
     ''' <param name="result"></param>
     ''' <param name="desiredType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function CheckNumericRange(ByVal value As Object, ByRef result As Object, ByVal desiredType As Mono.Cecil.TypeReference) As Boolean
         Dim builtInType As BuiltInDataTypes = TypeResolution.TypeCodeToBuiltInType(Helper.GetTypeCode(Compiler, desiredType))
 
         If value Is Nothing Then 'Nothing can be converted into anything.
             result = Nothing
             Return True
         End If
 
         If IsNumericType(desiredType) = False Then Return False
 
         If IsIntegralType(builtInType) AndAlso IsIntegralType(Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))) Then
             Return CheckIntegralRange(value, result, builtInType)
         Else
             Dim tpValue As TypeCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))
             Dim desiredCode As TypeCode = Helper.GetTypeCode(Compiler, desiredType)
 
             If Helper.CompareType(CecilHelper.GetType(Compiler, value), desiredType) Then
                 result = value
                 Return True
             End If
 
             If tpValue = TypeCode.DBNull Then
                 Select Case desiredCode
                     Case TypeCode.Boolean
                         result = CBool(Nothing)
                     Case TypeCode.Byte
                         result = CByte(Nothing)
                     Case TypeCode.Char
                         result = CChar(Nothing)
                     Case TypeCode.DateTime
                         result = CDate(Nothing)
                     Case TypeCode.Decimal
                         result = CDec(Nothing)
                     Case TypeCode.Double
                         result = CDbl(Nothing)
                     Case TypeCode.Int16
                         result = CShort(Nothing)
                     Case TypeCode.Int32
                         result = CInt(Nothing)
                     Case TypeCode.Int64
                         result = CLng(Nothing)
                     Case TypeCode.SByte
                         result = CSByte(Nothing)
                     Case TypeCode.Single
                         result = CSng(Nothing)
                     Case TypeCode.String
                         result = Nothing
                     Case TypeCode.UInt16
                         result = CUShort(Nothing)
                     Case TypeCode.UInt32
                         result = CUInt(Nothing)
                     Case TypeCode.UInt64
                         result = CULng(Nothing)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException("")
                 End Select
                 Return True
             End If
 
             If IsNumericType(CecilHelper.GetType(Compiler, value)) = False Then Return False
 
             Select Case desiredCode
                 Case TypeCode.Double
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                             result = CDbl(value)
                             Return True
                     End Select
                 Case TypeCode.Decimal
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal
                             result = CDec(value)
                             Return True
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Decimal.MaxValue AndAlso tmp >= Decimal.MinValue Then
                                 result = CDec(tmp) 'This should be CDec(value), but vbc.exe seems to do it like this.
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Single
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Decimal
                             result = CSng(value)
                             Return True
                         Case TypeCode.Double
                             If CDbl(value) >= Single.MinValue AndAlso CDbl(value) <= Single.MaxValue Then
                                 result = CSng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Byte
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Byte.MaxValue AndAlso tmp >= Byte.MinValue Then
                                 result = CByte(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= Byte.MaxValue AndAlso tmp >= Byte.MinValue Then
                                 result = CByte(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.SByte
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= SByte.MaxValue AndAlso tmp >= SByte.MinValue Then
                                 result = CSByte(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= SByte.MaxValue AndAlso tmp >= SByte.MinValue Then
                                 result = CSByte(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Int16
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Int16.MaxValue AndAlso tmp >= Int16.MinValue Then
                                 result = CShort(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= Int16.MaxValue AndAlso tmp >= Int16.MinValue Then
                                 result = CShort(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.UInt16
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= UInt16.MaxValue AndAlso tmp >= UInt16.MinValue Then
                                 result = CUShort(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= UInt16.MaxValue AndAlso tmp >= UInt16.MinValue Then
                                 result = CUShort(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Int32
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Boolean
                             result = CInt(value)
                             Return True
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Int32.MaxValue AndAlso tmp >= Int32.MinValue Then
                                 result = CInt(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= Int32.MaxValue AndAlso tmp >= Int32.MinValue Then
                                 result = CInt(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.UInt32
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= UInt32.MaxValue AndAlso tmp >= UInt32.MinValue Then
                                 result = CUInt(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= UInt32.MaxValue AndAlso tmp >= UInt32.MinValue Then
                                 result = CUInt(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Int64
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Boolean
                             result = CInt(value)
                             Return True
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Int64.MaxValue AndAlso tmp >= Int64.MinValue Then
                                 result = CLng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= Int64.MaxValue AndAlso tmp >= Int64.MinValue Then
                                 result = CLng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.UInt64
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= UInt64.MaxValue AndAlso tmp >= UInt64.MinValue Then
                                 result = CULng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= UInt64.MaxValue AndAlso tmp >= UInt64.MinValue Then
                                 result = CULng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
             End Select
 
             Select Case tpValue
                 Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                     Dim tmpValue As ULong = CULng(value)
                     Helper.Stop()
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                     Dim tmpValue As Long = CLng(value)
                     'Dim t As Type
                     Helper.Stop()
                 Case TypeCode.Char
                     Helper.Stop()
                 Case TypeCode.Boolean
                     Helper.Stop()
                 Case TypeCode.DateTime
                     Helper.Stop()
                 Case TypeCode.Decimal
                     Helper.Stop()
                 Case TypeCode.Double
                     Helper.Stop()
                 Case TypeCode.Single
                     Helper.Stop()
                 Case TypeCode.String
                     Helper.Stop()
                 Case Else
                     Helper.Stop()
             End Select
             Helper.Stop()
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="929" endline="1069"><![CDATA[
 
     ''' <summary>
     ''' Tries to convert the value into the desired type. Returns true if successful, 
     ''' returns false otherwise. Can only convert if value is already an integral type 
     ''' (does only do range-checking, not type conversion)
     ''' </summary>
     ''' <param name="value"></param>
     ''' <param name="result"></param>
     ''' <param name="desiredType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function CheckIntegralRange(ByVal value As Object, ByRef result As Object, ByVal desiredType As BuiltInDataTypes) As Boolean
         Helper.Assert(value IsNot Nothing)
         Helper.Assert(IsIntegralType(desiredType))
         Dim tpValue As TypeCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))
         Helper.Assert(IsIntegralType(tpValue))
         Select Case tpValue
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim tmpValue As ULong = CULng(value)
                 Select Case desiredType
                     Case BuiltInDataTypes.Byte
                         If tmpValue <= Byte.MaxValue Then
                             result = CByte(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.UShort
                         If tmpValue <= UShort.MaxValue Then
                             result = CUShort(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.UInteger
                         If tmpValue <= UInteger.MaxValue Then
                             result = CUInt(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.ULong
                         result = tmpValue
                         Return True
                     Case BuiltInDataTypes.SByte
                         If tmpValue <= SByte.MaxValue Then
                             result = CSByte(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Short
                         If tmpValue <= Short.MaxValue Then
                             result = CShort(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Integer
                         If tmpValue <= Integer.MaxValue Then
                             result = CInt(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Long
                         If tmpValue <= Long.MaxValue Then
                             result = CLng(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case Else
                         Throw New InternalException("")
                 End Select
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim tmpValue As Long = CLng(value)
                 Select Case desiredType
                     Case BuiltInDataTypes.Byte
                         If tmpValue >= Byte.MinValue AndAlso tmpValue <= Byte.MaxValue Then
                             result = CByte(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.UShort
                         If tmpValue >= UShort.MinValue AndAlso tmpValue <= UShort.MaxValue Then
                             result = CUShort(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.UInteger
                         If tmpValue >= UInteger.MinValue AndAlso tmpValue <= UInteger.MaxValue Then
                             result = CUInt(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.ULong
                         If tmpValue >= ULong.MinValue AndAlso tmpValue <= ULong.MaxValue Then
                             result = CULng(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.SByte
                         If tmpValue >= SByte.MinValue AndAlso tmpValue <= SByte.MaxValue Then
                             result = CSByte(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Short
                         If tmpValue >= Short.MinValue AndAlso tmpValue <= Short.MaxValue Then
                             result = CShort(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Integer
                         If tmpValue >= Integer.MinValue AndAlso tmpValue <= Integer.MaxValue Then
                             result = CInt(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Long
                         If tmpValue >= Long.MinValue AndAlso tmpValue <= Long.MaxValue Then
                             result = CLng(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case Else
                         Throw New InternalException("")
                 End Select
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\vbncException.vb" startline="26" endline="28"><![CDATA[
     Sub New(ByVal Message As String, ByVal InnerException As Exception)
         MyBase.New(Message, InnerException)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\vbncException.vb" startline="29" endline="32"><![CDATA[
 
     Sub New(ByVal Message As String)
         MyBase.New(Message)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\vbncException.vb" startline="33" endline="36"><![CDATA[
 
     Sub New()
         MyBase.New()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ExpressionResolveInfo.vb" startline="25" endline="28"><![CDATA[
     Sub New(ByVal Compiler As Compiler, ByVal LHSType As Mono.Cecil.TypeReference)
         MyBase.New(Compiler)
         Me.LHSType = LHSType
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="32" endline="38"><![CDATA[
     Shared Function [Default](ByVal Compiler As Compiler) As ResolveInfo
         If DefaultInfo Is Nothing OrElse Compiler Is DefaultInfo.Compiler = False Then
             DefaultInfo = New ResolveInfo(Compiler)
         End If
 
         Return DefaultInfo
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="39" endline="45"><![CDATA[
 
     Sub New(ByVal Compiler As Compiler, Optional ByVal SkipFunctionReturnVariable As Boolean = False, Optional ByVal CanFail As Boolean = False, Optional ByVal CanBeImplicitSimpleName As Boolean = True)
     Private m_Bits As New Collections.BitArray(32)
     Private Const c_SkipFunctionReturnVariable As Integer = 0
     Private Const c_CanFail As Integer = 1
     Private Const c_CanBeLateCall As Integer = 2
     Private Const c_CanBeImplicitSimpleName As Integer = 3
     Private Const c_EventResolution As Integer = 4
 
     Public Compiler As Compiler
 
     Private Shared DefaultInfo As ResolveInfo
 
     Shared Function [Default](ByVal Compiler As Compiler) As ResolveInfo
         If DefaultInfo Is Nothing OrElse Compiler Is DefaultInfo.Compiler = False Then
             DefaultInfo = New ResolveInfo(Compiler)
         End If
 
         Return DefaultInfo
     End Function
 
     Sub New(ByVal Compiler As Compiler, Optional ByVal SkipFunctionReturnVariable As Boolean = False, Optional ByVal CanFail As Boolean = False, Optional ByVal CanBeImplicitSimpleName As Boolean = True)
         Me.SkipFunctionReturnVariable = SkipFunctionReturnVariable
         Me.CanFail = CanFail
         Me.CanBeImplicitSimpleName = CanBeImplicitSimpleName
         Me.Compiler = Compiler
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="46" endline="50"><![CDATA[
 
     Public Property CanBeImplicitSimpleName() As Boolean
         Get
             Return m_Bits(c_CanBeImplicitSimpleName)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="51" endline="53"><![CDATA[
         Set(ByVal value As Boolean)
             m_Bits(c_CanBeImplicitSimpleName) = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="54" endline="59"><![CDATA[
     End Property
 
     Public Property CanBeLateCall() As Boolean
         Get
             Return m_Bits(c_CanBeLateCall)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="60" endline="62"><![CDATA[
         Set(ByVal value As Boolean)
             m_Bits(c_CanBeLateCall) = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="63" endline="68"><![CDATA[
     End Property
 
     Public Property SkipFunctionReturnVariable() As Boolean
         Get
             Return m_Bits(c_SkipFunctionReturnVariable)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="69" endline="71"><![CDATA[
         Set(ByVal value As Boolean)
             m_Bits(c_SkipFunctionReturnVariable) = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="72" endline="77"><![CDATA[
     End Property
 
     Public Property CanFail() As Boolean
         Get
             Return m_Bits(c_CanFail)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="78" endline="80"><![CDATA[
         Set(ByVal value As Boolean)
             m_Bits(c_CanFail) = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="81" endline="86"><![CDATA[
     End Property
 
     Public Property IsEventResolution() As Boolean
         Get
             Return m_Bits(c_EventResolution)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="87" endline="89"><![CDATA[
         Set(ByVal value As Boolean)
             m_Bits(c_EventResolution) = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AliasClause.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AliasClause.vb" startline="32" endline="36"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal StringLiteral As Token)
         MyBase.New(Parent)
         m_StringLiteral = StringLiteral
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AliasClause.vb" startline="37" endline="40"><![CDATA[
 
     Sub Init(ByVal StringLiteral As Token)
         m_StringLiteral = StringLiteral
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AliasClause.vb" startline="41" endline="44"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.Alias
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AliasClause.vb" startline="45" endline="49"><![CDATA[
 
     ReadOnly Property StringLiteral() As Token
         Get
             Return m_StringLiteral
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="31" endline="37"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_VariableInitializerList IsNot Nothing Then result = m_VariableInitializerList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="38" endline="41"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="42" endline="45"><![CDATA[
 
     Sub Init(ByVal VariableInitializerList As VariableInitializerList)
         m_VariableInitializerList = VariableInitializerList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="46" endline="55"><![CDATA[
 
     Sub Init(ByVal Elements As Expression())
         m_VariableInitializerList = New VariableInitializerList(Me)
         For Each e As Expression In Elements
             Dim vi As VariableInitializer
             vi = New VariableInitializer(Me)
             vi.Init(e)
             m_VariableInitializerList.Add(vi)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="56" endline="87"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         
         If m_VariableInitializerList IsNot Nothing Then
             Dim expInfo As ExpressionResolveInfo = TryCast(Info, ExpressionResolveInfo)
             Dim elementInfo As ResolveInfo
             If expInfo IsNot Nothing Then
                 Helper.Assert(CecilHelper.GetElementType(expInfo.LHSType) IsNot Nothing)
                 Helper.Assert(CecilHelper.IsArray(expInfo.LHSType))
                 If expInfo.LHSType IsNot Nothing AndAlso CecilHelper.GetArrayRank(expInfo.LHSType) > 1 Then
                     Dim newArrayRank As Integer = CecilHelper.GetArrayRank(expInfo.LHSType) - 1
                     Dim elementType As Mono.Cecil.TypeReference = CecilHelper.MakeArrayType(CecilHelper.GetElementType(expInfo.LHSType), newArrayRank)
                     elementInfo = New ExpressionResolveInfo(Compiler, elementType)
                 Else
                     elementInfo = New ExpressionResolveInfo(Compiler, CecilHelper.GetElementType(expInfo.LHSType))
                 End If
             Else
                 Helper.StopIfDebugging(True)
                 elementInfo = Info
             End If
 
                 Helper.Assert(expInfo Is Nothing OrElse DirectCast(elementInfo, ExpressionResolveInfo).LHSType IsNot Nothing)
 
                 result = m_VariableInitializerList.ResolveCode(elementInfo) AndAlso result
             End If
         result = SetElements() AndAlso result
 
         Compiler.Helper.AddCheck("Array element initializers must all have the same number of elements / ranks.")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="88" endline="101"><![CDATA[
 
     Function SetElements() As Boolean
         Dim result As Boolean = True
         m_Elements = New Generic.List(Of Integer)
         If m_VariableInitializerList IsNot Nothing Then
             If m_VariableInitializerList.List.ToArray.Length > 0 Then
                 If m_VariableInitializerList.List.ToArray()(0).IsArrayElementInitializer Then
                     m_Elements.AddRange(m_VariableInitializerList.List.ToArray()(0).AsArrayElementInitializer.Elements)
                 End If
                 m_Elements.Insert(0, m_VariableInitializerList.List.ToArray.Length)
             End If
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="102" endline="106"><![CDATA[
 
     ReadOnly Property Elements() As Generic.List(Of Integer)
         Get
             Return m_Elements
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="107" endline="180"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim arraytype As Mono.Cecil.TypeReference = Info.DesiredType
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arraytype)
         Dim tmpvar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, arraytype))
         Dim elementInfo As EmitInfo = Info.Clone(Me, True, False, elementtype)
         Dim indexInfo As EmitInfo = Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arraytype, m_Elements)
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpvar)
 
         'Calculate the total number of elements.
         Dim elements As Integer = 1
         For i As Integer = 0 To m_Elements.Count - 1
             elements *= m_Elements(i)
         Next
         If m_Elements.Count = 0 AndAlso elements = 1 Then elements = 0
 
         'Create a list of the current indices.
         Dim indices As New Generic.List(Of Integer)
         For i As Integer = 0 To m_Elements.Count - 1
             indices.Add(0)
         Next
 
         'Get the set method, if it is a multidimensional array.
         Dim method As Mono.Cecil.MethodReference = Nothing
         If m_Elements.Count > 1 Then
             method = GetSetMethod(Compiler, arraytype)
         End If
 
         'Store every element into its index in the array.
         For i As Integer = 1 To elements
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpvar)
             'Load all the indices.
             For j As Integer = 0 To indices.Count - 1
                 Emitter.EmitLoadI4Value(indexInfo, indices(j))
             Next
             If CecilHelper.IsValueType(elementtype) AndAlso CecilHelper.IsPrimitive(Compiler, elementtype) = False AndAlso Helper.IsEnum(Compiler, elementtype) = False Then
                 Emitter.EmitLoadElementAddress(Info, elementtype, arraytype)
             End If
             'Get the element expression.
             Dim elementExpression As Expression
             elementExpression = GetRegularInitializer(indices)
             'Generate the element expression
             result = elementExpression.GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             If m_Elements.Count > 1 Then
                 Emitter.EmitCallVirt(elementInfo, method)
             Else
                 Emitter.EmitStoreElement(elementInfo, elementtype, arraytype)
             End If
             'Increment the indices.
             For j As Integer = indices.Count - 1 To 0 Step -1
                 If indices(j) + 1 = m_Elements(j) Then
                     indices(j) = 0
                 Else
                     indices(j) += 1
                     Exit For
                 End If
             Next
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpvar)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="181" endline="195"><![CDATA[
 
     Shared Function GetGetMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Get", ArrayType, elementType, True, False, Mono.Cecil.MethodCallingConvention.Default)
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="196" endline="215"><![CDATA[
 
     Shared Function GetSetMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         Dim methodtypes As Mono.Cecil.TypeReference() = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, ranks + 1)
 
         methodtypes(ranks) = elementType
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Set", ArrayType, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, Mono.Cecil.MethodCallingConvention.Default)
 
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
         result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, elementType)))
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="216" endline="232"><![CDATA[
 
     Shared Function GetAddressMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         Dim methodtypes As Mono.Cecil.TypeReference() = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, ranks)
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Address", ArrayType, CecilHelper.MakeByRefType(elementType), True, False, Mono.Cecil.MethodCallingConvention.Default)
 
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="233" endline="251"><![CDATA[
 
     Private Function GetRegularInitializer(ByVal indices As Generic.List(Of Integer)) As Expression
         Dim ai As ArrayElementInitializer = Me
         Dim result As Expression
 
         Dim index As Integer
         For i As Integer = 0 To indices.Count - 2
             index = indices(i)
             Helper.Assert(ai.m_VariableInitializerList.List.ToArray.Length > index)
             Helper.Assert(ai.m_VariableInitializerList.List.ToArray()(index).IsArrayElementInitializer)
             ai = ai.m_VariableInitializerList.List.ToArray()(index).AsArrayElementInitializer
         Next
         index = indices(indices.Count - 1)
         Helper.Assert(ai.m_VariableInitializerList.List.ToArray.Length > index)
         Helper.Assert(ai.m_VariableInitializerList.List.ToArray()(index).IsRegularInitializer)
         result = ai.m_VariableInitializerList.List.ToArray()(index).AsRegularInitializer
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="252" endline="258"><![CDATA[
 
     Sub AddInitializer(ByVal Expression As Expression)
         Dim init As New VariableInitializer(Me)
         init.Init(Expression)
         m_VariableInitializerList.Add(init)
         If SetElements() = False Then Throw New InternalException(Me)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="259" endline="263"><![CDATA[
 
     ReadOnly Property Initializers() As VariableInitializerList
         Get
             Return m_VariableInitializerList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="264" endline="268"><![CDATA[
     End Property
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.LBrace)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="30" endline="32"><![CDATA[
         Get
             Return m_ArrayModifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="33" endline="37"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_ArrayModifier.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="38" endline="41"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="42" endline="45"><![CDATA[
 
     Sub Init(ByVal ArrayModifier As ArrayTypeModifiers)
         m_ArrayModifier = ArrayModifier
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="46" endline="49"><![CDATA[
 
     Sub Init(ByVal ArrayModifier As ArraySizeInitializationModifier)
         m_ArrayModifier = ArrayModifier
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="50" endline="62"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayNameModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayNameModifier(NewParent)
         If Me.IsArrayTypeModifiers Then
             result.Init(Me.AsArrayTypeModifiers.Clone(result))
         ElseIf Me.IsArraySizeInitializationModifier Then
             result.Init(Me.AsArraySizeInitializationModifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="63" endline="72"><![CDATA[
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Me.IsArraySizeInitializationModifier Then
             Return Me.AsArraySizeInitializationModifier.CreateArrayType(OriginalType)
         ElseIf Me.IsArrayTypeModifiers Then
             Return Me.AsArrayTypeModifiers.CreateArrayType(OriginalType)
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="73" endline="76"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_ArrayModifier.ResolveCode(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="77" endline="81"><![CDATA[
 
     ReadOnly Property IsArrayTypeModifiers() As Boolean
         Get
             Return TypeOf m_ArrayModifier Is ArrayTypeModifiers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="82" endline="87"><![CDATA[
     End Property
 
     ReadOnly Property AsArrayTypeModifiers() As ArrayTypeModifiers
         Get
             Return DirectCast(m_ArrayModifier, ArrayTypeModifiers)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="88" endline="93"><![CDATA[
     End Property
 
     ReadOnly Property IsArraySizeInitializationModifier() As Boolean
         Get
             Return TypeOf m_ArrayModifier Is ArraySizeInitializationModifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="94" endline="99"><![CDATA[
     End Property
 
     ReadOnly Property AsArraySizeInitializationModifier() As ArraySizeInitializationModifier
         Get
             Return DirectCast(m_ArrayModifier, ArraySizeInitializationModifier)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="100" endline="104"><![CDATA[
     End Property
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         Return ArrayTypeModifier.CanBeMe(tm) OrElse ArraySizeInitializationModifier.CanBeMe(tm)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="32" endline="39"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveTypeReferences AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="40" endline="43"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="44" endline="48"><![CDATA[
 
     Sub Init(ByVal BoundList As BoundList, ByVal ArrayTypeModifiers As ArrayTypeModifiers)
         m_BoundList = BoundList
         m_ArrayTypeModifiers = ArrayTypeModifiers
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="49" endline="56"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArraySizeInitializationModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArraySizeInitializationModifier(NewParent)
         result.m_BoundList = m_BoundList.Clone(result)
         If m_ArrayTypeModifiers IsNot Nothing Then result.m_ArrayTypeModifiers = m_ArrayTypeModifiers.Clone(result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="57" endline="61"><![CDATA[
 
     ReadOnly Property BoundList() As BoundList
         Get
             Return m_BoundList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="62" endline="67"><![CDATA[
     End Property
 
     ReadOnly Property ArrayTypeModifiers() As ArrayTypeModifiers
         Get
             Return m_ArrayTypeModifiers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="68" endline="91"><![CDATA[
     End Property
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = OriginalType
 
         If m_ArrayTypeModifiers IsNot Nothing Then
             result = m_ArrayTypeModifiers.CreateArrayType(result)
         End If
 
         If m_BoundList.Expressions.GetUpperBound(0) = 0 Then
             result = CecilHelper.MakeArrayType(result)
         Else
             Dim arr As ArrayType
             arr = CecilHelper.MakeArrayType(result, m_BoundList.Expressions.GetUpperBound(0) + 1)
             result = arr
             If arr.Rank > 1 Then
                 For d As Integer = 0 To arr.Rank - 1
                     arr.Dimensions(d) = New ArrayDimension(New Nullable(Of Integer)(0), Nothing)
                 Next
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="92" endline="100"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveCode(Info) AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="101" endline="112"><![CDATA[
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         If tm.CurrentToken = KS.LParenthesis Then
             If tm.PeekToken.Equals(KS.Comma, KS.RParenthesis) Then
                 Return False
             Else
                 Return True
             End If
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifier.vb" startline="30" endline="32"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifier.vb" startline="33" endline="36"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifier.vb" startline="37" endline="41"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Ranks As Integer)
         MyBase.New(Parent)
         m_Ranks = Ranks
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifier.vb" startline="42" endline="45"><![CDATA[
 
     Sub Init(ByVal Ranks As Integer)
         m_Ranks = Ranks
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifier.vb" startline="46" endline="50"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Return New ArrayTypeModifier(NewParent, m_Ranks)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifier.vb" startline="51" endline="55"><![CDATA[
 
     ReadOnly Property Ranks() As Integer
         Get
             Return m_Ranks
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifier.vb" startline="56" endline="60"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return True 'Nothing to resolve.
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifier.vb" startline="61" endline="64"><![CDATA[
 
     Overrides Function ToString() As String
         Return "(" & New String(","c, m_Ranks - 1) & ")"
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifier.vb" startline="65" endline="68"><![CDATA[
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.LParenthesis AndAlso (tm.PeekToken.Equals(KS.Comma, KS.RParenthesis))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="29" endline="31"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_ArrayTypeModifiers Is Nothing OrElse Helper.ResolveTypeReferencesCollection(m_ArrayTypeModifiers)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="32" endline="35"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="36" endline="39"><![CDATA[
 
     Sub Init(ByVal ArrayTypeModifiers() As ArrayTypeModifier)
         m_ArrayTypeModifiers = ArrayTypeModifiers
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="40" endline="50"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeModifiers
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeModifiers(NewParent)
         Dim mods(m_ArrayTypeModifiers.GetUpperBound(0)) As ArrayTypeModifier
         For i As Integer = 0 To mods.GetUpperBound(0)
             mods(i) = m_ArrayTypeModifiers(i).Clone(result)
         Next
         result.Init(mods)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="51" endline="66"><![CDATA[
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeReference(Compiler, OriginalType)
         Dim mods() As ArrayTypeModifier = m_ArrayTypeModifiers
         For i As Integer = mods.GetUpperBound(0) To 0 Step -1
             Dim arr As ArrayType
             arr = CecilHelper.MakeArrayType(result, mods(i).Ranks)
             result = arr
             If arr.Rank > 1 Then
                 For d As Integer = 0 To arr.Rank - 1
                     arr.Dimensions(d) = New ArrayDimension(New Nullable(Of Integer)(0), Nothing)
                 Next
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="67" endline="71"><![CDATA[
 
     ReadOnly Property ArrayTypeModifiers() As ArrayTypeModifier()
         Get
             Return m_ArrayTypeModifiers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="72" endline="81"><![CDATA[
     End Property
 
     ''' <summary>
     ''' There is no code to resolve here.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return True ' Helper.ResolveCodeCollection(m_ArrayTypeModifiers)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="82" endline="89"><![CDATA[
 
     Overrides Function ToString() As String
         Dim result As String = ""
         For Each atn As ArrayTypeModifier In m_ArrayTypeModifiers
             result &= atn.ToString
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="90" endline="93"><![CDATA[
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         Return ArrayTypeModifier.CanBeMe(tm)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="47" endline="49"><![CDATA[
         Get
             Return m_CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="50" endline="64"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns the specified argument, or nothing if index is out of range
     ''' </summary>
     ''' <param name="Index"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetArgument(ByVal Index As Integer) As Object
         If m_Arguments IsNot Nothing AndAlso Index < m_Arguments.Length Then
             Return m_Arguments(Index)
         Else
             Return Nothing
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="65" endline="69"><![CDATA[
 
     ReadOnly Property Arguments() As Object()
         Get
             Return m_Arguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="70" endline="75"><![CDATA[
     End Property
 
     ReadOnly Property IsAssembly() As Boolean
         Get
             Return m_IsAssembly
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="76" endline="81"><![CDATA[
     End Property
 
     ReadOnly Property IsModule() As Boolean
         Get
             Return m_IsModule
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="82" endline="87"><![CDATA[
     End Property
 
     ReadOnly Property SimpleTypeName() As SimpleTypeName
         Get
             Return m_SimpleTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="88" endline="93"><![CDATA[
     End Property
 
     Property ResolvedType() As Mono.Cecil.TypeReference
         Get
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="94" endline="96"><![CDATA[
         Set(ByVal value As Mono.Cecil.TypeReference)
             m_ResolvedType = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="97" endline="105"><![CDATA[
     End Property
 
     ReadOnly Property AttributeArguments() As AttributeArguments
         Get
             If m_AttributeArguments Is Nothing Then
                 m_AttributeArguments = New AttributeArguments(Me)
             End If
             Return m_AttributeArguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="106" endline="110"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="111" endline="116"><![CDATA[
 
     Public Sub New(ByVal Parent As ParsedObject, ByVal Type As Mono.Cecil.TypeReference, ByVal ParamArray Arguments() As Object)
         MyBase.New(Parent)
         m_ResolvedType = Type
         m_Arguments = Arguments
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="117" endline="123"><![CDATA[
 
     Sub Init(ByVal IsAssembly As Boolean, ByVal IsModule As Boolean, ByVal SimpleTypeName As SimpleTypeName, ByVal AttributeArguments As AttributeArguments)
         m_IsAssembly = IsAssembly
         m_IsModule = IsModule
         m_SimpleTypeName = SimpleTypeName
         m_AttributeArguments = AttributeArguments
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="124" endline="136"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attribute
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attribute(NewParent)
         result.m_IsAssembly = m_IsAssembly
         result.m_IsModule = m_IsModule
         If m_SimpleTypeName IsNot Nothing Then result.m_SimpleTypeName = m_SimpleTypeName.Clone(result)
         If m_AttributeArguments IsNot Nothing Then result.m_AttributeArguments = m_AttributeArguments.Clone(result)
         result.m_ResolvedType = m_ResolvedType
         result.m_ResolvedTypeConstructor = m_ResolvedTypeConstructor
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="137" endline="148"><![CDATA[
 
     Private Function ConvertArgument(ByVal constant As Object, ByVal Type As Mono.Cecil.TypeReference) As Object
         If Helper.IsEnum(Compiler, Type) = False Then Return constant
 
         Dim enumCecilAssembly As Mono.Cecil.AssemblyNameReference = CecilHelper.GetAssemblyRef(Type)
         Dim enumAssembly As Assembly = System.Reflection.Assembly.Load(enumCecilAssembly.FullName)
         Dim enumType As Type = enumAssembly.GetType(Type.FullName)
 
         If enumType.IsEnum = False Then Return constant
 
         Return System.Enum.ToObject(enumType, constant)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="149" endline="204"><![CDATA[
 
     Function Instantiate(ByVal errorNumber As Messages, ByRef instantiation As Object) As Boolean
         Dim attribModule As Mono.Cecil.ModuleDefinition = TryCast(ResolvedType.Scope, Mono.Cecil.ModuleDefinition)
         Dim attribAssembly As Assembly
         Dim attribType As Type
         Dim attribInstance As Object
 
         If attribModule Is Nothing Then
             Return Compiler.Report.ShowMessage(errorNumber, Location, "The attribute isn't defined in an assembly.")
         End If
 
         attribAssembly = System.Reflection.Assembly.Load(attribModule.Assembly.Name.FullName)
 
         If attribAssembly Is Nothing Then
             Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("Could not load the assembly '{0}' where this attribute is stored.", attribModule.Assembly.Name.FullName))
         End If
 
         attribType = attribAssembly.GetType(ResolvedType.FullName, False, False)
 
         If attribType Is Nothing Then
             Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("Could not load the type '{0}' from the assembly '{1}'.", ResolvedType.FullName, attribAssembly.FullName))
         End If
 
         Dim args As Object()
         ReDim args(Me.m_Arguments.Length)
         ReDim args(Me.m_Arguments.Length - 1)
         For i As Integer = 0 To m_Arguments.Length - 1
             args(i) = ConvertArgument(m_Arguments(i), m_ResolvedTypeConstructor.Parameters(i).ParameterType)
         Next
         attribInstance = Activator.CreateInstance(attribType, args)
 
         For i As Integer = 0 To m_Fields.Count - 1
             Dim fieldInfo As FieldInfo
             fieldInfo = attribType.GetField(m_Fields(i).Name, BindingFlags.Instance Or BindingFlags.Public)
             If fieldInfo Is Nothing Then
                 Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("Could not find the field '{0}' on the type '{1}'.", m_Fields(i).Name, attribType.FullName))
             End If
 
             fieldInfo.SetValue(attribInstance, m_FieldValues(i))
         Next
 
         For i As Integer = 0 To m_Properties.Count - 1
             Dim propInfo As PropertyInfo
             propInfo = attribType.GetProperty(m_Properties(i).Name, Type.EmptyTypes)
             If propInfo Is Nothing Then
                 Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("Could not find the property '{0}' on the type '{1}'.", m_Properties(i).Name, attribType.FullName))
             End If
             If propInfo.CanWrite = False Then
                 Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("The property '{0}' on the type '{1}' is ReadOnly.", propInfo.Name, attribType.FullName))
             End If
             propInfo.SetValue(attribInstance, m_PropertyValues(i), Nothing)
         Next
 
         instantiation = attribInstance
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="205" endline="210"><![CDATA[
 
     ReadOnly Property AttributeType() As Mono.Cecil.TypeReference
         Get
             ' If m_ResolvedType Is Nothing Then Throw New InternalException(Me)
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="211" endline="224"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedType Is Nothing Then
             Helper.Assert(m_SimpleTypeName IsNot Nothing, "SimpleTypeName Is Nothing
             result = m_SimpleTypeName.ResolveTypeReferences(True) AndAlso result
             m_ResolvedType = m_SimpleTypeName.ResolvedType
         End If
         result = m_ResolvedType IsNot Nothing AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="225" endline="497"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim argList As ArgumentList
 
         If m_IsResolved Then Return result
 
         If m_AttributeArguments IsNot Nothing Then
             Helper.Assert(m_Arguments Is Nothing)
             Helper.Assert(m_Fields Is Nothing)
             Helper.Assert(m_FieldValues Is Nothing)
             Helper.Assert(m_Properties Is Nothing)
             Helper.Assert(m_PropertyValues Is Nothing)
 
             result = m_AttributeArguments.ResolveCode(Info) AndAlso result
 
             If m_AttributeArguments.PositionalArgumentList IsNot Nothing Then
                 argList = New ArgumentList(Me, m_AttributeArguments.PositionalArgumentList.AsExpressions)
             Else
                 argList = New ArgumentList(Me)
             End If
 
             If m_AttributeArguments.VariablePropertyInitializerList IsNot Nothing Then
                 Dim cache As MemberCache
 
                 cache = Info.Compiler.TypeManager.GetCache(m_ResolvedType)
 
                 For Each item As VariablePropertyInitializer In m_AttributeArguments.VariablePropertyInitializerList
                     Dim name As String
                     Dim member As Mono.Cecil.MemberReference
                     Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
                     name = item.Identifier
                     members = cache.LookupFlattenedMembers(name)
                     members = Helper.FilterExternalInaccessible(Info.Compiler, members)
                     If members.Count <> 1 Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                     member = members(0)
                     If TypeOf member Is Mono.Cecil.FieldReference Then
                         Dim field As Mono.Cecil.FieldReference
                         field = DirectCast(member, Mono.Cecil.FieldReference)
 
                         If m_Fields Is Nothing Then m_Fields = New Generic.List(Of Mono.Cecil.FieldReference)
                         If m_FieldValues Is Nothing Then m_FieldValues = New Generic.List(Of Object)
                         m_Fields.Add(field)
                         m_FieldValues.Add(item.AttributeArgumentExpression.Expression.ConstantValue)
                     ElseIf TypeOf member Is Mono.Cecil.PropertyReference Then
                         Dim prop As Mono.Cecil.PropertyReference
                         prop = DirectCast(member, Mono.Cecil.PropertyReference)
                         If m_Properties Is Nothing Then m_Properties = New Generic.List(Of Mono.Cecil.PropertyReference)
                         If m_PropertyValues Is Nothing Then m_PropertyValues = New Generic.List(Of Object)
                         m_Properties.Add(prop)
                         m_PropertyValues.Add(item.AttributeArgumentExpression.Expression.ConstantValue)
                         'm_PropertyValues.add(item.
                     Else
                         Helper.AddError(Me, "Invalid member type for attribute value.")
                     End If
                 Next
             End If
 
         ElseIf m_Arguments IsNot Nothing Then
             argList = New ArgumentList(Me)
             For i As Integer = 0 To m_Arguments.Length - 1
                 argList.Arguments.Add(New PositionalArgument(argList, argList.Count, New ConstantExpression(argList, m_Arguments(i), CecilHelper.GetType(Compiler, m_Arguments(i)))))
             Next
         Else
             argList = New ArgumentList(Me)
         End If
 
         If m_Arguments Is Nothing Then m_Arguments = New Object() {}
         If m_Fields Is Nothing Then m_Fields = New Generic.List(Of Mono.Cecil.FieldReference)
         If m_FieldValues Is Nothing Then m_FieldValues = New Generic.List(Of Object)
         If m_Properties Is Nothing Then m_Properties = New Generic.List(Of Mono.Cecil.PropertyReference)
         If m_PropertyValues Is Nothing Then m_PropertyValues = New Generic.List(Of Object)
 
         Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference)
         Dim parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         ctors = CecilHelper.GetConstructors(m_ResolvedType)
 
         Dim groupClassification As New MethodGroupClassification(Me, Nothing, Nothing, Nothing, ctors)
         result = groupClassification.ResolveGroup(argList) AndAlso result
         m_ResolvedTypeConstructor = groupClassification.ResolvedConstructor
         result = m_ResolvedTypeConstructor IsNot Nothing AndAlso result
         result = argList.FillWithOptionalParameters(m_ResolvedTypeConstructor) AndAlso result
 
         parameters = Helper.GetParameters(Me, m_ResolvedTypeConstructor)
 
         ReDim m_Arguments(argList.Count - 1)
         For i As Integer = 0 To m_Arguments.Length - 1
             m_Arguments(i) = argList(i).Expression.ConstantValue
             If TypeOf m_Arguments(i) Is DBNull Then
                 m_Arguments(i) = Nothing
             End If
         Next
 
         m_IsResolved = result
 
         If result Then
             For i As Integer = 0 To m_Arguments.Length - 1
                 Dim value As Object = Nothing
                 If TypeOf m_Arguments(i) Is TypeReference Then Continue For
                 result = TypeConverter.ConvertTo(Me, m_Arguments(i), parameters(i).ParameterType, value)
                 If result Then m_Arguments(i) = value
             Next
             For i As Integer = 0 To m_FieldValues.Count - 1
                 Dim value As Object = Nothing
                 'TypeConverter.ConvertTo will report any errors
                 result = TypeConverter.ConvertTo(Me, m_FieldValues(i), m_Fields(i).FieldType, value)
                 If result Then m_FieldValues(i) = value
             Next
             For i As Integer = 0 To m_PropertyValues.Count - 1
                 Dim value As Object = Nothing
                 'TypeConverter.ConvertTo will report any errors
                 result = TypeConverter.ConvertTo(Me, m_PropertyValues(i), m_Properties(i).PropertyType, value)
                 If result Then m_PropertyValues(i) = value
             Next
         End If
 
         m_CecilBuilder = GetAttributeBuilderCecil()
 
         If m_IsAssembly Then
             Me.Compiler.AssemblyBuilderCecil.CustomAttributes.Add(CecilBuilder)
         ElseIf m_IsModule Then
             Me.Compiler.ModuleBuilderCecil.CustomAttributes.Add(CecilBuilder)
         Else
             Dim memberparent As IAttributableDeclaration = Me.FindFirstParent(Of IAttributableDeclaration)()
             If memberparent IsNot Nothing Then
                 Dim tp As TypeDeclaration = TryCast(memberparent, TypeDeclaration)
                 Dim mthd As IMethod = TryCast(memberparent, IMethod)
                 Dim ctro As IConstructorMember = TryCast(memberparent, IConstructorMember)
                 Dim fld As IFieldMember = TryCast(memberparent, IFieldMember)
                 Dim prop As PropertyDeclaration = TryCast(memberparent, PropertyDeclaration)
                 Dim param As Parameter = TryCast(memberparent, Parameter)
                 Dim evt As EventDeclaration = TryCast(memberparent, EventDeclaration)
 
                 If ctro IsNot Nothing Then mthd = Nothing
                 Helper.Assert(tp IsNot Nothing Xor mthd IsNot Nothing Xor ctro IsNot Nothing Xor fld IsNot Nothing Xor prop IsNot Nothing Xor param IsNot Nothing OrElse evt IsNot Nothing)
 
                 If tp IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_SerializableAttribute) Then
                         tp.Serializable = True
                     ElseIf Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_StructLayoutAttribute) Then
                         Dim layout As System.Runtime.InteropServices.LayoutKind
                         layout = CType(CecilBuilder.ConstructorArguments(0).Value, System.Runtime.InteropServices.LayoutKind)
                         Select Case layout
                             Case Runtime.InteropServices.LayoutKind.Auto
                                 tp.CecilType.IsAutoLayout = True
                             Case Runtime.InteropServices.LayoutKind.Explicit
                                 tp.CecilType.IsExplicitLayout = True
                             Case Runtime.InteropServices.LayoutKind.Sequential
                                 tp.CecilType.IsSequentialLayout = True
                             Case Else
                                 Compiler.Report.ShowMessage(Messages.VBNC30127, Me.Location, CecilBuilder.Constructor.DeclaringType.FullName, "Invalid argument.")
                                 Return False
                         End Select
                     Else
                         tp.CecilType.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf mthd IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
                         Dim values As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttributeNamedArgument) = CecilBuilder.Fields
                         Dim modRef As Mono.Cecil.ModuleReference = Nothing
                         Dim modRefName As String = DirectCast(CecilBuilder.ConstructorArguments(0).Value, String)
                         Dim entry As String = Nothing
                         Dim charSetField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim entryPointField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim callingConventionField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim setLastErrorField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
 
                         For i As Integer = 0 To values.Count - 1
                             If Helper.CompareNameOrdinal(values(i).Name, "CharSet") Then
                                 charSetField = values(i)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "EntryPoint") Then
                                 entryPointField = values(i)
                                 entry = DirectCast(entryPointField.Value.Argument.Value, String)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "CallingConvention") Then
                                 callingConventionField = values(i)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "SetLastError") Then
                                 setLastErrorField = values(i)
                             End If
                         Next
 
                         If entry = String.Empty Then entry = mthd.Name
                         For i As Integer = 0 To Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences.Count - 1
                             If Helper.CompareNameOrdinal(Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences(i).Name, modRefName) Then
                                 modRef = Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences(i)
                                 Exit For
                             End If
                         Next
                         If modRef Is Nothing Then
                             modRef = New Mono.Cecil.ModuleReference(modRefName)
                             Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences.Add(modRef)
                         End If
                         mthd.CecilBuilder.PInvokeInfo = New Mono.Cecil.PInvokeInfo(0, entry, modRef)
 
                         Dim charset As System.Runtime.InteropServices.CharSet
                         If charSetField.HasValue Then
                             charset = DirectCast(charSetField.Value.Argument.Value, System.Runtime.InteropServices.CharSet)
                         Else
                             charset = Runtime.InteropServices.CharSet.Auto
                         End If
                         Select Case charset
                             Case Runtime.InteropServices.CharSet.Ansi
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetAnsi = True
                             Case Runtime.InteropServices.CharSet.Auto
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetAuto = True
                             Case Runtime.InteropServices.CharSet.None
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetNotSpec = True
                             Case Runtime.InteropServices.CharSet.Unicode
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetUnicode = True
                             Case Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Invalid charset
                         End Select
 
                         Dim callingconv As System.Runtime.InteropServices.CallingConvention
                         If callingConventionField.HasValue Then
                             callingconv = DirectCast(callingConventionField.Value.Argument.Value, System.Runtime.InteropServices.CallingConvention)
                         Else
                             callingconv = Runtime.InteropServices.CallingConvention.Winapi
                         End If
                         Select Case callingconv
                             Case Runtime.InteropServices.CallingConvention.Cdecl
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvCdecl = True
                             Case Runtime.InteropServices.CallingConvention.FastCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvFastcall = True
                             Case Runtime.InteropServices.CallingConvention.StdCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvStdCall = True
                             Case Runtime.InteropServices.CallingConvention.ThisCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvThiscall = True
                             Case Runtime.InteropServices.CallingConvention.Winapi
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvWinapi = True
                             Case Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Invalid calling convention
                         End Select
 
                         Dim setlasterror As Boolean = True
                         If setLastErrorField.HasValue Then
                             setlasterror = DirectCast(setLastErrorField.Value.Argument.Value, Boolean)
                         End If
                         mthd.CecilBuilder.PInvokeInfo.SupportsLastError = setlasterror
                         mthd.CecilBuilder.PInvokeInfo.IsNoMangle = True
                     Else
                         mthd.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf ctro IsNot Nothing Then
                     ctro.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf fld IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_MarshalAsAttribute) Then
                         fld.FieldBuilder.MarshalInfo = New MarshalInfo(CType(CecilBuilder.ConstructorArguments(0).Value, Mono.Cecil.NativeType))
                         fld.FieldBuilder.Attributes = fld.FieldBuilder.Attributes Or Mono.Cecil.FieldAttributes.HasFieldMarshal
                     ElseIf Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_FieldOffsetAttribute) Then
                         fld.FieldBuilder.Offset = CType(CecilBuilder.ConstructorArguments(0).Value, Integer)
                     Else
                         fld.FieldBuilder.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf prop IsNot Nothing Then
                     prop.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf param IsNot Nothing Then
                     param.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf evt IsNot Nothing Then
                     evt.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 End If
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="498" endline="501"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="502" endline="505"><![CDATA[
 
     Public Function GetSecurityAttribute() As Mono.Cecil.SecurityAttribute
         Return DirectCast(GetAttribute(True), SecurityAttribute)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="506" endline="509"><![CDATA[
 
     Private Function GetAttributeBuilderCecil() As Mono.Cecil.CustomAttribute
         Return DirectCast(GetAttribute(False), CustomAttribute)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="510" endline="561"><![CDATA[
 
     Private Function GetAttribute(ByVal security As Boolean) As Mono.Cecil.ICustomAttribute
         Dim result As ICustomAttribute
         Dim customAttribute As CustomAttribute = Nothing
         Dim securityAttribute As SecurityAttribute = Nothing
         Dim parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetParameters(Compiler, m_ResolvedTypeConstructor)
 
         Helper.Assert(m_ResolvedTypeConstructor IsNot Nothing)
         Helper.Assert(m_Arguments IsNot Nothing)
         Helper.Assert(parameters.Count = m_Arguments.Length)
         Helper.Assert(m_Properties IsNot Nothing AndAlso m_PropertyValues IsNot Nothing AndAlso m_Properties.Count = m_PropertyValues.Count)
         Helper.Assert(m_Fields IsNot Nothing AndAlso m_FieldValues IsNot Nothing AndAlso m_Fields.Count = m_FieldValues.Count)
 
         m_ResolvedTypeConstructor = Helper.GetMethodOrMethodReference(Compiler, m_ResolvedTypeConstructor)
 
         Dim cecilArguments As Object()
         ReDim cecilArguments(m_Arguments.Length - 1)
         Array.Copy(m_Arguments, cecilArguments, m_Arguments.Length)
         For i As Integer = 0 To cecilArguments.Length - 1
             Dim type As Mono.Cecil.TypeReference
             type = TryCast(cecilArguments(i), Mono.Cecil.TypeReference)
             If type IsNot Nothing Then
                 cecilArguments(i) = Helper.GetTypeOrTypeReference(Compiler, type)
             End If
         Next
 
         Try
             If security Then
                 securityAttribute = New SecurityAttribute(Me.AttributeType)
                 result = securityAttribute
             Else
                 customAttribute = New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, m_ResolvedTypeConstructor))
                 result = customAttribute
             End If
 
             For i As Integer = 0 To m_Fields.Count - 1
                 result.Fields.Add(New Mono.Cecil.CustomAttributeNamedArgument(m_Fields(i).Name, New CustomAttributeArgument(Helper.GetTypeOrTypeReference(Compiler, m_Fields(i).FieldType), m_FieldValues(i))))
             Next
             For i As Integer = 0 To m_Properties.Count - 1
                 result.Properties.Add(New Mono.Cecil.CustomAttributeNamedArgument(m_Properties(i).Name, New CustomAttributeArgument(Helper.GetTypeOrTypeReference(Compiler, m_Properties(i).PropertyType), m_PropertyValues(i))))
             Next
             If customAttribute IsNot Nothing Then
                 For i As Integer = 0 To cecilArguments.Length - 1
                     customAttribute.ConstructorArguments.Add(New CustomAttributeArgument(Helper.GetTypeOrTypeReference(Compiler, parameters(i).ParameterType), cecilArguments(i)))
                 Next
             End If
         Catch ex As Exception
             Throw
         End Try
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="32" endline="34"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="35" endline="38"><![CDATA[
 
     Sub Init(ByVal Expression As Expression)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="39" endline="45"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArgumentExpression
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArgumentExpression(NewParent)
         result.Init(m_Expression.Clone(result))
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="46" endline="53"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="54" endline="61"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="62" endline="66"><![CDATA[
 
     ReadOnly Property Expression() As Expression
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="67" endline="71"><![CDATA[
     End Property
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         Return Not VariablePropertyInitializer.IsMe(tm)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="34" endline="36"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="37" endline="41"><![CDATA[
 
     Sub Init(ByVal PositionalArgumentList As AttributePositionalArgumentList, ByVal VariablePropertyInitializerList As VariablePropertyInitializerList)
         m_AttributePositionalArgumentList = PositionalArgumentList
         m_VariablePropertyInitializerList = VariablePropertyInitializerList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="42" endline="50"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArguments
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArguments(NewParent)
         If m_AttributePositionalArgumentList IsNot Nothing Then result.m_AttributePositionalArgumentList = m_AttributePositionalArgumentList.clone(result)
         If m_VariablePropertyInitializerList IsNot Nothing Then result.m_VariablePropertyInitializerList = m_VariablePropertyInitializerList.clone(result)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="51" endline="59"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_AttributePositionalArgumentList IsNot Nothing Then result = m_AttributePositionalArgumentList.ResolveCode(info) AndAlso result
         If m_VariablePropertyInitializerList IsNot Nothing Then result = m_VariablePropertyInitializerList.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="60" endline="67"><![CDATA[
 
     ReadOnly Property PositionalArgumentList() As AttributePositionalArgumentList
         Get
             If m_AttributePositionalArgumentList Is Nothing Then
                 m_AttributePositionalArgumentList = New AttributePositionalArgumentList(Me)
             End If
             Return m_AttributePositionalArgumentList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="68" endline="76"><![CDATA[
     End Property
 
     ReadOnly Property VariablePropertyInitializerList() As VariablePropertyInitializerList
         Get
             If m_VariablePropertyInitializerList Is Nothing Then
                 m_VariablePropertyInitializerList = New VariablePropertyInitializerList(Me)
             End If
             Return m_VariablePropertyInitializerList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeBlock.vb" startline="29" endline="31"><![CDATA[
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return m_List.GenerateCode(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeBlock.vb" startline="32" endline="36"><![CDATA[
 
     ReadOnly Property List() As AttributeList
         Get
             Return m_List
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeBlock.vb" startline="37" endline="41"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_List.ResolveCode(info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeBlock.vb" startline="42" endline="47"><![CDATA[
 
     Sub New(ByVal Parent As BaseObject, ByVal ParamArray Attributes() As Attribute)
         MyBase.New(Parent)
         m_List = New AttributeList(Me)
         m_List.List.AddRange(Attributes)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeBlock.vb" startline="48" endline="51"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.LT
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeList.vb" startline="28" endline="30"><![CDATA[
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return Helper.GenerateCodeCollection(m_List, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeList.vb" startline="31" endline="35"><![CDATA[
 
     ReadOnly Property List() As Generic.List(Of Attribute)
         Get
             Return m_list
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeList.vb" startline="36" endline="44"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each attrib As Attribute In m_List
             result = attrib.ResolveCode(info) AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeList.vb" startline="45" endline="48"><![CDATA[
 
     Sub New(ByVal Parent As BaseObject)
         MyBase.New(Parent)
     Private m_List As New Generic.List(Of Attribute)
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return Helper.GenerateCodeCollection(m_List, Info)
     End Function
 
     ReadOnly Property List() As Generic.List(Of Attribute)
         Get
             Return m_list
         End Get
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each attrib As Attribute In m_List
             result = attrib.ResolveCode(info) AndAlso result
         Next
         Return result
     End Function
 
     Sub New(ByVal Parent As BaseObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="31" endline="33"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="34" endline="39"><![CDATA[
 
     Overloads Sub Add(ByVal Constant As Object)
         Dim exp As New AttributeArgumentExpression(Me)
         exp.Init(New ConstantExpression(exp, Constant, CecilHelper.GetType(Compiler, Constant)))
         Add(exp)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="40" endline="43"><![CDATA[
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         Return AttributeArgumentExpression.CanBeMe(tm)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="44" endline="52"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributePositionalArgumentList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributePositionalArgumentList(NewParent)
         For Each item As AttributeArgumentExpression In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="53" endline="61"><![CDATA[
 
     ReadOnly Property AsExpressions() As Expression()
         Get
             Dim result(Me.Count - 1) As Expression
             For i As Integer = 0 To Me.Count - 1
                 result(i) = Item(i).Expression
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="27" endline="29"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="30" endline="38"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attributes
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attributes(NewParent)
         For Each item As Attribute In Me
             result.Add(item.Clone(NewParent))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="39" endline="52"><![CDATA[
 
     Function IsDefined(ByVal AttributeType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = False
 
         For Each att As Attribute In Me
             If AttributeType Is Nothing Then Return False
             If Helper.CompareType(att.AttributeType, AttributeType) Then
                 result = True
                 Exit For
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="53" endline="72"><![CDATA[
 
     ''' <summary>
     ''' Might return nothing
     ''' </summary>
     ''' <param name="AttributeType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindAttributes(ByVal AttributeType As Mono.Cecil.TypeReference) As Generic.List(Of Attribute)
         Dim result As Generic.List(Of Attribute) = Nothing
 
         If AttributeType Is Nothing Then Return Nothing
 
         For Each att As Attribute In Me
             If Helper.CompareType(att.AttributeType, AttributeType) Then
                 If result Is Nothing Then result = New Generic.List(Of Attribute)
                 result.Add(att)
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="73" endline="76"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.LT
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList.vb" startline="26" endline="28"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="30" endline="36"><![CDATA[
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For i As Integer = 0 To m_List.Count - 1
             m_List(i).Initialize(Parent)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="37" endline="44"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_List.Count - 1
             result = m_List(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="45" endline="48"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return Helper.ResolveTypeReferencesCollection(m_List)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="49" endline="52"><![CDATA[
 
     Sub Insert(ByVal index As Integer, ByVal Item As T)
         m_List.Insert(index, Item)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="53" endline="56"><![CDATA[
 
     Sub RemoveAt(ByVal index As Integer)
         m_List.RemoveAt(index)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="57" endline="60"><![CDATA[
 
     Sub Clear()
         m_List.Clear()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="61" endline="65"><![CDATA[
 
     Function Add(ByVal Item As T) As T
         m_List.Add(Item)
         Return Item
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="66" endline="71"><![CDATA[
 
     Sub AddRange(ByVal List As Generic.IEnumerable(Of T))
         For Each item As T In List
             m_List.Add(item)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="72" endline="75"><![CDATA[
 
     Overridable Function NewObject() As T
         Throw New InternalException(Me)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="76" endline="79"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     Private m_List As New Generic.List(Of T)
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For i As Integer = 0 To m_List.Count - 1
             m_List(i).Initialize(Parent)
         Next
     End Sub
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_List.Count - 1
             result = m_List(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return Helper.ResolveTypeReferencesCollection(m_List)
     End Function
 
     Sub Insert(ByVal index As Integer, ByVal Item As T)
         m_List.Insert(index, Item)
     End Sub
 
     Sub RemoveAt(ByVal index As Integer)
         m_List.RemoveAt(index)
     End Sub
 
     Sub Clear()
         m_List.Clear()
     End Sub
 
     Function Add(ByVal Item As T) As T
         m_List.Add(Item)
         Return Item
     End Function
 
     Sub AddRange(ByVal List As Generic.IEnumerable(Of T))
         For Each item As T In List
             m_List.Add(item)
         Next
     End Sub
 
     Overridable Function NewObject() As T
         Throw New InternalException(Me)
     End Function
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="80" endline="84"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Objects() As T)
         MyBase.new(Parent)
     Private m_List As New Generic.List(Of T)
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For i As Integer = 0 To m_List.Count - 1
             m_List(i).Initialize(Parent)
         Next
     End Sub
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_List.Count - 1
             result = m_List(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return Helper.ResolveTypeReferencesCollection(m_List)
     End Function
 
     Sub Insert(ByVal index As Integer, ByVal Item As T)
         m_List.Insert(index, Item)
     End Sub
 
     Sub RemoveAt(ByVal index As Integer)
         m_List.RemoveAt(index)
     End Sub
 
     Sub Clear()
         m_List.Clear()
     End Sub
 
     Function Add(ByVal Item As T) As T
         m_List.Add(Item)
         Return Item
     End Function
 
     Sub AddRange(ByVal List As Generic.IEnumerable(Of T))
         For Each item As T In List
             m_List.Add(item)
         Next
     End Sub
 
     Overridable Function NewObject() As T
         Throw New InternalException(Me)
     End Function
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Objects() As T)
         MyBase.new(Parent)
         m_List.AddRange(Objects)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="85" endline="89"><![CDATA[
 
     Default ReadOnly Property Item(ByVal Index As Integer) As T
         Get
             Return DirectCast(m_List.Item(Index), T)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="90" endline="95"><![CDATA[
     End Property
 
     ReadOnly Property Count() As Integer
         Get
             Return m_List.Count
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="96" endline="101"><![CDATA[
     End Property
 
     ReadOnly Property Length() As Integer
         Get
             Return m_List.Count
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="102" endline="107"><![CDATA[
     End Property
 
     Public ReadOnly Property List() As Generic.List(Of T)
         Get
             Return m_List
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="108" endline="112"><![CDATA[
     End Property
 
     Private Function GetEnumerator2() As System.Collections.IEnumerator Implements System.Collections.IEnumerable.GetEnumerator
         Return m_List.GetEnumerator
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="113" endline="116"><![CDATA[
 
     Public Function GetEnumerator() As System.Collections.Generic.IEnumerator(Of T) Implements System.Collections.Generic.IEnumerable(Of T).GetEnumerator
         Return m_List.GetEnumerator
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="30" endline="32"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="33" endline="36"><![CDATA[
 
     Sub Init(ByVal Expressions() As Expression)
         m_Expressions = Expressions
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="37" endline="43"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As BoundList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New BoundList(NewParent)
         result.Init(Helper.CloneExpressionArray(m_Expressions, result))
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="44" endline="48"><![CDATA[
 
     ReadOnly Property Expressions() As Expression()
         Get
             Return m_Expressions
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="49" endline="61"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Expressions.Length - 1
             result = m_Expressions(i).ResolveExpression(Info) AndAlso result
             If result Then
                 m_Expressions(i) = Helper.CreateTypeConversion(Me, m_Expressions(i), Compiler.TypeCache.System_Int32, result)
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="62" endline="69"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Expressions) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="40" endline="42"><![CDATA[
         Get
             Return m_RequiresSharedInitialization
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="43" endline="48"><![CDATA[
     End Property
 
     ReadOnly Property Resolved() As Boolean
         Get
             Return m_Resolved
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="49" endline="54"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="55" endline="62"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         MyBase.Init(Modifiers, Identifier.Name)
         m_Identifier = Identifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="63" endline="74"><![CDATA[
 
     ''' <summary>
     ''' Checks for the following grammar
     ''' ConstantMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Const
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="75" endline="87"><![CDATA[
 
     ReadOnly Property ConstantValue() As Object
         Get
             If m_Resolved = False Then
                 Dim result As Boolean
                 result = ResolveConstantValue(ResolveInfo.Default(Compiler))
                 If result = False Then
                     Helper.AddError(Me, "")
                     Return Nothing
                 End If
             End If
             Return m_ConstantValue
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="88" endline="116"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             result = m_TypeName.ResolveTypeReferences AndAlso result
             If m_Identifier.HasTypeCharacter Then
                 Helper.AddError(Me)
             End If
         ElseIf m_Identifier.HasTypeCharacter Then
             m_TypeName = New TypeName(Me, TypeCharacters.TypeCharacterToType(Compiler, m_Identifier.TypeCharacter))
         End If
 
         If m_ConstantExpression IsNot Nothing Then result = m_ConstantExpression.ResolveTypeReferences AndAlso result
 
         UpdateDefinition()
 
         If result AndAlso m_TypeName IsNot Nothing Then
             Helper.Assert(m_TypeName IsNot Nothing)
             If Helper.CompareType(m_TypeName.ResolvedType, Compiler.TypeCache.System_Decimal) Then
                 m_RequiresSharedInitialization = True
             ElseIf Helper.CompareType(m_TypeName.ResolvedType, Compiler.TypeCache.System_DateTime) Then
                 m_RequiresSharedInitialization = True
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="117" endline="168"><![CDATA[
 
     Shared Function GetDecimalConstant(ByVal Compiler As Compiler, ByVal Field As Mono.Cecil.FieldDefinition, ByRef value As Decimal) As Boolean
         Dim decAttrs As Mono.Collections.Generic.Collection(Of CustomAttribute)
         decAttrs = CecilHelper.GetCustomAttributes(Field.CustomAttributes, Compiler.TypeCache.System_Runtime_CompilerServices_DecimalConstantAttribute)
         If decAttrs IsNot Nothing AndAlso decAttrs.Count = 1 Then
             Dim attr As Mono.Cecil.CustomAttribute = decAttrs(0)
             Dim scale As Byte, sign As Byte
             Dim hi1 As Integer, mid1 As Integer, low1 As Integer
             Dim isUnsigned As Boolean
 
             If attr.ConstructorArguments.Count <> 5 Then Return False
             If TypeOf attr.ConstructorArguments(0).Value Is Byte = False Then Return False
             If TypeOf attr.ConstructorArguments(1).Value Is Byte = False Then Return False
 
             scale = DirectCast(attr.ConstructorArguments(0).Value, Byte)
             sign = DirectCast(attr.ConstructorArguments(1).Value, Byte)
 
             If TypeOf attr.ConstructorArguments(2).Value Is Integer Then
                 hi1 = DirectCast(attr.ConstructorArguments(2).Value, Integer)
                 isUnsigned = False
             ElseIf TypeOf attr.ConstructorArguments(2).Value Is UInteger Then
                 hi1 = BitConverter.ToInt32(BitConverter.GetBytes(DirectCast(attr.ConstructorArguments(2).Value, UInteger)), 0)
                 isUnsigned = True
             Else
                 Return False
             End If
 
             If TypeOf attr.ConstructorArguments(3).Value Is Integer Then
                 If isUnsigned Then Return False
                 mid1 = DirectCast(attr.ConstructorArguments(3).Value, Integer)
             ElseIf TypeOf attr.ConstructorArguments(3).Value Is UInteger Then
                 If isUnsigned = False Then Return False
                 mid1 = BitConverter.ToInt32(BitConverter.GetBytes(DirectCast(attr.ConstructorArguments(3).Value, UInteger)), 0)
             Else
                 Return False
             End If
 
             If TypeOf attr.ConstructorArguments(4).Value Is Integer Then
                 If isUnsigned Then Return False
                 low1 = DirectCast(attr.ConstructorArguments(4).Value, Integer)
             ElseIf TypeOf attr.ConstructorArguments(4).Value Is UInteger Then
                 If isUnsigned = False Then Return False
                 low1 = BitConverter.ToInt32(BitConverter.GetBytes(DirectCast(attr.ConstructorArguments(4).Value, UInteger)), 0)
             Else
                 Return False
             End If
 
             value = New Decimal(low1, mid1, hi1, sign <> 0, scale)
             Return True
         End If
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="169" endline="178"><![CDATA[
 
     Shared Function GetDateConstant(ByVal Compiler As Compiler, ByVal Field As Mono.Cecil.FieldDefinition, ByRef value As Date) As Boolean
         Dim dtAttrs As Mono.Collections.Generic.Collection(Of CustomAttribute)
         dtAttrs = CecilHelper.GetCustomAttributes(Field.CustomAttributes, Compiler.TypeCache.System_Runtime_CompilerServices_DateTimeConstantAttribute)
         If dtAttrs IsNot Nothing AndAlso dtAttrs.Count = 1 Then
             value = DirectCast(dtAttrs(0).Properties(0).Argument.Value, Date)
             Return True
         End If
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="179" endline="206"><![CDATA[
 
     Function ResolveConstantValue(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ConstantExpression IsNot Nothing)
         If m_ConstantExpression.IsResolved = False Then
             result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
             If m_ConstantExpression.IsConstant Then
                 m_ConstantValue = m_ConstantExpression.ConstantValue
                 Helper.Assert(m_ConstantValue IsNot Nothing)
 
                 If m_TypeName Is Nothing Then
                     m_TypeName = New TypeName(Me, m_ConstantExpression.ExpressionType)
                 Else
                     result = TypeConverter.ConvertTo(m_ConstantExpression, m_ConstantValue, m_TypeName.ResolvedType, m_ConstantValue) AndAlso result
                 End If
                 UpdateDefinition()
                 'If m_ConstantValue IsNot Nothing Then Compiler.Report.WriteLine("Converted to
             Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30059, m_ConstantExpression.Location)
             End If
             m_Resolved = True
         End If
 
         Helper.Assert(m_Resolved)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="207" endline="223"><![CDATA[
 
     Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_TypeName Is Nothing AndAlso Location.File(Compiler).IsOptionStrictOn Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30209, Me.Location) AndAlso result
         End If
 
         If m_ConstantExpression Is Nothing Then
             Helper.AddError(Me, "No constant expression.")
             Return False
         End If
 
         result = ResolveConstantValue(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="224" endline="227"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="228" endline="252"><![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         If m_ConstantValue IsNot Nothing AndAlso m_ConstantValue IsNot DBNull.Value Then
             If Helper.CompareType(CecilHelper.GetType(Compiler, m_ConstantValue), Compiler.TypeCache.System_Decimal) Then
                 Dim value As Decimal = DirectCast(m_ConstantValue, Decimal)
                 Dim ctor As MethodDefinition = Compiler.TypeCache.System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_UInt32_UInt32_UInt32
                 Dim attrib As New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, ctor))
                 Dim params As Object() = New Emitter.DecimalFields(value).AsByte_Byte_UInt32_UInt32_UInt32()
                 For i As Integer = 0 To params.Length - 1
                     attrib.ConstructorArguments.Add(New CustomAttributeArgument(ctor.Parameters(i).ParameterType, params(i)))
                 Next
                 m_FieldBuilderCecil.CustomAttributes.Add(attrib)
             ElseIf Helper.CompareType(CecilHelper.GetType(Compiler, m_ConstantValue), Compiler.TypeCache.System_DateTime) Then
                 Dim attrib As New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor_Int64))
                 attrib.ConstructorArguments.Add(New CustomAttributeArgument(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int64), DirectCast(m_ConstantValue, Date).Ticks))
                 m_FieldBuilderCecil.CustomAttributes.Add(attrib)
             End If
         End If
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="253" endline="280"><![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_FieldBuilderCecil Is Nothing Then
             m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(Name, 0, Nothing)
             m_FieldBuilderCecil.Annotations.Add(Compiler, Me)
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderCecil)
         End If
 
         If m_RequiresSharedInitialization Then
             m_FieldBuilderCecil.Constant = Nothing
         ElseIf m_ConstantValue Is DBNull.Value Then
             m_FieldBuilderCecil.Constant = Nothing
         Else
             m_FieldBuilderCecil.Constant = m_ConstantValue
         End If
         m_FieldBuilderCecil.HasDefault = True
         m_FieldBuilderCecil.HasConstant = Not m_RequiresSharedInitialization
         m_FieldBuilderCecil.Name = Name
         If m_TypeName IsNot Nothing Then
             m_FieldBuilderCecil.FieldType = Helper.GetTypeOrTypeReference(Compiler, m_TypeName.ResolvedType)
         Else
             'Helper.StopIfDebugging()
         End If
         m_FieldBuilderCecil.Attributes = Helper.GetAttributes(Compiler, Me)
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="281" endline="288"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="289" endline="294"><![CDATA[
 
 
     Public ReadOnly Property FieldBuilder() As Mono.Cecil.FieldDefinition Implements IFieldMember.FieldBuilder
         Get
             Return m_FieldBuilderCecil
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="295" endline="301"><![CDATA[
     End Property
 
     Public ReadOnly Property FieldType() As Mono.Cecil.TypeReference Implements IFieldMember.FieldType
         Get
             If m_FieldBuilderCecil Is Nothing Then Return Nothing
             Return m_FieldBuilderCecil.FieldType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="302" endline="307"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property MemberDescriptor() As Mono.Cecil.MemberReference
         Get
             Return m_FieldBuilderCecil
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="308" endline="313"><![CDATA[
     End Property
 
     ReadOnly Property Identifier() As Identifier
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="314" endline="319"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As TypeName
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="320" endline="325"><![CDATA[
     End Property
 
     ReadOnly Property ConstantExpression() As Expression
         Get
             Return m_ConstantExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="326" endline="331"><![CDATA[
     End Property
 
     Public Function ResolveAndGetConstantValue(ByRef value As Object) As Boolean Implements IFieldMember.ResolveAndGetConstantValue
         value = ConstantValue
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclarations.vb" startline="26" endline="28"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclarations.vb" startline="29" endline="32"><![CDATA[
 
     Sub Init(ByVal ConstantDeclarations As ConstantDeclaration())
         m_ConstantDeclarations = ConstantDeclarations
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclarations.vb" startline="33" endline="37"><![CDATA[
 
     ReadOnly Property Declarations() As ConstantDeclaration()
         Get
             Return m_ConstantDeclarations
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="57" endline="59"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="60" endline="63"><![CDATA[
 
     Shadows Sub Init(ByVal Code As CodeBlock)
         MyBase.Init(New Modifiers(), New SubSignature(Me, ConstructorName, New ParameterList(Me)), Code)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="64" endline="75"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature, ByVal Block As CodeBlock)
 
         'If vbnc.Modifiers.IsNothing(Modifiers) = False AndAlso Modifiers.Is(ModifierMasks.Shared) Then
         If Modifiers.Is(ModifierMasks.Shared) OrElse FindTypeParent.IsModule Then
             Signature.Init(New Identifier(Signature, SharedConstructorName, Signature.Location, TypeCharacters.Characters.None), Signature.TypeParameters, Signature.Parameters)
         Else
             Signature.Init(New Identifier(Signature, ConstructorName, Signature.Location, TypeCharacters.Characters.None), Signature.TypeParameters, Signature.Parameters)
         End If
 
         MyBase.Init(Modifiers, Signature, Block)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="76" endline="88"><![CDATA[
 
     Shared Function CreateTypeConstructor(ByVal Parent As TypeDeclaration) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
 
         result.Init(New Modifiers(ModifierMasks.Shared), New SubSignature(result, SharedConstructorName, New ParameterList(result)), New CodeBlock(result))
 
         result.UpdateDefinition()
         If result.ResolveTypeReferences() = False Then
             Helper.ErrorRecoveryNotImplemented(Parent.Location)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="89" endline="104"><![CDATA[
 
     Shared Function CreateDefaultConstructor(ByVal Parent As TypeDeclaration) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
         Dim modifiers As Modifiers
 
         If Parent.Modifiers.Is(ModifierMasks.MustInherit) Then
             modifiers.AddModifier(KS.Protected)
         End If
         result.Init(modifiers, New SubSignature(result, ConstructorName, New ParameterList(result)), New CodeBlock(result))
 
         If result.ResolveTypeReferences() = False Then
             Helper.ErrorRecoveryNotImplemented(Parent.Location)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="105" endline="114"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="115" endline="124"><![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="125" endline="155"><![CDATA[
 
     ReadOnly Property ExplicitCtorCall() As Mono.Cecil.MethodReference
         Get
             Dim firststatement As BaseObject
             Dim cs As CallStatement
             Dim ie As InvocationOrIndexExpression
             Dim ctor As Mono.Cecil.MethodReference
 
             firststatement = Code.FirstStatement
             If firststatement Is Nothing Then Return Nothing
 
             cs = TryCast(firststatement, CallStatement)
             If cs Is Nothing Then Return Nothing
 
             ie = TryCast(cs.Target, InvocationOrIndexExpression)
             If ie Is Nothing Then Return Nothing
             If ie.Expression.Classification.IsMethodGroupClassification = False Then Return Nothing
 
             ctor = ie.Expression.Classification.AsMethodGroupClassification.ResolvedConstructor
             If ctor Is Nothing Then Return Nothing
 
             If Helper.CompareNameOrdinal(ctor.Name, ConstructorDeclaration.ConstructorName) = False Then Return Nothing
 
             If Helper.CompareType(CecilHelper.FindDefinition(ctor.DeclaringType), CecilHelper.FindDefinition(Me.FindTypeParent.BaseType)) Then
                 Return ctor
             ElseIf Helper.CompareType(CecilHelper.FindDefinition(ctor.DeclaringType), CecilHelper.FindDefinition(Me.FindTypeParent.CecilType)) Then
                 Return ctor
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="156" endline="161"><![CDATA[
     End Property
 
     ReadOnly Property HasExplicitCtorCall() As Boolean
         Get
             Return ExplicitCtorCall IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="162" endline="180"><![CDATA[
     End Property
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         If Me.IsShared = False AndAlso Me.HasMethodBody AndAlso Me.HasExplicitCtorCall = False Then
             CreateDefaultCtorCall()
             CreateDefaultCtorCallCecil()
         ElseIf Code IsNot Nothing AndAlso Me.HasExplicitCtorCall Then
             m_BaseCtorCall = Code.FirstStatement
             If m_BaseCtorCall IsNot Nothing Then Code.RemoveStatement(m_BaseCtorCall)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="181" endline="192"><![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         'Helper.SetTypeOrTypeBuilder(Compiler, ParameterTypes)
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="193" endline="211"><![CDATA[
 
     Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If Signature IsNot Nothing AndAlso Signature.Parameters IsNot Nothing Then
             For i As Integer = 0 To Signature.Parameters.Count - 1
                 Signature.Parameters(i).UpdateDefinition()
             Next
         End If
         CecilBuilder.Name = Name
 
         MethodAttributes = Helper.GetAttributes(Me)
         MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL
 
         If DeclaringType IsNot Nothing AndAlso DeclaringType.CecilType IsNot Nothing AndAlso m_Added = False Then
             m_Added = True
             DeclaringType.CecilType.Methods.Add(CecilBuilder)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="212" endline="268"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If CBool(MethodImplAttributes And Mono.Cecil.MethodImplAttributes.Runtime) Then
             Return result
         End If
 
         Helper.Assert(Info Is Nothing)
         Dim parent As IType = Me.FindTypeParent
         Info = New EmitInfo(Me)
 
 #If DEBUG Then
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Nop)
 #End If
 
         Dim ParentType As Mono.Cecil.TypeReference
         ParentType = parent.CecilType
         If TypeOf parent Is StructureDeclaration AndAlso Me.IsShared = False Then
             Emitter.EmitLoadMe(Info, parent.CecilType)
             Emitter.EmitInitObj(Info, parent.CecilType)
         ElseIf m_DefaultBaseConstructor IsNot Nothing Then
             Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = m_DefaultBaseConstructor.Parameters
             Emitter.EmitLoadMe(Info, CecilHelper.FindDefinition(ParentType).BaseType)
             For i As Integer = 0 To params.Count - 1
                 Helper.Assert(params(i).IsOptional)
                 Emitter.EmitLoadValue(Info.Clone(Me, True, False, params(i).ParameterType), params(i).Constant)
             Next
 
             Emitter.EmitCall(Info, m_DefaultBaseConstructor)
         ElseIf m_BaseCtorCall IsNot Nothing Then
             result = m_BaseCtorCall.GenerateCode(Info)
         Else
             Helper.Assert(Me.IsShared)
         End If
 
         Dim exCtorCall As Mono.Cecil.MethodReference = ExplicitCtorCall
         If m_BaseCtorCall Is Nothing OrElse (exCtorCall IsNot Nothing AndAlso Helper.CompareType(exCtorCall.DeclaringType, Me.DeclaringType.CecilType) = False) Then
             result = EmitVariableInitialization(Info) AndAlso result
 
             For Each arhs As AddOrRemoveHandlerStatement In Me.DeclaringType.AddHandlers
                 result = arhs.GenerateCode(Info) AndAlso result
             Next
         End If
 
         If Me.IsShared Then
             result = EmitConstantInitialization(Info) AndAlso result
         End If
 
 #If DEBUG Then
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Nop)
 #End If
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="269" endline="293"><![CDATA[
 
     Private Function EmitVariableInitialization(ByVal Info As EmitInfo) As Boolean
         Dim variables As Generic.List(Of TypeVariableDeclaration)
         Dim parent As TypeDeclaration
         Dim result As Boolean = True
 
         parent = Me.DeclaringType
         variables = parent.Members.GetSpecificMembers(Of TypeVariableDeclaration)()
 
         For Each variable As TypeVariableDeclaration In variables
             If variable.HasInitializer AndAlso variable.IsShared = Me.IsShared Then
                 result = variable.EmitVariableInitializer(Info) AndAlso result
             End If
         Next
 
         For Each variable As LocalVariableDeclaration In parent.StaticVariables
             If variable.HasInitializer AndAlso variable.DeclaringMethod.IsShared = Me.IsShared Then
                 If Me.IsShared = False Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
                 Emitter.EmitNew(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__ctor)
                 Emitter.EmitStoreField(Info, CecilHelper.GetCorrectMember(variable.StaticInitBuilder, variable.StaticInitBuilder.DeclaringType))
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="294" endline="312"><![CDATA[
 
     Private Function EmitConstantInitialization(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim parent As TypeDeclaration
 
         Parent = Me.DeclaringType
 
         For Each variable As ConstantDeclaration In Parent.Members.GetSpecificMembers(Of ConstantDeclaration)()
             If Helper.CompareType(variable.FieldType, Compiler.TypeCache.System_DateTime) Then
                 Emitter.EmitLoadDateValue(Info, DirectCast(variable.ConstantValue, Date))
                 Emitter.EmitStoreField(Info, variable.FieldBuilder)
             ElseIf Helper.CompareType(variable.FieldType, Compiler.TypeCache.System_Decimal) Then
                 Emitter.EmitLoadDecimalValue(Info, DirectCast(variable.ConstantValue, Decimal))
                 Emitter.EmitStoreField(Info, variable.FieldBuilder)
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="313" endline="340"><![CDATA[
 
     Private Sub CreateDefaultCtorCall()
         Dim type As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim classtype As ClassDeclaration = TryCast(type, ClassDeclaration)
         Dim defaultctor As Mono.Cecil.MethodReference
         If classtype IsNot Nothing Then
             defaultctor = classtype.GetBaseDefaultConstructor()
             If defaultctor IsNot Nothing AndAlso Helper.IsPrivate(defaultctor) = False Then
                 If Helper.IsPrivate(defaultctor) OrElse (Helper.IsFriend(defaultctor) AndAlso Not Compiler.Assembly.IsDefinedHere(defaultctor.DeclaringType)) Then
                     Helper.AddError(Me, "Base class does not have an accessible default constructor")
                 Else
                     m_DefaultBaseConstructor = defaultctor
 
 #If DEBUG Then
                     Try
                         For Each param As Mono.Cecil.ParameterDefinition In m_DefaultBaseConstructor.Parameters
                             Helper.Assert(param.IsOptional)
                         Next
                     Catch ex As Exception
                         Helper.Assert(False)
                     End Try
 #End If
                 End If
             Else
                 Helper.AddError(Me, "Base class does not have a default constructor")
             End If
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="341" endline="369"><![CDATA[
 
     Private Sub CreateDefaultCtorCallCecil()
         Dim type As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim classtype As ClassDeclaration = TryCast(type, ClassDeclaration)
         Dim defaultctor As Mono.Cecil.MethodReference
         If classtype IsNot Nothing Then
             defaultctor = classtype.GetBaseDefaultConstructorCecil()
             If defaultctor IsNot Nothing AndAlso Helper.IsPrivate(defaultctor) = False Then
                 If Helper.IsPrivate(defaultctor) OrElse (Helper.IsFamilyOrAssembly(defaultctor) AndAlso defaultctor.DeclaringType.Module.Assembly IsNot Me.Compiler.AssemblyBuilderCecil) Then
                     Helper.AddError(Compiler, Location, "Base class does not have an accessible default constructor")
                 Else
                     m_DefaultBaseConstructorCecil = defaultctor
                     m_DefaultBaseConstructorCecil = Helper.GetMethodOrMethodReference(Compiler, m_DefaultBaseConstructorCecil)
 
 #If DEBUG Then
                     Try
                         For Each param As Mono.Cecil.ParameterDefinition In m_DefaultBaseConstructor.Parameters
                             Helper.Assert(param.IsOptional)
                         Next
                     Catch ex As Exception
                         Helper.Assert(False)
                     End Try
 #End If
                 End If
             Else
                 Helper.AddError(Compiler, Location, "Base class does not have a default constructor")
             End If
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="370" endline="378"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Sub) = False Then Return False
         Return tm.PeekToken(i + 1).Equals(KS.[New])
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="34" endline="36"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="37" endline="56"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal [Operator] As Token, ByVal Operand As Operand, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Block As CodeBlock)
         Dim mySignature As New FunctionSignature(Me)
         Dim parameters As New ParameterList(Me)
 
         parameters.Add(New Parameter(parameters, Operand.Name, Operand.TypeName))
 
         If Modifiers.Is(ModifierMasks.Widening) Then
             mySignature.Init("op_Implicit", Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
         ElseIf Modifiers.Is(ModifierMasks.Narrowing) Then
             mySignature.Init("op_Explicit", Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
         Else
             Helper.AddError(Me)
         End If
 
         m_Operator = [Operator]
         m_Operand = Operand
 
         MyBase.Init(Modifiers, mySignature, Block)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="57" endline="66"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Operand.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="67" endline="74"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="75" endline="78"><![CDATA[
 
     Shared Function IsOverloadableConversionOperator(ByVal token As Token) As Boolean
         Return token = KS.CType
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="79" endline="87"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         Return IsOverloadableConversionOperator(tm.PeekToken(i + 1))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="88" endline="92"><![CDATA[
 
     ReadOnly Property Operand() As Operand
         Get
             Return m_operand
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="33" endline="35"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="36" endline="40"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal TypeName As NonArrayTypeName, ByVal ImplementsClause As MemberImplementsClause)
         MyBase.Init(Modifiers, Identifier, ImplementsClause)
         m_Type = TypeName
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="41" endline="48"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals("Custom") AndAlso tm.PeekToken(i + 1).Equals(KS.Event)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="49" endline="53"><![CDATA[
 
     ReadOnly Property Type() As NonArrayTypeName
         Get
             Return m_Type
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="54" endline="67"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Type IsNot Nothing Then
             result = m_Type.ResolveTypeReferences AndAlso result
             EventType = m_Type.ResolvedType
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="46" endline="48"><![CDATA[
     Sub New(ByVal Parent As EventDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="49" endline="53"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal ParameterList As ParameterList, ByVal Block As CodeBlock, ByVal HandlerType As KS, ByVal EventName As Identifier)
         MyBase.Init(Modifiers, HandlerType, EventName, ParameterList, Block)
         MyBase.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="54" endline="61"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="62" endline="65"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(KS.AddHandler, KS.RemoveHandler, KS.RaiseEvent)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="66" endline="88"><![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         'Dim m_MethodAttributes As MethodAttributes
         'If m_HandlerType = KS.RaiseEvent Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Private
         'Else
         '    m_MethodAttributes = m_MethodAttributes Or Me.Modifiers.GetMethodAttributeScope
         'End If
         'm_MethodAttributes = m_MethodAttributes Or MethodAttributes.SpecialName
         'If DeclaringType.IsInterface Then
         '    m_MethodAttributes = m_MethodAttributes Or Reflection.MethodAttributes.Abstract Or Reflection.MethodAttributes.Virtual Or MethodAttributes.CheckAccessOnOverride Or MethodAttributes.NewSlot
         'End If
         'If Me.IsShared Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Static
         'End If
         'MyBase.Attributes = m_MethodAttributes
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="42" endline="45"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="46" endline="53"><![CDATA[
 
     Shadows Sub Init(ByVal EnumIndex As Integer, ByVal Identifier As Identifier, ByVal ConstantExpression As Expression)
         MyBase.Init(Nothing, Identifier.Identifier)
         m_EnumIndex = EnumIndex
         m_Identifier = Identifier
         m_ConstantExpression = ConstantExpression
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="54" endline="62"><![CDATA[
 
     Public Property ConstantValue() As Object
         Get
             If m_ResolvedMember = False Then
                 'Helper.StopIfDebugging()
                 ResolveMember(ResolveInfo.Default(Compiler))
             End If
             Return m_FieldBuilderCecil.Constant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="63" endline="65"><![CDATA[
         Set(ByVal value As Object)
             m_FieldBuilderCecil.Constant = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="66" endline="79"><![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_FieldBuilderCecil Is Nothing Then
             m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(Name, Mono.Cecil.FieldAttributes.Public Or Mono.Cecil.FieldAttributes.Static Or Mono.Cecil.FieldAttributes.Literal Or Mono.Cecil.FieldAttributes.HasDefault, Parent.CecilType)
             m_FieldBuilderCecil.Annotations.Add(Compiler, Me)
             Parent.CecilType.Fields.Add(m_FieldBuilderCecil)
         End If
 
         m_FieldBuilderCecil.Name = Name
         m_FieldBuilderCecil.IsLiteral = True
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="80" endline="84"><![CDATA[
 
     ReadOnly Property EnumIndex() As Integer
         Get
             Return m_EnumIndex
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="85" endline="90"><![CDATA[
     End Property
 
     Public ReadOnly Property FieldBuilder() As Mono.Cecil.FieldDefinition Implements IFieldMember.FieldBuilder
         Get
             Return m_FieldBuilderCecil
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="91" endline="96"><![CDATA[
     End Property
 
     Public ReadOnly Property FieldType() As Mono.Cecil.TypeReference Implements IFieldMember.FieldType
         Get
             Return Me.FindFirstParent(Of EnumDeclaration).EnumConstantType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="97" endline="102"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property MemberDescriptor() As Mono.Cecil.MemberReference
         Get
             Return m_FieldBuilderCecil
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="103" endline="108"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsShared() As Boolean
         Get
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="109" endline="114"><![CDATA[
     End Property
 
     ReadOnly Property Identifier() As Identifier
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="115" endline="120"><![CDATA[
     End Property
 
     ReadOnly Property ConstantExpression() As Expression
         Get
             Return m_ConstantExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="121" endline="130"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         result = Helper.ResolveTypeReferences(m_ConstantExpression) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="131" endline="175"><![CDATA[
 
     Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_ResolvedMember Then Return True
         m_ResolvedMember = True
 
         Dim obj As Object
         If m_ConstantExpression IsNot Nothing Then
             result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
             obj = m_ConstantExpression.ConstantValue
         Else
             If m_EnumIndex = 0 Then
                 obj = 0
             Else
                 obj = CDec(Parent.Constants(m_EnumIndex - 1).ConstantValue) + 1
             End If
         End If
 
         Select Case Parent.EnumConstantTypeKeyword
             Case KS.Byte
                 obj = CByte(obj)
             Case KS.SByte
                 obj = CSByte(obj)
             Case KS.Short
                 obj = CShort(obj)
             Case KS.UShort
                 obj = CUShort(obj)
             Case KS.Integer
                 obj = CInt(obj)
             Case KS.UInteger
                 obj = CUInt(obj)
             Case KS.Long
                 obj = CLng(obj)
             Case KS.ULong
                 obj = CULng(obj)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         ConstantValue = obj
         result = ConstantValue IsNot Nothing AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="176" endline="184"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_ConstantExpression IsNot Nothing Then result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="185" endline="189"><![CDATA[
 
     Shadows ReadOnly Property Parent() As EnumDeclaration
         Get
             Return Me.FindFirstParent(Of EnumDeclaration)()
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="190" endline="201"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Define the enum constant.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="202" endline="209"><![CDATA[
 
     Public Function ResolveAndGetConstantValue(ByRef value As Object) As Boolean Implements IFieldMember.ResolveAndGetConstantValue
         If m_ResolvedMember = False Then
             If ResolveMember(ResolveInfo.Default(Compiler)) = False Then Return False
         End If
         value = ConstantValue
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     Private m_Handlers(2) As CustomEventHandlerDeclaration
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="32" endline="37"><![CDATA[
 
     Sub Init(ByVal [AddHandler] As CustomEventHandlerDeclaration, ByVal [RemoveHandler] As CustomEventHandlerDeclaration, ByVal [RaiseEvent] As CustomEventHandlerDeclaration)
         Me.AddHandler = [AddHandler]
         Me.RemoveHandler = [RemoveHandler]
         Me.RaiseEvent = [RaiseEvent]
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="38" endline="42"><![CDATA[
 
     ReadOnly Property Handlers() As CustomEventHandlerDeclaration()
         Get
             Return m_Handlers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="43" endline="48"><![CDATA[
     End Property
 
     Property [AddHandler]() As CustomEventHandlerDeclaration
         Get
             Return m_Handlers(0)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="49" endline="54"><![CDATA[
         Private Set(ByVal value As CustomEventHandlerDeclaration)
             If m_Handlers(0) IsNot Nothing Then
                 Helper.AddError(Me)
             End If
             m_Handlers(0) = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="55" endline="60"><![CDATA[
     End Property
 
     Property [RemoveHandler]() As CustomEventHandlerDeclaration
         Get
             Return m_Handlers(1)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="61" endline="66"><![CDATA[
         Private Set(ByVal value As CustomEventHandlerDeclaration)
             If m_Handlers(1) IsNot Nothing Then
                 Helper.AddError(Me)
             End If
             m_Handlers(1) = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="67" endline="72"><![CDATA[
     End Property
 
     Property [RaiseEvent]() As CustomEventHandlerDeclaration
         Get
             Return m_Handlers(2)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="73" endline="78"><![CDATA[
         Private Set(ByVal value As CustomEventHandlerDeclaration)
             If m_Handlers(2) IsNot Nothing Then
                 Helper.AddError(Me)
             End If
             m_Handlers(2) = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="79" endline="83"><![CDATA[
     End Property
 
     Public Function DefineMembers() As Boolean
         Return Helper.DefineMembersCollection(m_Handlers)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="84" endline="87"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return Helper.GenerateCodeCollection(m_Handlers, Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="88" endline="95"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_Handlers.Length - 1
             result = m_Handlers(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="40" endline="42"><![CDATA[
         Get
             Return m_CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="43" endline="48"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.new(Parent)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="49" endline="58"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal ImplementsClause As MemberImplementsClause)
         MyBase.Init(Modifiers, Identifier.Name)
 
         m_Identifier = Identifier
         m_ImplementsClause = ImplementsClause
 
         Helper.Assert(m_Identifier IsNot Nothing)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="59" endline="63"><![CDATA[
 
     Public ReadOnly Property EventDescriptor() As Mono.Cecil.EventDefinition
         Get
             Return m_CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="64" endline="69"><![CDATA[
     End Property
 
     Public Property EventType() As Mono.Cecil.TypeReference
         Get
             Return m_CecilBuilder.EventType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="70" endline="72"><![CDATA[
         Set(ByVal value As Mono.Cecil.TypeReference)
             CecilBuilder.EventType = Helper.GetTypeOrTypeReference(Compiler, value)
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="73" endline="82"><![CDATA[
     End Property
 
     ReadOnly Property AddDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_AddMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_AddMethod.CecilBuilder
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="83" endline="92"><![CDATA[
     End Property
 
     ReadOnly Property RemoveDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RemoveMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RemoveMethod.CecilBuilder
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="93" endline="102"><![CDATA[
     End Property
 
     ReadOnly Property RaiseDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RaiseMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RaiseMethod.CecilBuilder
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="103" endline="108"><![CDATA[
     End Property
 
     Property AddMethod() As EventHandlerDeclaration
         Get
             Return m_AddMethod
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="109" endline="113"><![CDATA[
         Set(ByVal value As EventHandlerDeclaration)
             Helper.Assert(m_AddMethod Is Nothing)
             m_AddMethod = value
             UpdateDefinition()
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="114" endline="119"><![CDATA[
     End Property
 
     Property RemoveMethod() As EventHandlerDeclaration
         Get
             Return m_RemoveMethod
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="120" endline="124"><![CDATA[
         Set(ByVal value As EventHandlerDeclaration)
             Helper.Assert(m_RemoveMethod Is Nothing)
             m_RemoveMethod = value
             UpdateDefinition()
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="125" endline="130"><![CDATA[
     End Property
 
     Property RaiseMethod() As EventHandlerDeclaration
         Get
             Return m_RaiseMethod
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="131" endline="135"><![CDATA[
         Set(ByVal value As EventHandlerDeclaration)
             Helper.Assert(m_RaiseMethod Is Nothing)
             m_RaiseMethod = value
             UpdateDefinition()
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="136" endline="141"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property MemberDescriptor() As Mono.Cecil.MemberReference
         Get
             Return m_CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="142" endline="147"><![CDATA[
     End Property
 
     ReadOnly Property Identifier() As Identifier
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="148" endline="153"><![CDATA[
     End Property
 
     ReadOnly Property ImplementsClause() As MemberImplementsClause
         Get
             Return m_ImplementsClause
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="154" endline="169"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then result = m_ImplementsClause.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_AddMethod IsNot Nothing Then result = m_AddMethod.ResolveTypeReferences AndAlso result
         If m_RemoveMethod IsNot Nothing Then result = m_RemoveMethod.ResolveTypeReferences AndAlso result
         If m_RaiseMethod IsNot Nothing Then result = m_RaiseMethod.ResolveTypeReferences AndAlso result
 
         Helper.Assert(EventType IsNot Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="170" endline="177"><![CDATA[
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="178" endline="187"><![CDATA[
 
     Public Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then result = m_ImplementsClause.ResolveCode(Info) AndAlso result
 
         Helper.Assert(EventType IsNot Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="188" endline="195"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="196" endline="203"><![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="204" endline="213"><![CDATA[
 
     Function DefineOverrides() As Boolean
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then
             result = m_ImplementsClause.DefineImplements(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="214" endline="234"><![CDATA[
 
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_AddMethod.CecilBuilder IsNot Nothing)
         Helper.Assert(m_RemoveMethod.CecilBuilder IsNot Nothing)
 
         'm_Builder.SetAddOnMethod(m_AddMethod.MethodBuilder)
         'm_Builder.SetRemoveOnMethod(m_RemoveMethod.MethodBuilder)
         'If m_RaiseMethod IsNot Nothing Then m_Builder.SetRaiseMethod(m_RaiseMethod.MethodBuilder)
 
         result = DefineOverrides() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         m_CecilBuilder.AddMethod = m_AddMethod.CecilBuilder
         m_CecilBuilder.RemoveMethod = m_RemoveMethod.CecilBuilder
         If m_RaiseMethod IsNot Nothing Then m_CecilBuilder.InvokeMethod = m_RaiseMethod.CecilBuilder
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="235" endline="269"><![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_CecilBuilder Is Nothing Then
             m_CecilBuilder = New Mono.Cecil.EventDefinition(Name, 0, Nothing)
             m_CecilBuilder.Annotations.Add(Compiler, Me)
             FindFirstParent(Of TypeDeclaration).CecilType.Events.Add(m_CecilBuilder)
         End If
         m_CecilBuilder.Name = Name
 
         Dim members As MemberDeclarations = DeclaringType.Members
         Dim methods As Mono.Collections.Generic.Collection(Of MethodDefinition) = DeclaringType.CecilType.Methods
 
         If m_AddMethod IsNot Nothing Then
             m_AddMethod.UpdateDefinition()
             If members IsNot Nothing AndAlso members.Contains(m_AddMethod) = False Then members.Add(m_AddMethod)
             If methods.Contains(m_AddMethod.CecilBuilder) = False Then methods.Add(m_AddMethod.CecilBuilder)
             m_CecilBuilder.AddMethod = m_AddMethod.CecilBuilder
         End If
 
         If m_RemoveMethod IsNot Nothing Then
             m_RemoveMethod.UpdateDefinition()
             If members IsNot Nothing AndAlso members.Contains(m_RemoveMethod) = False Then members.Add(m_RemoveMethod)
             If methods.Contains(m_RemoveMethod.CecilBuilder) = False Then methods.Add(m_RemoveMethod.CecilBuilder)
             m_CecilBuilder.RemoveMethod = m_RemoveMethod.CecilBuilder
         End If
         If m_RaiseMethod IsNot Nothing Then
             m_RaiseMethod.UpdateDefinition()
             If members IsNot Nothing AndAlso members.Contains(m_RaiseMethod) = False Then members.Add(m_RaiseMethod)
             If methods.Contains(m_RaiseMethod.CecilBuilder) = False Then methods.Add(m_RaiseMethod.CecilBuilder)
             m_CecilBuilder.InvokeMethod = m_RaiseMethod.CecilBuilder
         End If
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlerDeclaration.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As EventDeclaration)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlerDeclaration.vb" startline="32" endline="58"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal HandlerType As KS, ByVal EventName As Identifier, ByVal Parameters As ParameterList, ByVal Code As CodeBlock)
 
         m_HandlerType = HandlerType
 
         Dim prefix As String
         Dim name As String
         Select Case m_HandlerType
             Case KS.AddHandler
                 prefix = "add_"
             Case KS.RemoveHandler
                 prefix = "remove_"
             Case KS.RaiseEvent
                 prefix = "raise_"
             Case Else
                 Throw New InternalException(Me)
         End Select
         name = prefix & EventName.Name
 
         Dim mySignature As SubSignature
 
         mySignature = New SubSignature(Me)
         mySignature.Init(New Identifier(mySignature, name, EventName.Location, EventName.TypeCharacter), Nothing, Parameters)
 
         MyBase.Init(Modifiers, mySignature, Code)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlerDeclaration.vb" startline="59" endline="67"><![CDATA[
 
     ''' <summary>
     ''' The type of this handler (AddHandler, RemoveHandler or RaiseEvent)
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property HandlerType() As KS
         Get
             Return m_HandlerType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlerDeclaration.vb" startline="68" endline="79"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The event declaration for this event handler.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property EventParent() As EventDeclaration
         Get
             Return DirectCast(MyBase.Parent, EventDeclaration)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="27" endline="29"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="30" endline="39"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each Item As EventMemberSpecifier In Me
             result = Item.ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="38" endline="40"><![CDATA[
         Get
             Return m_First
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     ReadOnly Property Second() As IdentifierOrKeyword
         Get
             Return m_second
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="47" endline="51"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="52" endline="60"><![CDATA[
 
     Sub Init(ByVal First As Expression, ByVal Second As IdentifierOrKeyword)
         m_First = First
         m_Second = Second
 
         m_Expression = New MemberAccessExpression(Me)
         m_Expression.Init(m_First, m_Second)
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="61" endline="124"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim eventInfo As ResolveInfo = ResolveInfo.Default(Compiler)
         eventInfo.IsEventResolution = True
 
         result = m_Expression.ResolveExpression(eventInfo) AndAlso result
 
         If result = False Then Return False
 
         If m_Expression.Classification.IsEventAccessClassification = False Then
             Return Compiler.Report.ShowMessage(Messages.VBNC30590, Me.Location, m_Second.Name)
         End If
 
         'Helper.NotImplementedYet("Variable must have WithEvents")
 
         Dim declaringType As TypeDeclaration
         Dim handler As MethodDeclaration
 
         declaringType = Me.FindFirstParent(Of TypeDeclaration)()
         handler = Me.FindFirstParent(Of MethodDeclaration)()
 
         Helper.Assert(declaringType IsNot Nothing)
 
         If TypeOf m_First Is MeExpression OrElse TypeOf m_First Is MyBaseExpression Then
             'add AddHandler to all constructors
 
             Dim arhs As New AddOrRemoveHandlerStatement(Me)
             arhs.Init(m_Expression, handler, True, m_First)
 
             declaringType.AddHandlers.Add(arhs)
 
         Else
             'add AddHandler/RemoveHandler to withevents variable's property
             Dim sne As SimpleNameExpression
             sne = TryCast(m_First, SimpleNameExpression)
             'Console.WriteLine(Me.Location.ToString(Compiler))
             Helper.Assert(sne IsNot Nothing)
             Dim propD As Mono.Cecil.PropertyDefinition 'PropertyDescriptor
             Dim propDecl As PropertyDeclaration
 
             If Not sne.Classification.IsPropertyGroupClassification Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC30506, Me.Location)
             End If
             Helper.Assert(sne.Classification.AsPropertyGroup.IsResolved)
             Helper.Assert(sne.Classification.AsPropertyGroup.ResolvedProperty IsNot Nothing)
 
             propD = CecilHelper.FindDefinition(sne.Classification.AsPropertyGroup.ResolvedProperty)
             propDecl = DirectCast(propD.Annotations(Compiler), PropertyDeclaration)
             Helper.Assert(propD IsNot Nothing)
 
             Dim arhs As New AddOrRemoveHandlerStatement(Me)
             Dim instanceExp As MeExpression = Nothing
             If Helper.IsShared(propD) = False Then
                 instanceExp = New MeExpression(Me)
                 result = instanceExp.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
             End If
 
             arhs.Init(m_Expression, handler, True, instanceExp)
             propDecl.Handlers.Add(arhs)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="125" endline="132"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="32" endline="34"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="35" endline="42"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal Identifier As Identifier, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName)
 
         Dim mySignature As New FunctionSignature(Me)
         mySignature.Init(Identifier, Nothing, ParameterList, ReturnTypeAttributes, TypeName, Me.Location)
 
         MyBase.Init(Modifiers, CharsetModifier, LibraryClause, AliasClause, mySignature)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="43" endline="52"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Function
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="53" endline="57"><![CDATA[
 
     Shadows ReadOnly Property Signature() As FunctionSignature
         Get
             Return DirectCast(MyBase.Signature, FunctionSignature)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="58" endline="67"><![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="34" endline="36"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="37" endline="45"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal Identifier As Identifier, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal ParameterList As ParameterList)
         MyBase.Init(Modifiers, New SubSignature(Me, Identifier.Name, ParameterList), Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="46" endline="54"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal Signature As SubSignature)
         MyBase.Init(Modifiers, Signature, Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="55" endline="59"><![CDATA[
 
     Public Overrides ReadOnly Property IsShared() As Boolean
         Get
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="60" endline="65"><![CDATA[
     End Property
 
     ReadOnly Property CharsetModifier() As KS
         Get
             Return m_Charsetmodifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="66" endline="71"><![CDATA[
     End Property
 
     ReadOnly Property Identifier() As Identifier
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="72" endline="77"><![CDATA[
     End Property
 
     ReadOnly Property LibraryClause() As libraryclause
         Get
             Return m_LibraryClause
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="78" endline="83"><![CDATA[
     End Property
 
     ReadOnly Property AliasClause() As AliasClause
         Get
             Return m_aliasclause
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="84" endline="94"><![CDATA[
     End Property
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Sub AndAlso tm.PeekToken(i + 2).IsIdentifier
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="95" endline="133"><![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Dim attrib As New Attribute(Me)
         attrib.ResolvedType = Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute
         attrib.AttributeArguments.PositionalArgumentList.Add(m_LibraryClause.StringLiteral.StringLiteral)
         If m_AliasClause IsNot Nothing Then
             attrib.AttributeArguments.VariablePropertyInitializerList.Add("EntryPoint", m_AliasClause.StringLiteral.LiteralValue)
         Else
             attrib.AttributeArguments.VariablePropertyInitializerList.Add("EntryPoint", Name)
         End If
         attrib.AttributeArguments.VariablePropertyInitializerList.Add("SetLastError", True)
         attrib.AttributeArguments.VariablePropertyInitializerList.Add("PreserveSig", True)
         Select Case m_CharsetModifier
             Case KS.Auto
                 attrib.AttributeArguments.VariablePropertyInitializerList.Add("CharSet", System.Runtime.InteropServices.CharSet.Auto)
             Case KS.Unicode
                 attrib.AttributeArguments.VariablePropertyInitializerList.Add("CharSet", System.Runtime.InteropServices.CharSet.Unicode)
             Case KS.Ansi, KS.None
                 attrib.AttributeArguments.VariablePropertyInitializerList.Add("CharSet", System.Runtime.InteropServices.CharSet.Ansi)
             Case Else
                 Throw New InternalException
         End Select
         Me.CustomAttributes.Add(attrib)
 
         For i As Integer = 0 To Signature.Parameters.Count - 1
             If Helper.CompareType(Signature.Parameters(i).ParameterType, Compiler.TypeCache.System_String) AndAlso Signature.Parameters(i).CustomAttributes.Count = 0 Then
                 Signature.Parameters(i).ParameterType = New ByReferenceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_String))
                 Signature.Parameters(i).CecilBuilder.MarshalInfo = New Mono.Cecil.MarshalInfo(Mono.Cecil.NativeType.ByValStr)
                 Signature.Parameters(i).CecilBuilder.Attributes = Signature.Parameters(i).CecilBuilder.Attributes Or Mono.Cecil.ParameterAttributes.HasFieldMarshal
             End If
         Next
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="36" endline="38"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="39" endline="44"><![CDATA[
 
     Sub New(ByVal Parent As TypeDeclaration, ByVal Name As String, ByVal MethodAttributes As Mono.Cecil.MethodAttributes, ByVal ParameterTypes As Mono.Cecil.TypeReference(), ByVal ReturnType As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), New FunctionSignature(Me, Name, New ParameterList(Me, ParameterTypes), ReturnType, Location), CType(Nothing, MemberImplementsClause), Nothing)
         MyBase.MethodAttributes = MethodAttributes
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="45" endline="52"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Function
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="53" endline="57"><![CDATA[
 
     Shadows ReadOnly Property Signature() As FunctionSignature
         Get
             Return DirectCast(MyBase.Signature, FunctionSignature)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="58" endline="67"><![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="33" endline="35"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="36" endline="41"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As ParameterList, ByVal ReturnType As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.New(Parent, Name, Parameters)
         m_ReturnType = ReturnType
         MyBase.Location = Location
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="42" endline="47"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As ParameterList, ByVal ReturnType As TypeName, ByVal Location As Span)
         MyBase.New(Parent, Name, Parameters)
         m_TypeName = ReturnType
         MyBase.Location = Location
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="48" endline="55"><![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_ReturnType = TypeName
         MyBase.Location = Location
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="56" endline="63"><![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="64" endline="71"><![CDATA[
 
     Shadows Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="72" endline="87"><![CDATA[
 
     ''' <summary>
     ''' The returned object will always be a function signature.
     ''' </summary>
     ''' <param name="NewParent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SubSignature
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New FunctionSignature(NewParent)
         MyBase.CloneTo(result)
         If m_ReturnTypeAttributes IsNot Nothing Then result.m_ReturnTypeAttributes = m_ReturnTypeAttributes.clone(result)
         result.m_ReturnType = m_ReturnType
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="88" endline="92"><![CDATA[
 
     ReadOnly Property ReturnTypeAttributes() As Attributes
         Get
             Return m_ReturnTypeAttributes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="93" endline="98"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As TypeName
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="99" endline="105"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ReturnType() As Mono.Cecil.TypeReference
         Get
             'Helper.Assert(m_ReturnType IsNot Nothing)
             Return m_ReturnType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="106" endline="140"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences(ByVal ResolveTypeParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences(ResolveTypeParameters) AndAlso result
         If m_ReturnTypeAttributes IsNot Nothing Then result = m_ReturnTypeAttributes.ResolveTypeReferences AndAlso result
 
         If m_ReturnType Is Nothing Then
             If m_TypeName IsNot Nothing Then
                 result = m_TypeName.ResolveTypeReferences AndAlso result
                 If result = False Then Return result
                 m_ReturnType = m_TypeName.ResolvedType
             ElseIf Identifier.HasTypeCharacter Then
                 m_ReturnType = TypeCharacters.TypeCharacterToType(Compiler, Identifier.TypeCharacter)
             Else
                 If Me.Location.File(Compiler).IsOptionStrictOn Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30210, Me.Location) AndAlso result
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC42024, Me.Location) AndAlso result
                 End If
                 m_ReturnType = Compiler.TypeCache.System_Object
             End If
 
             If result AndAlso m_ReturnType.GenericParameters.Count > 0 Then
                 Dim tmp As New Mono.Cecil.GenericInstanceType(m_ReturnType)
                 For i As Integer = 0 To m_ReturnType.GenericParameters.Count - 1
                     tmp.GenericArguments.Add(m_ReturnType.GenericParameters(i))
                 Next
                 m_ReturnType = tmp
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="141" endline="151"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         result = MyBase.ResolveCode(info) AndAlso result
 
         Helper.Assert(m_ReturnType IsNot Nothing OrElse Compiler.Report.Errors > 0)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="31" endline="33"><![CDATA[
         Get
             Return m_list
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="34" endline="38"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="39" endline="42"><![CDATA[
 
     Sub Init(ByVal List As EventHandlesList)
         m_List = List
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="43" endline="46"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_List.ResolveCode(info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="47" endline="54"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_List.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="55" endline="58"><![CDATA[
   
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.Handles
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="31" endline="33"><![CDATA[
         Get
             Return m_clause
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="34" endline="38"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="39" endline="44"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ImplementsClause As MemberImplementsClause)
         MyBase.new(Parent)
         m_Clause = ImplementsClause
         Helper.Assert(m_Clause IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="45" endline="50"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal HandlesClause As HandlesClause)
         MyBase.new(Parent)
         m_Clause = HandlesClause
         Helper.Assert(m_Clause IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="51" endline="55"><![CDATA[
 
     Sub Init(ByVal ImplementsClause As MemberImplementsClause)
         m_Clause = ImplementsClause
         Helper.Assert(m_Clause IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="56" endline="60"><![CDATA[
 
     Sub Init(ByVal HandlesClause As HandlesClause)
         m_Clause = HandlesClause
         Helper.Assert(m_Clause IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="61" endline="72"><![CDATA[
 
     ''' <summary>
     ''' Returns nothing if it is not a handles clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property HandlesClause() As HandlesClause
         Get
             Helper.Assert(m_Clause IsNot Nothing)
             Return TryCast(m_Clause, HandlesClause)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="73" endline="85"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if it is not an implements clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ImplementsClause() As MemberImplementsClause
         Get
             helper.Assert(m_clause IsNot Nothing)
             Return TryCast(m_Clause, MemberImplementsClause)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="86" endline="91"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Helper.Assert(m_Clause IsNot Nothing)
         Return m_Clause.ResolveCode(info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="92" endline="95"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return HandlesClause.IsMe(tm) OrElse vbnc.MemberImplementsClause.IsMe(tm)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="96" endline="110"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If HandlesClause IsNot Nothing Then
             result = HandlesClause.ResolveTypeReferences AndAlso result
         ElseIf ImplementsClause IsNot Nothing Then
             result = ImplementsClause.ResolveTypeReferences AndAlso result
         Else
             Helper.Stop()
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="32" endline="34"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="35" endline="38"><![CDATA[
 
     Sub Init(ByVal Bases As NonArrayTypeName())
         m_Bases = Bases
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="39" endline="43"><![CDATA[
 
     ReadOnly Property Bases() As NonArrayTypeName()
         Get
             Return m_Bases
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="44" endline="53"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Bases IsNot Nothing)
         result = Helper.ResolveTypeReferencesCollection(m_Bases)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="54" endline="57"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.Inherits
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceEventMemberDeclaration.vb" startline="28" endline="30"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceEventMemberDeclaration.vb" startline="31" endline="38"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceFunctionDeclaration.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceFunctionDeclaration.vb" startline="32" endline="35"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As FunctionSignature)
         MyBase.Init(Modifiers, Signature, Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceFunctionDeclaration.vb" startline="36" endline="43"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Function)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="41" endline="43"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="44" endline="48"><![CDATA[
 
     Sub Init(ByVal First As NonArrayTypeName, ByVal Second As IdentifierOrKeyword)
         m_1 = First
         m_2 = Second
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="49" endline="53"><![CDATA[
 
     ReadOnly Property ResolvedMethod() As Mono.Cecil.MemberReference
         Get
             Return m_ResolvedMember
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="54" endline="59"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedEventInfo() As Mono.Cecil.EventReference
         Get
             Return TryCast(m_ResolvedMember, Mono.Cecil.EventReference)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="60" endline="65"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedMethodInfo() As Mono.Cecil.MethodReference
         Get
             Return TryCast(m_ResolvedMember, Mono.Cecil.MethodReference)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="66" endline="71"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedPropertyInfo() As Mono.Cecil.PropertyReference
         Get
             Return TryCast(m_ResolvedMember, Mono.Cecil.PropertyReference)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="72" endline="77"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedType() As Mono.Cecil.TypeReference
         Get
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="78" endline="83"><![CDATA[
     End Property
 
     ReadOnly Property First() As NonArrayTypeName
         Get
             Return m_1
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="84" endline="89"><![CDATA[
     End Property
 
     ReadOnly Property Second() As IdentifierOrKeyword
         Get
             Return m_2
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="90" endline="107"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lst As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
         lst = Compiler.TypeManager.GetCache(m_ResolvedType).LookupFlattenedMembers(m_2.Name)
         'If lst.Count = 0 AndAlso m_ResolvedType.IsInterface Then
         '    lst.AddRange(Compiler.TypeManager.GetCache(m_ResolvedType).LookupMembersFlattened(m_2.Name))
         'End If
         m_ResolvedMember = MethodGroupClassification.ResolveInterfaceGroup(lst, Me.FindFirstParent(Of IMember))
         If m_ResolvedMember Is Nothing Then
             Helper.AddError(Me, "Implemented method has not the same signature as the interface method")
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="118" endline="127"><![CDATA[
 
 
     Public Function ResolveEarly() As Boolean
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
         result = ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfacePropertyMemberDeclaration.vb" startline="30" endline="32"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfacePropertyMemberDeclaration.vb" startline="33" endline="40"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceSubDeclaration.vb" startline="28" endline="30"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceSubDeclaration.vb" startline="31" endline="38"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Sub)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LibraryClause.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LibraryClause.vb" startline="32" endline="36"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal StringLiteral As Token)
         MyBase.New(Parent)
         m_StringLiteral = StringLiteral
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LibraryClause.vb" startline="37" endline="40"><![CDATA[
 
     Sub Init(ByVal StringLiteral As Token)
         m_StringLiteral = StringLiteral
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LibraryClause.vb" startline="41" endline="44"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.Lib
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LibraryClause.vb" startline="45" endline="49"><![CDATA[
 
     ReadOnly Property StringLiteral() As Token
         Get
             Return m_StringLiteral
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="35" endline="37"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="38" endline="42"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Modifiers, VariableIdentifier, IsNew, TypeName, VariableInitializer, ArgumentList)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="43" endline="47"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Modifiers, VariableIdentifier, IsNew, TypeName, VariableInitializer, ArgumentList)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="48" endline="52"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Identifier, IsNew, TypeName, VariableInitializer, ArgumentList)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="53" endline="56"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As Mono.Cecil.TypeReference)
         MyBase.Init(Modifiers, Name, VariableType)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="57" endline="75"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If IsStatic Then
             If m_FieldBuilderStaticInit Is Nothing AndAlso HasInitializer Then
                 Dim staticName As String
                 Dim attr As Mono.Cecil.FieldAttributes = Mono.Cecil.FieldAttributes.Private
 
                 staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name & "$Init"
                 If DeclaringMethod.IsShared Then attr = attr Or Mono.Cecil.FieldAttributes.Static
 
                 m_FieldBuilderStaticInit = New Mono.Cecil.FieldDefinition(staticName, attr, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag))
                 DeclaringType.CecilType.Fields.Add(m_FieldBuilderStaticInit)
             End If
         Else
             'TODO
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="76" endline="94"><![CDATA[
 
     Private Function DefineField() As Boolean
         Dim result As Boolean = True
 
         'result = MyBase.Define AndAlso result
 
         If IsStatic AndAlso m_FieldBuilderStatic Is Nothing Then
             Dim staticName As String
             Dim attr As Mono.Cecil.FieldAttributes = Mono.Cecil.FieldAttributes.Private
 
             staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name
             If DeclaringMethod.IsShared Then attr = attr Or Mono.Cecil.FieldAttributes.Static
 
             m_FieldBuilderStatic = New Mono.Cecil.FieldDefinition(staticName, attr, Helper.GetTypeOrTypeReference(Compiler, Me.VariableType))
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderStatic)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="95" endline="99"><![CDATA[
 
     ReadOnly Property IsStatic() As Boolean
         Get
             Return Modifiers.Is(ModifierMasks.Static)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="100" endline="105"><![CDATA[
     End Property
 
     ReadOnly Property LocalBuilder() As Mono.Cecil.Cil.VariableDefinition
         Get
             Return m_LocalBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="106" endline="111"><![CDATA[
     End Property
 
     ReadOnly Property StaticInitBuilder() As Mono.Cecil.FieldDefinition
         Get
             Return m_FieldBuilderStaticInit
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="112" endline="117"><![CDATA[
     End Property
 
     ReadOnly Property FieldBuilder() As Mono.Cecil.FieldDefinition
         Get
             Return m_FieldBuilderStatic
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="118" endline="123"><![CDATA[
     End Property
 
     ReadOnly Property IsLocalVariable() As Boolean
         Get
             Return Me.Modifiers.Is(ModifierMasks.Static) = False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="124" endline="129"><![CDATA[
     End Property
 
     ReadOnly Property IsStaticVariable() As Boolean
         Get
             Return Me.Modifiers.Is(ModifierMasks.Static)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="130" endline="144"><![CDATA[
     End Property
 
     Friend Function DefineLocalVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.IsStaticVariable Then Return result
 
         Helper.Assert(IsLocalVariable)
 
         If m_LocalBuilder Is Nothing Then
             m_LocalBuilder = Emitter.DeclareLocal(Info, VariableTypeOrTypeBuilder, Me.Name)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="145" endline="164"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             If IsLocalVariable Then
                 If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
                 Helper.Assert(m_LocalBuilder IsNot Nothing)
                 result = EmitVariableInitializer(Info) AndAlso result
             ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
                 result = DefineField() AndAlso result
                 result = EmitStaticInitializer(Info) AndAlso result
             End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="165" endline="174"><![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If m_LocalBuilder IsNot Nothing Then
             Emitter.EmitStoreVariable(Info, m_LocalBuilder)
         ElseIf FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="175" endline="180"><![CDATA[
 
     Protected Overrides Sub EmitThisIfNecessary(ByVal Info As EmitInfo)
         If FieldBuilder IsNot Nothing AndAlso FieldBuilder.IsStatic = False Then
             Emitter.EmitLoadMe(Info, FieldBuilder.DeclaringType)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="181" endline="241"><![CDATA[
 
     Private Function EmitStaticInitializer(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim elseIfLabel As Label
         Dim endIfLabel As Label
 
         If Me.HasInitializer = False Then Return result
 
         elseIfLabel = Emitter.DefineLabel(Info)
         endIfLabel = Emitter.DefineLabel(Info)
 
         'Monitor.Enter(initvar)
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Enter_Object)
         'Try
         Dim exBlock As Label
         exBlock = Emitter.EmitBeginExceptionBlock(Info)
         '   If initvar.State = 0 Then
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitLoadVariable(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__State)
         Emitter.EmitLoadI4Value(Info, 0I)
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Bne_Un_S, elseIfLabel)
         '       initvar.State = 2
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitLoadI4Value(Info, 2I)
         Emitter.EmitStoreField(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__State)
         '       (initalization)
         result = EmitVariableInitializer(Info) AndAlso result
         Emitter.EmitBranch(Info, endIfLabel)
         '   ElseIf initvar.State = 2 Then
         Emitter.MarkLabel(Info, elseIfLabel)
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitLoadVariable(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__State)
         Emitter.EmitLoadI4Value(Info, 2I)
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Bne_Un_S, endIfLabel)
         '       Throw New IncompleteInitializationException
         Emitter.EmitNew(Info, Compiler.TypeCache.MS_VB_CS_IncompleteInitialization__ctor)
         Emitter.EmitThrow(Info)
         '   End If
         Emitter.MarkLabel(Info, endIfLabel)
         Emitter.EmitLeave(Info, exBlock)
         'Finally
         Info.ILGen.BeginFinallyBlock()
         '   initvar.State = 1
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitLoadI4Value(Info, 1I)
         Emitter.EmitStoreField(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__State)
         '   Monitor.Exit(initvar)
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Exit_Object)
         'End Try
         Info.ILGen.EndExceptionBlock()
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="242" endline="246"><![CDATA[
 
     Public Overrides ReadOnly Property MemberDescriptor() As Mono.Cecil.MemberReference
         Get
             Throw New InternalException
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="31" endline="33"><![CDATA[
     Overridable Sub UpdateDefinition()
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="34" endline="40"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_CustomAttributes IsNot Nothing Then m_CustomAttributes.Initialize(Me)
         Helper.Assert(m_Name IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="41" endline="45"><![CDATA[
 
     ReadOnly Property GeneratedCode() As Boolean
         Get
             Return m_GeneratedCode
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="46" endline="51"><![CDATA[
     End Property
 
     Protected Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
         m_DeclaringType = Me.FindFirstParent(Of TypeDeclaration)()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="52" endline="56"><![CDATA[
 
     Protected Sub New(ByVal Parent As AssemblyDeclaration)
         MyBase.new(Parent)
         m_DeclaringType = Nothing
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="57" endline="61"><![CDATA[
 
     Protected Sub New(ByVal Parent As TypeDeclaration)
         MyBase.new(Parent)
         m_DeclaringType = Parent
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="62" endline="67"><![CDATA[
 
     Protected Sub New(ByVal Parent As PropertyDeclaration)
         MyBase.new(Parent)
         m_DeclaringType = Parent.DeclaringType
         Helper.Assert(m_DeclaringType IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="68" endline="73"><![CDATA[
 
     Protected Sub New(ByVal Parent As EventDeclaration)
         MyBase.new(Parent)
         m_DeclaringType = Parent.DeclaringType
         Helper.Assert(m_DeclaringType IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="74" endline="80"><![CDATA[
 
     Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String)
         m_Modifiers = Modifiers
         m_Name = Name
 
         If m_Name Is Nothing Then Throw New InternalException(Me.Location.ToString(Compiler))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="81" endline="87"><![CDATA[
 
     Protected Sub Rename(ByVal Name As String)
         m_Name = Name
         If MemberDescriptor IsNot Nothing Then
             MemberDescriptor.Name = m_Name
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="88" endline="92"><![CDATA[
 
     Public Property CustomAttributes() As Attributes Implements IAttributableDeclaration.CustomAttributes
         Get
             Return m_CustomAttributes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="93" endline="95"><![CDATA[
         Set(ByVal value As Attributes)
             m_CustomAttributes = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="96" endline="103"><![CDATA[
     End Property
 
     Public Sub AddCustomAttribute(ByVal Attribute As Attribute)
         If m_CustomAttributes Is Nothing Then
             m_CustomAttributes = New Attributes(Me)
         End If
         m_CustomAttributes.Add(Attribute)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="104" endline="108"><![CDATA[
 
     Public Property DeclaringType() As TypeDeclaration Implements IMember.DeclaringType
         Get
             Return m_DeclaringType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="109" endline="111"><![CDATA[
         Set(ByVal value As TypeDeclaration)
             m_DeclaringType = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="112" endline="117"><![CDATA[
     End Property
 
     Public Overridable ReadOnly Property IsShared() As Boolean Implements IMember.IsShared
         Get
             Return Me.Modifiers.Is(ModifierMasks.Shared) OrElse DeclaringType.IsShared OrElse Me.Modifiers.Is(ModifierMasks.Const)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="118" endline="125"><![CDATA[
     End Property
 
     Public MustOverride ReadOnly Property MemberDescriptor() As Mono.Cecil.MemberReference Implements IMember.MemberDescriptor
 
     Public Property Modifiers() As Modifiers Implements IModifiable.Modifiers
         Get
             Return m_Modifiers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="126" endline="128"><![CDATA[
         Set(ByVal value As Modifiers)
             m_Modifiers = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="129" endline="134"><![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="135" endline="137"><![CDATA[
         Set(ByVal value As String)
             m_Name = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="138" endline="146"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="147" endline="154"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="155" endline="166"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_GeneratedCode = False Then
             If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.GenerateCode(Info) AndAlso result
 
             m_GeneratedCode = True
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclarations.vb" startline="64" endline="66"><![CDATA[
         Get
             Return Me
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclarations.vb" startline="67" endline="76"><![CDATA[
     End Property
 
     ReadOnly Property MemberDeclarations() As Generic.List(Of Mono.Cecil.MemberReference)
         Get
             Dim result As New Generic.List(Of Mono.Cecil.MemberReference)
             For Each member As IMember In Me
                 result.Add(member.MemberDescriptor)
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclarations.vb" startline="77" endline="90"><![CDATA[
     End Property
 
     Function GetSpecificMembers(Of T)() As Generic.List(Of T)
         Dim result As New Generic.List(Of T)
 
         For i As Integer = 0 To Count - 1
             Dim obj As IMember = Me.Item(i)
             If TypeOf obj Is T Then
                 result.Add(CType(CObj(obj), T))
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclarations.vb" startline="91" endline="94"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="34" endline="36"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="37" endline="40"><![CDATA[
 
     Sub Init(ByVal ImplementsList As MemberImplementsList)
         m_ImplementsList = ImplementsList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="41" endline="94"><![CDATA[
 
     Function DefineImplements(ByVal Declaration As EventDeclaration) As Boolean
         Dim result As Boolean = True
         Dim declType As Mono.Cecil.TypeDefinition
 
         Helper.Assert(Declaration IsNot Nothing)
 
         declType = Declaration.DeclaringType.CecilType
 
         For i As Integer = 0 To m_ImplementsList.Count - 1
             Dim ispec As InterfaceMemberSpecifier = m_ImplementsList(i)
             Dim eventI As Mono.Cecil.EventDefinition
 
             eventI = CecilHelper.FindDefinition(ispec.ResolvedEventInfo)
 
             Helper.Assert(eventI IsNot Nothing)
 
             Dim addMethodI, removeMethodI As Mono.Cecil.MethodReference
             Dim addMethod, removeMethod As Mono.Cecil.MethodReference
             Dim raiseMethod As Mono.Cecil.MethodReference = Nothing
             Dim raiseMethodI As Mono.Cecil.MethodReference = Nothing
 
             addMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.AddMethod)
             removeMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.RemoveMethod)
             If eventI.InvokeMethod IsNot Nothing Then
                 raiseMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.InvokeMethod)
             End If
 
             addMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.AddDefinition)
             removeMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.RemoveDefinition)
             If Declaration.RaiseDefinition IsNot Nothing Then
                 raiseMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.RaiseDefinition)
             End If
 
             Helper.Assert((addMethodI Is Nothing Xor addMethod Is Nothing) = False)
             Helper.Assert((removeMethodI Is Nothing Xor removeMethod Is Nothing) = False)
             Helper.Assert((raiseMethodI Is Nothing Xor raiseMethod Is Nothing) = False)
 
             If addMethod IsNot Nothing AndAlso addMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(addMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(addMethodI))
             End If
             If removeMethod IsNot Nothing AndAlso removeMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(removeMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(removeMethodI))
             End If
             If raiseMethod IsNot Nothing AndAlso raiseMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(raiseMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(raiseMethodI))
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="95" endline="140"><![CDATA[
 
     Function DefineImplements(ByVal Method As Mono.Cecil.MethodDefinition) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Method IsNot Nothing)
 
         For i As Integer = 0 To m_ImplementsList.Count - 1
             Dim ispec As InterfaceMemberSpecifier = Me.m_ImplementsList(i)
             Dim methodI As Mono.Cecil.MethodReference = Nothing
             Dim propertyI As Mono.Cecil.PropertyReference = Nothing
             Dim propertyDef As Mono.Cecil.PropertyDefinition = Nothing
 
             If ispec.ResolvedMethodInfo IsNot Nothing Then
                 methodI = Helper.GetMethodOrMethodReference(Compiler, ispec.ResolvedMethodInfo)
             End If
 
             If ispec.ResolvedPropertyInfo IsNot Nothing Then
                 propertyI = Helper.GetPropertyOrPropertyBuilder(Compiler, ispec.ResolvedPropertyInfo)
                 propertyDef = CecilHelper.FindDefinition(propertyI)
             End If
 
             Helper.Assert(propertyI Is Nothing Xor methodI Is Nothing)
 
             If propertyI IsNot Nothing Then
                 'This is a property
                 If Method.Name.StartsWith("get_") Then
                     methodI = CecilHelper.GetCorrectMember(propertyDef.GetMethod, propertyI.DeclaringType)
                 ElseIf Method.Name.StartsWith("set_") Then
                     methodI = CecilHelper.GetCorrectMember(propertyDef.SetMethod, propertyI.DeclaringType)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                 End If
                 methodI = Helper.GetMethodOrMethodReference(Compiler, methodI)
             End If
 
 
             Helper.Assert(methodI IsNot Nothing)
 
             Method.Overrides.Add(CecilHelper.MakeEmittable(methodI))
 
 #If EXTENDEDDEBUG Then
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Defined method override '" & Builder.FullName & "
 #End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="141" endline="145"><![CDATA[
 
     ReadOnly Property ImplementsList() As MemberImplementsList
         Get
             Return m_ImplementsList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="146" endline="150"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_ImplementsList.ResolveCode(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="151" endline="154"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_ImplementsList.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="155" endline="158"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.Implements
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsList.vb" startline="31" endline="33"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="29" endline="31"><![CDATA[
     Protected Sub New(ByVal Parent As TypeDeclaration)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="32" endline="35"><![CDATA[
 
     Protected Sub New(ByVal Parent As PropertyDeclaration)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="36" endline="39"><![CDATA[
 
     Protected Sub New(ByVal Parent As EventDeclaration)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="40" endline="48"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="49" endline="53"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature)
         MyBase.Init(Modifiers, Signature)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="54" endline="58"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature, ByVal Code As CodeBlock)
         MyBase.Init(Modifiers, Signature, Code)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="59" endline="66"><![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="67" endline="76"><![CDATA[
 
     Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If Not added Then
             added = True
             DeclaringType.CecilType.Methods.Add(CecilBuilder)
         End If
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="77" endline="84"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="85" endline="94"><![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Helper.Assert(Me.DeclaringType IsNot Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="95" endline="108"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Signature.Parameters IsNot Nothing Then
             For i As Integer = 0 To Signature.Parameters.Count - 1
                 result = Signature.Parameters(i).GenerateCode(Info) AndAlso result
             Next
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="25" endline="25"><![CDATA[
     Public Shared LOGMETHODRESOLUTION As Boolean = False
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="26" endline="46"><![CDATA[
 
     Private m_Parent As ParsedObject
 
     Private m_Candidates As Generic.List(Of MemberCandidate)
     Private m_InitialCandidates As MemberCandidate()
     Private m_Name As String
     Private m_Arguments As ArgumentList
     Private m_TypeArguments As TypeArgumentList
     Private m_Caller As TypeDeclaration
 
     Private m_ArgumentsTypesAsString As String
 
     Private m_ResolvedCandidate As MemberCandidate
     Private m_ShowErrors As Boolean
     Private m_Resolved As Boolean
     Private m_IsLateBound As Boolean
 
     ReadOnly Property IsLateBound() As Boolean
         Get
             Return m_IsLateBound
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="47" endline="52"><![CDATA[
     End Property
 
     Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="53" endline="55"><![CDATA[
         Set(ByVal value As Boolean)
             m_ShowErrors = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="56" endline="61"><![CDATA[
     End Property
 
     ReadOnly Property Candidates() As Generic.List(Of MemberCandidate)
         Get
             Return m_Candidates
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="62" endline="70"><![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             If m_ArgumentsTypesAsString Is Nothing Then
                 m_ArgumentsTypesAsString = "(" & m_Arguments.ArgumentsTypesAsString & ")"
             End If
             Return m_ArgumentsTypesAsString
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="71" endline="76"><![CDATA[
     End Property
 
     ReadOnly Property Caller() As TypeDeclaration
         Get
             Return m_Caller
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="77" endline="82"><![CDATA[
     End Property
 
     ReadOnly Property Parent() As ParsedObject
         Get
             Return m_Parent
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="83" endline="88"><![CDATA[
     End Property
 
     ReadOnly Property MethodName() As String
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="89" endline="94"><![CDATA[
     End Property
 
     ReadOnly Property MethodDeclaringType() As Mono.Cecil.TypeReference
         Get
             Return m_InitialCandidates(0).Member.DeclaringType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="95" endline="110"><![CDATA[
     End Property
 
     Sub Init(ByVal InitialGroup As Generic.List(Of Mono.Cecil.MemberReference), ByVal Arguments As ArgumentList, ByVal TypeArguments As TypeArgumentList)
         m_Candidates = New Generic.List(Of MemberCandidate)(InitialGroup.Count)
         For i As Integer = 0 To InitialGroup.Count - 1
             Dim member As Mono.Cecil.MemberReference = InitialGroup(i)
             m_Candidates.Add(New MemberCandidate(Me, member))
         Next
 
         m_InitialCandidates = m_Candidates.ToArray()
 
         m_Arguments = Arguments
         m_TypeArguments = TypeArguments
         m_Caller = Parent.FindTypeParent()
         m_Name = InitialGroup(0).Name
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="111" endline="114"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         m_Parent = Parent
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="115" endline="119"><![CDATA[
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Parent.Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="120" endline="125"><![CDATA[
     End Property
 
     ReadOnly Property Arguments() As ArgumentList
         Get
             Return m_Arguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="126" endline="131"><![CDATA[
     End Property
 
     ReadOnly Property TypeArguments() As TypeArgumentList
         Get
             Return m_TypeArguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="132" endline="141"><![CDATA[
     End Property
 
     ReadOnly Property CandidatesLeft() As Integer
         Get
             Dim result As Integer
             For i As Integer = 0 To m_Candidates.Count - 1
                 If m_Candidates(i) IsNot Nothing Then result += 1
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="142" endline="177"><![CDATA[
     End Property
 
     Public Function Resolve() As Boolean
         Dim result As Boolean = True
 
         'If m_Resolved AndAlso ShowErrors = False Then Helper.StopIfDebugging()
 
         Log("")
         Log("Resolving method {0} with arguments {1}", ArgumentsTypesAsString)
 
         result = ResolveInternal()
 
         If result Then
             Helper.Assert(CandidatesLeft = 1 OrElse IsLateBound)
 
             If IsLateBound Then
                 m_ResolvedCandidate = Nothing
             Else
                 For Each member As MemberCandidate In m_Candidates
                     If member Is Nothing Then Continue For
 
                     If IsValidCandidate(member) = False Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC30657, Parent.Location, member.Member.Name)
                         Exit For
                     End If
                     m_ResolvedCandidate = member
                     m_ResolvedCandidate.SelectOutputArguments()
                     Exit For
                 Next
             End If
         End If
 
         m_Resolved = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="178" endline="300"><![CDATA[
 
     Private Function ResolveInternal() As Boolean
         Log("There are " & CandidatesLeft & " candidates left.")
 
         m_IsLateBound = False
 
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "No candidates
         End If
 
         RemoveInaccessible()
         Log("After removing inaccessible candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             If m_InitialCandidates.Length = 1 Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC30390, Parent.Location, m_InitialCandidates(0).Member.DeclaringType.Name, m_InitialCandidates(0).Member.Name, Helper.GetMethodAccessibilityString(Helper.GetMethodAttributes(m_InitialCandidates(0).Member)))
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC30517, Parent.Location, m_InitialCandidates(0).Member.Name)
             End If
         End If
 
         ExpandParamArrays()
         Log("After expanding paramarrays, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Throw New InternalException("Expanding paramarrays resulted in fewer candidates
         End If
 
         RemoveInapplicable()
         Log("After removing inapplicable candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             If m_InitialCandidates.Length = 1 Then
                 Dim argsGiven, argsRequired As Integer
                 Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
                 params = Helper.GetParameters(Compiler, m_InitialCandidates(0).Member)
                 argsRequired = params.Count
                 argsGiven = m_Arguments.Length
                 If argsGiven >= argsRequired Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30057, Parent.Location, m_InitialCandidates(0).ToString())
                 Else
                     For i As Integer = argsGiven To argsRequired - 1
                         Compiler.Report.ShowMessage(Messages.VBNC30455, Parent.Location, params(i).Name, m_InitialCandidates(0).ToString())
                     Next
                     Return False
                 End If
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC30516, Parent.Location, MethodName)
             End If
         End If
 
         InferTypeArguments()
         Log("After inferring type arguments, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 0 Then
             'Type infer code shows the error message if it's supposed to show errors
             Return False
         End If
 
         If CandidatesLeft <= 1 Then Return CandidatesLeft = 1
 
         RemoveNarrowingExceptObject()
         Log("After removing narrowing (except object) candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, String.Format("After removing narrowing (except object) candidates for method '{0}', nothing was found", Me.m_InitialCandidates(0).Member.Name))
             Helper.AddError(Me.m_Parent, String.Format("Tried to select using invocation list
             Dim reported As Integer = 0
             For i As Integer = 0 To m_InitialCandidates.Length - 1
                 reported += 1
                 Dim mi As Mono.Cecil.MemberReference = m_InitialCandidates(i).Member
                 Helper.AddError(Me.m_Parent, String.Format("Candidate #{0}
             Next
         End If
 
         If CandidatesLeft <= 1 Then Return CandidatesLeft = 1
 
         RemoveNarrowing()
         Log("After removing narrowing candidates, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 1 Then
             Return True
         ElseIf CandidatesLeft = 0 Then
             If Parent.Location.File(Compiler).IsOptionStrictOn = False Then
                 m_IsLateBound = True
                 Return True
             End If
         End If
 
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "No non-narrowing
         End If
 
         SelectMostApplicable()
         Log("After selecting the most applicable candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "No most applicable
         End If
 
         If CandidatesLeft = 1 Then
             Return True
         End If
 
         SelectLessGeneric()
         Log("After selecting the less generic candidates, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 1 Then
             Return True
         End If
 
         RemoveInvalid()
 
         If ShowErrors AndAlso CandidatesLeft <> 1 Then
             If CandidatesLeft > 1 Then
                 Helper.AddError(Me.m_Parent, String.Format("After selecting the less generic method for method '{0}', there are still {1} candidates left", Me.m_InitialCandidates(0).Member.Name, CandidatesLeft))
                 Helper.AddError(Me.m_Parent, String.Format("Tried to select using invocation list
                 Dim reported As Integer = 0
                 For i As Integer = 0 To m_Candidates.Count - 1
                     If m_Candidates(i) Is Nothing Then Continue For
                     reported += 1
                     Dim mi As Mono.Cecil.MemberReference = m_InitialCandidates(i).Member
                     Helper.AddError(Me.m_Parent, String.Format("Candidate #{0}
                 Next
             Else
                 Helper.AddError(Me.m_Parent, String.Format("After selecting the less generic method for method '{0}', nothing was found", Me.m_InitialCandidates(0).Member.Name))
             End If
         End If
 
         Return CandidatesLeft = 1
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="301" endline="308"><![CDATA[
 
     Function IsValidCandidate(ByVal candidate As MemberCandidate) As Boolean
         If CecilHelper.IsValidType(candidate.ReturnType) = False Then Return False
         For j As Integer = 0 To candidate.DefinedParametersTypes.Length - 1
             If CecilHelper.IsValidType(candidate.DefinedParametersTypes(j)) = False Then Return False
         Next
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="309" endline="316"><![CDATA[
 
     Sub RemoveInvalid()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim m As MemberCandidate = m_Candidates(i)
             If m Is Nothing Then Continue For
             If IsValidCandidate(m) = False Then m_Candidates(i) = Nothing
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="317" endline="341"><![CDATA[
 
     Private Function ContainsGenericParameters(ByVal Type As TypeReference, ByVal Find As Mono.Collections.Generic.Collection(Of GenericParameter)) As Boolean
         Dim elementType As TypeReference
         Dim tg As GenericParameter
         Dim git As GenericInstanceType
 
         If Type Is Nothing Then Return False
 
         tg = TryCast(Type, GenericParameter)
         If tg IsNot Nothing AndAlso Find.Contains(tg) Then Return True
 
         git = TryCast(Type, GenericInstanceType)
         If git IsNot Nothing AndAlso git.HasGenericArguments Then
             For i As Integer = 0 To Find.Count - 1
                 If git.GenericArguments.Contains(Find(i)) Then Return True
             Next
         End If
 
         elementType = Type.GetElementType()
         If elementType IsNot Nothing AndAlso elementType IsNot Type Then
             Return ContainsGenericParameters(elementType, Find)
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="342" endline="458"><![CDATA[
 
     Sub SelectLessGeneric()
         '
         'A member M is determined to be less generic than a member N as follows
         '1.	If, for each pair of matching parameters Mj and Nj, Mj is less or equally 
         '   generic than Nj with respect to type parameters on the method, and at least 
         '   one Mj is less generic with respect to type parameters on the method.
         '2.	Otherwise, if for each pair of matching parameters Mj and Nj, Mj is less or equally generic than Nj 
         '   with respect to type parameters on the type, and at least one Mj is less generic with respect to 
         '   type parameters on the type, then M is less generic than N.
         '
         'A parameter M is considered to be equally generic to a parameter N if their types Mt and Nt
         'both refer to type parameters or both don't refer to type parameters.
         'M is considered to be less generic than N if Mt does not refer to a type parameter and Nt does.
         '
 
         Dim gpType As Mono.Collections.Generic.Collection(Of GenericParameter) = Nothing
         Dim gp() As Mono.Collections.Generic.Collection(Of GenericParameter) = Nothing
 
         For i As Integer = 0 To m_Candidates.Count - 1
             If m_Candidates(i) Is Nothing Then Continue For
 
             For j As Integer = i + 1 To m_Candidates.Count - 1
                 If m_Candidates(j) Is Nothing Then Continue For
 
                 Dim candidateI As MemberCandidate = m_Candidates(i)
                 Dim candidateJ As MemberCandidate = m_Candidates(j)
                 Dim parametersI As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetOriginalParameters(candidateI.Member)
                 Dim parametersJ As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetOriginalParameters(candidateJ.Member)
                 Dim paramCount As Integer = Math.Min(parametersI.Count, parametersJ.Count)
                 Dim gpI As Mono.Collections.Generic.Collection(Of GenericParameter)
                 Dim gpJ As Mono.Collections.Generic.Collection(Of GenericParameter)
                 Dim timesLessGenericI As Integer
                 Dim timesLessGenericJ As Integer
 
                 'Not sure if the # of parameters can be different between I and J here
                 If paramCount = 0 Then Continue For
 
                 If gp Is Nothing Then ReDim gp(m_Candidates.Count - 1)
 
                 gpI = gp(i)
                 gpJ = gp(j)
 
                 If gpI Is Nothing Then
                     gp(i) = Helper.GetGenericParameters(candidateI.Member)
                     gpI = gp(i)
                 End If
                 If gpJ Is Nothing Then
                     gp(j) = Helper.GetGenericParameters(candidateJ.Member)
                     gpJ = gp(j)
                 End If
 
                 '1.	If, for each pair of matching parameters Mj and Nj, Mj is less or equally 
                 '   generic than Nj with respect to type parameters on the method, and at least 
                 '   one Mj is less generic with respect to type parameters on the method.
 
                 For p As Integer = 0 To paramCount - 1
                     Dim paramI As ParameterDefinition = parametersI(p)
                     Dim paramJ As ParameterDefinition = parametersJ(p)
                     Dim containsI As Boolean = ContainsGenericParameters(paramI.ParameterType, gpI)
                     Dim containsJ As Boolean = ContainsGenericParameters(paramJ.ParameterType, gpJ)
 
                     If containsI = False AndAlso containsJ = True Then
                         timesLessGenericI += 1
                     ElseIf containsI = True AndAlso containsJ = False Then
                         timesLessGenericJ += 1
                     End If
                 Next
 
                 If timesLessGenericI > 0 AndAlso timesLessGenericJ = 0 Then
                     Log("MORE METHOD GENERIC
                     m_Candidates(j) = Nothing
                     Exit For
                 ElseIf timesLessGenericI = 0 AndAlso timesLessGenericJ > 0 Then
                     Log("MORE METHOD GENERIC
                     m_Candidates(i) = Nothing
                     Exit For
                 End If
 
                 '2.	Otherwise, if for each pair of matching parameters Mj and Nj, Mj is less or equally generic than Nj 
                 '   with respect to type parameters on the type, and at least one Mj is less generic with respect to 
                 '   type parameters on the type, then M is less generic than N.
                 timesLessGenericI = 0
                 timesLessGenericJ = 0
 
                 If gpType Is Nothing Then
                     gpType = CecilHelper.FindDefinition(m_Candidates(i).Member.DeclaringType).GenericParameters
                 End If
 
                 'Not sure if the # of parameters can be different between I and J here
                 For p As Integer = 0 To paramCount - 1
                     Dim paramI As ParameterDefinition = parametersI(p)
                     Dim paramJ As ParameterDefinition = parametersJ(p)
                     Dim containsI As Boolean = ContainsGenericParameters(paramI.ParameterType, gpType)
                     Dim containsJ As Boolean = ContainsGenericParameters(paramJ.ParameterType, gpType)
 
                     If containsI = False AndAlso containsJ = True Then
                         timesLessGenericI += 1
                     ElseIf containsI = True AndAlso containsJ = False Then
                         timesLessGenericJ += 1
                     End If
                 Next
 
                 If timesLessGenericI > 0 AndAlso timesLessGenericJ = 0 Then
                     Log("MORE TYPE GENERIC
                     m_Candidates(j) = Nothing
                     Exit For
                 ElseIf timesLessGenericI = 0 AndAlso timesLessGenericJ > 0 Then
                     Log("MORE TYPE GENERIC
                     m_Candidates(i) = Nothing
                     Exit For
                 End If
 
                 Log("EQUALLY GENERIC
             Next
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="459" endline="473"><![CDATA[
 
     Sub RemoveInaccessible()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsAccessible = False Then
                 Log("NOT ACCESSIBLE
                 m_Candidates(i) = Nothing
             Else
                 Log("ACCESSIBLE    
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="474" endline="493"><![CDATA[
 
     Sub InferTypeArguments()
         If m_TypeArguments IsNot Nothing AndAlso m_TypeArguments.Count > 0 Then
             Log("Type arguments specified, not inferring them")
             Return
         End If
 
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.InferTypeArguments = False Then
                 Log("TYPE INFERENCE FAILED
                 m_Candidates(i) = Nothing
             Else
                 Log("TYPE INFERENCE PASSED
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="494" endline="503"><![CDATA[
 
     Sub ExpandParamArrays()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             candidate.ExpandParamArray()
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="504" endline="518"><![CDATA[
 
     Sub RemoveInapplicable()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.DefineApplicability = False Then
                 Log("NOT APPLICABLE
                 m_Candidates(i) = Nothing
             Else
                 Log("APPLICABLE    
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="519" endline="533"><![CDATA[
 
     Sub RemoveNarrowingExceptObject()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowingExceptObject Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="534" endline="548"><![CDATA[
 
     Sub RemoveNarrowing()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowing Then
                 Log("NARROWING    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="549" endline="612"><![CDATA[
 
     Sub SelectMostApplicable()
         'Find most applicable methods.
         Dim expandedArgumentTypes(m_Candidates.Count - 1)() As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To m_Candidates.Count - 1
             If m_Candidates(i) Is Nothing Then Continue For
 
             For j As Integer = i + 1 To m_Candidates.Count - 1
                 If m_Candidates(j) Is Nothing Then Continue For
 
                 Dim candidateI As MemberCandidate = m_Candidates(i)
                 Dim candidateJ As MemberCandidate = m_Candidates(j)
 
                 Helper.Assert(candidateI.ExactArguments IsNot Nothing)
                 Helper.Assert(candidateJ.ExactArguments IsNot Nothing)
 
                 Dim a, b As Boolean
 
                 If expandedArgumentTypes(i) Is Nothing Then
                     expandedArgumentTypes(i) = candidateI.TypesInInvokedOrder() ' Helper.GetExpandedTypes(Compiler, candidateI.InputParameters, Arguments.Count)
                 End If
                 If expandedArgumentTypes(j) Is Nothing Then
                     expandedArgumentTypes(j) = candidateJ.TypesInInvokedOrder() 'Helper.GetExpandedTypes(Compiler, candidateJ.InputParameters, Arguments.Count)
                 End If
 
                 a = Helper.IsFirstMoreApplicable(m_Parent, Arguments.Arguments, expandedArgumentTypes(i), expandedArgumentTypes(j))
                 b = Helper.IsFirstMoreApplicable(m_Parent, Arguments.Arguments, expandedArgumentTypes(j), expandedArgumentTypes(i))
 
                 If a = b Then ' AndAlso b = False Then
                     'It is possible for M and N to have the same signature if one or both contains an expanded 
                     'paramarray parameter. In that case, the member with the fewest number of arguments matching
                     'expanded paramarray parameters is considered more applicable. 
                     Dim iParamArgs, jParamArgs As Integer
 
                     If candidateI.IsParamArrayCandidate Then
                         iParamArgs = candidateI.ParamArrayExpression.ArrayElementInitalizer.Initializers.Count + 1
                     End If
                     If candidateJ.IsParamArrayCandidate Then
                         jParamArgs = candidateJ.ParamArrayExpression.ArrayElementInitalizer.Initializers.Count + 1
                     End If
                     If jParamArgs > iParamArgs Then
                         a = True 
                     ElseIf iParamArgs > jParamArgs Then
                         b = True 
                     End If
                     Helper.Assert(iParamArgs <> jParamArgs OrElse (iParamArgs = 0 AndAlso jParamArgs = 0), MethodName)
                 End If
 
                 If a Xor b Then
                     If a = False Then
                         Log("NOT MOST APPLICABLE
                         m_Candidates(i) = Nothing
                         Exit For
                     Else
                         Log("NOT MOST APPLICABLE
                         m_Candidates(j) = Nothing
                     End If
                 Else
                     Log("EQUALLY APPLICABLE
                 End If
             Next
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="613" endline="617"><![CDATA[
 
     ReadOnly Property Resolved() As Boolean
         Get
             Return m_ResolvedCandidate IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="618" endline="623"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedCandidate() As MemberCandidate
         Get
             Return m_ResolvedCandidate
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="624" endline="630"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedMember() As Mono.Cecil.MemberReference
         Get
             If m_ResolvedCandidate Is Nothing Then Return Nothing
             Return m_ResolvedCandidate.Member
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="631" endline="636"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedMethod() As Mono.Cecil.MethodReference
         Get
             Return TryCast(ResolvedMember, Mono.Cecil.MethodReference)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="637" endline="642"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedConstructor() As Mono.Cecil.MethodReference
         Get
             Return TryCast(ResolvedMember, Mono.Cecil.MethodReference)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="643" endline="648"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedProperty() As Mono.Cecil.PropertyReference
         Get
             Return TryCast(ResolvedMember, Mono.Cecil.PropertyReference)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="649" endline="658"><![CDATA[
     End Property
 
     <Diagnostics.Conditional("DEBUG")> _
     Sub Log(ByVal Format As String, Optional ByVal P1 As Object = Nothing, Optional ByVal P2 As Object = Nothing, Optional ByVal P3 As Object = Nothing)
         If LOGMETHODRESOLUTION Then
             Dim msg As String
             msg = String.Format(Format, MethodName, P1, P2, P3)
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, msg)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="673" endline="675"><![CDATA[
     Public Overrides Function ToString() As String
         Return Helper.ToString(m_Parent.Parent, m_Member)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="676" endline="680"><![CDATA[
 
     Sub New(ByVal Parent As MethodResolver, ByVal Member As Mono.Cecil.MemberReference)
         m_Parent = Parent
         m_Member = Member
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="681" endline="685"><![CDATA[
 
     ReadOnly Property TypesInInvokedOrder() As Mono.Cecil.TypeReference()
         Get
             Return m_TypesInInvokedOrder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="686" endline="691"><![CDATA[
     End Property
 
     ReadOnly Property ExactArguments() As Generic.List(Of Argument)
         Get
             Return m_ExactArguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="692" endline="698"><![CDATA[
     End Property
 
     ReadOnly Property DefinedParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Get
             If m_DefinedParameters Is Nothing Then m_DefinedParameters = Helper.GetParameters(Compiler, Member)
             Return m_DefinedParameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="699" endline="705"><![CDATA[
     End Property
 
     ReadOnly Property DefinedParametersTypes() As Mono.Cecil.TypeReference()
         Get
             If m_DefinedParametersTypes Is Nothing Then m_DefinedParametersTypes = Helper.GetTypes(DefinedParameters)
             Return m_DefinedParametersTypes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="706" endline="712"><![CDATA[
     End Property
 
     ReadOnly Property ReturnType As TypeReference
         Get
             If m_ReturnType Is Nothing Then m_ReturnType = Helper.GetReturnType(m_Member)
             Return m_ReturnType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="713" endline="718"><![CDATA[
     End Property
 
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Parent.Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="719" endline="724"><![CDATA[
     End Property
 
     ReadOnly Property Member() As Mono.Cecil.MemberReference
         Get
             Return m_Member
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="725" endline="730"><![CDATA[
     End Property
 
     ReadOnly Property Resolver() As MethodResolver
         Get
             Return m_Parent
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="731" endline="736"><![CDATA[
     End Property
 
     ReadOnly Property Parent() As ParsedObject
         Get
             Return m_Parent.Parent
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="737" endline="742"><![CDATA[
     End Property
 
     ReadOnly Property IsParamArrayCandidate() As Boolean
         Get
             Return m_IsParamArray
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="743" endline="749"><![CDATA[
     End Property
 
     ReadOnly Property ParamArrayExpression() As ArrayCreationExpression
         Get
             If m_IsParamArray = False Then Return Nothing
             Return DirectCast(m_ExactArguments(m_ExactArguments.Count - 1).Expression, ArrayCreationExpression)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="750" endline="759"><![CDATA[
     End Property
 
     ReadOnly Property IsAccessible() As Boolean
         Get
             If Resolver.Caller Is Nothing Then
                 Return Helper.IsAccessibleExternal(Compiler, m_Member)
             Else
                 Return Helper.IsAccessible(Compiler, Resolver.Caller.CecilType, m_Member)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="760" endline="765"><![CDATA[
     End Property
 
     ReadOnly Property IsNarrowingExceptObject() As Boolean
         Get
             Return IsNarrowingInternal(True)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="766" endline="771"><![CDATA[
     End Property
 
     ReadOnly Property IsNarrowing() As Boolean
         Get
             Return IsNarrowingInternal(False)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="772" endline="806"><![CDATA[
     End Property
 
     Private Function IsNarrowingInternal(ByVal ExceptObject As Boolean) As Boolean
         For j As Integer = 0 To InputParameters.Count - 1
             Dim arg As Argument
             Dim param As Mono.Cecil.ParameterDefinition
             Dim IsConvertible As Boolean
             Dim elementType As Mono.Cecil.TypeReference
             Dim initializer As Expression
 
             param = InputParameters(j)
             arg = ExactArguments(j)
 
             If ExceptObject AndAlso Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.System_Object) Then Continue For
 
             If m_IsParamArray AndAlso j = InputParameters.Count - 1 AndAlso ParamArrayExpression IsNot Nothing Then
                 'To match the automatically created array for the paramarray parameter each argument has to be 
                 'implicitly convertible to the element type of the paramarray parameter type.
                 IsConvertible = True
                 elementType = CType(param.ParameterType, Mono.Cecil.ArrayType).ElementType
                 For k As Integer = 0 To ParamArrayExpression.ArrayElementInitalizer.Initializers.Count - 1
                     initializer = ParamArrayExpression.ArrayElementInitalizer.Initializers(k).AsRegularInitializer
                     IsConvertible = IsConvertible AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(arg, initializer.ExpressionType, elementType)
                 Next
             Else
                 IsConvertible = Compiler.TypeResolution.IsImplicitlyConvertible(arg, arg.Expression.ExpressionType, param.ParameterType)
             End If
 
             If IsConvertible = False Then
                 Return True
             End If
         Next
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="807" endline="811"><![CDATA[
 
     ReadOnly Property Arguments() As ArgumentList
         Get
             Return Resolver.Arguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="812" endline="817"><![CDATA[
     End Property
 
     ReadOnly Property TypeArguments() As TypeArgumentList
         Get
             Return Resolver.TypeArguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="818" endline="823"><![CDATA[
     End Property
 
     ReadOnly Property InputParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Get
             Return DefinedParameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="824" endline="830"><![CDATA[
     End Property
 
     ReadOnly Property ParamArrayParameter() As Mono.Cecil.ParameterDefinition
         Get
             If m_IsParamArray = False Then Return Nothing
             Return m_DefinedParameters(m_DefinedParameters.Count - 1)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="831" endline="852"><![CDATA[
     End Property
 
     Private Sub CollectGenericParameters(ByVal Type As GenericInstanceType, ByVal Find As Mono.Collections.Generic.Collection(Of GenericParameter), ByRef collected As Generic.List(Of GenericParameter))
         Dim elementType As GenericInstanceType
 
         If Type Is Nothing Then Return
 
         If Type.HasGenericArguments Then
             For i As Integer = 0 To Find.Count - 1
                 If Type.GenericArguments.Contains(Find(i)) Then
                     If collected Is Nothing Then collected = New Generic.List(Of GenericParameter)
                     If collected.Contains(Find(i)) Then Continue For
                     collected.Add(Find(i))
                 End If
             Next
         End If
 
         elementType = TryCast(Type.GetElementType(), GenericInstanceType)
         If elementType IsNot Nothing AndAlso elementType IsNot Type Then
             CollectGenericParameters(elementType, Find, collected)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="853" endline="1092"><![CDATA[
 
     Function InferTypeArguments() As Boolean
         Dim GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim methodDef As MethodDefinition = TryCast(m_Member, MethodDefinition)
         Dim methodRef As MethodReference
 
         If methodDef Is Nothing Then
             methodRef = TryCast(m_Member, MethodReference)
             If methodRef IsNot Nothing Then
                 methodDef = CecilHelper.FindDefinition(methodRef)
             End If
         End If
 
         If methodDef IsNot Nothing Then
             If Not methodDef.HasGenericParameters Then Return True
             GenericParameters = methodDef.GenericParameters
         Else
             Return True
         End If
 
         If DefinedParameters.Count <> Arguments.Count Then
             If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location)
             Return False
         End If
 
         '* Generate a dependency graph *
         ' Given a set of arguments A1, A2, ?, AN, a set of matching parameters P1, P2, ?, PN and a set of method type parameters 
         ' T1, T2, ?, TN, the dependencies between the arguments and method type parameters are first collected as follows
 
         Dim A_deps() As Generic.List(Of GenericParameter) = Nothing
         Dim A_dep As Generic.List(Of GenericParameter)
 
         For i As Integer = 0 To Arguments.Count - 1
             Dim An As Argument = Arguments(i)
             Dim Pn As ParameterDefinition = m_DefinedParameters(i)
             Dim git As GenericInstanceType
             Dim gp As GenericParameter
 
             '?	If AN is the Nothing literal, no dependencies are generated.
             If TypeOf An.Expression Is NothingConstantExpression Then Continue For
 
             git = TryCast(Pn.ParameterType, GenericInstanceType)
             gp = TryCast(Pn.ParameterType, GenericParameter)
 
             '?	If AN is a lambda method and the type of PN is a constructed delegate type 
             '   or System.Linq.Expressions.Expression(Of T), where T is a constructed delegate type,
             '   ?	If the type of a lambda method parameter will be inferred from the type of the corresponding parameter PN, and the type of the parameter depends on a method type parameter TN, then AN has a dependency on TN.
             '   ?	If the type of a lambda method parameter is specified and the type of the corresponding parameter PN depends on a method type parameter TN, then TN has a dependency on AN.
             '   ?	If the return type of PN depends on a method type parameter TN, then TN has a dependency on AN.
             '* Lambda methods haven't been implemented yet *
 
             '?	If AN is a method pointer and the type of PN is a constructed delegate type,
             '   ?	If the return type of PN depends on a method type parameter TN, then TN has a dependency on AN.
             If An.Expression.Classification.IsMethodPointerClassification AndAlso Helper.IsDelegate(Compiler, Pn.ParameterType) AndAlso git IsNot Nothing Then
                 Dim invokeMethod As MethodReference = Helper.GetInvokeMethod(Compiler, Pn.ParameterType)
                 A_dep = Nothing
                 CollectGenericParameters(TryCast(invokeMethod.ReturnType, GenericInstanceType), GenericParameters, A_dep)
                 If A_dep IsNot Nothing Then
                     If A_deps Is Nothing Then ReDim A_deps(Arguments.Count - 1)
                     A_deps(i) = A_dep
                 End If
                 Continue For
             End If
 
             '?	If PN is a constructed type and the type of PN depends on a method type parameter TN, then TN has a dependency on AN.
             If git IsNot Nothing Then
                 A_dep = Nothing
                 CollectGenericParameters(git, GenericParameters, A_dep)
                 If A_dep IsNot Nothing Then
                     If A_deps Is Nothing Then ReDim A_deps(Arguments.Count - 1)
                     A_deps(i) = A_dep
                 End If
                 Continue For
             ElseIf gp IsNot Nothing AndAlso GenericParameters.Contains(gp) Then
                 If A_deps Is Nothing Then ReDim A_deps(Arguments.Count - 1)
                 A_dep = New Generic.List(Of GenericParameter)
                 A_dep.Add(gp)
                 A_deps(i) = A_dep
                 Continue For
             End If
 
             '?	Otherwise, no dependency is generated.
         Next
 
         ' After collecting dependencies, any arguments that have no dependencies are eliminated.
         '* eliminated arguments are represented by null entries in the A_deps array
 
         ' If any method type parameters have no outgoing dependencies (i.e. the method type parameter does not depend on an argument), then type inference fails. 
         If A_deps Is Nothing Then
             If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC32050, Me.Parent.Location, GenericParameters(0).Name, Helper.ToString(Compiler, m_Member))
             Return False '* No dependencies at all
         End If
         For i As Integer = 0 To GenericParameters.Count - 1
             Dim found As Boolean = False
             For a As Integer = 0 To A_deps.Length - 1
                 If A_deps(a) Is Nothing Then Continue For
                 If A_deps(a).Contains(GenericParameters(i)) Then
                     found = True
                     Exit For
                 End If
             Next
             If Not found Then
                 If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC32050, Me.Parent.Location, GenericParameters(i).Name, Helper.ToString(Compiler, m_Member))
                 Return False '* GenericParameter(i) does not have a dependency
             End If
         Next
 
         Dim hints As TypeHints()
         ReDim hints(GenericParameters.Count - 1)
 
         ' Otherwise, the remaining arguments and method type parameters are grouped into strongly connected components.
         ' A strongly connected component is a set of arguments and method type parameters,
         ' where any element in the component is reachable via dependencies on other elements.
         ' The strongly connected components are then topologically sorted and processed in topological order
         '* Since we don't have lambda methods yet, we only have a tree of dependencies (method type parameters on arguments)
         '* We'll always have one element in each the stronly connected component, so just look over each argument and each method type parameter
 
         '?	If the strongly typed component contains only one element,
         '   ?	If the element has already been marked complete, skip it.
         '   ?	If the element is an argument, then add type hints from the argument to the method type parameters 
         '       that depend on it and mark the element as complete. If the argument is a lambda method with parameters 
         '       that still need inferred types, then infer Object for the types of those parameters.
         For i As Integer = 0 To A_deps.Length - 1
             Dim Ta As TypeReference
             Dim Tp As TypeReference
             If A_deps(i) Is Nothing Then Continue For
 
             Ta = Arguments(i).Expression.ExpressionType
             Tp = DefinedParameters(i).ParameterType
             For a As Integer = 0 To A_deps(i).Count - 1
                 Dim Tg As GenericParameter = A_deps(i)(a)
                 Dim aI As Integer = GenericParameters.IndexOf(Tg)
                 Dim hint As TypeHints = hints(aI)
 
                 If hints(aI) Is Nothing Then
                     hint = New TypeHints(Me)
                     hints(aI) = hint
                 End If
 
                 If hint.GenerateHint(GenericParameters, Ta, DefinedParameters(i)) = False Then
                     If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location)
                     Return False
                 End If
 
             Next
             '       If the argument is a lambda method with parameters 
             '       that still need inferred types, then infer Object for the types of those parameters.
             '* no lambda method support yet *
         Next
 
         '   ?	If the element is a method type parameter, then infer the method type parameter to be the dominant
         '       type among the argument type hints and mark the element as complete. If a type hint has an array element 
         '       restriction on it, then only conversions that are valid between arrays of the given type are considered 
         '       (i.e. covariant and intrinsic array conversions). If a type hint has a generic argument restriction on it, 
         '       then only identity conversions are considered. If no dominant type can be chosen, inference fails. 
         '       If any lambda method argument types depend on this method type parameter, the type is propagated to the lambda method.
         Dim m_InferredTypeArguments As New Mono.Collections.Generic.Collection(Of TypeReference)(GenericParameters.Count)
         For i As Integer = 0 To GenericParameters.Count - 1
             Dim hint As TypeHints = hints(i)
             Dim types As Generic.List(Of TypeReference)
             Dim dominantType As TypeReference
             Dim generic_argument_restriction As Boolean
             Dim array_element_restriction As Boolean
             types = New Generic.List(Of TypeReference)(hint.Hints.Count)
 
             For h As Integer = 0 To hint.Hints.Count - 1
                 Dim hi As TypeHint = hint.Hints(h)
                 If hi.GenericArgumentRestriction Then
                     generic_argument_restriction = True
                 ElseIf hi.ArrayElementRestriction Then
                     array_element_restriction = True
                 End If
 
                 Dim found As Boolean
                 For t As Integer = 0 To types.Count - 1
                     If Helper.CompareType(types(t), hi.Hint) Then
                         found = True
                         Exit For
                     End If
                 Next
                 If Not found Then types.Add(hi.Hint)
             Next
 
             If types.Count = 0 Then
                 If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location)
                 Return False
             End If
 
             If generic_argument_restriction Then
                 'all types must be identical
                 dominantType = types(0)
                 For t As Integer = 1 To types.Count - 1
                     If Helper.CompareType(types(t), dominantType) = False Then
                         If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC36657, Me.Parent.Location, Helper.ToString(Compiler, m_Member))
                         Return False
                     End If
                 Next
             ElseIf array_element_restriction Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location, "Type argument inference with array element restriction")
             Else
                 dominantType = Helper.GetDominantType(Compiler, types)
             End If
 
             If dominantType Is Nothing Then
                 If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC36651, Me.Parent.Location, Helper.ToString(Compiler, m_Member))
                 Return False
             End If
             m_InferredTypeArguments.Add(dominantType)
         Next
 
         '?	If the strongly typed component contains more than one element, then the component contains a cycle.
         '   ?	For each method type parameter that is an element in the component, if the method type parameter depends
         '       on an argument that is not marked complete, convert that dependency into an assertion that will be 
         '       checked at the end of the inference process.
         '   ?	Restart the inference process at the point at which the strongly typed components were determined.
         '* This can't happen until lambda methods have been implemented, since only lambda methods can have a dependency 
         '* from method type parameters to arguments, so until then this is just a tree of arguments to method type parameters, 
         '* not a cyclic graph *
 
         'If type inference succeeds for all of the method type parameters, then any dependencies that were changed 
         'into assertions are checked. An assertion succeeds if the type of the argument is implicitly convertible 
         'to the inferred type of the method type parameter. If an assertion fails, then type argument inference fails.
         '* no assertions are added until lambda support has been implemented, so nothing to do here for now *
 
         '* type inference succeeded, inflate our method *
         Dim inflated_method As MethodReference = CecilHelper.GetCorrectMember(methodDef, m_InferredTypeArguments)
         Dim gim As New GenericInstanceMethod(inflated_method)
         gim.GenericArguments.AddRange(m_InferredTypeArguments)
         m_Member = gim
         m_DefinedParameters = Nothing
         m_DefinedParametersTypes = Nothing
         m_TypesInInvokedOrder = Nothing
 
         If DefineApplicability() = False Then
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location, "Applicability changed after inferring type arguments")
         End If
 
         'The success of type inference does not, in and of itself, guarantee that the method is applicable.
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1093" endline="1230"><![CDATA[
 
     Class TypeHint
         Public Hint As TypeReference
         Public ArrayElementRestriction As Boolean
         Public GenericArgumentRestriction As Boolean
     End Class
 
     Class TypeHints
         Private m_Candidate As MemberCandidate
         Private m_Hints As New Generic.List(Of TypeHint)
 
         ReadOnly Property Hints As Generic.List(Of TypeHint)
             Get
                 Return m_Hints
             End Get
         End Property
 
         Public Sub New(ByVal Candidate As MemberCandidate)
             m_Candidate = Candidate
         End Sub
 
         Private Function InvolvesMethodTypeParameters(ByVal GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal type As TypeReference) As Boolean
             Dim elementType As GenericInstanceType
             Dim genericParam As GenericParameter
             Dim git As GenericInstanceType
 
             If type Is Nothing Then Return False
 
             genericParam = TryCast(type, GenericParameter)
             If genericParam IsNot Nothing AndAlso GenericParameters.Contains(genericParam) Then Return True
 
             git = TryCast(type, GenericInstanceType)
             If git Is Nothing Then Return False
 
             For i As Integer = 0 To GenericParameters.Count - 1
                 If git.GenericArguments.Contains(GenericParameters(i)) Then Return True
             Next
 
             elementType = TryCast(type.GetElementType(), GenericInstanceType)
             If elementType IsNot type Then Return InvolvesMethodTypeParameters(GenericParameters, elementType)
 
             Return False
         End Function
 
         Public Function GenerateHint(ByVal GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal argument_type As TypeReference, ByVal parameter As ParameterDefinition) As Boolean
             Return GenerateHint(GenericParameters, argument_type, parameter.ParameterType, parameter, False, False)
         End Function
 
         Private Function GenerateHint(ByVal GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal argument_type As TypeReference, ByVal parameter_type As TypeReference, ByVal parameter As ParameterDefinition, ByVal array_element_restriction As Boolean, ByVal generic_argument_restriction As Boolean) As Boolean
 
             'Given an argument type TA for an argument A and a parameter type TP for a parameter P, type hints are generated as follows
             '?	If TP does not involve any method type parameters then no hints are generated.
             If InvolvesMethodTypeParameters(GenericParameters, parameter_type) = False Then Return True
 
             '?	If TP and TA are array types of the same rank, then replace TA and TP with the element types of 
             '   TA and TP and restart this process with an array element restriction.
             Dim arrayA As ArrayType = TryCast(argument_type, ArrayType)
             Dim arrayP As ArrayType = TryCast(parameter_type, ArrayType)
             If arrayA IsNot Nothing AndAlso arrayP IsNot Nothing Then
                 If arrayA.Rank = arrayP.Rank Then
                     Return GenerateHint(GenericParameters, arrayA.ElementType, arrayP.ElementType, parameter, True, generic_argument_restriction)
                 End If
             End If
 
             '?	If TP is a method type parameter, then TA is added as a type hint with the current restriction, if any.
             Dim gp As GenericParameter = TryCast(parameter_type, GenericParameter)
             If gp IsNot Nothing AndAlso GenericParameters.Contains(gp) Then
                 Dim hint As TypeHint = New TypeHint()
                 hint.ArrayElementRestriction = array_element_restriction
                 hint.GenericArgumentRestriction = generic_argument_restriction
                 hint.Hint = argument_type
                 m_Hints.Add(hint)
                 Return True
             End If
 
             '?	If A is a lambda method and TP is a constructed delegate type or System.Linq.Expressions.Expression(Of T), 
             '   where T is a constructed delegate type, for each lambda method parameter type TL and corresponding 
             '   delegate parameter type TD, replace TA with TL and TP with TD and restart the process with no restriction. 
             '   Then replace TA with the return type of the lambda method and TP with the return type of the delegate type 
             '   and restart the process with no restriction.
             '* no lambda support yet *
 
             '?	If A is a method pointer and TP is a constructed delegate type, use the parameter types of TP to determine 
             '   which method pointed is most applicable to TP. If there is a method that is most applicable, replace TA with 
             '   the return type of the method and TP with the return type of the delegate type and restart the process with 
             '   no restriction.
             '* TODO *
 
             '?	Otherwise, TP must be a constructed type. Given TG, the generic type of TP,
             '   ?	If TA is TG, inherits from TG, or implements the type TG exactly once, then for each matching 
             '       type argument TAX from TA and TPX from TP, replace TA with TAX and TP with TPX and restart 
             '       the process with a generic argument restriction.
             Dim tp_git As GenericInstanceType = TryCast(parameter_type, GenericInstanceType)
             Dim ta_git As GenericInstanceType = TryCast(argument_type, GenericInstanceType)
             If tp_git IsNot Nothing AndAlso ta_git IsNot Nothing Then
                 Dim restart As Boolean
                 Dim implement_count As Integer
                 Dim tp_td As TypeDefinition = CecilHelper.FindDefinition(tp_git)
                 Dim ta_td As TypeDefinition = CecilHelper.FindDefinition(ta_git)
                 Dim base As TypeReference = ta_td
                 Dim base_td As TypeDefinition
                 While base IsNot Nothing AndAlso restart = False
                     If base Is tp_td Then restart = True
                     base_td = CecilHelper.FindDefinition(base)
                     If base_td.HasInterfaces Then
                         For i As Integer = 0 To base_td.Interfaces.Count - 1
                             If base_td.Interfaces(i) Is tp_git Then implement_count += 1
                         Next
                     End If
 
                     base = base_td.BaseType
                 End While
                 If restart = False Then
                     restart = implement_count = 1
                 End If
                 If restart Then
                     For i As Integer = 0 To ta_git.GenericArguments.Count - 1
                         If GenerateHint(GenericParameters, ta_git.GenericArguments(i), tp_git.GenericArguments(i), parameter, array_element_restriction, True) = False Then
                             Return False
                         End If
                     Next
                 End If
                 Return True
             End If
 
             '?	Otherwise, type inference fails for the generic method.
             Return False
         End Function
     End Class
 
     Sub ExpandParamArray()
         If DefinedParameters.Count = 0 Then Return
         If Helper.IsParamArrayParameter(Compiler, DefinedParameters(DefinedParameters.Count - 1)) = False Then Return
 
         Dim candidate As New MemberCandidate(Resolver, m_Member)
         candidate.m_IsParamArray = True
         Resolver.Candidates.Add(candidate)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1231" endline="1462"><![CDATA[
 
     Function DefineApplicability() As Boolean
         Dim matchedParameters As Generic.List(Of Mono.Cecil.ParameterReference)
         Dim exactArguments As Generic.List(Of Argument)
         Dim method As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         Dim prop As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
 
         Dim isLastParamArray As Boolean
         Dim paramArrayExpression As ArrayCreationExpression = Nothing
         Dim inputParametersCount As Integer = InputParameters.Count
 
         isLastParamArray = m_IsParamArray
 
         '(if there are more arguments than parameters and the last parameter is not a 
         'paramarray parameter the method should not be applicable)
         If Arguments.Count > InputParameters.Count Then
             If InputParameters.Count < 1 Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
             If isLastParamArray = False Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
         End If
 
         matchedParameters = New Generic.List(Of Mono.Cecil.ParameterReference)
         exactArguments = New Generic.List(Of Argument)(Helper.CreateArray(Of Argument)(Nothing, inputParametersCount))
 
         ReDim m_TypesInInvokedOrder(Math.Max(Arguments.Count - 1, inputParametersCount - 1))
 
         If isLastParamArray Then
             Dim paramArrayArg As New PositionalArgument(Parent)
 
             Helper.Assert(paramArrayExpression Is Nothing)
             paramArrayExpression = New ArrayCreationExpression(paramArrayArg)
             paramArrayExpression.Init(ParamArrayParameter.ParameterType, New Expression() {})
 
             paramArrayArg.Init(ParamArrayParameter.Sequence, paramArrayExpression)
             exactArguments(inputParametersCount - 1) = paramArrayArg
 
             m_TypesInInvokedOrder(inputParametersCount - 1) = ParamArrayParameter.ParameterType
         End If
 
         Dim firstNamedArgument As Integer = Arguments.Count + 1
         For i As Integer = 0 To Arguments.Count - 1
             'First, match each positional argument in order to the list of method parameters. 
             'If there are more positional arguments than parameters and the last parameter 
             'is not a paramarray, the method is not applicable. Otherwise, the paramarray parameter 
             'is expanded with parameters of the paramarray element type to match the number
             'of positional arguments. If a positional argument is omitted, the method is not applicable.
             If Arguments(i).IsNamedArgument Then
                 firstNamedArgument = i
                 Exit For '(No more positional arguments)
             End If
 
             If inputParametersCount - 1 < i Then
                 '(more positional arguments than parameters)
                 If isLastParamArray = False Then '(last parameter is not a paramarray)
                     'LogResolutionMessage(Parent.Compiler, "N/A
                     Return False
                 End If
 
                 'Add the additional expressions to the param array creation expression.
                 Helper.Assert(paramArrayExpression.ArrayElementInitalizer.Initializers.Count = 1)
                 For j As Integer = i To Arguments.Count - 1
                     'A paramarray element has to be specified.
                     If Arguments(j).Expression Is Nothing Then
                         'LogResolutionMessage(Parent.Compiler, "N/A
                         Return False
                     End If
                     paramArrayExpression.ArrayElementInitalizer.AddInitializer(Arguments(j).Expression)
 
                     Helper.Assert(m_TypesInInvokedOrder(j) Is Nothing)
                     m_TypesInInvokedOrder(j) = CecilHelper.GetElementType(ParamArrayParameter.ParameterType)
                 Next
                 Exit For
             Else
                 matchedParameters.Add(InputParameters(i))
 
                 'Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                 m_TypesInInvokedOrder(i) = InputParameters(i).ParameterType
 
                 'Get the default value of the parameter if the specified argument has no expression.
                 Dim arg As Argument = Nothing
                 If Arguments(i).Expression Is Nothing Then
                     If InputParameters(i).IsOptional = False Then
                         Helper.Assert(False)
                     Else
                         Dim exp As Expression
                         Dim pArg As New PositionalArgument(Parent)
                         exp = Helper.GetOptionalValueExpression(pArg, InputParameters(i))
                         pArg.Init(InputParameters(i).Sequence, exp)
                         arg = pArg
                     End If
                 Else
                     arg = Arguments(i)
                 End If
 
                 If isLastParamArray = False Then exactArguments(i) = arg
                 If isLastParamArray AndAlso inputParametersCount - 1 = i Then
                     Helper.Assert(paramArrayExpression.ArrayElementInitalizer.Initializers.Count = 0)
                     paramArrayExpression.ArrayElementInitalizer.AddInitializer(arg.Expression)
                     'Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                     m_TypesInInvokedOrder(i) = CecilHelper.GetElementType(ParamArrayParameter.ParameterType)
                 Else
                     If isLastParamArray Then exactArguments(i) = arg
                 End If
             End If
             '??? If a positional argument is omitted, the method is not applicable.
         Next
 
 
         For i As Integer = firstNamedArgument To Arguments.Count - 1
             Helper.Assert(Arguments(i).IsNamedArgument)
 
             'Next, match each named argument to a parameter with the given name. 
             'If one of the named arguments fails to match, matches a paramarray parameter, 
             'or matches an argument already matched with another positional or named argument,
             'the method is not applicable.
 
             Dim namedArgument As NamedArgument = DirectCast(Arguments(i), NamedArgument)
 
             Dim matched As Boolean = False
             For j As Integer = 0 To inputParametersCount - 1
                 'Next, match each named argument to a parameter with the given name. 
                 Dim inputParam As Mono.Cecil.ParameterReference = InputParameters(j)
                 If Helper.CompareName(inputParam.Name, namedArgument.Name) Then
                     If matchedParameters.Contains(inputParam) Then
                         'If one of the named arguments (...) matches an argument already matched with 
                         'another positional or named argument, the method is not applicable
                         'LogResolutionMessage(Parent.Compiler, "N/A
                         Return False
                     ElseIf Helper.IsParamArrayParameter(Parent.Compiler, inputParam) Then
                         'If one of the named arguments (...) matches a paramarray parameter, 
                         '(...) the method is not applicable.
                         'LogResolutionMessage(Parent.Compiler, "N/A
                         Return False
                     Else
                         matchedParameters.Add(inputParam)
                         exactArguments(j) = Arguments(i)
 
                         Helper.Assert(m_TypesInInvokedOrder(j) Is Nothing)
                         m_TypesInInvokedOrder(j) = inputParam.ParameterType
                         matched = True
                         Exit For
                     End If
                 End If
             Next
             'If one of the named arguments fails to match (...) the method is not applicable
             If matched = False Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
         Next
 
         'Next, if parameters that have not been matched are not optional, 
         'the method is not applicable. If optional parameters remain, the default value 
         'specified in the optional parameter declaration is matched to the parameter. 
         'If an Object parameter does not specify a default value, then the expression 
         'System.Reflection.Missing.Value is used. If an optional Integer parameter 
         'has the Microsoft.VisualBasic.CompilerServices.OptionCompareAttribute attribute, 
         'then the literal 1 is supplied for text comparisons and the literal 0 otherwise.
 
         For i As Integer = 0 To inputParametersCount - 1
             If matchedParameters.Contains(InputParameters(i)) = False Then
                 'if parameters that have not been matched are not optional, the method is not applicable
                 If isLastParamArray = False AndAlso Helper.IsParamArrayParameter(Compiler, InputParameters(i)) Then
                     Return False
                 End If
                 If InputParameters(i).IsOptional = False AndAlso InputParameters(i) Is ParamArrayParameter = False Then
                     'LogResolutionMessage(Parent.Compiler, "N/A
                     Return False
                 End If
 
                 Dim exp As Expression
                 Dim arg As New PositionalArgument(Parent)
                 exp = Helper.GetOptionalValueExpression(arg, InputParameters(i))
                 arg.Init(InputParameters(i).Sequence, exp)
                 If isLastParamArray = False Then
                     Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                     m_TypesInInvokedOrder(i) = InputParameters(i).ParameterType
                     exactArguments(i) = arg
                 End If
                 If Helper.IsParamArrayParameter(Parent.Compiler, InputParameters(i)) = False Then
                     'he arraycreation has already been created and added to the exactArguments(1).
                     If isLastParamArray Then exactArguments(i) = arg
                 End If
             End If
         Next
 
         'Finally, if type arguments have been specified, they are matched against
         'the type parameter list. If the two lists do not have the same number of elements, 
         'the method is not applicable, unless the type argument list is empty. If the 
         'type argument list is empty, type inferencing is used to try and infer 
         'the type argument list. If type inferencing fails, the method is not applicable.
         'Otherwise, the type arguments are filled in the place of the 
         'type parameters in the signature.
         Dim genericTypeArgumentCount As Integer
         Dim genericTypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)
         If method IsNot Nothing AndAlso CecilHelper.IsGenericMethod(method) Then
             genericTypeArguments = CecilHelper.GetGenericArguments(method)
             genericTypeArgumentCount = genericTypeArguments.Count
         ElseIf prop IsNot Nothing Then
             'property cannot be generic.
         End If
 
         If genericTypeArgumentCount > 0 AndAlso (TypeArguments Is Nothing OrElse TypeArguments.List.Count = 0) Then
             'If the Then type argument list is empty, type inferencing is used to try and infer 
             'the type argument list.
             'Helper.NotImplementedYet("Type argument inference")
         ElseIf TypeArguments IsNot Nothing AndAlso TypeArguments.List.Count > 0 Then
             'If the two lists do not have the same number of elements, the method is not applicable
             If TypeArguments.List.Count <> genericTypeArgumentCount Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
 
             'Return m_Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Parent.Location)
             'Helper.NotImplemented("Type argument matching")
         End If
 
         m_ExactArguments = exactArguments
 
         Helper.AssertNotNothing(m_TypesInInvokedOrder)
 
         If ResolveUnresolvedExpressions() = False Then
             Return False
         End If
 
         Return True 'Method is applicable!!
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1463" endline="1489"><![CDATA[
 
     Function ResolveUnresolvedExpressions() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_ExactArguments.Count - 1
             Dim exp As Expression
             Dim expType As Mono.Cecil.TypeReference
 
             exp = m_ExactArguments(0).Expression
             expType = exp.ExpressionType
 
             If Helper.CompareType(expType, Compiler.TypeCache.DelegateUnresolvedType) = False Then Continue For
             If Helper.IsDelegate(Compiler, DefinedParameters(i).ParameterType) = False Then Return False
 
             Dim aoe As AddressOfExpression
             aoe = TryCast(exp, AddressOfExpression)
 
             If aoe IsNot Nothing Then
                 Dim exp2 As Expression
                 exp2 = exp.ReclassifyMethodPointerToValueExpression(DefinedParameters(i).ParameterType)
                 result = exp2.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
                 If result Then m_ExactArguments(0).Expression = exp2
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1490" endline="1501"><![CDATA[
 
     Sub SelectOutputArguments()
         If IsParamArrayCandidate Then
             Dim ace As ArrayCreationExpression
             ace = ParamArrayExpression ' TryCast(OutputArguments.Item(OutputArguments.Count - 1).Expression, ArrayCreationExpression)
             If ace IsNot Nothing AndAlso ace.IsResolved = False AndAlso Helper.IsParamArrayParameter(Compiler, InputParameters(InputParameters.Count - 1)) Then
                 If ace.ResolveExpression(ResolveInfo.Default(Compiler)) = False Then
                     Helper.ErrorRecoveryNotImplemented(Parent.Location)
                 End If
             End If
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="23" endline="27"><![CDATA[
     Overloads Shared Function IsKS(ByVal KS As KS, ByVal Mask As ModifierMasks) As Boolean
         If KS > KS.WriteOnly Then Return False
         Dim modifier As ModifierMasks = KSToMask(KS)
         Return (modifier And Mask) = modifier
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="28" endline="31"><![CDATA[
 
     Shared Function KSToMask(ByVal Modifier As KS) As ModifierMasks
         Return CType(1 << Modifier, ModifierMasks)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="32" endline="36"><![CDATA[
 
     ReadOnly Property Empty() As Boolean
         Get
             Return m_ModifierMask = 0
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="37" endline="41"><![CDATA[
     End Property
 
     Sub New(ByVal Mask As ModifierMasks)
         m_ModifierMask = Mask
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="42" endline="45"><![CDATA[
 
     Sub New(ByVal Modifiers As Modifiers)
         m_ModifierMask = Modifiers.m_ModifierMask
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="46" endline="50"><![CDATA[
 
     ReadOnly Property Mask() As ModifierMasks
         Get
             Return m_ModifierMask
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="51" endline="61"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifier(ByVal Modifier As KS) As Modifiers
         m_ModifierMask = m_ModifierMask Or KSToMask(Modifier)
         Return Me
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="62" endline="71"><![CDATA[
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifiers(ByVal Modifier As ModifierMasks) As Modifiers
         m_ModifierMask = m_ModifierMask Or Modifier
         Return Me
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="72" endline="84"><![CDATA[
 
     ''' <summary>
     ''' Returns true if the modifier Publis is set, or any other modifiers (Private, Friend, Protected) 
     ''' is not set.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property IsPublic() As Boolean
         Get
             Dim mask As ModifierMasks = ModifierMasks.AccessModifiers
             Return mask = ModifierMasks.Public OrElse mask = 0
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="85" endline="90"><![CDATA[
     End Property
 
     ReadOnly Property AccessibilityMask() As ModifierMasks
         Get
             Return m_ModifierMask And (ModifierMasks.Public Or ModifierMasks.Private Or ModifierMasks.Friend Or ModifierMasks.Protected)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="91" endline="96"><![CDATA[
     End Property
 
     ReadOnly Property [Is](ByVal Modifier As ModifierMasks) As Boolean
         Get
             Return (m_ModifierMask And Modifier) = Modifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="97" endline="102"><![CDATA[
     End Property
 
     ReadOnly Property IsAny(ByVal Modifier As ModifierMasks) As Boolean
         Get
             Return (m_ModifierMask And Modifier) > 0
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="103" endline="121"><![CDATA[
     End Property
 
     Function GetMethodAttributeScope() As Mono.Cecil.MethodAttributes
         If Me.Is(ModifierMasks.Public) Then
             Return Mono.Cecil.MethodAttributes.Public
         ElseIf Me.Is(ModifierMasks.Friend) Then
             If Me.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.MethodAttributes.FamORAssem
             Else
                 Return Mono.Cecil.MethodAttributes.Assembly
             End If
         ElseIf Me.Is(ModifierMasks.Protected) Then
             Return Mono.Cecil.MethodAttributes.Family
         ElseIf Me.Is(ModifierMasks.Private) Then
             Return Mono.Cecil.MethodAttributes.Private
         Else
             Return Mono.Cecil.MethodAttributes.Public
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="122" endline="147"><![CDATA[
 
     Function GetFieldAttributeScope(ByVal TypeDeclaration As TypeDeclaration) As Mono.Cecil.FieldAttributes
         If Me.Is(ModifierMasks.Public) Then
             Return Mono.Cecil.FieldAttributes.Public
         ElseIf Me.Is(ModifierMasks.Friend) Then
             If Me.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.FieldAttributes.FamORAssem
             Else
                 Return Mono.Cecil.FieldAttributes.Assembly
             End If
         ElseIf Me.Is(ModifierMasks.Protected) Then
             Return Mono.Cecil.FieldAttributes.Family
         ElseIf Me.Is(ModifierMasks.Private) Then
             Return Mono.Cecil.FieldAttributes.Private
         ElseIf Me.Is(ModifierMasks.Dim) OrElse Me.Is(ModifierMasks.Const) Then
             If TypeOf TypeDeclaration Is StructureDeclaration Then
                 Return Mono.Cecil.FieldAttributes.Public
             Else
                 Return Mono.Cecil.FieldAttributes.Private
             End If
         ElseIf TypeOf TypeDeclaration Is EnumDeclaration Then
             Return Mono.Cecil.FieldAttributes.Public
         Else
             Return Mono.Cecil.FieldAttributes.Private
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MustOverridePropertyDeclaration.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MustOverridePropertyDeclaration.vb" startline="32" endline="39"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\NamedBaseList.vb" startline="23" endline="26"><![CDATA[
     Shadows Function Add(ByVal Item As T) As T
         MyBase.Add(Item)
         Return Item
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\NamedBaseList.vb" startline="27" endline="31"><![CDATA[
 
     Default Shadows ReadOnly Property Item(ByVal index As Integer) As T
         Get
             Return DirectCast(MyBase.Item(index), T)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\NamedBaseList.vb" startline="32" endline="37"><![CDATA[
     End Property
 
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\NamedBaseList.vb" startline="38" endline="55"><![CDATA[
 
     ''' <summary>
     ''' Finds the list item with the specified name.
     ''' Returns nothing if nothing found.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal Name As String) As T
         Get
             For Each tp As T In Me
                 Dim t As INameable = CType(CObj(tp), INameable)
                 If Helper.CompareName(t.Name, Name) Then
                     Return tp
                 End If
             Next
             Return Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="31" endline="33"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="34" endline="38"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal TypeName As TypeName)
         m_Identifier = Identifier
         m_TypeName = TypeName
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="39" endline="43"><![CDATA[
 
     ReadOnly Property Identifier() As Identifier
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="44" endline="49"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As TypeName
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="50" endline="54"><![CDATA[
     End Property
 
     <Obsolete("No code to resolve here.")> Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="55" endline="62"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="63" endline="67"><![CDATA[
 
     Public Property Name() As String Implements INameable.Name
         Get
             Return m_Identifier.Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="68" endline="70"><![CDATA[
         Set(ByVal value As String)
             m_Identifier.Name = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="42" endline="44"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="45" endline="134"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As String, ByVal Symbol As KS, ByVal Operand1 As Operand, ByVal Operand2 As Operand, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Block As CodeBlock)
 
         Helper.Assert(Identifier Is Nothing Xor Symbol = KS.None)
 
         Dim mySignature As New FunctionSignature(Me)
         Dim parameters As New ParameterList(Me)
         Dim name As String
 
         parameters.Add(New Parameter(parameters, Operand1.Name, Operand1.TypeName))
         If Operand2 IsNot Nothing Then
             parameters.Add(New Parameter(parameters, Operand2.Name, Operand2.TypeName))
         End If
 
 
         If Identifier IsNot Nothing Then
             Dim opname As String
             opname = Identifier
             If Helper.CompareName(opname, "IsTrue") Then
                 name = "op_True"
             ElseIf Helper.CompareName(opname, "IsFalse") Then
                 name = "op_False"
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Select Case Symbol
                 Case KS.Add
                     If Operand2 IsNot Nothing Then
                         name = "op_Addition"
                     Else
                         name = "op_UnaryPlus"
                     End If
                 Case KS.Minus
                     If Operand2 IsNot Nothing Then
                         name = "op_Subtraction"
                     Else
                         name = "op_UnaryNegation"
                     End If
                 Case KS.Mult
                     name = "op_Multiply"
                 Case KS.IntDivision
                     name = "op_IntegerDivision"
                 Case KS.RealDivision
                     name = "op_Division"
                 Case KS.Concat
                     name = "op_Concatenate"
                 Case KS.Like
                     name = "op_Like"
                 Case KS.Mod
                     name = "op_Modulus"
                 Case KS.And
                     name = "op_BitwiseAnd"
                 Case KS.Or
                     name = "op_BitwiseOr"
                 Case KS.Xor
                     name = "op_ExclusiveOr"
                 Case KS.Power
                     name = "op_Exponent"
                 Case KS.ShiftLeft
                     name = "op_LeftShift"
                 Case KS.ShiftRight
                     name = "op_RightShift"
                 Case KS.Equals
                     name = "op_Equality"
                 Case KS.NotEqual
                     name = "op_Inequality"
                 Case KS.GT
                     name = "op_GreaterThan"
                 Case KS.LT
                     name = "op_LessThan"
                 Case KS.GE
                     name = "op_GreaterThanOrEqual"
                 Case KS.LE
                     name = "op_LessThanOrEqual"
                 Case KS.Not
                     name = "op_OnesComplement"
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
         Helper.Assert(name <> "")
         mySignature.Init(name, Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
 
         'm_Operator = [Operator]
         m_Operand1 = Operand1
         m_Operand2 = Operand2
 
         MyBase.Init(Modifiers, mySignature, Block)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="135" endline="140"><![CDATA[
 
 
     ReadOnly Property Operand1() As Operand
         Get
             Return m_operand1
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="141" endline="146"><![CDATA[
     End Property
 
     ReadOnly Property Operand2() As Operand
         Get
             Return m_Operand2
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="147" endline="164"><![CDATA[
     End Property
 
     ''' <summary>
     ''' OverloadableBinaryOperator  
     '''	"+" | "-" | "*" |  "/"  |  "\"  |  "&amp;" |  "Like"  |  "Mod"  |  "And"  |  "Or" |  "Xor"  |
     '''	"^" | "&lt;&lt;" |  "&gt;&gt;" | "="  |  "&lt;&gt;" | "&gt;" |  "&lt;" |  "&gt;="  |  "&lt;="
     ''' </summary>
     ''' <param name="token"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsOverloadableBinaryOperator(ByVal token As Token) As Boolean
         Return token = KS.Add OrElse token = KS.Minus OrElse token = KS.Mult _
         OrElse token = KS.IntDivision OrElse token = KS.RealDivision OrElse token = KS.Concat _
         OrElse token = KS.Like OrElse token = KS.Mod OrElse token = KS.And OrElse token = KS.Or _
         OrElse token = KS.Xor OrElse token = KS.Power OrElse token = KS.ShiftLeft _
         OrElse token = KS.ShiftRight OrElse token = KS.Equals OrElse token = KS.NotEqual _
         OrElse token = KS.GT OrElse token = KS.LT OrElse token = KS.GE OrElse token = KS.LE
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="165" endline="174"><![CDATA[
 
     ''' <summary>
     ''' OverloadableUnaryOperator  
     ''' </summary>
     ''' <param name="token"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsOverloadableUnaryOperator(ByVal token As Token) As Boolean
         Return token = KS.Add OrElse token = KS.Minus OrElse token = KS.Not OrElse token.Equals("IsTrue") OrElse token.Equals("IsFalse")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="175" endline="178"><![CDATA[
 
     Shared Function IsOverloadableOperator(ByVal token As Token) As Boolean
         Return IsOverloadableBinaryOperator(token) OrElse IsOverloadableUnaryOperator(token)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="179" endline="188"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.OperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.OperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         If IsOverloadableOperator(tm.PeekToken(i + 1)) = False Then Return False
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="42" endline="44"><![CDATA[
         Get
             Return m_ParameterBuilderCecil
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="45" endline="50"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="51" endline="61"><![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="62" endline="72"><![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         m_TypeName = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="73" endline="77"><![CDATA[
 
     ReadOnly Property ParameterIdentifier() As ParameterIdentifier
         Get
             Return m_ParameterIdentifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="78" endline="83"><![CDATA[
     End Property
 
     Shadows ReadOnly Property Parent() As ParameterList
         Get
             Return DirectCast(MyBase.Parent, ParameterList)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="84" endline="96"><![CDATA[
     End Property
 
     Sub Init(ByVal Attributes As Attributes, ByVal Modifiers As Modifiers, ByVal ParameterIdentifier As ParameterIdentifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         m_CustomAttributes = Attributes
         m_Modifiers = Modifiers
         m_ParameterIdentifier = ParameterIdentifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
 
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="97" endline="108"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParameterList = Nothing) As Parameter
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParameterList)
         Dim result As New Parameter(NewParent)
         result.m_CustomAttributes = m_CustomAttributes
         result.m_Modifiers = m_Modifiers
         result.m_ParameterIdentifier = m_ParameterIdentifier.Clone(result)
         If m_TypeName IsNot Nothing Then result.m_TypeName = m_TypeName.Clone(result)
         If m_ConstantExpression IsNot Nothing Then result.m_ConstantExpression = m_ConstantExpression.Clone(result)
         result.UpdateDefinition()
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="109" endline="113"><![CDATA[
 
     ReadOnly Property HasConstantValue() As Boolean
         Get
             Return m_ConstantExpression IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="114" endline="120"><![CDATA[
     End Property
 
     Property ConstantValue() As Object
         Get
             If m_ParameterBuilderCecil Is Nothing Then Return Nothing
             Return m_ParameterBuilderCecil.Constant
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="121" endline="128"><![CDATA[
         Set(ByVal value As Object)
             If TypeConverter.ConvertTo(Me, value, ParameterType, value) = False Then
                 Throw New NotImplementedException
             End If
             If value Is DBNull.Value Then value = Nothing
             m_ParameterBuilderCecil.Constant = value
             UpdateDefinition()
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="129" endline="134"><![CDATA[
     End Property
 
     Property CustomAttributes() As Attributes Implements IAttributableDeclaration.CustomAttributes
         Get
             Return m_CustomAttributes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="135" endline="137"><![CDATA[
         Set(ByVal value As Attributes)
             m_CustomAttributes = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="138" endline="143"><![CDATA[
     End Property
 
     Property ParameterAttributes() As Mono.Cecil.ParameterAttributes
         Get
             Return m_ParameterAttributes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="144" endline="147"><![CDATA[
         Set(ByVal value As Mono.Cecil.ParameterAttributes)
             m_ParameterAttributes = value
             UpdateDefinition()
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="148" endline="153"><![CDATA[
     End Property
 
     ReadOnly Property Position() As Integer
         Get
             Return Me.FindFirstParent(Of ParameterList).List.IndexOf(Me) + 1
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="154" endline="159"><![CDATA[
     End Property
 
     Property ParameterType() As Mono.Cecil.TypeReference
         Get
             Return m_ParameterBuilderCecil.ParameterType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="160" endline="165"><![CDATA[
         Set(ByVal value As Mono.Cecil.TypeReference)
             If value.FullName.Contains("Void") Then Stop
             If m_ParameterBuilderCecil Is Nothing Then UpdateDefinition()
             m_ParameterBuilderCecil.ParameterType = Helper.GetTypeOrTypeReference(Compiler, value)
             UpdateDefinition()
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="166" endline="172"><![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             If m_ParameterIdentifier Is Nothing Then Return Nothing
             Return m_ParameterIdentifier.Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="173" endline="176"><![CDATA[
         Set(ByVal value As String)
             m_ParameterIdentifier = New ParameterIdentifier(Me, value)
             UpdateDefinition()
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="177" endline="182"><![CDATA[
     End Property
 
     Public Property Modifiers() As Modifiers Implements IModifiable.Modifiers
         Get
             Return m_Modifiers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="183" endline="185"><![CDATA[
         Set(ByVal value As Modifiers)
             m_Modifiers = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="186" endline="191"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As TypeName
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="192" endline="196"><![CDATA[
     End Property
 
     <Obsolete("Call Define(Builder")> Public Overrides Function Define() As Boolean
         Throw New InternalException(Me)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="197" endline="233"><![CDATA[
 
     Public Sub UpdateDefinition()
         Dim Parent As MethodBaseDeclaration = FindFirstParent(Of MethodBaseDeclaration)()
         Dim Builder As Mono.Cecil.MethodDefinition = Nothing
 
         If Parent IsNot Nothing Then
             Builder = Parent.CecilBuilder
         Else
             'Helper.StopIfDebugging()
         End If
 
         If m_ParameterBuilderCecil Is Nothing Then
             m_ParameterBuilderCecil = New Mono.Cecil.ParameterDefinition(Nothing)
             m_ParameterBuilderCecil.Sequence = -1
             m_ParameterBuilderCecil.Annotations.Add(Compiler, Me)
         End If
 
         m_ParameterBuilderCecil.Name = Name
         m_ParameterBuilderCecil.IsOptional = Modifiers.Is(ModifierMasks.Optional)
 
         If Builder IsNot Nothing AndAlso m_ParameterBuilderCecil.Sequence = -1 Then
             Builder.Parameters.Add(m_ParameterBuilderCecil)
         End If
 
         If Me.Modifiers.Is(ModifierMasks.ParamArray) AndAlso m_ParamArrayAttribute Is Nothing Then
             m_ParamArrayAttribute = New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_ParamArrayAttribute__ctor))
             m_ParameterBuilderCecil.CustomAttributes.Add(m_ParamArrayAttribute)
         End If
 
         If m_ParameterBuilderCecil.IsOptional Then
             'm_ParameterBuilderCecil.Constant = TypeConverter.ConvertTo(Compiler, m_ConstantValue, ParameterType)
             m_ParameterBuilderCecil.HasDefault = True
         End If
         If m_ParameterBuilderCecil.ParameterType Is Nothing Then
             m_ParameterBuilderCecil.ParameterType = Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="234" endline="271"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveCode(Info) AndAlso result
 
         If m_ConstantExpression IsNot Nothing Then
             result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
         End If
 
         If Me.Modifiers.Is(ModifierMasks.Optional) Then
             m_ParameterAttributes = Mono.Cecil.ParameterAttributes.Optional
             If m_ConstantExpression Is Nothing Then
                 Helper.AddError(Me, "Optional parameters must have a constant expression.")
                 result = False
             ElseIf m_ConstantExpression.IsConstant = False Then
                 Helper.AddError(Me, "Optional expressions must be constant.")
                 result = False
             Else
                 Dim cv As Object = m_ConstantExpression.ConstantValue
                 result = TypeConverter.ConvertTo(Me, cv, ParameterType, cv) AndAlso result
                 If cv Is DBNull.Value Then
                     cv = Nothing
                 End If
                 ConstantValue = cv
             End If
         Else
             If m_ConstantExpression IsNot Nothing Then
                 Helper.AddError(Me, "Non-optional parameters cannot have constant expressions.")
                 result = False
             End If
         End If
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="272" endline="310"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_ConstantExpression, m_TypeName, m_ParameterIdentifier) AndAlso result
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         'If ParameterType Is Nothing Then
         If m_TypeName IsNot Nothing Then
             ParameterType = m_TypeName.ResolvedType
             If m_ParameterIdentifier.ArrayNameModifier IsNot Nothing Then
                 If m_TypeName.IsArrayTypeName Then
                     Helper.AddError(Me)
                 Else
                     ParameterType = m_ParameterIdentifier.ArrayNameModifier.CreateArrayType(ParameterType)
                 End If
             End If
         ElseIf m_ParameterIdentifier.Identifier.HasTypeCharacter Then
             ParameterType = TypeCharacters.TypeCharacterToType(Compiler, m_ParameterIdentifier.Identifier.TypeCharacter)
         ElseIf ParameterType Is Nothing OrElse Helper.CompareType(ParameterType, Compiler.TypeCache.System_Void) Then
             If Me.Location.File(Compiler).IsOptionStrictOn Then
                 Helper.AddError(Me, "Parameter type must be specified.")
             Else
                 Helper.AddWarning("Parameter type should be specified.")
             End If
             ParameterType = Compiler.TypeCache.System_Object
         End If
         'End If
         Helper.Assert(ParameterType IsNot Nothing)
         If m_Modifiers.Is(ModifierMasks.ByRef) Then
             ParameterType = Compiler.TypeManager.MakeByRefType(Me, ParameterType)
         End If
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="311" endline="320"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.CustomAttributes IsNot Nothing Then
             result = Me.CustomAttributes.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="32" endline="40"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParameterTypes() As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         If ParameterTypes IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In ParameterTypes
                 Add("", t)
             Next
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="41" endline="46"><![CDATA[
 
     Sub AddCloned(ByVal List As ParameterList)
         For i As Integer = 0 To List.Count - 1
             Add(List(i).Clone(Me))
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="47" endline="55"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterList(NewParent)
         For i As Integer = 0 To Me.Count - 1
             result.Add(Me.Item(i).Clone(result))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="56" endline="59"><![CDATA[
 
     Overloads Function Add(ByVal Name As String, ByVal Type As Mono.Cecil.TypeReference) As Parameter
         Return MyBase.Add(New Parameter(Me, Name, Type))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="60" endline="70"><![CDATA[
 
     ReadOnly Property AsParameterInfo() As Mono.Cecil.ParameterDefinition()
         Get
             If m_ParameterInfos Is Nothing Then
                 ReDim m_ParameterInfos(Me.Count - 1)
                 For i As Integer = 0 To Count - 1
                     m_ParameterInfos(i) = Me(i).CecilBuilder
                 Next
             End If
             Return m_ParameterInfos
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="71" endline="79"><![CDATA[
     End Property
 
     Function ToTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
         For i As Integer = 0 To Me.Count - 1
             result(i) = Me.Item(i).ParameterType
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="80" endline="98"><![CDATA[
 
     ''' <summary>
     ''' Resolves either all optional parameters or all non-optional parameters.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="OptionalParameters"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function ResolveParameters(ByVal Info As ResolveInfo, ByVal OptionalParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Count - 1
             If Me(i).Modifiers.Is(ModifierMasks.Optional) = OptionalParameters Then
                 result = Me(i).ResolveCode(Info) AndAlso result
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="99" endline="102"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return ResolveParameters(Info, False)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="30" endline="32"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="33" endline="36"><![CDATA[
 
     Sub Init(ByVal ParameterList As ParameterList)
         m_ParameterList = ParameterList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="37" endline="40"><![CDATA[
 
     Sub Init(ByVal NonArrayTypeName As NonArrayTypeName)
         m_NonArrayTypeName = NonArrayTypeName
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="41" endline="45"><![CDATA[
 
     ReadOnly Property Parameters() As ParameterList
         Get
             Return m_ParameterList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="46" endline="51"><![CDATA[
     End Property
 
     ReadOnly Property Type() As NonArrayTypeName
         Get
             Return m_NonArrayTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="52" endline="60"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then result = m_ParameterList.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="61" endline="73"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then
             result = m_ParameterList.ResolveTypeReferences AndAlso result
         End If
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="33" endline="35"><![CDATA[
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="36" endline="38"><![CDATA[
         Set(ByVal value As Identifier)
             m_Identifier = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="39" endline="43"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As Parameter)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="44" endline="48"><![CDATA[
 
     Sub New(ByVal Parent As Parameter, ByVal Name As String)
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="49" endline="53"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="54" endline="61"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="62" endline="71"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As Parameter = Nothing) As ParameterIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterIdentifier(NewParent)
         result.m_Identifier = m_Identifier
         If m_ArrayNameModifier IsNot Nothing Then
             result.m_ArrayNameModifier = m_ArrayNameModifier.clone(result)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="72" endline="76"><![CDATA[
 
     Shadows ReadOnly Property Parent() As Parameter
         Get
             Return DirectCast(MyBase.Parent, Parameter)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="77" endline="82"><![CDATA[
     End Property
 
     ReadOnly Property ArrayNameModifier() As ArrayNameModifier
         Get
             Return m_ArrayNameModifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="83" endline="88"><![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             Return m_Identifier.Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="89" endline="91"><![CDATA[
         Set(ByVal value As String)
             m_Identifier.Name = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="34" endline="36"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="37" endline="40"><![CDATA[
 
     Overloads Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal ReturnType As TypeName)
         Me.Init(Modifiers, New FunctionSignature(Me, Name, Nothing, ReturnType, Me.Location), Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="41" endline="44"><![CDATA[
 
     Overloads Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal ReturnType As Mono.Cecil.TypeReference)
         Me.Init(Modifiers, New FunctionSignature(Me, Name, Nothing, ReturnType, Me.Location), Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="45" endline="65"><![CDATA[
 
     Overloads Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As FunctionSignature, Optional ByVal GetMethod As PropertyGetDeclaration = Nothing, Optional ByVal SetMethod As PropertySetDeclaration = Nothing, Optional ByVal MemberImplementsClause As MemberImplementsClause = Nothing)
         MyBase.Init(Modifiers, Signature.Name)
 
         m_Signature = Signature
 
         If Modifiers.Is(ModifierMasks.ReadOnly) = False AndAlso SetMethod Is Nothing Then
             SetMethod = New PropertySetDeclaration(Me)
             SetMethod.Init(Modifiers, Nothing, Nothing, Nothing)
         End If
         If Modifiers.Is(ModifierMasks.WriteOnly) = False AndAlso GetMethod Is Nothing Then
             GetMethod = New PropertyGetDeclaration(Me)
             GetMethod.Init(Modifiers, Nothing, Nothing)
         End If
 
         m_Get = GetMethod
         m_Set = SetMethod
         m_MemberImplementsClause = MemberImplementsClause
 
         Helper.Assert(m_Signature IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="66" endline="70"><![CDATA[
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.PropertyDefinition
         Get
             Return m_CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="71" endline="76"><![CDATA[
     End Property
 
     Property HandlesField() As TypeVariableDeclaration
         Get
             Return m_HandlesField
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="77" endline="79"><![CDATA[
         Set(ByVal value As TypeVariableDeclaration)
             m_HandlesField = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="80" endline="88"><![CDATA[
     End Property
 
     ReadOnly Property Handlers() As Generic.List(Of AddOrRemoveHandlerStatement)
         Get
             If m_Handlers Is Nothing Then
                 m_Handlers = New Generic.List(Of AddOrRemoveHandlerStatement)
             End If
             Return m_Handlers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="89" endline="94"><![CDATA[
     End Property
 
     ReadOnly Property ImplementsClause() As MemberImplementsClause
         Get
             Return m_MemberImplementsClause
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="95" endline="100"><![CDATA[
     End Property
 
     ReadOnly Property CanRead() As Boolean
         Get
             Return Modifiers.Is(ModifierMasks.WriteOnly) = False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="101" endline="106"><![CDATA[
     End Property
 
     ReadOnly Property CanWrite() As Boolean
         Get
             Return Modifiers.Is(ModifierMasks.ReadOnly) = False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="107" endline="112"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property MemberDescriptor() As Mono.Cecil.MemberReference
         Get
             Return m_CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="113" endline="118"><![CDATA[
     End Property
 
     ReadOnly Property GetDeclaration() As MethodDeclaration
         Get
             Return m_Get
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="119" endline="124"><![CDATA[
     End Property
 
     ReadOnly Property SetDeclaration() As MethodDeclaration
         Get
             Return m_Set
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="125" endline="134"><![CDATA[
     End Property
 
     Public ReadOnly Property GetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Get IsNot Nothing Then
                 Return m_Get.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="135" endline="140"><![CDATA[
     End Property
 
     Public ReadOnly Property PropertyBuilder() As Mono.Cecil.PropertyDefinition
         Get
             Return m_CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="141" endline="150"><![CDATA[
     End Property
 
     Public ReadOnly Property SetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Set IsNot Nothing Then
                 Return m_Set.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="151" endline="156"><![CDATA[
     End Property
 
     Public Property Signature() As FunctionSignature
         Get
             Return m_Signature
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="157" endline="159"><![CDATA[
         Set(ByVal value As FunctionSignature)
             m_Signature = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="160" endline="173"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_Signature IsNot Nothing Then result = m_Signature.ResolveTypeReferences AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveTypeReferences AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveTypeReferences AndAlso result
 
         If m_MemberImplementsClause IsNot Nothing Then result = m_MemberImplementsClause.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="174" endline="179"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="180" endline="198"><![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_CecilBuilder Is Nothing Then
             m_CecilBuilder = New Mono.Cecil.PropertyDefinition(Name, 0, Helper.GetTypeOrTypeReference(Compiler, Me.Signature.ReturnType))
             m_CecilBuilder.Annotations.Add(Compiler, Me)
             DeclaringType.CecilType.Properties.Add(m_CecilBuilder)
         End If
         m_CecilBuilder.Name = Me.Name
         m_CecilBuilder.PropertyType = Helper.GetTypeOrTypeReference(Compiler, Me.Signature.ReturnType)
 
         If m_Get IsNot Nothing Then
             m_CecilBuilder.GetMethod = m_Get.CecilBuilder
         End If
         If m_Set IsNot Nothing Then
             m_CecilBuilder.SetMethod = m_Set.CecilBuilder
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="199" endline="218"><![CDATA[
 
     Public Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         result = m_Signature.ResolveCode(Info) AndAlso result
 
         If m_Get IsNot Nothing Then result = m_Get.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If Modifiers.Is(ModifierMasks.Default) Then
             Dim tp As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
             result = tp.SetDefaultAttribute(Me.Name) AndAlso result
         End If
 
         UpdateDefinition()
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="219" endline="228"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="229" endline="257"><![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         If m_Get IsNot Nothing Then
             result = m_Get.DefineMember() AndAlso result
         End If
 
         If m_Set IsNot Nothing Then
             result = m_Set.DefineMember AndAlso result
         End If
 
         Dim name As String
         Dim attributes As Mono.Cecil.PropertyAttributes
         Dim returnType As Mono.Cecil.TypeReference
         Dim parameterTypes() As Mono.Cecil.TypeReference
 
         name = Me.Name
         attributes = 0 'Mono.Cecil.PropertyAttributes.None
         returnType = Me.Signature.ReturnType
         parameterTypes = Me.Signature.Parameters.ToTypeArray
 
         Helper.SetTypeOrTypeBuilder(Compiler, parameterTypes)
         returnType = Helper.GetTypeOrTypeBuilder(Compiler, returnType)
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="258" endline="268"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Get IsNot Nothing Then result = m_Get.GenerateCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.GenerateCode(Info) AndAlso result
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" startline="30" endline="32"><![CDATA[
     Public Sub New(ByVal Parent As PropertyDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" startline="33" endline="74"><![CDATA[
 
     Public Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal ImplementsClause As MemberImplementsClause, ByVal Block As CodeBlock)
 
         Dim mySignature As FunctionSignature
 
         mySignature = New FunctionSignature(Me)
 
         Dim typeParams As TypeParameters
         Dim retTypeAttributes As Attributes
         Dim name As String
         Dim params As ParameterList
         Dim typename As TypeName
 
         If PropertySignature.TypeParameters IsNot Nothing Then
             typeParams = PropertySignature.TypeParameters.Clone()
             typeParams.Initialize(mySignature)
         Else
             typeParams = Nothing
         End If
         If PropertySignature.ReturnTypeAttributes IsNot Nothing Then
             retTypeAttributes = PropertySignature.ReturnTypeAttributes.Clone(mySignature)
         Else
             retTypeAttributes = Nothing
         End If
         If PropertySignature.Parameters IsNot Nothing Then
             params = PropertySignature.Parameters.Clone(Me)
         Else
             params = Nothing
         End If
         If PropertySignature.TypeName IsNot Nothing Then
             typename = PropertySignature.TypeName.Clone(mySignature)
         ElseIf PropertySignature.ReturnType IsNot Nothing Then
             typename = New TypeName(mySignature, PropertySignature.ReturnType)
         Else
             typename = Nothing
         End If
         name = "get_" & PropertySignature.Name
 
         mySignature.Init(New Identifier(mySignature, name, PropertySignature.Location, PropertySignature.Identifier.TypeCharacter), typeParams, params, retTypeAttributes, typename, PropertySignature.Location)
 
         MyBase.Init(Modifiers, mySignature, ImplementsClause, Block)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" startline="75" endline="82"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Get
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyHandlerDeclaration.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As PropertyDeclaration)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyHandlerDeclaration.vb" startline="26" endline="30"><![CDATA[
 
     Shadows ReadOnly Property Parent() As PropertyDeclaration
         Get
             Return DirectCast(MyBase.Parent, PropertyDeclaration)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyHandlerDeclaration.vb" startline="31" endline="36"><![CDATA[
     End Property
 
     ReadOnly Property PropertySignature() As FunctionSignature
         Get
             Return Parent.Signature
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="33" endline="35"><![CDATA[
     Public Sub New(ByVal Parent As PropertyDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="36" endline="110"><![CDATA[
 
     Public Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal ImplementsClause As MemberImplementsClause, ByVal Block As CodeBlock, ByVal SetParameters As ParameterList)
         Dim mySignature As SubSignature
         Dim name As String
         Dim typeParams As TypeParameters
         Dim params As ParameterList
         Dim manualValue As Boolean
 
         mySignature = New SubSignature(Me)
 
         If PropertySignature.TypeParameters IsNot Nothing Then
             typeParams = PropertySignature.TypeParameters.Clone()
             typeParams.Initialize(mySignature)
         Else
             typeParams = Nothing
         End If
         If SetParameters IsNot Nothing Then
             params = SetParameters
         Else
             params = New ParameterList(Me)
         End If
 
         Helper.Assert(CecilBuilder.Parameters.Count = params.Count)
 
         If params.Count = 1 Then
             manualValue = True
         Else
             manualValue = False
             If params.Count > 1 Then
                 Helper.AddError(Compiler, Me.Location, "Invalid set parameters, there should be only 0 or 1 parameters")
                 params.Clear()
             End If
         End If
 
         If PropertySignature.Parameters IsNot Nothing Then
             Dim tmp As Parameter = Nothing
             Dim ctmp As Mono.Cecil.ParameterDefinition = Nothing
 
             'The 'value' parameter should go at the end, so take it out of the list, add the other parameters, and add it back again
             If manualValue Then
                 tmp = params(0)
                 ctmp = CecilBuilder.Parameters(0)
                 params.Clear()
                 CecilBuilder.Parameters.Clear()
             End If
 
             For i As Integer = 0 To PropertySignature.Parameters.Count - 1
                 params.Add(PropertySignature.Parameters(i).Clone(params))
             Next
             If manualValue Then
                 params.Add(tmp)
                 CecilBuilder.Parameters.Add(ctmp)
                 ctmp.Sequence = CecilBuilder.Parameters.Count
             End If
         End If
 
         ' Setter without a 'value', create it automatically
         If manualValue = False Then
             Dim valueName As String = "value"
             Dim param As Parameter
             If PropertySignature.ReturnType IsNot Nothing Then
                 param = New Parameter(params, valueName, PropertySignature.ReturnType)
             Else
                 param = New Parameter(params, valueName, PropertySignature.TypeName)
                 param.ParameterIdentifier.Identifier.TypeCharacter = PropertySignature.Identifier.TypeCharacter
             End If
             params.Add(param)
         End If
 
         name = "set_" & PropertySignature.Name
 
         mySignature.Init(New Identifier(mySignature, name, PropertySignature.Location, PropertySignature.Identifier.TypeCharacter), typeParams, params)
 
         MyBase.Init(Modifiers, mySignature, ImplementsClause, Block)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="37" endline="39"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="40" endline="44"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal ParametersOrType As ParametersOrType, ByVal ImplementsClause As MemberImplementsClause)
         MyBase.Init(Modifiers, Identifier, ImplementsClause)
         m_ParametersOrType = ParametersOrType
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="45" endline="52"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="53" endline="57"><![CDATA[
 
     ReadOnly Property Parameters() As ParameterList
         Get
             Return m_ParametersOrType.Parameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="58" endline="63"><![CDATA[
     End Property
 
     ReadOnly Property Type() As NonArrayTypeName
         Get
             Return m_ParametersOrType.Type
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="64" endline="72"><![CDATA[
     End Property
 
     Public ReadOnly Property EventField() As Mono.Cecil.FieldDefinition
         Get
             Helper.Assert(m_Variable IsNot Nothing)
             Helper.Assert(m_Variable.IsFieldVariable)
             Helper.Assert(m_Variable.FieldBuilder IsNot Nothing)
             Return m_Variable.FieldBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="73" endline="185"><![CDATA[
     End Property
 
     Public Function CreateImplicitElements() As Boolean Implements IHasImplicitTypes.CreateImplicitTypes
         Dim result As Boolean = True
         'An event creates the following members.
         '1 - if the event is not an explicit delegate, and not an implemented interface event, a nested delegate in the 
         '    parent called (name)EventHandler.
         '    the parameters to the delegate are the same as for the event 
         '    accessability is the same as for the event.
         '2 - a private variable in the parent called (name)Event of type (name)EventHandler.
         '    (unless it is an interface)
         '3 - an add_(name) method in the parent with 1 parameter of type (name)EventHandler.
         '    accessability is the same as for the event.
         '4 - an remove_(name) method in the parent with 1 parameter of type (name)EventHandler.
         '    accessability is the same as for the event.
         '5 - possibly a raise_(name) method in the parent as well.
         '    accessability is the same as for the event.
         '    this method seems to be created only for custom events.
         '6 - an event in the parent called (name) with the add, remove and raise methods of 3, 4 & 5
         '    accessability is the same as for the event.
 
         If m_ElementsCreated Then Return result
         m_ElementsCreated = True
 
         Dim m_AddMethod As RegularEventHandlerDeclaration
         Dim m_RemoveMethod As RegularEventHandlerDeclaration
         Dim m_Parameters As ParameterList = Me.Parameters
         Dim m_Type As TypeName = Nothing
 
         If Me.Type IsNot Nothing Then m_Type = New TypeName(Me, Me.Type)
 
 
         'Create the delegate, if necessary.
         If ImplementsClause IsNot Nothing AndAlso ImplementsClause.ImplementsList.Count > 0 Then
             Dim ism As InterfaceMemberSpecifier
             ism = ImplementsClause.ImplementsList(0)
 
             Helper.Assert(ImplementsClause.ImplementsList.Count = 1)
             Helper.Assert(ism IsNot Nothing)
 
             result = ism.ResolveEarly() AndAlso result
 
             If result = False Then Return result
 
             Helper.Assert(ism.ResolvedEventInfo IsNot Nothing)
 
             Dim eD As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(ism.ResolvedEventInfo)
 
             If eD IsNot Nothing Then
                 If eD.EventType Is Nothing Then
                     Dim red As RegularEventDeclaration = TryCast(eD.Annotations(Compiler), RegularEventDeclaration)
                     If red IsNot Nothing Then
                         result = red.CreateImplicitElements AndAlso result
                         result = red.ResolveTypeReferences AndAlso result
                     End If
                 End If
                 Helper.Assert(eD.EventType IsNot Nothing)
                 EventType = eD.EventType
             Else
                 EventType = ism.ResolvedEventInfo.EventType
             End If
             m_Type = New TypeName(Me, EventType)
         ElseIf m_Parameters IsNot Nothing Then
             m_ImplicitEventDelegate = New DelegateDeclaration(DeclaringType, DeclaringType.Namespace, New SubSignature(m_ImplicitEventDelegate, Me.Name & "EventHandler", m_Parameters.Clone()))
             m_ImplicitEventDelegate.Modifiers = Me.Modifiers
             m_ImplicitEventDelegate.UpdateDefinition()
             If m_ImplicitEventDelegate.CreateImplicitElements() = False Then Helper.ErrorRecoveryNotImplemented(Me.Location)
 
             EventType = m_ImplicitEventDelegate.CecilType
         ElseIf m_Type IsNot Nothing Then
             m_ImplicitEventDelegate = Nothing
             'Helper.NotImplemented()
         Else
             Throw New InternalException(Me)
         End If
 
 
         'Create the variable.
         If DeclaringType.IsInterface = False Then
             Dim eventVariableModifiers As Modifiers
             m_Variable = New TypeVariableDeclaration(DeclaringType)
             eventVariableModifiers = New Modifiers(ModifierMasks.Private)
             If Me.IsShared Then eventVariableModifiers.AddModifiers(ModifierMasks.Shared)
             If m_ImplicitEventDelegate IsNot Nothing Then
                 m_Variable.Init(eventVariableModifiers, Me.Name & "Event", m_ImplicitEventDelegate.CecilType)
             Else
                 Helper.Assert(m_Type IsNot Nothing)
                 m_Variable.Init(eventVariableModifiers, Me.Name & "Event", m_Type)
             End If
         Else
             m_Variable = Nothing
         End If
 
         'Create the add method
         m_AddMethod = New RegularEventHandlerDeclaration(Me, Me.Modifiers, KS.AddHandler, Me.Identifier)
 
         'Create the remove method
         m_RemoveMethod = New RegularEventHandlerDeclaration(Me, Me.Modifiers, KS.RemoveHandler, Me.Identifier)
 
         Helper.Assert(m_AddMethod IsNot Nothing)
         Helper.Assert(m_AddMethod.Name <> "")
         Helper.Assert(m_RemoveMethod IsNot Nothing)
         Helper.Assert(m_RemoveMethod.Name <> "")
 
         'Add everything to the parent's members.
         If m_ImplicitEventDelegate IsNot Nothing Then DeclaringType.Members.Add(m_ImplicitEventDelegate)
         If m_Variable IsNot Nothing Then DeclaringType.Members.Add(m_Variable)
 
         MyBase.AddMethod = m_AddMethod
         MyBase.RemoveMethod = m_RemoveMethod
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="186" endline="209"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ParametersOrType.ResolveTypeReferences AndAlso result
         If EventType IsNot Nothing Then
             'Nothing to do
         ElseIf Type IsNot Nothing Then
             Helper.Assert(EventType Is Nothing)
             EventType = Type.ResolvedType
         ElseIf Parameters IsNot Nothing Then
             Helper.Assert(EventType IsNot Nothing OrElse ImplementsClause IsNot Nothing)
         Else
             Throw New InternalException(Me)
         End If
 
         If m_ImplicitEventDelegate IsNot Nothing Then
             result = m_ImplicitEventDelegate.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="25" endline="55"><![CDATA[
     Sub New(ByVal Parent As EventDeclaration, ByVal Modifiers As Modifiers, ByVal HandlerType As KS, ByVal EventName As Identifier)
         MyBase.new(Parent)
 
         Dim Code As ImplicitCodeBlock
         If (Parent.Modifiers.Is(ModifierMasks.MustOverride) OrElse DeclaringType.IsInterface) Then
             Code = Nothing
         Else
             Select Case HandlerType
                 Case KS.AddHandler
                     Code = New ImplicitCodeBlock(Me, New ImplicitCodeBlock.CodeGenerator(AddressOf CreateAddHandlerCode))
                 Case KS.RemoveHandler
                     Code = New ImplicitCodeBlock(Me, New ImplicitCodeBlock.CodeGenerator(AddressOf CreateRemoveHandlerCode))
                 Case KS.RaiseEvent
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     Code = Nothing
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
 
         MyBase.Init(Modifiers, HandlerType, EventName, New ParameterList(Me), Code)
 
         If DeclaringType.IsValueType Then
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
         ElseIf DeclaringType.IsInterface Then
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
         Else
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed Or Mono.Cecil.MethodImplAttributes.Synchronized
         End If
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="56" endline="68"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(EventParent.EventType IsNot Nothing)
         If Signature.Parameters.Count = 0 Then
             Signature.Parameters.Add(New Parameter(Signature.Parameters, "obj", EventParent.EventType))
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="69" endline="93"><![CDATA[
 
     Private Function CreateRemoveHandlerCode(ByVal Info As EmitInfo) As Boolean
         If Me.IsShared = False Then
             With Info.ILGen
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_1)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Remove), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         Else
             With Info.ILGen
                 .Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_0)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Remove), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         End If
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="94" endline="119"><![CDATA[
 
     Private Function CreateAddHandlerCode(ByVal Info As EmitInfo) As Boolean
         Helper.Assert([EventParent].EventField IsNot Nothing)
         If Me.IsShared = False Then
             With Info.ILGen
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_1)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         Else
             With Info.ILGen
                 .Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_0)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         End If
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="120" endline="124"><![CDATA[
 
     Shadows ReadOnly Property EventParent() As RegularEventDeclaration
         Get
             Return DirectCast(MyBase.EventParent, RegularEventDeclaration)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularPropertyDeclaration.vb" startline="32" endline="34"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularPropertyDeclaration.vb" startline="35" endline="42"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="38" endline="40"><![CDATA[
     Sub New(ByVal Parent As TypeDeclaration)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="41" endline="44"><![CDATA[
 
     Protected Sub New(ByVal Parent As PropertyDeclaration)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="45" endline="51"><![CDATA[
 
     Sub New(ByVal Parent As TypeDeclaration, ByVal Name As String, ByVal MethodAttributes As Mono.Cecil.MethodAttributes, ByVal ParameterTypes As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), New SubSignature(Me, Name, ParameterTypes))
         MyBase.MethodAttributes = MethodAttributes
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="52" endline="57"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_HandlesOrImplements IsNot Nothing Then m_HandlesOrImplements.Initialize(Me)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="58" endline="62"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature, ByVal Block As CodeBlock)
         MyBase.Init(Modifiers, Signature, Block)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="63" endline="68"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature, ByVal HandlesOrImplements As HandlesOrImplements, ByVal Block As CodeBlock)
         MyBase.Init(Modifiers, Signature, Block)
         m_HandlesOrImplements = HandlesOrImplements
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="69" endline="74"><![CDATA[
 
     Protected Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature, ByVal ImplementsClause As MemberImplementsClause, ByVal Block As CodeBlock)
         MyBase.Init(Modifiers, Signature, Block)
         If ImplementsClause IsNot Nothing Then m_HandlesOrImplements = New HandlesOrImplements(Me, ImplementsClause)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="75" endline="79"><![CDATA[
 
     Public Overrides ReadOnly Property HandlesOrImplements() As HandlesOrImplements
         Get
             Return m_HandlesOrImplements
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="80" endline="88"><![CDATA[
     End Property
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="89" endline="106"><![CDATA[
 
     Function DefineHandlesOrImplements() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then
             Dim hclause As HandlesClause = m_HandlesOrImplements.HandlesClause
             Dim iclause As MemberImplementsClause = m_HandlesOrImplements.ImplementsClause
             If hclause IsNot Nothing Then
                 'Helper.NotImplemented()
             ElseIf iclause IsNot Nothing Then
                 result = iclause.DefineImplements(Me.CecilBuilder)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="107" endline="119"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info Is Nothing Then
             Info = New EmitInfo(Me)
         End If
 
         result = DefineHandlesOrImplements() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="120" endline="129"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="130" endline="139"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveCode(Info) AndAlso result
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="140" endline="144"><![CDATA[
 
     ReadOnly Property IsMustOverride() As Boolean
         Get
             Return Modifiers.Is(ModifierMasks.MustOverride)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="145" endline="153"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Sub AndAlso tm.PeekToken(i + 1).IsIdentifier
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="48" endline="50"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="51" endline="61"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As Mono.Cecil.ParameterReference())
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         m_ParameterList = New ParameterList(Me)
         For i As Integer = 0 To Parameters.GetUpperBound(0)
             m_ParameterList.Add(Parameters(i).Name, Parameters(i).ParameterType)
         Next
         'Helper.Assert(m_Identifier IsNot Nothing)
         Helper.Assert(m_ParameterList IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="62" endline="71"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As ParameterList)
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = Parameters
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="72" endline="81"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = New ParameterList(Me, Parameters)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="82" endline="91"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         Helper.Assert(TypeOf Parent Is ClassDeclaration = False)
 
         If m_Identifier IsNot Nothing Then m_Identifier.Initialize(Me)
         If m_TypeParameters IsNot Nothing Then m_TypeParameters.Initialize(Me)
         If m_ParameterList IsNot Nothing Then m_ParameterList.Initialize(Me)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="92" endline="101"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList)
         m_Identifier = Identifier
         m_TypeParameters = TypeParameters
         If ParameterList Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = ParameterList
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="102" endline="105"><![CDATA[
 
     Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList)
         Me.Init(New Identifier(Me, Identifier, Nothing, TypeCharacters.Characters.None), TypeParameters, ParameterList)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="106" endline="112"><![CDATA[
 
     Overridable Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SubSignature
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SubSignature(NewParent)
         CloneTo(result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="113" endline="124"><![CDATA[
 
     Sub CloneTo(ByVal ClonedSignature As SubSignature)
         ClonedSignature.m_Identifier = m_Identifier
         If m_TypeParameters IsNot Nothing Then
             ClonedSignature.m_TypeParameters = m_TypeParameters.Clone()
             ClonedSignature.m_TypeParameters.Initialize(ClonedSignature)
         End If
         If m_ParameterList IsNot Nothing Then
             ClonedSignature.m_ParameterList = m_ParameterList.Clone(ClonedSignature)
             ClonedSignature.m_ParameterList.Initialize(ClonedSignature)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="125" endline="129"><![CDATA[
 
     ReadOnly Property Identifier() As Identifier
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="130" endline="135"><![CDATA[
     End Property
 
     Overridable ReadOnly Property ReturnType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeCache.System_Void
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="136" endline="142"><![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ParameterList
         Get
             Helper.Assert(m_ParameterList IsNot Nothing)
             Return m_ParameterList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="143" endline="148"><![CDATA[
     End Property
 
     Property TypeParameters() As TypeParameters
         Get
             Return m_TypeParameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="149" endline="151"><![CDATA[
         Set(ByVal value As TypeParameters)
             m_TypeParameters = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="152" endline="163"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveCode(info) AndAlso result
         If m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="164" endline="167"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return ResolveTypeReferences(True)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="168" endline="178"><![CDATA[
 
     Overridable Overloads Function ResolveTypeReferences(ByVal ResolveTypeParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveTypeReferences AndAlso result
         If ResolveTypeParameters = True AndAlso m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="179" endline="183"><![CDATA[
 
     Public Property Name() As String Implements INameable.Name
         Get
             Return m_Identifier.Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="184" endline="186"><![CDATA[
         Set(ByVal value As String)
             m_Identifier.Name = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="187" endline="201"><![CDATA[
     End Property
 
     Public Function VerifyParameterNamesDoesntMatchFunctionName() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Parameters.Count - 1
             Dim p As Parameter = Parameters(i)
 
             If Helper.CompareName(p.Name, Name) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30530, Me.Location)
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="36" endline="39"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="40" endline="45"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Modifiers, VariableIdentifier, IsNew, TypeName, VariableInitializer, ArgumentList)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Modifiers, VariableIdentifier, IsNew, TypeName, VariableInitializer, ArgumentList)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="46" endline="51"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Modifiers, VariableIdentifier, IsNew, TypeName, VariableInitializer, ArgumentList)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Modifiers, VariableIdentifier, IsNew, TypeName, VariableInitializer, ArgumentList)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Modifiers, VariableIdentifier, IsNew, TypeName, VariableInitializer, ArgumentList)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="52" endline="57"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Identifier, IsNew, TypeName, VariableInitializer, ArgumentList)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Modifiers, VariableIdentifier, IsNew, TypeName, VariableInitializer, ArgumentList)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Modifiers, VariableIdentifier, IsNew, TypeName, VariableInitializer, ArgumentList)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent, Identifier, IsNew, TypeName, VariableInitializer, ArgumentList)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="58" endline="64"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As Mono.Cecil.TypeReference)
         MyBase.Init(Modifiers, Name, VariableType)
         UpdateDefinition()
 
         Helper.Assert(FieldType IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="65" endline="70"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As TypeName)
         MyBase.Init(Modifiers, Name, VariableType)
         UpdateDefinition()
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="71" endline="75"><![CDATA[
 
     ReadOnly Property FieldBuilder() As Mono.Cecil.FieldDefinition Implements IFieldMember.FieldBuilder
         Get
             Return m_FieldBuilderCecil
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="76" endline="81"><![CDATA[
     End Property
 
     ReadOnly Property IsFieldVariable() As Boolean
         Get
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="82" endline="87"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property MemberDescriptor() As Mono.Cecil.MemberReference
         Get
             Return m_FieldBuilderCecil
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="88" endline="93"><![CDATA[
     End Property
 
     ReadOnly Property FieldType() As Mono.Cecil.TypeReference
         Get
             Return VariableType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="94" endline="99"><![CDATA[
     End Property
 
     Private ReadOnly Property FieldType2() As Mono.Cecil.TypeReference Implements IFieldMember.FieldType
         Get
             Return m_FieldBuilderCecil.FieldType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="100" endline="114"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         Helper.Assert(VariableType IsNot Nothing)
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="115" endline="120"><![CDATA[
 
     Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="121" endline="128"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="129" endline="145"><![CDATA[
 
     Overrides Sub UpdateDefinition()
         If Compiler Is Nothing Then Return
         MyBase.UpdateDefinition()
         Dim result As Boolean = True
 
         If m_FieldBuilderCecil Is Nothing Then
             m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(Name, Helper.GetAttributes(Compiler, Me), Helper.GetTypeOrTypeReference(Compiler, FieldType))
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderCecil)
         End If
         m_FieldBuilderCecil.Attributes = Helper.GetAttributes(Compiler, Me)
         If VariableType IsNot Nothing AndAlso m_FieldBuilderCecil.FieldType Is Nothing Then
             m_FieldBuilderCecil.FieldType = Helper.GetTypeOrTypeReference(Compiler, VariableType)
         End If
         m_FieldBuilderCecil.Name = Name
         m_FieldBuilderCecil.IsStatic = Me.IsShared
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="146" endline="151"><![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="152" endline="165"><![CDATA[
 
     Friend Function DefineStaticMember() As Boolean
         Dim result As Boolean = True
 
         If FieldBuilder Is Nothing Then
 
             Dim staticName As String
             staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name
             m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(staticName, Helper.GetAttributes(Compiler, Me), Helper.GetTypeOrTypeReference(Compiler, FieldType))
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderCecil)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="166" endline="176"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="177" endline="184"><![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="185" endline="190"><![CDATA[
 
     Protected Overrides Sub EmitThisIfNecessary(ByVal Info As EmitInfo)
         If FieldBuilder IsNot Nothing AndAlso FieldBuilder.IsStatic = False Then
             Emitter.EmitLoadMe(Info, FieldBuilder.DeclaringType)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="191" endline="223"><![CDATA[
 
     Public Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         If Me.Modifiers.Is(ModifierMasks.WithEvents) = False Then Return result
 
         Dim parentType As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim propertyAccessor As New PropertyDeclaration(parentType)
         Dim modifiers As Modifiers
 
         If Me.IsShared Then
             modifiers.AddModifiers(ModifierMasks.Shared)
         Else
             modifiers.AddModifier(KS.Overridable)
         End If
         If (Me.Modifiers.Mask And ModifierMasks.AccessModifiers) = 0 Then
             modifiers.AddModifier(KS.Private)
         Else
             modifiers.AddModifiers(Me.Modifiers.Mask And ModifierMasks.AccessModifiers)
         End If
 
         propertyAccessor.Init(modifiers, Name, Me.TypeName)
         result = propertyAccessor.ResolveTypeReferences() AndAlso result
         propertyAccessor.HandlesField = Me
         propertyAccessor.SetDeclaration.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.Synchronized
 
         Me.CustomAttributes.Add(New Attribute(Me, Compiler.TypeCache.System_Runtime_CompilerServices_AccessedThroughPropertyAttribute, Name))
         Rename("_" & Name)
 
         parentType.Members.Add(propertyAccessor)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="224" endline="227"><![CDATA[
 
     Public Function ResolveAndGetConstantValue(ByRef value As Object) As Boolean Implements IFieldMember.ResolveAndGetConstantValue
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="42" endline="44"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="45" endline="55"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="56" endline="66"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="67" endline="78"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), Identifier.Name)
 
         m_VariableIdentifier = New VariableIdentifier(Me, Identifier)
         m_IsNew = IsNew
         m_TypeName = New TypeName(Me, TypeName)
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="79" endline="84"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As Mono.Cecil.TypeReference)
         MyBase.Init(Modifiers, Name)
         m_VariableType = VariableType
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="85" endline="91"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As TypeName)
         MyBase.Init(Modifiers, Name)
         m_TypeName = VariableType
 
         Helper.Assert(m_TypeName IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="92" endline="96"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="97" endline="101"><![CDATA[
 
     ReadOnly Property DeclaringMethod() As MethodDeclaration
         Get
             Return Me.FindFirstParent(Of MethodDeclaration)()
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="102" endline="107"><![CDATA[
     End Property
 
     ReadOnly Property HasInitializer() As Boolean
         Get
             Return m_IsNew OrElse m_VariableInitializer IsNot Nothing OrElse (m_VariableIdentifier IsNot Nothing AndAlso m_VariableIdentifier.HasArrayNameModifier AndAlso m_VariableIdentifier.ArrayNameModifier.IsArraySizeInitializationModifier)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="108" endline="113"><![CDATA[
     End Property
 
     Public ReadOnly Property VariableType() As Mono.Cecil.TypeReference
         Get
             Return m_VariableType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="114" endline="119"><![CDATA[
     End Property
 
     ReadOnly Property VariableTypeOrTypeBuilder() As Mono.Cecil.TypeReference
         Get
             Return Helper.GetTypeOrTypeBuilder(Compiler, VariableType)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="120" endline="125"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As TypeName
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="126" endline="131"><![CDATA[
     End Property
 
     ReadOnly Property IsNew() As Boolean
         Get
             Return m_IsNew
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="132" endline="137"><![CDATA[
     End Property
 
     ReadOnly Property VariableInitializer() As VariableInitializer
         Get
             Return m_VariableInitializer
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="138" endline="143"><![CDATA[
     End Property
 
     ReadOnly Property ArgumentList() As ArgumentList
         Get
             Return m_ArgumentList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="144" endline="200"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         If m_VariableInitializer IsNot Nothing Then result = m_VariableInitializer.ResolveTypeReferences() AndAlso result
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         If m_VariableType Is Nothing Then 'the declaration might have been created with the type already.
             If m_TypeName IsNot Nothing Then
                 m_VariableType = m_TypeName.ResolvedType
 
                 If m_IsNew Then
                     If m_TypeName.IsNonArrayTypeName = False Then
                         result = Helper.AddError(Me) AndAlso result
                     End If
                     m_NewExpression = New DelegateOrObjectCreationExpression(Me, m_TypeName.AsNonArrayTypeName, m_ArgumentList)
                 End If
             ElseIf m_VariableIdentifier.Identifier.HasTypeCharacter Then
                 m_VariableType = TypeCharacters.TypeCharacterToType(Compiler, m_VariableIdentifier.Identifier.TypeCharacter)
             Else
                 If Me.Location.File(Compiler).IsOptionStrictOn Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30209, Me.Location) AndAlso result
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC42020, Me.Location) AndAlso result
                 End If
                 m_VariableType = Compiler.TypeCache.System_Object
             End If
         End If
 
         If m_VariableIdentifier IsNot Nothing AndAlso m_VariableIdentifier.HasArrayNameModifier Then
             If CecilHelper.IsArray(m_VariableType) Then
                 result = Helper.AddError(Me, "Cannot specify array modifier on both type name and on variable name.") AndAlso result
             Else
                 If m_VariableIdentifier.ArrayNameModifier.IsArraySizeInitializationModifier Then
                     m_VariableType = m_VariableIdentifier.ArrayNameModifier.AsArraySizeInitializationModifier.CreateArrayType(m_VariableType)
                 ElseIf m_VariableIdentifier.ArrayNameModifier.IsArrayTypeModifiers Then
                     m_VariableType = m_VariableIdentifier.ArrayNameModifier.AsArrayTypeModifiers.CreateArrayType(m_VariableType)
                 Else
                     Throw New InternalException(Me)
                 End If
             End If
         End If
 
         If m_NewExpression IsNot Nothing Then result = m_NewExpression.ResolveTypeReferences AndAlso result
 
         'Helper.Assert(m_FieldType IsNot Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="201" endline="221"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Report.Trace("{0}
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
 
         result = MyBase.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If m_NewExpression IsNot Nothing Then
             result = m_NewExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
         End If
 
         If m_VariableInitializer IsNot Nothing Then
             result = m_VariableInitializer.ResolveCode(New ExpressionResolveInfo(Compiler, VariableType)) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="222" endline="243"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             'If IsLocalVariable Then
             '    If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
             '    Helper.Assert(m_LocalBuilder IsNot Nothing)
             '    result = EmitVariableInitializer(Info) AndAlso result
             'ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
             '    result = EmitStaticInitializer(Info) AndAlso result
             'Else
             '    'Field builder has been defined in DefineMember
             '    'EmitVariableInitializer will be called by the constructor declaration
             'End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="244" endline="275"><![CDATA[
 
     Protected MustOverride Sub EmitThisIfNecessary(ByVal Info As EmitInfo)
     Protected MustOverride Sub EmitStore(ByVal Info As EmitInfo)
 
     Function EmitVariableInitializer(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim varType As Mono.Cecil.TypeReference = VariableType
 
         If m_VariableInitializer IsNot Nothing Then
             EmitThisIfNecessary(Info)
             result = m_VariableInitializer.GenerateCode(Info.Clone(Me, True, False, varType)) AndAlso result
 
             If m_VariableInitializer.InitializerExpression IsNot Nothing AndAlso Helper.CompareType(varType, Compiler.TypeCache.System_Object) AndAlso Helper.CompareType(m_VariableInitializer.ExpressionType, Compiler.TypeCache.System_Object) Then
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
             End If
             EmitStore(Info)
         ElseIf m_IsNew Then
             Helper.Assert(m_NewExpression IsNot Nothing)
             EmitThisIfNecessary(Info)
             result = m_NewExpression.GenerateCode(Info.Clone(Me, True, False, varType)) AndAlso result
             EmitStore(Info)
         End If
 
         If m_VariableIdentifier IsNot Nothing AndAlso m_VariableIdentifier.ArrayNameModifier IsNot Nothing AndAlso m_VariableIdentifier.ArrayNameModifier.IsArraySizeInitializationModifier Then
             EmitThisIfNecessary(Info)
             ArrayCreationExpression.EmitArrayCreation(Me, Info, varType, m_VariableIdentifier.ArrayNameModifier.AsArraySizeInitializationModifier)
             EmitStore(Info)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="276" endline="287"><![CDATA[
 
     ''' <summary>
     ''' Checks for this grammar
     ''' VariableMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         Return i > 0 AndAlso tm.PeekToken(i).IsIdentifier
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="32" endline="34"><![CDATA[
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="35" endline="39"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="40" endline="45"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier)
         MyBase.New(Parent)
         m_Identifier = Identifier
         If Identifier.Identifier Is Nothing Then Throw New InternalException("No identifier
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="46" endline="52"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
 
         If Identifier.Identifier Is Nothing Then Throw New InternalException("No identifier
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="53" endline="57"><![CDATA[
 
     ReadOnly Property ArrayNameModifier() As ArrayNameModifier
         Get
             Return m_ArrayNameModifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="58" endline="63"><![CDATA[
     End Property
 
     ReadOnly Property HasArrayNameModifier() As Boolean
         Get
             Return m_ArrayNameModifier IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="64" endline="69"><![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             Return m_Identifier.Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="70" endline="72"><![CDATA[
         Set(ByVal value As String)
             m_Identifier.Identifier = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifiers.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="31" endline="33"><![CDATA[
         Get
             Return m_Initializer
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="34" endline="38"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Initializer.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="39" endline="42"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="43" endline="47"><![CDATA[
 
     Sub Init(ByVal Initializer As ParsedObject)
         m_Initializer = Initializer
         Helper.StopIfDebugging(m_Initializer Is Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="48" endline="52"><![CDATA[
 
     ReadOnly Property InitializerExpression() As Expression
         Get
             Return TryCast(m_Initializer, Expression)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="53" endline="63"><![CDATA[
     End Property
 
     ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Dim exp As Expression = InitializerExpression
             If exp IsNot Nothing Then
                 Return exp.ExpressionType
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="64" endline="72"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Initializer.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="73" endline="109"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim expInfo As ExpressionResolveInfo = TryCast(Info, ExpressionResolveInfo)
 
         result = m_Initializer.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         Dim initExp As Expression = TryCast(m_Initializer, Expression)
         If initExp IsNot Nothing Then
             If initExp.Classification.IsValueClassification = False Then
                 If initExp.Classification.IsMethodPointerClassification Then
                     Dim exp As ExpressionResolveInfo = TryCast(Info, ExpressionResolveInfo)
                     If exp IsNot Nothing AndAlso exp.LHSType IsNot Nothing Then
                         initExp = initExp.ReclassifyMethodPointerToValueExpression(exp.LHSType)
                     Else
                         initExp = initExp.ReclassifyToValueExpression
                     End If
                 Else
                     initExp = initExp.ReclassifyToValueExpression
                 End If
                 result = initExp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             End If
 
             If result = False Then Return result
 
             If expInfo IsNot Nothing Then
                 initExp = Helper.CreateTypeConversion(Me, initExp, expInfo.LHSType, result)
             Else
                 Helper.StopIfDebugging()
             End If
             m_Initializer = initExp
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="110" endline="114"><![CDATA[
 
     ReadOnly Property IsRegularInitializer() As Boolean
         Get
             Return TypeOf m_Initializer Is Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="115" endline="120"><![CDATA[
     End Property
 
     ReadOnly Property AsRegularInitializer() As Expression
         Get
             Return DirectCast(m_Initializer, Expression)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="121" endline="126"><![CDATA[
     End Property
 
     ReadOnly Property IsArrayElementInitializer() As Boolean
         Get
             Return TypeOf m_Initializer Is ArrayElementInitializer
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="127" endline="132"><![CDATA[
     End Property
 
     ReadOnly Property AsArrayElementInitializer() As ArrayElementInitializer
         Get
             Return DirectCast(m_Initializer, ArrayElementInitializer)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializerList.vb" startline="27" endline="29"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="32" endline="38"><![CDATA[
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AttributeArgumentExpression.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="39" endline="46"><![CDATA[
 
     ReadOnly Property Identifier() As String
         Get
             If m_Identifier IsNot Nothing Then
                 Return m_Identifier
             End If
             Return m_IdentifierOrKeyword.Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="47" endline="52"><![CDATA[
     End Property
 
     ReadOnly Property AttributeArgumentExpression() As AttributeArgumentExpression
         Get
             Return m_AttributeArgumentExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="53" endline="57"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="58" endline="62"><![CDATA[
 
     Sub Init(ByVal Identifier As String, ByVal AttributeArgumentExpression As AttributeArgumentExpression)
         m_Identifier = Identifier
         m_AttributeArgumentExpression = AttributeArgumentExpression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="63" endline="67"><![CDATA[
 
     Sub Init(ByVal IdentifierOrKeyword As IdentifierOrKeyword, ByVal AttributeArgumentExpression As AttributeArgumentExpression)
         m_IdentifierOrKeyword = IdentifierOrKeyword
         m_AttributeArgumentExpression = AttributeArgumentExpression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="68" endline="76"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializer
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializer(NewParent)
         If m_IdentifierOrKeyword IsNot Nothing Then result.m_IdentifierOrKeyword = m_IdentifierOrKeyword.Clone(result)
         If m_AttributeArgumentExpression IsNot Nothing Then result.m_AttributeArgumentExpression = m_AttributeArgumentExpression.Clone(result)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="77" endline="81"><![CDATA[
 
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.IsIdentifierOrKeyword AndAlso tm.PeekToken.Equals(KS.Colon) AndAlso tm.PeekToken(2).Equals(KS.Equals)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" startline="30" endline="36"><![CDATA[
     Overloads Sub Add(ByVal Name As String, ByVal Value As Object)
         Dim var As New VariablePropertyInitializer(Me)
         Dim exp As New AttributeArgumentExpression(var)
         exp.Init(New ConstantExpression(var, Value, CecilHelper.GetType(Compiler, Value)))
         var.Init(Name, exp)
         Add(var)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" startline="37" endline="40"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return VariablePropertyInitializer.IsMe(tm)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" startline="41" endline="44"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" startline="45" endline="53"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializerList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializerList(NewParent)
         For Each item As VariablePropertyInitializer In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="31" endline="33"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     Private m_TypeCharacter As TypeCharacters.Characters = TypeCharacters.Characters.None
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="34" endline="39"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As String, ByVal Location As Span, ByVal TypeCharacter As TypeCharacters.Characters)
         MyBase.new(Parent, Location)
     Private m_TypeCharacter As TypeCharacters.Characters = TypeCharacters.Characters.None
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As String, ByVal Location As Span, ByVal TypeCharacter As TypeCharacters.Characters)
         MyBase.new(Parent, Location)
         m_Name = Identifier
         m_TypeCharacter = TypeCharacter
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="40" endline="43"><![CDATA[
 
     Sub New(ByVal Identifier As String)
     Private m_TypeCharacter As TypeCharacters.Characters = TypeCharacters.Characters.None
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As String, ByVal Location As Span, ByVal TypeCharacter As TypeCharacters.Characters)
         MyBase.new(Parent, Location)
         m_Name = Identifier
         m_TypeCharacter = TypeCharacter
     End Sub
 
     Sub New(ByVal Identifier As String)
         m_Name = Identifier
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="44" endline="49"><![CDATA[
 
     Sub Init(ByVal Identifier As String, ByVal Location As Span, ByVal TypeCharacter As TypeCharacters.Characters)
         Me.Location = Location
         m_Name = Identifier
         m_TypeCharacter = TypeCharacter
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="50" endline="54"><![CDATA[
 
     Property Identifier() As String
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="55" endline="57"><![CDATA[
         Set
             m_Name = Value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="58" endline="63"><![CDATA[
     End Property
 
     Property TypeCharacter() As TypeCharacters.Characters
         Get
             Return m_TypeCharacter
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="64" endline="66"><![CDATA[
         Set
             m_TypeCharacter = Value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="67" endline="72"><![CDATA[
     End Property
 
     ReadOnly Property HasTypeCharacter() As Boolean
         Get
             Return m_TypeCharacter <> TypeCharacters.Characters.None
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="73" endline="81"><![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Identifier
         Dim result As Identifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         result = New Identifier(NewParent)
         result.Init(m_Name, Location, m_TypeCharacter)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="82" endline="86"><![CDATA[
 
     Property Name() As String
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="87" endline="89"><![CDATA[
         Set(ByVal value As String)
             m_Name = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="34" endline="36"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="37" endline="40"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Location As Span)
         MyBase.New(Parent, location)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="41" endline="45"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal First As ParsedObject, ByVal Second As Token)
         MyBase.new(Parent)
         Me.Init(First, Second)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="46" endline="50"><![CDATA[
 
     Sub Init(ByVal First As ParsedObject, ByVal Second As Token)
         m_First = First
         m_Second = Second
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="51" endline="67"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As QualifiedIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New QualifiedIdentifier(NewParent, Me.Location)
 
         If Me.IsFirstGlobal Then
             result.Init(Me.FirstAsGlobal.Clone(result), m_Second)
         ElseIf Me.IsFirstIdentifier Then
             result.Init(Me.FirstAsIdentifier.Clone(result), m_Second)
         ElseIf Me.IsFirstQualifiedIdentifier Then
             result.Init(Me.FirstAsQualifiedIdentifier.Clone(result), m_Second)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="68" endline="72"><![CDATA[
 
     ReadOnly Property ResolvedType() As Mono.Cecil.TypeReference
         Get
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="73" endline="116"><![CDATA[
     End Property
 
     Function ResolveAsTypeName(ByVal AsAttributeTypeName As Boolean, Optional ByVal TypeArity As Integer = 0) As Boolean
         Dim result As Boolean = True
         Dim nri As New TypeNameResolutionInfo(Me, Me)
         Dim resolvedType As Mono.Cecil.TypeReference
 
         nri.IsAttributeTypeName = AsAttributeTypeName
         nri.TypeArgumentCount = TypeArity
         result = nri.Resolve() AndAlso result
         If result = False Then Return result
         If nri.FoundOnlyOneObject Then
             If nri.FoundIsType Then
                 resolvedType = nri.FoundAsType
             ElseIf nri.FoundIs(Of TypeParameter)() Then
                 resolvedType = nri.FoundAsType 'New TypeParameterDescriptor(nri.FoundAs(Of TypeParameter)())
             ElseIf nri.FoundIs(Of ImportsClause)() Then
                 Dim ic As ImportsClause = nri.FoundAs(Of ImportsClause)()
                 If ic.IsNamespaceClause Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30182, Me.Location)
                 ElseIf ic.AsAliasClause.Second.IsNamespaceImport Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30182, Me.Location)
                 Else
                     resolvedType = ic.AsAliasClause.Second.TypeImported
                     If resolvedType Is Nothing Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30002, Me.Location, ic.AsAliasClause.Name)
                     End If
                 End If
             Else
                 resolvedType = Nothing
                 Return Helper.AddError(Me, "Could not resolve
             End If
         ElseIf nri.FoundObjects.Count > 1 Then
             resolvedType = Nothing
             Return Helper.AddError(Me, "Could not resolve (>1 results)
         Else
             resolvedType = Nothing
             Return Helper.AddError(Me, "Could not resolve (no result)
         End If
 
         m_ResolvedType = resolvedType
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="117" endline="120"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return True 'Nothing to do here
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="121" endline="129"><![CDATA[
 
     ''' <summary>
     ''' Resolves this typename to a type.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ResolveAsTypeName() As Boolean
         Return ResolveAsTypeName(False)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="130" endline="134"><![CDATA[
 
     ReadOnly Property First() As ParsedObject
         Get
             Return m_First
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="135" endline="140"><![CDATA[
     End Property
 
     Property Second() As Token
         Get
             Return m_Second
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="141" endline="143"><![CDATA[
         Set(ByVal value As Token)
             m_Second = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="144" endline="149"><![CDATA[
     End Property
 
     ReadOnly Property FirstAsIdentifier() As Identifier
         Get
             Return DirectCast(m_First, Identifier)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="150" endline="155"><![CDATA[
     End Property
 
     ReadOnly Property IsFirstIdentifier() As Boolean
         Get
             Return TypeOf m_First Is Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="156" endline="161"><![CDATA[
     End Property
 
     ReadOnly Property IsFirstGlobal() As Boolean
         Get
             Return TypeOf m_First Is GlobalExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="162" endline="167"><![CDATA[
     End Property
 
     ReadOnly Property FirstAsGlobal() As GlobalExpression
         Get
             Return DirectCast(m_First, GlobalExpression)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="168" endline="173"><![CDATA[
     End Property
 
     ReadOnly Property FirstAsQualifiedIdentifier() As QualifiedIdentifier
         Get
             Return DirectCast(m_First, QualifiedIdentifier)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="174" endline="179"><![CDATA[
     End Property
 
     ReadOnly Property IsFirstQualifiedIdentifier() As Boolean
         Get
             Return TypeOf m_First Is QualifiedIdentifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="180" endline="209"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The complete name for this qualified identifier.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             If m_Name Is Nothing Then
                 m_Name = String.Empty
                 If m_First IsNot Nothing Then
                     Dim id As Identifier = TryCast(m_First, Identifier)
                     Dim qid As QualifiedIdentifier = TryCast(m_First, QualifiedIdentifier)
                     If id IsNot Nothing Then
                         m_Name = id.Name
                     ElseIf qid IsNot Nothing Then
                         m_Name = qid.Name
                     Else
                         m_Name = m_First.ToString
                     End If
                 Else
                     Throw New InternalException(Me)
                 End If
                 If Token.IsSomething(m_Second) Then
                     m_Name = m_Name & "." & m_Second.ToString
                 End If
             End If
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="210" endline="214"><![CDATA[
     End Property
 
     Shared Function CanBeQualifiedIdentifier(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.IsIdentifier OrElse tm.CurrentToken.Equals(KS.Global)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" startline="26" endline="28"><![CDATA[
         Get
             Return m_IsLeftSide
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" startline="29" endline="31"><![CDATA[
         Set(ByVal value As Boolean)
             m_IsLeftSide = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" startline="32" endline="37"><![CDATA[
     End Property
 
     Property Parent() As ParsedObject
         Get
             Return m_Parent
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" startline="38" endline="40"><![CDATA[
         Set(ByVal value As ParsedObject)
             m_Parent = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     Public Property IsInTypeOf() As Boolean
         Get
             Return m_IsInTypeOf
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" startline="47" endline="49"><![CDATA[
         Set(ByVal value As Boolean)
             m_IsInTypeOf = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" startline="50" endline="61"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Initializing constructor.
     ''' </summary>
     ''' <param name="LeftSide"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, Optional ByVal LeftSide As Boolean = False, Optional ByVal IsInTypeOf As Boolean = False)
         m_IsLeftSide = LeftSide
         m_IsInTypeOf = IsInTypeOf
         m_Parent = Parent
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParseAttributableInfo.vb" startline="26" endline="28"><![CDATA[
         Get
             Return m_Attributes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParseAttributableInfo.vb" startline="29" endline="34"><![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler, ByVal Attributes As Attributes)
         MyBase.new(Compiler)
         m_Attributes = Attributes
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="25" endline="27"><![CDATA[
     Protected Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="28" endline="31"><![CDATA[
 
     Protected Sub New(ByVal Parent As ParsedObject, ByVal Location As Span)
         MyBase.new(Parent, Location)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="32" endline="35"><![CDATA[
 
     Protected Sub New(ByVal Parent As Compiler)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="36" endline="39"><![CDATA[
 
     Protected Sub New()
         MyBase.New()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="40" endline="44"><![CDATA[
 
     Property HasErrors() As Boolean
         Get
             Return m_HasErrors
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="45" endline="47"><![CDATA[
         Set(ByVal value As Boolean)
             m_HasErrors = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="48" endline="53"><![CDATA[
     End Property
 
     Shadows Property Parent() As ParsedObject
         Get
             Return DirectCast(MyBase.Parent, ParsedObject)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="54" endline="56"><![CDATA[
         Set(ByVal value As ParsedObject)
             MyBase.Parent = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="57" endline="61"><![CDATA[
     End Property
 
     Overridable Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="31" endline="33"><![CDATA[
         Get
             Return m_ShowErrors
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="34" endline="39"><![CDATA[
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="40" endline="46"><![CDATA[
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
     Private m_ShowErrors As Boolean = True
 
     Private ReadOnly Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         tm = m_Compiler.tm
         Helper.Assert(tm IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="47" endline="53"><![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
     Private m_ShowErrors As Boolean = True
 
     Private ReadOnly Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         tm = m_Compiler.tm
         Helper.Assert(tm IsNot Nothing)
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
         m_Compiler = Compiler
         tm = New tm(Compiler, TokenReader)
         tm.NextToken()
         Helper.Assert(tm IsNot Nothing)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="54" endline="63"><![CDATA[
 
     Public Function Parse(ByVal RootNamespace As String, ByVal assembly As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = ParseAssemblyDeclaration(RootNamespace, assembly) AndAlso result
 
         result = Compiler.Report.Errors = 0 AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="64" endline="120"><![CDATA[
 
     ''' <summary>
     ''' Can be called multiple times. (Will just exit).
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseFileHeader(ByVal CodeFile As CodeFile, ByVal [Assembly] As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         Dim m_OptionExplicit As OptionExplicitStatement = CodeFile.OptionExplicit
         Dim m_OptionStrict As OptionStrictStatement = CodeFile.OptionStrict
         Dim m_OptionCompare As OptionCompareStatement = CodeFile.OptionCompare
         Dim m_OptionInfer As OptionInferStatement = CodeFile.OptionInfer
         Dim m_Imports As ImportsClauses = CodeFile.Imports
 
         While tm.CurrentToken.Equals(KS.Option)
             If OptionExplicitStatement.IsMe(tm) Then
                 If m_OptionExplicit IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Explicit") AndAlso result
                 End If
                 m_OptionExplicit = ParseOptionExplicitStatement(CodeFile)
                 If m_OptionExplicit Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionStrictStatement.IsMe(tm) Then
                 If m_OptionStrict IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Strict") AndAlso result
                 End If
                 m_OptionStrict = ParseOptionStrictStatement(CodeFile)
                 If m_OptionStrict Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionCompareStatement.IsMe(tm) Then
                 If m_OptionCompare IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Compare") AndAlso result
                 End If
                 m_OptionCompare = ParseOptionCompareStatement(CodeFile)
                 If m_OptionCompare Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionInferStatement.IsMe(tm) Then
                 If m_OptionInfer IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Infer") AndAlso result
                 End If
                 m_OptionInfer = ParseOptionInferStatement(CodeFile)
                 If m_OptionInfer Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30206, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Option)
             If OptionExplicitStatement.IsMe(tm) Then
                 If m_OptionExplicit IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Explicit") AndAlso result
                 End If
                 m_OptionExplicit = ParseOptionExplicitStatement(CodeFile)
                 If m_OptionExplicit Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionStrictStatement.IsMe(tm) Then
                 If m_OptionStrict IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Strict") AndAlso result
                 End If
                 m_OptionStrict = ParseOptionStrictStatement(CodeFile)
                 If m_OptionStrict Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionCompareStatement.IsMe(tm) Then
                 If m_OptionCompare IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Compare") AndAlso result
                 End If
                 m_OptionCompare = ParseOptionCompareStatement(CodeFile)
                 If m_OptionCompare Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionInferStatement.IsMe(tm) Then
                 If m_OptionInfer IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Infer") AndAlso result
                 End If
                 m_OptionInfer = ParseOptionInferStatement(CodeFile)
                 If m_OptionInfer Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30206, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         End While
 
         If m_Imports Is Nothing Then m_Imports = New ImportsClauses([Assembly])
         Dim tmpImportsStatements As Generic.List(Of ImportsStatement)
         tmpImportsStatements = ParseImportsStatements([Assembly])
         For Each imp As ImportsStatement In tmpImportsStatements
             m_Imports.AddRange(imp.Clauses)
         Next
 
         CodeFile.Init(m_OptionCompare, m_OptionStrict, m_OptionExplicit, m_OptionInfer, m_Imports)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="121" endline="148"><![CDATA[
     ''' <summary>
     ''' OptionCompareStatement  
     ''' CompareOption  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionCompareStatement(ByVal Parent As BaseObject) As OptionCompareStatement
         Dim result As New OptionCompareStatement(Parent)
 
         Dim m_IsBinary As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Compare")
 
         If tm.Accept("Text") Then
             m_IsBinary = False
         ElseIf tm.Accept("Binary") Then
             m_IsBinary = True
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30207, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsBinary)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="149" endline="174"><![CDATA[
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionInferStatement(ByVal Parent As BaseObject) As OptionInferStatement
         Dim result As New OptionInferStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Infer")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="175" endline="201"><![CDATA[
 
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionStrictStatement(ByVal Parent As BaseObject) As OptionStrictStatement
         Dim result As New OptionStrictStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Strict")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="202" endline="225"><![CDATA[
 
     ''' <summary>
     ''' OptionExplicitStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionExplicitStatement(ByVal Parent As BaseObject) As OptionExplicitStatement
         Dim result As New OptionExplicitStatement(Parent)
 
         Dim m_Off As Boolean
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Explicit")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30640, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="226" endline="239"><![CDATA[
 
     ''' <summary>
     ''' ImportsClauses  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClauses(ByVal Parent As ImportsStatement) As ImportsClauses
         Dim result As New ImportsClauses(Parent)
 
         If ParseList(Of ImportsClause)(result, New ParseDelegate_Parent(Of ImportsClause)(AddressOf ParseImportsClause), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="240" endline="271"><![CDATA[
 
     ''' <summary>
     ''' Parses clauses seen on the command line.
     ''' ImportsClauses  
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function ParseImportsClauses(ByVal Parent As ImportsClauses, ByVal str As String) As Boolean
         Dim result As Boolean = True
 
         For Each clause As String In str.Split(","c)
             If clause <> "" Then
                 Dim newClause As ImportsClause
                 newClause = ParseImportsClause(Parent, str)
                 If newClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
                 If Parent.Exists(newClause) Then
                     If newClause.IsNamespaceClause Then '
                         'ignore the duplication
                     ElseIf newClause.IsAliasClause Then
                         Parent.Compiler.Report.SaveMessage(Messages.VBNC30572, Span.CommandLineSpan, newClause.AsAliasClause.Name)
                     Else
                         Throw New InternalException("")
                     End If
                 Else
                     Parent.Add(newClause)
                 End If
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="272" endline="293"><![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(str) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="294" endline="315"><![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClause(ByVal Parent As ParsedObject) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(tm) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="316" endline="347"><![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' 
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsAliasClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         Dim values() As String = str.Split("="c)
         If values.Length <> 2 Then Return Nothing
 
         m_Identifier = New Identifier(result, values(0), Span.CommandLineSpan, TypeCharacters.Characters.None)
 
         m_Second = ParseImportsNamespaceClause(result, values(1))
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="348" endline="375"><![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsAliasClause(ByVal Parent As ParsedObject) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_Second = ParseImportsNamespaceClause(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="376" endline="397"><![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim qi As QualifiedIdentifier = Nothing
         qi = ParseQualifiedIdentifier(result, str)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(qi)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="398" endline="429"><![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim qi As QualifiedIdentifier
 
         qi = ParseQualifiedIdentifier(result)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result IsNot Nothing AndAlso tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             Dim ctn As ConstructedTypeName = Nothing
             tm.RestoreToPoint(iCurrent)
             ctn = ParseConstructedTypeName(result)
             If ctn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(ctn)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(qi)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="430" endline="481"><![CDATA[
 
     Private Function ParseAssemblyDeclaration(ByVal RootNamespace As String, ByVal assembly As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         Dim iLastLocation As Span
 
         Dim AssemblyAttributes As New Attributes(assembly)
 
         tm.NextToken() 'Goto the first token
 
         Do Until tm.CurrentToken.IsEndOfCode
 #If EXTENDEDDEBUG Then
             Dim iFileCount, iTotalFiles As Integer
             iFileCount += 1
             iTotalFiles = Me.Compiler.CommandLine.Files.Count
             Me.Compiler.Report.WriteLine(Report.ReportLevels.Debug, "Parsing file " & tm.CurrentToken.Location.File.FileName & " (" & iFileCount & " of " & iTotalFiles & " files)")
 #End If
             iLastLocation = tm.CurrentLocation
 
             While tm.AcceptNewLine
 
             End While
             While tm.AcceptNewLine
 
             End While
             '[  OptionStatement+  ]
             '[  ImportsStatement+  ]
 
             If Me.ParseFileHeader(tm.CurrentLocation.File(Compiler), assembly) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             ''	[  AttributesStatement+  ]
             'If vbnc.Attributes.IsMe(tm) Then
             '    If Me.ParseAttributes(result, AssemblyAttributes) = False Then
             '        Helper.ErrorRecoveryNot    Implemented()
             '    End If
             'End If
 
             '	[  NamespaceMemberDeclaration+  ]
             result = ParseAssemblyMembers(assembly, RootNamespace) AndAlso result
 
             While tm.AcceptNewLine
 
             End While
             While tm.AcceptNewLine
 
             End While
             tm.AcceptEndOfFile()
             If iLastLocation.Equals(tm.CurrentLocation) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         Loop
         Do Until tm.CurrentToken.IsEndOfCode
 #If EXTENDEDDEBUG Then
             Dim iFileCount, iTotalFiles As Integer
             iFileCount += 1
             iTotalFiles = Me.Compiler.CommandLine.Files.Count
             Me.Compiler.Report.WriteLine(Report.ReportLevels.Debug, "Parsing file " & tm.CurrentToken.Location.File.FileName & " (" & iFileCount & " of " & iTotalFiles & " files)")
 #End If
             iLastLocation = tm.CurrentLocation
 
             While tm.AcceptNewLine
 
             End While
             '[  OptionStatement+  ]
             '[  ImportsStatement+  ]
 
             If Me.ParseFileHeader(tm.CurrentLocation.File(Compiler), assembly) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             ''	[  AttributesStatement+  ]
             'If vbnc.Attributes.IsMe(tm) Then
             '    If Me.ParseAttributes(result, AssemblyAttributes) = False Then
             '        Helper.ErrorRecoveryNot    Implemented()
             '    End If
             'End If
 
             '	[  NamespaceMemberDeclaration+  ]
             result = ParseAssemblyMembers(assembly, RootNamespace) AndAlso result
 
             While tm.AcceptNewLine
 
             End While
             tm.AcceptEndOfFile()
             If iLastLocation.Equals(tm.CurrentLocation) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         Loop
 
         assembly.Init(AssemblyAttributes)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="482" endline="499"><![CDATA[
 
     ''' <summary>
     '''  Attributes 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         While AttributeBlock.IsMe(tm)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
         While AttributeBlock.IsMe(tm)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="500" endline="516"><![CDATA[
     ''' <summary>
     '''  Parses attributes (if any). Always returns something.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject) As Attributes
         Dim result As New Attributes(Parent)
 
         If Attributes.IsMe(tm) Then
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="517" endline="535"><![CDATA[
     ''' <summary>
     ''' AttributeBlock  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeBlock(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         tm.AcceptIfNotInternalError(KS.LT)
 
         If ParseAttributeList(Parent, Attributes) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result = tm.AcceptIfNotError(KS.GT) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="536" endline="554"><![CDATA[
 
     ''' <summary>
     ''' AttributeList  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeList(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         Do
             Dim Attribute As Attribute
             Attribute = ParseAttribute(Parent)
             If Attribute Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Attributes.Add(Attribute)
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="555" endline="591"><![CDATA[
 
     ''' <summary>
     ''' Attribute          
     ''' AttributeModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttribute(ByVal Parent As ParsedObject) As Attribute
         Dim result As New Attribute(Parent)
 
         Dim m_IsAssembly As Boolean
         Dim m_IsModule As Boolean
         Dim m_SimpleTypeName As SimpleTypeName = Nothing
         Dim m_AttributeArguments As AttributeArguments = Nothing
 
         If tm.Accept("Assembly") Then
             m_IsAssembly = True
             If tm.AcceptIfNotError(KS.Colon) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.Accept(KS.Module) Then
             m_IsModule = True
             If tm.AcceptIfNotError(KS.Colon) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_SimpleTypeName = ParseSimpleTypeName(result)
         If m_SimpleTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_AttributeArguments = ParseAttributeArguments(result)
                 If m_AttributeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_IsAssembly, m_IsModule, m_SimpleTypeName, m_AttributeArguments)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="592" endline="638"><![CDATA[
 
     ''' <summary>
     ''' AttributeArguments  
     '''     AttributePositionalArgumentList  |
     ''' 	AttributePositionalArgumentList  ,  VariablePropertyInitializerList  |
     '''	    VariablePropertyInitializerList
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeArguments(ByVal Parent As ParsedObject) As AttributeArguments
         Dim result As New AttributeArguments(Parent)
 
         Dim m_AttributePositionalArgumentList As New AttributePositionalArgumentList(result)
         Dim m_VariablePropertyInitializerList As New VariablePropertyInitializerList(result)
 
         If AttributePositionalArgumentList.CanBeMe(tm) Then
             Do
                 Dim newObject As AttributeArgumentExpression
                 newObject = ParseAttributeArgumentExpression(Parent)
                 If newObject Is Nothing Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 m_AttributePositionalArgumentList.Add(newObject)
 
                 If tm.CurrentToken = KS.Comma Then
                     Dim current As RestorablePoint = tm.GetRestorablePoint
                     tm.NextToken()
                     If AttributePositionalArgumentList.CanBeMe(tm) = False Then
                         tm.RestoreToPoint(current)
                         Exit Do
                     Else
                         tm.RestoreToPoint(current)
                     End If
                 End If
             Loop While tm.Accept(KS.Comma)
         End If
 
         If m_AttributePositionalArgumentList.Count = 0 OrElse tm.Accept(KS.Comma) Then
             If ParseList(Of VariablePropertyInitializer)(m_VariablePropertyInitializerList, New ParseDelegate_Parent(Of VariablePropertyInitializer)(AddressOf ParseVariablePropertyInitializer), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         result.Init(m_AttributePositionalArgumentList, m_VariablePropertyInitializerList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="639" endline="655"><![CDATA[
 
     ''' <summary>
     ''' Parses lists of type List 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseList(Of T As BaseObject)(ByVal List As BaseList(Of T), ByVal ParseMethod As ParseDelegate_Parent(Of T), ByVal Parent As ParsedObject) As Boolean
         Helper.Assert(List IsNot Nothing, "List was nothing, tm.CurrentToken=" & tm.CurrentLocation.ToString(Compiler))
         Do
             Dim newObject As T
             newObject = ParseMethod(Parent)
             If newObject Is Nothing Then
                 Return False
             End If
             List.Add(newObject)
         Loop While tm.Accept(KS.Comma)
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="656" endline="681"><![CDATA[
 
     Private Delegate Function ParseDelegate_Parent(Of T)(ByVal Parent As ParsedObject) As T
 
     ''' <summary>
     ''' VariablePropertyInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariablePropertyInitializer(ByVal Parent As ParsedObject) As VariablePropertyInitializer
         Dim result As New VariablePropertyInitializer(Parent)
 
         Dim m_IdentifierOrKeyword As IdentifierOrKeyword
         Dim m_AttributeArgumentExpression As AttributeArgumentExpression
 
         m_IdentifierOrKeyword = ParseIdentifierOrKeyword(result)
         If m_IdentifierOrKeyword Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_AttributeArgumentExpression = ParseAttributeArgumentExpression(result)
         If m_AttributeArgumentExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IdentifierOrKeyword, m_AttributeArgumentExpression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="682" endline="695"><![CDATA[
 
     Private Function ParseIdentifierOrKeyword(ByVal Parent As ParsedObject) As IdentifierOrKeyword
         Dim result As IdentifierOrKeyword
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             result = New IdentifierOrKeyword(Parent, tm.CurrentToken)
             tm.NextToken()
         Else
             Helper.AddError(Compiler, tm.CurrentLocation)
             result = Nothing
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="696" endline="720"><![CDATA[
 
     ''' <summary>
     ''' AttributeArgumentExpression  
     '''   ConstantExpression  |
     '''   GetTypeExpression  |
     '''   ArrayCreationExpression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeArgumentExpression(ByVal Parent As ParsedObject) As AttributeArgumentExpression
         Dim result As New AttributeArgumentExpression(Parent)
 
         Dim m_Expression As Expression
 
         If tm.CurrentToken = KS.GetType Then
             m_Expression = ParseGetTypeExpression(result)
         ElseIf tm.CurrentToken = KS.[New] Then
             m_Expression = ParseArrayCreationExpression(result)
         Else
             m_Expression = ParseExpression(result)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="721" endline="767"><![CDATA[
 
 
 
     ''' <summary>
     ''' Type | QualifiedIdentifier ( Of [TypeArityList] )
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseGetTypeTypeName(ByVal Parent As GetTypeExpression) As GetTypeTypeName
         'TypeName |
         'QualifiedIdentifier (Of [TypeArityList])
         'TypeArityList 
         ' , |
         ' TypeParameterList ,
         Dim result As New GetTypeTypeName(Parent)
 
         'First try to parse as typename, if no 
         'success try as qualifiedidentifier.
         Dim m_TypeName As TypeName
         Dim iCurPos As RestorablePoint = tm.GetRestorablePoint
 
         m_TypeName = ParseTypeName(result)
         If m_TypeName Is Nothing Then
             tm.RestoreToPoint(iCurPos)
 
             Dim qn As QualifiedIdentifier
 
             qn = ParseQualifiedIdentifier(result)
             If qn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             tm.AcceptIfNotInternalError(KS.LParenthesis)
             tm.AcceptIfNotError(KS.Of)
 
             Dim typeArity As Integer = 1
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
 
             tm.AcceptIfNotError(KS.RParenthesis)
 
             result.Init(qn, typeArity)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(m_TypeName)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="768" endline="813"><![CDATA[
 
     ''' <summary>
     ''' ArrayCreationExpression    
     ''' 
     ''' LAMESPEC? I think the following should be used
     ''' ArrayCreationExpression    
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayCreationExpression(ByVal Parent As ParsedObject) As ArrayCreationExpression
         Dim result As New ArrayCreationExpression(Parent)
 
         Dim m_ArrayElementInitializer As ArrayElementInitializer
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ArrayNameModifier As ArrayNameModifier
 
         tm.AcceptIfNotInternalError(KS.[New])
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.CurrentToken <> KS.LParenthesis Then
             If ShowErrors Then tm.AcceptIfNotError(KS.LParenthesis)
             Return Nothing
         End If
         If ArrayNameModifier.CanBeMe(tm) = False Then
             If ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC90007, tm.CurrentLocation, tm.CurrentToken.ToString)
             Return Nothing
         End If
 
         m_ArrayNameModifier = ParseArrayNameModifier(result)
         If m_ArrayNameModifier Is Nothing Then
             If m_ShowErrors = False Then Return Nothing
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.CurrentToken <> KS.LBrace Then
             If ShowErrors Then tm.AcceptIfNotError(KS.LBrace)
             Return Nothing
         End If
 
         m_ArrayElementInitializer = ParseArrayElementInitializer(result)
         If m_ArrayElementInitializer Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_NonArrayTypeName, m_ArrayNameModifier, m_ArrayElementInitializer)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="814" endline="839"><![CDATA[
 
     ''' <summary>
     ''' ArrayElementInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayElementInitializer(ByVal Parent As ParsedObject) As ArrayElementInitializer
         Dim result As New ArrayElementInitializer(Parent)
 
         Dim m_VariableInitializerList As VariableInitializerList
 
         m_VariableInitializerList = New VariableInitializerList(result)
 
         tm.AcceptIfNotInternalError(KS.LBrace)
         If tm.Accept(KS.RBrace) = False Then
 
             If ParseList(Of VariableInitializer)(m_VariableInitializerList, New ParseDelegate_Parent(Of VariableInitializer)(AddressOf ParseVariableInitializer), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_VariableInitializerList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="840" endline="862"><![CDATA[
 
     ''' <summary>
     ''' VariableInitializer  
     ''' RegularInitializer 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableInitializer(ByVal Parent As ParsedObject) As VariableInitializer
         Dim result As New VariableInitializer(Parent)
 
         If ArrayElementInitializer.CanBeMe(tm) Then
             Dim newAEI As ArrayElementInitializer
             newAEI = ParseArrayElementInitializer(Parent)
             If newAEI Is Nothing Then Return Nothing
             result.Init(newAEI)
         Else
             Dim newExp As Expression
             newExp = ParseExpression(Parent)
             If newExp Is Nothing Then Return Nothing
             result.Init(newExp)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="863" endline="889"><![CDATA[
 
     ''' <summary>
     ''' ArrayNameModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayNameModifier(ByVal Parent As ParsedObject) As ArrayNameModifier
         Dim result As New ArrayNameModifier(Parent)
 
         If ArrayTypeModifiers.CanBeMe(tm) Then
             Dim newATM As ArrayTypeModifiers
             newATM = ParseArrayTypeModifiers(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(newATM)
         ElseIf ArraySizeInitializationModifier.CanBeMe(tm) Then
             Dim newASIM As ArraySizeInitializationModifier
             newASIM = ParseArraySizeInitializationModifer(result)
             If newASIM Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             result.Init(newASIM)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="890" endline="921"><![CDATA[
 
     ''' <summary>
     ''' ArraySizeInitializationModifier  
     ''' LAMESPEC this might be correct? REMOVED, CURRENTLY USING ^ SPEC!
     ''' ArraySizeInitializationModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArraySizeInitializationModifer(ByVal Parent As ParsedObject) As ArraySizeInitializationModifier
         Dim result As New ArraySizeInitializationModifier(Parent)
 
         Dim m_BoundList As BoundList = Nothing
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers = Nothing
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_BoundList = ParseBoundList(result)
         If m_BoundList Is Nothing Then
             If m_ShowErrors = False Then Return Nothing
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayTypeModifiers.CanBeMe(tm) Then
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(result)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_BoundList, m_ArrayTypeModifiers)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="922" endline="946"><![CDATA[
 
     ''' <summary>
     ''' InterfaceBase   
     ''' InterfaceBases  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceBases(ByVal Parent As ParsedObject) As InterfaceBases
         Dim result As New InterfaceBases(Parent)
         Dim tmp As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         If tmp.Count <= 0 Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="947" endline="971"><![CDATA[
 
     ''' <summary>
     ''' TypeImplementsClause  
     ''' Implements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeImplementsClauses(ByVal Parent As ParsedObject) As TypeImplementsClauses
         Dim result As New TypeImplementsClauses(Parent)
 
         Dim m_Clauses As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="972" endline="997"><![CDATA[
 
     ''' <summary>
     ''' BoundList
     ''' UpperBoundList
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseBoundList(ByVal Parent As ParsedObject) As BoundList
         Dim result As New BoundList(Parent)
 
         Dim newExp As Expression = Nothing
         Dim tmp As New Generic.List(Of Expression)
 
         Do
             If tm.CurrentToken.IsIntegerLiteral AndAlso tm.CurrentToken.IntegralLiteral = 0 AndAlso tm.PeekToken.Equals(KS.To) Then tm.NextToken(2)
             newExp = ParseExpression(result)
             If newExp Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             tmp.Add(newExp)
         Loop While tm.Accept(KS.Comma)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="998" endline="1062"><![CDATA[
 
     ''' <summary>
     ''' NonArrayTypeName  
     ''' SimpleTypeName    
     ''' BuiltInTypeName   
     ''' PrimitiveTypeName      
     ''' NumericTypeName        
     ''' IntegralTypeName       
     ''' FloatingPointTypeName  
     ''' ConstructedTypeName    
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseNonArrayTypeName(ByVal Parent As ParsedObject) As NonArrayTypeName
         Dim result As New NonArrayTypeName(Parent)
 
         Dim m_SimpleTypeName As SimpleTypeName
         Dim m_ConstructedTypeName As ConstructedTypeName
 
         m_SimpleTypeName = ParseSimpleTypeName(result)
 
         If m_SimpleTypeName Is Nothing Then Return Nothing
 
         If m_SimpleTypeName.IsQualifiedIdentifier AndAlso tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             Dim m_TypeArgumentList As TypeArgumentList
             Dim m_Q As QualifiedIdentifier
             Dim m_NestedTypeName As ConstructedTypeName
 
             m_TypeArgumentList = ParseTypeArgumentList(result)
             If m_TypeArgumentList Is Nothing Then Return Nothing
             m_ConstructedTypeName = New ConstructedTypeName(result)
             m_ConstructedTypeName.Init(m_SimpleTypeName.AsQualifiedIdentifier, m_TypeArgumentList)
 
             Do While tm.Accept(KS.Dot)
                 m_Q = ParseQualifiedIdentifier(result)
                 m_TypeArgumentList = Nothing
 
                 m_NestedTypeName = New ConstructedTypeName(m_ConstructedTypeName)
 
                 If tm.Accept(KS.LParenthesis) Then
                     tm.AcceptIfNotError(KS.Of)
 
                     m_TypeArgumentList = New TypeArgumentList(m_NestedTypeName)
                     If ParseList(Of TypeName)(m_TypeArgumentList, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
 
                     tm.AcceptIfNotError(KS.RParenthesis)
                 End If
 
                 m_NestedTypeName.Init(m_ConstructedTypeName, m_Q, m_TypeArgumentList)
 
                 m_ConstructedTypeName = m_NestedTypeName
             Loop
             Do While tm.Accept(KS.Dot)
                 m_Q = ParseQualifiedIdentifier(result)
                 m_TypeArgumentList = Nothing
 
                 m_NestedTypeName = New ConstructedTypeName(m_ConstructedTypeName)
 
                 If tm.Accept(KS.LParenthesis) Then
                     tm.AcceptIfNotError(KS.Of)
 
                     m_TypeArgumentList = New TypeArgumentList(m_NestedTypeName)
                     If ParseList(Of TypeName)(m_TypeArgumentList, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
 
                     tm.AcceptIfNotError(KS.RParenthesis)
                 End If
 
                 m_NestedTypeName.Init(m_ConstructedTypeName, m_Q, m_TypeArgumentList)
 
                 m_ConstructedTypeName = m_NestedTypeName
             Loop
 
             result.Init(m_ConstructedTypeName)
         Else
             result.Init(m_SimpleTypeName)
         End If
 
         If tm.Accept(KS.Interrogation) Then
             result.IsNullable = True
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1063" endline="1108"><![CDATA[
 
     ''' <summary>
     ''' ConstructedTypeName 
     '''     QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''     ConstructedTypeName "." QualifiedIdentifier [LAMESPEC]
     '''     ConstructedTypeName "." QualifiedIdentifier "(" "Of" TypeArgumentList ")" [LAMESPEC]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstructedTypeName(ByVal Parent As ParsedObject) As ConstructedTypeName
         Dim result As ConstructedTypeName
         Dim current As ConstructedTypeName
 
         Dim m_QualifiedIdentifier As QualifiedIdentifier
         Dim m_TypeArgumentList As TypeArgumentList
 
         current = Nothing
 
         Do
 
             If current Is Nothing Then
                 result = New ConstructedTypeName(Parent)
             Else
                 result = New ConstructedTypeName(current)
             End If
 
             m_QualifiedIdentifier = ParseQualifiedIdentifier(result)
             If m_QualifiedIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_TypeArgumentList = Nothing
 
             If tm.Accept(KS.LParenthesis) Then
                 tm.AcceptIfNotError(KS.Of)
 
                 If ParseList(Of TypeName)(m_TypeArgumentList, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             result.Init(current, m_QualifiedIdentifier, m_TypeArgumentList)
 
             current = result
         Loop While tm.Accept(KS.Dot)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1109" endline="1128"><![CDATA[
 
 
     ''' <summary>
     ''' TypeArgumentList 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeArgumentList(ByVal Parent As ParsedObject) As TypeArgumentList
         Dim result As New TypeArgumentList(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
         tm.AcceptIfNotInternalError(KS.Of)
 
         If ParseList(Of TypeName)(result, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
             Return Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1129" endline="1168"><![CDATA[
 
 
     ''' <summary>
     ''' TypeName 
     ''' 
     ''' ArrayTypeName          
     ''' ArrayTypeModifiers     
     ''' ArrayTypeModifier      
     ''' RankList               
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeName(ByVal Parent As ParsedObject) As TypeName
         Dim result As New TypeName(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers
         Dim m_ArrayTypeName As ArrayTypeName
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If m_NonArrayTypeName Is Nothing Then Return Nothing
 
         If ArrayTypeName.CanBeArrayTypeModifier(tm) Then
             m_ArrayTypeName = New ArrayTypeName(Parent)
 
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(m_ArrayTypeName)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             m_NonArrayTypeName.Parent = m_ArrayTypeName
 
             m_ArrayTypeName.Init(m_NonArrayTypeName, m_ArrayTypeModifiers)
 
             result.Init(m_ArrayTypeName)
         Else
             result.Init(m_NonArrayTypeName)
         End If
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1169" endline="1188"><![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifiers  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifiers(ByVal Parent As ParsedObject) As ArrayTypeModifiers
         Dim result As New ArrayTypeModifiers(Parent)
 
         Dim tmp As New Generic.List(Of ArrayTypeModifier)
         Do
             Dim newATM As ArrayTypeModifier
             newATM = ParseArrayTypeModifier(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             tmp.Add(newATM)
         Loop While ArrayTypeModifier.CanBeMe(tm)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1189" endline="1210"><![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifier  
     ''' RankList  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifier(ByVal Parent As ParsedObject) As ArrayTypeModifier
         Dim result As New ArrayTypeModifier(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         Dim m_Ranks As Integer
         Do
             m_Ranks += 1
         Loop While tm.Accept(KS.Comma)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Ranks)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1211" endline="1243"><![CDATA[
 
     ''' <summary>
     ''' SimpleTypeName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleTypeName(ByVal Parent As ParsedObject) As SimpleTypeName
         Dim result As New SimpleTypeName(Parent)
 
         If BuiltInTypeName.IsBuiltInTypeName(tm) Then
             Dim m_BuiltInTypeName As BuiltInTypeName
             m_BuiltInTypeName = ParseBuiltinTypeName(result)
             If m_BuiltInTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_BuiltInTypeName)
         Else
             Dim m_QualifiedIdentifier As QualifiedIdentifier
 
             If QualifiedIdentifier.CanBeQualifiedIdentifier(tm) = False Then
                 If tm.CurrentToken.IsKeyword Then
                     Compiler.Report.ShowMessage(Messages.VBNC30180, tm.CurrentLocation)
                     tm.NextToken()
                 End If
                 Return Nothing
             End If
 
             m_QualifiedIdentifier = ParseQualifiedIdentifier(result)
             If m_QualifiedIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_QualifiedIdentifier)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1244" endline="1278"><![CDATA[
 
     Private Shared Function ParseQualifiedIdentifier(ByVal Parent As ParsedObject, ByVal str As String) As QualifiedIdentifier
         Dim result As New QualifiedIdentifier(Parent)
 
         Dim m_First As ParsedObject
         Dim m_Second As Token = Nothing
 
         Dim first As String
         Dim second As String = Nothing
         Dim isplit As Integer = str.LastIndexOf("."c)
 
         If isplit >= 0 Then
             first = str.Substring(0, isplit)
             second = str.Substring(isplit + 1)
         Else
             first = str
         End If
 
         If first.Contains("."c) Then
             m_First = ParseQualifiedIdentifier(result, first)
             If m_First Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
         ElseIf first.Length > 7 AndAlso Helper.CompareName(first.Substring(1, 7), "Global.") Then
             m_First = New GlobalExpression(result)
         Else
             m_First = New Identifier(Parent, first, Parent.Location, TypeCharacters.Characters.None)
         End If
 
         If second IsNot Nothing Then
             m_Second = Token.CreateIdentifierToken(Span.CommandLineSpan, second)
         End If
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1279" endline="1317"><![CDATA[
 
     ''' <summary>
     ''' QualifiedIdentifier 
     ''' 
     ''' Call if CurrentToken is identifier or "Global".
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseQualifiedIdentifier(ByVal Parent As ParsedObject) As QualifiedIdentifier
         Dim result As New QualifiedIdentifier(Parent)
 
         Helper.Assert(vbnc.QualifiedIdentifier.CanBeQualifiedIdentifier(tm))
 
         Dim m_First As ParsedObject
         Dim m_Second As Token = Nothing
 
         If tm.CurrentToken.IsIdentifier Then
             m_First = ParseIdentifier(result)
         ElseIf tm.CurrentToken.Equals(KS.Global) Then
             m_First = ParseGlobalExpression(result)
             If tm.CurrentToken <> KS.Dot Then Return Nothing
         Else
             Throw New InternalException(result)
         End If
 
         While tm.Accept(KS.Dot)
             If Token.IsSomething(m_Second) Then m_First = New QualifiedIdentifier(Parent, m_First, m_Second)
             If tm.CurrentToken.IsIdentifierOrKeyword Then
                 m_Second = tm.CurrentToken
                 tm.NextToken()
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
                 Return Nothing
             End If
         End While
         While tm.Accept(KS.Dot)
             If Token.IsSomething(m_Second) Then m_First = New QualifiedIdentifier(Parent, m_First, m_Second)
             If tm.CurrentToken.IsIdentifierOrKeyword Then
                 m_Second = tm.CurrentToken
                 tm.NextToken()
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
                 Return Nothing
             End If
         End While
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1318" endline="1321"><![CDATA[
 
     Private Function ParseIdentifier() As Identifier
         Return ParseIdentifier(CType(Nothing, ParsedObject))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1322" endline="1334"><![CDATA[
 
     Private Function ParseIdentifier(ByVal Parent As ParsedObject) As Identifier
         Dim result As Identifier
 
         If tm.CurrentToken.IsIdentifier Then
             result = New Identifier(Parent, tm.CurrentToken.Identifier, tm.CurrentLocation, tm.CurrentTypeCharacter)
             tm.NextToken()
         Else
             result = Nothing
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1335" endline="1345"><![CDATA[
 
     Private Function ParseBuiltinTypeName(ByVal Parent As ParsedObject) As BuiltInTypeName
         Dim m_Typename As KS
 
         If vbnc.BuiltInTypeName.IsBuiltInTypeName(tm) = False Then Throw New InternalException(Parent)
 
         m_Typename = tm.CurrentToken.Keyword
         tm.NextToken()
 
         Return New BuiltInTypeName(Parent, m_Typename)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1346" endline="1356"><![CDATA[
 
     Private Function ParseModifiers(ByVal ValidModifiers As ModifierMasks) As Modifiers
         Dim result As New Modifiers()
 
         While tm.CurrentToken.Equals(ValidModifiers)
             result.AddModifier(tm.CurrentToken.Keyword)
             tm.NextToken()
         End While
         While tm.CurrentToken.Equals(ValidModifiers)
             result.AddModifier(tm.CurrentToken.Keyword)
             tm.NextToken()
         End While
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1357" endline="1404"><![CDATA[
 
     ''' <summary>
     ''' Parses type members for interfaces.
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseInterfaceMembers(ByVal Parent As InterfaceDeclaration) As Boolean
         Dim newMembers As New Generic.List(Of IMember)
         While True
             Dim attributes As Attributes
             attributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, Parent.Namespace)
             If newType IsNot Nothing AndAlso Not Parent.Members.Contains(newType) Then
                 Parent.Members.Add(newType)
                 Continue While
             End If
 
             Dim newMember As IMember
             'InterfaceDeclarations
             If InterfaceEventMemberDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceEventMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfaceFunctionDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfaceSubDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfacePropertyMemberDeclaration.IsMe(tm) Then
                 newMember = ParseInterfacePropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             Else
                 If attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
 
             If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             Parent.Members.Add(newMember)
         End While
         While True
             Dim attributes As Attributes
             attributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, Parent.Namespace)
             If newType IsNot Nothing AndAlso Not Parent.Members.Contains(newType) Then
                 Parent.Members.Add(newType)
                 Continue While
             End If
 
             Dim newMember As IMember
             'InterfaceDeclarations
             If InterfaceEventMemberDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceEventMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfaceFunctionDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfaceSubDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfacePropertyMemberDeclaration.IsMe(tm) Then
                 newMember = ParseInterfacePropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             Else
                 If attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
 
             If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             Parent.Members.Add(newMember)
         End While
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1405" endline="1500"><![CDATA[
 
     ''' <summary>
     ''' Parses type members for classes, modules and structures.
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <remarks></remarks>
     Private Function ParseTypeMembers(ByVal Parent As TypeDeclaration) As Boolean
         Dim result As Boolean = True
         Dim isModuleDeclaration As Boolean = TypeOf Parent Is ModuleDeclaration
 
         Helper.Assert(TypeOf Parent Is ClassDeclaration OrElse isModuleDeclaration OrElse TypeOf Parent Is StructureDeclaration)
 
         Dim newMembers As New Generic.List(Of IMember)
         While True
             Dim attributes As Attributes
             attributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, Parent.Namespace)
             If newType IsNot Nothing Then
                 Parent.Members.Add(newType)
                 Continue While
             End If
 
             Dim newMember As IMember
 
             'Class and Structure declarations
             If isModuleDeclaration = False AndAlso OperatorDeclaration.IsMe(tm) Then
                 newMember = ParseOperatorDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf isModuleDeclaration = False AndAlso ConversionOperatorDeclaration.IsMe(tm) Then
                 newMember = ParseConversionOperatorDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 'Class, Structure and Module declarations
             ElseIf RegularEventDeclaration.IsMe(tm) Then
                 newMember = ParseRegularEventDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf CustomEventDeclaration.IsMe(tm) Then
                 newMember = ParseCustomEventMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf VariableDeclaration.IsMe(tm) Then
                 Dim tmp As Generic.List(Of TypeVariableDeclaration)
                 tmp = ParseTypeVariableMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If tmp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 For Each item As TypeVariableDeclaration In tmp
                     newMembers.Add(item)
                 Next
                 newMember = Nothing
             ElseIf ConstantDeclaration.IsMe(tm) Then
                 Dim tmp As Generic.List(Of ConstantDeclaration)
                 tmp = ParseConstantMemberDeclarations(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If tmp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 For Each item As ConstantDeclaration In tmp
                     newMembers.Add(item)
                 Next
                 newMember = Nothing
             ElseIf ExternalSubDeclaration.IsMe(tm) Then
                 newMember = ParseExternalSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf ExternalFunctionDeclaration.IsMe(tm) Then
                 newMember = ParseExternalFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf SubDeclaration.IsMe(tm) Then
                 newMember = ParseSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf FunctionDeclaration.IsMe(tm) Then
                 newMember = ParseFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf RegularPropertyDeclaration.IsMe(tm) Then
                 newMember = ParseRegularPropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf MustOverridePropertyDeclaration.IsMe(tm) Then
                 newMember = ParseMustOverridePropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf ConstructorDeclaration.IsMe(tm) Then
                 newMember = ParseConstructorMember(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 If attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
 
             If newMember IsNot Nothing Then newMembers.Add(newMember)
             If newMembers.Count = 0 Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Parent.Members.AddRange(newMembers)
             newMembers.Clear()
         End While
         While True
             Dim attributes As Attributes
             attributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, Parent.Namespace)
             If newType IsNot Nothing Then
                 Parent.Members.Add(newType)
                 Continue While
             End If
 
             Dim newMember As IMember
 
             'Class and Structure declarations
             If isModuleDeclaration = False AndAlso OperatorDeclaration.IsMe(tm) Then
                 newMember = ParseOperatorDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf isModuleDeclaration = False AndAlso ConversionOperatorDeclaration.IsMe(tm) Then
                 newMember = ParseConversionOperatorDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 'Class, Structure and Module declarations
             ElseIf RegularEventDeclaration.IsMe(tm) Then
                 newMember = ParseRegularEventDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf CustomEventDeclaration.IsMe(tm) Then
                 newMember = ParseCustomEventMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf VariableDeclaration.IsMe(tm) Then
                 Dim tmp As Generic.List(Of TypeVariableDeclaration)
                 tmp = ParseTypeVariableMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If tmp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 For Each item As TypeVariableDeclaration In tmp
                     newMembers.Add(item)
                 Next
                 newMember = Nothing
             ElseIf ConstantDeclaration.IsMe(tm) Then
                 Dim tmp As Generic.List(Of ConstantDeclaration)
                 tmp = ParseConstantMemberDeclarations(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If tmp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 For Each item As ConstantDeclaration In tmp
                     newMembers.Add(item)
                 Next
                 newMember = Nothing
             ElseIf ExternalSubDeclaration.IsMe(tm) Then
                 newMember = ParseExternalSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf ExternalFunctionDeclaration.IsMe(tm) Then
                 newMember = ParseExternalFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf SubDeclaration.IsMe(tm) Then
                 newMember = ParseSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf FunctionDeclaration.IsMe(tm) Then
                 newMember = ParseFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf RegularPropertyDeclaration.IsMe(tm) Then
                 newMember = ParseRegularPropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf MustOverridePropertyDeclaration.IsMe(tm) Then
                 newMember = ParseMustOverridePropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf ConstructorDeclaration.IsMe(tm) Then
                 newMember = ParseConstructorMember(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 If attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
 
             If newMember IsNot Nothing Then newMembers.Add(newMember)
             If newMembers.Count = 0 Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Parent.Members.AddRange(newMembers)
             newMembers.Clear()
         End While
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1501" endline="1529"><![CDATA[
 
     ''' <summary>
     ''' Parses a type declaration. Returns nothing if no type declaration was found.
     ''' Parses only one typedeclaration.
     ''' Type declaration = Class, Module, Structure, Enum, Delegate, Interface declaration.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseTypeDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As TypeDeclaration
         Dim result As TypeDeclaration
         If ClassDeclaration.IsMe(tm) Then
             result = ParseClassDeclaration(Parent, Attributes, [Namespace])
         ElseIf EnumDeclaration.IsMe(tm) Then
             result = ParseEnumDeclaration(Parent, Attributes, [Namespace])
         ElseIf StructureDeclaration.IsMe(tm) Then
             result = ParseStructureDeclaration(Parent, Attributes, [Namespace])
         ElseIf InterfaceDeclaration.IsMe(tm) Then
             result = ParseInterfaceDeclaration(Parent, Attributes, [Namespace])
         ElseIf DelegateDeclaration.IsMe(tm) Then
             result = ParseDelegateDeclaration(Parent, Attributes, [Namespace])
         ElseIf ModuleDeclaration.IsMe(tm) Then
             result = ParseModuleDeclaration(Parent, Attributes, [Namespace])
         Else
             result = Nothing
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1530" endline="1601"><![CDATA[
 
     Private Function ParseAssemblyMembers(ByVal Parent As AssemblyDeclaration, ByVal RootNamespace As String) As Boolean
         Dim result As Boolean = True
         Dim currentNameSpace As String = RootNamespace
         Dim currentNamespaces As New Generic.List(Of QualifiedIdentifier)
 
         While True
             Dim attributes As Attributes
             attributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 If tm.AcceptEndOfStatement Then
                     For Each attrib As Attribute In attributes
                         If attrib.IsAssembly = False AndAlso attrib.IsModule = False Then
                             If attrib.Location.File(Compiler).DoesLineEndWithLineContinuation(attrib.Location.Line) Then
                                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, attrib.Location) AndAlso result
                             Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC32035, attrib.Location) AndAlso result
                             End If
                         End If
                     Next
                     Parent.Attributes.AddRange(attributes)
                     Continue While
                 End If
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, currentNameSpace)
             If newType IsNot Nothing Then
                 If Not Parent.Members.Contains(newType) Then
                     'This may be false for partial types
                     Parent.Members.Add(newType)
                 End If
             ElseIf tm.Accept(KS.Namespace) Then
                 Dim qi As QualifiedIdentifier
                 qi = ParseQualifiedIdentifier(Parent)
                 If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 currentNamespaces.Add(qi)
                 currentNameSpace = RootNamespace
                 If currentNamespaces.Count > 0 Then
                     If currentNameSpace <> "" Then currentNameSpace &= "."
                     For i As Integer = 0 To currentNamespaces.Count - 2
                         currentNameSpace &= currentNamespaces(i).Name & "."
                     Next
                     currentNameSpace &= currentNamespaces(currentNamespaces.Count - 1).Name
                 End If
                 If tm.AcceptNewLine(True, True, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf tm.Accept(KS.End, KS.Namespace) Then
                 If tm.AcceptNewLine(True, False, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If currentNamespaces.Count >= 1 Then
                     currentNamespaces.RemoveAt(currentNamespaces.Count - 1)
                     currentNameSpace = RootNamespace
                     If currentNamespaces.Count > 0 Then
                         If currentNameSpace <> "" Then currentNameSpace &= "."
                         For i As Integer = 0 To currentNamespaces.Count - 2
                             currentNameSpace &= currentNamespaces(i).Name & "."
                         Next
                         currentNameSpace &= currentNamespaces(currentNamespaces.Count - 1).Name
                     End If
                 Else
                     Helper.AddError(Compiler, tm.CurrentLocation, "'End Namespace' without 'Namespace'.")
                 End If
             Else
                 If attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
         End While
         While True
             Dim attributes As Attributes
             attributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 If tm.AcceptEndOfStatement Then
                     For Each attrib As Attribute In attributes
                         If attrib.IsAssembly = False AndAlso attrib.IsModule = False Then
                             If attrib.Location.File(Compiler).DoesLineEndWithLineContinuation(attrib.Location.Line) Then
                                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, attrib.Location) AndAlso result
                             Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC32035, attrib.Location) AndAlso result
                             End If
                         End If
                     Next
                     Parent.Attributes.AddRange(attributes)
                     Continue While
                 End If
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, currentNameSpace)
             If newType IsNot Nothing Then
                 If Not Parent.Members.Contains(newType) Then
                     'This may be false for partial types
                     Parent.Members.Add(newType)
                 End If
             ElseIf tm.Accept(KS.Namespace) Then
                 Dim qi As QualifiedIdentifier
                 qi = ParseQualifiedIdentifier(Parent)
                 If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 currentNamespaces.Add(qi)
                 currentNameSpace = RootNamespace
                 If currentNamespaces.Count > 0 Then
                     If currentNameSpace <> "" Then currentNameSpace &= "."
                     For i As Integer = 0 To currentNamespaces.Count - 2
                         currentNameSpace &= currentNamespaces(i).Name & "."
                     Next
                     currentNameSpace &= currentNamespaces(currentNamespaces.Count - 1).Name
                 End If
                 If tm.AcceptNewLine(True, True, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf tm.Accept(KS.End, KS.Namespace) Then
                 If tm.AcceptNewLine(True, False, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If currentNamespaces.Count >= 1 Then
                     currentNamespaces.RemoveAt(currentNamespaces.Count - 1)
                     currentNameSpace = RootNamespace
                     If currentNamespaces.Count > 0 Then
                         If currentNameSpace <> "" Then currentNameSpace &= "."
                         For i As Integer = 0 To currentNamespaces.Count - 2
                             currentNameSpace &= currentNamespaces(i).Name & "."
                         Next
                         currentNameSpace &= currentNamespaces(currentNamespaces.Count - 1).Name
                     End If
                 Else
                     Helper.AddError(Compiler, tm.CurrentLocation, "'End Namespace' without 'Namespace'.")
                 End If
             Else
                 If attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
         End While
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1602" endline="1649"><![CDATA[
 
 
     ''' <summary>
     ''' EventAccessorDeclaration  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEventAccessorDeclarations(ByVal Parent As EventDeclaration, ByVal EventName As Identifier, ByVal EventModifiers As Modifiers) As EventAccessorDeclarations
         Dim result As New EventAccessorDeclarations(Parent)
         Dim parsing As Boolean = True
 
         Dim m_AddHandler As CustomEventHandlerDeclaration = Nothing
         Dim m_RemoveHandler As CustomEventHandlerDeclaration = Nothing
         Dim m_RaiseEvent As CustomEventHandlerDeclaration = Nothing
 
         Do
             Dim attributes As Attributes
             attributes = New Attributes(result)
             If vbnc.Attributes.IsMe(tm) Then
                 ParseAttributes(result, attributes)
             End If
             If CustomEventHandlerDeclaration.IsMe(tm) Then
                 Dim newMember As CustomEventHandlerDeclaration
                 newMember = ParseCustomEventHandlerDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes), EventName, EventModifiers)
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Select Case newMember.HandlerType
                     Case KS.AddHandler
                         m_AddHandler = newMember
                     Case KS.RemoveHandler
                         m_RemoveHandler = newMember
                     Case KS.RaiseEvent
                         m_RaiseEvent = newMember
                     Case Else
                         Throw New InternalException(result)
                 End Select
             Else
                 If attributes IsNot Nothing AndAlso attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation)
                 End If
                 Exit Do
             End If
         Loop
 
         result.Init(m_AddHandler, m_RemoveHandler, m_RaiseEvent)
 
         result.HasErrors = m_AddHandler IsNot Nothing AndAlso m_RemoveHandler IsNot Nothing AndAlso m_RaiseEvent IsNot Nothing
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1650" endline="1708"><![CDATA[
 
     ''' <summary>
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" TypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' 
     ''' LAMESPEC!!! Using the following
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" NonArrayTypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCustomEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As CustomEventDeclaration
         Dim result As New CustomEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeName As NonArrayTypeName
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
         Dim m_EventAccessorDeclarations As EventAccessorDeclarations = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError("Custom")
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_TypeName = ParseNonArrayTypeName(result)
         If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_EventAccessorDeclarations = ParseEventAccessorDeclarations(result, m_Identifier, m_Modifiers)
         If m_EventAccessorDeclarations Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Event) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_TypeName, m_ImplementsClause)
 
         result.AddMethod = m_EventAccessorDeclarations.AddHandler
         result.RemoveMethod = m_EventAccessorDeclarations.RemoveHandler
         result.RaiseMethod = m_EventAccessorDeclarations.RaiseEvent
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1709" endline="1738"><![CDATA[
 
     ''' <summary>
     ''' InterfaceEventMemberDeclaration  
     '''	[  Attributes  ]  [  InterfaceEventModifiers+  ]  "Event"  Identifier  ParametersOrType  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceEventMemberDeclaration
         Dim result As New InterfaceEventMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
 
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceEventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1739" endline="1771"><![CDATA[
 
     ''' <summary>
     ''' ParametersOrType  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParametersOrType(ByVal Parent As ParsedObject) As ParametersOrType
         Dim result As New ParametersOrType(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ParameterList As ParameterList
 
         If tm.Accept(KS.As) Then
             m_NonArrayTypeName = ParseNonArrayTypeName(result)
             result.Init(m_NonArrayTypeName)
         Else
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.LParenthesis) Then
                 If tm.Accept(KS.RParenthesis) = False Then
                     If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
                     If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Else
                     m_ParameterList = New ParameterList(result)
                 End If
                 result.Init(m_ParameterList)
             Else
                 result.Init(m_ParameterList)
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1772" endline="1808"><![CDATA[
 
     ''' <summary>
     ''' RegularEventMemberDeclaration  
     ''' 	[  Attributes  ]  [  EventModifiers+  ]  "Event"  Identifier  ParametersOrType  [  ImplementsClause  ] StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRegularEventDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As RegularEventDeclaration
         Dim result As New RegularEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
         Dim m_ImplementsClause As MemberImplementsClause
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ImplementsClause = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, m_ImplementsClause)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1809" endline="1877"><![CDATA[
 
     ''' <summary>
     ''' AddHandlerDeclaration  
     '''	[  Attributes  ]  "AddHandler" "(" ParameterList ")" LineTerminator
     '''	[  Block  ]
     '''	"End" "AddHandler" StatementTerminator
     ''' 
     ''' RemoveHandlerDeclaration  
     '''	[  Attributes  ]  "RemoveHandler" "("  ParameterList  ")"  LineTerminator
     '''	[  Block  ]
     '''	"End" "RemoveHandler" StatementTerminator
     ''' 
     ''' LAMESPEC
     ''' RemoveHandlerDeclaration  
     '''	[  Attributes  ]  "RemoveHandler" "("  [ ParameterList  ] ")"  LineTerminator
     '''	[  Block  ]
     '''	"End" "RemoveHandler" StatementTerminator
     ''' 
     ''' RaiseEventDeclaration  
     '''	[  Attributes  ]  "RaiseEvent" (  ParameterList  )  LineTerminator
     '''	[  Block  ]
     '''	"End" "RaiseEvent" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCustomEventHandlerDeclaration(ByVal Parent As EventDeclaration, ByVal Info As ParseAttributableInfo, ByVal EventName As Identifier, ByVal EventModifiers As Modifiers) As CustomEventHandlerDeclaration
         Dim result As New CustomEventHandlerDeclaration(Parent)
 
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Block As CodeBlock
         Dim m_HandlerType As KS
         Dim m_Modifiers As Modifiers
 
         If tm.CurrentToken.Equals(KS.AddHandler, KS.RemoveHandler, KS.RaiseEvent) Then
             m_HandlerType = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.RParenthesis) = False Then
             If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, m_HandlerType) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_ParameterList Is Nothing Then m_ParameterList = New ParameterList(result)
 
         If m_HandlerType = KS.RaiseEvent Then
             m_Modifiers = New Modifiers(ModifierMasks.Private)
         Else
             m_Modifiers = EventModifiers
         End If
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_ParameterList, m_Block, m_HandlerType, EventName)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1878" endline="1883"><![CDATA[
 
 
     Private Function ParseGlobalExpression(ByVal Parent As ParsedObject) As GlobalExpression
         tm.AcceptIfNotInternalError(KS.Global)
         Return New GlobalExpression(Parent)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1884" endline="1898"><![CDATA[
 
     Private Function ParseBuiltInTypeExpression(ByVal Parent As ParsedObject) As BuiltInTypeExpression
         Dim result As New BuiltInTypeExpression(Parent)
 
         Dim m_Type As BuiltInDataTypes
 
         Helper.Assert(tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames))
 
         m_Type = CType(tm.CurrentToken.Keyword, BuiltInDataTypes)
         tm.NextToken()
 
         result.Init(m_Type)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1899" endline="1932"><![CDATA[
 
     ''' <summary>
     ''' MemberAccessExpression 
     ''' MemberAccessBase 
     ''' 
     ''' TODO
     ''' LAMESPEC
     ''' MemberAccessExpression 
     ''' </summary>
     ''' <param name="FirstExpression"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseMemberAccessExpression(ByVal Parent As ParsedObject, ByVal FirstExpression As Expression) As MemberAccessExpression
         Dim result As New MemberAccessExpression(Parent)
 
         Dim m_First As Expression
         Dim m_Second As IdentifierOrKeywordWithTypeArguments
 
         m_First = FirstExpression 'Might be nothing.
         If m_First IsNot Nothing Then m_First.Parent = result
         'According to the language specification, the dot is optional,
         'but that doesn't seem to be correct... so let's make it 
         'required
         tm.AcceptIfNotInternalError(KS.Dot)
         'Specifically, this is not a MemberAccessExpression without the
         'dot, so it is an internal error.
 
         m_Second = ParseIdentifierOrKeywordWithTypeArguments(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1933" endline="1958"><![CDATA[
 
     Private Function ParseIdentifierOrKeywordWithTypeArguments(ByVal Parent As ParsedObject) As IdentifierOrKeywordWithTypeArguments
         Dim result As New IdentifierOrKeywordWithTypeArguments(Parent)
 
         Dim m_TypeArguments As TypeArgumentList
         Dim m_Token As Token
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_Token = tm.CurrentToken
             tm.NextToken()
         Else
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Return Nothing
         End If
 
         If tm.CurrentToken.Equals(KS.LParenthesis) AndAlso tm.PeekToken.Equals(KS.Of) Then
             m_TypeArguments = ParseTypeArgumentList(result)
             If m_TypeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeArguments = Nothing
         End If
 
         result.Init(m_Token, m_TypeArguments)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1959" endline="1984"><![CDATA[
 
     ''' <summary>
     ''' DictionaryAccessExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDictionaryAccessExpression(ByVal Parent As ParsedObject, ByVal FirstPart As Expression) As DictionaryAccessExpression
         Dim result As New DictionaryAccessExpression(Parent)
 
         Dim m_FirstPart As Expression
         Dim m_SecondPart As IdentifierOrKeyword
 
         m_FirstPart = FirstPart
         If m_FirstPart IsNot Nothing Then m_FirstPart.Parent = result
         tm.AcceptIfNotInternalError(KS.Exclamation)
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_SecondPart = ParseIdentifierOrKeyword(result)
             If m_SecondPart Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_FirstPart, m_SecondPart)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1985" endline="1998"><![CDATA[
 
     Private Function ParseCByteExpression(ByVal Parent As ParsedObject) As CByteExpression
         Dim result As New CByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1999" endline="2013"><![CDATA[
 
     Private Function ParseCBoolExpression(ByVal Parent As ParsedObject) As CBoolExpression
         Dim result As New CBoolExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CBool)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2014" endline="2028"><![CDATA[
 
     Private Function ParseCCharExpression(ByVal Parent As ParsedObject) As CCharExpression
         Dim result As New CCharExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CChar)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2029" endline="2043"><![CDATA[
 
     Private Function ParseCDateExpression(ByVal Parent As ParsedObject) As CDateExpression
         Dim result As New CDateExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDate)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2044" endline="2058"><![CDATA[
 
     Private Function ParseCDblExpression(ByVal Parent As ParsedObject) As CDblExpression
         Dim result As New CDblExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDbl)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2059" endline="2073"><![CDATA[
 
     Private Function ParseCDecExpression(ByVal Parent As ParsedObject) As CDecExpression
         Dim result As New CDecExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDec)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2074" endline="2088"><![CDATA[
 
     Private Function ParseCIntExpression(ByVal Parent As ParsedObject) As CIntExpression
         Dim result As New CIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2089" endline="2103"><![CDATA[
 
     Private Function ParseCLngExpression(ByVal Parent As ParsedObject) As CLngExpression
         Dim result As New CLngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CLng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2104" endline="2118"><![CDATA[
 
     Private Function ParseCObjExpression(ByVal Parent As ParsedObject) As CObjExpression
         Dim result As New CObjExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CObj)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2119" endline="2133"><![CDATA[
 
     Private Function ParseCSByteExpression(ByVal Parent As ParsedObject) As CSByteExpression
         Dim result As New CSByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2134" endline="2148"><![CDATA[
 
     Private Function ParseCShortExpression(ByVal Parent As ParsedObject) As CShortExpression
         Dim result As New CShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2149" endline="2163"><![CDATA[
 
     Private Function ParseCSngExpression(ByVal Parent As ParsedObject) As CSngExpression
         Dim result As New CSngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2164" endline="2178"><![CDATA[
 
     Private Function ParseCStrExpression(ByVal Parent As ParsedObject) As CStrExpression
         Dim result As New CStrExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CStr)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2179" endline="2193"><![CDATA[
 
     Private Function ParseCUIntExpression(ByVal Parent As ParsedObject) As CUIntExpression
         Dim result As New CUIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2194" endline="2208"><![CDATA[
 
     Private Function ParseCULngExpression(ByVal Parent As ParsedObject) As CULngExpression
         Dim result As New CULngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CULng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2209" endline="2223"><![CDATA[
 
     Private Function ParseCUShortExpression(ByVal Parent As ParsedObject) As CUShortExpression
         Dim result As New CUShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2224" endline="2253"><![CDATA[
 
     ''' <summary>
     ''' VariableIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifier(ByVal Parent As ParsedObject) As VariableIdentifier
         Dim result As New VariableIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier
 
         If tm.CurrentToken.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ArrayNameModifier = Nothing
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2254" endline="2289"><![CDATA[
 
     ''' <summary>
     ''' RaiseEventStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRaiseEventStatement(ByVal Parent As ParsedObject) As RaiseEventStatement
         Dim result As New RaiseEventStatement(Parent)
 
         Dim m_Event As SimpleNameExpression
         Dim m_Arguments As ArgumentList
         Dim m_Identifier As IdentifierOrKeyword
 
         tm.AcceptIfNotInternalError(KS.RaiseEvent)
 
         m_Identifier = ParseIdentifierOrKeyword(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Event = New SimpleNameExpression(result)
         m_Event.Identifier = New Identifier(m_Event, m_Identifier.Identifier, m_Identifier.Location, TypeCharacters.Characters.None)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_Arguments = ParseArgumentList(result)
                 If m_Arguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_Arguments = New ArgumentList(result)
             End If
         Else
             m_Arguments = Nothing
         End If
 
         result.Init(m_Event, m_Arguments)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2290" endline="2321"><![CDATA[
 
     ''' <summary>
     ''' InvocationExpression
     ''' IndexExpression
     ''' Note that for the index expression the parenthesis are not optional.
     ''' This is reflected by the fact that m_ArgumentList is not nothing if 
     ''' parenthesis are provided.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInvocationOrIndexExpression(ByVal Parent As ParsedObject, ByVal First As Expression) As InvocationOrIndexExpression
         Dim result As New InvocationOrIndexExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_ArgumentList As ArgumentList
 
         m_Expression = First
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(result)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(result)
             End If
         Else
             m_ArgumentList = Nothing
         End If
 
         result.Init(m_Expression, m_ArgumentList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2322" endline="2344"><![CDATA[
 
     ''' <summary>
     ''' ParenthesizedExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParenthesizedExpression(ByVal Parent As ParsedObject) As ParenthesizedExpression
         Dim result As New ParenthesizedExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_Expression = ParseExpression(result)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2345" endline="2359"><![CDATA[
 
 
     Private Function ParseUnaryMinusExpression(ByVal Info As ExpressionParseInfo) As UnaryMinusExpression
         Dim result As New UnaryMinusExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Minus)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2360" endline="2390"><![CDATA[
 
     Private Function ParseCTypeExpression(ByVal Parent As ParsedObject, ByVal GetKeyword As KS) As CTypeExpression
         Dim result As CTypeExpression = Nothing
 
         Dim m_DestinationType As TypeName
         Dim m_Expression As Expression
 
         Select Case GetKeyword
             Case KS.CType
                 result = New CTypeExpression(Parent, True)
             Case KS.DirectCast
                 result = New DirectCastExpression(Parent)
             Case KS.TryCast
                 result = New TryCastExpression(Parent)
             Case Else
                 Throw New InternalException(result)
         End Select
 
         tm.AcceptIfNotInternalError(GetKeyword)
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_Expression = ParseExpression(result)
         If tm.AcceptIfNotError(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_DestinationType = ParseTypeName(result)
         If m_DestinationType Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.Init(m_Expression, m_DestinationType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2391" endline="2403"><![CDATA[
 
     Private Function ParseUnaryNotExpression(ByVal Info As ExpressionParseInfo) As UnaryNotExpression
         Dim result As New UnaryNotExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Not)
 
         m_Expression = ParseComparison(Info)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2404" endline="2417"><![CDATA[
 
     Private Function ParseUnaryPlusExpression(ByVal Info As ExpressionParseInfo) As UnaryPlusExpression
         Dim result As New UnaryPlusExpression(Info.Parent)
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Add)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2418" endline="2441"><![CDATA[
 
     Private Function ParseArrayInitializerExpression(ByVal Parent As ParsedObject) As ArrayInitializerExpression
         Dim result As New ArrayInitializerExpression(Parent)
 
         Dim m_Initializers As New Expressions()
 
         tm.AcceptIfNotInternalError(KS.LBrace)
 
         If tm.CurrentToken <> KS.RBrace Then
             Do
                 Dim newExp As Expression
                 newExp = ParseExpression(result)
                 If newExp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 m_Initializers.Add(newExp)
             Loop While tm.Accept(KS.Comma)
         End If
 
         If tm.Accept(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Initializers)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2442" endline="2487"><![CDATA[
 
     ''' <summary>
     ''' LoopControlVariable  
     '''	   Identifier  [  ArrayNameModifier  ] "As" TypeName  |
     '''	   Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLoopControlVariable(ByVal Parent As ParsedObject) As LoopControlVariable
         Dim result As New LoopControlVariable(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
         Dim m_TypeName As TypeName = Nothing
         Dim m_Expression As Expression = Nothing
 
         'First try first option
         Dim tmpANM As ArrayNameModifier = Nothing
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim doExpression As Boolean = True
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If m_Identifier IsNot Nothing Then
             If ArrayNameModifier.CanBeMe(tm) Then
                 tmpANM = ParseArrayNameModifier(result)
                 If tmpANM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tmpANM Is Nothing AndAlso tm.Accept(KS.As) Then
                 m_ArrayNameModifier = tmpANM
                 m_TypeName = ParseTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 doExpression = False
             End If
         End If
 
         If doExpression Then
             tm.RestoreToPoint(iCurrent)
             m_Expression = ParseExpression(New ExpressionParseInfo(result, True))
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             tm.IgnoreRestoredPoint()
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier, m_TypeName, m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2488" endline="2517"><![CDATA[
 
     ''' <summary>
     ''' NewExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseNewExpression(ByVal Parent As ParsedObject) As NewExpression
         Dim result As New NewExpression(Parent)
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim bShowingErrors As Boolean
 
         Dim ace As ArrayCreationExpression
 
         bShowingErrors = Me.ShowErrors
         Me.m_ShowErrors = False
         ace = ParseArrayCreationExpression(result)
         Me.m_ShowErrors = bShowingErrors
 
         If ace IsNot Nothing Then
             tm.IgnoreRestoredPoint()
             result.Init(ace)
         Else
             tm.RestoreToPoint(iCurrent)
             Dim doce As DelegateOrObjectCreationExpression
             doce = ParseDelegateOrObjectCreationExpression(result)
             If doce Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(doce)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2518" endline="2546"><![CDATA[
 
     ''' <summary>
     ''' DelegateCreationExpression 
     ''' ObjectCreationExpression   
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateOrObjectCreationExpression(ByVal Parent As ParsedObject) As DelegateOrObjectCreationExpression
         Dim result As New DelegateOrObjectCreationExpression(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
 
         tm.AcceptIfNotInternalError(KS.[New])
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_ArgumentList = ParseArgumentList(result)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
 
         result.Init(m_NonArrayTypeName, m_ArgumentList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2547" endline="2593"><![CDATA[
 
     ''' <summary>
     ''' ArgumentList  
     '''                     PositionalArgumentList  |
     '''	                    NamedArgumentList
     ''' 
     ''' PositionalArgumentList  
     ''' 
     ''' NamedArgumentList  
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArgumentList(ByVal Parent As ParsedObject) As ArgumentList
         Dim result As New ArgumentList(Parent)
 
         Dim m_Arguments As New BaseObjects(Of Argument)(result)
 
         'First parse positional arguments
         Do
             'Check for named argument.
             If NamedArgument.CanBeMe(tm) Then Exit Do
 
             Dim exp As Expression
             exp = Nothing
 
             If tm.CurrentToken.Equals(KS.Comma) = False Then
                 exp = ParseExpression(result)
             End If
 
             Dim newPA As PositionalArgument
             newPA = New PositionalArgument(result, m_Arguments.Count, exp)
             m_Arguments.Add(newPA)
         Loop While tm.Accept(KS.Comma)
 
         'Then parse named arguments
         If NamedArgument.CanBeMe(tm) Then
             Do
                 Dim newArgument As NamedArgument
                 newArgument = ParseNamedArgument(result)
                 m_Arguments.Add(newArgument)
             Loop While tm.Accept(KS.Comma)
         End If
 
         result.Init(m_Arguments)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2594" endline="2618"><![CDATA[
 
     Private Function ParseNamedArgument(ByVal Parent As ParsedObject) As NamedArgument
         Dim result As New NamedArgument(Parent)
         Dim Name As String
         Dim Expression As Expression = Nothing
 
         If tm.CurrentToken.IsIdentifier Then
             Name = tm.CurrentToken.Identifier
         ElseIf tm.CurrentToken.IsKeyword Then
             Name = tm.CurrentToken.Identifier
         Else
             Throw New InternalException(result)
         End If
         tm.NextToken()
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
 
         Expression = ParseExpression(result)
         If Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.Init(Name, Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2619" endline="2627"><![CDATA[
 
     Private Function ParseMyClassExpression(ByVal Parent As ParsedObject) As MyClassExpression
         Dim result As MyClassExpression
 
         tm.AcceptIfNotInternalError(KS.MyClass)
         result = New MyClassExpression(Parent)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2628" endline="2636"><![CDATA[
 
     Private Function ParseMyBaseExpression(ByVal Parent As ParsedObject) As MyBaseExpression
         Dim result As MyBaseExpression
 
         tm.AcceptIfNotInternalError(KS.MyBase)
         result = New MyBaseExpression(Parent)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2637" endline="2645"><![CDATA[
 
     Private Function ParseMeExpression(ByVal Parent As ParsedObject) As MeExpression
         Dim result As MeExpression
 
         tm.AcceptIfNotInternalError(KS.Me)
         result = New MeExpression(Parent)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2646" endline="2672"><![CDATA[
     ''' <summary>
     ''' A single identifier followed by an optional type argument list.
     ''' 
     ''' SimpleNameExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleNameExpression(ByVal Parent As ParsedObject) As SimpleNameExpression
         Dim result As New SimpleNameExpression(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeArgumentList As TypeArgumentList
 
         m_Identifier = ParseIdentifier(result)
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             m_TypeArgumentList = ParseTypeArgumentList(result)
             If m_TypeArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             'If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented()
         Else
             m_TypeArgumentList = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeArgumentList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2673" endline="2957"><![CDATA[
 
     Private Function ParseCodeBlock(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CodeBlock
         Dim result As New CodeBlock(Parent)
         Dim breakloop As Boolean
 
         Do
             If IsOneLiner = False AndAlso LabelDeclarationStatement.CanBeMe(tm) Then
                 Dim newLabel As LabelDeclarationStatement
                 newLabel = ParseLabelDeclarationStatement(result)
                 If newLabel Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 result.AddStatement(newLabel)
                 result.AddLabel(newLabel)
             ElseIf MidAssignStatement.IsMe(tm) Then
                 Dim newMidAssign As MidAssignStatement
                 newMidAssign = ParseMidAssignmentStatement(result, IsOneLiner)
                 If newMidAssign Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 result.AddStatement(newMidAssign)
             ElseIf tm.CurrentToken.IsIdentifier OrElse _
               tm.CurrentToken.Equals(KS.Dot, KS.Me, KS.MyClass, KS.MyBase) OrElse _
               tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames) OrElse _
               tm.CurrentToken.Equals(KS.Global) OrElse _
               tm.CurrentToken.Equals(KS.DirectCast, KS.TryCast, KS.CType) OrElse _
               tm.CurrentToken.Equals(KS.GetType) Then
                 'Must appear after the label check.
                 'Must appear before the symbol check.
                 'Must appear before the keywords check
                 Dim lside, rside As Expression
 
                 lside = ParseExpression(New ExpressionParseInfo(result, True, False))
                 If lside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.CurrentToken.IsSymbol Then
                     Select Case tm.CurrentToken.Symbol
                         Case KS.Equals
                             tm.NextToken()
                             Dim newStmt As New AssignmentStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.AddAssign
                             tm.NextToken()
                             Dim newStmt As New AddAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.ConcatAssign
                             tm.NextToken()
                             Dim newStmt As New ConcatAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.RealDivAssign
                             tm.NextToken()
                             Dim newStmt As New DivisionAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.IntDivAssign
                             tm.NextToken()
                             Dim newStmt As New IntDivisionAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.MultAssign
                             tm.NextToken()
                             Dim newStmt As New MultiplicationAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.PowerAssign
                             tm.NextToken()
                             Dim newStmt As New PowerAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.ShiftRightAssign
                             tm.NextToken()
                             Dim newStmt As New RShiftAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.ShiftLeftAssign
                             tm.NextToken()
                             Dim newStmt As New LShiftAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.MinusAssign
                             tm.NextToken()
                             Dim newStmt As New SubtractionAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case Else
                             Dim newStmt As New CallStatement(result)
                             newStmt.Init(lside)
                             result.AddStatement(newStmt)
                     End Select
                 Else
                     Dim newStmt As New CallStatement(result)
                     newStmt.Init(lside)
                     result.AddStatement(newStmt)
                 End If
             ElseIf tm.CurrentToken.IsKeyword Then
                 Select Case tm.CurrentToken.Keyword
                     Case KS.Dim, KS.Static, KS.Const
                         Dim newVariables As Generic.List(Of LocalVariableDeclaration)
                         newVariables = ParseLocalDeclarationStatement(result)
                         If newVariables Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddVariables(newVariables)
                     Case KS.SyncLock
                         Dim newLock As SyncLockStatement
                         newLock = ParseSyncLockStatement(result, IsOneLiner)
                         If newLock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newLock)
                     Case KS.Try
                         Dim newTry As TryStatement
                         newTry = ParseTryStatement(result, IsOneLiner)
                         If newTry Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newTry)
                     Case KS.Throw
                         Dim newThrow As ThrowStatement
                         newThrow = ParseThrowStatement(result)
                         If newThrow Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newThrow)
                     Case KS.With
                         Dim newWith As WithStatement
                         newWith = ParseWithStatement(result, IsOneLiner)
                         If newWith Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newWith)
                     Case KS.Select
                         Dim newSelect As SelectStatement
                         newSelect = ParseSelectStatement(result, IsOneLiner)
                         If newSelect Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newSelect)
                     Case KS.If
                         Dim newIf As IfStatement
                         newIf = ParseIfStatement(result, IsOneLiner)
                         If newIf Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newIf)
                     Case KS.Do
                         Dim newDo As DoStatement
                         newDo = ParseDoStatement(result, IsOneLiner)
                         If newDo Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newDo)
                     Case KS.Stop
                         Dim newStop As StopStatement
                         newStop = ParseStopStatement(result)
                         If newStop Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newStop)
                     Case KS.End
                         Dim newEnd As EndStatement
                         If tm.PeekToken.IsEndOfStatement() Then
                             newEnd = ParseEndStatement(result)
                             If newEnd Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             result.AddStatement(newEnd)
                         Else
                             breakloop = True
                         End If
                     Case KS.While
                         Dim newWhile As WhileStatement
                         newWhile = ParseWhileStatement(result, IsOneLiner)
                         If newWhile Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newWhile)
                     Case KS.Exit
                         Dim newExit As ExitStatement
                         newExit = ParseExitStatement(result)
                         If newExit Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newExit)
                     Case KS.Return
                         Dim newReturn As ReturnStatement
                         newReturn = ParseReturnStatement(result)
                         If newReturn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newReturn)
                     Case KS.For
                         If tm.PeekToken.Equals(KS.Each) Then
                             Dim newFor As ForEachStatement
                             newFor = ParseForEachStatement(result, IsOneLiner)
                             If newFor Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             result.AddStatement(newFor)
                         Else
                             Dim newFor As ForStatement
                             newFor = ParseForStatement(result, IsOneLiner)
                             If newFor Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             result.AddStatement(newFor)
                         End If
                     Case KS.Continue
                         Dim newContinue As ContinueStatement
                         newContinue = ParseContinueStatement(result, IsOneLiner)
                         If newContinue Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newContinue)
                     Case KS.GoTo
                         Dim newGoto As GotoStatement
                         newGoto = ParseGotoStatement(result)
                         If newGoto Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newGoto)
                     Case KS.On
                         Dim newOnError As OnErrorStatement
                         newOnError = ParseOnErrorStatement(result)
                         If newOnError Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newOnError)
                     Case KS.Error
                         Dim newError As ErrorStatement
                         newError = ParseErrorStatement(result)
                         If newError Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newError)
                     Case KS.AddHandler, KS.RemoveHandler
                         Dim newAddHandler As AddOrRemoveHandlerStatement
                         newAddHandler = ParseAddOrRemoveHandlerStatement(result)
                         If newAddHandler Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newAddHandler)
                     Case KS.RaiseEvent
                         Dim newRaiseEvent As RaiseEventStatement
                         newRaiseEvent = ParseRaiseEventStatement(result)
                         If newRaiseEvent Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newRaiseEvent)
                     Case KS.Call
                         Dim newCall As CallStatement
                         newCall = ParseCallStatement(result)
                         If newCall Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newCall)
                     Case KS.Erase
                         Dim newErase As EraseStatement
                         newErase = ParseEraseStatement(result)
                         If newErase Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newErase)
                     Case KS.ReDim
                         Dim newReDim As ReDimStatement
                         newReDim = ParseReDimStatement(result)
                         If newReDim Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newReDim)
                     Case KS.Resume
                         Dim newResume As ResumeStatement
                         newResume = ParseResumeStatement(result)
                         If newResume Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newResume)
                     Case KS.Using
                         Dim newUsing As UsingStatement
                         newUsing = ParseUsingStatement(result, IsOneLiner)
                         If newUsing Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newUsing)
                     Case Else
                         breakloop = True
                 End Select
             ElseIf tm.CurrentToken.Equals(KS.Colon) Then
                 'tm.NextToken()
             Else
                 breakloop = True
             End If
 
             If breakloop = False Then
                 If IsOneLiner Then
                     If tm.Accept(KS.Colon) = False Then
                         breakloop = True
                     End If
                 Else
                     If tm.AcceptEndOfStatement(False, Compiler.Report.Errors = 0) = False Then
                         Return result
                     End If
                 End If
             End If
 
             If result.FirstStatement Is Nothing AndAlso breakloop = False Then
                 If result.Statements.Count = 1 Then
                     result.FirstStatement = result.Statements(0)
                     'ElseIf result.Variables.Count >= 1 Then
                     'result.FirstStatement = result.Variables(0)
                 ElseIf result.Statements.Count > 1 Then 'OrElse result.Variables.Count > 1 Then
                     Throw New InternalException(result)
                 Else
                     'Do nothing. No statements were parsed.
                 End If
             End If
         Loop Until breakloop = True
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2958" endline="2967"><![CDATA[
 
     Private Function ParseExpressionList(ByVal Parent As ParsedObject) As ExpressionList
         Dim result As New ExpressionList(Parent)
 
         If ParseList(Of Expression)(result, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2968" endline="2976"><![CDATA[
 
     <Obsolete()> Private Function ParseExpression() As Expression
         Dim result As Expression = Nothing
 
         Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         '        result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2977" endline="2984"><![CDATA[
 
     Private Function ParseExpression(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As Expression = Nothing
 
         result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2985" endline="2992"><![CDATA[
 
     Public Function ParseExpression(ByVal Parent As ParsedObject) As Expression
         Dim result As Expression = Nothing
 
         result = ParseOr_OrElse_Xor(New ExpressionParseInfo(Parent))
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2993" endline="3012"><![CDATA[
     ''' <summary>
     ''' GetTypeExpression 
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseGetTypeExpression(ByVal Parent As ParsedObject) As GetTypeExpression
         Dim result As New GetTypeExpression(Parent)
 
         tm.AcceptIfNotInternalError(KS.GetType)
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Dim m_TypeName As GetTypeTypeName
         m_TypeName = ParseGetTypeTypeName(result)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_TypeName)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3013" endline="3020"><![CDATA[
 
     Private Function Parse(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As Expression
 
         result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3021" endline="3144"><![CDATA[
 
     Private Function ParseIdentifier(ByVal Info As ExpressionParseInfo) As Expression
         Dim value As Expression = Nothing
         Dim result As Boolean = True
 
         If tm.CurrentToken.IsLiteral Then
             value = ParseLiteralExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken = KS.Dot Then
             value = ParseMemberAccessExpression(Info.Parent, Nothing)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken = KS.Exclamation Then
             value = ParseDictionaryAccessExpression(Info.Parent, Nothing)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames) Then
             value = ParseBuiltInTypeExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.IsIdentifier Then
             value = ParseSimpleNameExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken = KS.LBrace Then
             value = ParseArrayInitializerExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken = KS.LParenthesis Then
             value = ParseParenthesizedExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.Equals(KS.Add, KS.Minus) Then
             value = ParseUnaryPlusMinus(Info)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.IsKeyword Then
             Select Case tm.CurrentToken.Keyword
                 Case KS.Not
                     value = ParseNot(Info)
                 Case KS.DirectCast, KS.TryCast, KS.CType
                     value = ParseCTypeExpression(Info.Parent, tm.CurrentToken.Keyword)
                 Case KS.AddressOf
                     value = ParseAddressOfExpression(Info.Parent)
                 Case KS.[New]
                     value = ParseNewExpression(Info.Parent)
                 Case KS.CInt
                     value = ParseCIntExpression(Info.Parent)
                 Case KS.CBool
                     value = ParseCBoolExpression(Info.Parent)
                 Case KS.CByte
                     value = ParseCByteExpression(Info.Parent)
                 Case KS.CChar
                     value = ParseCCharExpression(Info.Parent)
                 Case KS.CDate
                     value = ParseCDateExpression(Info.Parent)
                 Case KS.CDbl
                     value = ParseCDblExpression(Info.Parent)
                 Case KS.CDec
                     value = ParseCDecExpression(Info.Parent)
                 Case KS.CLng
                     value = ParseCLngExpression(Info.Parent)
                 Case KS.CObj
                     value = ParseCObjExpression(Info.Parent)
                 Case KS.CSByte
                     value = ParseCSByteExpression(Info.Parent)
                 Case KS.CShort
                     value = ParseCShortExpression(Info.Parent)
                 Case KS.CSng
                     value = ParseCSngExpression(Info.Parent)
                 Case KS.CStr
                     value = ParseCStrExpression(Info.Parent)
                 Case KS.CUInt
                     value = ParseCUIntExpression(Info.Parent)
                 Case KS.CULng
                     value = ParseCULngExpression(Info.Parent)
                 Case KS.CUShort
                     value = ParseCUShortExpression(Info.Parent)
                 Case KS.True, KS.False
                     value = ParseBooleanLiteralExpression(Info.Parent)
                 Case KS.Nothing
                     tm.AcceptIfNotInternalError(KS.Nothing)
                     value = New NothingConstantExpression(Info.Parent)
                 Case KS.GetType
                     value = ParseGetTypeExpression(Info.Parent)
                 Case KS.TypeOf
                     value = ParseTypeOfExpression(Info.Parent)
                 Case KS.Me
                     value = ParseMeExpression(Info.Parent)
                 Case KS.MyBase
                     value = ParseMyBaseExpression(Info.Parent)
                 Case KS.MyClass
                     value = ParseMyClassExpression(Info.Parent)
                 Case KS.Global
                     Dim newGlobal As GlobalExpression
                     newGlobal = ParseGlobalExpression(Info.Parent)
                     value = ParseMemberAccessExpression(Info.Parent, newGlobal)
                 Case KS.If
                     value = ParseIfExpression(Info.Parent)
                 Case Else
                     Helper.Stop()
             End Select
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             value = Nothing
         End If
 
         Do While result
             If tm.CurrentToken = KS.Dot Then
                 Dim newExp As MemberAccessExpression
                 newExp = ParseMemberAccessExpression(Info.Parent, value)
                 value = newExp
             ElseIf tm.CurrentToken = KS.Exclamation Then
                 Dim newExp As DictionaryAccessExpression
                 newExp = ParseDictionaryAccessExpression(Info.Parent, value)
                 value = newExp
             ElseIf tm.CurrentToken = KS.LParenthesis Then
                 If tm.PeekToken.IsIntegerLiteral AndAlso tm.PeekToken.IntegralLiteral = 0 AndAlso tm.PeekToken(2).Equals(KS.To) Then
                     Exit Do
                 End If
                 Dim newExp As InvocationOrIndexExpression
                 newExp = ParseInvocationOrIndexExpression(Info.Parent, value)
                 value = newExp
             Else
                 Exit Do
             End If
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While result
             If tm.CurrentToken = KS.Dot Then
                 Dim newExp As MemberAccessExpression
                 newExp = ParseMemberAccessExpression(Info.Parent, value)
                 value = newExp
             ElseIf tm.CurrentToken = KS.Exclamation Then
                 Dim newExp As DictionaryAccessExpression
                 newExp = ParseDictionaryAccessExpression(Info.Parent, value)
                 value = newExp
             ElseIf tm.CurrentToken = KS.LParenthesis Then
                 If tm.PeekToken.IsIntegerLiteral AndAlso tm.PeekToken.IntegralLiteral = 0 AndAlso tm.PeekToken(2).Equals(KS.To) Then
                     Exit Do
                 End If
                 Dim newExp As InvocationOrIndexExpression
                 newExp = ParseInvocationOrIndexExpression(Info.Parent, value)
                 value = newExp
             Else
                 Exit Do
             End If
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         Return value
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3145" endline="3157"><![CDATA[
 
     Private Function ParseExponent(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIdentifier(Info)
 
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3158" endline="3171"><![CDATA[
 
     Private Function ParseUnaryPlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryExpression
 
         If tm.CurrentToken = KS.Add Then
             result = ParseUnaryPlusExpression(Info)
         ElseIf tm.CurrentToken = KS.Minus Then
             result = ParseUnaryMinusExpression(Info)
         Else
             Return ParseExponent(Info)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3172" endline="3193"><![CDATA[
 
     Private Function ParseMultDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseUnaryPlusMinus(Info)
 
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3194" endline="3206"><![CDATA[
 
     Private Function ParseIntDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMultDiv(Info)
 
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3207" endline="3219"><![CDATA[
 
     Private Function ParseMod(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIntDiv(Info)
 
         While tm.Accept(KS.Mod)
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Mod)
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3220" endline="3242"><![CDATA[
 
     Private Function ParsePlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMod(Info)
 
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3243" endline="3255"><![CDATA[
 
     Private Function ParseConcat(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParsePlusMinus(Info)
 
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3256" endline="3277"><![CDATA[
 
     Private Function ParseBitshift(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseConcat(Info)
 
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3278" endline="3321"><![CDATA[
 
     Private Function ParseComparison(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseBitshift(Info)
         While tm.CurrentToken.Equals(KS.NotEqual, KS.LE, KS.LT, KS.GT, KS.GE, KS.Like, KS.IsNot) OrElse _
           (tm.CurrentToken = KS.Equals AndAlso Info.IsLeftSide = False) OrElse _
           (tm.CurrentToken = KS.Is AndAlso Info.IsInTypeOf = False)
             Dim op As KS
             If tm.CurrentToken.IsSymbol Then
                 op = tm.CurrentToken.Symbol
             ElseIf tm.CurrentToken.IsKeyword Then
                 op = tm.CurrentToken.Keyword
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
 
             tm.NextToken()
 
             rSide = ParseBitshift(Info)
 
             If op = KS.Equals Then
                 lSide = New EqualsExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.NotEqual Then
                 lSide = New NotEqualsExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.GE Then
                 lSide = New GEExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.GT Then
                 lSide = New GTExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.LE Then
                 lSide = New LEExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.LT Then
                 lSide = New LTExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Is OrElse op = KS.IsNot Then
                 lSide = New Is_IsNotExpression(Info.Parent, lSide, rSide, op)
             ElseIf op = KS.Like Then
                 lSide = New LikeExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.NotEqual, KS.LE, KS.LT, KS.GT, KS.GE, KS.Like, KS.IsNot) OrElse _
           (tm.CurrentToken = KS.Equals AndAlso Info.IsLeftSide = False) OrElse _
           (tm.CurrentToken = KS.Is AndAlso Info.IsInTypeOf = False)
             Dim op As KS
             If tm.CurrentToken.IsSymbol Then
                 op = tm.CurrentToken.Symbol
             ElseIf tm.CurrentToken.IsKeyword Then
                 op = tm.CurrentToken.Keyword
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
 
             tm.NextToken()
 
             rSide = ParseBitshift(Info)
 
             If op = KS.Equals Then
                 lSide = New EqualsExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.NotEqual Then
                 lSide = New NotEqualsExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.GE Then
                 lSide = New GEExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.GT Then
                 lSide = New GTExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.LE Then
                 lSide = New LEExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.LT Then
                 lSide = New LTExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Is OrElse op = KS.IsNot Then
                 lSide = New Is_IsNotExpression(Info.Parent, lSide, rSide, op)
             ElseIf op = KS.Like Then
                 lSide = New LikeExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3322" endline="3333"><![CDATA[
 
     Private Function ParseNot(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryNotExpression
 
         If tm.CurrentToken = KS.Not Then
             result = ParseUnaryNotExpression(Info)
         Else
             Return ParseComparison(Info)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3334" endline="3355"><![CDATA[
 
     Private Function ParseAnd_AndAlso(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseNot(Info)
 
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3356" endline="3379"><![CDATA[
 
     Private Function ParseOr_OrElse_Xor(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseAnd_AndAlso(Info)
 
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3380" endline="3397"><![CDATA[
 
     ''' <summary>
     ''' AddressOfExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddressOfExpression(ByVal Parent As ParsedObject) As AddressOfExpression
         Dim result As New AddressOfExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.AddressOf)
 
         m_Expression = ParseExpression(result)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3398" endline="3438"><![CDATA[
 
     Private Function ParseIfExpression(ByVal Parent As ParsedObject) As IfExpression
         Dim result As New IfExpression(Parent)
         Dim expressions As ExpressionList
 
         tm.AcceptIfNotInternalError(KS.If)
 
         If Not tm.Accept(KS.LParenthesis) Then
             Compiler.Report.ShowMessage(Messages.VBNC30199, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         If tm.Accept(KS.RParenthesis) Then
             Compiler.Report.ShowMessage(Messages.VBNC33104, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         expressions = ParseExpressionList(result)
 
         If expressions.Count < 2 OrElse expressions.Count > 3 Then
             Compiler.Report.ShowMessage(Messages.VBNC33104, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         If Not tm.Accept(KS.RParenthesis) Then
             Compiler.Report.ShowMessage(Messages.VBNC30198, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         result.Condition = expressions(0)
         result.SecondPart = expressions(1)
         If expressions.Count = 3 Then
             result.ThirdPart = expressions(2)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3439" endline="3471"><![CDATA[
 
     ''' <summary>
     ''' "TypeOf" Expression "Is" TypeName
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeOfExpression(ByVal Parent As ParsedObject) As TypeOfExpression
         Dim result As New TypeOfExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_Is As Boolean
         Dim m_Type As TypeName
 
         tm.AcceptIfNotInternalError(KS.TypeOf)
 
         m_Expression = ParseExpression(New ExpressionParseInfo(result, False, True))
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Is) Then
             m_Is = True
         ElseIf tm.Accept(KS.IsNot) Then
             m_Is = False
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Type = ParseTypeName(result)
         If m_Type Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression, m_Is, m_Type)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3472" endline="3491"><![CDATA[
 
     ''' <summary>
     ''' LiteralExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLiteralExpression(ByVal Parent As ParsedObject) As LiteralExpression
         Dim result As LiteralExpression
 
         Dim m_Value As Token
         m_Value = tm.CurrentToken
         If m_Value.IsLiteral = False Then
             result = Nothing
         Else
             result = New LiteralExpression(Parent)
             result.Init(m_Value)
             tm.NextToken()
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3492" endline="3509"><![CDATA[
 
     Private Function ParseBooleanLiteralExpression(ByVal Parent As ParsedObject) As BooleanLiteralExpression
         Dim result As New BooleanLiteralExpression(Parent)
 
         Dim m_Value As Boolean
 
         If tm.Accept(KS.True) Then
             m_Value = True
         ElseIf tm.Accept(KS.False) Then
             m_Value = False
         Else
             Throw New InternalException(result)
         End If
 
         result.Init(m_Value)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3510" endline="3525"><![CDATA[
 
     ''' <summary>
     ''' VariableIdentifiers  
     '''	            VariableIdentifier  |
     '''	            VariableIdentifiers  ,  VariableIdentifier
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifiers(ByVal Parent As ParsedObject) As VariableIdentifiers
         Dim result As New VariableIdentifiers(Parent)
 
         If ParseList(Of VariableIdentifier)(result, New ParseDelegate_Parent(Of VariableIdentifier)(AddressOf ParseVariableIdentifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3526" endline="3570"><![CDATA[
 
     ''' <summary>
     ''' ConstructorMemberDeclaration  
     ''' [  Attributes  ]  [  ConstructorModifier+  ]  "Sub" "New" [  "("  [  ParameterList  ]  ")"  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Sub" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstructorMember(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Signature As SubSignature
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstructorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
         tm.AcceptIfNotInternalError(KS.[New])
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         m_Signature = New SubSignature(result, "", m_ParameterList)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Sub) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_Block)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3571" endline="3655"><![CDATA[
 
     ''' <summary>
     ''' RegularPropertyMemberDeclaration  
     '''	[  Attributes  ]  [  PropertyModifier+  ] "Property" FunctionSignature  [  ImplementsClause  ]
     '''		LineTerminator
     '''	PropertyAccessorDeclaration+
     '''	"End" "Property" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRegularPropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As RegularPropertyDeclaration
         Dim result As New RegularPropertyDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Signature As FunctionSignature
         Dim m_ImplementsClause As MemberImplementsClause
         Dim m_Attributes As New Attributes(result)
         Dim m_Get As PropertyGetDeclaration = Nothing
         Dim m_Set As PropertySetDeclaration = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.PropertyModifiers)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If tm.AcceptEndOfStatement() = False Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ImplementsClause = Nothing
         End If
 
         Do
             m_Attributes = ParseAttributes(result)
             If PropertyGetDeclaration.IsMe(tm) Then
                 If m_Get IsNot Nothing Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Found more than one Get Property.")
                 End If
                 m_Get = ParsePropertyGetMember(result, New ParseAttributableInfo(Compiler, m_Attributes), m_Signature, m_ImplementsClause, m_Modifiers.Mask)
                 If m_Get Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Attributes = Nothing
             ElseIf PropertySetDeclaration.IsMe(tm) Then
                 If m_Set IsNot Nothing Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Found more than one Set Property.")
                 End If
                 m_Set = ParsePropertySetMember(result, New ParseAttributableInfo(Compiler, m_Attributes), m_Signature, m_ImplementsClause, m_Modifiers.Mask)
                 If m_Set Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Attributes = Nothing
             Else
                 If m_Attributes IsNot Nothing AndAlso m_Attributes.Count > 0 Then
                     'Hanging attributes.
                     Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
                 End If
                 Exit Do
             End If
         Loop
 
         If tm.AcceptIfNotError(KS.End, KS.Property) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.ReadOnly) AndAlso m_Get Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC30126, m_Signature.Location)
         End If
         If m_Modifiers.Is(ModifierMasks.WriteOnly) AndAlso m_Set Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC30125, m_Signature.Location)
         End If
 
         If m_Modifiers.Is(ModifierMasks.ReadOnly) = False AndAlso m_Modifiers.Is(ModifierMasks.WriteOnly) = False Then
             If m_Get Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30124, m_Signature.Location)
             End If
             If m_Set Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30124, m_Signature.Location)
             End If
         End If
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_Get, m_Set, m_ImplementsClause)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3656" endline="3699"><![CDATA[
 
     ''' <summary>
     ''' PropertySetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  "Set" [  (  ParameterList  )  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Set" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertySetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertySetDeclaration
         Dim result As New PropertySetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
         tm.AcceptIfNotInternalError(KS.Set)
 
         If tm.Accept(KS.LParenthesis) Then
             If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Set) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block, m_ParameterList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3700" endline="3734"><![CDATA[
 
     ''' <summary>
     ''' PropertyGetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  Get  LineTerminator
     '''	[  Block  ]
     '''	End  Get  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertyGetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertyGetDeclaration
         Dim result As New PropertyGetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
 
         tm.AcceptIfNotInternalError(KS.Get)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Get) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3735" endline="3771"><![CDATA[
 
     ''' <summary>
     ''' Tries to parse a sub signature. Returns false if not successful.
     ''' SubSignature  
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="m_Identifier">Output parameter, must be nothing on entry.</param>
     ''' <param name="m_TypeParameters">Output parameter, must be nothing on entry.</param>
     ''' <param name="m_ParameterList">Input/Output parameter, must not be nothing on entry.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseSubSignature(ByVal Parent As ParsedObject, ByRef m_Identifier As Identifier, ByRef m_TypeParameters As TypeParameters, ByVal m_ParameterList As ParameterList) As Boolean
         Dim result As Boolean = True
 
         'Helper.Assert(m_Identifier Is Nothing)
         Helper.Assert(m_TypeParameters Is Nothing)
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         m_Identifier = ParseIdentifier(Parent)
         result = m_Identifier IsNot Nothing AndAlso result
 
         If vbnc.TypeParameters.IsMe(tm) Then
             m_TypeParameters = ParseTypeParameters(Parent)
         End If
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 result = tm.AcceptIfNotError(KS.RParenthesis) AndAlso result
             End If
         End If
 
         'Helper.Assert(m_Identifier IsNot Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3772" endline="3791"><![CDATA[
 
     ''' <summary>
     ''' SubSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSubSignature(ByVal Parent As ParsedObject) As SubSignature
         Dim result As New SubSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3792" endline="3823"><![CDATA[
 
     ''' <summary>
     ''' FunctionSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionSignature(ByVal Parent As ParsedObject) As FunctionSignature
         Dim result As New FunctionSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
         Dim m_ReturnTypeAttributes As New Attributes(result)
         Dim m_TypeName As TypeName = Nothing
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             If Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList, m_ReturnTypeAttributes, m_TypeName, New Span(m_Identifier.Location, tm.CurrentLocation))
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3824" endline="3845"><![CDATA[
 
 
     ''' <summary>
     ''' TypeParameters  
     ''' CHANGED
     ''' </summary>
     ''' <remarks></remarks>
     ''' 
     Private Function ParseTypeParameters(ByVal Parent As ParsedObject) As TypeParameters
         Dim result As New TypeParameters()
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptIfNotError(KS.Of) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseList(Of TypeParameter)(result.Parameters, New ParseDelegate_Parent(Of TypeParameter)(AddressOf ParseTypeParameter), result.Parameters) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3846" endline="3878"><![CDATA[
 
     ''' <summary>
     ''' TypeParameter  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameter(ByVal Parent As ParsedObject) As TypeParameter
         Dim result As New TypeParameter(Parent)
         Dim m_Identifier As Identifier
         Dim m_TypeParameterConstraints As TypeParameterConstraints
         Dim parentList As TypeParameterList
 
         Helper.Assert(TypeOf Parent Is TypeParameterList)
 
         parentList = DirectCast(Parent, TypeParameterList)
         result.GenericParameterPosition = parentList.Count + 1
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             result.Identifier = m_Identifier
         End If
 
         If TypeParameterConstraints.CanBeMe(tm) Then
             m_TypeParameterConstraints = ParseTypeParameterConstraints(result)
             If m_TypeParameterConstraints Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.TypeParameterConstraints = m_TypeParameterConstraints
         Else
             m_TypeParameterConstraints = Nothing
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3879" endline="3905"><![CDATA[
 
     ''' <summary>
     ''' TypeParameterConstraints  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameterConstraints(ByVal Parent As ParsedObject) As TypeParameterConstraints
         Dim result As New TypeParameterConstraints(Parent)
 
         tm.AcceptIfNotInternalError(KS.As)
 
         Dim m_ConstraintList As New ConstraintList(result)
 
         If tm.Accept(KS.LBrace) Then
             If ParseList(Of Constraint)(m_ConstraintList, New ParseDelegate_Parent(Of Constraint)(AddressOf ParseConstraint), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Dim tmpConstraint As Constraint = Nothing
             tmpConstraint = ParseConstraint(result)
             m_ConstraintList = New ConstraintList(result, tmpConstraint)
         End If
 
         result.Init(m_ConstraintList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3906" endline="3930"><![CDATA[
 
     ''' <summary>
     ''' Constraint  
     ''' LAMESPEC? Using the following
     ''' Constraint  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstraint(ByVal Parent As ParsedObject) As Constraint
         Dim result As New Constraint(Parent)
 
         Dim m_Special As KS
         Dim m_TypeName As TypeName = Nothing
 
         If tm.CurrentToken.Equals(KS.[New], KS.Class, KS.Structure) Then
             m_Special = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_TypeName, m_Special)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3931" endline="3974"><![CDATA[
 
     ''' <summary>
     ''' Parameter            
     ''' ParameterModifier    
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameter(ByVal Parent As ParsedObject) As Parameter
         Helper.Assert(TypeOf Parent Is ParameterList)
         Dim result As New Parameter(DirectCast(Parent, ParameterList))
 
         Dim m_Attributes As New Attributes(result)
         Dim m_Modifiers As Modifiers
         Dim m_ParameterIdentifier As ParameterIdentifier
         Dim m_TypeName As TypeName
         Dim m_ConstantExpression As Expression
 
         If vbnc.Attributes.IsMe(tm) Then
             ParseAttributes(result, m_Attributes)
         End If
 
         m_Modifiers = ParseModifiers(ModifierMasks.ParameterModifiers)
 
         m_ParameterIdentifier = ParseParameterIdentifier(result)
         If m_ParameterIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         result.Init(m_Attributes, m_Modifiers, m_ParameterIdentifier, m_TypeName, m_ConstantExpression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3975" endline="3997"><![CDATA[
 
     ''' <summary>
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameterIdentifier(ByVal Parent As Parameter) As ParameterIdentifier
         Dim result As New ParameterIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3998" endline="4013"><![CDATA[
 
     Private Function ParseImplementsClause(ByVal Parent As ParsedObject) As MemberImplementsClause
         Dim result As New MemberImplementsClause(Parent)
 
         Dim m_ImplementsList As New MemberImplementsList(Parent)
 
         tm.AcceptIfNotInternalError(KS.Implements)
 
         If ParseList(Of InterfaceMemberSpecifier)(m_ImplementsList, New ParseDelegate_Parent(Of InterfaceMemberSpecifier)(AddressOf ParseInterfaceMemberSpecifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_ImplementsList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4014" endline="4058"><![CDATA[
 
     Private Function ParseInterfaceMemberSpecifier(ByVal Parent As ParsedObject) As InterfaceMemberSpecifier
         Dim result As New InterfaceMemberSpecifier(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName = Nothing
         Dim m_1 As NonArrayTypeName = Nothing
         Dim m_2 As IdentifierOrKeyword = Nothing
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.Accept(KS.Dot) Then
             m_1 = m_NonArrayTypeName
             m_2 = ParseIdentifierOrKeyword(result)
             If m_2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf m_NonArrayTypeName.IsSimpleTypeName AndAlso m_NonArrayTypeName.AsSimpleTypeName.IsQualifiedIdentifier Then
             Dim stn As SimpleTypeName = m_NonArrayTypeName.AsSimpleTypeName
             Dim qi As QualifiedIdentifier = stn.AsQualifiedIdentifier
             m_1 = m_NonArrayTypeName
             If Token.IsSomething(qi.Second) Then
                 m_2 = New IdentifierOrKeyword(result, qi.Second)
                 qi.Second = Nothing
             Else
                 Helper.AddError(Compiler, tm.CurrentLocation)
             End If
         ElseIf m_NonArrayTypeName.IsConstructedTypeName Then
             Dim constructedTypeName As ConstructedTypeName = m_NonArrayTypeName.AsConstructedTypeName
             If constructedTypeName.QualifiedIdentifier IsNot Nothing AndAlso constructedTypeName.ConstructedTypeName IsNot Nothing AndAlso constructedTypeName.TypeArgumentList Is Nothing Then
                 If constructedTypeName.QualifiedIdentifier.IsFirstIdentifier AndAlso Token.IsSomething(constructedTypeName.QualifiedIdentifier.Second) = False Then
                     m_1 = New NonArrayTypeName(result)
                     m_1.Init(constructedTypeName.ConstructedTypeName)
                     m_2 = New IdentifierOrKeyword(result, constructedTypeName.QualifiedIdentifier.FirstAsIdentifier.Identifier, KS.None)
                 Else
                     Helper.AddError(Compiler, tm.CurrentLocation)
                 End If
             Else
                 Helper.AddError(Compiler, tm.CurrentLocation)
             End If
         Else
             Helper.AddError(Compiler, tm.CurrentLocation)
         End If
 
         result.Init(m_1, m_2)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4059" endline="4080"><![CDATA[
 
     ''' <summary>
     ''' ConstantMemberDeclaration  
     ''' </summary>
     ''' <remarks>
     ''' </remarks>
     Private Function ParseConstantMemberDeclarations(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstantModifiers)
 
         tm.AcceptIfNotInternalError(KS.Const)
         m_Modifiers.AddModifiers(ModifierMasks.Const)
 
         result = ParseConstantDeclarations(Parent, Info.Attributes, m_Modifiers)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4081" endline="4093"><![CDATA[
 
     Private Function ParseConstantDeclarations(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal Modifiers As Modifiers) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Do
             Dim newCD As ConstantDeclaration = Nothing
             newCD = ParseConstantDeclaration(Parent, New ParseAttributableInfo(Parent.Compiler, Attributes), Modifiers)
             If newCD Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Add(newCD)
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4094" endline="4127"><![CDATA[
 
     ''' <summary>
     ''' MustOverridePropertyMemberDeclaration  
     '''	[  Attributes  ]  [  MustOverridePropertyModifier+  ]  "Property" FunctionSignature  [  ImplementsClause  ]
     '''		StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseMustOverridePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As MustOverridePropertyDeclaration
         Dim result As New MustOverridePropertyDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverridePropertyModifiers)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, , , m_ImplementsClause)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4128" endline="4184"><![CDATA[
 
     ''' <summary>
     ''' ConversionOperatorDeclaration    
     '''	[  Attributes  ]  [  ConversionOperatorModifier+  ]  "Operator" "CType" "("  Operand  ")"
     '''		[  "As"  [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConversionOperatorDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ConversionOperatorDeclaration
         Dim result As New ConversionOperatorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Operator As Token = Nothing
         Dim m_Operand As Operand = Nothing
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConversionOperatorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Operator)
 
         If vbnc.ConversionOperatorDeclaration.IsOverloadableConversionOperator(tm.CurrentToken) Then
             m_Operator = tm.CurrentToken 
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Operand = ParseOperand(result)
         If m_Operand Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Operator) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Operator, m_Operand, m_ReturnTypeAttributes, m_TypeName, m_Block)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4185" endline="4212"><![CDATA[
 
     ''' <summary>
     ''' EnumMemberDeclaration  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal EnumIndex As Integer) As EnumMemberDeclaration
         Dim result As New EnumMemberDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ConstantExpression As Expression
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(EnumIndex, m_Identifier, m_ConstantExpression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4213" endline="4239"><![CDATA[
 
     ''' <summary>
     ''' Operand  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOperand(ByVal Parent As ParsedObject) As Operand
         Dim result As New Operand(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName
 
         tm.Accept(KS.ByVal)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeName)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4240" endline="4321"><![CDATA[
 
 
     ''' <summary>
     ''' BinaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator"  OverloadableBinaryOperator
     '''		"("  Operand  ","  Operand  ")"  [ "As"  [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' 
     ''' UnaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator" OverloadableUnaryOperator 
     '''     "("  Operand  ")" 		[  "As" [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' OverloadableUnaryOperator  
     ''' </summary>
     ''' <remarks></remarks>
 
     Private Function ParseOperatorDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As OperatorDeclaration
         Dim result As New OperatorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_OperatorSymbol As KS
         Dim m_OperatorIdentifier As String = Nothing
         Dim m_Operand1 As Operand
         Dim m_Operand2 As Operand
         Dim m_TypeName As TypeName
         Dim m_ReturnTypeAttributes As New Attributes(Parent)
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.OperatorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Operator)
 
         If vbnc.OperatorDeclaration.IsOverloadableOperator(tm.CurrentToken) Then
             If tm.CurrentToken.IsIdentifier Then
                 m_OperatorIdentifier = DirectCast(tm.Reader.TokenData, String)
             Else
                 m_OperatorSymbol = tm.CurrentToken.Symbol
             End If
             tm.NextToken()
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Operand1 = ParseOperand(result)
         If m_Operand1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) Then
             m_Operand2 = ParseOperand(result)
             If m_Operand2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Operand2 = Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Operator) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_OperatorIdentifier, m_OperatorSymbol, m_Operand1, m_Operand2, m_ReturnTypeAttributes, m_TypeName, m_Block)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4322" endline="4370"><![CDATA[
 
     ''' <summary>
     ''' FunctionDeclaration  
     '''	[  Attributes  ]  [  ProcedureModifier+  ]  "Function" FunctionSignature  [  HandlesOrImplements  ]
     '''		LineTerminator
     '''	Block
     '''	"End" "Function" StatementTerminator
     ''' 
     ''' MustOverrideFunctionDeclaration  
     '''	[  Attributes  ]  [  MustOverrideProcedureModifier+  ]  "Function" FunctionSignature
     '''		[  HandlesOrImplements  ]  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As FunctionDeclaration
         Dim result As New FunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_HandlesOrImplements As HandlesOrImplements = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverrideProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.HandlesOrImplements.IsMe(tm) Then
             m_HandlesOrImplements = ParseHandlesOrImplements(result)
             If m_HandlesOrImplements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.MustOverride) = False Then
             m_Block = ParseCodeBlock(result, False)
             If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             If tm.AcceptIfNotError(KS.End, KS.Function) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_HandlesOrImplements, m_Block)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4371" endline="4417"><![CDATA[
 
     ''' <summary>
     ''' SubDeclaration  
     '''	[  Attributes  ]  [  ProcedureModifier+  ] "Sub" SubSignature  [  HandlesOrImplements  ]  LineTerminator
     '''	Block
     '''	"End" "Sub" StatementTerminator
     ''' 
     ''' MustOverrideSubDeclaration  
     '''	[  Attributes  ]  [  MustOverrideProcedureModifier+  ] "Sub" SubSignature  [  HandlesOrImplements  ]
     '''		StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As SubDeclaration
         Dim result As New SubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
         Dim m_HandlesOrImplements As HandlesOrImplements = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverrideProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.HandlesOrImplements.IsMe(tm) Then
             m_HandlesOrImplements = ParseHandlesOrImplements(result)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.MustOverride) = False Then
             m_Block = ParseCodeBlock(result, False)
             If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             If tm.AcceptIfNotError(KS.End, KS.Sub) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_HandlesOrImplements, m_Block)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4418" endline="4441"><![CDATA[
 
     ''' <summary>
     ''' HandlesOrImplements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesOrImplements(ByVal Parent As ParsedObject) As HandlesOrImplements
         Dim result As New HandlesOrImplements(Parent)
 
         If vbnc.HandlesClause.IsMe(tm) Then
             Dim m_Clause As HandlesClause
             m_Clause = ParseHandlesClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         ElseIf vbnc.MemberImplementsClause.IsMe(tm) Then
             Dim m_Clause As MemberImplementsClause
             m_Clause = ParseImplementsClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4442" endline="4463"><![CDATA[
 
     ''' <summary>
     ''' HandlesClause  
     ''' LAMESPEC
     ''' HandlesClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesClause(ByVal Parent As ParsedObject) As HandlesClause
         Dim result As New HandlesClause(Parent)
 
         Dim m_List As New EventHandlesList(result)
 
         tm.AcceptIfNotInternalError(KS.Handles)
 
         If ParseList(Of EventMemberSpecifier)(m_List, New ParseDelegate_Parent(Of EventMemberSpecifier)(AddressOf ParseEventMemberSpecifier), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_List)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4464" endline="4502"><![CDATA[
 
     ''' <summary>
     ''' EventMemberSpecifier  
     '''  QualifiedIdentifier  "."  IdentifierOrKeyword  |
     '''  MyBase  "."  IdentifierOrKeyword  |
     '''	 Me  "."  IdentifierOrKeyword
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEventMemberSpecifier(ByVal Parent As ParsedObject) As EventMemberSpecifier
         Dim result As New EventMemberSpecifier(Parent)
 
         Dim m_First As Expression
         Dim m_Second As IdentifierOrKeyword
 
         If tm.CurrentToken = KS.MyBase Then
             m_First = ParseMyBaseExpression(result)
         ElseIf tm.CurrentToken = KS.Me Then
             m_First = ParseMeExpression(result)
         Else
             Dim id As Identifier
             id = ParseIdentifier(result)
             If id Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             Dim sne As New SimpleNameExpression(result)
             sne.Init(id, New TypeArgumentList(sne))
             m_First = sne
         End If
         If m_First Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Dot) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Second = ParseIdentifierOrKeyword(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4503" endline="4528"><![CDATA[
 
     ''' <summary>
     ''' InterfaceSubDeclaration  
     ''' [  Attributes  ]  [  InterfaceProcedureModifier+  ]  "Sub" SubSignature  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceSubDeclaration
         Dim result As New InterfaceSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4529" endline="4554"><![CDATA[
 
     ''' <summary>
     ''' InterfaceFunctionDeclaration  
     '''	[  Attributes  ]  [  InterfaceProcedureModifier+  ] "Function" FunctionSignature  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceFunctionDeclaration
         Dim result As New InterfaceFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4555" endline="4613"><![CDATA[
 
     ''' <summary>
     ''' ExternalSubDeclaration 
     ''' 	[  Attributes  ]  [  ExternalMethodModifier+  ] "Declare" [  CharsetModifier  ] "Sub" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalSubDeclaration
         Dim result As New ExternalSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
 
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4614" endline="4681"><![CDATA[
 
     ''' <summary>
     ''' ExternalFunctionDeclaration  
     '''	[  Attributes  ]  [  ExternalMethodModifier+  ]  "Declare" [  CharsetModifier  ] "Function" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  [  As  [  Attributes  ]  TypeName  ]
     '''		StatementTerminator
     ''' 
     ''' CharsetModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalFunctionDeclaration
         Dim result As New ExternalFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS = KS.None
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList, m_ReturnTypeAttributes, m_TypeName)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4682" endline="4704"><![CDATA[
 
     ''' <summary>
     ''' AliasClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAliasClause(ByVal Parent As ParsedObject) As AliasClause
         Dim result As New AliasClause(Parent)
 
         Dim m_StringLiteral As Token = Nothing
 
         tm.AcceptIfNotInternalError(KS.Alias)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4705" endline="4728"><![CDATA[
 
     ''' <summary>
     ''' LibraryClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLibraryClause(ByVal Parent As ParsedObject) As LibraryClause
         Dim result As New LibraryClause(Parent)
 
         Dim m_StringLiteral As Token
 
         tm.AcceptIfNotInternalError(KS.Lib)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             m_StringLiteral = Nothing
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4729" endline="4761"><![CDATA[
 
     ''' <summary>
     ''' ConstantDeclarator  
     ''' TODO
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstantDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal Modifiers As Modifiers) As ConstantDeclaration
         Dim result As New ConstantDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName = Nothing
         Dim m_ConstantExpression As Expression = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ConstantExpression = ParseExpression(result)
         If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(Modifiers, m_Identifier, m_TypeName, m_ConstantExpression)
 
         'Don't parse a StatementTerminator as the VB spec says.
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4762" endline="4777"><![CDATA[
 
     ''' <summary>
     ''' LocalDeclarationStatement  
     ''' </summary>
     Private Function ParseLocalDeclarationStatement(ByVal Parent As CodeBlock) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.LocalModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_Modifiers, New ParseAttributableInfo(Compiler, Nothing))
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4778" endline="4794"><![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseTypeVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As Generic.List(Of TypeVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseTypeVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4795" endline="4811"><![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseLocalVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4812" endline="4831"><![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLocalVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of LocalVariableDeclaration)
             tmp = ParseLocalVariableDeclarator(Parent, Modifiers, Info)
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4832" endline="4853"><![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of TypeVariableDeclaration)
             'Console.WriteLine("ParseTypeVariableDeclarators...")
             tmp = ParseTypeVariableDeclarator(Parent, Modifiers, Info)
             'Console.WriteLine("Got something
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4854" endline="4862"><![CDATA[
 
     Private Function ParseLocalVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
         If ParseVariableDeclarator(Parent, Modifiers, Info, result, True) = False Then
             Console.WriteLine("Returned false")
             Return Nothing
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4863" endline="4877"><![CDATA[
 
     Private Function ParseTypeVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
         Dim tmp As Boolean
 
         'Console.Write("ParseTypeVariableDeclarator...")
         tmp = ParseVariableDeclarator(Parent, Modifiers, Info, result, False)
         'Console.WriteLine("tmp
         If tmp = False Then
             'Console.WriteLine("tmp was false")
             Return Nothing
         End If
         'Console.WriteLine("tmp was true")
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4878" endline="4944"><![CDATA[
 
     ''' <summary>
     ''' VariableDeclarator  
     '''  	VariableIdentifiers  [  As  [  New  ]  TypeName  [  (  ArgumentList  )  ]  ]  |
     '''     VariableIdentifier   [  As  TypeName  ]  [  =  VariableInitializer  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo, ByVal result As IList, ByVal local As Boolean) As Boolean
         Dim m_VariableIdentifiers As VariableIdentifiers
         Dim m_IsNew As Boolean
         Dim m_TypeName As TypeName
         Dim m_VariableInitializer As VariableInitializer
         Dim m_ArgumentList As ArgumentList
 
         m_VariableIdentifiers = ParseVariableIdentifiers(Parent)
         If m_VariableIdentifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_IsNew = tm.Accept(KS.[New])
             If m_IsNew Then
                 'Arrays not allowed.
                 Dim m_NonArrayTypeName As NonArrayTypeName
                 m_NonArrayTypeName = ParseNonArrayTypeName(Parent)
                 If m_NonArrayTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = New TypeName(Parent, m_NonArrayTypeName)
             Else
                 'Arrays allowed.
                 m_TypeName = ParseTypeName(Parent)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         Else
             m_TypeName = Nothing
         End If
 
         If tm.Accept(KS.Equals) Then
             m_VariableInitializer = ParseVariableInitializer(Parent)
             If m_VariableInitializer Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30201, tm.CurrentLocation)
             m_ArgumentList = Nothing
         ElseIf tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(Parent)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(Parent)
             End If
             m_VariableInitializer = Nothing
         Else
             m_VariableInitializer = Nothing
             m_ArgumentList = Nothing
         End If
 
         'result Dim result As New Generic.List(Of VariableDeclaration)
         For Each identifier As VariableIdentifier In m_VariableIdentifiers
             Dim varD As VariableDeclaration
             If local Then
                 varD = New LocalVariableDeclaration(Parent, Modifiers, identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
             Else
                 varD = New TypeVariableDeclaration(Parent, Modifiers, identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
             End If
             varD.Location = identifier.Location
             varD.CustomAttributes = Info.Attributes
             result.Add(varD)
         Next
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4945" endline="4966"><![CDATA[
 
     Private Function ParseInterfacePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfacePropertyMemberDeclaration
         Dim result As New InterfacePropertyMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfacePropertyModifier)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4967" endline="4993"><![CDATA[
 
 
     ''' <summary>
     ''' LabelDeclarationStatement  
     ''' LabelName  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLabelDeclarationStatement(ByVal Parent As ParsedObject) As LabelDeclarationStatement
         Dim m_Label As Token
 
         If tm.CurrentToken.IsIdentifier OrElse tm.CurrentToken.IsIntegerLiteral Then
             m_Label = tm.CurrentToken
             tm.NextToken()
         Else
             Throw New InternalException(Parent)
         End If
 
         If tm.CurrentToken.Equals(KS.Colon) = False Then
             Throw New InternalException(Parent)
         End If
 
         If tm.PeekToken.IsEndOfLineOnly Then
             tm.NextToken()
         End If
 
         Return New LabelDeclarationStatement(Parent, m_Label)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4994" endline="5016"><![CDATA[
 
     ''' <summary>
     ''' ThrowStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseThrowStatement(ByVal Parent As ParsedObject) As ThrowStatement
         Dim result As New ThrowStatement(Parent)
 
         Dim m_Exception As Expression
 
         tm.AcceptIfNotInternalError(KS.Throw)
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_Exception = ParseExpression(result)
             If m_Exception Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Exception = Nothing
         End If
 
         result.Init(m_Exception)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5017" endline="5022"><![CDATA[
 
     Private Function ParseStopStatement(ByVal Parent As ParsedObject) As StopStatement
         tm.AcceptIfNotInternalError(KS.Stop)
 
         Return New StopStatement(Parent)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5023" endline="5031"><![CDATA[
 
     Private Function ParseResumeStatement(ByVal Parent As ParsedObject) As ResumeStatement
         Dim m_IsResumeNext As Boolean
 
         tm.AcceptIfNotInternalError(KS.Resume)
         m_IsResumeNext = tm.Accept(KS.Next)
 
         Return New ResumeStatement(Parent, m_IsResumeNext)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5032" endline="5059"><![CDATA[
 
     ''' <summary>
     ''' RedimStatement  
     ''' RedimClauses  
     '''	   RedimClause  |
     '''	   RedimClauses  ","  RedimClause
     ''' RedimClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseReDimStatement(ByVal Parent As ParsedObject) As ReDimStatement
         Dim result As New ReDimStatement(Parent)
 
         Dim m_IsPreserve As Boolean
         Dim m_Clauses As RedimClauses
 
         tm.AcceptIfNotInternalError(KS.ReDim)
         If tm.CurrentToken.Equals("Preserve") Then
             m_IsPreserve = True
             tm.NextToken()
         End If
 
         m_Clauses = ParseRedimClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsPreserve, m_Clauses)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5060" endline="5109"><![CDATA[
 
     ''' <summary>
     ''' OnErrorStatement  
     ''' ErrorClause  
     '''	   "GoTo"  "-"  "1" |
     '''	   "GoTo"  "0"  |
     '''	   GotoStatement  |
     '''	   "Resume" "Next"
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOnErrorStatement(ByVal Parent As ParsedObject) As OnErrorStatement
         Dim m_IsResumeNext As Boolean
         Dim m_Label As Token = Nothing
         Dim m_IsGotoMinusOne As Boolean
         Dim m_IsGotoZero As Boolean
 
         tm.AcceptIfNotInternalError(KS.On)
         If tm.Accept(KS.Error) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.Accept(KS.Resume) Then
             If tm.Accept(KS.Next) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_IsResumeNext = True
         Else
             If tm.Accept(KS.GoTo) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.CurrentToken.IsIntegerLiteral Then
                 If tm.CurrentToken.IntegralLiteral = 0 Then
                     m_IsGotoZero = True
                 Else
                     m_Label = tm.CurrentToken
                 End If
                 tm.NextToken()
             ElseIf tm.CurrentToken = KS.Minus AndAlso tm.PeekToken.IsIntegerLiteral Then
                 If tm.PeekToken.IntegralLiteral = 1 Then
                     m_IsGotoMinusOne = True
                     tm.NextToken(2)
                 Else
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     Compiler.Report.ShowMessage(Messages.VBNC90011, tm.CurrentLocation, "-1")
                 End If
             ElseIf tm.CurrentToken.IsIdentifier Then
                 m_Label = tm.CurrentToken
                 tm.NextToken()
             Else
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
                 Return Nothing
             End If
         End If
 
         Return New OnErrorStatement(Parent, m_IsResumeNext, m_Label, m_IsGotoMinusOne, m_IsGotoZero)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5110" endline="5129"><![CDATA[
 
 
     ''' <summary>
     ''' GotoStatement  
     ''' LabelName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseGotoStatement(ByVal Parent As ParsedObject) As GotoStatement
         Dim m_GotoWhere As Token
 
         tm.AcceptIfNotInternalError(KS.GoTo)
         If tm.CurrentToken.IsIdentifier OrElse tm.CurrentToken.IsIntegerLiteral Then
             m_GotoWhere = tm.CurrentToken
             tm.NextToken()
         Else
             Return Nothing
         End If
 
         Return New GotoStatement(Parent, m_GotoWhere)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5130" endline="5149"><![CDATA[
 
     ''' <summary>
     ''' ExitStatement  
     ''' ExitKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExitStatement(ByVal Parent As ParsedObject) As ExitStatement
         Dim m_ExitWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Exit)
         If tm.CurrentToken.Equals(KS.Sub, KS.Function, KS.Property, KS.Do, KS.For, KS.Try, KS.While, KS.Select) Then
             m_ExitWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30240, tm.CurrentLocation)
             Return Nothing
         End If
 
         Return New ExitStatement(Parent, m_ExitWhat)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5150" endline="5158"><![CDATA[
 
     ''' <summary>
     ''' EndStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEndStatement(ByVal Parent As ParsedObject) As EndStatement
         tm.AcceptIfNotInternalError(KS.End)
         Return New EndStatement(Parent)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5159" endline="5182"><![CDATA[
 
     ''' <summary>
     '''ContinueStatement  
     '''ContinueKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseContinueStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ContinueStatement
         Dim result As New ContinueStatement(Parent)
 
         Dim m_ContinueWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Continue)
         If tm.CurrentToken.Equals(KS.Do, KS.For, KS.While) Then
             m_ContinueWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30781, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_ContinueWhat)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5183" endline="5204"><![CDATA[
 
     ''' <summary>
     ''' EraseStatement  
     ''' EraseExpressions  
     '''	  Expression  |
     '''	  EraseExpressions  ,  Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEraseStatement(ByVal Parent As ParsedObject) As EraseStatement
         Dim result As New EraseStatement(Parent)
 
         Dim m_Targets As ExpressionList
 
         tm.AcceptIfNotInternalError(KS.Erase)
 
         m_Targets = ParseExpressionList(Parent)
         If m_Targets Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Targets)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5205" endline="5222"><![CDATA[
 
     Private Function ParseReturnStatement(ByVal Parent As ParsedObject) As ReturnStatement
         Dim result As New ReturnStatement(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Return)
         If Not tm.CurrentToken.IsEndOfStatement Then
             m_Expression = ParseExpression(result)
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression = Nothing
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5223" endline="5230"><![CDATA[
 
     Private Function ParseRedimClauses(ByVal Parent As ReDimStatement) As RedimClauses
         Dim result As New RedimClauses(Parent)
         If ParseList(Of RedimClause)(result, New ParseDelegate_Parent(Of RedimClause)(AddressOf ParseRedimClause), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5231" endline="5269"><![CDATA[
 
     ''' <summary>
     ''' RedimClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRedimClause(ByVal Parent As ParsedObject) As RedimClause
         Dim result As New RedimClause(Parent)
 
         Dim m_Expression As Expression
         Dim asim As ArraySizeInitializationModifier
 
         m_Expression = ParseExpression(result)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Dim invExpression As InvocationOrIndexExpression = TryCast(m_Expression, InvocationOrIndexExpression)
         If invExpression IsNot Nothing Then
             m_Expression = invExpression.Expression
             asim = New ArraySizeInitializationModifier(result)
             Dim bl As New BoundList(asim)
             Dim exp() As Expression
 
             ReDim exp(invExpression.ArgumentList.Count - 1)
             For i As Integer = 0 To invExpression.ArgumentList.Count - 1
                 exp(i) = invExpression.ArgumentList(i).Expression
             Next
             bl.Init(exp)
             asim.Init(bl, Nothing)
 
         ElseIf tm.CurrentToken.Equals(KS.LParenthesis) AndAlso tm.PeekToken.IsIntegerLiteral AndAlso tm.PeekToken.IntegralLiteral = 0 AndAlso tm.PeekToken(2).Equals(KS.To) Then
             asim = ParseArraySizeInitializationModifer(result)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_Expression, asim)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5270" endline="5288"><![CDATA[
 
     ''' <summary>
     ''' ErrorStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseErrorStatement(ByVal Parent As ParsedObject) As ErrorStatement
         Dim result As New ErrorStatement(Parent)
 
         Dim m_ErrNumber As Expression
 
         tm.AcceptIfNotInternalError(KS.Error)
 
         m_ErrNumber = ParseExpression(result)
         If m_ErrNumber Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_ErrNumber)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5289" endline="5331"><![CDATA[
 
     ''' <summary>
     ''' MidAssignmentStatement  
     '''	   "Mid" [ "$" ]  "("  Expression "," Expression  [ "," Expression  ] ")"  =  Expression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseMidAssignmentStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As MidAssignStatement
         Dim result As New MidAssignStatement(Parent)
 
         Dim m_Target As Expression
         Dim m_Start As Expression
         Dim m_Length As Expression
         Dim m_Source As Expression
 
         tm.AcceptIfNotInternalError("Mid")
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Target = ParseExpression(result)
         If m_Target Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Start = ParseExpression(result)
         If m_Start Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) Then
             m_Length = ParseExpression(result)
             If m_Length Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Length = Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.Accept(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Source = ParseExpression(result)
         If m_Source Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Target, m_Start, m_Length, m_Source)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5332" endline="5359"><![CDATA[
     ''' <summary>
     ''' WhileStatement  
     '''	   "While" BooleanExpression  StatementTerminator
     '''	         [  Block  ]
     '''	   "End" "While" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWhileStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WhileStatement
         Dim result As New WhileStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.While)
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.While) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Condition, m_Code)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5360" endline="5389"><![CDATA[
 
     ''' <summary>
     ''' WithStatement  
     '''	   "With" Expression  StatementTerminator
     '''	        [  Block  ]
     '''	   "End" "With" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWithStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WithStatement
         Dim result As New WithStatement(Parent)
 
         Dim m_WithExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.With)
 
         m_WithExpression = ParseExpression(result)
         If m_WithExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_Code = ParseCodeBlock(result, IsOneLiner)
 
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.With) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_WithExpression)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5390" endline="5445"><![CDATA[
 
     ''' <summary>
     ''' Homebrew
     ''' UsingDeclarator 
     '''  Identifier  [  As  [  New  ]  NonArrayTypeName  [  (  ArgumentList  )  ]  ]  |
     '''  Identifier  [  As  NonArrayTypeName  ]  [  =  VariableInitializer  ]
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseUsingDeclarator(ByVal Parent As ParsedObject) As UsingDeclarator
         Dim result As New UsingDeclarator(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_IsNew As Boolean
         Dim m_IsVariableDeclaration As Boolean
         Dim m_TypeName As NonArrayTypeName
         Dim m_VariableInitializer As VariableInitializer = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
         Dim m_VariableDeclaration As LocalVariableDeclaration
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_IsVariableDeclaration = True
             m_IsNew = tm.Accept(KS.[New])
 
             m_TypeName = ParseNonArrayTypeName(result)
 
             If m_IsNew = False Then
                 If tm.Accept(KS.Equals) Then
                     m_VariableInitializer = ParseVariableInitializer(result)
                 End If
             Else
                 If tm.Accept(KS.LParenthesis) Then
                     If tm.Accept(KS.RParenthesis) = False Then
                         m_ArgumentList = ParseArgumentList(result)
                         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
                 End If
                 If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
             End If
 
             m_VariableDeclaration = New LocalVariableDeclaration(result, m_Identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
         Else
             m_VariableDeclaration = Nothing
             m_VariableInitializer = Nothing
             m_ArgumentList = Nothing
             m_TypeName = Nothing
         End If
 
 
         result.Init(m_Identifier, m_IsNew, m_TypeName, m_ArgumentList, m_VariableInitializer, m_IsVariableDeclaration, m_VariableDeclaration)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5446" endline="5503"><![CDATA[
 
     ''' <summary>
     ''' UsingStatement  
     '''	"Using" UsingResources  StatementTerminator
     '''		[  Block  ]
     '''	"End" "Using" StatementTerminator
     ''' 
     ''' UsingResources  
     ''' 
     ''' LAMESPEC!?
     ''' I'm using this
     ''' UsingResources 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseUsingStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As UsingStatement
         Dim result As New UsingStatement(Parent)
 
         Dim m_UsingResources As ParsedObject
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Using)
 
         Dim newDecls As UsingDeclarators = Nothing
         If tm.CurrentToken.IsIdentifier AndAlso tm.PeekToken.Equals(KS.Equals, KS.As) Then
             'This is a variable declaration
             newDecls = New UsingDeclarators(result)
             If ParseList(Of UsingDeclarator)(newDecls, New ParseDelegate_Parent(Of UsingDeclarator)(AddressOf ParseUsingDeclarator), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_UsingResources = newDecls
         Else
             'This is an expression
             Dim exp As Expression = Nothing
             exp = ParseExpression(result)
             If exp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_UsingResources = exp
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If newDecls IsNot Nothing Then
             For Each decl As UsingDeclarator In newDecls
                 If decl.IsVariableDeclaration Then
                     m_Code.Variables.Add(decl.VariableDeclaration)
                 End If
                 decl.Parent = m_Code
             Next
         End If
 
         If tm.Accept(KS.End, KS.Using) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_UsingResources, m_Code)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5504" endline="5533"><![CDATA[
 
     ''' <summary>
     '''SyncLockStatement  
     '''	"SyncLock" Expression  StatementTerminator
     '''	   [  Block  ]
     '''	"End" "SyncLock" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSyncLockStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SyncLockStatement
         Dim result As New SyncLockStatement(Parent)
 
         Dim m_Lock As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.SyncLock)
 
         m_Lock = ParseExpression(result)
         If m_Lock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.SyncLock) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Lock, m_Code)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5534" endline="5550"><![CDATA[
 
     Private Function ParseDoStatementCondition(ByVal Parent As ParsedObject, ByRef IsWhile As Boolean) As Expression
         Dim result As Expression = Nothing
 
         If tm.Accept(KS.While) Then
             IsWhile = True
             result = ParseExpression(Parent)
         ElseIf tm.Accept(KS.Until) Then
             IsWhile = False
             result = ParseExpression(Parent)
         Else
             Throw New InternalException(result)
         End If
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5551" endline="5607"><![CDATA[
 
     ''' <summary>
     ''' DoLoopStatement  
     ''' DoTopLoopStatement  
     '''	   "Do" [  WhileOrUntil  BooleanExpression  ]  StatementTerminator
     '''	       [  Block  ]
     '''	   "Loop" StatementTerminator
     ''' DoBottomLoopStatement  
     '''	   "Do" StatementTerminator
     '''	       [  Block  ]
     '''	   "Loop" WhileOrUntil  BooleanExpression  StatementTerminator
     '''WhileOrUntil  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDoStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As DoStatement
         Dim result As New DoStatement(Parent)
 
         Dim m_PreCondition As Expression
         Dim m_PostCondition As Expression
         Dim m_IsWhile As Boolean
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Do)
         If tm.CurrentToken.Equals(KS.While, KS.Until) Then
             m_PreCondition = ParseDoStatementCondition(result, m_IsWhile)
             If m_PreCondition Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             End If
         Else
             m_PreCondition = Nothing
         End If
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Loop) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.CurrentToken.Equals(KS.While, KS.Until) Then
             m_PostCondition = ParseDoStatementCondition(result, m_IsWhile)
             If m_PostCondition Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             End If
         Else
             m_PostCondition = Nothing
         End If
 
         result.Init(m_PreCondition, m_PostCondition, m_IsWhile, m_Code)
 
         If m_PreCondition IsNot Nothing AndAlso m_PostCondition IsNot Nothing Then
             'helper.AddError "error BC30238
             Compiler.Report.ShowMessage(Messages.VBNC30238, tm.CurrentLocation)
             result.HasErrors = True
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5608" endline="5651"><![CDATA[
 
     ''' <summary>
     '''TryStatement  
     '''	"Try" StatementTerminator
     '''	   [  Block  ]
     '''	[  CatchStatement+  ]
     '''	[  FinallyStatement  ]
     '''	"End" "Try" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTryStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As TryStatement
         Dim result As New TryStatement(Parent)
 
         Dim m_TryCode As CodeBlock
         Dim m_FinallyBlock As CodeBlock
         Dim m_Catches As BaseObjects(Of CatchStatement)
 
         tm.AcceptIfNotInternalError(KS.Try)
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_TryCode = ParseCodeBlock(result, IsOneLiner)
         If m_TryCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Catches = New BaseObjects(Of CatchStatement)(result)
         While tm.CurrentToken = KS.Catch
             Dim newCatch As CatchStatement
             newCatch = ParseCatchStatement(result, IsOneLiner)
             m_Catches.Add(newCatch)
         End While
         While tm.CurrentToken = KS.Catch
             Dim newCatch As CatchStatement
             newCatch = ParseCatchStatement(result, IsOneLiner)
             m_Catches.Add(newCatch)
         End While
 
         If tm.Accept(KS.Finally) Then
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_FinallyBlock = ParseCodeBlock(result, IsOneLiner)
             If m_FinallyBlock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_FinallyBlock = Nothing
         End If
 
         If tm.Accept(KS.End, KS.Try) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Catches, m_TryCode, m_FinallyBlock)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5652" endline="5691"><![CDATA[
 
     ''' <summary>
     ''' CatchStatement  
     '''	   "Catch" [  Identifier "As" NonArrayTypeName  ]  [ "When" BooleanExpression  ]  StatementTerminator
     '''	      [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCatchStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CatchStatement
         Dim result As New CatchStatement(Parent)
 
         Dim m_Code As CodeBlock
         Dim m_Variable As Identifier = Nothing
         Dim m_When As Expression = Nothing
         Dim m_TypeName As NonArrayTypeName = Nothing
 
         tm.AcceptIfNotInternalError(KS.Catch)
 
         If tm.AcceptEndOfStatement(IsOneLiner) = False Then
             m_Variable = ParseIdentifier(result)
             If m_Variable IsNot Nothing Then
                 If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = ParseNonArrayTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.Accept(KS.When) Then
                 m_When = ParseExpression(result)
                 If m_When Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Variable, m_TypeName, m_When, m_Code)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5692" endline="5764"><![CDATA[
     ''' <summary>
     ''' IfStatement  
     ''' BlockIfStatement  
     '''	   "If" BooleanExpression  [ "Then" ]  StatementTerminator
     '''	        [  Block  ]
     '''	   [  ElseIfStatement+  ]
     '''	   [  ElseStatement  ]
     '''	   "End" "If" StatementTerminator
     ''' ElseIfStatement  
     '''	   "ElseIf" BooleanExpression  [ "Then" ]  StatementTerminator
     '''	        [  Block  ]
     ''' ElseStatement  
     '''	   "Else" StatementTerminator
     '''	        [  Block  ]
     ''' LineIfThenStatement  
     '''	   "If" BooleanExpression "Then" Statements  [ "Else" Statements  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseIfStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As IfStatement
         Dim result As New IfStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_TrueCode As CodeBlock
         Dim m_FalseCode As CodeBlock
         Dim m_OneLiner As Boolean
         Dim m_ElseIfs As BaseObjects(Of ElseIfStatement)
 
         tm.AcceptIfNotInternalError(KS.If)
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Then) = False Then
             m_OneLiner = False 'Cannot be a oneliner if Then is not found.
             If IsOneLiner Then
                 Helper.AddError(Compiler, tm.CurrentLocation, "report error BC30081, 'if' must end with a matching 'end if'")
                 tm.GotoNewline(False)
             Else
                 tm.AcceptEndOfStatement(False, True)
             End If
         Else
             If IsOneLiner = False Then
                 m_OneLiner = Not tm.AcceptEndOfStatement(False, False)
             Else
                 m_OneLiner = True
             End If
         End If
 
         m_TrueCode = ParseCodeBlock(result, m_OneLiner)
         If m_TrueCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ElseIfs = New BaseObjects(Of ElseIfStatement)(result)
         While tm.CurrentToken = KS.ElseIf OrElse (m_OneLiner = False AndAlso tm.CurrentToken = KS.Else AndAlso tm.PeekToken = KS.If)
             Dim newElseIf As ElseIfStatement
             newElseIf = ParseElseIfStatement(result, m_OneLiner)
             m_ElseIfs.Add(newElseIf)
         End While
         While tm.CurrentToken = KS.ElseIf OrElse (m_OneLiner = False AndAlso tm.CurrentToken = KS.Else AndAlso tm.PeekToken = KS.If)
             Dim newElseIf As ElseIfStatement
             newElseIf = ParseElseIfStatement(result, m_OneLiner)
             m_ElseIfs.Add(newElseIf)
         End While
 
         If tm.Accept(KS.Else) Then
             If m_OneLiner = False Then
                 If tm.AcceptEndOfStatement(False, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_FalseCode = ParseCodeBlock(result, m_OneLiner)
             If m_FalseCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_FalseCode = Nothing
         End If
 
         If m_OneLiner = False Then tm.AcceptIfNotError(KS.End, KS.If)
 
         result.Init(m_Condition, m_FalseCode, m_TrueCode, m_OneLiner, m_ElseIfs)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5765" endline="5802"><![CDATA[
 
     ''' <summary>
     ''' ElseIfStatement  
     '''	   "ElseIf" BooleanExpression  [  Then  ]  StatementTerminator
     '''	        [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseElseIfStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ElseIfStatement
         Dim result As New ElseIfStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         If tm.Accept(KS.Else) Then
             'This is not in the spec, but MS is accepting it anyway.
             'See test Bugs/aspnet2.vb for a test case.
             tm.AcceptIfNotInternalError(KS.If)
         Else
             tm.AcceptIfNotInternalError(KS.ElseIf)
         End If
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         'ElseIf cannot be a oneliner...
         tm.Accept(KS.Then) '"Then" is not required.
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If IsOneLiner Then
             Helper.AddError(Compiler, tm.CurrentLocation)
             'TODO
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_Condition)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5803" endline="5839"><![CDATA[
 
     ''' <summary>
     ''' SelectStatement  
     '''	   "Select" [ "Case" ]  Expression  StatementTerminator
     '''	        [  CaseStatement+  ]
     '''	        [  CaseElseStatement  ]
     '''	   "End" "Select" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSelectStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SelectStatement
         Dim result As New SelectStatement(Parent)
 
         Dim m_Test As Expression
         Dim m_Cases As BaseObjects(Of CaseStatement)
 
         tm.AcceptIfNotInternalError(KS.Select)
 
         tm.Accept(KS.Case) '"Case" is not required
 
         m_Test = ParseExpression(result)
         If m_Test Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Cases = New BaseObjects(Of CaseStatement)(result)
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
 
         If tm.Accept(KS.End, KS.Select) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Test, m_Cases)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5840" endline="5879"><![CDATA[
 
     ''' <summary>
     ''' CaseStatement  
     '''	   "Case" CaseClauses  StatementTerminator
     '''	        [  Block  ]
     ''' CaseElseStatement  
     '''	   "Case" "Else" StatementTerminator
     '''	   [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCaseStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CaseStatement
         Dim result As New CaseStatement(Parent)
 
         Dim m_IsElse As Boolean
         Dim m_Clauses As CaseClauses
         Dim m_Block As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Case)
         If tm.Accept(KS.Else) Then
             m_IsElse = True
             m_Clauses = Nothing
         Else
             m_Clauses = New CaseClauses(result)
             If ParseList(Of CaseClause)(m_Clauses, New ParseDelegate_Parent(Of CaseClause)(AddressOf ParseCaseClause), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         m_Block = ParseCodeBlock(result, IsOneLiner)
         If m_Block Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_IsElse, m_Clauses, m_Block)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5880" endline="5891"><![CDATA[
 
     Private Function ParseCallStatement(ByVal Parent As ParsedObject) As CallStatement
         Dim result As New CallStatement(Parent)
 
         Dim m_Target As Expression
         tm.AcceptIfNotInternalError(KS.Call)
         m_Target = ParseExpression(result)
 
         result.Init(m_Target)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5892" endline="5935"><![CDATA[
 
     ''' <summary>
     ''' ForEachStatement  
     '''	   "For" "Each" LoopControlVariable "In" Expression  StatementTerminator
     '''	         [  Block  ]
     '''	   "Next" [Expression  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseForEachStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ForEachStatement
         Dim result As New ForEachStatement(Parent)
 
         Dim m_LoopControlVariable As LoopControlVariable
         Dim m_InExpression As Expression
         Dim m_NextExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.For)
         tm.AcceptIfNotInternalError(KS.Each)
 
         m_LoopControlVariable = ParseLoopControlVariable(result)
         If m_LoopControlVariable Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.In) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_InExpression = ParseExpression(result)
         If m_InExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Next) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_NextExpression = ParseExpression(result)
             If m_NextExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_NextExpression = Nothing
         End If
 
         result.Init(m_LoopControlVariable, m_InExpression, m_NextExpression, m_Code)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5936" endline="6003"><![CDATA[
 
     ''' <summary>
     ''' ForStatement  
     '''	   "For" LoopControlVariable  "="  Expression  "To"  Expression  [  "Step"  Expression  ]  StatementTerminator
     '''	      [ Block  ]
     '''	   "Next" [  NextExpressionList  ]  StatementTerminator
     ''' LoopControlVariable  
     '''	   Identifier  [  ArrayNameModifier  ] "As" TypeName  |
     '''	   Expression
     ''' NextExpressionList  
     '''	   Expression  |
     '''	   NextExpressionList "," Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseForStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ForStatement
         Dim result As New ForStatement(Parent)
 
         Dim m_LoopControlVariable As LoopControlVariable
         Dim m_LoopStartExpression As Expression
         Dim m_LoopEndExpression As Expression
         Dim m_LoopStepExpression As Expression
         Dim m_NextExpressionList As ExpressionList
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.For)
         m_LoopControlVariable = ParseLoopControlVariable(result)
         If m_LoopControlVariable Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LoopStartExpression = ParseExpression(result)
         If m_LoopStartExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.To) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LoopEndExpression = ParseExpression(result)
         If m_LoopEndExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Step) Then
             m_LoopStepExpression = ParseExpression(result)
             If m_LoopStepExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_LoopStepExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Next) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30084, tm.CurrentLocation)
             Return result
         End If
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_NextExpressionList = New ExpressionList(result)
             If ParseList(Of Expression)(m_NextExpressionList, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         Else
             m_NextExpressionList = Nothing
         End If
 
         result.Init(m_LoopControlVariable, m_LoopStartExpression, m_LoopEndExpression, m_LoopStepExpression, m_NextExpressionList, m_Code)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6004" endline="6039"><![CDATA[
 
     Private Function ParseCaseClause(ByVal Parent As ParsedObject) As CaseClause
         Dim result As New CaseClause(Parent)
 
         Dim m_Expression1 As Expression
         Dim m_Expression2 As Expression = Nothing
         Dim m_Comparison As KS
 
         If tm.Accept(KS.Is) Then
             If tm.CurrentToken.Equals(CaseClause.RelationalOperators) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30239, tm.CurrentLocation)
                 m_Comparison = KS.Equals
             Else
                 m_Comparison = tm.CurrentToken.Symbol
                 tm.NextToken()
             End If
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.Equals(CaseClause.RelationalOperators) Then
             m_Comparison = tm.CurrentToken.Symbol
             tm.NextToken()
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.Accept(KS.To) Then
                 m_Expression2 = ParseExpression(result)
                 If m_Expression2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         result.Init(m_Expression1, m_Expression2, m_Comparison)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6040" endline="6072"><![CDATA[
 
     ''' <summary>
     ''' AddHandlerStatement  
     ''' RemoveHandlerStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddOrRemoveHandlerStatement(ByVal Parent As ParsedObject) As AddOrRemoveHandlerStatement
         Dim result As New AddOrRemoveHandlerStatement(Parent)
 
         Dim m_Event As Expression
         Dim m_EventHandler As Expression
         Dim m_IsAddHandler As Boolean
 
         If tm.Accept(KS.AddHandler) Then
             m_IsAddHandler = True
         ElseIf tm.Accept(KS.RemoveHandler) Then
             m_IsAddHandler = False
         Else
             Throw New InternalException(result)
         End If
 
         m_Event = ParseExpression(result)
         If m_Event Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_EventHandler = ParseExpression(result)
         If m_EventHandler Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Event, m_EventHandler, m_IsAddHandler)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6073" endline="6082"><![CDATA[
 
     Private Function ParseImportsStatements(ByVal Parent As ParsedObject) As Generic.List(Of ImportsStatement)
         Dim result As New Generic.List(Of ImportsStatement)
         While ImportsStatement.IsMe(tm)
             Dim newI As ImportsStatement
             newI = ParseImportsStatement(Parent)
             result.Add(newI)
         End While
         While ImportsStatement.IsMe(tm)
             Dim newI As ImportsStatement
             newI = ParseImportsStatement(Parent)
             result.Add(newI)
         End While
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6083" endline="6103"><![CDATA[
 
     ''' <summary>
     ''' ImportsStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsStatement(ByVal Parent As ParsedObject) As ImportsStatement
         Dim result As New ImportsStatement(Parent)
 
         Dim m_Clauses As ImportsClauses
 
         tm.AcceptIfNotInternalError(KS.Imports)
 
         m_Clauses = ParseImportsClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6104" endline="6120"><![CDATA[
 
     ''' <summary>
     ''' Parses a imports statement as specified on the commandline.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Shared Function ParseImportsStatement(ByVal Parent As ImportsStatement, ByVal str As String) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Parent IsNot Nothing)
         Helper.Assert(Parent.Clauses IsNot Nothing)
 
         result = ParseImportsClauses(Parent.Clauses, str) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6121" endline="6165"><![CDATA[
 
     Private Function GetPartialType(ByVal Parent As ParsedObject, ByVal m_Identifier As Identifier, ByVal m_TypeParameters As TypeParameters, ByVal m_Modifiers As Modifiers, ByVal IsClass As Boolean, ByVal [Namespace] As String) As PartialTypeDeclaration
         Dim result As PartialTypeDeclaration
 
         'Get the actual name of the type including generic number
         Dim CompleteName As String
         Dim GenericName As Identifier
         If m_TypeParameters Is Nothing Then
             GenericName = m_Identifier
         Else
             GenericName = New Identifier(Helper.CreateGenericTypename(m_Identifier.Name, m_TypeParameters.Parameters.Count))
         End If
 
         CompleteName = GenericName.Name
         If TypeOf Parent Is AssemblyDeclaration AndAlso [Namespace] <> String.Empty Then
             CompleteName = [Namespace] & "." & CompleteName
         End If
 
         'Try to find the type in the parent
         Dim partialType As TypeDeclaration = FindTypeInParent(Parent, CompleteName)
         Dim partialClassOrStruct As PartialTypeDeclaration = TryCast(partialType, PartialTypeDeclaration)
 
         If partialType IsNot Nothing Then
             'There is already a type with the same name
             result = partialClassOrStruct
             result.IsPartial = True
             result.Modifiers = result.Modifiers.AddModifiers(m_Modifiers.Mask)
             result.PartialModifierFound = result.Modifiers.Is(ModifierMasks.Partial) OrElse m_Modifiers.Is(ModifierMasks.Partial)
         ElseIf partialType IsNot Nothing Then
             'There is another type with the same name
             Helper.AddError(tm.Compiler, tm.CurrentLocation, "Two types with the same name
             Return Nothing
         Else
             'No type with the same name.
             If IsClass Then
                 result = New ClassDeclaration(Parent, [Namespace], GenericName, m_TypeParameters)
             Else
                 result = New StructureDeclaration(Parent, [Namespace], GenericName, m_TypeParameters)
             End If
             result.Modifiers = m_Modifiers
             result.UpdateDefinition()
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6166" endline="6256"><![CDATA[
     ''' <summary>
     ''' ClassDeclaration  
     '''	[  Attributes  ]  [  ClassModifier+  ]  "Class"  Identifier  [  TypeParameters  ]  StatementTerminator
     '''	[  ClassBase  ]
     '''	[  TypeImplementsClause+  ]
     '''	[  ClassMemberDeclaration+  ]
     '''	"End" "Class" StatementTerminator
     ''' 
     ''' ClassBase 
     ''' </summary>
     ''' <param name="Parent">Should be the declaring type of the assembly itself it is not a nested type.</param>
     ''' <param name="Attributes"></param>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseClassDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As ClassDeclaration
         Dim result As ClassDeclaration
         Dim partialType As PartialTypeDeclaration
 
         Dim m_Attributes As Attributes
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeParameters As TypeParameters
         Dim m_Inherits As NonArrayTypeName
         Dim m_DeclaringType As TypeDeclaration
 
         m_DeclaringType = TryCast(Parent, TypeDeclaration)
         Helper.Assert(m_DeclaringType IsNot Nothing OrElse TypeOf Parent Is AssemblyDeclaration)
 
         m_Attributes = Attributes
         m_Modifiers = ParseModifiers(ModifierMasks.ClassModifiers)
 
         tm.AcceptIfNotInternalError(KS.Class)
 
         m_Identifier = ParseIdentifier(CType(Nothing, ParsedObject))
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(Nothing)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeParameters = Nothing
         End If
 
         'Here we have enough information to know if it's a partial type or not
         partialType = GetPartialType(Parent, m_Identifier, m_TypeParameters, m_Modifiers, True, [Namespace])
 
         result = TryCast(partialType, ClassDeclaration)
         If result Is Nothing Then
             If partialType IsNot Nothing Then
                 Helper.AddError(tm.Compiler, tm.CurrentLocation, "Partial types must be either all classes or all structures.")
             Else
                 'Error message has already been shown
             End If
             Return Nothing
         End If
 
         m_Identifier.Parent = result
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         If tm.Accept(KS.Inherits) Then
             m_Inherits = ParseNonArrayTypeName(result)
             If m_Inherits Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Inherits = Nothing
         End If
         If m_Inherits IsNot Nothing Then result.AddInheritsClause(m_Inherits)
 
         If TypeImplementsClauses.IsMe(tm) Then
             result.Implements = ParseTypeImplementsClauses(result)
             If result.Implements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Class) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result.CustomAttributes IsNot Nothing Then
             result.CustomAttributes.AddRange(Attributes)
         Else
             result.CustomAttributes = Attributes
         End If
         result.UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6257" endline="6280"><![CDATA[
 
     Private Function FindTypeInParent(ByVal Parent As ParsedObject, ByVal CompleteName As String) As TypeDeclaration
         Dim assemblyParent As AssemblyDeclaration = TryCast(Parent, AssemblyDeclaration)
         Dim typeParent As TypeDeclaration = TryCast(Parent, TypeDeclaration)
         Dim partialType As TypeDeclaration = Nothing
         Dim partialTypes As Generic.List(Of INameable)
 
         If assemblyParent IsNot Nothing Then
             partialType = assemblyParent.FindTypeWithFullname(CompleteName)
         ElseIf typeParent IsNot Nothing Then
             partialTypes = typeParent.Members.Index.Item(CompleteName)
             If partialTypes IsNot Nothing Then
                 If partialTypes.Count = 1 Then
                     partialType = TryCast(partialTypes(0), TypeDeclaration)
                     If partialType Is Nothing Then
                         Helper.AddError(Compiler, tm.CurrentLocation, "Already a member with the name " & CompleteName)
                     End If
                 ElseIf partialTypes.Count > 1 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Already a member with the name " & CompleteName)
                 End If
             End If
         End If
         Return partialType
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330"><![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6331" endline="6358"><![CDATA[
 
     ''' <summary>
     ''' Parses enum members.
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseEnumMembers(ByVal Parent As EnumDeclaration) As Boolean
         Dim newConst As EnumMemberDeclaration
         Dim constAttributes As Attributes
 
         Do Until tm.CurrentToken.Equals(KS.End, KS.Enum)
             constAttributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, constAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             newConst = ParseEnumMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, constAttributes), Parent.Members.Count)
             If newConst Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Return False
             End If
             Parent.Members.Add(newConst)
         Loop
         Do Until tm.CurrentToken.Equals(KS.End, KS.Enum)
             constAttributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, constAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             newConst = ParseEnumMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, constAttributes), Parent.Members.Count)
             If newConst Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Return False
             End If
             Parent.Members.Add(newConst)
         Loop
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6359" endline="6403"><![CDATA[
 
     ''' <summary>
     ''' EnumDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Enum"  Identifier  [  "As"  IntegralTypeName  ]  StatementTerminator
     '''	   EnumMemberDeclaration+
     '''	"End" "Enum"  StatementTerminator
     ''' 
     ''' LAMESPEC
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As EnumDeclaration
         Dim result As EnumDeclaration
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_QualifiedName As KS = KS.Integer
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Enum)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If tm.CurrentToken.Equals(Enums.IntegralTypeNames) Then
                 m_QualifiedName = tm.CurrentToken.Keyword
                 tm.NextToken()
             Else
                 Helper.AddError(Compiler, tm.CurrentLocation, "Enum type must be integral")
             End If
         End If
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result = New EnumDeclaration(Parent, [Namespace], m_Identifier, m_QualifiedName)
 
         If ParseEnumMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Enum) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6404" endline="6459"><![CDATA[
 
     ''' <summary>
     ''' InterfaceDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Interface" Identifier  [  TypeParameters  ]  StatementTerminator
     '''	[  InterfaceBase+  ]
     '''	[  InterfaceMemberDeclaration+  ]
     '''	"End" "Interface" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As InterfaceDeclaration
         Dim result As InterfaceDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_GenericName As Identifier
         Dim m_TypeParameters As TypeParameters
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Interface)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(Parent)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_GenericName = Helper.CreateGenericTypename(m_Identifier, m_TypeParameters)
         Else
             m_TypeParameters = Nothing
             m_GenericName = m_Identifier
         End If
 
         result = New InterfaceDeclaration(Parent, [Namespace], m_GenericName, m_TypeParameters)
 
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         If InterfaceBases.IsMe(tm) Then
             result.InterfaceBases = ParseInterfaceBases(result)
             If result.InterfaceBases Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If ParseInterfaceMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Interface) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6460" endline="6499"><![CDATA[
 
     ''' <summary>
     ''' ModuleDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Module"  Identifier  StatementTerminator
     '''	[  ModuleMemberDeclaration+  ]
     '''	"End" "Module" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseModuleDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As ModuleDeclaration
         Dim result As ModuleDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Name As Identifier
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Module)
 
         m_Name = ParseIdentifier()
         If m_Name Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result = New ModuleDeclaration(Parent, [Namespace], m_Name)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Module) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result.CustomAttributes IsNot Nothing Then
             result.CustomAttributes.AddRange(Attributes)
         Else
             result.CustomAttributes = Attributes
         End If
         result.Modifiers = m_Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6500" endline="6567"><![CDATA[
 
     ''' <summary>
     ''' StructureDeclaration  
     '''	[  Attributes  ]  [  StructureModifier+  ]  "Structure" Identifier  [  TypeParameters  ]	StatementTerminator
     '''	[  TypeImplementsClause+  ]
     '''	[  StructMemberDeclaration+  ]
     '''	"End" "Structure"  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseStructureDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As StructureDeclaration
         Dim result As StructureDeclaration = Nothing
         Dim partialType As PartialTypeDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeParameters As TypeParameters
         Dim m_DeclaringType As TypeDeclaration
         Dim m_Attributes As Attributes
 
         m_DeclaringType = TryCast(Parent, TypeDeclaration)
         Helper.Assert(m_DeclaringType IsNot Nothing OrElse TypeOf Parent Is AssemblyDeclaration)
 
         m_Attributes = Attributes
         m_Modifiers = ParseModifiers(ModifierMasks.StructureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Structure)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(result)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeParameters = Nothing
         End If
 
         'Here we have enough information to know if it's a partial type or not
         partialType = GetPartialType(Parent, m_Identifier, m_TypeParameters, m_Modifiers, False, [Namespace])
 
         result = TryCast(partialType, StructureDeclaration)
         If result Is Nothing Then
             If partialType IsNot Nothing Then
                 Helper.AddError(tm.Compiler, tm.CurrentLocation, "Partial types must be either all classes or all structures.")
             Else
                 'Error message has already been shown
             End If
             Return Nothing
         End If
 
         m_Identifier.Parent = result
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         result.Implements = ParseTypeImplementsClauses(result)
         If result.Implements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Structure) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParseTypeInfo.vb" startline="27" endline="29"><![CDATA[
         Get
             Return m_Namespace
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParseTypeInfo.vb" startline="30" endline="35"><![CDATA[
     End Property
 
     ReadOnly Property BaseType() As IType
         Get
             Return m_BaseType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParseTypeInfo.vb" startline="36" endline="42"><![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler, ByVal Attributes As Attributes, ByVal [Namespace] As String, ByVal BaseType As IType)
         MyBase.New(Compiler, Attributes)
         m_Namespace = [Namespace]
         m_BaseType = BaseType
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="32" endline="39"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_EventHandler IsNot Nothing Then result = m_EventHandler.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="40" endline="43"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="44" endline="49"><![CDATA[
 
     Sub Init(ByVal [Event] As Expression, ByVal EventHandler As Expression, ByVal IsAddHandler As Boolean)
         m_Event = [Event]
         m_EventHandler = EventHandler
         m_IsAddHandler = IsAddHandler
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="50" endline="65"><![CDATA[
 
     Sub Init(ByVal [Event] As Expression, ByVal EventHandler As MethodDeclaration, ByVal IsAddHandler As Boolean, ByVal InstanceExpression As Expression)
         Dim result As Boolean = True
         m_Event = [Event]
         m_IsAddHandler = IsAddHandler
 
         Dim o As Object = CType(CecilHelper.FindDefinition(m_Event.Classification.AsEventAccess.EventType), Mono.Cecil.TypeDefinition).Methods(0).Parameters
 
         Dim eventInfo As Mono.Cecil.EventReference = m_Event.Classification.AsEventAccess.EventInfo
         Dim objCreation As New DelegateOrObjectCreationExpression(Me)
         Dim methodPointer As New AddressOfExpression(Me)
         methodPointer.Init(EventHandler, InstanceExpression)
         objCreation.Init(eventInfo.EventType, New ArgumentList(objCreation, methodPointer))
         result = objCreation.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
         m_EventHandler = objCreation
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="66" endline="70"><![CDATA[
 
     ReadOnly Property [Event]() As Expression
         Get
             Return m_Event
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="71" endline="76"><![CDATA[
     End Property
 
     ReadOnly Property EventHandler() As Expression
         Get
             Return m_EventHandler
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="77" endline="81"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Return GenerateCode(Info, m_IsAddHandler)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="82" endline="123"><![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal IsAddHandler As Boolean) As Boolean
         Dim result As Boolean = True
 
         Dim handler As Mono.Cecil.MethodReference
 
         '1 - Load the instance expression of the event (m_Event)
         '    (first argument to the add/remove method - the this pointer)
         '2 - Create the delegate to call when the event is fired.
         '    (second argument to the add/remove method).
         '2.1 - Load the instance expression of the eventhandler (m_EventHandler)
         '      (first argument to the delegate constructor).
         '2.2 - Load the method pointer of the eventhandler (m_EventHandler)
         '      (second argument to the delegate constructor).
         '2.2.1 - Load the instance expression of the eventhandler (m_EventHandler)
         '        (the argument of the load method pointer instruction)
         '2.2.2 - Call the method pointer creation instruction.
         '2.3 - Call the delegate's constructor.
         '3 - Call the add/remove method
 
         Helper.Assert(m_Event.Classification.IsEventAccessClassification)
         Helper.Assert(m_EventHandler.Classification.IsValueClassification)
 
         Dim evt As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(m_Event.Classification.AsEventAccess.EventInfo)
 
         If IsAddHandler Then
             handler = evt.AddMethod
         Else
             handler = evt.RemoveMethod
         End If
 
         If Helper.IsShared(handler) = False Then
             result = m_Event.Classification.AsEventAccess.GenerateCode(Info) AndAlso result
         End If
         result = m_EventHandler.Classification.GenerateCode(Info.Clone(Me, True, False, m_EventHandler.ExpressionType)) AndAlso result
 
         Helper.Assert(handler IsNot Nothing)
 
         Emitter.EmitCallOrCallVirt(Info, handler)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="124" endline="150"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Event.ResolveExpression(Info) AndAlso result
         result = m_EventHandler.ResolveExpression(info) AndAlso result
 
         If result = False Then Return result
 
         Dim delegatetp As Mono.Cecil.TypeReference = m_Event.Classification.AsEventAccess.Type
 
         If m_EventHandler.Classification.IsMethodPointerClassification Then
             'result = m_EventHandler.Classification.AsMethodPointerClassification.Resolve(delegatetp) AndAlso result
             m_EventHandler = m_EventHandler.ReclassifyMethodPointerToValueExpression(delegatetp)
             result = m_EventHandler.ResolveExpression(Info) AndAlso result
             'result = Helper.VerifyValueClassification(m_EventHandler, Info) AndAlso result
         ElseIf m_EventHandler.Classification.IsValueClassification = False AndAlso m_EventHandler.Classification.CanBeValueClassification Then
             m_EventHandler = m_EventHandler.ReclassifyToValueExpression()
             result = m_EventHandler.ResolveExpression(Info) AndAlso result
         End If
 
         Helper.Assert(m_EventHandler.Classification.IsValueClassification)
 
         Compiler.Helper.AddCheck("The first argument must be an expression that is classified as an event access and the second argument must be an expression that is classified as a value. ")
         Compiler.Helper.AddCheck("The second argument's type must be the delegate type associated with the event access.")
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AddAssignStatement.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AddAssignStatement.vb" startline="26" endline="31"><![CDATA[
 
 #If DEBUG Then
     Public Overrides ReadOnly Property AssignmentType() As KS
         Get
             Return KS.AddAssign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AddAssignStatement.vb" startline="32" endline="37"><![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Return New BinaryAddExpression(Me, lside, RSide)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="32" endline="39"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LSide.ResolveTypeReferences AndAlso result
         result = m_RSide.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="40" endline="43"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="44" endline="50"><![CDATA[
 
     Sub Init(ByVal LSide As Expression, ByVal RSide As Expression)
         m_LSide = LSide
         m_RSide = RSide
         m_LSide.Parent = Me
         m_RSide.Parent = Me
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="51" endline="55"><![CDATA[
 
     ReadOnly Property LSide() As Expression
         Get
             Return m_LSide
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="56" endline="61"><![CDATA[
     End Property
 
     Property RSide() As Expression
         Get
             Return m_RSide
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="62" endline="64"><![CDATA[
         Set(ByVal value As Expression)
             m_RSide = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="65" endline="76"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lInfo As EmitInfo = Info.Clone(Me, RSide)
 
         Helper.Assert(LSide.Classification.IsVariableClassification OrElse LSide.Classification.IsPropertyAccessClassification)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="77" endline="145"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LSide.ResolveExpression(Info) AndAlso result
         result = m_RSide.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If TypeOf m_LSide Is InstanceExpression Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30062, Location) AndAlso result
         End If
 
         If RSide.Classification.IsValueClassification Then
             'do nothing
         ElseIf RSide.Classification.IsMethodPointerClassification Then
             ''result = RSide.ResolveAddressOfExpression(m_LSide.ExpressionType) AndAlso result
             'If result Then
             m_RSide = m_RSide.ReclassifyMethodPointerToValueExpression(m_LSide.ExpressionType)
             result = m_RSide.ResolveExpression(Info) AndAlso result
             'End If
         ElseIf RSide.Classification.CanBeValueClassification Then
             RSide = RSide.ReclassifyToValueExpression()
             result = RSide.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             If result AndAlso RSide.Classification.IsPropertyGroupClassification Then
                 RSide = RSide.ReclassifyToPropertyAccessExpression
                 result = RSide.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             End If
         Else
             Helper.ShowClassificationError(Compiler, RSide.Location, RSide.Classification, "expression")
             result = False
         End If
 
         If result = False Then Return result
 
         If LSide.Classification.IsVariableClassification OrElse LSide.Classification.IsPropertyAccessClassification Then
             'do nothing
         ElseIf LSide.Classification.CanBePropertyAccessClassification Then
             m_LSide = LSide.ReclassifyToPropertyAccessExpression
             result = LSide.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             If result = False Then
                 result = Helper.AddError(Me) AndAlso result
                 Return result
             End If
         Else
             Helper.ShowClassificationError(Compiler, LSide.Location, LSide.Classification, "expression")
             result = False
         End If
 
         If result = False Then Return result
 
         If CecilHelper.IsGenericType(m_LSide.ExpressionType) AndAlso Helper.CompareType(Compiler.TypeCache.System_Nullable1, CecilHelper.GetGenericTypeDefinition(m_LSide.ExpressionType)) Then
             Dim lTypeArg As Mono.Collections.Generic.Collection(Of Mono.Cecil.TypeReference)
             lTypeArg = CecilHelper.GetGenericArguments(m_LSide.ExpressionType)
             If lTypeArg.Count = 1 AndAlso Helper.CompareType(lTypeArg(0), m_RSide.ExpressionType) Then
                 Dim objCreation As DelegateOrObjectCreationExpression
                 objCreation = New DelegateOrObjectCreationExpression(Me)
                 objCreation.Init(m_LSide.ExpressionType, New ArgumentList(objCreation, m_RSide))
                 result = objCreation.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                 m_RSide = objCreation
             End If
         End If
 
         If result = False Then Return result
 
         result = CreateTypeConversion() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="146" endline="153"><![CDATA[
 
     Overridable Function CreateTypeConversion() As Boolean
         Dim result As Boolean = True
 
         m_RSide = Helper.CreateTypeConversion(Me, m_RSide, m_LSide.ExpressionType, result)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="154" endline="159"><![CDATA[
 
 #If DEBUG Then
     Overridable ReadOnly Property AssignmentType() As KS
         Get
             Return KS.Equals
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="27" endline="29"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="30" endline="41"><![CDATA[
 
     Private Function CheckIndexedStatement(ByVal Info As ResolveInfo, ByVal InvocationExpression As InvocationOrIndexExpression) As Boolean
         Dim result As Boolean = True
 
         If InvocationExpression Is Nothing Then Return result
 
         If InvocationExpression.Classification.IsVariableClassification AndAlso CecilHelper.IsArray(InvocationExpression.Expression.ExpressionType) Then
             result = ResolveIndexedStatement(Info, InvocationExpression) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="42" endline="72"><![CDATA[
 
     Private Function ResolveIndexedStatement(ByVal Info As ResolveInfo, ByVal InvocationExpression As InvocationOrIndexExpression) As Boolean
         Dim result As Boolean = True
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
 
         For i As Integer = 0 To InvocationExpression.ArgumentList.Count - 1
             Dim arg As Argument = InvocationExpression.ArgumentList(i)
             Dim exp As Expression = arg.Expression
             Dim newExp As VariableExpression
             Dim varDecl As LocalVariableDeclaration
             Dim stmt As AssignmentStatement
 
             varDecl = New LocalVariableDeclaration(arg)
             varDecl.Init(Nothing, "VB$tmp", exp.ExpressionType)
             block.AddVariable(varDecl)
 
             newExp = New VariableExpression(arg, varDecl)
 
             stmt = New AssignmentStatement(Me.Parent)
             stmt.Init(newExp, exp)
             block.AddStatementBefore(stmt, Me)
 
             arg.Expression = newExp
         Next
 
         If InvocationExpression.Classification.IsVariableClassification Then
             result = CheckIndexedStatement(Info, TryCast(InvocationExpression.Classification.AsVariableClassification.ArrayVariable, InvocationOrIndexExpression)) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="73" endline="90"><![CDATA[
 
     Public NotOverridable Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveStatement(Info) AndAlso result
 
         If result = False Then Return result
 
         result = CheckIndexedStatement(Info, TryCast(LSide, InvocationOrIndexExpression)) AndAlso result
 
         m_CompoundExpression = ResolveStatement(LSide, RSide)
 
         result = m_CompoundExpression.ResolveExpression(Info) AndAlso result
 
         m_CompoundExpression = Helper.CreateTypeConversion(Me, m_CompoundExpression, LSide.ExpressionType, result)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="91" endline="101"><![CDATA[
 
     Friend NotOverridable Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         'result = m_CompoundExpression.GenerateCode(Info.Clone(True, False, LSide.ExpressionType)) AndAlso result
 
         Dim lInfo As EmitInfo = Info.Clone(Me, m_CompoundExpression)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="102" endline="107"><![CDATA[
 
     Public Overrides Function CreateTypeConversion() As Boolean
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\ConcatAssignStatement.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\ConcatAssignStatement.vb" startline="26" endline="31"><![CDATA[
 
 #If DEBUG Then
     Public Overrides ReadOnly Property AssignmentType() As KS
         Get
             Return KS.ConcatAssign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\ConcatAssignStatement.vb" startline="32" endline="37"><![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Return New ConcatExpression(Me, LSide, RSide)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\DivisionAssignStatement.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\DivisionAssignStatement.vb" startline="26" endline="31"><![CDATA[
 
 #If DEBUG Then
     Public Overrides ReadOnly Property AssignmentType() As KS
         Get
             Return KS.RealDivAssign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\DivisionAssignStatement.vb" startline="32" endline="37"><![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Return New RealDivisionExpression(Me, LSide, RSide)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\IntDivisionAssignStatement.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\IntDivisionAssignStatement.vb" startline="26" endline="31"><![CDATA[
 
 #If DEBUG Then
     Public Overrides ReadOnly Property AssignmentType() As KS
         Get
             Return KS.IntDivAssign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\IntDivisionAssignStatement.vb" startline="32" endline="37"><![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Return New IntDivisionExpression(Me, LSide, RSide)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\LShiftAssignStatement.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\LShiftAssignStatement.vb" startline="26" endline="31"><![CDATA[
 
 #If DEBUG Then
     Public Overrides ReadOnly Property AssignmentType() As KS
         Get
             Return KS.ShiftLeftAssign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\LShiftAssignStatement.vb" startline="32" endline="37"><![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Return New LShiftExpression(Me, LSide, RSide)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="34" endline="36"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="37" endline="43"><![CDATA[
 
     Sub Init(ByVal Target As Expression, ByVal Start As Expression, ByVal Length As Expression, ByVal Source As Expression)
         m_Target = Target
         m_Start = Start
         m_Length = Length
         m_Source = Source
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="44" endline="54"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Target IsNot Nothing Then result = m_Target.ResolveTypeReferences AndAlso result
         If m_Start IsNot Nothing Then result = m_Start.ResolveTypeReferences AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveTypeReferences AndAlso result
         If m_Source IsNot Nothing Then result = m_Source.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="55" endline="92"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Target.Classification.IsVariableClassification OrElse m_Target.Classification.IsPropertyAccessClassification)
         Helper.Assert(m_Start.Classification.CanBeValueClassification)
         Helper.Assert(m_Length Is Nothing OrElse m_Length.Classification.CanBeValueClassification)
         Helper.Assert(m_Source.Classification.CanBeValueClassification)
 
         Dim tmpLocal As Mono.Cecil.Cil.VariableDefinition = Nothing
         If m_Target.Classification.IsPropertyAccessClassification Then
             tmpLocal = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_String, "MidTmp" & ObjectID.ToString)
             result = m_Target.GenerateCode(Info.Clone(Me, True, False, tmpLocal.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, tmpLocal)
             Emitter.EmitLoadVariableLocation(Info, tmpLocal)
         Else
             result = m_Target.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_String_ByRef)) AndAlso result
         End If
 
         result = m_Start.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
         Emitter.EmitConversion(m_Start.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         If m_Length IsNot Nothing Then
             result = m_Length.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
             Emitter.EmitConversion(m_Length.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         Else
             Emitter.EmitLoadI4Value(Info, Integer.MaxValue)
         End If
         result = m_Source.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_String)) AndAlso result
         Emitter.EmitConversion(m_Source.ExpressionType, Compiler.TypeCache.System_String, Info)
 
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_StringType__MidStmtStr_String_Int32_Int32_String)
 
         If m_Target.Classification.IsPropertyAccessClassification Then
             result = m_Target.GenerateCode(Info.Clone(Me, New LoadLocalExpression(Me, tmpLocal))) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="93" endline="117"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Target.ResolveExpression(Info) AndAlso result
         result = m_Start.ResolveExpression(info) AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveExpression(Info) AndAlso result
         result = m_Source.ResolveExpression(info) AndAlso result
 
         If Not m_Target.Classification.IsVariableClassification AndAlso Not m_Target.Classification.IsPropertyAccessClassification Then
             If m_Target.Classification.CanBePropertyAccessClassification Then
                 m_Target = m_Target.ReclassifyToPropertyAccessExpression()
                 result = m_Target.ResolveExpression(Info) AndAlso result
             Else
                 result = False
             End If
         End If
 
         Compiler.Helper.AddCheck("The first argument is the target of the assignment and must be classified as a variable or a property access whose type is implicitly convertible to and from String. ")
         Compiler.Helper.AddCheck("The second parameter is the 1-based start position that corresponds to where the assignment should begin in the target string and must be classified as a value whose type must be implicitly convertible to Integer")
         Compiler.Helper.AddCheck("The optional third parameter is the number of characters from the right-side value to assign into the target string and must be classified as a value whose type is implicitly convertible to Integer")
         Compiler.Helper.AddCheck("The right side is the source string and must be classified as a value whose type is implicitly convertible to String.")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="118" endline="121"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals("Mid") AndAlso tm.PeekToken = KS.LParenthesis
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MultiplicationAssignStatement.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MultiplicationAssignStatement.vb" startline="26" endline="31"><![CDATA[
 
 #If DEBUG Then
     Public Overrides ReadOnly Property AssignmentType() As KS
         Get
             Return KS.MultAssign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MultiplicationAssignStatement.vb" startline="32" endline="37"><![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Return New MultExpression(Me, LSide, RSide)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\PowerAssignStatement.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\PowerAssignStatement.vb" startline="26" endline="31"><![CDATA[
 
 #If DEBUG Then
     Public Overrides ReadOnly Property AssignmentType() As KS
         Get
             Return KS.PowerAssign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\PowerAssignStatement.vb" startline="32" endline="39"><![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Dim result As Expression = New ExponentExpression(Me, LSide, RSide)
         result = ConversionExpression.GetTypeConversion(Me, result, LSide.ExpressionType)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\RShiftAssignStatement.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\RShiftAssignStatement.vb" startline="26" endline="31"><![CDATA[
 
 #If DEBUG Then
     Public Overrides ReadOnly Property AssignmentType() As KS
         Get
             Return KS.ShiftRightAssign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\RShiftAssignStatement.vb" startline="32" endline="37"><![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Return New RShiftExpression(Me, LSide, RSide)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\SubtractionAssignStatement.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\SubtractionAssignStatement.vb" startline="26" endline="31"><![CDATA[
 
 #If DEBUG Then
     Public Overrides ReadOnly Property AssignmentType() As KS
         Get
             Return KS.MinusAssign
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\SubtractionAssignStatement.vb" startline="32" endline="37"><![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Return New BinarySubExpression(Me, LSide, RSide)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="27" endline="29"><![CDATA[
         Get
             Return m_EndLabel
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="30" endline="32"><![CDATA[
         Protected Set(ByVal value As Label)
             m_EndLabel = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="33" endline="37"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="38" endline="41"><![CDATA[
 
     Protected Sub Init(ByVal Block As CodeBlock)
         m_Code = Block
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="42" endline="46"><![CDATA[
 
     ReadOnly Property CodeBlock() As CodeBlock
         Get
             Return m_Code
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="47" endline="62"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         '#If DEBUG Then
         '        Dim m1, m2 As MethodInfo
         '        m1 = Me.GetType.GetMethod("ResolveTypeReferences")
         '        m2 = GetType(BlockStatement).GetMethod("ResolveTypeReferences")
         '        Helper.Assert(m1 IsNot m2)
         '#End If
 
         result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="25" endline="27"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="28" endline="32"><![CDATA[
 
     Sub Init(ByVal Target As Expression)
         m_Target = Target
         m_Target.Parent = Me
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="33" endline="37"><![CDATA[
 
     ReadOnly Property Target() As Expression
         Get
             Return m_Target
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="38" endline="60"><![CDATA[
     End Property
 
     Private Function IsExcluded() As Boolean
         Dim exp As InvocationOrIndexExpression
         Dim method As Mono.Cecil.MethodReference
         Dim classification As MethodGroupClassification
    
         If Not m_Target.Classification.IsVoidClassification Then Return False
 
         exp = TryCast(m_Target, InvocationOrIndexExpression)
 
         If exp Is Nothing Then Return False
         If exp.Expression Is Nothing Then Return False
 
         classification = TryCast(exp.Expression.Classification, MethodGroupClassification)
         If classification Is Nothing Then Return False
 
         method = classification.ResolvedMethodInfo
 
         If method Is Nothing Then Return False
 
         Return Compiler.Scanner.IsConditionallyExcluded(method, Me.Location)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="61" endline="83"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Target.Classification.IsLateBoundClassification Then
             result = m_Target.GenerateCode(Info) AndAlso result
 
             Return result
         End If
 
         Helper.Assert(m_Target.Classification.IsValueClassification OrElse m_Target.Classification.IsVoidClassification)
 
         If IsExcluded() Then Return result
 
         result = m_Target.GenerateCode(Info.Clone(Me, True)) AndAlso result
         If m_Target.Classification.IsValueClassification Then
             If Helper.CompareType(m_Target.Classification.AsValueClassification.Type, Compiler.TypeCache.System_Void) = False Then
                 Emitter.EmitPop(Info, m_Target.ExpressionType)
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="84" endline="100"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Target.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Target.Classification.IsMethodGroupClassification Then
             Dim tmp As New InvocationOrIndexExpression(Me)
             tmp.Init(m_Target, New ArgumentList(tmp))
             result = tmp.ResolveExpression(Info) AndAlso result
             m_Target = tmp
         End If
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="101" endline="104"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Target.ResolveTypeReferences()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="30" endline="30"><![CDATA[
     Public Shared ReadOnly RelationalOperators As KS() = New KS() {KS.Equals, KS.NotEqual, KS.GT, KS.GE, KS.LT, KS.LE}
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="31" endline="41"><![CDATA[
 
     Private m_Expression1 As Expression
     Private m_Expression2 As Expression
     Private m_Comparison As KS = KS.Equals
 
     Private m_ComparisonExpression As Expression
 
     ReadOnly Property Expression1() As Expression
         Get
             Return m_Expression1
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="42" endline="47"><![CDATA[
     End Property
 
     ReadOnly Property Expression2() As Expression
         Get
             Return m_Expression2
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="48" endline="53"><![CDATA[
     End Property
 
     ReadOnly Property Comparison() As KS
         Get
             Return m_Comparison
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="54" endline="63"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression1 IsNot Nothing Then result = m_Expression1.ResolveTypeReferences AndAlso result
         If m_Expression2 IsNot Nothing Then result = m_Expression2.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="64" endline="67"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     Private m_Comparison As KS = KS.Equals
 
     Private m_ComparisonExpression As Expression
 
     ReadOnly Property Expression1() As Expression
         Get
             Return m_Expression1
         End Get
     End Property
 
     ReadOnly Property Expression2() As Expression
         Get
             Return m_Expression2
         End Get
     End Property
 
     ReadOnly Property Comparison() As KS
         Get
             Return m_Comparison
         End Get
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression1 IsNot Nothing Then result = m_Expression1.ResolveTypeReferences AndAlso result
         If m_Expression2 IsNot Nothing Then result = m_Expression2.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="68" endline="73"><![CDATA[
 
     Sub Init(ByVal Expression1 As Expression, ByVal Expression2 As Expression, ByVal Comparison As KS)
         m_Expression1 = Expression1
         m_Expression2 = Expression2
         m_Comparison = Comparison
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="74" endline="86"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim casestmt As CaseStatement = Me.FindFirstParent(Of CaseStatement)()
         Dim selectstmt As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         result = m_ComparisonExpression.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
 
         Emitter.EmitBranchIfTrue(Info, casestmt.StartCode)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="87" endline="128"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression1.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_Expression1, Info) AndAlso result
 
         Dim selectstmt As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         m_Expression1 = Helper.CreateTypeConversion(Me, m_Expression1, selectstmt.Test.ExpressionType, result)
 
         If m_Expression2 IsNot Nothing Then
             result = m_Expression2.ResolveExpression(Info) AndAlso result
             result = Helper.VerifyValueClassification(m_Expression2, Info) AndAlso result
             m_Expression2 = Helper.CreateTypeConversion(Me, m_Expression2, selectstmt.Test.ExpressionType, result)
 
             Dim lside, rside As Expression
             lside = New GEExpression(Me, selectstmt.CachedTest, m_Expression1)
             rside = New LEExpression(Me, selectstmt.CachedTest, m_Expression2)
             m_ComparisonExpression = New AndExpression(Me, lside, rside)
         Else
             Select Case m_Comparison
                 Case KS.GT
                     m_ComparisonExpression = New GTExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.LT
                     m_ComparisonExpression = New LTExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.GE
                     m_ComparisonExpression = New GEExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.LE
                     m_ComparisonExpression = New LEExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.Equals, KS.None
                     m_ComparisonExpression = New EqualsExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.NotEqual
                     m_ComparisonExpression = New NotEqualsExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
         result = m_ComparisonExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="30" endline="32"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="33" endline="36"><![CDATA[
 
     Function ResolveStatements(ByVal Info As ResolveInfo) As Boolean
         Return ResolveCode(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="37" endline="39"><![CDATA[
         Get
             Return m_StartCode
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="40" endline="45"><![CDATA[
     End Property
 
     ReadOnly Property IsElse() As Boolean
         Get
             Return m_iselse
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="46" endline="51"><![CDATA[
     End Property
 
     ReadOnly Property Clauses() As CaseClauses
         Get
             Return m_Clauses
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="52" endline="62"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then result = m_Clauses.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="63" endline="66"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="67" endline="72"><![CDATA[
 
     Shadows Sub Init(ByVal IsElse As Boolean, ByVal Clauses As CaseClauses, ByVal Block As CodeBlock)
         MyBase.Init(Block)
         m_IsElse = IsElse
         m_Clauses = Clauses
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="73" endline="95"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim selectparent As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         EndLabel = Emitter.DefineLabel(Info)
         m_StartCode = Emitter.DefineLabel(Info)
 
         If m_IsElse = False Then
             For i As Integer = 0 To m_Clauses.Count - 1
                 Dim clause As CaseClause = m_Clauses.Item(i)
                 result = clause.GenerateCode(Info) AndAlso result
             Next
             Emitter.EmitBranch(Info, EndLabel)
         End If
         Emitter.MarkLabel(Info, m_StartCode)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, selectparent.EndLabel)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="96" endline="106"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then
             result = m_Clauses.ResolveStatements(Info) AndAlso result
         End If
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="107" endline="111"><![CDATA[
 
     Function ParentAsSelectStatement() As SelectStatement
         Helper.Assert(TypeOf Me.Parent Is SelectStatement)
         Return DirectCast(Me.Parent, SelectStatement)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="38" endline="40"><![CDATA[
         Get
             Return m_Variable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As NonArrayTypeName
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="47" endline="52"><![CDATA[
     End Property
 
     ReadOnly Property [When]() As Expression
         Get
             Return m_When
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="53" endline="57"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="58" endline="65"><![CDATA[
 
     Shadows Sub Init(ByVal Variable As Identifier, ByVal TypeName As NonArrayTypeName, ByVal [When] As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_Variable = Variable
         m_TypeName = TypeName
         m_When = [When]
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="66" endline="112"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_When IsNot Nothing Then
             Dim EndWhen, DoWhenComparison As Label
             EndWhen = Emitter.DefineLabel(Info)
             DoWhenComparison = Emitter.DefineLabel(Info)
 
             Emitter.EmitBeginExceptionFilter(Info)
             'Check if the exception object is of type System.Exception.
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
             Emitter.EmitDup(Info)
             'If True, do the comparison
             Emitter.EmitBranchIfTrue(Info, DoWhenComparison, Compiler.TypeCache.System_Exception)
             'Otherwise load a false value and go to the end of the filter.
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             Emitter.EmitLoadValue(Info, False)
             Emitter.EmitBranch(Info, EndWhen)
 
             'Do the when clause.
             Emitter.MarkLabel(Info, DoWhenComparison)
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             result = m_When.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.MarkLabel(Info, EndWhen)
             Emitter.EmitBeginCatch(Info, Nothing)
         Else
             Helper.Assert(m_ExceptionType IsNot Nothing)
             Emitter.EmitBeginCatch(Info, m_ExceptionType)
         End If
 
         If m_VariableDeclaration Is Nothing Then
             If m_ExceptionType Is Nothing Then
                 Emitter.EmitPop(Info, Compiler.TypeCache.System_Object)
             Else
                 Emitter.EmitPop(Info, m_ExceptionType)
             End If
         Else
             result = m_VariableDeclaration.GenerateCode(Info) AndAlso result
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, m_ExceptionType)
             Emitter.EmitStoreVariable(Info, m_VariableDeclaration.LocalBuilder)
         End If
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="113" endline="128"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             result = m_TypeName.ResolveTypeReferences AndAlso result
         End If
 
         If m_When IsNot Nothing Then
             result = m_When.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="129" endline="160"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             m_ExceptionType = m_TypeName.ResolvedType
             Helper.Assert(m_ExceptionType IsNot Nothing)
             If Helper.CompareType(Compiler.TypeCache.System_Exception, m_ExceptionType) = False AndAlso Helper.IsSubclassOf(Compiler.TypeCache.System_Exception, m_ExceptionType) = False Then
                 Helper.AddError(Me, "Exception type does not inherit from System.Exception")
                 result = True
             End If
         ElseIf m_When Is Nothing Then
             m_ExceptionType = Compiler.TypeCache.System_Exception
         End If
         If m_Variable IsNot Nothing Then 'Token.IsSomething(m_Variable) Then
             m_VariableDeclaration = New LocalVariableDeclaration(Me, m_Variable, False, m_TypeName, Nothing, Nothing)
             result = m_VariableDeclaration.ResolveTypeReferences AndAlso result
             CodeBlock.Variables.Add(m_VariableDeclaration)
         End If
         If m_When IsNot Nothing Then result = m_When.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_When IsNot Nothing Then
             m_When = Helper.CreateTypeConversion(Me, m_When, Compiler.TypeCache.System_Boolean, result)
             If result = False Then
                 Helper.AddError(Me)
                 Return result
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="161" endline="165"><![CDATA[
 
     Function ParentAsTryStatement() As TryStatement
         Helper.Assert(TypeOf Me.Parent Is TryStatement)
         Return DirectCast(Me.Parent, TryStatement)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ContinueStatement.vb" startline="32" endline="34"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ContinueStatement.vb" startline="35" endline="38"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ContinueStatement.vb" startline="39" endline="42"><![CDATA[
 
     Sub Init(ByVal ContinueWhat As KS)
         m_ContinueWhat = ContinueWhat
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ContinueStatement.vb" startline="43" endline="80"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim nextIteration As Nullable(Of Label)
         Select Case m_ContinueWhat
             Case KS.While
                 Dim whilestmt As WhileStatement = TryCast(m_ContainingStatement, WhileStatement)
                 If whilestmt IsNot Nothing Then
                     nextIteration = whilestmt.nextiteration
                 Else
                     Throw New InternalException(Me)
                 End If
             Case KS.Do
                 Dim dostmt As DoStatement = TryCast(m_ContainingStatement, DoStatement)
                 If dostmt IsNot Nothing Then
                     nextIteration = dostmt.nextiteration
                 Else
                     Throw New InternalException(Me)
                 End If
             Case KS.For
                 Dim forstmt As ForStatement = TryCast(m_ContainingStatement, ForStatement)
                 Dim foreachstmt As ForEachStatement = TryCast(m_ContainingStatement, ForEachStatement)
                 If forstmt IsNot Nothing Then
                     nextIteration = forstmt.NextIteration
                 ElseIf foreachstmt IsNot Nothing Then
                     nextIteration = foreachstmt.nextiteration
                 Else
                     Throw New InternalException(Me)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Helper.Assert(nextIteration.HasValue)
         Emitter.EmitBranchOrLeave(Info, nextIteration.Value, Me, m_ContainingStatement)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ContinueStatement.vb" startline="81" endline="112"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         'If the Continue statement is not contained within the kind of block specified in the statement, a compile-time error occurs.
         Select Case m_ContinueWhat
             Case KS.While
                 m_ContainingStatement = Me.FindFirstParent(Of WhileStatement)()
                 If m_ContainingStatement Is Nothing Then
                     'Helper.AddCheck("error BC30784
                     Compiler.Report.ShowMessage(Messages.VBNC30784, Location)
                 End If
             Case KS.For
                 m_ContainingStatement = CType(Me.FindFirstParent(Of ForEachStatement, ForStatement)(), Statement)
                 If m_ContainingStatement Is Nothing Then
                     'Helper.AddError("error BC30783
                     Compiler.Report.ShowMessage(Messages.VBNC30783, Location)
                 End If
             Case KS.Do
                 m_ContainingStatement = Me.FindFirstParent(Of DoStatement)()
                 If m_ContainingStatement Is Nothing Then
                     'Helper.AddCheck("error BC30782
                     Compiler.Report.ShowMessage(Messages.VBNC30782, Location)
                 End If
             Case KS.Else
                 Throw New InternalException(Me)
         End Select
         result = m_ContainingStatement IsNot Nothing
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ContinueStatement.vb" startline="113" endline="117"><![CDATA[
 
     ReadOnly Property ContinueWhat() As KS
         Get
             Return m_ContinueWhat
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="43" endline="45"><![CDATA[
         Get
             Return m_precondition
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="46" endline="51"><![CDATA[
     End Property
 
     ReadOnly Property PostCondition() As Expression
         Get
             Return m_postcondition
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="52" endline="61"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_PreCondition, m_PostCondition) AndAlso result
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="62" endline="65"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="66" endline="73"><![CDATA[
 
     Shadows Sub Init(ByVal PreCondition As Expression, ByVal PostCondition As Expression, ByVal IsWhile As Boolean, ByVal Code As CodeBlock)
         MyBase.Init(Code)
 
         m_PreCondition = PreCondition
         m_PostCondition = PostCondition
         m_IsWhile = IsWhile
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="74" endline="78"><![CDATA[
 
     ReadOnly Property NextIteration() As Label
         Get
             Return m_NextIteration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="79" endline="117"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim startLabel As Label = Emitter.DefineLabel(Info)
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         Emitter.MarkLabel(Info, startLabel)
         If m_PreCondition IsNot Nothing Then
             Emitter.MarkLabel(Info, m_NextIteration)
             result = m_PreCondition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.EmitConversion(m_PreCondition.ExpressionType, Compiler.TypeCache.System_Boolean, Info)
             If m_IsWhile Then
                 Emitter.EmitBranchIfFalse(Info, EndLabel)
             Else
                 Emitter.EmitBranchIfTrue(Info, EndLabel)
             End If
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         If m_PostCondition IsNot Nothing Then
             Emitter.MarkLabel(Info, m_NextIteration)
             result = m_PostCondition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.EmitConversion(m_PostCondition.ExpressionType, Compiler.TypeCache.System_Boolean, Info)
             If m_IsWhile Then
                 Emitter.EmitBranchIfFalse(Info, EndLabel)
             Else
                 Emitter.EmitBranchIfTrue(Info, EndLabel)
             End If
         End If
         Emitter.EmitBranch(Info, startLabel)
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="118" endline="142"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_PreCondition IsNot Nothing Then
             result = m_PreCondition.ResolveExpression(Info) AndAlso result
             result = Helper.VerifyValueClassification(m_PreCondition, Info) AndAlso result
 
             If Me.Location.File(Compiler).IsOptionStrictOn AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Me, m_PreCondition.ExpressionType, Compiler.TypeCache.System_Boolean) = False Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30512, m_PreCondition.Location, m_PreCondition.ExpressionType.FullName, "Boolean")
             End If
         End If
 
         If m_PostCondition IsNot Nothing Then
             result = m_PostCondition.ResolveExpression(info) AndAlso result
             result = Helper.VerifyValueClassification(m_PostCondition, Info) AndAlso result
 
             If Me.Location.File(Compiler).IsOptionStrictOn AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Me, m_PostCondition.ExpressionType, Compiler.TypeCache.System_Boolean) = False Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30512, m_PostCondition.Location, m_PostCondition.ExpressionType.FullName, "Boolean")
             End If
         End If
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="143" endline="147"><![CDATA[
 
     ReadOnly Property IsUntil() As Boolean
         Get
             Return Not m_IsWhile
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="148" endline="153"><![CDATA[
     End Property
 
     ReadOnly Property IsWhile() As Boolean
         Get
             Return m_IsWhile
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="32" endline="34"><![CDATA[
         Get
             Return m_condition
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="35" endline="39"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="40" endline="44"><![CDATA[
 
     Shadows Sub Init(ByVal Code As CodeBlock, ByVal Condition As Expression)
         MyBase.Init(Code)
         m_Condition = Condition
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="45" endline="60"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim falseLabel As Label = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, falseLabel)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, ParentAsIfStatement.EndLabel)
 
         Emitter.MarkLabel(Info, falseLabel)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="61" endline="70"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="71" endline="99"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_Condition.Classification.IsValueClassification Then
             'nothing to do
         ElseIf m_Condition.Classification.CanBeValueClassification Then
             m_Condition = m_Condition.ReclassifyToValueExpression
             result = m_Condition.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
 
             If result = False Then
                 result = Helper.AddError(Me) AndAlso result
                 Return result
             End If
             m_Condition = Helper.CreateTypeConversion(Me, m_Condition, Compiler.TypeCache.System_Boolean, result)
 
             If result = False Then
                 result = Helper.AddError(Me) AndAlso result
                 Return result
             End If
         Else
             result = Helper.AddError(Me, "Each expression in an If...Then...Else statement must be classified as a value and be implicitly convertible to Boolean") AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="100" endline="104"><![CDATA[
 
     Shadows ReadOnly Property Parent() As IfStatement
         Get
             Return DirectCast(MyBase.Parent, IfStatement)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="105" endline="110"><![CDATA[
     End Property
 
     Function ParentAsIfStatement() As IfStatement
         Helper.Assert(TypeOf Me.Parent Is IfStatement)
         Return DirectCast(Me.Parent, IfStatement)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" startline="27" endline="29"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" startline="30" endline="33"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" startline="34" endline="41"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__EndApp)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" startline="42" endline="56"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim m As Object
         Dim method As IMethod
 
         Compiler.Helper.AddCheck("End statements may not be used in programs that are not executable (for example, DLLs). ")
 
         m = FindMethod()
         method = TryCast(m, IMethod)
         If method IsNot Nothing Then
             method.CecilBuilder.ImplAttributes = Mono.Cecil.MethodImplAttributes.NoInlining Or Mono.Cecil.MethodImplAttributes.NoOptimization
         End If
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="33" endline="35"><![CDATA[
         Get
             Return m_targets
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="36" endline="40"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="41" endline="44"><![CDATA[
 
     Sub Init(ByVal Targets As ExpressionList)
         m_Targets = Targets
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="45" endline="57"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim nullExp As New NothingConstantExpression(Me)
         result = nullExp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
         For i As Integer = 0 To m_Targets.Count - 1
             Dim exp As Expression = DirectCast(m_Targets.Item(i), Expression)
             result = exp.GenerateCode(Info.Clone(Me, nullExp)) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="58" endline="63"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         result = m_Targets.ResolveCode(info) AndAlso result
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="64" endline="71"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Targets.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="32" endline="35"><![CDATA[
 
     Sub Init(ByVal ErrNumber As Expression)
         m_ErrNumber = ErrNumber
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="36" endline="46"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
         Emitter.EmitConversion(m_ErrNumber.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="47" endline="56"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.ResolveExpression(info) AndAlso result
 
         Compiler.Helper.AddCheck("The expression must be classified as a value and its type must be implicitly convertible to Integer.")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ExitStatement.vb" startline="32" endline="34"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ExitStatement.vb" startline="35" endline="39"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ExitWhat As KS)
         MyBase.New(Parent)
         m_ExitWhat = ExitWhat
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ExitStatement.vb" startline="40" endline="85"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Select Case m_ExitWhat
             Case KS.Sub
                 Emitter.EmitRetOrLeave(Info, Me, False)
             Case KS.Function
                 Dim func As FunctionDeclaration = TryCast(m_Container, FunctionDeclaration)
                 If func IsNot Nothing Then
                     Emitter.EmitLoadVariable(Info, func.DefaultReturnVariable)
                     Emitter.EmitRetOrLeave(Info, Me, False)
                 Else
                     Throw New InternalException(Me)
                 End If
             Case KS.Property
                 Dim propGet As PropertyGetDeclaration = TryCast(m_Container, PropertyGetDeclaration)
                 Dim propSet As PropertySetDeclaration = TryCast(m_Container, PropertySetDeclaration)
                 If propget IsNot Nothing Then
                     Emitter.EmitLoadVariable(Info, propGet.DefaultReturnVariable)
                     Emitter.EmitRetOrLeave(Info, Me, False)
                 ElseIf propSet IsNot Nothing Then
                     Emitter.EmitRetOrLeave(Info, Me, False)
                 Else
                     Throw New InternalException(Me)
                 End If
             Case KS.Select
                 Dim destinationStmt As SelectStatement
                 destinationStmt = DirectCast(m_Container, SelectStatement)
                 Emitter.EmitBranchOrLeave(Info, destinationStmt.EndLabel, Me, destinationStmt)
             Case KS.While, KS.Do, KS.For, KS.Try
                 Dim destinationStmt As BlockStatement
                 destinationStmt = TryCast(m_Container, BlockStatement)
                 If destinationStmt IsNot Nothing Then
                     Dim lblStatement As Statement
                     lblStatement = destinationStmt.FindFirstParent(Of Statement)()
                     Emitter.EmitBranchOrLeave(Info, destinationStmt.EndLabel, Me, lblStatement)
                 Else
                     Throw New InternalException(Me)
                 End If
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ExitStatement.vb" startline="86" endline="134"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Select Case m_ExitWhat
             Case KS.Sub
                 m_Container = Me.FindFirstParent(Of IMethod)()
                 If m_Container Is Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30065, Location) AndAlso result
                 ElseIf (TypeOf m_Container Is SubDeclaration = False AndAlso TypeOf m_Container Is ConstructorDeclaration = False) OrElse TypeOf m_Container Is FunctionDeclaration = True Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30065, Location) AndAlso result
                 End If
             Case KS.Property
                 m_Container = Me.FindFirstParent(Of IMethod)()
                 If m_Container Is Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30066, Location) AndAlso result
                 ElseIf TypeOf m_Container Is PropertyDeclaration = False AndAlso TypeOf m_Container Is PropertyHandlerDeclaration = False Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30066, Location) AndAlso result
                 End If
             Case KS.Function
                 m_Container = Me.FindFirstParent(Of IMethod)()
                 If m_Container Is Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30067, Location) AndAlso result
                 ElseIf TypeOf m_Container Is FunctionDeclaration = False Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30067, Location) AndAlso result
                 End If
             Case KS.Do
                 m_Container = Me.FindFirstParent(Of DoStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30089, Location)
             Case KS.Try
                 m_Container = Me.FindFirstParent(Of TryStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30393, Location)
             Case KS.For
                 m_Container = Me.FindFirstParent(Of ForStatement, ForEachStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30096, Location)
             Case KS.While
                 m_Container = Me.FindFirstParent(Of WhileStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30097, Location)
             Case KS.Select
                 m_Container = Me.FindFirstParent(Of SelectStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30099, Location)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         result = m_Container IsNot Nothing AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ExitStatement.vb" startline="135" endline="139"><![CDATA[
 
     ReadOnly Property ExitWhat() As KS
         Get
             Return m_ExitWhat
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="40" endline="42"><![CDATA[
         Get
             Return m_NextExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="43" endline="48"><![CDATA[
     End Property
 
     ReadOnly Property InExpression() As Expression
         Get
             Return m_InExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="49" endline="54"><![CDATA[
     End Property
 
     ReadOnly Property LoopControlVariable() As LoopControlVariable
         Get
             Return m_loopcontrolvariable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="55" endline="59"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="60" endline="67"><![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal InExpression As Expression, ByVal NextExpression As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_InExpression = InExpression
         m_NextExpression = NextExpression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="68" endline="72"><![CDATA[
 
     ReadOnly Property Enumerator() As Mono.Cecil.Cil.VariableDefinition
         Get
             Return m_Enumerator
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="73" endline="78"><![CDATA[
     End Property
 
     ReadOnly Property NextIteration() As Label
         Get
             Return m_NextIteration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="79" endline="122"><![CDATA[
     End Property
 
     Function GenerateCode_LoadCurrentLoopVariable(ByVal Info As EmitInfo) As Boolean
         Dim varType As Mono.Cecil.TypeReference = m_LoopControlVariable.VariableType
         Dim isGenericParameter As Boolean = CecilHelper.IsGenericParameter(varType)
         Dim isValueType As Boolean = isGenericParameter = False AndAlso CecilHelper.IsValueType(varType)
         Dim isClass As Boolean = isGenericParameter = False AndAlso CecilHelper.IsClass(varType)
 
         Emitter.EmitLoadVariable(Info, m_Enumerator)
         Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_Collections_IEnumerator__get_Current)
 
         Dim valueTPLoad As Label = Nothing
         Dim valueTPLoaded As Label = Nothing
 
         If isValueType Then
             Dim tmpStructureVariable As Mono.Cecil.Cil.VariableDefinition
 
             valueTPLoad = Emitter.DefineLabel(Info)
             valueTPLoaded = Emitter.DefineLabel(Info)
             tmpStructureVariable = Emitter.DeclareLocal(Info, varType)
             Emitter.EmitDup(Info)
             Emitter.EmitBranchIfTrue(Info, valueTPLoad)
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Object)
             Emitter.EmitLoadVariable(Info, tmpStructureVariable)
             Emitter.EmitBranch(Info, valueTPLoaded)
             Emitter.FreeLocal(tmpStructureVariable)
         Else
             Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
         End If
 
         If isGenericParameter Then
             Emitter.EmitUnbox_Any(Info, varType)
         ElseIf isClass Then
             Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Object, varType)
         ElseIf isValueType Then
             Emitter.MarkLabel(Info, valueTPLoad)
             Emitter.EmitUnbox(Info, varType)
             Emitter.EmitLoadObject(Info, varType)
             Emitter.MarkLabel(Info, valueTPLoaded)
         Else
             Emitter.EmitConversion(Compiler.TypeCache.System_Object, varType, Info.Clone(Me, True, True, varType))
         End If
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="123" endline="185"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim beginEx As Label
 
         Dim startIteration As Label
 
         result = m_LoopControlVariable.GenerateCode(Info) AndAlso result 'Creates the localbuilder if necessary
 
         m_Enumerator = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerator))
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
         startIteration = Emitter.DefineLabel(Info)
 
         beginEx = Emitter.EmitBeginExceptionBlock(Info)
 
         Compiler.Helper.AddCheck("Check correct type of foreach loop container.")
         Helper.Assert(Helper.CompareType(Compiler.TypeCache.System_Object, m_InExpression.ExpressionType) OrElse Helper.IsAssignable(Me, m_InExpression.ExpressionType, Compiler.TypeCache.System_Collections_IEnumerable))
 
         'Load the container variable and get the enumerator
         result = m_InExpression.GenerateCode(Info.Clone(Me, True, False, m_InExpression.ExpressionType)) AndAlso result
         Emitter.EmitCastClass(Info, m_InExpression.ExpressionType, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerable))
         Emitter.EmitCallVirt(Info, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerable__GetEnumerator))
         Emitter.EmitStoreVariable(Info, m_Enumerator)
 
         'Jump to the next iteration
         Emitter.EmitBranch(Info, m_NextIteration)
 
         'Mark the beginning of the code
         Emitter.MarkLabel(Info, startIteration)
 
         Emitter.EmitNop(Info)
         Dim cge As New CompilerGeneratedExpression(Me, New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCode_LoadCurrentLoopVariable), m_LoopControlVariable.VariableType)
         result = m_LoopControlVariable.EmitStoreVariable(Info.Clone(Me, cge)) AndAlso result
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         'Move to the next element
         Emitter.MarkLabel(Info, m_NextIteration)
         Emitter.EmitNop(Info)
         Emitter.EmitLoadVariable(Info, m_Enumerator)
         Emitter.EmitCallVirt(Info, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerator__MoveNext))
         'Jump to the code for the next element
         Emitter.EmitBranchIfTrue(Info, startIteration)
         'End of try code.
         'Emitter.EmitLeave(Info, beginEx)
 
         'Dispose of the enumerator if it is disposable.
         Emitter.EmitBeginFinallyBlock(Info)
         Dim EndFinally As Label = Emitter.DefineLabel(info)
         Emitter.EmitLoadVariable(Info, m_Enumerator)
         Emitter.EmitIsInst(Info, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerator), Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_IDisposable))
         Emitter.EmitBranchIfFalse(Info, EndFinally)
         Emitter.EmitLoadVariable(Info, m_Enumerator)
         Emitter.EmitIsInst(Info, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerator), Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_IDisposable))
         Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_IDisposable__Dispose)
         Emitter.MarkLabel(info, EndFinally)
         Emitter.EmitEndExceptionBlock(Info)
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="186" endline="197"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_InExpression IsNot Nothing Then result = m_InExpression.ResolveTypeReferences AndAlso result
         If m_NextExpression IsNot Nothing Then result = m_NextExpression.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="198" endline="229"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LoopControlVariable.ResolveCode(Info) AndAlso result
         If m_LoopControlVariable.GetVariableDeclaration IsNot Nothing Then
             MyBase.CodeBlock.AddVariable(m_LoopControlVariable.GetVariableDeclaration)
         End If
 
         result = m_InExpression.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_InExpression, Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_NextExpression IsNot Nothing Then
             'TODO
             Dim sneNext As SimpleNameExpression = TryCast(m_NextExpression, SimpleNameExpression)
             If sneNext IsNot Nothing Then
                 If Helper.CompareName(sneNext.Identifier.Identifier, m_LoopControlVariable.Identifier.Identifier) = False Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30070, sneNext.Location, m_LoopControlVariable.Identifier.Identifier) AndAlso result
                 End If
             End If
         End If
 
         Compiler.Helper.AddCheck("It is not valid to branch into a For Each statement block from outside the block.")
         Compiler.Helper.AddCheck("The loop control variable is specified either through an identifier followed by an As clause or an expression. (...) In the case of an expression, the expression must be classified as a variable. ")
         Compiler.Helper.AddCheck("The enumerator expression must be classified as a value and its type must be a collection type or Object. ")
         Compiler.Helper.AddCheck("If the type of the enumerator expression is Object, then all processing is deferred until run-time. Otherwise, a conversion must exist from the element type of the collection to the type of the loop control variable")
         Compiler.Helper.AddCheck("The loop control variable cannot be used by another enclosing For Each statement. ")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="75" endline="86"><![CDATA[
     End Class
 
     Private Enum LoopCounterTypes
         Local
         Field
         Array
     End Enum
 
     ReadOnly Property LoopStepExpression() As Expression
         Get
             Return m_LoopStepExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="87" endline="92"><![CDATA[
     End Property
 
     ReadOnly Property NextExpressionList() As ExpressionList
         Get
             Return m_NextExpressionList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="93" endline="98"><![CDATA[
     End Property
 
     ReadOnly Property LoopEndExpression() As Expression
         Get
             Return m_LoopEndExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="99" endline="104"><![CDATA[
     End Property
 
     ReadOnly Property LoopStartExpression() As Expression
         Get
             Return m_LoopStartExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="105" endline="110"><![CDATA[
     End Property
 
     ReadOnly Property LoopControlVariable() As LoopControlVariable
         Get
             Return m_LoopControlVariable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="111" endline="125"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_LoopStartExpression IsNot Nothing Then result = m_LoopStartExpression.ResolveTypeReferences AndAlso result
         If m_LoopEndExpression IsNot Nothing Then result = m_LoopEndExpression.ResolveTypeReferences AndAlso result
         If m_LoopStepExpression IsNot Nothing Then result = m_LoopStepExpression.ResolveTypeReferences AndAlso result
         If m_NextExpressionList IsNot Nothing Then result = m_NextExpressionList.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="126" endline="129"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="130" endline="139"><![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal LoopStartExpression As Expression, ByVal LoopEndExpression As Expression, ByVal LoopStepExpression As Expression, ByVal NextExpressionList As ExpressionList, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_LoopStartExpression = LoopStartExpression
         m_LoopEndExpression = LoopEndExpression
         m_LoopStepExpression = LoopStepExpression
         m_NextExpressionList = NextExpressionList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="140" endline="144"><![CDATA[
 
     ReadOnly Property NextIteration() As Label
         Get
             Return m_NextIteration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="145" endline="157"><![CDATA[
     End Property
 
     Private Function IsNegativeStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) < 0
         Else
             Return CDbl(constant) < 0
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="158" endline="169"><![CDATA[
 
     Private Function IsPositiveStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) > 0
         Else
             Return CDbl(constant) > 0
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="170" endline="173"><![CDATA[
 
     Private Function IsKnownStep() As Boolean
         Return m_LoopStepExpression.IsConstant
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="174" endline="191"><![CDATA[
 
     Private Function EmitLoadAddressCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariableLocation(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariableLocation(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="192" endline="209"><![CDATA[
 
     Private Function EmitLoadCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariable(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="210" endline="219"><![CDATA[
 
     Private Function EmitStoreCounterInstanceExpression(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
 
         If Data.InstanceExpression IsNot Nothing Then
             result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="220" endline="234"><![CDATA[
 
     Private Function EmitStoreCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 Emitter.EmitStoreField(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitStoreVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="235" endline="411"><![CDATA[
 
     ''' <summary>
     ''' Emit code for
     ''' For i As Integer = 0 ...
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim conditionLabel As Label
         Dim startlabel As Label
         Dim loopCounter As LoopCounterData
         Dim loopMax As Mono.Cecil.Cil.VariableDefinition
         Dim loopStart As Mono.Cecil.Cil.VariableDefinition
         Dim loopStep As Mono.Cecil.Cil.VariableDefinition
         Dim loopLateBoundObject As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim loadInfo As EmitInfo
 
         conditionLabel = Emitter.DefineLabel(Info)
         startlabel = Emitter.DefineLabel(Info)
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         loadInfo = Info.Clone(Me, True, False, m_LoopType)
 
         'Create the localbuilder
         If m_LoopControlVariable.IsVariableDeclaration Then
             result = m_LoopControlVariable.GenerateCode(Info) AndAlso result
             loopCounter = New LoopCounterData(m_LoopControlVariable.GetVariableDeclaration.LocalBuilder, LoopCounterTypes.Local)
         Else
             Dim varClass As VariableClassification
             varClass = m_LoopControlVariable.Expression.Classification.AsVariableClassification
             If varClass.LocalBuilder IsNot Nothing Then
                 loopCounter = New LoopCounterData(varClass.LocalBuilder, LoopCounterTypes.Local)
             ElseIf varClass.FieldInfo IsNot Nothing Then
                 loopCounter = New LoopCounterData(varClass.FieldInfo, LoopCounterTypes.Field, varClass.InstanceExpression)
             Else
                 Throw New InternalException()
             End If
         End If
 
         loopMax = Emitter.DeclareLocal(Info, m_LoopType, "maxvar$" & Me.ObjectID.ToString)
         loopStep = Emitter.DeclareLocal(Info, m_LoopType, "stepvar$" & Me.ObjectID.ToString)
         loopStart = Emitter.DeclareLocal(Info, m_LoopType, "startvar$" & Me.ObjectID.ToString)
         If m_IsLateBound Then
             loopLateBoundObject = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Object, "loopobj$" & Me.ObjectID.ToString)
         End If
 
         'Load the initial expression
         result = m_LoopStartExpression.GenerateCode(loadInfo) AndAlso result
         Emitter.EmitStoreVariable(Info, loopStart)
 
         'Store the initial expression in the counter
         EmitStoreCounterInstanceExpression(Info, loopCounter)
         Emitter.EmitLoadVariable(Info, loopStart)
         EmitStoreCounter(Info, loopCounter)
 
         'Load the max expression
         result = m_LoopEndExpression.GenerateCode(loadInfo) AndAlso result
         Emitter.EmitStoreVariable(Info, loopMax)
 
         'Load the step expression
         result = m_LoopStepExpression.GenerateCode(loadInfo) AndAlso result
         Emitter.EmitStoreVariable(Info, loopStep)
 
         'Jump to the comparison
         If m_IsLateBound Then
             EmitLoadCounter(Info, loopCounter)
             'Emitter.EmitLoadVariable(Info, loopCounter)
             Emitter.EmitLoadVariable(Info, loopStart)
             Emitter.EmitLoadVariable(Info, loopMax)
             Emitter.EmitLoadVariable(Info, loopStep)
             Emitter.EmitLoadVariableLocation(Info, loopLateBoundObject)
             EmitLoadAddressCounter(Info, loopCounter)
             'Emitter.EmitLoadVariableLocation(Info, loopCounter)
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ObjectFlowControl_ForLoopControl__ForLoopInitObj_Object_Object_Object_Object_Object_Object)
             Emitter.EmitBranchIfFalse(Info, EndLabel)
         Else
             Emitter.EmitBranch(Info, conditionLabel)
         End If
 
         'Emit the contained code.
         Emitter.MarkLabel(Info, startlabel)
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         'This is the start of the next iteration
         Emitter.MarkLabel(Info, m_NextIteration)
 
         If m_IsLateBound Then
             EmitLoadCounter(Info, loopCounter)
             'Emitter.EmitLoadVariable(Info, loopCounter)
             Emitter.EmitLoadVariable(Info, loopLateBoundObject)
             EmitLoadAddressCounter(Info, loopCounter)
             'Emitter.EmitLoadVariableLocation(Info, loopCounter)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckObj_Object_Object_Object)
             Emitter.EmitBranchIfTrue(Info, startlabel)
         ElseIf m_IsDecimal Then
             EmitStoreCounterInstanceExpression(Info, loopCounter)
             EmitLoadCounter(Info, loopCounter) 'Emitter.EmitLoadVariable(Info, loopCounter)
             Emitter.EmitLoadVariable(Info, loopStep)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             EmitStoreCounter(Info, loopCounter)
 
             'Do the comparison
             Emitter.MarkLabel(Info, conditionLabel)
 
             'Load the current value
             EmitLoadCounter(Info, loopCounter)
             'Emitter.EmitLoadVariable(Info, loopCounter)
 
             'Load the max value
             Emitter.EmitLoadVariable(Info, loopMax)
 
             'Load the step value
             Emitter.EmitLoadVariable(Info, loopStep)
 
             'Compare the values
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckDec_Decimal_Decimal_Decimal)
             Emitter.EmitBranchIfTrue(Info, startlabel)
         Else
             EmitStoreCounterInstanceExpression(Info, loopCounter)
             EmitLoadCounter(Info, loopCounter) 'Emitter.EmitLoadVariable(Info, loopCounter)
             Emitter.EmitLoadVariable(Info, loopStep)
             Emitter.EmitAdd(Info, m_LoopType)
             EmitStoreCounter(Info, loopCounter) 'Emitter.EmitStoreVariable(Info, loopCounter)
 
             'Do the comparison
             Emitter.MarkLabel(Info, conditionLabel)
 
             'Load the current value
             EmitLoadCounter(Info, loopCounter) 'Emitter.EmitLoadVariable(Info, loopCounter)
 
             'Load the max value
             Emitter.EmitLoadVariable(Info, loopMax)
 
             'Compare the values
             If IsKnownStep() Then
                 If IsPositiveStep() Then
                     Emitter.EmitLE(Info, m_LoopType)
                     Emitter.EmitBranchIfTrue(Info, startlabel)
                 ElseIf IsNegativeStep() Then
                     Emitter.EmitGE(Info, m_LoopType)
                     Emitter.EmitBranchIfTrue(Info, startlabel)
                 Else
                     Helper.AddError(Me, "Infinite loop")
                 End If
             Else
                 Dim negativeLabel As Label
                 Dim endCheck As Label
 
                 negativeLabel = Emitter.DefineLabel(Info)
                 endCheck = Emitter.DefineLabel(Info)
 
                 Emitter.EmitLoadVariable(Info, loopStep)
                 Dim tmp As Object = Nothing
                 If TypeConverter.ConvertTo(Me, 0, m_LoopType, tmp) Then
                     Emitter.EmitLoadValue(Info.Clone(Me, True, False, m_LoopType), tmp)
                 Else
                     Throw New InternalException
                 End If
                 Emitter.EmitGE(Info, m_LoopType) 'stepvar >= 0?
                 Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Brfalse_S, negativeLabel)
                 Emitter.EmitLE(Info, m_LoopType) 'Positive check
                 Emitter.EmitBranch(Info, endCheck)
                 Emitter.MarkLabel(Info, negativeLabel)
                 Emitter.EmitGE(Info, m_LoopType) 'Negative check
                 Emitter.MarkLabel(Info, endCheck)
                 Emitter.EmitBranchIfTrue(Info, startlabel)
             End If
         End If
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="412" endline="419"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = GenerateCodeInternal(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="420" endline="542"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LoopControlVariable.ResolveCode(Info) AndAlso result
         result = m_LoopStartExpression.ResolveExpression(Info) AndAlso result
         result = m_LoopEndExpression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_LoopControlVariable.MustInfer = False AndAlso m_LoopControlVariable.Expression IsNot Nothing Then
             If m_LoopControlVariable.Expression.Classification.IsVariableClassification = False Then
                 Select Case m_LoopControlVariable.Expression.Classification.Classification
                     Case ExpressionClassification.Classifications.Type
                         If Me.IsOptionInferOn Then
                             m_LoopControlVariable.MustInfer = True
                         Else
                             Return Compiler.Report.ShowMessage(Messages.VBNC30108, Me.Location, m_LoopControlVariable.Identifier.Identifier)
                         End If
                     Case ExpressionClassification.Classifications.PropertyAccess, ExpressionClassification.Classifications.PropertyGroup, ExpressionClassification.Classifications.LateBoundAccess
                         Return Compiler.Report.ShowMessage(Messages.VBNC30039, Me.Location) AndAlso result
                     Case ExpressionClassification.Classifications.Value
                         Return Helper.ShowClassificationError(Compiler, Me.Location, m_LoopControlVariable.Expression.Classification, "Variable") AndAlso result
                     Case Else
                         Return Helper.ShowClassificationError(Compiler, Me.Location, m_LoopControlVariable.Expression.Classification, "Variable") AndAlso result
                 End Select
             End If
         End If
 
         If m_LoopStepExpression IsNot Nothing Then
             result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
             If Not m_LoopStepExpression.Classification.CanBeValueClassification Then
                 result = m_LoopStepExpression.ReportReclassifyToValueErrorMessage()
             Else
                 m_LoopStepExpression = m_LoopStepExpression.ReclassifyToValueExpression()
                 result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If Not m_LoopStartExpression.Classification.CanBeValueClassification Then
             result = m_LoopStartExpression.ReportReclassifyToValueErrorMessage()
         Else
             m_LoopStartExpression = m_LoopStartExpression.ReclassifyToValueExpression()
             result = m_LoopStartExpression.ResolveExpression(Info) AndAlso result
         End If
 
         If Not m_LoopEndExpression.Classification.CanBeValueClassification Then
             result = m_LoopEndExpression.ReportReclassifyToValueErrorMessage()
         Else
             m_LoopEndExpression = m_LoopEndExpression.ReclassifyToValueExpression()
             result = m_LoopEndExpression.ResolveExpression(Info) AndAlso result
         End If
 
         If result = False Then Return result
 
         If m_LoopControlVariable.MustInfer Then
             Dim start_type As TypeReference = m_LoopStartExpression.ExpressionType
             Dim end_type As TypeReference = m_LoopEndExpression.ExpressionType
             Dim step_type As TypeReference = If(m_LoopStepExpression IsNot Nothing, m_LoopStepExpression.ExpressionType, Nothing)
 
             m_LoopType = Compiler.TypeResolution.GetWidestType(start_type, end_type, step_type)
             If m_LoopType Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30983, Me.Location, m_LoopControlVariable.Identifier.Identifier)
                 Return False
             End If
 
             m_LoopControlVariable.CreateInferredVariable(m_LoopType)
         Else
             m_LoopType = m_LoopControlVariable.VariableType
         End If
 
         If m_LoopStepExpression Is Nothing Then
             If m_LoopControlVariable.MustInfer Then
                 m_LoopStepExpression = New ConstantExpression(Me, 1, m_LoopType)
                 result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
                 If Helper.IsEnum(Compiler, m_LoopType) Then
                     m_LoopStepExpression = New CTypeExpression(Me, m_LoopStepExpression, m_LoopType)
                     result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
                 End If
             Else
                 m_LoopStepExpression = New ConstantExpression(Me, 1, Compiler.TypeCache.System_Int32)
                 result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         'If m_NextExpressionList IsNot Nothing Then result = m_NextExpressionList.ResolveCode(info) AndAlso result
         m_LoopStepExpression = Helper.CreateTypeConversion(Me, m_LoopStepExpression, m_LoopType, result)
         m_LoopStartExpression = Helper.CreateTypeConversion(Me, m_LoopStartExpression, m_LoopType, result)
         m_LoopEndExpression = Helper.CreateTypeConversion(Me, m_LoopEndExpression, m_LoopType, result)
 
         If m_LoopControlVariable.IsVariableDeclaration Then
             CodeBlock.Variables.Add(m_LoopControlVariable.GetVariableDeclaration)
         End If
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         Select Case Helper.GetTypeCode(Compiler, m_LoopType)
             Case TypeCode.Boolean, TypeCode.Char, TypeCode.DBNull, TypeCode.Empty, TypeCode.String
                 result = Compiler.Report.ShowMessage(Messages.VBNC30337, Location, m_LoopType.Name) AndAlso result
             Case TypeCode.Decimal
                 m_IsLateBound = False
                 m_IsDecimal = True
             Case TypeCode.Byte, TypeCode.Double, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.Single, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 m_IsLateBound = False
             Case TypeCode.Object
                 m_IsLateBound = True
 
                 Compiler.Helper.AddCheck("The loop control variable of a For statement must be of a primitive numeric type (...), Object, or a type T that has the following operators
 
             Case Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30337, Location, m_LoopType.Name) AndAlso result
         End Select
 
 
         Compiler.Helper.AddCheck("Check that loop variable has not been used in another for statement.")
         Compiler.Helper.AddCheck("The bound and step expressions must be implicitly convertible to the type of the loop control. ")
         Compiler.Helper.AddCheck("If a variable matches a For loop that is not the most nested loop at that point, a compile-time error results")
         Compiler.Helper.AddCheck("It is not valid to branch into a For loop from outside the loop.")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="32" endline="34"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="35" endline="39"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal GotoWhere As Token)
         MyBase.New(Parent)
         m_GotoWhere = GotoWhere
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="40" endline="47"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitBranchOrLeave(Info, m_Destination.GetLabel(Info), Me, m_Destination)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="48" endline="56"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_Destination = Me.FindFirstParent(Of CodeBlock).FindLabel(m_GotoWhere)
         result = m_Destination IsNot Nothing AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="57" endline="61"><![CDATA[
 
     ReadOnly Property GotoWhere() As Token
         Get
             Return m_GotoWhere
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="53" endline="55"><![CDATA[
         Get
             Return m_Condition
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="56" endline="61"><![CDATA[
     End Property
 
     ReadOnly Property FalseCode() As CodeBlock
         Get
             Return m_FalseCode
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="62" endline="67"><![CDATA[
     End Property
 
     ReadOnly Property ElseIfs() As BaseObjects(Of ElseIfStatement)
         Get
             Return m_ElseIfs
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="68" endline="72"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="73" endline="81"><![CDATA[
 
     Shadows Sub Init(ByVal Condition As Expression, ByVal FalseCode As CodeBlock, ByVal TrueCode As CodeBlock, ByVal OneLiner As Boolean, ByVal ElseIfs As BaseObjects(Of ElseIfStatement))
         MyBase.Init(TrueCode)
 
         m_Condition = Condition
         m_FalseCode = FalseCode
         m_ElseIfs = ElseIfs
         m_OneLiner = OneLiner
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="82" endline="111"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim startFalse As Label = Emitter.DefineLabel(Info)
         EndLabel = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
 
         Emitter.EmitBranchIfFalse(Info, startFalse)
         'True code
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, EndLabel)
 
         'False code
         Emitter.MarkLabel(Info, startFalse)
         If m_ElseIfs IsNot Nothing Then
             For Each eif As ElseIfStatement In m_ElseIfs
                 result = eif.GenerateCode(Info) AndAlso result
             Next
         End If
 
         If m_FalseCode IsNot Nothing Then
             result = m_FalseCode.GenerateCode(Info) AndAlso result
         End If
         Emitter.MarkLabel(Info, EndLabel)
 
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="112" endline="145"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveCode(Info) AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Condition.Classification.IsValueClassification Then
             'nothing to do
         ElseIf m_Condition.Classification.CanBeValueClassification Then
             m_Condition = m_Condition.ReclassifyToValueExpression
             result = m_Condition.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
 
             If result = False Then
                 Helper.AddError(Me)
                 Return result
             End If
         Else
             Helper.AddError(Me, "Each expression in an If...Then...Else statement must be classified as a value and be implicitly convertible to Boolean")
         End If
 
         m_Condition = Helper.CreateTypeConversion(Me, m_Condition, Compiler.TypeCache.System_Boolean, result)
 
         If result = False Then
             Helper.AddError(Me)
             Return result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="146" endline="157"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If m_Condition IsNot Nothing Then result = m_Condition.ResolveTypeReferences AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveTypeReferences AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="158" endline="162"><![CDATA[
 
     Overrides ReadOnly Property IsOneLiner() As Boolean
         Get
             Return m_OneLiner OrElse MyBase.IsOneLiner
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="36" endline="38"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="39" endline="43"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Label As Token)
         MyBase.New(Parent)
         m_Label = Label
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="44" endline="47"><![CDATA[
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         Return tm.PeekToken = KS.Colon AndAlso (tm.CurrentToken.IsIntegerLiteral OrElse tm.CurrentToken.IsIdentifier)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="48" endline="55"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.MarkLabel(Info, GetLabel(Info))
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="56" endline="63"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Helper.AddCheck("Check if the label name is unique.")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="64" endline="70"><![CDATA[
 
     Function GetLabel(ByVal Info As EmitInfo) As Label
         If m_LabelBuilder.HasValue = False Then
             m_LabelBuilder = Emitter.DefineLabel(Info)
         End If
         Return m_LabelBuilder.Value
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="71" endline="75"><![CDATA[
 
     ReadOnly Property Label() As Token
         Get
             Return m_Label
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="38" endline="40"><![CDATA[
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     ReadOnly Property ArrayNameModifier() As ArrayNameModifier
         Get
             Return m_ArrayNameModifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="47" endline="52"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As TypeName
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="53" endline="58"><![CDATA[
     End Property
 
     ReadOnly Property Expression() As Expression
         Get
             Return m_Expression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="59" endline="71"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
 
         If m_Declaration IsNot Nothing Then result = m_Declaration.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="72" endline="75"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="76" endline="82"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier, ByVal TypeName As TypeName, ByVal Expression As Expression)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
         m_TypeName = TypeName
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="83" endline="86"><![CDATA[
 
     Function GetVariableDeclaration() As LocalVariableDeclaration
         Return m_Declaration
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="87" endline="91"><![CDATA[
 
     ReadOnly Property IsVariableDeclaration() As Boolean
         Get
             Return m_TypeName IsNot Nothing OrElse m_Declaration IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="92" endline="111"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Store the stack value into the loop control variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitStoreVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Info.RHSExpression IsNot Nothing)
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             result = Info.RHSExpression.Classification.GenerateCode(Info.Clone(Me, True, False, m_Declaration.LocalBuilder.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info) AndAlso result
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="112" endline="128"><![CDATA[
 
     ''' <summary>
     ''' Loads the loop control variable onto the stack
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitLoadVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             Emitter.EmitLoadVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False)) AndAlso result
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="129" endline="147"><![CDATA[
 
     ''' <summary>
     ''' This creates the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Declaration IsNot Nothing Then
             result = m_Declaration.DefineLocalVariable(Info) AndAlso result
             result = m_Declaration.GenerateCode(Info) AndAlso result
         Else
             'm_LoopVariableBuilder()
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="148" endline="158"><![CDATA[
 
     ReadOnly Property VariableType() As Mono.Cecil.TypeReference
         Get
             If m_Expression IsNot Nothing Then
                 Return m_Expression.ExpressionType
             ElseIf m_TypeName IsNot Nothing Then
                 Return m_TypeName.ResolvedType
             Else
                 Return m_Declaration.VariableType
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="159" endline="196"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim sne As SimpleNameExpression
 
         If m_Expression IsNot Nothing Then
             sne = TryCast(m_Expression, SimpleNameExpression)
             If sne IsNot Nothing Then
                 sne.InferEnabled = Me.IsOptionInferOn
                 If sne.ResolveExpression(Info) = False Then
                     If sne.InferPossible Then
                         MustInfer = True
                         result = True 'So far so good
                     Else
                         result = False
                     End If
                 End If
             Else
                 result = m_Expression.ResolveExpression(Info) AndAlso result
 
                 Dim iie As InvocationOrIndexExpression = TryCast(m_Expression, InvocationOrIndexExpression)
                 If iie IsNot Nothing AndAlso iie.IsLateBoundArray Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30039, Location) AndAlso result
                 End If
             End If
         Else
             'result = m_Identifier.Resolve AndAlso result
             'result = m_ArrayNameModifier.Resolve AndAlso result
             result = m_TypeName.ResolveTypeReferences AndAlso result
             m_Declaration = New LocalVariableDeclaration(Me, New Modifiers(), m_Identifier, False, m_TypeName, Nothing, Nothing)
             result = m_Declaration.ResolveTypeReferences() AndAlso result
             'result = m_Declaration.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
             result = m_Declaration.ResolveCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="197" endline="202"><![CDATA[
 
     Public Sub CreateInferredVariable(ByVal Type As TypeReference)
         m_Declaration = New LocalVariableDeclaration(Me)
         m_Declaration.Init(New Modifiers(), m_Identifier.Identifier, Type)
         m_Expression = Nothing
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="39" endline="45"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal IsResumeNext As Boolean, ByVal Label As Token, ByVal IsGotoMinusOne As Boolean, ByVal IsGotoZero As Boolean)
         MyBase.New(Parent)
         m_IsResumeNext = IsResumeNext
         m_Label = Label
         m_IsGotoMinusOne = IsGotoMinusOne
         m_IsGotoZero = IsGotoZero
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="46" endline="53"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedLabel IsNot Nothing Then result = m_ResolvedLabel.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="54" endline="90"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim parent As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         Dim lastparent As CodeBlock = parent.FindFirstParent(Of CodeBlock)()
         Do Until lastparent Is Nothing
             parent = lastparent
             lastparent = parent.FindFirstParent(Of CodeBlock)()
         Loop
         Do Until lastparent Is Nothing
             parent = lastparent
             lastparent = parent.FindFirstParent(Of CodeBlock)()
         Loop
 
         If m_IsGotoMinusOne Then
             '	On Error GoTo -1 resets the most recent exception to Nothing.
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
         ElseIf m_IsGotoZero Then
             '	On Error GoTo 0 resets the most recent exception-handler location to Nothing.
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
             Emitter.EmitLoadI4Value(Info, 0)
             Emitter.EmitStoreVariable(Info, parent.VB_ActiveHandler)
         ElseIf m_IsResumeNext Then
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
             '	On Error Resume Next, establishes the Resume Next behavior as the most recent exception-handler location.
             Emitter.EmitLoadI4Value(Info, parent.UnstructuredExceptionHandlers.IndexOf(parent.UnstructuredResumeNextHandler)) 'Load the index of the switch table, 1 = resume next handler.
             Emitter.EmitStoreVariable(Info, parent.VB_ActiveHandler)
         Else
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
             Dim index As Integer
             If parent.UnstructuredExceptionHandlers.Contains(m_ResolvedLabel.GetLabel(Info)) = False Then
                 parent.UnstructuredExceptionHandlers.Add(m_ResolvedLabel.GetLabel(Info))
             End If
             index = parent.UnstructuredExceptionHandlers.IndexOf(m_ResolvedLabel.GetLabel(Info))
             Emitter.EmitLoadI4Value(Info, index)
             Emitter.EmitStoreVariable(Info, parent.VB_ActiveHandler)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="91" endline="109"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         block.HasUnstructuredExceptionHandling = True
         If m_IsResumeNext Then block.HasResume = True
         If block.HasStructuredExceptionHandling Then
             Helper.AddError(Me, "No structured exception handling in the same method.")
         End If
 
         If Token.IsSomething(m_Label) Then
             block = Me.FindFirstParent(Of CodeBlock)()
             m_ResolvedLabel = block.FindLabel(m_Label)
             Compiler.Helper.AddCheck("Label must exist.")
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionCompareStatement.vb" startline="30" endline="32"><![CDATA[
     Sub New(ByVal Parent As BaseObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionCompareStatement.vb" startline="33" endline="36"><![CDATA[
 
     Sub Init(ByVal Binary As Boolean)
         m_IsBinary = Binary
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionCompareStatement.vb" startline="37" endline="41"><![CDATA[
 
     ReadOnly Property IsBinary() As Boolean
         Get
             Return m_IsBinary
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionCompareStatement.vb" startline="42" endline="46"><![CDATA[
     End Property
     ReadOnly Property IsText() As Boolean
         Get
             Return Not m_IsBinary
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionCompareStatement.vb" startline="47" endline="51"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.PeekToken(0) = KS.Option AndAlso tm.PeekToken(1).Equals("Compare")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionExplicitStatement.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As BaseObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionExplicitStatement.vb" startline="32" endline="35"><![CDATA[
 
     Sub Init(ByVal Off As Boolean)
         m_Off = Off
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionExplicitStatement.vb" startline="36" endline="40"><![CDATA[
 
     ReadOnly Property Off() As Boolean
         Get
             Return m_Off
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionExplicitStatement.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     ReadOnly Property IsOn() As Boolean
         Get
             Return Not m_Off
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionExplicitStatement.vb" startline="47" endline="51"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.PeekToken(0) = KS.Option AndAlso tm.PeekToken(1).Equals("Explicit")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionInferStatement.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As BaseObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionInferStatement.vb" startline="32" endline="35"><![CDATA[
 
     Sub Init(ByVal Off As Boolean)
         m_Off = Off
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionInferStatement.vb" startline="36" endline="40"><![CDATA[
 
     ReadOnly Property Off() As Boolean
         Get
             Return m_Off
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionInferStatement.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     ReadOnly Property IsOn() As Boolean
         Get
             Return Not m_Off
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionInferStatement.vb" startline="47" endline="51"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.PeekToken(0) = KS.Option AndAlso tm.PeekToken(1).Equals("Infer")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As BaseObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="32" endline="35"><![CDATA[
 
     Sub Init(ByVal Off As Boolean)
         m_off = off
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="36" endline="40"><![CDATA[
 
     ReadOnly Property IsOn() As Boolean
         Get
             Return Not m_Off
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="41" endline="45"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.PeekToken(0) = KS.Option AndAlso tm.PeekToken(1).Equals("Strict")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="35" endline="42"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_Arguments IsNot Nothing Then result = m_Arguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="43" endline="47"><![CDATA[
 
     ReadOnly Property [Event]() As SimpleNameExpression
         Get
             Return m_Event
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="48" endline="53"><![CDATA[
     End Property
 
     ReadOnly Property Arguments() As ArgumentList
         Get
             Return m_Arguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="54" endline="58"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="59" endline="63"><![CDATA[
 
     Sub Init(ByVal [Event] As SimpleNameExpression, ByVal Arguments As ArgumentList)
         m_Event = [Event]
         m_Arguments = Arguments
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="64" endline="124"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Event.Classification.IsEventAccessClassification)
 
         Dim cl As EventAccessClassification = m_Event.Classification.AsEventAccess
         Dim eventtp As Mono.Cecil.TypeReference = cl.EventType
         Dim delegatetp As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(cl.Type)
 
         Helper.Assert(delegatetp IsNot Nothing)
 
         Dim raiseMethod As Mono.Cecil.MethodReference
         raiseMethod = CecilHelper.FindDefinition(cl.EventInfo).InvokeMethod
         If raiseMethod IsNot Nothing Then
             'Call the raise method
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
         Else
             'Manually raise the event
             Dim delegateVar As Mono.Cecil.Cil.VariableDefinition
             Dim endIfLabel As Label
             Dim eventDeclaration As RegularEventDeclaration
             Dim eventdesc As Mono.Cecil.EventDefinition
             Dim invokemethod As Mono.Cecil.MethodReference
 
             delegateVar = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, delegatetp))
             endIfLabel = Emitter.DefineLabel(Info)
             eventdesc = CecilHelper.FindDefinition(cl.EventInfo)
             eventDeclaration = DirectCast(eventdesc.Annotations(Compiler), RegularEventDeclaration)
             invokemethod = Helper.GetInvokeMethod(Compiler, delegatetp)
 
             'Helper.Assert(eventDeclaration IsNot Nothing)
             'Helper.Assert(TypeOf cl.EventInfo Is EventDescriptor)
             'Helper.Assert(Helper.CompareType(cl.EventType, Me.FindFirstParent(Of IType).CecilType))
             Helper.Assert(invokemethod IsNot Nothing)
 
             'Load the field of the variable
             If eventDeclaration.EventField.IsStatic = False Then
                 Emitter.EmitLoadMe(Info, cl.EventType)
             End If
             Emitter.EmitLoadVariable(Info, eventDeclaration.EventField)
 
             'Test if the field is nothing
             Emitter.EmitStoreVariable(Info, delegateVar)
             Emitter.EmitLoadVariable(Info, delegateVar)
             'If the field is nothing, don't invoke anything.
             Emitter.EmitBranchIfFalse(Info, endIfLabel)
 
             'Load the field again
             Emitter.EmitLoadVariable(Info, delegateVar)
             'Load the invoke arguments
             result = m_Arguments.GenerateCode(Info.Clone(Me, True), invokemethod.Parameters) AndAlso result
             'Call the invoke method.
             Emitter.EmitCallOrCallVirt(Info, invokemethod)
 
             'End of the RaiseEvent statement.
             Emitter.MarkLabel(Info, endIfLabel)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="125" endline="136"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_Event.ResolveExpression(Info) AndAlso result
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Compiler.Helper.AddCheck("The result of the expression must be classified as an event access for an event defined in the class itself; ")
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="51" endline="58"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArraySizeInitModifier IsNot Nothing Then result = m_ArraySizeInitModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="59" endline="62"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="63" endline="67"><![CDATA[
 
     Sub Init(ByVal Expression As Expression, ByVal ArraySizeInitModifier As ArraySizeInitializationModifier)
         m_Expression = Expression
         m_ArraySizeInitModifier = ArraySizeInitModifier
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="68" endline="101"><![CDATA[
 
     Private Function GenerateCodeForNewArray(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim rankTypes() As Mono.Cecil.TypeReference = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, m_Rank)
 
         Helper.Assert(m_Rank >= 1)
 
         If m_Rank = 1 Then
             result = m_ArraySizeInitModifier.BoundList.Expressions(0).GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
             Emitter.EmitNewArr(Info, m_ElementType)
         Else
             'Dim ctor As ConstructorInfo
             'ctor = m_ArrayType.GetConstructor(BindingFlags.Instance Or BindingFlags.Public, Nothing, Nothing, rankTypes, Nothing)
             'ctor = Compiler.TypeCache.Array.GetConstructor(BindingFlags.Instance Or BindingFlags.NonPublic Or BindingFlags.Public, Nothing, Type.EmptyTypes, Nothing)
             ''ctor = Compiler.TypeCache.Array.GetConstructor(BindingFlags.Instance Or BindingFlags.NonPublic Or BindingFlags.Public, Nothing, rankTypes, Nothing)
             'Helper.Assert(ctor IsNot Nothing)
             'Emitter.EmitNew(Info, ctor)
 
             Dim ElementType As Mono.Cecil.TypeReference
             Dim ArrayType As Mono.Cecil.TypeReference
 
             ElementType = Helper.GetTypeOrTypeBuilder(Compiler, CecilHelper.GetElementType(m_ArrayType))
             ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, m_ArrayType)
 
             Emitter.EmitLoadToken(Info, ElementType)
             Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
 
             result = Helper.EmitIntegerArray(Info, m_ArraySizeInitModifier.BoundList.Expressions) AndAlso result
             Emitter.EmitCall(Info, Compiler.TypeCache.System_Array__CreateInstance)
 
             Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Array, ArrayType)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="102" endline="111"><![CDATA[
 
     Private Function GenerateCodeForPreserve(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_ArrayType)) AndAlso result
         Emitter.EmitCastClass(Info, m_Expression.ExpressionType, Compiler.TypeCache.System_Array)
         result = GenerateCodeForNewArray(Info) AndAlso result
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Utils__CopyArray_Array_Array)
         Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Array, m_ArrayType)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="112" endline="116"><![CDATA[
 
     ReadOnly Property IsPreserve() As Boolean
         Get
             Return Me.FindFirstParent(Of ReDimStatement).IsPreserve
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="117" endline="125"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AssignStatement.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="126" endline="211"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim expCount As Integer
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
         result = m_ArraySizeInitModifier.ResolveCode(Info) AndAlso result
 
         If CecilHelper.IsByRef(m_Expression.ExpressionType) Then
             m_Expression = m_Expression.DereferenceByRef
         End If
 
         m_ArrayType = m_Expression.ExpressionType
         m_IsObjectArray = Helper.CompareType(Compiler.TypeCache.System_Object, m_ArrayType)
 
         expCount = m_ArraySizeInitModifier.BoundList.Expressions.Length
 
         If m_IsObjectArray Then
             m_Rank = expCount
             m_ElementType = Compiler.TypeCache.System_Object
             If m_Rank = 1 Then
                 m_ArrayType = CecilHelper.MakeArrayType(m_ElementType)
             Else
                 m_ArrayType = CecilHelper.MakeArrayType(m_ElementType, m_Rank)
             End If
         ElseIf CecilHelper.IsArray(m_ArrayType) = False Then
             Return Helper.AddError(Me)
         Else
             m_Rank = CecilHelper.GetArrayRank(m_ArrayType)
             m_ElementType = CecilHelper.GetElementType(m_ArrayType)
             If expCount <> m_Rank Then
                 Return Helper.AddError(Me)
             End If
         End If
 
         If Me.IsPreserve Then
             Dim assign As New AssignmentStatement(Me)
             Dim arr As CompilerGeneratedExpression
 
             arr = New CompilerGeneratedExpression(Me, New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeForPreserve), m_ArrayType)
 
             For i As Integer = 0 To expCount - 1
                 Dim add As New ConstantExpression(Me, 1, Compiler.TypeCache.System_Int32)
                 Dim exp As Expression
                 Dim addExp As Expression
 
                 exp = Helper.CreateTypeConversion(Me, m_ArraySizeInitModifier.BoundList.Expressions(i), Compiler.TypeCache.System_Int32, result)
                 If result = False Then Return result
 
                 addExp = New BinaryAddExpression(Me, exp, add)
                 result = addExp.ResolveExpression(Info) AndAlso result
                 m_ArraySizeInitModifier.BoundList.Expressions(i) = addExp
             Next
 
             assign.Init(m_Expression, arr)
             result = assign.ResolveStatement(Info) AndAlso result
             m_AssignStatement = assign
         Else
             Dim assign As New AssignmentStatement(Me)
             Dim arr As New ArrayCreationExpression(Me)
             Dim exps() As Expression
 
             exps = m_ArraySizeInitModifier.BoundList.Expressions
             arr.Init(m_Expression.ExpressionType, exps, Nothing)
 
             assign.Init(m_Expression, arr)
             result = assign.ResolveStatement(Info) AndAlso result
             m_AssignStatement = assign
         End If
 
         If m_Expression.Classification.IsPropertyGroupClassification Then
             m_Expression = m_Expression.ReclassifyToPropertyAccessExpression()
             result = m_Expression.ResolveExpression(Info) AndAlso result
         ElseIf m_Expression.Classification.IsVariableClassification Then
         ElseIf m_Expression.Classification.IsPropertyAccessClassification Then
         Else
             Return Helper.AddError(Me, "Redim clause must be classifiable as a property access or variable.")
         End If
         If IsPreserve Then
             If m_Expression.Classification.CanBeValueClassification = False Then
                 Return Helper.AddError(Me, "Redim Preserve clause must be classifiable as a value.")
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClauses.vb" startline="30" endline="32"><![CDATA[
     Sub New(ByVal Parent As ReDimStatement)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="35" endline="37"><![CDATA[
         Get
             Return m_Clauses
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="38" endline="42"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Clauses Is Nothing OrElse m_Clauses.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="43" endline="46"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="47" endline="51"><![CDATA[
 
     Sub Init(ByVal IsPreserve As Boolean, ByVal Clauses As RedimClauses)
         m_IsPreserve = IsPreserve
         m_Clauses = Clauses
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="52" endline="56"><![CDATA[
     
     ReadOnly Property IsPreserve() As Boolean
         Get
             Return m_IsPreserve
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="57" endline="65"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Helper.GenerateCodeCollection(m_Clauses, Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="66" endline="77"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Clauses.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Each clause in the statement must be classified as a variable or a property access whose type is an array type or Object, and be followed by a list of array bounds. ")
         Compiler.Helper.AddCheck("The number of the bounds must be consistent with the type of the variable; any number of bounds is allowed for Object.")
         Compiler.Helper.AddCheck("If the Preserve keyword is specified, then the expressions must also be classifiable as a value, and the new size for each dimension except for the rightmost one must be the same as the size of the existing array. ")
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ResumeStatement.vb" startline="24" endline="27"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal IsResumeNext As Boolean)
         MyBase.New(Parent)
         m_IsResumeNext = IsResumeNext
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ResumeStatement.vb" startline="28" endline="31"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ResumeStatement.vb" startline="32" endline="69"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim ResumeOK As Label = Emitter.DefineLabel(Info)
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         Dim lastblock As CodeBlock = block
         Do Until lastblock Is Nothing
             block = lastblock
             lastblock = block.FindFirstParent(Of CodeBlock)()
         Loop
         Do Until lastblock Is Nothing
             block = lastblock
             lastblock = block.FindFirstParent(Of CodeBlock)()
         Loop
 
         'Clear the error.
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
 
         'Test if the code is in an exception handler
         Emitter.EmitLoadVariable(Info, block.VB_ResumeTarget)
         Emitter.EmitBranchIfTrue(Info, ResumeOK)
 
         'If code is not in an exception handler raise an error
         Emitter.EmitLoadI4Value(Info, -2146828268)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Emitter.MarkLabel(Info, ResumeOK)
         'Load the instruction switch index
         Emitter.EmitLoadVariable(Info, block.VB_CurrentInstruction)
         'Increment the instruction pointer if it is a Resume Next statement
         If m_IsResumeNext Then
             Emitter.EmitLoadI4Value(Info, 1)
             Emitter.EmitAdd(Info, Compiler.TypeCache.System_Int32)
         End If
         'If everything is ok, jump to the instruction switch (adding one to the instruction if necessary)
         Emitter.EmitLeave(Info, block.UnstructuredResumeHandler)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ResumeStatement.vb" startline="70" endline="81"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Helper.AddCheck("Resume statement can only occur in methods with no structured exception handling.")
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         block.HasUnstructuredExceptionHandling = True
         block.HasResume = True
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="25" endline="27"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="28" endline="31"><![CDATA[
 
     Sub Init(ByVal Expression As Expression)
         m_Expression = Expression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="32" endline="48"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim isSub As Boolean
 
         isSub = Info.Method.Signature.ReturnType Is Nothing OrElse Helper.CompareType(Info.Method.Signature.ReturnType, Compiler.TypeCache.System_Void)
         If isSub Then
             Helper.Assert(m_Expression Is Nothing)
         Else
             Helper.Assert(m_Expression IsNot Nothing)
             result = m_Expression.GenerateCode(Info.Clone(Me, True, , Info.Method.Signature.ReturnType)) AndAlso result
         End If
 
         Emitter.EmitRetOrLeave(Info, Me, Not isSub)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="49" endline="71"><![CDATA[
 
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(info) AndAlso result
             If result AndAlso m_Expression.Classification.IsValueClassification = False Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If result = False Then Return result
 
         If m_Expression IsNot Nothing Then
             Dim method As IMethod
             method = Me.FindFirstParent(Of IMethod)()
             m_Expression = Helper.CreateTypeConversion(Me, m_Expression, method.Signature.ReturnType, result)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="72" endline="75"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Expression Is Nothing OrElse m_Expression.ResolveTypeReferences()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="38" endline="40"><![CDATA[
         Get
             Return m_cachedtest
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="41" endline="46"><![CDATA[
     End Property
 
     ReadOnly Property Test() As Expression
         Get
             Return m_Test
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="47" endline="52"><![CDATA[
     End Property
 
     ReadOnly Property Cases() As BaseObjects(Of CaseStatement)
         Get
             Return m_Cases
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="53" endline="62"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Test IsNot Nothing Then result = m_Test.ResolveTypeReferences AndAlso result
         If m_Cases IsNot Nothing Then result = m_Cases.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="63" endline="66"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="67" endline="71"><![CDATA[
 
     Sub Init(ByVal Test As Expression, ByVal Cases As BaseObjects(Of CaseStatement))
         m_Test = Test
         m_Cases = Cases
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="72" endline="86"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.DefineLabel(Info)
 
         For i As Integer = 0 To m_Cases.Count - 1
             Dim stmt As CaseStatement = m_Cases(i)
             result = stmt.GenerateCode(Info) AndAlso result
         Next
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="87" endline="103"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Test.ResolveExpression(Info) AndAlso result
         If result = False Then Return False
 
         result = Helper.VerifyValueClassification(m_Test, Info) AndAlso result
         If result = False Then Return False
 
         m_CachedTest = New CachedExpression(m_Test, m_Test)
 
         result = m_Cases.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Check that there is at most one else block, and only at the end.")
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\Statement.vb" startline="24" endline="32"><![CDATA[
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\Statement.vb" startline="33" endline="37"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\Statement.vb" startline="38" endline="42"><![CDATA[
 
     ReadOnly Property FindParentCodeBlock() As CodeBlock
         Get
             Return MyBase.FindFirstParent(Of CodeBlock)()
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\Statement.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\Statement.vb" startline="43" endline="50"><![CDATA[
     End Property
 
     MustOverride Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
 
     <Obsolete("Call ResolveStatement"), ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Never)> _
     Public NotOverridable Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return ResolveStatement(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\StopStatement.vb" startline="23" endline="25"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\StopStatement.vb" startline="26" endline="29"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\StopStatement.vb" startline="30" endline="38"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ' Helper.NotImplemented()
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Diagnostics_Debugger__Break)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\StopStatement.vb" startline="39" endline="42"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="33" endline="35"><![CDATA[
         Get
             Return m_Lock
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="36" endline="45"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Lock) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="46" endline="49"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="50" endline="54"><![CDATA[
 
     Shadows Sub Init(ByVal Lock As Expression, ByVal Code As CodeBlock)
         MyBase.Init(Code)
         m_Lock = Lock
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="55" endline="89"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lockType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, m_Lock.ExpressionType)
 
         Dim lockVariable As Mono.Cecil.Cil.VariableDefinition
         lockVariable = Emitter.DeclareLocal(Info, lockType)
 
         result = m_Lock.GenerateCode(Info.Clone(Me, True, False, lockType)) AndAlso result
         Emitter.EmitStoreVariable(Info, lockVariable)
 
         If Helper.CompareType(Compiler.TypeCache.System_Object, lockVariable.VariableType) Then
             Emitter.EmitLoadVariable(Info, lockVariable)
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ObjectFlowControl__CheckForSyncLockOnValueType_Object)
         End If
 
         Dim endException As Label
         endException = Emitter.EmitBeginExceptionBlock(Info)
         'Enter the lock
         Emitter.EmitLoadVariable(Info, lockVariable)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Enter_Object)
 
         'Emit the code
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Info.ILGen.BeginFinallyBlock()
 
         'Exit the lock
         Emitter.EmitLoadVariable(Info, lockVariable)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Exit_Object)
 
         Info.ILGen.EndExceptionBlock()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="90" endline="98"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Lock.ResolveExpression(INfo) AndAlso result
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" startline="29" endline="31"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_Exception Is Nothing OrElse m_Exception.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" startline="32" endline="35"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" startline="36" endline="39"><![CDATA[
 
     Sub Init(ByVal Exception As Expression)
         m_Exception = Exception
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" startline="40" endline="52"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Exception Is Nothing Then
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Rethrow)
         Else
             result = m_Exception.GenerateCode(Info.Clone(Me, True, False, m_Exception.ExpressionType)) AndAlso result
             Emitter.EmitThrow(Info)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" startline="53" endline="64"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Exception IsNot Nothing Then
             result = m_Exception.ResolveExpression(Info) AndAlso result
             If result = False Then Return result
             result = Helper.VerifyValueClassification(m_Exception, Info) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="37" endline="39"><![CDATA[
         Get
             Return m_finallyblock
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="40" endline="45"><![CDATA[
     End Property
 
     ReadOnly Property Catches() As BaseObjects(Of CatchStatement)
         Get
             Return m_Catches
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="46" endline="50"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="51" endline="56"><![CDATA[
 
     Shadows Sub Init(ByVal Catches As BaseObjects(Of CatchStatement), ByVal TryBlock As CodeBlock, ByVal FinallyBlock As CodeBlock)
         MyBase.Init(TryBlock)
         m_Catches = Catches
         m_FinallyBlock = FinallyBlock
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="57" endline="78"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.EmitBeginExceptionBlock(Info)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         For i As Integer = 0 To m_Catches.Count - 1
             Dim catchstmt As CatchStatement = m_Catches(i)
             result = catchstmt.GenerateCode(Info) AndAlso result
         Next
 
         If m_FinallyBlock IsNot Nothing Then
             Info.ILGen.BeginFinallyBlock()
             result = m_FinallyBlock.GenerateCode(Info) AndAlso result
         End If
 
         Info.ILGen.EndExceptionBlock()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="79" endline="88"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Catches.ResolveCode(Info) AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveCode(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="89" endline="99"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Catches IsNot Nothing Then result = m_Catches.ResolveTypeReferences() AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="49" endline="51"><![CDATA[
         Get
             Return m_VariableInitializer
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="52" endline="57"><![CDATA[
     End Property
 
     ReadOnly Property Identifier() As Identifier
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="58" endline="63"><![CDATA[
     End Property
 
     ReadOnly Property ArgumentList() As ArgumentList
         Get
             Return m_ArgumentList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="64" endline="69"><![CDATA[
     End Property
 
     ReadOnly Property IsNew() As Boolean
         Get
             Return m_isnew
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="70" endline="75"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As NonArrayTypeName
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="76" endline="80"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="81" endline="90"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal ArgumentList As ArgumentList, ByVal VariableInitializer As VariableInitializer, ByVal IsVariableDeclaration As Boolean, ByVal VariableDeclaration As LocalVariableDeclaration)
         m_Identifier = Identifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_ArgumentList = ArgumentList
         m_VariableInitializer = VariableInitializer
         m_IsVariableDeclaration = IsVariableDeclaration
         m_VariableDeclaration = VariableDeclaration
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="91" endline="95"><![CDATA[
 
     ReadOnly Property IsVariableDeclaration() As Boolean
         Get
             Return m_IsVariableDeclaration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="96" endline="101"><![CDATA[
     End Property
 
     ReadOnly Property VariableDeclaration() As LocalVariableDeclaration
         Get
             Return m_VariableDeclaration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="102" endline="115"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsVariableDeclaration Then
             result = m_VariableDeclaration.GenerateCode(Info.Clone(Me, True, False, UsingVariableType)) AndAlso result
             UsingVariable = m_VariableDeclaration.LocalBuilder
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="116" endline="123"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_TypeName, m_ArgumentList, m_VariableInitializer) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="124" endline="161"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         'TODO
         If m_ArgumentList IsNot Nothing Then
             result = m_ArgumentList.ResolveCode(Info) AndAlso result
         End If
 
         If m_TypeName IsNot Nothing Then
             UsingVariableType = m_TypeName.ResolvedType
             m_IsVariableDeclaration = True
             If m_IsNew Then
                 Dim grp As New MethodGroupClassification(Me, Nothing, Nothing, Nothing, CecilHelper.GetConstructors(CecilHelper.FindDefinition(m_TypeName.ResolvedType)))
                 result = grp.ResolveGroup(m_ArgumentList) AndAlso result
                 m_Constructor = grp.ResolvedConstructor
                 If m_Constructor Is Nothing Then
                     result = Helper.AddError(Me) AndAlso result
                 End If
             End If
         ElseIf m_VariableInitializer IsNot Nothing Then
             UsingVariableType = Compiler.TypeCache.System_Object
             m_IsVariableDeclaration = True
         Else
             Helper.Assert(m_ArgumentList Is Nothing)
             'Helper.Assert(m_Identifier IsNot Nothing)
             m_IsVariableDeclaration = False
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         If m_VariableInitializer IsNot Nothing Then
             Dim expInfo As ExpressionResolveInfo
             expInfo = New ExpressionResolveInfo(Compiler, UsingVariableType)
             result = m_VariableInitializer.ResolveCode(expInfo) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="39" endline="41"><![CDATA[
         Get
             Return m_UsingResources
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="42" endline="51"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         ' result = Helper.ResolveTypeReferences(m_UsingResources) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="52" endline="55"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="56" endline="60"><![CDATA[
 
     Shadows Sub Init(ByVal UsingResources As ParsedObject, ByVal Code As CodeBlock)
         MyBase.Init(Code)
         m_UsingResources = UsingResources
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="61" endline="107"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim usingDecls As UsingDeclarators = TryCast(m_UsingResources, UsingDeclarators)
         Dim usingExp As Expression = TryCast(m_UsingResources, Expression)
         Dim usingVars As New Generic.Stack(Of Mono.Cecil.Cil.VariableDefinition)
         Dim exceptionEnds As New Generic.Stack(Of Label)
         Dim exceptionEnds2 As New Generic.Stack(Of Label)
 
         If usingDecls IsNot Nothing Then
             For i As Integer = 0 To usingDecls.Count - 1
                 Dim tmpDecl As UsingDeclarator = usingDecls(i)
                 result = usingDecls(i).GenerateCode(Info) AndAlso result
                 usingVars.Push(tmpDecl.UsingVariable)
                 exceptionEnds.Push(Emitter.EmitBeginExceptionBlock(Info))
                 exceptionEnds2.Push(Emitter.DefineLabel(Info))
             Next
         ElseIf usingExp IsNot Nothing Then
             Dim local As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, usingExp.ExpressionType)
             result = usingExp.GenerateCode(Info.Clone(Me, True, False, usingExp.ExpressionType)) AndAlso result
             Emitter.EmitStoreVariable(Info, local)
             usingVars.Push(local)
             exceptionEnds.Push(Emitter.EmitBeginExceptionBlock(Info))
             exceptionEnds2.Push(Emitter.DefineLabel(Info))
         Else
             Throw New InternalException(Me)
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         Do Until usingVars.Count = 0
             Dim tmpvar As Mono.Cecil.Cil.VariableDefinition = usingVars.Pop
             Dim endblock As Label = exceptionEnds.Pop
             Dim endblock2 As Label = exceptionEnds2.Pop
 
             Info.ILGen.BeginFinallyBlock()
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitBranchIfFalse(Info, endblock2)
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_IDisposable__Dispose)
             Emitter.MarkLabel(Info, endblock2)
             Info.ILGen.EndExceptionBlock()
         Loop
         Do Until usingVars.Count = 0
             Dim tmpvar As Mono.Cecil.Cil.VariableDefinition = usingVars.Pop
             Dim endblock As Label = exceptionEnds.Pop
             Dim endblock2 As Label = exceptionEnds2.Pop
 
             Info.ILGen.BeginFinallyBlock()
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitBranchIfFalse(Info, endblock2)
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_IDisposable__Dispose)
             Emitter.MarkLabel(Info, endblock2)
             Info.ILGen.EndExceptionBlock()
         Loop
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="108" endline="118"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_UsingResources.ResolveCode(Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="35" endline="37"><![CDATA[
         Get
             Return m_condition
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="38" endline="47"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Condition) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="48" endline="51"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="52" endline="56"><![CDATA[
 
     Shadows Sub Init(ByVal Condition As Expression, ByVal Code As CodeBlock)
         MyBase.Init(Code)
         m_Condition = Condition
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="57" endline="61"><![CDATA[
 
     ReadOnly Property NextIteration() As Label
         Get
             Return m_NextIteration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="62" endline="78"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         Emitter.MarkLabel(Info, m_NextIteration)
         result = m_Condition.GenerateCode(Info.Clone(Me, True, , Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, EndLabel)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, m_NextIteration)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="79" endline="88"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_Condition, Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="36" endline="43"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_WithExpression) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="44" endline="47"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="48" endline="52"><![CDATA[
 
     Shadows Sub Init(ByVal Code As CodeBlock, ByVal WithExpression As Expression)
         MyBase.Init(Code)
         m_WithExpression = WithExpression
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="53" endline="57"><![CDATA[
 
     ReadOnly Property WithVariable() As Mono.Cecil.Cil.VariableDefinition
         Get
             Return m_WithVariable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="58" endline="74"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_WithExpression Is m_WithVariableExpression = False Then
             m_WithVariable = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, m_WithExpression.ExpressionType), "WithVariable" & Me.ObjectID.ToString)
             result = m_WithExpression.GenerateCode(Info.Clone(Me, True, False, m_WithVariable.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_WithVariable)
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         Emitter.FreeLocal(m_WithVariable)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="75" endline="79"><![CDATA[
 
     ReadOnly Property WithVariableExpression() As Expression
         Get
             Return m_WithVariableExpression
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="80" endline="99"><![CDATA[
     End Property
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_WithExpression.ResolveExpression(Info) AndAlso result
 
         If result Then
             If CecilHelper.IsValueType(m_WithExpression.ExpressionType) AndAlso m_WithExpression.Classification.IsVariableClassification Then
                 m_WithVariableExpression = m_WithExpression
             Else
                 m_WithVariableExpression = New CompilerGeneratedExpression(Me, New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateVariableCode), m_WithExpression.ExpressionType)
                 result = m_WithVariableExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="100" endline="111"><![CDATA[
 
     Function GenerateVariableCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.IsRHS, "With variables can't be assigned to...")
 
         If Info.IsRHS Then
             Emitter.EmitLoadVariable(Info, m_WithVariable)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="26" endline="28"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="29" endline="32"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="33" endline="37"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Token As Token)
         MyBase.New(Parent)
         Me.Init(Token)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="38" endline="43"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As String, ByVal Keyword As KS)
         MyBase.New(Parent)
         m_Identifier = Identifier
         m_Keyword = Keyword
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="44" endline="48"><![CDATA[
 
     Sub Init(ByVal Identifier As String, ByVal Keyword As KS)
         m_Identifier = Identifier
         m_Keyword = Keyword
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="49" endline="54"><![CDATA[
 
     Sub Init(ByVal Token As Token)
         Helper.Assert(Token.IsIdentifierOrKeyword)
         m_Identifier = Token.Identifier
         If Token.IsKeyword Then m_Keyword = Token.Keyword
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="55" endline="59"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As IdentifierOrKeyword
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Return New IdentifierOrKeyword(NewParent, m_Identifier, m_Keyword)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="60" endline="64"><![CDATA[
 
     ReadOnly Property Name() As String
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="65" endline="70"><![CDATA[
     End Property
 
     ReadOnly Property Identifier() As String
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="71" endline="76"><![CDATA[
     End Property
 
     ReadOnly Property Keyword() As KS
         Get
             Return m_Keyword
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="77" endline="82"><![CDATA[
     End Property
 
     ReadOnly Property IsIdentifier() As Boolean
         Get
             Return Not IsKeyword
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeyword.vb" startline="83" endline="88"><![CDATA[
     End Property
 
     ReadOnly Property IsKeyword() As Boolean
         Get
             Return m_Keyword <> KS.None
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="25" endline="32"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="33" endline="36"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="37" endline="41"><![CDATA[
 
     Shadows Sub Init(ByVal Token As Token, ByVal TypeArguments As TypeArgumentList)
         MyBase.Init(Token)
         m_TypeArguments = TypeArguments
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="42" endline="46"><![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal Keyword As KS, ByVal TypeArguments As TypeArgumentList)
         MyBase.Init(Identifier, Keyword)
         m_TypeArguments = TypeArguments
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="47" endline="57"><![CDATA[
 
     Shadows Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As IdentifierOrKeywordWithTypeArguments
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New IdentifierOrKeywordWithTypeArguments(NewParent)
         If m_TypeArguments IsNot Nothing Then
             result.Init(Me.Identifier, Me.Keyword, m_TypeArguments.Clone(result))
         Else
             result.Init(Me.Identifier, Me.Keyword, Nothing)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="58" endline="63"><![CDATA[
 
     Shared Function CreateAndParseTo(ByRef result As Expression) As Boolean
 
         Return result.Compiler.Report.ShowMessage(Messages.VBNC99997, result.Location)
 
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="64" endline="71"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="72" endline="79"><![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="80" endline="84"><![CDATA[
 
     ReadOnly Property TypeArguments() As TypeArgumentList
         Get
             Return m_TypeArguments
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="32" endline="34"><![CDATA[
     Overloads Function Equals(ByVal Location As Span) As Boolean
         Return m_Line = Location.m_Line AndAlso m_Column = Location.m_Column AndAlso m_EndColumn = Location.m_EndColumn AndAlso m_FileIndex = Location.m_FileIndex
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="35" endline="43"><![CDATA[
     ''' <summary>
     ''' The line of the location.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public ReadOnly Property Line() As UInteger
         Get
             Return m_Line
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="44" endline="54"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The column of the location.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public ReadOnly Property Column() As Byte
         Get
             Return m_Column
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="55" endline="69"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The file of the location.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public ReadOnly Property File(ByVal Compiler As Compiler) As CodeFile
         Get
             If Compiler Is Nothing Then Return Nothing
             If m_FileIndex = 0 Then Return Nothing
             If m_FileIndex = UShort.MaxValue Then Return Nothing
             If m_FileIndex > Compiler.CommandLine.Files.Count Then Return Nothing
             Return Compiler.CommandLine.Files(m_FileIndex - 1)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="70" endline="75"><![CDATA[
     End Property
 
     ReadOnly Property FileIndex() As UShort
         Get
             Return m_FileIndex
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="76" endline="81"><![CDATA[
     End Property
 
     ReadOnly Property HasFile() As Boolean
         Get
             Return m_FileIndex <> UShort.MaxValue AndAlso m_FileIndex <> 0
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="82" endline="92"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The location expressed as a string that the IDE can understand.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Use another overload")> _
     Overrides Function ToString() As String
         Return ToString(False, Nothing)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="93" endline="96"><![CDATA[
 
     Overloads Function ToString(ByVal Compiler As Compiler) As String
         Return ToString(False, Compiler)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="97" endline="118"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="IncludePath"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function ToString(ByVal IncludePath As Boolean, ByVal Compiler As Compiler) As String
         If m_Line < 0 Then
             Return "(in the commandline)"
         End If
 
         If Not File(Compiler) Is Nothing Then
             If IncludePath Then
                 Return String.Format("{0} ({1},{2})", File(Compiler).FileName, Line.ToString, Column.ToString)
             Else
                 Return String.Format("{0} ({1},{2})", File(Compiler).FileNameToReport, Line.ToString, Column.ToString)
             End If
         Else
             Return String.Format("({0},{1})", Line.ToString, Column.ToString)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="119" endline="123"><![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Return ToString(Nothing)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="124" endline="129"><![CDATA[
     End Property
 
     ReadOnly Property AsString(ByVal Compiler As Compiler) As String
         Get
             Return ToString(Compiler)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="130" endline="140"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The end column of the span.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public ReadOnly Property EndColumn() As Byte
         Get
             Return m_EndColumn + m_Column
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="141" endline="145"><![CDATA[
     End Property
 
     Sub SpanTo(ByVal Location As Span)
         m_EndColumn = Location.m_EndColumn
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="146" endline="152"><![CDATA[
 
     Public Sub New(ByVal FileIndex As UShort, ByVal StartLine As UInteger, ByVal StartColumn As Byte, Optional ByVal EndColumn As Byte = 0)
         m_EndColumn = EndColumn
         m_FileIndex = FileIndex + 1US
         m_Line = StartLine
         m_Column = StartColumn
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="153" endline="157"><![CDATA[
 
     Public Sub New(ByVal FromLocation As Span, ByVal ToLocation As Span)
         Me.New(FromLocation.FileIndex - 1US, FromLocation.Line, FromLocation.Column, ToLocation.Column)
         Helper.Assert(FromLocation.FileIndex = ToLocation.FileIndex)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="24" endline="27"><![CDATA[
     Shared Function IsSomething(ByVal Token As Token) As Boolean
         'Return Token IsNot Nothing AndAlso Token.IsSomething
         Return Token.IsSomething
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="28" endline="31"><![CDATA[
 
     Function IsSomething() As Boolean
         Return m_TokenType <> TokenType.None
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="32" endline="41"><![CDATA[
 
     Public Overrides Function ToString() As String
         If Me.IsIdentifier Then
             Return Me.Identifier
         ElseIf Me.IsKeyword Then
             Return Me.Identifier
         Else
             Return "<Token>"
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="42" endline="48"><![CDATA[
 
     Shared Function CreateIdentifierToken(ByVal Location As Span, ByVal Identifier As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Identifier
         result.m_TokenObject = Identifier
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="49" endline="54"><![CDATA[
 
     Shared Function CreateEndOfCodeToken() As Token
         Dim result As New Token(Span.CommandLineSpan)
         result.m_TokenType = TokenType.EndOfCode
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="55" endline="60"><![CDATA[
 
     Shared Function CreateEndOfLineToken(ByVal Location As Span) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.EndOfLine
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="61" endline="66"><![CDATA[
 
     Shared Function CreateEndOfFileToken(ByVal Location As Span) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.EndOfFile
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="67" endline="73"><![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80"><![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="81" endline="87"><![CDATA[
 
     Shared Function CreateCharToken(ByVal Location As Span, ByVal Value As Char) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.CharLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="88" endline="94"><![CDATA[
 
     Shared Function CreateDecimalToken(ByVal Location As Span, ByVal Value As Decimal) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DecimalLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="95" endline="101"><![CDATA[
 
     Shared Function CreateSingleToken(ByVal Location As Span, ByVal Value As Single) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.SingleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="102" endline="108"><![CDATA[
 
     Shared Function CreateDoubleToken(ByVal Location As Span, ByVal Value As Double) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DoubleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="109" endline="115"><![CDATA[
 
     Shared Function CreateInt16Token(ByVal Location As Span, ByVal Value As Short) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="116" endline="122"><![CDATA[
 
     Shared Function CreateInt32Token(ByVal Location As Span, ByVal Value As Integer) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="123" endline="129"><![CDATA[
 
     Shared Function CreateInt64Token(ByVal Location As Span, ByVal Value As Long) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="130" endline="136"><![CDATA[
 
     Shared Function CreateUInt16Token(ByVal Location As Span, ByVal Value As UShort) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="137" endline="143"><![CDATA[
 
     Shared Function CreateUInt32Token(ByVal Location As Span, ByVal Value As UInteger) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="144" endline="150"><![CDATA[
 
     Shared Function CreateUInt64Token(ByVal Location As Span, ByVal Value As ULong) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="151" endline="157"><![CDATA[
 
     Shared Function CreateStringLiteral(ByVal Location As Span, ByVal Value As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.StringLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="158" endline="164"><![CDATA[
 
     Shared Function CreateSymbolToken(ByVal Location As Span, ByVal Symbol As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Symbol
         result.m_TokenObject = Symbol
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="165" endline="167"><![CDATA[
 
     Sub New(ByVal Span As Span)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="168" endline="177"><![CDATA[
 
     Function IdentiferOrKeywordIdentifier() As String
         If IsKeyword() Then
             Return Identifier
         ElseIf IsIdentifier() Then
             Return Identifier
         Else
             Throw New InternalException()
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="178" endline="181"><![CDATA[
 
     Function IsSpecial() As Boolean
         Return IsKeyword() OrElse IsSymbol()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="182" endline="213"><![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Select Case m_TokenType
                 Case TokenType.CharLiteral
                     Return """" & CharLiteral & """c"
                 Case TokenType.DateLiteral
                     Return "#" & DateLiteral.ToString() & "#"
                 Case TokenType.DecimalLiteral
                     Return DecimalLiteral.ToString
                 Case TokenType.EndOfCode
                     Return "END OF CODE"
                 Case TokenType.EndOfFile
                     Return "END OF FILE"
                 Case TokenType.EndOfLine
                     Return "END OF LINE"
                 Case TokenType.Identifier
                     Return Identifier
                 Case TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                     Return IntegralLiteral.ToString
                 Case TokenType.Keyword
                     Return Keyword.ToString()
                 Case TokenType.SingleLiteral, TokenType.DoubleLiteral
                     Return Me.LiteralValue.ToString
                 Case TokenType.StringLiteral
                     Return """" & Me.StringLiteral & """"
                 Case TokenType.Symbol
                     Return Me.Symbol.ToString
                 Case Else
                     Return "EMPTY TOKEN"
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="214" endline="225"><![CDATA[
     End Property
 
     ReadOnly Property AsSpecial() As KS
         Get
             If IsKeyword() Then
                 Return Keyword
             ElseIf IsSymbol() Then
                 Return Symbol
             Else
                 Return KS.None
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="226" endline="230"><![CDATA[
     End Property
 
     Function IsKeyword() As Boolean
         Return m_TokenType = TokenType.Keyword
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="231" endline="234"><![CDATA[
 
     Function IsSymbol() As Boolean
         Return m_TokenType = TokenType.Symbol
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="235" endline="239"><![CDATA[
 
     ReadOnly Property Symbol() As KS
         Get
             Return CType(m_TokenObject, KS)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="240" endline="245"><![CDATA[
     End Property
 
     ReadOnly Property Keyword() As KS
         Get
             Return CType(m_TokenObject, KS)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="246" endline="250"><![CDATA[
     End Property
 
     Function IsIdentifierOrKeyword() As Boolean
         Return IsIdentifier() OrElse IsKeyword()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="251" endline="254"><![CDATA[
 
     Function IsIdentifier() As Boolean
         Return m_TokenType = TokenType.Identifier
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="255" endline="259"><![CDATA[
 
     ReadOnly Property LiteralValue() As Object
         Get
             Return m_TokenObject
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="260" endline="269"><![CDATA[
     End Property
 
     Function IsLiteral() As Boolean
         Select Case m_TokenType
             Case TokenType.DateLiteral, TokenType.CharLiteral, TokenType.DecimalLiteral, TokenType.DoubleLiteral, TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.SingleLiteral, TokenType.StringLiteral, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="270" endline="274"><![CDATA[
 
     ReadOnly Property IntegralLiteral() As ULong
         Get
             Return CULng(m_TokenObject)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="275" endline="279"><![CDATA[
     End Property
 
     Function IsDateLiteral() As Boolean
         Return m_TokenType = TokenType.DateLiteral
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="280" endline="288"><![CDATA[
 
     Function IsIntegerLiteral() As Boolean
         Select Case m_TokenType
             Case TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="289" endline="292"><![CDATA[
 
     Function IsCharLiteral() As Boolean
         Return m_TokenType = TokenType.CharLiteral
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="293" endline="297"><![CDATA[
 
     ReadOnly Property CharLiteral() As Char
         Get
             Return DirectCast(m_TokenObject, Char)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="298" endline="302"><![CDATA[
     End Property
 
     Function IsStringLiteral() As Boolean
         Return m_TokenType = TokenType.StringLiteral
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="303" endline="307"><![CDATA[
 
     ReadOnly Property StringLiteral() As String
         Get
             Return DirectCast(m_TokenObject, String)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="308" endline="313"><![CDATA[
     End Property
 
     ReadOnly Property DateLiteral() As Date
         Get
             Return DirectCast(m_TokenObject, Date)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="314" endline="319"><![CDATA[
     End Property
 
     ReadOnly Property DecimalLiteral() As Decimal
         Get
             Return DirectCast(m_TokenObject, Decimal)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="320" endline="324"><![CDATA[
     End Property
 
     Function IsDecimalLiteral() As Boolean
         Return m_TokenType = TokenType.DecimalLiteral
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="325" endline="335"><![CDATA[
 
     ReadOnly Property Identifier() As String
         Get
             If IsKeyword() Then
                 Return Enums.strSpecial(Keyword)
             ElseIf IsIdentifier() Then
                 Return DirectCast(m_TokenObject, String)
             Else
                 Return Nothing
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="336" endline="350"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Compares this token to any of the specified tokens. 
     ''' Returns true if any token matches.
     ''' </summary>
     ''' <param name="AnySpecial"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overloads Function Equals(ByVal AnySpecial() As KS) As Boolean
         For i As Integer = 0 To VB.UBound(AnySpecial)
             If Equals(AnySpecial(i)) = True Then Return True
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="351" endline="354"><![CDATA[
 
     Public Overloads Function Equals(ByVal AnySpecial As ModifierMasks) As Boolean
         Return IsKeyword() AndAlso Modifiers.IsKS(Keyword, AnySpecial)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="355" endline="358"><![CDATA[
 
     Public Overloads Function Equals(ByVal a As KS, ByVal b As KS) As Boolean
         Return Equals(a) OrElse Equals(b)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="359" endline="362"><![CDATA[
 
     Public Overloads Function Equals(ByVal a As KS, ByVal b As KS, ByVal c As KS) As Boolean
         Return Equals(a) OrElse Equals(b) OrElse Equals(c)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="363" endline="366"><![CDATA[
 
     Public Overloads Function Equals(ByVal a As KS, ByVal b As KS, ByVal c As KS, ByVal d As KS) As Boolean
         Return Equals(a) OrElse Equals(b) OrElse Equals(c) OrElse Equals(d)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="367" endline="370"><![CDATA[
 
     Public Overloads Function Equals(ByVal a As KS, ByVal b As KS, ByVal c As KS, ByVal d As KS, ByVal e As KS) As Boolean
         Return Equals(a) OrElse Equals(b) OrElse Equals(c) OrElse Equals(d) OrElse Equals(e)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="371" endline="374"><![CDATA[
 
     Public Overloads Function Equals(ByVal a As KS, ByVal b As KS, ByVal c As KS, ByVal d As KS, ByVal e As KS, ByVal f As KS) As Boolean
         Return Equals(a) OrElse Equals(b) OrElse Equals(c) OrElse Equals(d) OrElse Equals(e) OrElse Equals(f)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="375" endline="378"><![CDATA[
 
     Public Overloads Function Equals(ByVal a As KS, ByVal b As KS, ByVal c As KS, ByVal d As KS, ByVal e As KS, ByVal f As KS, ByVal g As KS) As Boolean
         Return Equals(a) OrElse Equals(b) OrElse Equals(c) OrElse Equals(d) OrElse Equals(e) OrElse Equals(f) OrElse Equals(g)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="379" endline="382"><![CDATA[
 
     Public Overloads Function Equals(ByVal a As KS, ByVal b As KS, ByVal c As KS, ByVal d As KS, ByVal e As KS, ByVal f As KS, ByVal g As KS, ByVal h As KS) As Boolean
         Return Equals(a) OrElse Equals(b) OrElse Equals(c) OrElse Equals(d) OrElse Equals(e) OrElse Equals(f) OrElse Equals(g) OrElse Equals(h)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="383" endline="390"><![CDATA[
 
     Public Overloads Function Equals(ByVal Special As KS) As Boolean
         If m_TokenType = TokenType.Keyword OrElse m_TokenType = TokenType.Symbol Then
             Return CInt(m_TokenObject) = CInt(Special)
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="391" endline="401"><![CDATA[
 
     Shared Function IsKeyword(ByVal str As Char(), ByVal length As Integer, ByRef Keyword As KS) As Boolean
         Dim special As KS
         special = Enums.GetKS(str, length)
         If special <> KS.None Then
             Keyword = special
             Return True
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="402" endline="405"><![CDATA[
 
     Public Overloads Function Equals(ByVal Identifier As String) As Boolean
         Return Me.IsIdentifier AndAlso Helper.CompareName(Me.Identifier, Identifier)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="406" endline="413"><![CDATA[
 
     Public Overrides Function Equals(ByVal obj As Object) As Boolean
         If TypeOf obj Is Token Then
             Return Equals(DirectCast(obj, Token))
         Else
             Throw New InternalException()
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="414" endline="427"><![CDATA[
 
     Overloads Function Equals(ByVal obj As Token) As Boolean
         If Me.IsIdentifier AndAlso obj.IsIdentifier Then
             Return Me.Equals(obj.Identifier)
         ElseIf Me.IsLiteral AndAlso obj.IsLiteral Then
             Return Me.LiteralValue.Equals(obj.LiteralValue)
         ElseIf Me.IsKeyword AndAlso obj.IsKeyword Then
             Return Me.Keyword = obj.Keyword
         ElseIf Me.IsSymbol AndAlso obj.IsSymbol Then
             Return Me.Symbol = obj.Symbol
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="428" endline="432"><![CDATA[
 
     ReadOnly Property IsEndOfCode() As Boolean
         Get
             Return m_TokenType = TokenType.EndOfCode
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="433" endline="438"><![CDATA[
     End Property
 
     ReadOnly Property IsEndOfFile() As Boolean
         Get
             Return m_TokenType = TokenType.EndOfFile OrElse m_TokenType = TokenType.EndOfCode
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="439" endline="444"><![CDATA[
     End Property
 
     ReadOnly Property IsEndOfLine() As Boolean
         Get
             Return m_TokenType = TokenType.EndOfLine OrElse m_TokenType = TokenType.EndOfFile OrElse m_TokenType = TokenType.EndOfCode
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="445" endline="450"><![CDATA[
     End Property
 
     ReadOnly Property IsEndOfLineOnly() As Boolean
         Get
             Return m_TokenType = TokenType.EndOfLine
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="451" endline="455"><![CDATA[
     End Property
 
     Function IsEndOfStatement() As Boolean
         Return IsEndOfLineOnly OrElse Equals(KS.Colon)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="456" endline="459"><![CDATA[
 
     Shared Operator =(ByVal Token As Token, ByVal Special As KS) As Boolean
         Return Token.Equals(Special)
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="460" endline="463"><![CDATA[
 
     Shared Operator <>(ByVal Token As Token, ByVal Special As KS) As Boolean
         Return Not Token.Equals(Special)
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="464" endline="468"><![CDATA[
 
     ReadOnly Property FriendlyString() As String
         Get
             Return ToString()
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="469" endline="475"><![CDATA[
     End Property
 
     ReadOnly Property SpecialString() As String
         Get
             If TypeOf m_TokenObject Is KS Then Return DirectCast(m_TokenObject, KS).ToString()
             Return "not a symbol"
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="63" endline="65"><![CDATA[
         Get
             Return m_GroupedClasses
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="66" endline="68"><![CDATA[
         Set(ByVal value As Generic.List(Of MyGroupData))
             m_GroupedClasses = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="69" endline="74"><![CDATA[
     End Property
 
     ReadOnly Property Members() As MemberDeclarations
         Get
             Return m_Members
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="75" endline="80"><![CDATA[
     End Property
 
     ReadOnly Property TypeDeclarations() As TypeDeclaration()
         Get
             Return m_TypeDeclarations
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="81" endline="85"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As Compiler)
         MyBase.New(Parent)
     Private m_Attributes As New Attributes(Me)
 
     ''' <summary>
     ''' The name of the assembly. 
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Name As String
 
     ''' <summary>
     ''' All the non-nested types in this assembly.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Members As New MemberDeclarations(Me)
 
     ''' <summary>
     ''' All the types as an array of type declarations.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TypeDeclarations() As TypeDeclaration
 
     Private m_GroupedClasses As Generic.List(Of MyGroupData)
 
     Property GroupedClasses() As Generic.List(Of MyGroupData)
         Get
             Return m_GroupedClasses
         End Get
         Set(ByVal value As Generic.List(Of MyGroupData))
             m_GroupedClasses = value
         End Set
     End Property
 
     ReadOnly Property Members() As MemberDeclarations
         Get
             Return m_Members
         End Get
     End Property
 
     ReadOnly Property TypeDeclarations() As TypeDeclaration()
         Get
             Return m_TypeDeclarations
         End Get
     End Property
 
     Sub New(ByVal Parent As Compiler)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="86" endline="96"><![CDATA[
 
     Sub Init(ByVal Attributes As Attributes)
         If m_Attributes Is Nothing Then
             m_Attributes = Attributes
         Else
             m_Attributes.AddRange(Attributes)
         End If
         m_TypeDeclarations = m_Members.GetSpecificMembers(Of TypeDeclaration).ToArray
 
         Helper.Assert(m_Members.Count = m_TypeDeclarations.Length)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="97" endline="108"><![CDATA[
 
     Private Function DefineType(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineType AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineType(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="109" endline="120"><![CDATA[
 
     Private Function DefineTypeHierarchy(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineTypeHierarchy AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineTypeHierarchy(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="121" endline="144"><![CDATA[
 
     Private Function DefineMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Type.CecilType IsNot Nothing)
 
         For Each i As IMember In Type.Members.GetSpecificMembers(Of IMember)()
             If TypeOf i Is TypeDeclaration Then
                 'If TypeOf i Is DelegateDeclaration = False Then
                 result = DefineMembers(DirectCast(i, TypeDeclaration)) AndAlso result
                 vbnc.Helper.Assert(result = (Report.Errors = 0))
                 'Else
                 'Skip the delagete declarations, they are already defined.
                 'End If
             ElseIf TypeOf i Is IDefinableMember Then
                 result = DirectCast(i, IDefinableMember).DefineMember AndAlso result
                 vbnc.Helper.Assert(result = (Report.Errors = 0))
             Else
                 Throw New InternalException("Type " & CObj(i).GetType.ToString & " is not a definable object")
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="145" endline="156"><![CDATA[
 
     Friend Function Emit(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.GenerateCode(Nothing) AndAlso result
         result = Type.Members.GenerateCode(Nothing) AndAlso result
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = Emit(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="157" endline="186"><![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeDeclarations.Length - 1
             Dim type As TypeDeclaration = m_TypeDeclarations(i)
 
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Green
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveCode " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = type.ResolveCode(Info) AndAlso result
             Compiler.VerifyConsistency(result, type.Location)
         Next
 
         result = m_Attributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="187" endline="204"><![CDATA[
 
     Function CreateImplicitTypes() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitTypes " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitTypes = TryCast(Type, IHasImplicitTypes)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitTypes AndAlso result
 
             result = CreateImplicitTypes(Type) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="205" endline="218"><![CDATA[
 
     Private Function CreateImplicitTypes(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitTypes(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitTypes In Type.Members.GetSpecificMembers(Of IHasImplicitTypes)()
             result = Member.CreateImplicitTypes() AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="219" endline="226"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For i As Integer = 0 To m_TypeDeclarations.Length - 1
             m_TypeDeclarations(i).Initialize(Me)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="227" endline="243"><![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveTypeReferences " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveTypeReferences(type) AndAlso result
         Next
 
         result = m_Attributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="244" endline="263"><![CDATA[
 
     Private Overloads Function ResolveTypeReferences(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         For Each Member As ParsedObject In Type.Members
             Dim NestedType As TypeDeclaration = TryCast(Member, TypeDeclaration)
             If NestedType IsNot Nothing Then
                 result = ResolveTypeReferences(NestedType) AndAlso result
             Else
                 result = Member.ResolveTypeReferences() AndAlso result
             End If
             If result = False Then Return result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="264" endline="281"><![CDATA[
 
     Function CreateImplicitMembers() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitMembers " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitMembers = TryCast(Type, IHasImplicitMembers)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitMembers AndAlso result
 
             result = CreateImplicitMembers(Type) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="282" endline="295"><![CDATA[
 
     Private Function CreateImplicitMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitMembers(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitMembers In Type.Members.GetSpecificMembers(Of IHasImplicitMembers)()
             result = Member.CreateImplicitMembers() AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="296" endline="310"><![CDATA[
 
     Function ResolveMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="311" endline="330"><![CDATA[
 
     Private Shared Function ResolveMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each n As IBaseObject In Type.Members.GetSpecificMembers(Of IBaseObject)()
             Dim nType As TypeDeclaration = TryCast(n, TypeDeclaration)
             Dim nMember As INonTypeMember = TryCast(n, INonTypeMember)
 
             If nType IsNot Nothing Then
                 result = ResolveMembers(nType) AndAlso result
             ElseIf nMember IsNot Nothing Then
                 'Resolve all non-type members.
                 result = nMember.ResolveMember(ResolveInfo.Default(Type.Compiler)) AndAlso result
             Else
                 Helper.Stop() '?
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="331" endline="353"><![CDATA[
 
 
     ''' <summary>
     ''' - Types are defined with the reflection.emit namespace. 
     ''' - Only classes, modules, structures, interfaces, enums, delegates and eventnos (not a type by itself, bu an event might declare a new delegate). They are only defined, nothing else.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineType()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypes() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypes " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineType(type) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="354" endline="376"><![CDATA[
 
     ''' <summary>
     ''' - Base classes for classes, modules, structures, enums, interfaces and delegates are set.
     ''' - Implemented interfaces for classes are set.
     ''' - Type parameters for classes and structures are set.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineTypeHierarchy()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypeHierarchy " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineTypeHierarchy(type) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="377" endline="406"><![CDATA[
 
     ''' <summary>
     ''' - All the type's members are defined (methods, constructors, properties, fields, events, operators).
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Green
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = DefineMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="407" endline="416"><![CDATA[
 
     Function EmitAttributes() As Boolean
         Dim result As Boolean = True
 
         If m_Attributes IsNot Nothing Then
             result = m_Attributes.GenerateCode(Nothing) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="417" endline="453"><![CDATA[
 
     ''' <summary>
     ''' - All code is emitted for fields with initializers.
     ''' - All the code is emitted for each and every method, constructor, operator and property.
     ''' - Classes, modules, structures, methods, constructors, properties, events, operators should implement IEmittable.Emit(Info as EmitInfo)
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Emit() As Boolean
         Dim result As Boolean = True
 
         result = EmitAttributes() AndAlso result
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Yellow
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Emit " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = Emit(type) AndAlso result
         Next
 
         SetFileVersion()
         SetAdditionalAttributes()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="454" endline="463"><![CDATA[
 
     Sub SetAdditionalAttributes()
         Dim cab As Mono.Cecil.CustomAttribute
 
         If Compiler.CommandLine.Define.IsDefined("DEBUG") Then
             cab = New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Diagnostics_DebuggableAttribute__ctor_DebuggingModes))
             cab.ConstructorArguments.Add(New CustomAttributeArgument(Compiler.TypeCache.System_Diagnostics_DebuggableAttribute, System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations Or Diagnostics.DebuggableAttribute.DebuggingModes.Default))
             Me.Compiler.AssemblyBuilderCecil.CustomAttributes.Add(cab)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="464" endline="727"><![CDATA[
 
     Sub SetFileVersion()
         Dim product As String = String.Empty
         Dim productversion As String = String.Empty
         Dim company As String = String.Empty
         Dim copyright As String = String.Empty
         Dim trademark As String = String.Empty
 
         Dim att As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim custom_attributes As Mono.Collections.Generic.Collection(Of CustomAttribute) = Me.Compiler.AssemblyBuilderCecil.CustomAttributes
 
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyProductAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then product = CecilHelper.GetAttributeCtorString(att(0), 0)
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyVersionAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then productversion = CecilHelper.GetAttributeCtorString(att(0), 0)
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyCompanyAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then company = CecilHelper.GetAttributeCtorString(att(0), 0)
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyCopyrightAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then copyright = CecilHelper.GetAttributeCtorString(att(0), 0)
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyTrademarkAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then trademark = CecilHelper.GetAttributeCtorString(att(0), 0)
 
         'Dim rdt As New Mono.Cecil.PE.ResourceDirectoryTable()
         'Dim r1 As New Mono.Cecil.PE.ResourceDirectoryEntry(16)
         'Dim r2 As New Mono.Cecil.PE.ResourceDirectoryEntry(1)
         'Dim r3 As New Mono.Cecil.PE.ResourceDirectoryEntry(0)
         'Dim data As New Mono.Cecil.PE.ResourceDataEntry()
 
         'Dim rsrc As Mono.Cecil.PE.Section = Nothing
         'If Compiler.AssemblyBuilderCecil.MainModule.Image Is Nothing Then
         '    Compiler.AssemblyBuilderCecil.MainModule.Image = New Mono.Cecil.PE.Image()
         '    Compiler.AssemblyBuilderCecil.MainModule.Image.Sections = New Mono.Cecil.PE.Section() {}
         'End If
         'rsrc = Compiler.AssemblyBuilderCecil.MainModule.Image.GetSection(".rsrc")
         'If rsrc Is Nothing Then
         '    rsrc = New Mono.Cecil.PE.Section()
         '    rsrc.Name = ".rsrc"
         '    Dim sections(Me.Compiler.AssemblyBuilderCecil.MainModule.Image.Sections.Length) As Mono.Cecil.PE.Section
         '    For i As Integer = 0 To sections.Length - 2
         '        sections(i) = Compiler.AssemblyBuilderCecil.MainModule.Image.Sections(i)
         '    Next
         '    sections(sections.Length - 1) = rsrc
         '    Me.Compiler.AssemblyBuilderCecil.MainModule.Image.Sections = sections
         'End If
         'Me.Compiler.AssemblyBuilderCecil.MainModule.Image.ResourceDirectoryRoot = New Mono.Cecil.PE.ResourceDirectoryTable()
 
         'Me.Compiler.AssemblyBuilderCecil.MainModule.Image.ResourceDirectoryRoot.Entries.Add(r1)
         'rdt = New Mono.Cecil.Binary.ResourceDirectoryTable()
         'rdt.Entries.Add(r2)
         'r1.Child = rdt
 
         'rdt = New Mono.Cecil.Binary.ResourceDirectoryTable()
         'rdt.Entries.Add(r3)
         'r2.Child = rdt
 
         'r3.Child = data
         'data.Size = 0
         'data.ResourceData = New Byte() {}
 
         Dim win32versionresources As Byte()
         Using ms As New IO.MemoryStream()
             Using w As New IO.BinaryWriter(ms, System.Text.Encoding.Unicode)
                 Dim file_flags_mask As Integer = 63
                 Dim file_flags As Integer = 0
                 Dim file_os As Integer = 4 '/* VOS_WIN32 */
                 Dim file_type As Integer = 2
                 Dim file_subtype As Integer = 0
                 Dim file_date As Long = 0
                 Dim file_lang As Integer = 0
                 Dim file_codepage As Integer = 1200
                 Dim properties As New Generic.Dictionary(Of String, String)
 
                 Dim file_version As Long
                 Dim product_version As Long
 
                 Dim WellKnownProperties As String() = New String() {"Assembly Version", "FileDescription", "FileVersion", "InternalName", "OriginalFilename", "ProductVersion"}
 
                 For i As Integer = 0 To WellKnownProperties.Length - 1
                     properties.Add(WellKnownProperties(i), WellKnownProperties(i) & " ")
                 Next
 
                 If product <> String.Empty Then properties("ProductName") = product
                 If productversion <> String.Empty Then
                     properties("ProductVersion") = productversion
                     properties("FileVersion") = productversion
                 End If
                 If company <> String.Empty Then properties("Company") = company
                 If copyright <> String.Empty Then properties("LegalCopyright") = copyright
                 If trademark <> String.Empty Then properties("LegalTrademark") = trademark
 
                 'VS_VERSIONINFO
                 w.Write(CShort(0))
                 w.Write(CShort(&H34))
                 w.Write(CShort(0))
                 w.Write("VS_VERSION_INFO".ToCharArray())
                 w.Write(CShort(0))
                 emit_padding(w)
 
                 '// VS_FIXEDFILEINFO
                 w.Write(&HFEEF04BDUI)
                 w.Write(CInt(1 << 16))
                 w.Write(CInt(file_version >> 32)) 'TODO
                 w.Write(CInt(((file_version And &HFFFFFFFF)))) 'TODO
 
                 w.Write(CInt(product_version >> 32))
                 w.Write(CInt(product_version And &HFFFFFFFF))
                 w.Write(CInt(file_flags_mask))
                 w.Write(CInt(file_flags))
                 w.Write(CInt(file_os))
                 w.Write(CInt(file_type))
                 w.Write(CInt(file_subtype))
                 w.Write(CInt((file_date >> 32)))
                 w.Write(CInt((file_date And &HFFFFFFFF)))
 
                 emit_padding(w)
 
                 '// VarFileInfo
                 Dim var_file_info_pos As Long = ms.Position
                 w.Write(CShort(0))
                 w.Write(CShort(0))
                 w.Write(CShort(1))
                 w.Write("VarFileInfo".ToCharArray())
                 w.Write(CShort(0))
 
                 If ((ms.Position Mod 4) <> 0) Then
                     w.Write(CShort(0))
                 End If
 
                 '// Var
                 Dim var_pos As Long = ms.Position
                 w.Write(CShort(0))
                 w.Write(CShort(4))
                 w.Write(CShort(0))
                 w.Write("Translation".ToCharArray())
                 w.Write(CShort(0))
 
                 If ((ms.Position Mod 4) <> 0) Then
                     w.Write(CShort(0))
                 End If
 
                 w.Write(CShort(file_lang))
                 w.Write(CShort(file_codepage))
 
                 patch_length(w, var_pos)
 
                 patch_length(w, var_file_info_pos)
 
                 '// StringFileInfo
                 Dim string_file_info_pos As Long = ms.Position
                 w.Write(CShort(0))
                 w.Write(CShort(0))
                 w.Write(CShort(1))
                 w.Write("StringFileInfo".ToCharArray())
 
                 emit_padding(w)
 
                 '// StringTable
                 Dim string_table_pos As Long = ms.Position
                 w.Write(CShort(0))
                 w.Write(CShort(0))
                 w.Write(CShort(1))
                 w.Write(String.Format("{0
 
                 emit_padding(w)
 
                 '// Strings
                 For Each key As String In properties.Keys
                     Dim value As String = properties(key)
 
                     Dim string_pos As Long = ms.Position
                     w.Write(CShort(0))
                     w.Write(CShort((value.ToCharArray().Length + 1)))
                     w.Write(CShort(1))
                     w.Write(key.ToCharArray())
                     w.Write(CShort(0))
 
                     emit_padding(w)
 
                     w.Write(value.ToCharArray())
                     w.Write(CShort(0))
 
                     emit_padding(w)
 
                     patch_length(w, string_pos)
                 Next
 
                 patch_length(w, string_table_pos)
 
                 patch_length(w, string_file_info_pos)
 
                 patch_length(w, 0)
                 win32versionresources = ms.ToArray()
             End Using
         End Using
 
 
         Using ms As New IO.MemoryStream()
             Using w As New IO.BinaryWriter(ms, System.Text.Encoding.Unicode)
                 ' IMAGE_RESOURCE_DIRECTORY
                 w.Write(0UI) 'characteristics
                 w.Write(0UI) 'timedatestamp
                 w.Write(0US) 'majorversion
                 w.Write(0US) 'minorversion
                 w.Write(0US) 'NumberOfNamedEntries
                 w.Write(1US) 'NumberOfIdEntries
 
                 '16 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY_ENTRY
                 w.Write(16UI) 'name
                 w.Write(&H20UI + &H80000000UI) 'dataoffset
                 w.Write(0UI) 'codepage
                 w.Write(0UI) 'reserved
 
                 ' 16 bytes, total 32 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY
                 w.Write(0UI) 'characteristics
                 w.Write(0UI) 'timedatestamp
                 w.Write(0US) 'majorversion
                 w.Write(0US) 'minorversion
                 w.Write(0US) 'NumberOfNamedEntries
                 w.Write(1US) 'NumberOfIdEntries
 
                 ' 16 bytes, total 48 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY_ENTRY
                 w.Write(1UI) 'name
                 w.Write(&H40UI + &H80000000UI) 'dataoffset
                 w.Write(0UI) 'codepage
                 w.Write(0UI) 'reserved
 
                 ' 16 bytes, total 64 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY
                 w.Write(0UI) 'characteristics
                 w.Write(0UI) 'timedatestamp
                 w.Write(0US) 'majorversion
                 w.Write(0US) 'minorversion
                 w.Write(0US) 'NumberOfNamedEntries
                 w.Write(1US) 'NumberOfIdEntries
 
                 ' 16 bytes, total 80 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY_ENTRY
                 w.Write(0UI) 'name
                 w.Write(&H60UI) 'dataoffset
                 w.Write(0UI) 'codepage
                 w.Write(0UI) 'reserved
 
                 ' 16 bytes, total 96 bytes
 
                 ' IMAGE_RESOURCE_DATA_ENTRY
                 w.Write(&H70UI) 'offsettodata
                 w.Write(CUInt(win32versionresources.Length)) 'size
                 w.Write(0UI) 'codepage
                 w.Write(0UI) 'reserved
 
                 w.Write(win32versionresources)
 
                 Compiler.ModuleBuilderCecil.Win32resources = ms.ToArray()
             End Using
         End Using
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="728" endline="736"><![CDATA[
 
     Private Sub patch_length(ByVal w As IO.BinaryWriter, ByVal len_pos As Long)
         Dim ms As IO.Stream = w.BaseStream
 
         Dim pos As Long = ms.Position
         ms.Position = len_pos
         w.Write(CShort(pos - len_pos))
         ms.Position = pos
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="737" endline="744"><![CDATA[
 
     Private Sub emit_padding(ByVal w As IO.BinaryWriter)
         Dim ms As IO.Stream = w.BaseStream
 
         If ((ms.Position Mod 4) <> 0) Then
             w.Write(CShort(0))
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="745" endline="780"><![CDATA[
 
     Public Function SetCecilName(ByVal Name As Mono.Cecil.AssemblyNameDefinition) As Boolean
         Dim result As Boolean = True
         Dim keyfile As String = Nothing
         Dim keyname As String = Nothing
         Dim delaysign As Boolean = False
 
         Name.Name = IO.Path.GetFileNameWithoutExtension(Compiler.OutFileName)
 
         If Compiler.CommandLine.KeyFile <> String.Empty Then
             keyfile = Compiler.CommandLine.KeyFile
         End If
 
         For Each attri As Attribute In Me.Attributes
             Dim attribType As Mono.Cecil.TypeReference
             attribType = attri.ResolvedType
 
             If Helper.CompareType(attribType, Compiler.TypeCache.System_Reflection_AssemblyVersionAttribute) Then
                 result = SetVersion(Name, attri, attri.Location) AndAlso result
             ElseIf Helper.CompareType(attribType, Compiler.TypeCache.System_Reflection_AssemblyKeyFileAttribute) Then
                 If keyfile = String.Empty Then keyfile = TryCast(attri.Arguments()(0), String)
             ElseIf Helper.CompareType(attribType, Compiler.TypeCache.System_Reflection_AssemblyKeyNameAttribute) Then
                 keyname = TryCast(attri.Arguments()(0), String)
             ElseIf Helper.CompareType(attribType, Compiler.TypeCache.System_Reflection_AssemblyDelaySignAttribute) Then
                 delaysign = CBool(attri.Arguments()(0))
             End If
         Next
 
         If keyfile <> String.Empty Then
             If SignWithKeyFile(Name, keyfile, delaysign) = False Then
                 Return result
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="781" endline="818"><![CDATA[
 
     Private Function SignWithKeyFile(ByVal result As Mono.Cecil.AssemblyNameDefinition, ByVal KeyFile As String, ByVal DelaySign As Boolean) As Boolean
         Dim filename As String
 
         filename = IO.Path.GetFullPath(KeyFile)
 
 #If DEBUG Then
         Compiler.Report.WriteLine("Signing with file
 #End If
 
         If IO.File.Exists(filename) = False Then
             Helper.AddError(Me, "Can't find keyfile
             Return False
         End If
 
         Using stream As New IO.FileStream(filename, IO.FileMode.Open, IO.FileAccess.Read)
             Dim snkeypair() As Byte
             ReDim snkeypair(CInt(stream.Length - 1))
             stream.Read(snkeypair, 0, snkeypair.Length)
 
             If Helper.IsOnMono Then
                 SignWithKeyFileMono(result, filename, DelaySign, snkeypair)
             Else
                 If DelaySign Then
                     result.PublicKey = snkeypair
                 Else
                     'FIXME
                     'result.KeyPair = New StrongNameKeyPair(snkeypair)
                     result.PublicKey = snkeypair
                 End If
             End If
 
         End Using
 
         Compiler.ModuleBuilderCecil.Attributes = Compiler.ModuleBuilderCecil.Attributes Or ModuleAttributes.StrongNameSigned
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="819" endline="871"><![CDATA[
 
     Private Sub SignWithKeyFileMono(ByVal result As Mono.Cecil.AssemblyNameDefinition, ByVal KeyFile As String, ByVal DelaySign As Boolean, ByVal blob As Byte())
         Dim CryptoConvert As Type
         Dim FromCapiKeyBlob As System.Reflection.MethodInfo
         Dim ToCapiPublicKeyBlob As System.Reflection.MethodInfo
         Dim FromCapiPrivateKeyBlob As System.Reflection.MethodInfo
         Dim RSA As Type
         Dim mscorlib As System.Reflection.Assembly = GetType(Integer).Assembly
 
 #If DEBUG Then
         Compiler.Report.WriteLine("Signing on Mono")
 #End If
 
         Try
             RSA = mscorlib.GetType("System.Security.Cryptography.RSA")
             CryptoConvert = mscorlib.GetType("Mono.Security.Cryptography.CryptoConvert")
             FromCapiKeyBlob = CryptoConvert.GetMethod("FromCapiKeyBlob", System.Reflection.BindingFlags.Public Or System.Reflection.BindingFlags.Static Or System.Reflection.BindingFlags.ExactBinding, Nothing, New Type() {GetType(Byte())}, Nothing)
             ToCapiPublicKeyBlob = CryptoConvert.GetMethod("ToCapiPublicKeyBlob", System.Reflection.BindingFlags.Static Or System.Reflection.BindingFlags.Public Or System.Reflection.BindingFlags.ExactBinding, Nothing, New Type() {RSA}, Nothing)
             FromCapiPrivateKeyBlob = CryptoConvert.GetMethod("FromCapiPrivateKeyBlob", System.Reflection.BindingFlags.Static Or System.Reflection.BindingFlags.Public Or System.Reflection.BindingFlags.ExactBinding, Nothing, New Type() {GetType(Byte())}, Nothing)
 
             If DelaySign Then
                 If blob.Length = 16 Then
                     result.PublicKey = blob
 #If DEBUG Then
                     Compiler.Report.WriteLine("Delay signed 1")
 #End If
                 Else
                     Dim publickey() As Byte
                     Dim fromCapiResult As Object
                     Dim publicKeyHeader As Byte() = New Byte() {&H0, &H24, &H0, &H0, &H4, &H80, &H0, &H0, &H94, &H0, &H0, &H0}
                     Dim encodedPublicKey() As Byte
 
                     fromCapiResult = FromCapiKeyBlob.Invoke(Nothing, New Object() {blob})
                     publickey = CType(ToCapiPublicKeyBlob.Invoke(Nothing, New Object() {fromCapiResult}), Byte())
 
                     ReDim encodedPublicKey(11 + publickey.Length)
                     Buffer.BlockCopy(publicKeyHeader, 0, encodedPublicKey, 0, 12)
                     Buffer.BlockCopy(publickey, 0, encodedPublicKey, 12, publickey.Length)
                     result.PublicKey = encodedPublicKey
 #If DEBUG Then
                     Compiler.Report.WriteLine("Delay signed 2")
 #End If
                 End If
             Else
                 FromCapiPrivateKeyBlob.Invoke(Nothing, New Object() {blob})
                 'FIXME
                 'result.KeyPair = New StrongNameKeyPair(blob)
                 result.PublicKey = blob
             End If
         Catch ex As Exception
             Helper.AddError(Me, "Invalid key file
         End Try
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="872" endline="926"><![CDATA[
 
     Private Function SetVersion(ByVal Name As Mono.Cecil.AssemblyNameDefinition, ByVal Attribute As Attribute, ByVal Location As Span) As Boolean
         Dim result As Version
         Dim version As String = ""
 
         If Attribute.Arguments IsNot Nothing AndAlso Attribute.Arguments.Length = 1 Then
             version = TryCast(Attribute.Arguments()(0), String)
         Else
             Return ShowInvalidVersionMessage(version, Location)
         End If
 
         Try
             Dim parts() As String
             Dim major, minor, build, revision As UShort
             parts = version.Split("."c)
 
             If parts.Length > 4 Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If Not UShort.TryParse(parts(0), major) Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If Not UShort.TryParse(parts(1), minor) Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If parts.Length < 3 Then
                 'Use 0
             ElseIf parts(2) = "*" Then
                 build = CUShort((Date.Now - New Date(2000, 1, 1)).TotalDays)
                 revision = CUShort((Date.Now.Hour * 3600 + Date.Now.Minute * 60 + Date.Now.Second) / 2)
             ElseIf Not UShort.TryParse(parts(2), build) Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If parts.Length < 4 Then
                 'Use 0
             ElseIf parts.Length > 3 Then
                 If parts(3) = "*" Then
                     revision = CUShort((Date.Now.Hour * 3600 + Date.Now.Minute * 60 + Date.Now.Second) / 2)
                 ElseIf Not UShort.TryParse(parts(3), revision) Then
                     Return ShowInvalidVersionMessage(version, Location)
                 End If
             End If
 
             result = New Version(major, minor, build, revision)
         Catch ex As Exception
             Return ShowInvalidVersionMessage(version, Location)
         End Try
 
         Name.Version = result
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="927" endline="931"><![CDATA[
 
     Private Function ShowInvalidVersionMessage(ByVal Version As String, ByVal Location As Span) As Boolean
         Compiler.Report.ShowMessage(Messages.VBNC30129, Location, "System.Reflection.AssemblyVersionAttribute", Version)
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="932" endline="957"><![CDATA[
 
     ''' <summary>
     ''' Checks whether the specified Type is defined in the current compiling assembly
     ''' </summary>
     ''' <param name="Type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedHere(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Helper.Assert(Type IsNot Nothing)
         If TypeOf Type Is Mono.Cecil.ArrayType Then
             Return IsDefinedHere(DirectCast(Type, Mono.Cecil.ArrayType).ElementType)
         ElseIf TypeOf Type Is Mono.Cecil.GenericParameter Then
             Dim gp As Mono.Cecil.GenericParameter = DirectCast(Type, Mono.Cecil.GenericParameter)
             If TypeOf gp.Owner Is Mono.Cecil.TypeDefinition Then
                 Return IsDefinedHere(DirectCast(gp.Owner, Mono.Cecil.TypeDefinition))
             ElseIf TypeOf gp.Owner Is Mono.Cecil.MethodDefinition Then
                 Return IsDefinedHere(DirectCast(gp.Owner, Mono.Cecil.MethodDefinition))
             Else
                 Throw New NotImplementedException
             End If
         ElseIf TypeOf Type Is ByReferenceType Then
             Dim tR As ByReferenceType = DirectCast(Type, ByReferenceType)
             Return IsDefinedHere(tR.ElementType)
         End If
         Return Type.Module.Assembly Is Compiler.AssemblyBuilderCecil
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="958" endline="967"><![CDATA[
 
     ''' <summary>
     ''' Checks whether the specified Type is defined in the current compiling assembly
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedHere(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Helper.Assert(Member IsNot Nothing)
         Return Member.DeclaringType.Module.Assembly Is Compiler.AssemblyBuilderCecil
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="968" endline="974"><![CDATA[
 
     Function FindType(ByVal FullName As String) As TypeDeclaration
         For Each type As TypeDeclaration In Me.Types
             If Helper.CompareName(type.FullName, FullName) Then Return type
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="975" endline="983"><![CDATA[
 
     Function FindTypeWithName(ByVal Name As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.Name, Name) Then Return tD
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="984" endline="992"><![CDATA[
 
     Function FindTypeWithFullname(ByVal Fullname As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.FullName, Fullname) Then Return tD
         Next
         Return Nothing
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="993" endline="997"><![CDATA[
 
     Property Name() As String
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="998" endline="1000"><![CDATA[
         Set(ByVal value As String)
             m_Name = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="1001" endline="1006"><![CDATA[
     End Property
 
     ReadOnly Property Types() As TypeDeclaration()
         Get
             Return m_TypeDeclarations
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="1007" endline="1012"><![CDATA[
     End Property
 
     ReadOnly Property Attributes() As Attributes
         Get
             Return m_Attributes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="43" endline="45"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier, ByVal TypeParameters As TypeParameters)
         MyBase.New(Parent, [Namespace], Name, TypeParameters)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="46" endline="52"><![CDATA[
 
     Sub AddInheritsClause(ByVal Clause As NonArrayTypeName)
         If m_InheritsClauses Is Nothing Then
             m_InheritsClauses = New Generic.List(Of NonArrayTypeName)
         End If
         m_InheritsClauses.Add(Clause)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="53" endline="65"><![CDATA[
 
     Function CreateBaseImplicitMembers() As Boolean
         Dim tD As Mono.Cecil.TypeDefinition
         Dim cD As ClassDeclaration
 
         tD = CecilHelper.FindDefinition(Me.BaseType)
         If tD Is Nothing Then Return True
 
         cD = TryCast(tD.Annotations(Compiler), ClassDeclaration)
         If cD Is Nothing Then Return True
 
         Return cD.CreateImplicitMembers
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="66" endline="78"><![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructor() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="79" endline="91"><![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructorCecil() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="92" endline="103"><![CDATA[
 
     Private Function GetTypeAttributes() As Mono.Cecil.TypeAttributes
         Dim result As Mono.Cecil.TypeAttributes = MyBase.TypeAttributes
 
         If Me.Modifiers.Is(ModifierMasks.MustInherit) Then
             result = result Or Mono.Cecil.TypeAttributes.Abstract
         ElseIf Me.Modifiers.Is(ModifierMasks.NotInheritable) Then
             result = result Or Mono.Cecil.TypeAttributes.Sealed
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="104" endline="109"><![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = GetTypeAttributes()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="110" endline="140"><![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_InheritsClauses Is Nothing OrElse m_InheritsClauses.Count > 0) 'Perf check
 
         If m_InheritsClauses IsNot Nothing AndAlso m_InheritsClauses.Count > 0 Then
             For i As Integer = 0 To m_InheritsClauses.Count - 1
                 result = m_InheritsClauses(i).ResolveTypeReferences AndAlso result
             Next
             If result = False Then Return False
 
             For i As Integer = 1 To m_InheritsClauses.Count - 1
                 If Helper.CompareType(m_InheritsClauses(0).ResolvedType, m_InheritsClauses(i).ResolvedType) = False Then
                     Helper.AddError(Compiler, Me.Location, "Class specifies different base classes")
                     result = False
                 End If
             Next
             If result = False Then Return False
             BaseType = m_InheritsClauses(0).ResolvedType
         Else
             BaseType = Compiler.TypeCache.System_Object
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         'Find the default constructors for this class
         Me.FindDefaultConstructors()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="141" endline="149"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="150" endline="207"><![CDATA[
 
     Private Function AddInitializeComponentCall(ByVal Ctor As ConstructorDeclaration) As Boolean
         Dim result As Boolean = True
 
         'If the class has the Microsoft.VisualBasic.CompilerServices.DesignerGeneratedAttribute, we call InitializeComponent.
         'InitializeComponent must be correctly spelled (case-sensitive), have no parameters (not even optional) and must be private
         Dim attribs As Generic.List(Of Attribute)
         attribs = Me.CustomAttributes.FindAttributes(Compiler.TypeCache.MS_VB_CS_DesignerGeneratedAttribute)
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return result
 
         Dim methods As Generic.List(Of INameable)
 
         methods = Members.Index.Item("InitializeComponent")
 
         If methods Is Nothing OrElse methods.Count = 0 Then Return result
 
         methods = New Generic.List(Of INameable)(methods)
 
         For i As Integer = methods.Count - 1 To 0 Step -1
             Dim subD As SubDeclaration
             subD = TryCast(methods(i), SubDeclaration)
             If subD Is Nothing Then
                 methods.RemoveAt(i)
                 Continue For
             End If
 
             If subD.Signature.ReturnType IsNot Nothing AndAlso Helper.CompareType(subD.Signature.ReturnType, Compiler.TypeCache.System_Void) = False Then
                 methods.RemoveAt(i)
                 Continue For
             End If
 
             If subD.Signature.Parameters.Count <> 0 Then
                 methods.RemoveAt(i)
                 Continue For
             End If
 
             If subD.Modifiers.Is(ModifierMasks.Private) = False Then
                 methods.RemoveAt(i)
                 Continue For
             End If
         Next
 
         If methods.Count = 0 Then Return result
 
         If methods.Count > 1 Then
             'Huh?
             Helper.StopIfDebugging(True)
         Else
             Dim callStmt As New CallStatement(Me)
             Dim sExp As New SimpleNameExpression(callStmt)
             sExp.Init(New Identifier(Me, "InitializeComponent", Me.Location, TypeCharacters.Characters.None), Nothing)
             callStmt.Init(sExp)
             Ctor.Code.AddStatement(callStmt)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="208" endline="253"><![CDATA[
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         If m_CreatedImplicitMembers Then Return True
 
         result = CreateBaseImplicitMembers() AndAlso result
 
         If result = False Then Return result
 
         'If a type contains no instance constructor declarations, a default constructor 
         'is automatically provided. The default constructor simply invokes the 
         'parameterless constructor of the direct base type. If the direct 
         'base type does not have an accessible parameterless constructor, 
         'a compile-time error occurs. 
         'The declared access type for the default constructor is always Public. 
         If HasInstanceConstructors = False Then
             Dim baseDefaultCtor As Mono.Cecil.MethodReference
             baseDefaultCtor = Me.GetBaseDefaultConstructor()
 
             If baseDefaultCtor IsNot Nothing Then
                 If Helper.IsPrivate(baseDefaultCtor) Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30387, Location, Name, BaseType.Name) AndAlso result
                 Else
                     DefaultInstanceConstructor = ConstructorDeclaration.CreateDefaultConstructor(Me)
                     Members.Add(DefaultInstanceConstructor)
 
                     result = AddInitializeComponentCall(DefaultInstanceConstructor) AndAlso result
                 End If
             Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30387, Location, Name, BaseType.Name) AndAlso result
             End If
         End If
 
         If DefaultSharedConstructor Is Nothing AndAlso Me.HasSharedFieldsWithInitializers Then
             DefaultSharedConstructor = ConstructorDeclaration.CreateTypeConstructor(Me)
             Members.Add(DefaultSharedConstructor)
             BeforeFieldInit = True
         End If
 
         result = CreateMyGroupMembers() AndAlso result
 
         m_CreatedImplicitMembers = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="254" endline="531"><![CDATA[
 
     Private Function CreateMyGroupMembers() As Boolean
         Dim result As Boolean = True
 
         If Me.CustomAttributes Is Nothing Then Return result
 
         Dim attrib As Attribute
         Dim attribs As Generic.List(Of Attribute)
 
         attribs = Me.CustomAttributes.FindAttributes(Compiler.TypeCache.MS_VB_MyGroupCollectionAttribute)
 
         If attribs Is Nothing Then Return result
         If attribs.Count <> 1 Then Return result
 
         attrib = attribs(0)
 
         Dim groupData As New MyGroupData
         Dim typeToCollect As String
         Dim createInstanceMethodName As String
         Dim disposeInstanceMethodName As String
         Dim defaultInstanceAlias As String
 
         If Not attrib.ResolveCode(ResolveInfo.Default(Compiler)) Then
             'The attribute is not instantiated correctly, this will cause an error on the attribute
             'no need to show more errors here.
             Return result
         End If
 
         'Check the number of arguments and their types
         'There should be 4 string arguments, if not there's something wrong with
         'the MyGroupCollectionAttribute (won't reach here if the code is wrong
         'because we resolve the attribute first)
         'It's also safe to index the arguments, since attributes can't have named constructor parameters.
         Dim args As Object() = attrib.Arguments
         If args Is Nothing OrElse args.Length <> 4 Then
             Throw New InternalException("Weird MyGroupCollectionAttribute, should have 4 arguments.")
         Else
             For Each arg As Object In args
                 If arg Is Nothing Then Continue For
                 If TypeOf arg Is String Then Continue For
                 Throw New InternalException("Weird MyGroupCollectionAttribute, non-string argument?")
             Next
         End If
         typeToCollect = DirectCast(args(0), String)
         createInstanceMethodName = DirectCast(args(1), String)
         disposeInstanceMethodName = DirectCast(args(2), String)
         defaultInstanceAlias = DirectCast(args(3), String)
 
         If typeToCollect = String.Empty Then Return result
         If createInstanceMethodName = String.Empty Then Return result
         If disposeInstanceMethodName = String.Empty Then Return result
 
         Dim collectType As Mono.Cecil.TypeReference
         Dim foundTypes As Generic.List(Of Mono.Cecil.TypeReference)
         foundTypes = Compiler.TypeManager.GetType(typeToCollect, False)
         If foundTypes.Count <> 1 Then
             Return result
         End If
         collectType = foundTypes(0)
         groupData.TypeToCollect = collectType
 
         For Each mi As MethodDeclaration In Members.GetSpecificMembers(Of MethodDeclaration)()
             If mi.IsShared AndAlso Helper.CompareName(createInstanceMethodName, mi.Name) Then
                 If mi.Signature.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.TypeParameters Is Nothing OrElse mi.Signature.TypeParameters.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.ReturnType Is Nothing Then Continue For
 
                 Dim T As TypeParameter = mi.Signature.TypeParameters.Parameters(0)
                 If T.TypeParameterConstraints Is Nothing Then Continue For
 
                 Dim constraints As ConstraintList = T.TypeParameterConstraints.Constraints
                 If constraints.Count <> 2 Then Continue For
 
                 If Not (constraints(0).Special = KS.[New] OrElse constraints(1).Special = KS.[New]) Then Continue For
 
                 Dim tn As TypeName
                 tn = constraints(0).TypeName
                 If tn Is Nothing Then tn = constraints(1).TypeName
                 If tn Is Nothing Then Continue For
                 If Not Helper.CompareType(tn.ResolvedType, groupData.TypeToCollect) Then Continue For
 
                 If Helper.CompareType(mi.Signature.Parameters(0).ParameterType, T.CecilBuilder) = False Then Continue For
                 If Helper.CompareType(mi.Signature.ReturnType, T.CecilBuilder) = False Then Continue For
 
 
                 If groupData.CreateInstanceMethod IsNot Nothing Then Continue For
                 groupData.CreateInstanceMethod = mi.CecilBuilder
             ElseIf mi.IsShared = False AndAlso Helper.CompareName(disposeInstanceMethodName, mi.Name) Then
                 If mi.Signature.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.TypeParameters Is Nothing OrElse mi.Signature.TypeParameters.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.ReturnType IsNot Nothing AndAlso Helper.CompareType(mi.Signature.ReturnType, Compiler.TypeCache.System_Void) = False Then Continue For
 
                 Dim T As TypeParameter = mi.Signature.TypeParameters.Parameters(0)
                 'SPECBUG
                 'https
                 If T.TypeParameterConstraints Is Nothing OrElse T.TypeParameterConstraints.Constraints Is Nothing OrElse T.TypeParameterConstraints.Constraints.Count <> 1 Then Continue For
                 If Not Helper.CompareType(T.TypeParameterConstraints.Constraints(0).TypeName.ResolvedType, groupData.TypeToCollect) Then Continue For
 
                 If Helper.CompareType(mi.Signature.Parameters(0).ParameterType, Compiler.TypeManager.MakeByRefType(Me, T.CecilBuilder)) = False Then Continue For
 
                 If groupData.DisposeInstanceMethod IsNot Nothing Then Continue For
                 groupData.DisposeInstanceMethod = mi.CecilBuilder
             End If
             If groupData.DisposeInstanceMethod IsNot Nothing AndAlso groupData.CreateInstanceMethod IsNot Nothing Then Exit For
         Next
 
         If groupData.CreateInstanceMethod Is Nothing Then Return result
         If groupData.DisposeInstanceMethod Is Nothing Then Return result
 
         If Compiler.Assembly.GroupedClasses Is Nothing Then Compiler.Assembly.GroupedClasses = New Generic.List(Of MyGroupData)
         Compiler.Assembly.GroupedClasses.Add(groupData)
 
         'Parse the alias
         If defaultInstanceAlias <> String.Empty Then
             Dim scanner As New Scanner(Compiler, defaultInstanceAlias)
             Dim parser As New Parser(Compiler, scanner)
             Dim alias_exp As Expression
             'TODO
             alias_exp = parser.ParseExpression(Me)
 
             If alias_exp IsNot Nothing Then
                 Dim alias_result As Boolean
                 alias_result = alias_exp.ResolveExpression(New ResolveInfo(Compiler))
                 If alias_result Then
                     groupData.DefaultInstanceAlias = alias_exp
                 End If
             End If
         End If
 
 
         'Find all non-generic types that inherit from the type to collect
         Dim typesCollected As New Generic.List(Of TypeDeclaration)
         Dim namesUsed As New Generic.Dictionary(Of String, Object)(Helper.StringComparer)
         Dim namesClashed As New Generic.Dictionary(Of String, Object)(Helper.StringComparer)
         For Each type As TypeDeclaration In Compiler.theAss.Types
             Dim classType As ClassDeclaration = TryCast(type, ClassDeclaration)
 
             If classType Is Nothing Then Continue For
             If classType.TypeParameters IsNot Nothing AndAlso classType.TypeParameters.Parameters.Count > 0 Then Continue For
 
             If Helper.IsSubclassOf(collectType, type.CecilType) Then
                 typesCollected.Add(type)
                 If namesUsed.ContainsKey(type.Name) Then
                     namesClashed.Add(type.Name, Nothing)
                 Else
                     namesUsed.Add(type.Name, Nothing)
                 End If
             End If
         Next
 
         For Each type As TypeDeclaration In typesCollected
             Dim propertyName As String
             Dim fieldName As String
 
             If namesClashed.ContainsKey(type.Name) Then
                 propertyName = type.FullName.Replace(".", "_")
             Else
                 propertyName = type.Name
             End If
             fieldName = "m_" & propertyName
 
             Dim field As New TypeVariableDeclaration(Me)
             Dim prop As New PropertyDeclaration(Me)
             Dim modifiers As New Modifiers(ModifierMasks.Public)
 
             field.Init(modifiers, fieldName, type.CecilType)
             prop.Init(modifiers, propertyName, type.CecilType)
 
             type.MyGroupField = field
 
             Dim setter As MethodDeclaration
             Dim getter As MethodDeclaration
 
             getter = prop.GetDeclaration
             setter = prop.SetDeclaration
 
             getter.Code = New CodeBlock(getter)
             setter.Code = New CodeBlock(setter)
 
             Dim get_1 As New AssignmentStatement(getter.Code)
             Dim get_1_left As New SimpleNameExpression(get_1)
             Dim get_1_right As New InvocationOrIndexExpression(get_1)
             Dim get_1_right_instance_exp As New SimpleNameExpression(get_1_right)
             Dim get_1_right_instance_exp_typeargs As New TypeArgumentList(get_1_right_instance_exp)
             Dim get_1_right_instance_exp_typeargs_1 As New TypeName(get_1_right_instance_exp_typeargs)
             Dim get_1_right_arg1 As New SimpleNameExpression(get_1_right)
             Dim get_1_right_arglist As New ArgumentList(get_1_right, get_1_right_arg1)
             Dim get_1_right_field_token As Identifier = New Identifier(get_1_right, fieldName, attrib.Location, TypeCharacters.Characters.None)
             Dim get_1_right_method_token As Identifier = New Identifier(get_1_right, createInstanceMethodName, attrib.Location, TypeCharacters.Characters.None)
 
             get_1_left.Init(get_1_right_field_token, Nothing)
 
             get_1_right_instance_exp_typeargs_1.Init(type.CecilType)
             get_1_right_instance_exp_typeargs.Add(get_1_right_instance_exp_typeargs_1)
             get_1_right_instance_exp.Init(get_1_right_method_token, get_1_right_instance_exp_typeargs)
             get_1_right_arg1.Init(get_1_right_field_token, Nothing)
             get_1_right.Init(get_1_right_instance_exp, get_1_right_arglist)
             get_1.Init(get_1_left, get_1_right)
 
             Dim get_2 As New ReturnStatement(getter.Code)
             Dim get_2_exp As New SimpleNameExpression(get_2)
             get_2_exp.Init(get_1_right_field_token, Nothing)
             get_2.Init(get_2_exp)
 
             getter.Code.AddStatement(get_1)
             getter.Code.AddStatement(get_2)
 
             Dim set_if1 As New IfStatement(setter.Code)
             Dim value_token As Identifier = New Identifier(set_if1, "Value", attrib.Location, TypeCharacters.Characters.None)
             Dim field_token As Identifier = New Identifier(set_if1, fieldName, attrib.Location, TypeCharacters.Characters.None)
             Dim set_if1_condition_left As New SimpleNameExpression(set_if1)
             Dim set_if1_condition_right As New SimpleNameExpression(set_if1)
             Dim set_if1_condition As New Is_IsNotExpression(set_if1, set_if1_condition_left, set_if1_condition_right, KS.IsNot)
             Dim set_if1_code As New CodeBlock(set_if1)
             Dim set_if2 As New IfStatement(set_if1)
             Dim set_if2_condition_right As New NothingConstantExpression(set_if2)
             Dim set_if2_condition As New Is_IsNotExpression(set_if2, set_if1_condition_left, set_if2_condition_right, KS.IsNot)
             Dim set_if2_code As New CodeBlock(set_if2)
             Dim set_throw As New ThrowStatement(set_if2_code)
             Dim set_throw_creation As New DelegateOrObjectCreationExpression(set_throw)
             Dim set_throw_arg1 As New ConstantExpression(set_throw_creation, "Property can only be set to Nothing", Compiler.TypeCache.System_String)
             Dim set_throw_args As New ArgumentList(set_throw_creation, set_throw_arg1)
             Dim set_dispose As New CallStatement(set_if1)
             Dim set_dispose_invocation As New InvocationOrIndexExpression(set_dispose)
             Dim set_dispose_invocation_instance_exp As New SimpleNameExpression(set_dispose_invocation)
             Dim set_dispose_invocation_instance_exp_typeargs As New TypeArgumentList(set_dispose_invocation_instance_exp)
             Dim set_dispose_invocation_instance_exp_typeargs_1 As New TypeName(set_dispose_invocation_instance_exp_typeargs)
             Dim set_dispose_invocation_arg1 As New SimpleNameExpression(set_dispose_invocation)
             Dim set_dispose_invocation_arglist As New ArgumentList(set_dispose_invocation, set_dispose_invocation_arg1)
             Dim set_dispose_invocation_field_token As Identifier = New Identifier(set_dispose_invocation, fieldName, attrib.Location, TypeCharacters.Characters.None)
             Dim set_dispose_invocation_method_token As Identifier = New Identifier(set_dispose_invocation, disposeInstanceMethodName, attrib.Location, TypeCharacters.Characters.None)
 
             set_throw_creation.Init(Compiler.TypeCache.System_ArgumentException, set_throw_args)
             set_throw.Init(set_throw_creation)
 
             set_if2_code.AddStatement(set_throw)
 
             set_dispose_invocation_instance_exp_typeargs_1.Init(type.CecilType)
             set_dispose_invocation_instance_exp_typeargs.Add(set_dispose_invocation_instance_exp_typeargs_1)
             set_dispose_invocation_instance_exp.Init(set_dispose_invocation_method_token, set_dispose_invocation_instance_exp_typeargs)
             set_dispose_invocation_arg1.Init(set_dispose_invocation_field_token, Nothing)
             set_dispose_invocation.Init(set_dispose_invocation_instance_exp, set_dispose_invocation_arglist)
             set_dispose.Init(set_dispose_invocation)
 
             set_if1_code.AddStatement(set_if2)
             set_if1_code.AddStatement(set_dispose)
 
             set_if1_condition_left.Init(value_token, Nothing)
             set_if1_condition_right.Init(field_token, Nothing)
 
             set_if1.Init(set_if1_condition, Nothing, set_if1_code, False, Nothing)
             set_if2.Init(set_if2_condition, Nothing, set_if2_code, False, Nothing)
 
             setter.Code.AddStatement(set_if1)
 
             result = setter.ResolveTypeReferences AndAlso result
             result = getter.ResolveTypeReferences AndAlso result
 
             Members.Add(field)
             Members.Add(prop)
 
             field.UpdateDefinition()
             prop.UpdateDefinition()
 
             'Me.TypeDescriptor.ClearCache()
 
             If Compiler.TypeManager.ContainsCache(Me.CecilType) Then
                 Dim cache As MemberCache = Compiler.TypeManager.GetCache(Me.CecilType)
                 'cache.Cache.Add(New MemberCacheEntry(field.FieldDescriptor))
                 'cache.Cache.Add(New MemberCacheEntry(prop.MemberDescriptor))
                 'cache.FlattenedCache.Add(New MemberCacheEntry(field.FieldDescriptor))
                 'cache.FlattenedCache.Add(New MemberCacheEntry(prop.MemberDescriptor))
                 cache.ClearAll()
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="532" endline="540"><![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         'Define type parameters
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="541" endline="548"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Class)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="48" endline="51"><![CDATA[
     Public Sub New(ByVal Parent As TypeDeclaration, ByVal Signature As SubSignature)
         MyBase.New(Parent, Parent.Namespace, Signature.Identifier, Signature.TypeParameters)
         m_Signature = Signature
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="52" endline="56"><![CDATA[
 
     Public Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Signature As SubSignature)
         MyBase.New(Parent, [Namespace], Helper.CreateGenericTypename(Signature.Identifier, Signature.TypeParameters), Signature.TypeParameters)
         m_Signature = Signature
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="57" endline="62"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Signature IsNot Nothing Then m_Signature.Initialize(Me)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="63" endline="170"><![CDATA[
 
     Function CreateImplicitElements() As Boolean Implements IHasImplicitTypes.CreateImplicitTypes
         Dim result As Boolean = True
         Dim ReturnType As TypeName
         Dim Parameters As ParameterList = m_Signature.Parameters
 
         If m_ImplicitElementsCreated Then Return True
         m_ImplicitElementsCreated = True
 
         Helper.Assert(Me.Members.Count = 0)
 
         If TypeOf m_Signature Is FunctionSignature Then
             ReturnType = DirectCast(m_Signature, FunctionSignature).TypeName
             If ReturnType Is Nothing Then ReturnType = New TypeName(Me, Compiler.TypeCache.System_Object)
         Else
             ReturnType = Nothing
         End If
 
         'Create the constructor
         m_Constructor = New ConstructorDeclaration(Me)
         m_Constructor.Init(Nothing)
         m_Constructor.Signature.Parameters.Add("TargetObject", Compiler.TypeCache.System_Object)
         m_Constructor.Signature.Parameters.Add("TargetMethod", Compiler.TypeCache.System_IntPtr)
         m_Constructor.MethodAttributes = Mono.Cecil.MethodAttributes.Public Or Mono.Cecil.MethodAttributes.SpecialName Or Mono.Cecil.MethodAttributes.RTSpecialName
         m_Constructor.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.Runtime
 
         Members.Add(m_Constructor)
 
         Dim paramCount As Integer
         If Parameters IsNot Nothing Then paramCount = Parameters.Count
 
         Dim invokeParameters As ParameterList
         Dim beginInvokeParameters As ParameterList
         Dim endInvokeParameters As ParameterList
 
         Dim invokeSignature As SubSignature
         Dim beginInvokeSignature As FunctionSignature
         Dim endInvokeSignature As SubSignature
 
         'Invoke takes same types as delegate, and same return type
         'BeginInvoke takes same types as delegate + AsyncCallback + Object, and return type is IAsyncResult
         'EndInvoke takes byref types of delegate + IAsyncResult, and same return type
 
         If ReturnType Is Nothing Then
             m_Invoke = New SubDeclaration(Me)
             m_EndInvoke = New SubDeclaration(Me)
         Else
             m_Invoke = New FunctionDeclaration(Me)
             m_EndInvoke = New FunctionDeclaration(Me)
         End If
         m_BeginInvoke = New FunctionDeclaration(Me)
 
         invokeParameters = New ParameterList(m_Invoke)
         beginInvokeParameters = New ParameterList(m_BeginInvoke)
         endInvokeParameters = New ParameterList(m_EndInvoke)
 
         For i As Integer = 0 To paramCount - 1
             invokeParameters.Add(Parameters(i).Clone(invokeParameters))
             beginInvokeParameters.Add(Parameters(i).Clone(beginInvokeParameters))
             If Parameters(i).Modifiers.Is(ModifierMasks.ByRef) Then
                 endInvokeParameters.Add(Parameters(i).Clone(endInvokeParameters))
             End If
         Next
         beginInvokeParameters.Add(New Parameter(beginInvokeParameters, "DelegateCallback", Compiler.TypeCache.System_AsyncCallback))
         beginInvokeParameters.Add(New Parameter(beginInvokeParameters, "DelegateAsyncState", Compiler.TypeCache.System_Object))
         endInvokeParameters.Add(New Parameter(endInvokeParameters, "DelegateAsyncResult", Compiler.TypeCache.System_IAsyncResult))
 
         If ReturnType Is Nothing Then
             invokeSignature = New SubSignature(m_Invoke, STR_Invoke, invokeParameters)
             endInvokeSignature = New SubSignature(m_EndInvoke, STR_EndInvoke, endInvokeParameters)
         Else
             invokeSignature = New FunctionSignature(m_Invoke)
             DirectCast(invokeSignature, FunctionSignature).Init(STR_Invoke, Nothing, invokeParameters, Nothing, ReturnType, Me.Location)
             endInvokeSignature = New FunctionSignature(m_EndInvoke)
             DirectCast(endInvokeSignature, FunctionSignature).Init(STR_EndInvoke, Nothing, endInvokeParameters, Nothing, ReturnType, Me.Location)
         End If
         beginInvokeSignature = New FunctionSignature(m_BeginInvoke, STR_BeginInvoke, beginInvokeParameters, Compiler.TypeCache.System_IAsyncResult, Me.Location)
 
         m_Invoke.Init(New Modifiers(), invokeSignature, Nothing, Nothing)
         m_BeginInvoke.Init(New Modifiers(), beginInvokeSignature, Nothing, Nothing)
         m_EndInvoke.Init(New Modifiers(), endInvokeSignature, Nothing, Nothing)
 
         Dim attr As Mono.Cecil.MethodAttributes
         Dim implattr As Mono.Cecil.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.Runtime
         attr = Mono.Cecil.MethodAttributes.Public Or Mono.Cecil.MethodAttributes.NewSlot Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
 
         'If Me.DeclaringType IsNot Nothing AndAlso Me.DeclaringType.TypeDescriptor.IsInterface Then
         '    attr = attr Or MethodAttributes.CheckAccessOnOverride
         'End If
 
         m_Invoke.MethodAttributes = attr
         m_BeginInvoke.MethodAttributes = attr
         m_EndInvoke.MethodAttributes = attr
 
         m_Invoke.MethodImplAttributes = implattr
         m_BeginInvoke.MethodImplAttributes = implattr
         m_EndInvoke.MethodImplAttributes = implattr
 
         Members.Add(m_BeginInvoke)
         Members.Add(m_EndInvoke)
         Members.Add(m_Invoke)
 
         m_BeginInvoke.Initialize(Me)
         m_EndInvoke.Initialize(Me)
         m_Invoke.Initialize(Me)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="171" endline="182"><![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         BaseType = Compiler.TypeCache.System_MulticastDelegate
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences(False) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="183" endline="190"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Delegate)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="191" endline="195"><![CDATA[
 
     ReadOnly Property Signature() As SubSignature
         Get
             Return m_Signature
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="196" endline="202"><![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="40" endline="43"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier, ByVal EnumType As KS)
         MyBase.New(Parent, [Namespace], Name)
     Private m_QualifiedName As KS = KS.Integer
     Private m_Constants As Generic.List(Of EnumMemberDeclaration)
     Private m_ValueField As Mono.Cecil.FieldDefinition
 
     Public Const EnumTypeMemberName As String = "value__"
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier, ByVal EnumType As KS)
         MyBase.New(Parent, [Namespace], Name)
         m_QualifiedName = EnumType
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="44" endline="52"><![CDATA[
 
     ReadOnly Property Constants() As Generic.List(Of EnumMemberDeclaration)
         Get
             If m_Constants Is Nothing Then
                 m_Constants = Members.GetSpecificMembers(Of EnumMemberDeclaration)()
                 Helper.Assert(m_Constants.Count = Members.Count)
             End If
             Return m_Constants
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="53" endline="62"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences() AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="63" endline="67"><![CDATA[
 
     ReadOnly Property EnumConstantTypeKeyword() As KS
         Get
             Return m_QualifiedName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="68" endline="73"><![CDATA[
     End Property
 
     ReadOnly Property EnumConstantType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeResolution.TypeCodeToType(TypeResolution.KeywordToTypeCode(m_QualifiedName))
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="74" endline="82"><![CDATA[
     End Property
 
     Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="83" endline="92"><![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="93" endline="100"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Enum)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="101" endline="105"><![CDATA[
 
     ReadOnly Property QualifiedName() As KS
         Get
             Return m_QualifiedName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="106" endline="122"><![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
         BaseType = Compiler.TypeCache.System_Enum
 
         If m_ValueField Is Nothing AndAlso m_QualifiedName <> KS.None Then
             m_ValueField = New Mono.Cecil.FieldDefinition(EnumTypeMemberName, Mono.Cecil.FieldAttributes.Public Or Mono.Cecil.FieldAttributes.SpecialName Or Mono.Cecil.FieldAttributes.RTSpecialName, Helper.GetTypeOrTypeReference(Compiler, EnumConstantType))
             CecilType.Fields.Add(m_ValueField)
         End If
 
         If m_ValueField IsNot Nothing Then
             m_ValueField.FieldType = Helper.GetTypeOrTypeReference(Compiler, EnumConstantType)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="123" endline="127"><![CDATA[
 
     Public Overrides ReadOnly Property IsShared() As Boolean
         Get
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="26" endline="29"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier, ByVal TypeParameters As TypeParameters)
         MyBase.new(Parent, [Namespace], Name)
         m_TypeParameters = TypeParameters
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="30" endline="35"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_TypeParameters IsNot Nothing Then m_TypeParameters.Initialize(Me)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="36" endline="40"><![CDATA[
 
     ReadOnly Property TypeParameters() As TypeParameters Implements IConstructable.TypeParameters
         Get
             Return m_TypeParameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="41" endline="52"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameters IsNot Nothing Then
             result = m_TypeParameters.ResolveTypeReferences AndAlso result
         End If
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="53" endline="60"><![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="33" endline="35"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier, ByVal TypeParameters As TypeParameters)
         MyBase.New(Parent, [Namespace], Name, TypeParameters)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="36" endline="41"><![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Interface Or Mono.Cecil.TypeAttributes.Abstract
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="42" endline="46"><![CDATA[
 
     Public Overrides ReadOnly Property IsShared() As Boolean
         Get
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="47" endline="52"><![CDATA[
     End Property
 
     Property InterfaceBases() As InterfaceBases
         Get
             Return m_InterfaceBases
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="53" endline="55"><![CDATA[
         Set(ByVal value As InterfaceBases)
             m_InterfaceBases = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="56" endline="71"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfaceBases IsNot Nothing Then
             result = m_InterfaceBases.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_InterfaceBases.Bases.Length - 1
                 AddInterface(m_InterfaceBases.Bases(i).ResolvedType)
             Next
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="72" endline="79"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Interface)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="34" endline="50"><![CDATA[
     Private Function AddAttribute() As Boolean
         Dim result As Boolean = True
         Dim newAttrib As Attribute
 
         If m_DefinedStandardModuleAttribute Then Return True
 
         If Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute Is Nothing Then Return True
 
         newAttrib = New Attribute(Me, Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute)
         result = newAttrib.ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
 
         If MyBase.CustomAttributes Is Nothing Then MyBase.CustomAttributes = New Attributes(Me)
         MyBase.CustomAttributes.Add(newAttrib)
         m_DefinedStandardModuleAttribute = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="51" endline="59"><![CDATA[
 
     Public Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         result = AddAttribute() AndAlso result
         result = MyBase.DefineType() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="60" endline="63"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier)
         MyBase.New(Parent, [Namespace], Name)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="64" endline="74"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_Object
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Me.FindDefaultConstructors()
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="75" endline="82"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Module)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="83" endline="89"><![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
         AddAttribute()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="90" endline="94"><![CDATA[
 
     Public Overrides ReadOnly Property IsShared() As Boolean
         Get
             Return True
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="95" endline="109"><![CDATA[
     End Property
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         If DefaultSharedConstructor Is Nothing AndAlso (Me.HasSharedConstantFields OrElse Me.HasSharedFieldsWithInitializers) Then
             DefaultSharedConstructor = New ConstructorDeclaration(Me)
             DefaultSharedConstructor.Init(New Modifiers(ModifierMasks.Shared), New SubSignature(DefaultSharedConstructor, ConstructorDeclaration.SharedConstructorName, New ParameterList(DefaultSharedConstructor)), New CodeBlock(DefaultSharedConstructor))
             result = DefaultSharedConstructor.ResolveTypeReferences AndAlso result
             Members.Add(DefaultSharedConstructor)
             BeforeFieldInit = True
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="28" endline="30"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier, ByVal TypeParameters As TypeParameters)
         MyBase.new(Parent, [Namespace], Name, TypeParameters)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="31" endline="35"><![CDATA[
 
     Property [Implements]() As TypeImplementsClauses
         Get
             Return m_TypeImplementsClauses
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="36" endline="38"><![CDATA[
         Set(ByVal value As TypeImplementsClauses)
             m_TypeImplementsClauses = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="39" endline="47"><![CDATA[
     End Property
 
     Private Function GetTypeAttributes() As Mono.Cecil.TypeAttributes
         Dim result As Mono.Cecil.TypeAttributes
 
         result = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="48" endline="53"><![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = GetTypeAttributes()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="54" endline="93"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfacesImplemented = False AndAlso m_TypeImplementsClauses IsNot Nothing Then
             result = m_TypeImplementsClauses.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_TypeImplementsClauses.Clauses.Count - 1
                 AddInterface(m_TypeImplementsClauses.Clauses(i).ResolvedType)
             Next
             m_InterfacesImplemented = True
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If Me.IsPartial Then
             If PartialModifierFound = False Then
                 Dim first As PartialTypeDeclaration = Me
                 Compiler.Report.ShowMessage(Messages.VBNC30179, Me.Location, Me.DescriptiveType, Me.Name, Me.DescriptiveType, Me.Name, Me.Namespace, Me.Namespace)
                 result = False
             End If
             'TODO
             'If TypeOf Me Is ClassDeclaration Then
             '    Dim inheritedTypes() As Mono.Cecil.TypeReference
             '    inheritedTypes = GetInheritedTypes()
             '    If inheritedTypes.Length > 0 Then
             '        Dim tmpType As Mono.Cecil.TypeReference
             '        tmpType = CheckUniqueType(inheritedTypes)
             '        If tmpType Is Nothing Then
             '            Return Helper.AddError(Me, "Partial classes must inherit from only one base class.")
             '        Else
             '            BaseType = tmpType
             '        End If
             '    Else
             '        Helper.Assert(BaseType IsNot Nothing) 'Should already be set to System.Object.
             '    End If
             'End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="94" endline="123"><![CDATA[
 
     '''' <summary>
     '''' Checks that all types are equal.
     '''' Returns nothing if types are not equal.
     '''' </summary>
     '''' <param name="Types"></param>
     '''' <returns></returns>
     '''' <remarks></remarks>
     'Private Function CheckUniqueType(ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
     '    Helper.Assert(Types.Length >= 1)
     '    For i As Integer = 1 To Types.Length - 1
     '        If Helper.CompareType(Types(0), Types(i)) = False Then Return Nothing
     '    Next
     '    Return Types(0)
     'End Function
 
     ''' <summary>
     ''' Checks that all types are equal.
     ''' Returns nothing if types are not equal.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function CheckUniqueType(ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(Types.Length >= 1)
         For i As Integer = 1 To Types.Length - 1
             If Helper.CompareType(Types(0), Types(i)) = False Then Return Nothing
         Next
         Return Types(0)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="32" endline="34"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier, ByVal TypeParameters As TypeParameters)
         MyBase.New(Parent, [Namespace], Name, TypeParameters)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="35" endline="43"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_ValueType
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="44" endline="51"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Structure)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="52" endline="57"><![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = MyBase.TypeAttributes Or Mono.Cecil.TypeAttributes.SequentialLayout Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="64" endline="66"><![CDATA[
         Get
             Return m_MyGroupField
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="67" endline="69"><![CDATA[
         Set(ByVal value As TypeVariableDeclaration)
             m_MyGroupField = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="70" endline="75"><![CDATA[
     End Property
 
     Property Serializable() As Boolean
         Get
             Return m_Serializable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="76" endline="79"><![CDATA[
         Set(ByVal value As Boolean)
             If m_CecilType IsNot Nothing Then m_CecilType.IsSerializable = value
             m_Serializable = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="80" endline="88"><![CDATA[
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For Each member As MemberDeclaration In m_Members
             member.Initialize(Me)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="89" endline="107"><![CDATA[
 
     ReadOnly Property DescriptiveType() As String
         Get
             If TypeOf Me Is ClassDeclaration Then
                 Return "class"
             ElseIf TypeOf Me Is ModuleDeclaration Then
                 Return "module"
             ElseIf TypeOf Me Is EnumDeclaration Then
                 Return "enum"
             ElseIf TypeOf Me Is StructureDeclaration Then
                 Return "structure"
             ElseIf TypeOf Me Is DelegateDeclaration Then
                 Return "delegate"
             ElseIf TypeOf Me Is InterfaceDeclaration Then
                 Return "interface"
             Else
                 Return "type"
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="108" endline="113"><![CDATA[
     End Property
 
     ReadOnly Property AddHandlers() As Generic.List(Of AddOrRemoveHandlerStatement)
         Get
             Return m_AddHandlers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="114" endline="126"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier)
         MyBase.New(Parent)
     Private m_Members As New MemberDeclarations(Me)
     Private m_Namespace As String
     Private m_Name As Identifier
 
     Private m_DefaultInstanceConstructor As ConstructorDeclaration
     Private m_DefaultSharedConstructor As ConstructorDeclaration
     Private m_StaticVariables As Generic.List(Of LocalVariableDeclaration)
     Private m_BeforeFieldInit As Boolean
     Private m_Serializable As Boolean
     Private m_AddedCompareTextAttribute As Boolean
 
     'Information collected during define phase.
     Private m_CecilType As Mono.Cecil.TypeDefinition
 
     Private m_FullName As String
 
     Private m_AddHandlers As New Generic.List(Of AddOrRemoveHandlerStatement)
     Private m_MyGroupField As TypeVariableDeclaration
 
     Property MyGroupField() As TypeVariableDeclaration
         Get
             Return m_MyGroupField
         End Get
         Set(ByVal value As TypeVariableDeclaration)
             m_MyGroupField = value
         End Set
     End Property
 
     Property Serializable() As Boolean
         Get
             Return m_Serializable
         End Get
         Set(ByVal value As Boolean)
             If m_CecilType IsNot Nothing Then m_CecilType.IsSerializable = value
             m_Serializable = value
         End Set
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For Each member As MemberDeclaration In m_Members
             member.Initialize(Me)
         Next
     End Sub
 
     ReadOnly Property DescriptiveType() As String
         Get
             If TypeOf Me Is ClassDeclaration Then
                 Return "class"
             ElseIf TypeOf Me Is ModuleDeclaration Then
                 Return "module"
             ElseIf TypeOf Me Is EnumDeclaration Then
                 Return "enum"
             ElseIf TypeOf Me Is StructureDeclaration Then
                 Return "structure"
             ElseIf TypeOf Me Is DelegateDeclaration Then
                 Return "delegate"
             ElseIf TypeOf Me Is InterfaceDeclaration Then
                 Return "interface"
             Else
                 Return "type"
             End If
         End Get
     End Property
 
     ReadOnly Property AddHandlers() As Generic.List(Of AddOrRemoveHandlerStatement)
         Get
             Return m_AddHandlers
         End Get
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier)
         MyBase.New(Parent)
 
         m_Namespace = [Namespace]
         m_Name = Name
         MyBase.Name = Name.Name
 
         Helper.Assert(m_Namespace IsNot Nothing)
         Helper.Assert(m_Name IsNot Nothing)
         UpdateDefinition()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="127" endline="148"><![CDATA[
 
     Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_CecilType Is Nothing Then
             If Me.IsNestedType Then
                 m_CecilType = New Mono.Cecil.TypeDefinition(Nothing, Me.Name, 0)
             Else
                 m_CecilType = New Mono.Cecil.TypeDefinition(Me.Namespace, Me.Name, 0)
             End If
             m_CecilType.Annotations.Add(Compiler, Me)
         End If
         m_CecilType.Name = Name
 
         If CecilType.Module Is Nothing AndAlso Me.Name IsNot Nothing Then
             If IsNestedType Then
                 DeclaringType.CecilType.NestedTypes.Add(CecilType)
             Else
                 Compiler.ModuleBuilderCecil.Types.Add(CecilType)
             End If
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="149" endline="153"><![CDATA[
 
     Protected Property BeforeFieldInit() As Boolean
         Get
             Return m_BeforeFieldInit
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="154" endline="157"><![CDATA[
         Set(ByVal value As Boolean)
             m_BeforeFieldInit = value
             UpdateDefinition()
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="158" endline="163"><![CDATA[
     End Property
 
     Protected Friend Property DefaultInstanceConstructor() As ConstructorDeclaration
         Get
             Return m_DefaultInstanceConstructor
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="164" endline="166"><![CDATA[
         Set(ByVal value As ConstructorDeclaration)
             m_DefaultInstanceConstructor = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="167" endline="172"><![CDATA[
     End Property
 
     Protected Property DefaultSharedConstructor() As ConstructorDeclaration
         Get
             Return m_DefaultSharedConstructor
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="173" endline="175"><![CDATA[
         Set(ByVal value As ConstructorDeclaration)
             m_DefaultSharedConstructor = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="176" endline="202"><![CDATA[
     End Property
 
     Protected Sub FindDefaultConstructors()
         For i As Integer = 0 To Me.Members.Count - 1
             Dim member As IMember = Me.Members(i)
             Dim ctor As ConstructorDeclaration = TryCast(member, ConstructorDeclaration)
 
             If ctor Is Nothing Then Continue For
 
             Dim isdefault As Boolean
             isdefault = False
             If ctor.GetParameters.Length = 0 Then
                 isdefault = True
             Else
                 isdefault = ctor.GetParameters()(0).IsOptional
             End If
             If isdefault Then
                 If ctor.IsShared Then
                     Helper.Assert(m_DefaultSharedConstructor Is Nothing OrElse m_DefaultSharedConstructor Is ctor)
                     m_DefaultSharedConstructor = ctor
                 Else
                     Helper.Assert(m_DefaultInstanceConstructor Is Nothing OrElse m_DefaultInstanceConstructor Is ctor)
                     m_DefaultInstanceConstructor = ctor
                 End If
             End If
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="203" endline="208"><![CDATA[
 
     ReadOnly Property [Namespace]() As String Implements IType.Namespace
         Get
             Helper.Assert(m_Namespace IsNot Nothing)
             Return m_Namespace
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="209" endline="213"><![CDATA[
     End Property
 
     Sub AddInterface(ByVal Type As Mono.Cecil.TypeReference)
         m_CecilType.Interfaces.Add(Helper.GetTypeOrTypeReference(Compiler, Type))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="214" endline="218"><![CDATA[
 
     ReadOnly Property Identifier() As Identifier
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="219" endline="224"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsShared() As Boolean
         Get
             Return TypeOf Me Is ModuleDeclaration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="225" endline="230"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property MemberDescriptor() As Mono.Cecil.MemberReference
         Get
             Return m_CecilType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="231" endline="247"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property FullName() As String
         Get
             If m_FullName Is Nothing Then
                 If Me.IsNestedType Then
                     m_FullName = DeclaringType.FullName & "+" & Me.Name
                 Else
                     If m_Namespace <> "" Then
                         m_FullName = m_Namespace & "." & Me.Name
                     Else
                         m_FullName = Me.Name
                     End If
                 End If
             End If
             Return m_FullName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="248" endline="262"><![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Property BaseType() As Mono.Cecil.TypeReference Implements IType.BaseType
         Get
             If m_CecilType Is Nothing Then
                 Return Nothing
             End If
             Return m_CecilType.BaseType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="263" endline="265"><![CDATA[
         Set(ByVal value As Mono.Cecil.TypeReference)
             m_CecilType.BaseType = Helper.GetTypeOrTypeReference(Compiler, value)
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="266" endline="271"><![CDATA[
     End Property
 
     Public ReadOnly Property Members() As MemberDeclarations Implements IType.Members
         Get
             Return m_Members
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="272" endline="277"><![CDATA[
     End Property
 
     Public Overridable ReadOnly Property CecilType() As Mono.Cecil.TypeDefinition Implements IType.CecilType
         Get
             Return m_CecilType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="278" endline="286"><![CDATA[
     End Property
 
     ReadOnly Property IsNestedType() As Boolean Implements IType.IsNestedType
         Get
             Dim result As Boolean
             result = DeclaringType IsNot Nothing
             Helper.Assert(result = (Me.FindFirstParent(Of IType)() IsNot Nothing))
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="287" endline="348"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If File IsNot Nothing AndAlso File.IsOptionCompareText AndAlso m_AddedCompareTextAttribute = False Then
             m_AddedCompareTextAttribute = True
             AddCustomAttribute(New Attribute(Me, Compiler.TypeCache.MS_VB_CS_OptionTextAttribute))
         End If
 
         m_StaticVariables = New Generic.List(Of LocalVariableDeclaration)
         For Each method As MethodDeclaration In m_Members.GetSpecificMembers(Of MethodDeclaration)()
             If method.Code IsNot Nothing Then method.Code.FindStaticVariables(m_StaticVariables)
         Next
         For Each prop As PropertyDeclaration In m_Members.GetSpecificMembers(Of PropertyDeclaration)()
             If prop.GetDeclaration IsNot Nothing AndAlso prop.GetDeclaration.Code IsNot Nothing Then prop.GetDeclaration.Code.FindStaticVariables(m_StaticVariables)
             If prop.SetDeclaration IsNot Nothing AndAlso prop.SetDeclaration.Code IsNot Nothing Then prop.SetDeclaration.Code.FindStaticVariables(m_StaticVariables)
         Next
 
         'Create nested generic type parameters
         If Me.IsNestedType Then
             Dim parentType As TypeDeclaration = DeclaringType
             Dim parentGenericType As GenericTypeDeclaration
             Dim stack As New Generic.Stack(Of TypeParameter)
             Dim insertAt As Integer = 0
 
             Do
                 parentGenericType = TryCast(parentType, GenericTypeDeclaration)
                 If parentGenericType IsNot Nothing AndAlso parentGenericType.TypeParameters IsNot Nothing Then
                     For i As Integer = parentGenericType.TypeParameters.Parameters.Count - 1 To 0 Step -1
                         stack.Push(parentGenericType.TypeParameters.Parameters(i))
                     Next
                 End If
                 parentType = parentType.DeclaringType
             Loop While parentType IsNot Nothing
 
             Dim typeParameter As TypeParameter
 
             Do While stack.Count > 0
                 typeParameter = stack.Pop
                 CecilType.GenericParameters.Insert(insertAt, typeParameter.Clone(typeParameter.CecilBuilder, CecilType, CecilType.GenericParameters.Count))
                 insertAt += 1
             Loop
             Do While stack.Count > 0
                 typeParameter = stack.Pop
                 CecilType.GenericParameters.Insert(insertAt, typeParameter.Clone(typeParameter.CecilBuilder, CecilType, CecilType.GenericParameters.Count))
                 insertAt += 1
             Loop
 
             Dim enumDecl As EnumDeclaration = TryCast(Me, EnumDeclaration)
             If enumDecl IsNot Nothing AndAlso CecilType.GenericParameters.Count > 0 Then
                 Dim enumFieldType As New Mono.Cecil.GenericInstanceType(CecilType)
                 For i As Integer = 0 To CecilType.GenericParameters.Count - 1
                     enumFieldType.GenericArguments.Add(CecilType.GenericParameters(i))
                 Next
                 For i As Integer = 0 To enumDecl.Members.Count - 1
                     Dim enumField As EnumMemberDeclaration = TryCast(enumDecl.Members(i), EnumMemberDeclaration)
                     If enumField Is Nothing Then Continue For
                     enumField.FieldBuilder.FieldType = enumFieldType
                 Next
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="349" endline="356"><![CDATA[
 
     Overridable Function DefineType() As Boolean Implements IDefinableType.DefineType
         Dim result As Boolean = True
 
         Helper.Assert(BaseType IsNot Nothing OrElse Me.CecilType.IsInterface)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="357" endline="371"><![CDATA[
 
     Public Overridable Function DefineTypeHierarchy() As Boolean Implements IDefinableType.DefineTypeHierarchy
         Dim result As Boolean = True
 
         If BaseType Is Nothing Then
             If Me.IsInterface = False Then
                 m_CecilType.BaseType = Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void)
             End If
         End If
         If DeclaringType IsNot Nothing Then
             m_CecilType.DeclaringType = DeclaringType.CecilType
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="372" endline="395"><![CDATA[
 
     Public Function SetDefaultAttribute(ByVal Name As String) As Boolean
         Dim result As Boolean = True
         For Each att As Attribute In CustomAttributes
             result = att.ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
             If result = False Then Return result
             If Helper.CompareType(att.AttributeType, Compiler.TypeCache.System_Reflection_DefaultMemberAttribute) Then
                 Dim tmpName As String
                 tmpName = TryCast(att.GetArgument(0), String)
                 If tmpName IsNot Nothing AndAlso Helper.CompareNameOrdinal(Name, tmpName) = False Then
                     Compiler.Report.ShowMessage(Messages.VBNC32304, Location, Me.FullName, tmpName, Name)
                     Return False
                 End If
                 Return True
             End If
         Next
 
         'Helper.NotImplementedYet("Check that the property is indexed.")
         Dim attrib As Attribute
         attrib = New Attribute(Me, Compiler.TypeCache.System_Reflection_DefaultMemberAttribute, Name)
         result = attrib.ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
         CustomAttributes.Add(attrib)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="396" endline="408"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Report.Trace("{0}
 
         result = MyBase.ResolveCode(Info) AndAlso result
         Compiler.VerifyConsistency(result, Location)
         result = m_Members.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="409" endline="416"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="417" endline="421"><![CDATA[
 
     ReadOnly Property StaticVariables() As Generic.List(Of LocalVariableDeclaration)
         Get
             Return m_StaticVariables
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="422" endline="427"><![CDATA[
     End Property
 
     Property TypeAttributes() As Mono.Cecil.TypeAttributes Implements IType.TypeAttributes
         Get
             Return m_CecilType.Attributes
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="428" endline="432"><![CDATA[
         Set(ByVal value As Mono.Cecil.TypeAttributes)
             m_CecilType.Attributes = value
             m_CecilType.IsBeforeFieldInit = m_BeforeFieldInit
             m_CecilType.IsSerializable = m_Serializable
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="433" endline="438"><![CDATA[
     End Property
 
     ReadOnly Property IsInterface() As Boolean
         Get
             Return TypeOf Me Is InterfaceDeclaration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="439" endline="444"><![CDATA[
     End Property
 
     ReadOnly Property IsClass() As Boolean
         Get
             Return TypeOf Me Is ClassDeclaration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="445" endline="450"><![CDATA[
     End Property
 
     ReadOnly Property IsDelegate() As Boolean
         Get
             Return TypeOf Me Is DelegateDeclaration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="451" endline="456"><![CDATA[
     End Property
 
     ReadOnly Property IsValueType() As Boolean
         Get
             Return TypeOf Me Is StructureDeclaration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="457" endline="462"><![CDATA[
     End Property
 
     ReadOnly Property IsEnum() As Boolean
         Get
             Return TypeOf Me Is EnumDeclaration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="463" endline="468"><![CDATA[
     End Property
 
     ReadOnly Property IsModule() As Boolean
         Get
             Return TypeOf Me Is ModuleDeclaration
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="469" endline="479"><![CDATA[
     End Property
 
     ReadOnly Property HasInstanceConstructors() As Boolean
         Get
             Dim ctors As Generic.List(Of ConstructorDeclaration)
             ctors = Me.Members.GetSpecificMembers(Of ConstructorDeclaration)()
             For Each item As ConstructorDeclaration In ctors
                 If item.IsShared = False Then Return True
             Next
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="480" endline="487"><![CDATA[
     End Property
 
     ReadOnly Property HasSharedConstantFields() As Boolean
         Get
             Dim ctors As Generic.List(Of ConstantDeclaration)
             ctors = Me.Members.GetSpecificMembers(Of ConstantDeclaration)()
             Return ctors.Count > 0
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="488" endline="504"><![CDATA[
     End Property
 
     ReadOnly Property HasSharedFieldsWithInitializers() As Boolean
         Get
             Dim ctors As Generic.List(Of VariableDeclaration)
             ctors = Me.Members.GetSpecificMembers(Of VariableDeclaration)()
             For Each item As VariableDeclaration In ctors
                 If item.IsShared AndAlso item.HasInitializer Then Return True
             Next
             For Each item As VariableDeclaration In m_StaticVariables
                 If item.DeclaringMethod.IsShared AndAlso item.HasInitializer Then Return True
             Next
             For Each item As ConstantDeclaration In Members.GetSpecificMembers(Of ConstantDeclaration)()
                 If item.RequiresSharedInitialization Then Return True
             Next
             Return False
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="35" endline="37"><![CDATA[
         Get
             Return m_Typename
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="38" endline="43"><![CDATA[
     End Property
 
     ReadOnly Property ArrayTypeModifiers() As ArrayTypeModifiers
         Get
             Return m_ArrayTypeModifiers
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="44" endline="48"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="49" endline="53"><![CDATA[
 
     Sub Init(ByVal TypeName As NonArrayTypeName, ByVal ArrayTypeModifiers As ArrayTypeModifiers)
         m_TypeName = TypeName
         m_ArrayTypeModifiers = ArrayTypeModifiers
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="54" endline="62"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeName(NewParent)
 
         result.Init(m_TypeName.Clone(result), m_ArrayTypeModifiers.Clone(result))
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="63" endline="67"><![CDATA[
 
     ReadOnly Property ResolvedType() As Mono.Cecil.TypeReference
         Get
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="68" endline="81"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveTypeReferences AndAlso result
         'Not necessary.'result = m_ArrayTypeModifiers.ResolveCode AndAlso result
 
         Dim tp As Mono.Cecil.TypeReference = m_TypeName.ResolvedType
         tp = m_ArrayTypeModifiers.CreateArrayType(tp)
         m_ResolvedType = tp
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="82" endline="86"><![CDATA[
 
     ReadOnly Property Name() As String
         Get
             Return m_TypeName.Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="87" endline="91"><![CDATA[
     End Property
 
     Shared Function CanBeArrayTypeModifier(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.LParenthesis AndAlso (tm.PeekToken.Equals(KS.Comma, KS.RParenthesis))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="92" endline="95"><![CDATA[
 
     Overrides Function ToString() As String
         Return m_TypeName.ToString & m_ArrayTypeModifiers.ToString
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="96" endline="103"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\BuiltInTypeName.vb" startline="26" endline="28"><![CDATA[
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\BuiltInTypeName.vb" startline="29" endline="34"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal TypeName As KS)
         MyBase.neW(Parent)
         m_TypeName = Typename
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\BuiltInTypeName.vb" startline="35" endline="39"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As BuiltInTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Return New BuiltInTypeName(NewParent, m_TypeName)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\BuiltInTypeName.vb" startline="40" endline="44"><![CDATA[
 
     ReadOnly Property ResolvedType() As Mono.Cecil.TypeReference
         Get
             Return Compiler.TypeResolution.KeywordToType(m_TypeName)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\BuiltInTypeName.vb" startline="45" endline="54"><![CDATA[
     End Property
 
     ''' <summary>
     ''' No type references to resolve here.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\BuiltInTypeName.vb" startline="55" endline="63"><![CDATA[
 
     ''' <summary>
     ''' No code to resolve here.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\BuiltInTypeName.vb" startline="64" endline="68"><![CDATA[
 
     ReadOnly Property Name() As String
         Get
             Return m_Typename.ToString
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\BuiltInTypeName.vb" startline="69" endline="73"><![CDATA[
     End Property
 
     Shared Function IsBuiltInTypeName(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="32" endline="34"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     Private m_Special As KS = KS.None
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="35" endline="39"><![CDATA[
 
     Sub Init(ByVal TypeName As TypeName, ByVal Special As KS)
         m_TypeName = TypeName
         m_Special = Special
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="40" endline="47"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Constraint
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New Constraint(NewParent)
         If m_TypeName IsNot Nothing Then result.m_TypeName = m_TypeName.Clone(result)
         result.m_Special = m_Special
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="48" endline="52"><![CDATA[
 
     ReadOnly Property TypeName() As TypeName
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="53" endline="58"><![CDATA[
     End Property
 
     ReadOnly Property Special() As KS
         Get
             Return m_special
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="59" endline="75"><![CDATA[
     End Property
 
     ReadOnly Property SpecialConstraintAttribute() As Mono.Cecil.GenericParameterAttributes
         Get
             Select Case m_Special
                 Case KS.[New]
                     Return Mono.Cecil.GenericParameterAttributes.DefaultConstructorConstraint
                 Case KS.Class
                     Return Mono.Cecil.GenericParameterAttributes.ReferenceTypeConstraint
                 Case KS.Structure
                     Return Mono.Cecil.GenericParameterAttributes.NotNullableValueTypeConstraint
                 Case KS.None
                     Return Mono.Cecil.GenericParameterAttributes.NonVariant
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="76" endline="80"><![CDATA[
     End Property
 
     <Obsolete("No code to resolve here.")> Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="81" endline="88"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstraintList.vb" startline="27" endline="29"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Objects() As Constraint)
         MyBase.New(Parent, Objects)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstraintList.vb" startline="30" endline="38"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstraintList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstraintList(NewParent)
         For Each item As Constraint In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstraintList.vb" startline="39" endline="74"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Dim hasClass, hasStructure, hasNew As Boolean
 
         For Each constraint As Constraint In Me
             result = constraint.ResolveTypeReferences AndAlso result
             Select Case constraint.Special
                 Case KS.None
                 Case KS.Class
                     If hasClass Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC32101, Location) AndAlso result
                     End If
                     hasClass = True
                 Case KS.Structure
                     If hasStructure Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC32102, Location) AndAlso result
                     End If
                     hasStructure = True
                 Case KS.[New]
                     hasNew = True
             End Select
 
         Next
 
         If hasNew AndAlso hasStructure Then
             result = Compiler.Report.ShowMessage(Messages.VBNC32103, Location) AndAlso result
         End If
 
         If hasStructure AndAlso hasClass Then
             result = Compiler.Report.ShowMessage(Messages.VBNC32104, Location) AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="41" endline="43"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="44" endline="49"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal QualifiedIdentifier As QualifiedIdentifier, ByVal TypeArgumentList As TypeArgumentList)
         MyBase.new(Parent)
         m_QualifiedIdentifier = QualifiedIdentifier
         m_TypeArgumentList = TypeArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="50" endline="55"><![CDATA[
 
     Sub Init(ByVal ConstructedTypeName As ConstructedTypeName, ByVal QualifiedIdentifier As QualifiedIdentifier, ByVal TypeArgumentList As TypeArgumentList)
         m_ConstructedTypeName = ConstructedTypeName
         m_QualifiedIdentifier = QualifiedIdentifier
         m_TypeArgumentList = TypeArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="56" endline="60"><![CDATA[
 
     Sub Init(ByVal QualifiedIdentifier As QualifiedIdentifier, ByVal TypeArgumentList As TypeArgumentList)
         m_QualifiedIdentifier = QualifiedIdentifier
         m_TypeArgumentList = TypeArgumentList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="61" endline="67"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstructedTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstructedTypeName(NewParent)
         result.Init(m_QualifiedIdentifier.Clone(result), m_TypeArgumentList.Clone(result))
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="68" endline="72"><![CDATA[
 
     Public ReadOnly Property ConstructedTypeName() As ConstructedTypeName
         Get
             Return m_ConstructedTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="73" endline="78"><![CDATA[
     End Property
 
     ReadOnly Property OpenResolvedType() As Mono.Cecil.TypeReference
         Get
             Return m_OpenResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="79" endline="84"><![CDATA[
     End Property
 
     ReadOnly Property ClosedResolvedType() As Mono.Cecil.TypeReference
         Get
             Return m_ClosedResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="85" endline="90"><![CDATA[
     End Property
 
     ReadOnly Property TypeArgumentList() As TypeArgumentList
         Get
             Return m_TypeArgumentList
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="91" endline="96"><![CDATA[
     End Property
 
     ReadOnly Property QualifiedIdentifier() As QualifiedIdentifier
         Get
             Return m_QualifiedIdentifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="97" endline="102"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedType() As Mono.Cecil.TypeReference
         Get
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="103" endline="210"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
         If m_ConstructedTypeName IsNot Nothing Then result = m_ConstructedTypeName.ResolveTypeReferences AndAlso result
 
         If result = False Then Return False
 
         If m_ConstructedTypeName IsNot Nothing Then
             Dim cache As MemberCache
             Dim entry As MemberCacheEntry
             Dim stack As New Generic.Stack(Of QualifiedIdentifier)
             Dim argumentCount As Integer
 
             argumentCount = CecilHelper.GetGenericArguments(m_ConstructedTypeName.ResolvedType).Count
             cache = Compiler.TypeManager.GetCache(m_ConstructedTypeName.ResolvedType)
 
             Dim tmp As QualifiedIdentifier = m_QualifiedIdentifier
 
             While tmp.IsFirstQualifiedIdentifier
                 stack.Push(tmp)
                 tmp = tmp.FirstAsQualifiedIdentifier
             End While
             While tmp.IsFirstQualifiedIdentifier
                 stack.Push(tmp)
                 tmp = tmp.FirstAsQualifiedIdentifier
             End While
 
             Do
                 If tmp.IsFirstIdentifier Then
                     Dim id As Identifier = tmp.FirstAsIdentifier
                     If tmp Is m_QualifiedIdentifier AndAlso m_TypeArgumentList IsNot Nothing Then
                         argumentCount = m_TypeArgumentList.Count
                     Else
                         argumentCount = 0
                     End If
                     entry = cache.LookupFlattened(Helper.CreateGenericTypename(id.Name, argumentCount), Me.FindFirstParent_IType.CecilType)
                     If entry Is Nothing OrElse entry.Members.Count = 0 Then
                         Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                         Return False
                     ElseIf entry.Members.Count > 1 Then
                         Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                         Return False
                     Else
                         Dim memberType As Mono.Cecil.TypeReference = TryCast(entry.Members(0), Mono.Cecil.TypeReference)
                         If memberType IsNot Nothing Then
                             Dim nextCache As MemberCache
 
                             nextCache = Compiler.TypeManager.GetCache(memberType)
                             argumentCount += CecilHelper.GetGenericArguments(memberType).Count
 
 
                             cache = nextCache
                         Else
                             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                             Return False
                         End If
                     End If
                 ElseIf tmp.IsFirstGlobal Then
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     Return False
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Internal compiler error.")
                     Return False
                 End If
 
                 If stack.Count = 0 Then Exit Do
                 tmp = stack.Pop
             Loop While True
 
             Dim nextCacheGenericInstance As Mono.Cecil.GenericInstanceType
             nextCacheGenericInstance = TryCast(cache.Type, Mono.Cecil.GenericInstanceType)
             If m_TypeArgumentList IsNot Nothing AndAlso nextCacheGenericInstance IsNot Nothing Then
                 Dim gi As New Mono.Cecil.GenericInstanceType(nextCacheGenericInstance.ElementType)
                 For i As Integer = 0 To nextCacheGenericInstance.GenericArguments.Count - 1
                     gi.GenericArguments.Add(nextCacheGenericInstance.GenericArguments(i))
                 Next
                 For i As Integer = 0 To m_TypeArgumentList.Count - 1
                     gi.GenericArguments.Add(Helper.GetTypeOrTypeReference(Me.Compiler, m_TypeArgumentList(i).ResolvedType))
                 Next
                 m_ResolvedType = gi
             Else
                 m_ResolvedType = cache.Type
             End If
 
         ElseIf m_TypeArgumentList IsNot Nothing Then
             Dim nri As New TypeNameResolutionInfo(Me, Me, m_TypeArgumentList.Count)
             result = nri.Resolve AndAlso result
 
             If result = False Then Return result
 
             If nri.FoundOnlyOneObject Then
                 If nri.FoundIs(Of IType)() Then
                     m_OpenResolvedType = nri.FoundAs(Of IType).CecilType
                 ElseIf nri.FoundIs(Of Mono.Cecil.TypeReference)() Then
                     m_OpenResolvedType = nri.FoundAsType
                 Else
                     Helper.AddError(Me)
                 End If
                 m_ClosedResolvedType = Compiler.TypeManager.MakeGenericType(Me, m_OpenResolvedType, m_TypeArgumentList.ArgumentCollection)
                 m_ResolvedType = m_ClosedResolvedType
             Else
                 Helper.AddError(Me)
             End If
         Else
             Helper.Stop()
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="211" endline="218"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = VerifyConstraints() AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="219" endline="239"><![CDATA[
 
     Function VerifyConstraints() As Boolean
         Dim result As Boolean = True
 
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim git As GenericInstanceType
         Dim td As TypeDefinition
 
         git = TryCast(m_ResolvedType, GenericInstanceType)
         td = CecilHelper.FindDefinition(git)
 
         If git Is Nothing OrElse td Is Nothing Then Return True
 
         parameters = td.GenericParameters
         arguments = git.GenericArguments
 
         result = Helper.VerifyConstraints(Me, parameters, arguments)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="240" endline="244"><![CDATA[
 
     ReadOnly Property Name() As String
         Get
             Return m_QualifiedIdentifier.Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="33" endline="35"><![CDATA[
         Get
             Return m_Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="36" endline="54"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedType IsNot Nothing Then Return True
 
         If m_TypeArity > 0 Then
             Dim qi As QualifiedIdentifier = DirectCast(m_Name, QualifiedIdentifier)
             result = qi.ResolveAsTypeName(False, m_TypeArity) AndAlso result
 
             If result Then m_ResolvedType = qi.ResolvedType
         Else
             result = m_Name.ResolveTypeReferences AndAlso result
             If result Then m_ResolvedType = DirectCast(m_Name, TypeName).ResolvedType
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="55" endline="58"><![CDATA[
 
     Sub New(ByVal Parent As GetTypeExpression)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="59" endline="62"><![CDATA[
 
     Sub Init(ByVal Name As TypeName)
         m_Name = Name
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="63" endline="67"><![CDATA[
 
     Sub Init(ByVal Name As QualifiedIdentifier, ByVal TypeArity As Integer)
         m_Name = Name
         m_TypeArity = TypeArity
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="68" endline="73"><![CDATA[
 
     ReadOnly Property ResolvedType() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_ResolvedType IsNot Nothing)
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="74" endline="78"><![CDATA[
     End Property
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return ResolveTypeReferences()
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsAliasClause.vb" startline="36" endline="38"><![CDATA[
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsAliasClause.vb" startline="39" endline="44"><![CDATA[
     End Property
 
     ReadOnly Property Second() As ImportsNamespaceClause
         Get
             Return m_second
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsAliasClause.vb" startline="45" endline="49"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsAliasClause.vb" startline="50" endline="54"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal Second As ImportsNamespaceClause)
         m_Identifier = Identifier
         m_Second = Second
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsAliasClause.vb" startline="55" endline="65"><![CDATA[
 
     ''' <summary>
     ''' The imported namespace or type name.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property NamespaceClause() As ImportsNamespaceClause
         Get
             Return m_Second
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsAliasClause.vb" startline="66" endline="71"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Helper.Assert(m_Second IsNot Nothing)
         Return m_Second.ResolveCode(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsAliasClause.vb" startline="72" endline="82"><![CDATA[
 
     ''' <summary>
     ''' The alias
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             Return m_Identifier.Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsAliasClause.vb" startline="83" endline="87"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.IsIdentifier AndAlso tm.PeekToken.Equals(KS.Equals)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsAliasClause.vb" startline="88" endline="91"><![CDATA[
 
     Shared Function IsMe(ByVal str As String) As Boolean
         Return str.Contains("=")
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="30" endline="32"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="33" endline="36"><![CDATA[
 
     Sub Init(ByVal Clause As ImportsAliasClause)
         m_Clause = Clause
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="37" endline="40"><![CDATA[
 
     Sub Init(ByVal Clause As ImportsNamespaceClause)
         m_Clause = Clause
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="41" endline="44"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_Clause.ResolveCode(Info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="45" endline="49"><![CDATA[
 
     ReadOnly Property IsAliasClause() As Boolean
         Get
             Return TypeOf m_Clause Is ImportsAliasClause
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="50" endline="55"><![CDATA[
     End Property
 
     ReadOnly Property IsNamespaceClause() As Boolean
         Get
             Return TypeOf m_Clause Is ImportsNamespaceClause
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="56" endline="61"><![CDATA[
     End Property
 
     ReadOnly Property AsAliasClause() As ImportsAliasClause
         Get
             Return DirectCast(m_Clause, ImportsAliasClause)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="62" endline="67"><![CDATA[
     End Property
 
     ReadOnly Property AsNamespaceClause() As ImportsNamespaceClause
         Get
             Return DirectCast(m_Clause, ImportsNamespaceClause)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="68" endline="77"><![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             If Me.IsAliasClause Then
                 Return Me.AsAliasClause.Name
             Else
                 Return ""
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="78" endline="80"><![CDATA[
         Set(ByVal value As String)
             Throw New InternalException
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="27" endline="39"><![CDATA[
     Function GetNamespaces(ByVal FromWhere As BaseObject, ByVal Name As String) As Generic.List(Of [Namespace])
         Dim result As New Generic.List(Of [Namespace])
         For Each imp As ImportsClause In Me
             If imp.IsNamespaceClause AndAlso imp.AsNamespaceClause.IsNamespaceImport Then
                 Dim ns As [Namespace]
                 ns = FromWhere.Compiler.TypeManager.Namespaces.Item(imp.AsNamespaceClause.NamespaceImported, Name)
                 If ns IsNot Nothing Then
                     result.Add(ns)
                 End If
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="40" endline="66"><![CDATA[
 
     ''' <summary>
     ''' Looks up all the modules imported by all the imports clauses.
     ''' </summary>
     ''' <param name="FromWhere"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetModules(ByVal FromWhere As BaseObject) As TypeList
         Dim result As TypeList = Nothing
         For Each imp As ImportsClause In Me
             If imp.IsNamespaceClause Then
                 Dim ns As ImportsNamespaceClause = imp.AsNamespaceClause
                 If ns.IsTypeImport Then
                     'A type cannot contain a module, nothing to do here.
                 ElseIf ns.IsNamespaceImport Then
                     Dim modules As TypeDictionary = FromWhere.Compiler.TypeManager.GetModulesByNamespace(ns.NamespaceImported.ToString)
                     If modules IsNot Nothing AndAlso modules.Count > 0 Then
                         If result Is Nothing Then result = New TypeList
                         result.AddRange(modules.TypesAsArray)
                     End If
                 Else
                     Continue For 'This import was not resolved correctly, don't use it.
                 End If
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="67" endline="70"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="71" endline="97"><![CDATA[
 
     ''' <summary>
     ''' Returns true if a clause with the same imported namespace or alias exists.
     ''' </summary>
     ''' <param name="Clause"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Exists(ByVal Clause As ImportsClause) As Boolean
         For Each cl As ImportsClause In Me
             If cl.IsNamespaceClause Then
                 If Clause.IsNamespaceClause Then
                     If Helper.CompareName(cl.AsNamespaceClause.Name, Clause.AsNamespaceClause.Name) Then
                         Return True
                     End If
                 End If
             ElseIf cl.IsAliasClause Then
                 If Clause.IsAliasClause Then
                     If Helper.CompareName(cl.AsAliasClause.Name, Clause.AsAliasClause.Name) Then
                         Return True
                     End If
                 End If
             Else
                 Throw New InternalException(Me)
             End If
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="38" endline="40"><![CDATA[
         Get
             Return m_Object
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="41" endline="45"><![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="46" endline="50"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Location As Span)
         MyBase.New(Parent, Location)
         'Helper.Assert(Me.HasLocation)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="51" endline="54"><![CDATA[
 
     Sub Init(ByVal Obj As BaseObject)
         m_Object = Obj
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="55" endline="59"><![CDATA[
 
     ReadOnly Property NamespaceImported() As [Namespace]
         Get
             Return m_Namespace
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="60" endline="65"><![CDATA[
     End Property
 
     ReadOnly Property TypeImported() As Mono.Cecil.TypeReference 'Descriptor
         Get
             Return m_Type
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="66" endline="71"><![CDATA[
     End Property
 
     ReadOnly Property IsNamespaceImport() As Boolean
         Get
             Return m_Namespace IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="72" endline="77"><![CDATA[
     End Property
 
     ReadOnly Property IsTypeImport() As Boolean
         Get
             Return m_Type IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="78" endline="112"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim nri As TypeNameResolutionInfo
         If IsConstructedTypeName Then
             nri = New TypeNameResolutionInfo(AsConstructedTypeName, Me)
         ElseIf IsQualifiedIdentifier Then
             nri = New TypeNameResolutionInfo(AsQualifiedIdentifier, Me)
         Else
             Throw New InternalException(Me)
         End If
         nri.IsImportsResolution = True
         result = nri.Resolve AndAlso result
 
         If nri.FoundOnlyOneObject = False Then
             'Do not propage error condition here, since this message is a warning
 			Compiler.Report.ShowMessage(Messages.VBNC40056, Location, Name)
             Return True
         End If
 
         If nri.FoundIs(Of [Namespace])() Then
             m_Namespace = nri.FoundAs(Of [Namespace])()
         ElseIf nri.FoundIs(Of TypeDeclaration)() Then
             m_Type = nri.FoundAs(Of TypeDeclaration).CecilType
         ElseIf nri.FoundIs(Of Type)() Then
             m_Type = nri.FoundAs(Of Mono.Cecil.TypeReference)()
         ElseIf nri.FoundIs(Of Mono.Cecil.TypeReference)() Then
             m_Type = nri.FoundAs(Of Mono.Cecil.TypeReference)()
         Else
             Helper.AddError(Me)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="113" endline="117"><![CDATA[
 
     Private ReadOnly Property AsConstructedTypeName() As ConstructedTypeName
         Get
             Return DirectCast(m_Object, ConstructedTypeName)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="118" endline="123"><![CDATA[
     End Property
 
     Private ReadOnly Property AsQualifiedIdentifier() As QualifiedIdentifier
         Get
             Return DirectCast(m_Object, QualifiedIdentifier)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="124" endline="129"><![CDATA[
     End Property
 
     Private ReadOnly Property IsQualifiedIdentifier() As System.Boolean
         Get
             Return TypeOf m_Object Is QualifiedIdentifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="130" endline="135"><![CDATA[
     End Property
 
     Private ReadOnly Property IsConstructedTypeName() As System.Boolean
         Get
             Return TypeOf m_Object Is ConstructedTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="136" endline="153"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The namespace or type that is imported.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             If IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             ElseIf IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsStatement.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsStatement.vb" startline="32" endline="35"><![CDATA[
 
     Sub New(ByVal Parent As Compiler)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsStatement.vb" startline="36" endline="39"><![CDATA[
 
     Sub Init(ByVal Clauses As ImportsClauses)
         m_Clauses = Clauses
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsStatement.vb" startline="40" endline="43"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_Clauses.ResolveCode(info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsStatement.vb" startline="44" endline="48"><![CDATA[
 
     ReadOnly Property Clauses() As ImportsClauses
         Get
             Return m_Clauses
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsStatement.vb" startline="49" endline="53"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.Imports
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\MissingType.vb" startline="25" endline="28"><![CDATA[
     Sub New(ByVal Compiler As Compiler)
         MyBase.New("Missing", "")
         m_Compiler = Compiler
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\MissingType.vb" startline="29" endline="32"><![CDATA[
 
     Shared Operator =(ByVal t As Mono.Cecil.TypeReference, ByVal m As MissingType) As Boolean
         Return Helper.CompareType(m, t)
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\MissingType.vb" startline="33" endline="36"><![CDATA[
 
     Shared Operator <>(ByVal t As Mono.Cecil.TypeReference, ByVal m As MissingType) As Boolean
         Return Not t = m
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\MissingType.vb" startline="37" endline="40"><![CDATA[
 
     Shared Operator =(ByVal m As MissingType, ByVal t As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(m, t)
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\MissingType.vb" startline="41" endline="44"><![CDATA[
 
     Shared Operator <>(ByVal m As MissingType, ByVal t As Mono.Cecil.TypeReference) As Boolean
         Return Not m = t
     End Operator
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Nameables.vb" startline="29" endline="32"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
         m_Index = New Index(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Nameables.vb" startline="33" endline="45"><![CDATA[
 
 
     ''' <summary>
     ''' Looks up the type of the specified index. 
     ''' </summary>
     ''' <param name="Index"></param>
     ''' <value></value>
     ''' <remarks></remarks>
     ''' <exception cref="IndexOutOfRangeException">If the Index is invalid.</exception>
     Default Shadows ReadOnly Property Item(ByVal Index As Integer) As T
         Get
             Return DirectCast(MyBase.Item(Index), T)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Nameables.vb" startline="46" endline="57"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns true if contains (a) type(s) with this name.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete()> _
     Shadows Function ContainsName(ByVal Name As String) As Boolean
         Return m_Index.ContainsName(Name)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Nameables.vb" startline="58" endline="73"><![CDATA[
 
     ''' <summary>
     ''' Adds a new object to this collection.
     ''' </summary>
     ''' <param name="Base"></param>
     ''' <remarks></remarks>
     Shadows Sub Add(ByVal Base As T)
         'This is a workaround for #463303
         Dim B As INameable = DirectCast(Base, INameable)
 
 #If DEBUG Then
         If B.Name = "" Then Throw New InternalException(Base)
 #End If
         MyBase.Add(Base)
         m_Index.Add(Base)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Nameables.vb" startline="74" endline="79"><![CDATA[
 
     Shadows Sub AddRange(ByVal Base As Generic.IEnumerable(Of T))
         For Each obj As T In Base
             Add(obj)
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Nameables.vb" startline="80" endline="84"><![CDATA[
 
     ReadOnly Property Index() As Index
         Get
             Return m_Index
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="39" endline="41"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="42" endline="45"><![CDATA[
 
     Sub Init(ByVal TypeName As SimpleTypeName)
         m_TypeName = TypeName
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="46" endline="49"><![CDATA[
 
     Sub Init(ByVal TypeName As ConstructedTypeName)
         m_TypeName = TypeName
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="50" endline="54"><![CDATA[
 
     Property IsNullable As Boolean
         Get
             Return m_IsNullable
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="55" endline="57"><![CDATA[
         Set(ByVal value As Boolean)
             m_IsNullable = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="58" endline="72"><![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As NonArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New NonArrayTypeName(NewParent)
         result.IsNullable = IsNullable
         If Me.IsConstructedTypeName Then
             result.Init(Me.AsConstructedTypeName.Clone)
         ElseIf Me.IsSimpleTypeName Then
             result.Init(Me.AsSimpleTypeName.Clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="73" endline="77"><![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Return ToString()
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="78" endline="83"><![CDATA[
     End Property
 
     ReadOnly Property IsResolved() As Boolean
         Get
             Return m_ResolvedType IsNot Nothing
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="84" endline="89"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedType() As Mono.Cecil.TypeReference 'Descriptor
         Get
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="90" endline="95"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedCecilType() As Mono.Cecil.TypeReference
         Get
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="96" endline="107"><![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             ElseIf Me.IsSimpleTypeName Then
                 Return AsSimpleTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="108" endline="113"><![CDATA[
     End Property
 
     ReadOnly Property IsConstructedTypeName() As Boolean
         Get
             Return TypeOf m_TypeName Is ConstructedTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="114" endline="119"><![CDATA[
     End Property
 
     ReadOnly Property AsConstructedTypeName() As ConstructedTypeName
         Get
             Return DirectCast(m_TypeName, ConstructedTypeName)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="120" endline="125"><![CDATA[
     End Property
 
     ReadOnly Property IsSimpleTypeName() As Boolean
         Get
             Return TypeOf m_TypeName Is SimpleTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="126" endline="131"><![CDATA[
     End Property
 
     ReadOnly Property AsSimpleTypeName() As SimpleTypeName
         Get
             Return DirectCast(m_TypeName, SimpleTypeName)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="132" endline="137"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As ParsedObject
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="138" endline="172"><![CDATA[
     End Property
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Dim stn As SimpleTypeName = TryCast(m_TypeName, SimpleTypeName)
         Dim ctn As ConstructedTypeName = TryCast(m_TypeName, ConstructedTypeName)
 
         If stn IsNot Nothing Then
             result = stn.ResolveTypeReferences AndAlso result
             m_ResolvedType = stn.ResolvedType
         ElseIf ctn IsNot Nothing Then
             result = ctn.ResolveTypeReferences AndAlso result
             m_ResolvedType = ctn.ResolvedType
         Else
             Throw New InternalException(Me)
         End If
 
         If m_IsNullable Then
             If CecilHelper.IsValueType(m_ResolvedType) = False Then
                 Dim gp As GenericParameter = TryCast(m_ResolvedType, GenericParameter)
                 If gp Is Nothing OrElse gp.HasNotNullableValueTypeConstraint = False Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC33101, Me.Location, Helper.ToString(Me, m_ResolvedType))
                 End If
             End If
 
             Dim git As New GenericInstanceType(Compiler.TypeCache.System_Nullable1)
             git.GenericArguments.Add(m_ResolvedType)
             m_ResolvedType = git
         End If
 
         Helper.Assert(m_ResolvedType IsNot Nothing OrElse result = False)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="173" endline="190"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim stn As SimpleTypeName
         Dim ctn As ConstructedTypeName
 
         stn = TryCast(m_TypeName, SimpleTypeName)
         If stn IsNot Nothing Then
             result = stn.ResolveCode(Info) AndAlso result
         Else
             ctn = TryCast(m_TypeName, ConstructedTypeName)
             If ctn IsNot Nothing Then
                 result = ctn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="191" endline="200"><![CDATA[
 
     Overrides Function ToString() As String
         If IsConstructedTypeName Then
             Return AsConstructedTypeName.Name
         ElseIf IsSimpleTypeName Then
             Return AsSimpleTypeName.Name
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\RestorablePoint.vb" startline="23" endline="25"><![CDATA[
     Sub New(ByVal Index As Integer)
         Me.Index = Index
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="32" endline="34"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="35" endline="39"><![CDATA[
 
     Sub Init(ByVal QualifiedIdentifier As QualifiedIdentifier)
         Helper.Assert(QualifiedIdentifier IsNot Nothing)
         m_TypeName = QualifiedIdentifier
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="40" endline="44"><![CDATA[
 
     Sub Init(ByVal BuiltInTypeName As BuiltInTypeName)
         Helper.Assert(BuiltInTypeName IsNot Nothing)
         m_TypeName = BuiltInTypeName
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="45" endline="57"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SimpleTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleTypeName(NewParent)
         If Me.IsBuiltInTypeName Then
             result.Init(Me.AsBuiltInTypeName.Clone(result))
         ElseIf Me.IsQualifiedIdentifier Then
             result.Init(Me.AsQualifiedIdentifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="58" endline="64"><![CDATA[
 
     Friend Sub ChangeQualifiedIdentifier(ByVal qi As QualifiedIdentifier)
         Helper.Assert(IsQualifiedIdentifier)
         'Helper.Assert(AsQualifiedIdentifier.Second IsNot Nothing)
         Helper.Assert(AsQualifiedIdentifier.First Is qi)
         m_TypeName = qi
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="65" endline="69"><![CDATA[
 
     ReadOnly Property TypeParameter() As TypeParameter
         Get
             Return m_TypeParameter
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="70" endline="75"><![CDATA[
     End Property
 
     ReadOnly Property ResolvedType() As Mono.Cecil.TypeReference 'Descriptor
         Get
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="76" endline="85"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         If m_TypeParameter IsNot Nothing Then result = m_TypeParameter.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="86" endline="89"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return ResolveTypeReferences(False)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="90" endline="118"><![CDATA[
 
     Overloads Function ResolveTypeReferences(ByVal AsAttributeTypeName As Boolean) As Boolean
         Dim result As Boolean = True
         If IsBuiltInTypeName Then
             'Not necessary.'result = AsBuiltInTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = AsBuiltInTypeName.ResolvedType
         ElseIf IsQualifiedIdentifier Then
             Dim tpParam As Mono.Cecil.GenericParameter
             result = AsQualifiedIdentifier.ResolveAsTypeName(AsAttributeTypeName) AndAlso result
             If result = False Then Return result
             m_ResolvedType = AsQualifiedIdentifier.ResolvedType
             tpParam = TryCast(m_ResolvedType, Mono.Cecil.GenericParameter)
             If tpParam IsNot Nothing Then
                 m_TypeParameter = DirectCast(tpParam.Annotations(Compiler), TypeParameter)
             End If
             If result = False Then Return result
             If Not TypeOf m_ResolvedType Is Mono.Cecil.GenericInstanceType AndAlso m_ResolvedType.GenericParameters.Count > 0 Then
                 Dim tmp As New Mono.Cecil.GenericInstanceType(m_ResolvedType)
                 For i As Integer = 0 To m_ResolvedType.GenericParameters.Count - 1
                     tmp.GenericArguments.Add(m_ResolvedType.GenericParameters(i))
                 Next
                 m_ResolvedType = tmp
             End If
         Else
             Throw New InternalException(Me)
         End If
         Return result
 
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="119" endline="123"><![CDATA[
 
     ReadOnly Property TypeName() As ParsedObject
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="124" endline="135"><![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsBuiltInTypeName Then
                 Return AsBuiltInTypeName.Name
             ElseIf IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="136" endline="141"><![CDATA[
     End Property
 
     ReadOnly Property IsBuiltInTypeName() As Boolean
         Get
             Return TypeOf m_TypeName Is BuiltInTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="142" endline="147"><![CDATA[
     End Property
 
     ReadOnly Property AsBuiltInTypeName() As BuiltInTypeName
         Get
             Return DirectCast(m_TypeName, BuiltInTypeName)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="148" endline="153"><![CDATA[
     End Property
 
     ReadOnly Property IsQualifiedIdentifier() As Boolean
         Get
             Return TypeOf m_TypeName Is QualifiedIdentifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="154" endline="159"><![CDATA[
     End Property
 
     ReadOnly Property AsQualifiedIdentifier() As QualifiedIdentifier
         Get
             Return DirectCast(m_TypeName, QualifiedIdentifier)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="35" endline="37"><![CDATA[
         Get
             Return m_Current
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="38" endline="43"><![CDATA[
         Set(ByVal value As Token)
             m_Previous = m_Current
             m_Current = value
 
             'Console.WriteLine("Setting currenttoken to
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="44" endline="49"><![CDATA[
     End Property
 
     ReadOnly Property CurrentTypeCharacter() As TypeCharacters.Characters
         Get
             Return m_Reader.currenttypecharacter
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="50" endline="55"><![CDATA[
     End Property
 
     ReadOnly Property Reader() As Scanner
         Get
             Return m_Reader
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="56" endline="60"><![CDATA[
     End Property
 
     Function CurrentToken() As Token
         Return Current
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="61" endline="65"><![CDATA[
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return m_Reader.GetCurrentLocation
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="66" endline="79"><![CDATA[
     End Property
 
     Function PeekToken(Optional ByVal Jump As Integer = 1) As Token
         Helper.Assert(Jump >= -1)
         If Jump = -1 Then Return m_Previous
         If Jump = 0 Then Return CurrentToken()
         If m_TokenList.Count = 0 Then
             m_TokenList.Add(CurrentToken)
         End If
         For i As Integer = m_TokenList.Count To m_CurrentIndex + Jump
             m_TokenList.Add(m_Reader.Next())
         Next
         Return m_TokenList(m_CurrentIndex + Jump)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="80" endline="108"><![CDATA[
 
     Sub NextToken()
         If m_RestorePoints > 0 Then
             m_CurrentIndex += 1
             Helper.Assert(m_CurrentIndex <= m_TokenList.Count)
             If m_CurrentIndex = m_TokenList.Count Then
                 Current = m_Reader.Next
                 m_TokenList.Add(Current)
             Else
                 Current = m_TokenList(m_CurrentIndex)
             End If
         ElseIf m_TokenList.Count > 0 Then
             'Peeked items.
             m_CurrentIndex += 1
             Helper.Assert(m_CurrentIndex <= m_TokenList.Count)
             If m_CurrentIndex = m_TokenList.Count Then
 #If DEBUG Then
                 'Console.WriteLine("Reached a total of " & m_TokenList.Count.ToString & " tokens in restorable list")
 #End If
                 Current = m_Reader.Next
                 m_TokenList.Clear()
                 m_CurrentIndex = 0
             Else
                 Current = m_TokenList(m_CurrentIndex)
             End If
         Else
             Current = m_Reader.Next()
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="109" endline="115"><![CDATA[
 
     Sub NextToken(ByVal Jump As Integer)
         Helper.Assert(Jump >= 0)
         For i As Integer = 1 To Jump
             NextToken()
         Next
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="116" endline="124"><![CDATA[
 
     Function GetRestorablePoint() As RestorablePoint
         m_RestorePoints += 1
         If m_TokenList.Count = 0 Then
             m_TokenList.Add(CurrentToken)
         End If
         'Console.WriteLine(" Creating restore point
         Return New RestorablePoint(m_CurrentIndex)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="125" endline="131"><![CDATA[
 
     Sub RestoreToPoint(ByVal Point As RestorablePoint)
         m_CurrentIndex = Point.Index
         Current = m_TokenList(m_CurrentIndex)
         'Console.WriteLine(" Restored to
         IgnoreRestoredPoint()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="132" endline="135"><![CDATA[
 
     Sub IgnoreRestoredPoint()
         m_RestorePoints -= 1
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="136" endline="149"><![CDATA[
 
 #If DEBUG Then
     ReadOnly Property TokenSequence() As String
         Get
             Const Range As Integer = 3
             Dim result As String = ""
             For i As Integer = -Range To Range
                 'If Me.IsTokenValid(Me.iCurrentToken + i) Then
                 'result &= "(" & i.ToString & ")
                 result &= Me.PeekToken(i).ToString & " "
                 'End If
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="150" endline="159"><![CDATA[
     End Property
 #End If
 
     Function AcceptSequence(ByVal ParamArray ks As KS()) As Boolean
         For i As Integer = 0 To ks.GetUpperBound(0)
             If Me.PeekToken(i).Equals(ks(i)) = False Then Return False
         Next
         Me.NextToken(ks.GetUpperBound(0) + 1)
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="160" endline="164"><![CDATA[
 
     Sub New(ByVal Compiler As Compiler, ByVal Reader As Scanner)
         MyBase.New(Compiler)
     Private m_TokenList As New Generic.List(Of Token)
     Private m_RestorePoints As Integer
     Private m_CurrentIndex As Integer
     Private m_Current As Token
     Private m_Previous As Token
 
     Private Property Current() As Token
         Get
             Return m_Current
         End Get
         Set(ByVal value As Token)
             m_Previous = m_Current
             m_Current = value
 
             'Console.WriteLine("Setting currenttoken to
         End Set
     End Property
 
     ReadOnly Property CurrentTypeCharacter() As TypeCharacters.Characters
         Get
             Return m_Reader.currenttypecharacter
         End Get
     End Property
 
     ReadOnly Property Reader() As Scanner
         Get
             Return m_Reader
         End Get
     End Property
 
     Function CurrentToken() As Token
         Return Current
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return m_Reader.GetCurrentLocation
         End Get
     End Property
 
     Function PeekToken(Optional ByVal Jump As Integer = 1) As Token
         Helper.Assert(Jump >= -1)
         If Jump = -1 Then Return m_Previous
         If Jump = 0 Then Return CurrentToken()
         If m_TokenList.Count = 0 Then
             m_TokenList.Add(CurrentToken)
         End If
         For i As Integer = m_TokenList.Count To m_CurrentIndex + Jump
             m_TokenList.Add(m_Reader.Next())
         Next
         Return m_TokenList(m_CurrentIndex + Jump)
     End Function
 
     Sub NextToken()
         If m_RestorePoints > 0 Then
             m_CurrentIndex += 1
             Helper.Assert(m_CurrentIndex <= m_TokenList.Count)
             If m_CurrentIndex = m_TokenList.Count Then
                 Current = m_Reader.Next
                 m_TokenList.Add(Current)
             Else
                 Current = m_TokenList(m_CurrentIndex)
             End If
         ElseIf m_TokenList.Count > 0 Then
             'Peeked items.
             m_CurrentIndex += 1
             Helper.Assert(m_CurrentIndex <= m_TokenList.Count)
             If m_CurrentIndex = m_TokenList.Count Then
 #If DEBUG Then
                 'Console.WriteLine("Reached a total of " & m_TokenList.Count.ToString & " tokens in restorable list")
 #End If
                 Current = m_Reader.Next
                 m_TokenList.Clear()
                 m_CurrentIndex = 0
             Else
                 Current = m_TokenList(m_CurrentIndex)
             End If
         Else
             Current = m_Reader.Next()
         End If
     End Sub
 
     Sub NextToken(ByVal Jump As Integer)
         Helper.Assert(Jump >= 0)
         For i As Integer = 1 To Jump
             NextToken()
         Next
     End Sub
 
     Function GetRestorablePoint() As RestorablePoint
         m_RestorePoints += 1
         If m_TokenList.Count = 0 Then
             m_TokenList.Add(CurrentToken)
         End If
         'Console.WriteLine(" Creating restore point
         Return New RestorablePoint(m_CurrentIndex)
     End Function
 
     Sub RestoreToPoint(ByVal Point As RestorablePoint)
         m_CurrentIndex = Point.Index
         Current = m_TokenList(m_CurrentIndex)
         'Console.WriteLine(" Restored to
         IgnoreRestoredPoint()
     End Sub
 
     Sub IgnoreRestoredPoint()
         m_RestorePoints -= 1
     End Sub
 
 #If DEBUG Then
     ReadOnly Property TokenSequence() As String
         Get
             Const Range As Integer = 3
             Dim result As String = ""
             For i As Integer = -Range To Range
                 'If Me.IsTokenValid(Me.iCurrentToken + i) Then
                 'result &= "(" & i.ToString & ")
                 result &= Me.PeekToken(i).ToString & " "
                 'End If
             Next
             Return result
         End Get
     End Property
 #End If
 
     Function AcceptSequence(ByVal ParamArray ks As KS()) As Boolean
         For i As Integer = 0 To ks.GetUpperBound(0)
             If Me.PeekToken(i).Equals(ks(i)) = False Then Return False
         Next
         Me.NextToken(ks.GetUpperBound(0) + 1)
         Return True
     End Function
 
     Sub New(ByVal Compiler As Compiler, ByVal Reader As Scanner)
         MyBase.New(Compiler)
         m_Reader = Reader
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="165" endline="169"><![CDATA[
 
     ReadOnly Property IsCurrentTokenValid() As Boolean
         Get
             Return Token.IsSomething(Current)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="170" endline="186"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Skips tokens until a newline is found.
     ''' Returns if CodeEnd of EndOfFile found.
     ''' </summary>
     ''' <param name="EatNewLine">Eat the newline character?</param>
     ''' <param name="ReportError">Report the error "End of line expected."? (Always shown if this paramter is true.</param>
     ''' <remarks></remarks>
     Sub GotoNewline(ByVal EatNewLine As Boolean, Optional ByVal ReportError As Boolean = False)
         If ReportError Then Compiler.Report.ShowMessage(Messages.VBNC90018, CurrentLocation)
 
         Do Until CurrentToken.IsEndOfLine
             NextToken()
         Loop
         Do Until CurrentToken.IsEndOfLine
             NextToken()
         Loop
         If EatNewLine AndAlso CurrentToken.IsEndOfFile = False Then NextToken()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="187" endline="196"><![CDATA[
     ''' <summary>
     ''' If not the current token is a newline, then shows a message ("End of line expected")
     ''' and eats the newline. After this sub the current token will be the first after the newline
     ''' Returns false if first symbol isn't a newline
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindNewLineAndShowError() As Boolean
         Return FindNewLineAndShowError(Messages.VBNC90018)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="197" endline="213"><![CDATA[
 
     ''' <summary>
     ''' If not the current token is a newline, then shows the specified message
     ''' and eats the newline. After this sub the current token will be the first after the newline
     ''' Returns false if first symbol isn't a newline
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindNewLineAndShowError(ByVal Message As Messages) As Boolean
         If Not AcceptNewLine() Then
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             GotoNewline(True, False)
             Return False
         Else
             Return True
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="214" endline="222"><![CDATA[
 
     ''' <summary>
     ''' Skips token until it finds any of the specified tokens or KS.EndOfFile or KS.CodeEnd
     ''' </summary>
     ''' <param name="Specials"></param>
     ''' <remarks></remarks>
     Sub GotoAny(ByVal ParamArray Specials As KS())
         GotoAny(False, Specials)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="223" endline="241"><![CDATA[
 
     ''' <summary>
     ''' Skips tokens until it finds any of the specified tokens.
     ''' If StopOnNewLine = True then stops also when a NewLine is found 
     ''' (the newline token is not eaten).
     ''' </summary>
     ''' <param name="StopOnNewline"></param>
     ''' <param name="Specials"></param>
     ''' <remarks></remarks>
     Sub GotoAny(ByVal StopOnNewline As Boolean, ByVal ParamArray Specials() As KS)
         Do Until (CurrentToken.Equals(Specials))
             If StopOnNewline AndAlso CurrentToken.IsEndOfLine Then
                 Return
             ElseIf CurrentToken.IsEndOfFile Then
                 Return
             End If
             NextToken()
         Loop
         Do Until (CurrentToken.Equals(Specials))
             If StopOnNewline AndAlso CurrentToken.IsEndOfLine Then
                 Return
             ElseIf CurrentToken.IsEndOfFile Then
                 Return
             End If
             NextToken()
         Loop
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="242" endline="246"><![CDATA[
 
     Sub EatNewLines()
         Do While AcceptNewLine()
         Loop
         Do While AcceptNewLine()
         Loop
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="247" endline="258"><![CDATA[
 
     ''' <summary>
     ''' Eats the current token if if coincides, if not shows a 
     ''' message "Expected
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         Return AcceptIfNotError(Special, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="259" endline="269"><![CDATA[
 
     ''' <summary>
     ''' Eats the current tokens if if coincides, if not shows a 
     ''' message "Expected
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special1 As KS, ByVal Special2 As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         Return AcceptIfNotError(Special1, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special1)) AndAlso AcceptIfNotError(Special2, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special2))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="270" endline="280"><![CDATA[
 
     ''' <summary>
     ''' If the current token is not the specified keyword / symbol, then a
     ''' InternalException is thrown. (In which case it doesn't return,
     ''' so this is not a function).
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <remarks></remarks>
     Sub AcceptIfNotInternalError(ByVal Special As KS)
         If Not Accept(Special) Then Throw New InternalException("Location
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="281" endline="284"><![CDATA[
 
     Sub AcceptIfNotInternalError(ByVal Identifier As String)
         If Not Accept(Identifier) Then Throw New InternalException("")
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="285" endline="302"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="303" endline="320"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal GotoNewline As Boolean, ByVal MessageParameters() As String) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation, MessageParameters)
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="321" endline="330"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal GotoNewline As Boolean, ByVal MessageParameter As String) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation, MessageParameter)
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="331" endline="340"><![CDATA[
     ''' <summary>
     ''' GotoNewline defaults to false for this overload.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal ParamArray MessageParameters() As String) As Boolean
         Return AcceptIfNotError(Special, Message, False, MessageParameters)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="341" endline="364"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' Accepts only newline, not endofcode, nor endoffile. 
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <param name="EOFIsError">Specifies whether to return false if the current token is EOF or not.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptNewLine(Optional ByVal GotoNewline As Boolean = False, Optional ByVal EOFIsError As Boolean = True, Optional ByVal ReportError As Boolean = False) As Boolean
         If CurrentToken.IsEndOfLine Then
             If CurrentToken.IsEndOfLineOnly Then
                 NextToken()
                 Return True
             ElseIf EOFIsError = False Then
                 Return True
             Else
                 Return False
             End If
         Else
             If GotoNewline Then Me.GotoNewline(True, ReportError)
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="365" endline="404"><![CDATA[
 
     ''' <summary>
     ''' Accepts Newline or 
     ''' If ReportError = True then
     '''  - reports an error if currenttoken != ks.colon AND currenttoken != newline
     '''    doesn't matter if OnlyColon is true or not.
     ''' </summary>
     ''' <param name="OnlyColon">Set to true to only accept colon, not even NewLine</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptEndOfStatement(Optional ByVal OnlyColon As Boolean = False, Optional ByVal ReportError As Boolean = False) As Boolean
         Dim result As Boolean = True
         If OnlyColon Then
             result = Accept(KS.Colon)
             If ReportError AndAlso result = False AndAlso CurrentToken.IsEndOfLineOnly = False Then
 #If DEBUG Then
                 System.Console.WriteLine("Found
 #End If
                 Compiler.Report.ShowMessage(Messages.VBNC30205, CurrentLocation)
             End If
             Return result
         Else
             If CurrentToken.IsEndOfLineOnly OrElse CurrentToken() = KS.Colon Then
                 Do
                     NextToken()
                 Loop While CurrentToken.IsEndOfLineOnly OrElse CurrentToken.Equals(KS.Colon)
                 Return True
             ElseIf CurrentToken.IsEndOfFile Then
                 Return True
             Else
                 If ReportError Then
 #If DEBUG Then
                     System.Console.WriteLine("Found
 #End If
                     Compiler.Report.ShowMessage(Messages.VBNC30205, CurrentLocation)
                 End If
                 Return False
             End If
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="405" endline="413"><![CDATA[
 
     Function AcceptEndOfFile() As Boolean
         If CurrentToken.IsEndOfFile Then
             NextToken()
             Return True
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="414" endline="428"><![CDATA[
 
     <Obsolete()> _
     Function AcceptIdentifier(ByRef result As Token) As Boolean
         Dim tmp As Token = CurrentToken()
         If CurrentToken.IsIdentifier Then
             result = CurrentToken()
             If tmp.IsIdentifier = False Then Throw New InternalException("Not an identifier?????")
             If CurrentToken.IsIdentifier = False Then Throw New InternalException("Not an identifier???")
             If result.IsIdentifier = False Then Throw New InternalException("Not an identifier?")
             NextToken()
             Return True
         Else
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="429" endline="445"><![CDATA[
 
     ''' <summary>
     ''' Returns true if the current token is an identifier
     ''' and advances to the next token.
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIdentifier(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIdentifier Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="446" endline="455"><![CDATA[
 
     Function AcceptStringLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsStringLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="456" endline="471"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIntegerLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIntegerLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="472" endline="488"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="489" endline="506"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special1 As KS, ByVal Special2 As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special1) AndAlso PeekToken.Equals(Special2) Then
             NextToken()
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
 
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="507" endline="519"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="520" endline="529"><![CDATA[
 
     Function AcceptAny(ByVal ParamArray Keywords() As KS) As Boolean
         Dim i As Integer
         For i = 0 To Keywords.Length - 1
             If Accept(Keywords(i)) Then
                 Return True
             End If
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="530" endline="537"><![CDATA[
     Function AcceptAll(ByVal ParamArray Specials() As KS) As Boolean
         Dim i As Integer
         AcceptAll = True
         For i = 0 To Specials.Length - 1
             AcceptAll = PeekToken(i).Equals(Specials(i)) AndAlso AcceptAll
         Next
         If AcceptAll Then NextToken(Specials.Length)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArgumentList.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArgumentList.vb" startline="32" endline="42"><![CDATA[
 
     ReadOnly Property ArgumentCollection() As Mono.Collections.Generic.Collection(Of TypeReference)
         Get
             If m_ArgumentCollection Is Nothing Then
                 m_ArgumentCollection = New Mono.Collections.Generic.Collection(Of TypeReference)()
                 For i As Integer = 0 To Count - 1
                     m_ArgumentCollection.Add(Item(i).ResolvedType)
                 Next
             End If
             Return m_ArgumentCollection
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArgumentList.vb" startline="43" endline="52"><![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeArgumentList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeArgumentList(NewParent)
         For Each item As TypeName In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="32" endline="34"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="35" endline="44"><![CDATA[
 
     ReadOnly Property AsTypeArray() As Type()
         Get
             Dim t As Type = GetType(System.Collections.Generic.Dictionary(Of ,))
             Dim result(m_TypeParameters.Length - 1) As Type
             For i As Integer = 0 To result.Length - 1
                 'result(i) = m_TypeParameters(i).Parameters
             Next
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="45" endline="49"><![CDATA[
     End Property
 
     Sub Init(ByVal TypeParameters() As TypeParameters)
         m_TypeParameters = TypeParameters
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="50" endline="54"><![CDATA[
 
     ReadOnly Property TypeParameters() As TypeParameters()
         Get
             Return m_TypeParameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="55" endline="67"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeParameters.Length - 1
             If m_TypeParameters(i) IsNot Nothing Then
                 result = m_TypeParameters(i).ResolveTypeReferences() AndAlso result
             End If
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="30" endline="32"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     Private m_Clauses As New Generic.List(Of NonArrayTypeName)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.new(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="33" endline="36"><![CDATA[
 
     Sub Init(ByVal Clauses As Generic.List(Of NonArrayTypeName))
         m_Clauses = Clauses
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="37" endline="40"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return Helper.ResolveTypeReferencesCollection(m_Clauses)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="41" endline="45"><![CDATA[
 
     ReadOnly Property Clauses() As Generic.List(Of NonArrayTypeName)
         Get
             Return m_Clauses
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="46" endline="50"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.Implements
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="36" endline="45"><![CDATA[
     Sub New(ByVal Parent As ParsedObject, Optional ByVal NonArrayTypeName As NonArrayTypeName = Nothing, Optional ByVal ArrayTypeName As ArrayTypeName = Nothing)
         MyBase.New(Parent)
         If NonArrayTypeName IsNot Nothing AndAlso ArrayTypeName IsNot Nothing Then
             Throw New ArgumentException("Both NonArrayTypeName and ArrayTypeName cannot be specified.")
         ElseIf NonArrayTypeName IsNot Nothing Then
             Init(NonArrayTypeName)
         ElseIf ArrayTypeName IsNot Nothing Then
             Init(ArrayTypeName)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="46" endline="50"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Type As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
         m_ResolvedType = Type
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="51" endline="54"><![CDATA[
 
     Sub Init(ByVal NonArrayTypeName As NonArrayTypeName)
         m_TypeName = NonArrayTypeName
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="55" endline="58"><![CDATA[
 
     Sub Init(ByVal ArrayTypeName As ArrayTypeName)
         m_TypeName = ArrayTypeName
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="59" endline="62"><![CDATA[
 
     Sub Init(ByVal Type As Mono.Cecil.TypeReference)
         m_ResolvedType = Type
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="63" endline="75"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeName(NewParent)
         If Me.IsNonArrayTypeName Then
             result.Init(Me.AsNonArrayTypeName.clone)
         ElseIf Me.IsArrayTypeName Then
             result.Init(Me.AsArrayTypeName.clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="76" endline="82"><![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             If TypeOf m_TypeName Is NonArrayTypeName Then Return AsNonArrayTypeName.Name
             If TypeOf m_TypeName Is ArrayTypeName Then Return AsArrayTypeName.Name
             Return DirectCast(m_TypeName, INameable).Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="83" endline="88"><![CDATA[
     End Property
 
     ReadOnly Property IsNonArrayTypeName() As Boolean
         Get
             Return TypeOf m_TypeName Is NonArrayTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="89" endline="94"><![CDATA[
     End Property
 
     ReadOnly Property IsArrayTypeName() As Boolean
         Get
             Return TypeOf m_TypeName Is ArrayTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="95" endline="101"><![CDATA[
     End Property
 
     ReadOnly Property AsNonArrayTypeName() As NonArrayTypeName
         Get
             Helper.Assert(IsNotArray)
             Return DirectCast(m_TypeName, NonArrayTypeName)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="102" endline="108"><![CDATA[
     End Property
 
     ReadOnly Property AsArrayTypeName() As ArrayTypeName
         Get
             Helper.Assert(IsArray)
             Return DirectCast(m_TypeName, ArrayTypeName)
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="109" endline="114"><![CDATA[
     End Property
 
     ReadOnly Property IsNotArray() As Boolean
         Get
             Return TypeOf m_TypeName Is NonArrayTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="115" endline="125"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns true if this type is an array.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsArray() As Boolean
         Get
             Return TypeOf m_TypeName Is ArrayTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="126" endline="131"><![CDATA[
     End Property
 
     ReadOnly Property TypeName() As ParsedObject
         Get
             Return m_TypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="132" endline="142"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The resolved type of the TypeName.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public ReadOnly Property ResolvedType() As Mono.Cecil.TypeReference
         Get
             Return m_ResolvedType
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="143" endline="161"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim atn As ArrayTypeName
         Dim natn As NonArrayTypeName
 
         atn = TryCast(m_TypeName, ArrayTypeName)
         If atn IsNot Nothing Then
             result = atn.ResolveCode(Info) AndAlso result
         Else
             natn = TryCast(m_TypeName, NonArrayTypeName)
             If natn IsNot Nothing Then
                 result = natn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="162" endline="181"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If Me.IsArrayTypeName Then
             result = Me.AsArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = Me.AsArrayTypeName.ResolvedType
         ElseIf Me.IsNonArrayTypeName Then
             result = Me.AsNonArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = Me.AsNonArrayTypeName.ResolvedType
         ElseIf m_ResolvedType Is Nothing Then
             Throw New InternalException(Me)
         End If
 
         If result = False Then Return result
 
         Helper.Assert(m_ResolvedType IsNot Nothing)
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="32" endline="34"><![CDATA[
         Get
             Return m_IsAttributeTypeName
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="35" endline="37"><![CDATA[
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="38" endline="48"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="49" endline="54"><![CDATA[
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="55" endline="72"><![CDATA[
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="73" endline="77"><![CDATA[
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="78" endline="85"><![CDATA[
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="86" endline="89"><![CDATA[
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="90" endline="98"><![CDATA[
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="99" endline="104"><![CDATA[
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="105" endline="110"><![CDATA[
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="111" endline="113"><![CDATA[
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="114" endline="119"><![CDATA[
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="120" endline="122"><![CDATA[
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="123" endline="129"><![CDATA[
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="130" endline="135"><![CDATA[
 
     Sub New(ByVal Name As QualifiedIdentifier, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
 
     Sub New(ByVal Name As QualifiedIdentifier, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="136" endline="141"><![CDATA[
 
     Sub New(ByVal Name As Identifier, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
 
     Sub New(ByVal Name As QualifiedIdentifier, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
 
     Sub New(ByVal Name As Identifier, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="142" endline="147"><![CDATA[
 
     Sub New(ByVal Name As GlobalExpression, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
 
     Sub New(ByVal Name As QualifiedIdentifier, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
 
     Sub New(ByVal Name As Identifier, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
 
     Sub New(ByVal Name As GlobalExpression, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="148" endline="222"><![CDATA[
 
     Function Resolve() As Boolean
         Dim result As Boolean = True
         Dim tmp As TypeNameResolutionInfo
 
         Dim glob As GlobalExpression = TryCast(Name, GlobalExpression)
         Dim id As Identifier = TryCast(Name, Identifier)
         Dim qi As QualifiedIdentifier = TryCast(Name, QualifiedIdentifier)
         Dim ctn As ConstructedTypeName = TryCast(Name, ConstructedTypeName)
 
         If ctn IsNot Nothing Then
             qi = ctn.QualifiedIdentifier
             Helper.Assert(TypeArgumentCount > 0)
         End If
 
         If qi IsNot Nothing Then
             If qi.IsFirstQualifiedIdentifier Then
                 If Token.IsSomething(qi.Second) Then
                     tmp = New TypeNameResolutionInfo(qi.FirstAsQualifiedIdentifier, FromWhere, 0)
                 Else
                     tmp = New TypeNameResolutionInfo(qi.FirstAsQualifiedIdentifier, FromWhere, Me.TypeArgumentCount)
                     tmp.IsAttributeTypeName = Me.IsAttributeTypeName
                 End If
                 'Helper.Assert(qi.Second IsNot Nothing) 'A qualified identifier can perfectly be only an identifier
             ElseIf qi.IsFirstGlobal Then
                 Helper.Assert(TypeArgumentCount = 0)
                 tmp = New TypeNameResolutionInfo(qi.FirstAsGlobal, FromWhere)
                 'Helper.Assert(qi.Second IsNot Nothing)
             ElseIf qi.IsFirstIdentifier Then
                 If Token.IsSomething(qi.Second) = False Then
                     tmp = New TypeNameResolutionInfo(qi.FirstAsIdentifier, FromWhere, Me.TypeArgumentCount)
                     tmp.IsAttributeTypeName = Me.IsAttributeTypeName
                 Else
                     tmp = New TypeNameResolutionInfo(qi.FirstAsIdentifier, FromWhere, 0)
                 End If
             Else
                 Throw New InternalException(FromWhere)
             End If
 
             tmp.IsImportsResolution = Me.IsImportsResolution
             result = tmp.Resolve AndAlso result
             If result = False Then Return result
 
             If Token.IsSomething(qi.Second) = False Then
                 Me.m_FoundObjects = tmp.m_FoundObjects
             Else
                 If Me.IsAttributeTypeName Then
                     result = ResolveQualifiedName(tmp, qi.Second.IdentiferOrKeywordIdentifier & "Attribute", qi.Second.IdentiferOrKeywordIdentifier, Me.TypeArgumentCount) AndAlso result
                 Else
                     result = ResolveQualifiedName(tmp, qi.Second.IdentiferOrKeywordIdentifier, Nothing, Me.TypeArgumentCount) AndAlso result
                 End If
             End If
         ElseIf glob IsNot Nothing Then
             m_FoundObjects.Add(glob)
             result = True
         ElseIf id IsNot Nothing Then
             If Me.IsImportsResolution Then
                 result = Me.CheckOutermostNamespace(id.Name, Me.TypeArgumentCount) AndAlso result
             Else
                 Dim names() As String
                 If Me.IsAttributeTypeName Then
                     names = New String() {id.Name & "Attribute", id.Name}
                 Else
                     names = New String() {id.Name}
                 End If
                 result = ResolveUnqualifiedName(names, Me.TypeArgumentCount) AndAlso result
             End If
         ElseIf ctn IsNot Nothing Then
             Return Name.Compiler.Report.ShowMessage(Messages.VBNC99997, Name.Location)
         Else
             Return Name.Compiler.Report.ShowMessage(Messages.VBNC99997, Name.Location)
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="223" endline="234"><![CDATA[
 
     Private Function ResolveQualifiedName(ByVal Qualifier As TypeNameResolutionInfo, ByVal R1 As String, ByVal R2 As String, ByVal TypeArgumentCount As Integer) As Boolean
         Dim result As Boolean = True
 
         result = ResolveQualifiedNameInternal(Qualifier, R1, R2 Is Nothing, TypeArgumentCount) AndAlso result
 
         If result = False AndAlso R2 IsNot Nothing Then
             result = ResolveQualifiedNameInternal(Qualifier, R2, True, TypeArgumentCount) 'AndAlso result
         End If
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="235" endline="406"><![CDATA[
 
     Private Function ResolveQualifiedNameInternal(ByVal Qualifier As TypeNameResolutionInfo, ByVal R As String, ByVal ShowError As Boolean, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '*************************************** Qualified Name Resolution '**************************************
         '---------------------------------------------------------------------------------------------------------
         '* Given a qualified namespace or type name of the form N.R, where R is the rightmost identifier in the 
         '* qualified name, the following steps describe how to determine to which namespace or type the qualified 
         '* Name(refers)
         '**	Resolve N, which may be either a qualified or unqualified name.
         '**	If resolution of N fails, resolves to a type parameter, or does not resolve to a namespace or type, a
         '**  compile-time error occurs. If R matches the name of a namespace or type in N, then the qualified name 
         '** refers to that namespace or type.
         '**	If N contains one or more standard modules, and R matches the name of a type in exactly one standard 
         '** module, then the qualified name refers to that type. If R matches the name of types in more than one 
         '** standard module, a compile-time error occurs.
         '**	Otherwise, a compile-time error occurs. 
         ' * Note   An implication of this resolution process is that type members do not shadow namespaces or types 
         ' * when resolving namespace or type names.
         '---------------------------------------------------------------------------------------------------------
 
         Me.m_Qualifier = Qualifier
 
         If Qualifier.FoundOnlyOneObject Then
             Dim modules As TypeList = Nothing
             If Qualifier.IsGlobal Then
                 'Helper.NotImplemented()
                 If CheckOutermostNamespace(R, TypeArgumentCount) Then Return True
             ElseIf Qualifier.FoundIs(Of [Namespace])() OrElse Qualifier.FoundIs(Of ImportsClause)() Then
                 'Helper.NotImplemented()
                 '** If R matches the name of a namespace or type in N, 
                 '** then the qualified name refers to that namespace or type.
                 Dim strNS As String
 
                 If Qualifier.FoundIs(Of [Namespace])() Then
                     Dim ns As [Namespace]
                     ns = Qualifier.FoundAs(Of [Namespace])()
                     strNS = ns.FullName
                 ElseIf Qualifier.FoundIs(Of ImportsClause)() Then
                     Dim ic As ImportsClause
                     ic = Qualifier.FoundAs(Of ImportsClause)()
                     If ic.IsAliasClause Then
                         Dim ac As ImportsAliasClause = ic.AsAliasClause
                         If ac.NamespaceClause.IsNamespaceImport Then
                             Dim ns As [Namespace]
                             ns = ac.NamespaceClause.NamespaceImported
                             strNS = ns.FullName
                         ElseIf ac.NamespaceClause.IsTypeImport Then
                             strNS = ac.NamespaceClause.TypeImported.FullName
                         Else
                             Throw New InternalException(FromWhere)
                         End If
                     Else
                         Throw New InternalException(FromWhere)
                     End If
                 Else
                     Throw New InternalException(FromWhere)
                 End If
 
                 Dim nsp As [Namespace]
                 nsp = FromWhere.Compiler.TypeManager.Namespaces.FindNamespace(strNS, R)
                 If nsp IsNot Nothing Then
                     m_FoundObjects.Add(nsp)
                     Return True
                 End If
 
                 Dim types As TypeDictionary
                 types = FromWhere.Compiler.TypeManager.TypesByNamespace(strNS)
                 If types IsNot Nothing AndAlso types.Count > 0 Then
                     Dim genericName As String
                     genericName = vbnc.Helper.CreateGenericTypename(R, TypeArgumentCount)
 
                     'Dim typesByName As Generic.List(Of Mono.Cecil.TypeReference) = Nothing
                     'Dim tmp As Boolean
                     'tmp = FromWhere.Compiler.TypeManager.TypesByName.TryGetValue(genericName, typesByName)
 
                     For Each tp As Mono.Cecil.TypeReference In types.Values
                         'If TypeOf tp Is TypeDescriptor Then
                         If Helper.CompareName(tp.Name, genericName) Then
                             m_FoundObjects.Add(tp)
                         End If
                         'Else
                         'If typesByName IsNot Nothing AndAlso typesByName.Contains(tp) Then
                         '    m_FoundObjects.Add(tp)
                         'End If
                         'End If
                     Next
                     'Return True
                 End If
 
                 '**	If N contains one or more standard modules, and R matches the name of a type in 
                 '** exactly one standard module, then the qualified name refers to that type. If R 
                 '** matches the name of types in more than one standard module, a compile-time error occurs.
                 If m_FoundObjects.Count = 0 Then
                     Dim dic As TypeDictionary = FromWhere.Compiler.TypeManager.GetModulesByNamespace(strNS)
                     If dic IsNot Nothing Then
                         modules = dic.ToTypeList
                     Else
                         modules = Nothing
                     End If
                     'Return True
                 End If
 
                 'Throw New InternalException("(1) Could not resolve
 
                 'Return False
             ElseIf Qualifier.FoundIs(Of IType)() Then
                 '** If R matches the name of a namespace or type in N, 
                 '** then the qualified name refers to that namespace or type.
                 Dim tp As IType = Qualifier.FoundAs(Of IType)()
                 Dim types As Generic.List(Of IType) = tp.Members.GetSpecificMembers(Of IType)()
                 For Each t As IType In types
                     If Helper.CompareName(t.Name, R) Then
                         m_FoundObjects.Add(t)
                     End If
                 Next
 
                 '**	If N contains one or more standard modules, and R matches the name of a type in 
                 '** exactly one standard module, then the qualified name refers to that type. If R 
                 '** matches the name of types in more than one standard module, a compile-time error occurs.
                 If m_FoundObjects.Count = 0 Then
                     modules = Helper.CreateList(tp.Members.GetSpecificMembers(Of ModuleDeclaration)())
                 End If
             ElseIf Qualifier.FoundIs(Of Mono.Cecil.TypeReference)() Then
                 '** If R matches the name of a namespace or type in N, 
                 '** then the qualified name refers to that namespace or type.
                 Dim tp As Mono.Cecil.TypeReference = Qualifier.FoundAs(Of Mono.Cecil.TypeReference)()
                 Dim nestedtp As Mono.Cecil.TypeReference = CecilHelper.GetNestedType(tp, Helper.CreateGenericTypename(R, TypeArgumentCount))
 
                 If nestedtp IsNot Nothing Then m_FoundObjects.Add(nestedtp)
 
                 '**	If N contains one or more standard modules, and R matches the name of a type in 
                 '** exactly one standard module, then the qualified name refers to that type. If R 
                 '** matches the name of types in more than one standard module, a compile-time error occurs.
                 If m_FoundObjects.Count = 0 Then
                     Return Name.Compiler.Report.ShowMessage(Messages.VBNC99997, Name.Location)
                     modules = Helper.CreateList(CecilHelper.GetNestedTypes(tp))
                 End If
             Else
                 '**	If resolution of N fails, resolves to a type parameter, or does not resolve to a namespace 
                 '** or type, a compile-time error occurs.  (..)
                 If ShowError = False Then Return False
                 'Helper.AddError("(2) Could not resolve
                 Return Name.Compiler.Report.ShowMessage(Messages.VBNC99997, Name.Location)
             End If
 
             '**	If N contains one or more standard modules, and R matches the name of a type in 
             '** exactly one standard module, then the qualified name refers to that type. If R 
             '** matches the name of types in more than one standard module, a compile-time error occurs.
 
             If modules IsNot Nothing AndAlso modules.Count > 0 AndAlso CheckModules(modules, R, TypeArgumentCount) Then Return True
 
             If m_FoundObjects.Count = 0 Then
                 If ShowError = False Then Return False
 
                 If Not IsImportsResolution Then FromWhere.Compiler.Report.ShowMessage(Messages.VBNC30456, FromWhere.Location, R, Qualifier.FoundObject.ToString)
                 Return False
             ElseIf m_FoundObjects.Count > 1 Then
                 If ShowError = False Then Return False
                 Helper.AddError(Name, "Found " & m_FoundObjects.Count.ToString & " members in type or namespace '" & Qualifier.FoundObject.ToString & "'")
                 Return False
             Else
                 Return True
             End If
         Else
             '**	If resolution of N fails, (...)
             If ShowError = False Then Return False
             Helper.AddError(Name, "Qualifying member '" & Qualifier.m_Qualifier.FoundObject.ToString & "' resolves to '" & Qualifier.FoundObjects.Count.ToString & " objects" & "(R = " & R & ")")
             Return False
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="407" endline="430"><![CDATA[
 
     Private Function CheckCurrentFunctionForTypeParameters(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         Dim signature As SubSignature = Nothing
         Dim method As MethodBaseDeclaration = FromWhere.FindFirstParent(Of MethodBaseDeclaration)()
 
         If method IsNot Nothing Then
             signature = method.Signature
         Else
             Dim del As DelegateDeclaration = FromWhere.FindFirstParent(Of DelegateDeclaration)()
             If del IsNot Nothing Then
                 signature = del.Signature
             End If
         End If
 
         If signature IsNot Nothing AndAlso signature.TypeParameters IsNot Nothing Then
             Dim item As TypeParameter = signature.TypeParameters.Parameters.Item(R)
             If item IsNot Nothing Then
                 m_FoundObjects.Add(item)
                 Return True
             End If
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="431" endline="486"><![CDATA[
 
     Private Function CheckNestedTypesOrTypeParameters(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* For each nested type containing the name reference, starting from the innermost type and going to the
         '* outermost, if R matches the name of an accessible nested type or a type parameter in the current type, 
         '* then the unqualified name refers to that type or type parameter.
         '---------------------------------------------------------------------------------------------------------
 
         'SPEC OMISSION
         'Spec does not say anything about type parameters declared in a method.
         If CheckCurrentFunctionForTypeParameters(R, TypeArgumentCount) Then Return True
 
 
         Dim tp As IType = FromWhere.FindFirstParent(Of IType)()
         Dim obj As BaseObject = FromWhere
         Do
             tp = obj.FindFirstParent(Of IType)()
             If tp Is Nothing Then Exit Do
             obj = DirectCast(tp, BaseObject)
 
             'First check if there are nested types with the corresponding name.
             'Get all the members in the type corresponding to the Name
             Dim members As Generic.List(Of INameable)
             members = tp.Members.Declarations.Index.Item(vbnc.Helper.CreateGenericTypename(R, TypeArgumentCount))
             If members IsNot Nothing Then
                 Dim i As Integer = 0
                 While i <= members.Count - 1
                     Dim member As INameable = members(i)
                     'Remove all members that aren't types.
                     If TypeOf member Is IType = False Then
                         members.RemoveAt(i)
                     Else
                         i += 1
                     End If
                 End While
                 While i <= members.Count - 1
                     Dim member As INameable = members(i)
                     'Remove all members that aren't types.
                     If TypeOf member Is IType = False Then
                         members.RemoveAt(i)
                     Else
                         i += 1
                     End If
                 End While
                 If members.Count > 0 Then
                     m_FoundObjects.AddRange(members.ToArray)
                     Return True
                 End If
             End If
 
             'Then check if there are type parameters with the corresponding name
             'in the type (only if the current type is a class or a structure)
             Dim tpConstructable As IConstructable = TryCast(tp, IConstructable)
             If tpConstructable IsNot Nothing AndAlso tpConstructable.TypeParameters IsNot Nothing Then
                 Dim param As TypeParameter
                 param = tpConstructable.TypeParameters.Parameters.Item(R)
                 If param IsNot Nothing Then
                     m_FoundObjects.Add(param)
                     Return True
                 End If
             End If
         Loop
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="487" endline="528"><![CDATA[
 
     Private Function CheckOutermostNamespace(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* (...)
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '*
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         '*
         '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
         '** error occurs.
         '--------------------------------------------------------------------------------------------------------- 
 
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         Dim types As TypeDictionary = Nothing
         Dim modules As TypeList
         Dim foundType As Mono.Cecil.TypeReference
 
         Dim RName As String = Helper.CreateGenericTypename(R, TypeArgumentCount)
         foundType = FromWhere.Compiler.TypeManager.TypesByNamespace("").Item(RName)
         If foundType IsNot Nothing Then
             m_FoundObjects.Add(foundType)
         End If
         If TypeArgumentCount = 0 AndAlso FromWhere.Compiler.TypeManager.Namespaces.IsNamespace(R, True) Then
             m_FoundObjects.Add(FromWhere.Compiler.TypeManager.Namespaces.Item(R))
         End If
 
         If m_FoundObjects.Count > 0 Then Return True
 
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
 
         If types Is Nothing Then Return False 'There are no types (nor modules) in the outermost namespace.
 
         modules = FromWhere.Compiler.TypeManager.GetModulesByNamespace("").ToTypeList
 
         If CheckModules(modules, R, TypeArgumentCount) Then Return True
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="529" endline="559"><![CDATA[
 
     Private Function CheckModules(ByVal moduletypes As TypeList, ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '**	(...), and R matches the name of an 
         '** accessible nested type in exactly one standard module, (...)
 #If DEBUG Then
         For Each t As Mono.Cecil.TypeReference In moduletypes
             Helper.Assert(Helper.IsModule(FromWhere.Compiler, t))
         Next
 #End If
         Dim allModuleTypes As New Generic.List(Of Mono.Cecil.TypeReference) 'Descriptor)
 
         For Each t As Mono.Cecil.TypeReference In moduletypes
             Dim tFound As Mono.Cecil.TypeReference
             tFound = CecilHelper.GetNestedType(t, R)
             If tFound IsNot Nothing Then
                 allModuleTypes.Add(tFound)
             End If
         Next
 
         If allModuleTypes.Count = 1 Then
             m_FoundObjects.Add(allModuleTypes.Item(0))
             Return True
         ElseIf allModuleTypes.Count > 1 Then
             '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
             '** error occurs.
             Helper.AddError(Name)
             Return False
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="560" endline="615"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="R"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function CheckNamespace(ByVal R As String, ByVal Types As TypeDictionary, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* (...)
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '*
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         '*
         '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
         '** error occurs.
         '---------------------------------------------------------------------------------------------------------
 
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         Dim RName As String = vbnc.Helper.CreateGenericTypename(R, TypeArgumentCount)
 
         Dim foundType As Mono.Cecil.TypeReference
 
         foundType = Types.Item(RName)
         If foundType IsNot Nothing Then
             m_FoundObjects.Add(foundType)
             Return True
         End If
 
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         Dim foundModules As Generic.List(Of Mono.Cecil.TypeReference)
         foundModules = Helper.FilterToModules(FromWhere.Compiler, Types)
         If foundModules.Count > 0 Then
             Dim typesInAllModules As New Generic.List(Of Mono.Cecil.TypeReference)
             For Each [module] As Mono.Cecil.TypeReference In foundModules
                 Dim typeInCurrentModule As Mono.Cecil.TypeReference
                 typeInCurrentModule = CecilHelper.GetNestedType([module], RName)
                 If typeInCurrentModule IsNot Nothing Then typesInAllModules.Add(typeInCurrentModule)
             Next
             If typesInAllModules.Count = 1 Then
                 m_FoundObjects.AddRange(typesInAllModules.ToArray)
                 Return True
             ElseIf typesInAllModules.Count > 1 Then
                 '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
                 '** error occurs.
                 Helper.AddError(Name)
                 Return False
             End If
         End If
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="616" endline="666"><![CDATA[
 
     Private Function CheckNamespaces(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* For each nested namespace containing the name reference, starting from the innermost namespace and 
         '* going to the outermost namespace, do the following
         '** (...)
         '---------------------------------------------------------------------------------------------------------
         'Check all the namespaces up to the outermost namespace (not including)
         Dim declaringtype As TypeDeclaration = FromWhere.FindFirstParent(Of TypeDeclaration)()
         Dim ns As String
         If declaringtype IsNot Nothing Then
             ns = declaringtype.Namespace
         Else
             ns = FromWhere.Compiler.CommandLine.RootNamespace
         End If
         If ns Is Nothing Then ns = String.Empty
         Dim current As BaseObject = FromWhere
         'Dim dotR As String = "." & R
         'Dim nsDotR As String = ns & dotR
         Do
             If CheckNamespace(R, FromWhere.Compiler.TypeManager.GetTypesByNamespace(ns), TypeArgumentCount) Then Return True
 
             If ns.Length > R.Length + 1 AndAlso ns.EndsWith(R, Helper.StringComparison) AndAlso ns(ns.Length - R.Length - 1) = "."c Then
                 m_FoundObjects.Add(FromWhere.Compiler.TypeManager.Namespaces(ns))
                 Return True
             End If
 
             If ns <> String.Empty AndAlso TypeArgumentCount = 0 Then
                 Dim nSpace As [Namespace]
                 nSpace = FromWhere.Compiler.TypeManager.Namespaces.FindNamespace(ns, R)
                 If nSpace IsNot Nothing Then
                     m_FoundObjects.Add(nSpace)
                     Return True
                 End If
             End If
 
             If Helper.CompareName(ns, R) Then
                 m_FoundObjects.Add(FromWhere.Compiler.TypeManager.Namespaces(ns))
                 Return True
             End If
             ns = vbnc.Helper.GetNamespaceParent(ns)
             'nsDotR = ns & dotR
         Loop Until ns Is Nothing
 
         'Check the outermost namespace
         'First the current compiling outermost namespace
         If CheckNamespace(R, FromWhere.Compiler.TypeManager.GetTypesByNamespace(String.Empty), TypeArgumentCount) Then Return True
 
         'then all the namespaces in the referenced assemblies
         Return CheckOutermostNamespace(R, TypeArgumentCount)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="667" endline="687"><![CDATA[
 
     Private Function CheckImportsAlias(ByVal R As String, ByVal [Imports] As ImportsClauses, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* If the source file has one or more import aliases, and R matches the name of one of them, then 
         '* the unqualified name refers to that import alias.
         '---------------------------------------------------------------------------------------------------------
         ' (...)
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more import aliases, and R matches the name of one of 
         '* them, then the unqualified name refers to that import alias.
         '---------------------------------------------------------------------------------------------------------
         For Each import As ImportsClause In [Imports]
             If import.IsAliasClause Then
                 If Helper.CompareName(import.AsAliasClause.Name, R) Then
                     m_FoundObjects.Add(import)
                     Return True
                 End If
             End If
         Next
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="688" endline="792"><![CDATA[
 
     Private Function CheckImports(ByVal R As String, ByVal [Imports] As ImportsClauses, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '*	If the source file containing the name reference has one or more imports
         '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
         '** that type. If R matches the name of an accessible type in more than one import and all are not the 
         '** same entity, a compile-time error occurs.
         '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
         '** namespace. If R matches the name of a namespace in more than one import and all are not the same entity, a 
         '** compile-time error occurs.
         '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible 
         '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches 
         '** the name of accessible nested types in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         ' (...)
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more imports
         '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
         '** that type. If R matches the name of an accessible type in more than one import, a compile-time error 
         '** occurs.
         '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
         '** namespace. If R matches the name of a namespace in more than one import, a compile-time error occurs.
         '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible
         '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches the        '** name of accessible nested types in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         Dim nsclauses As New Generic.List(Of ImportsNamespaceClause)
         For Each imp As ImportsClause In [Imports]
             If imp.IsNamespaceClause Then nsclauses.Add(imp.AsNamespaceClause)
         Next
 
         Dim tpFound As New Generic.List(Of Object)
         Dim genericR As String = Helper.CreateGenericTypename(R, TypeArgumentCount)
         '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
         '** that type. If R matches the name of an accessible type in more than one import, a compile-time error 
         '** occurs.
 
         For Each nsimp As ImportsNamespaceClause In nsclauses
             If nsimp.IsTypeImport Then
                 Dim tp As Mono.Cecil.TypeReference
                 tp = CecilHelper.GetNestedType(nsimp.TypeImported, genericR)
                 If tp IsNot Nothing Then tpFound.Add(tp)
             ElseIf nsimp.IsNamespaceImport Then
                 Dim nsName As String = nsimp.NamespaceImported.FullName
                 If FromWhere.Compiler.TypeManager.TypesByNamespace.ContainsKey(nsName) Then
                     Dim foundType As Mono.Cecil.TypeReference
                     foundType = FromWhere.Compiler.TypeManager.TypesByNamespace(nsName).Item(genericR)
                     If foundType IsNot Nothing Then tpFound.Add(foundType)
                 End If
             Else
                 Continue For
             End If
         Next
         If tpFound.Count = 1 Then
             m_FoundObjects.Add(tpFound(0))
             Return True
         ElseIf tpFound.Count > 0 Then
             Helper.AddError(Name)
             Return False
         End If
 
         '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
         '** namespace. If R matches the name of a namespace in more than one import, a compile-time error occurs.
         'Helper.Stop()
         For Each nsimp As ImportsNamespaceClause In nsclauses
             If nsimp.IsNamespaceImport Then
                 Dim nsName As String = nsimp.NamespaceImported.FullName
                 Dim nsCombined As String = String.Concat(nsName, ".", Helper.CreateGenericTypename(R, TypeArgumentCount))
                 If FromWhere.Compiler.TypeManager.Namespaces.ContainsKey(nsCombined) Then
                     tpFound.Add(FromWhere.Compiler.TypeManager.Namespaces(nsCombined))
                 End If
             ElseIf nsimp.IsTypeImport Then
                 'Skip this
             Else
                 Continue For
             End If
         Next
         If tpFound.Count = 1 Then
             m_FoundObjects.Add(tpFound(0))
             Return True
         ElseIf tpFound.Count > 0 Then
             Helper.AddError(Name)
             Return False
         End If
 
         '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible
         '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches the                 '** name of accessible nested types in more than one standard module, a compile-time error occurs.
         'Helper.Stop()
         Dim modules As New TypeList
         For Each nsimp As ImportsNamespaceClause In nsclauses
             If nsimp.IsTypeImport Then
                 Dim tp As Mono.Cecil.TypeReference
                 tp = CecilHelper.GetNestedType(nsimp.TypeImported, genericR)
                 If tp IsNot Nothing AndAlso Helper.IsModule(FromWhere.Compiler, tp) Then modules.Add(tp)
             ElseIf nsimp.IsNamespaceImport Then
                 Dim nsName As String = nsimp.NamespaceImported.FullName
                 Dim importedModules As TypeDictionary = FromWhere.Compiler.TypeManager.GetModulesByNamespace(nsName)
                 If importedModules IsNot Nothing Then modules.AddRange(importedModules.ToTypeList)
             Else
                 Continue For
             End If
         Next
         If CheckModules(modules, R, TypeArgumentCount) Then Return True
 
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="793" endline="882"><![CDATA[
 
     Private Function ResolveUnqualifiedName(ByVal Rs As String(), ByVal TypeArgumentCount As Integer) As Boolean
 
         For Each R As String In Rs
             '---------------------------------------------------------------------------------------------------------
             ' Given an unqualified name R, the following steps describe how to determine to which namespace or type an 
             ' unqualified name refers
             '---------------------------------------------------------------------------------------------------------
 
             '---------------------------------------------------------------------------------------------------------
             '* For each nested type containing the name reference, starting from the innermost type and going to the
             '* outermost, if R matches the name of an accessible nested type or a type parameter in the current type, 
             '* then the unqualified name refers to that type or type parameter.
             '---------------------------------------------------------------------------------------------------------
             If CheckNestedTypesOrTypeParameters(R, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* For each nested namespace containing the name reference, starting from the innermost namespace and 
             '* going to the outermost namespace, do the following
             '*
             '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
             '** unqualified name refers to that type or nested namespace.
             '*
             '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
             '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
             '*
             '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
             '** error occurs.
             '---------------------------------------------------------------------------------------------------------
             If CheckNamespaces(R, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* If the source file has one or more import aliases, and R matches the name of one of them, then 
             '* the unqualified name refers to that import alias.
             '---------------------------------------------------------------------------------------------------------
             Helper.Assert(FromWhere IsNot Nothing)
             'Helper.Assert(FromWhere.HasLocation)
             Helper.Assert(FromWhere.File IsNot Nothing)
             Helper.Assert(FromWhere.File.Imports IsNot Nothing)
 
             If CheckImportsAlias(R, FromWhere.File.Imports, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '*	If the source file containing the name reference has one or more imports
             '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
             '** that type. If R matches the name of an accessible type in more than one import and all are not the 
             '** same entity, a compile-time error occurs.
             '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
             '** namespace. If R matches the name of a namespace in more than one import and all are not the same entity, a 
             '** compile-time error occurs.
             '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible 
             '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches 
             '** the name of accessible nested types in more than one standard module, a compile-time error occurs.
             '---------------------------------------------------------------------------------------------------------
             If CheckImports(R, FromWhere.File.Imports, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* If the compilation environment defines one or more import aliases, and R matches the name of one of 
             '* them, then the unqualified name refers to that import alias.
             '---------------------------------------------------------------------------------------------------------
             If CheckImportsAlias(R, FromWhere.Compiler.CommandLine.Imports.Clauses, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* If the compilation environment defines one or more imports
             '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
             '** that type. If R matches the name of an accessible type in more than one import, a compile-time error 
             '** occurs.
             '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
             '** namespace. If R matches the name of a namespace in more than one import, a compile-time error occurs.
             '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible
             '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches the                 
             '** name of accessible nested types in more than one standard module, a compile-time error occurs.
             '---------------------------------------------------------------------------------------------------------
             If CheckImports(R, FromWhere.Compiler.CommandLine.Imports.Clauses, TypeArgumentCount) Then Return True
         Next
         '---------------------------------------------------------------------------------------------------------
         '* Otherwise, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
 
         FromWhere.Compiler.Report.ShowMessage(Messages.VBNC30451, FromWhere.Location, Rs(0))
 
         '---------------------------------------------------------------------------------------------------------
         '* Note   
         '* An implication of this resolution process is that type members do not shadow namespaces or types 
         '* when resolving namespace or type names.
         '* If the type name is a constructed type name (i.e. it includes a type argument list), then only types 
         '* with the same arity as the type argument list are matched.
         '---------------------------------------------------------------------------------------------------------
         Return False
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="34" endline="36"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="37" endline="65"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         Helper.Assert(m_Identifier IsNot Nothing)
 
         If m_CecilBuilder Is Nothing Then
             Dim p As BaseObject = Me.Parent
             Dim owner As Mono.Cecil.IGenericParameterProvider = Nothing
             While p IsNot Nothing AndAlso owner Is Nothing
                 Dim tD As TypeDeclaration = TryCast(p, TypeDeclaration)
                 Dim mD As MethodBaseDeclaration = TryCast(p, MethodBaseDeclaration)
 
                 If tD IsNot Nothing Then
                     owner = tD.CecilType
                     Exit While
                 ElseIf mD IsNot Nothing Then
                     owner = mD.CecilBuilder
                     Exit While
                 Else
                     p = p.Parent
                 End If
             End While
             While p IsNot Nothing AndAlso owner Is Nothing
                 Dim tD As TypeDeclaration = TryCast(p, TypeDeclaration)
                 Dim mD As MethodBaseDeclaration = TryCast(p, MethodBaseDeclaration)
 
                 If tD IsNot Nothing Then
                     owner = tD.CecilType
                     Exit While
                 ElseIf mD IsNot Nothing Then
                     owner = mD.CecilBuilder
                     Exit While
                 Else
                     p = p.Parent
                 End If
             End While
             Helper.Assert(owner IsNot Nothing)
             m_CecilBuilder = New Mono.Cecil.GenericParameter(m_Identifier.Identifier, owner)
             m_CecilBuilder.Annotations.Add(Compiler, Me)
             owner.GenericParameters.Add(m_CecilBuilder)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="66" endline="70"><![CDATA[
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.GenericParameter
         Get
             Return m_CecilBuilder
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="71" endline="79"><![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameter
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameter(NewParent)
         result.m_Identifier = m_Identifier
         If m_TypeParameterConstraints IsNot Nothing Then result.m_TypeParameterConstraints = m_TypeParameterConstraints.Clone(result)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="80" endline="96"><![CDATA[
 
     Shared Function Clone(ByVal Builder As Mono.Cecil.GenericParameter, ByVal Owner As Mono.Cecil.IGenericParameterProvider, ByVal Position As Integer) As Mono.Cecil.GenericParameter
         Dim result As New Mono.Cecil.GenericParameter(Builder.Name, Owner)
 
         For i As Integer = 0 To Builder.Constraints.Count - 1
             result.Constraints.Add(Builder.Constraints(i))
         Next
 
         result.HasDefaultConstructorConstraint = Builder.HasDefaultConstructorConstraint
         result.HasNotNullableValueTypeConstraint = Builder.HasNotNullableValueTypeConstraint
         result.HasReferenceTypeConstraint = Builder.HasReferenceTypeConstraint
         result.IsContravariant = Builder.IsContravariant
         result.IsCovariant = Builder.IsCovariant
         result.IsNonVariant = Builder.IsNonVariant
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="97" endline="101"><![CDATA[
 
     Property Identifier() As Identifier
         Get
             Return m_Identifier
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="102" endline="106"><![CDATA[
         Set(ByVal value As Identifier)
             Helper.Assert(value IsNot Nothing)
             Helper.Assert(m_Identifier Is Nothing)
             m_Identifier = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="107" endline="112"><![CDATA[
     End Property
 
     ReadOnly Property TypeParameterConstraintsNullable() As TypeParameterConstraints
         Get
             Return m_TypeParameterConstraints
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="113" endline="121"><![CDATA[
     End Property
 
     Property TypeParameterConstraints() As TypeParameterConstraints
         Get
             If m_TypeParameterConstraints Is Nothing Then
                 m_TypeParameterConstraints = New TypeParameterConstraints(Me)
             End If
             Return m_TypeParameterConstraints
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="122" endline="126"><![CDATA[
         Set(ByVal value As TypeParameterConstraints)
             Helper.Assert(value IsNot Nothing)
             Helper.Assert(m_TypeParameterConstraints Is Nothing)
             m_TypeParameterConstraints = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="127" endline="132"><![CDATA[
     End Property
 
     Property GenericParameterPosition() As Integer
         Get
             Return m_GenericParameterPosition
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="133" endline="135"><![CDATA[
         Set(ByVal value As Integer)
             m_GenericParameterPosition = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="136" endline="141"><![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             Return m_Identifier.Name
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="142" endline="144"><![CDATA[
         Set(ByVal value As String)
             m_Identifier.Name = value
         End Set
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="145" endline="155"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameterConstraints IsNot Nothing Then
             result = m_TypeParameterConstraints.ResolveTypeReferences AndAlso result
             result = DefineParameterConstraints() AndAlso result
         End If
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="156" endline="161"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="162" endline="174"><![CDATA[
 
     ReadOnly Property GenericParameterAttributes() As Mono.Cecil.GenericParameterAttributes
         Get
             Dim result As Mono.Cecil.GenericParameterAttributes
 
             If m_TypeParameterConstraints IsNot Nothing Then
                 For i As Integer = 0 To m_TypeParameterConstraints.Constraints.Count - 1
                     result = result Or m_TypeParameterConstraints.Constraints(i).SpecialConstraintAttribute
                 Next
             End If
 
             Return result
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="175" endline="216"><![CDATA[
     End Property
 
     Function DefineParameterConstraints() As Boolean
         Dim result As Boolean = True
         Dim attributes As Mono.Cecil.GenericParameterAttributes
 
         If m_Defined Then Return True
         m_Defined = True
 
         attributes = GenericParameterAttributes
 
         If m_TypeParameterConstraints IsNot Nothing Then
             Dim interfaces As New Generic.List(Of Mono.Cecil.TypeReference)
             Dim basetype As Mono.Cecil.TypeReference = Nothing
             For Each constraint As Constraint In m_TypeParameterConstraints.Constraints
                 If constraint.TypeName IsNot Nothing Then
                     If Helper.IsInterface(Compiler, constraint.TypeName.ResolvedType) Then
                         interfaces.Add(constraint.TypeName.ResolvedType)
                     Else
                         If basetype IsNot Nothing Then
                             result = Helper.AddError(Me) AndAlso result
                             result = False
                         Else
                             basetype = constraint.TypeName.ResolvedType
                         End If
                     End If
                 End If
             Next
             If basetype IsNot Nothing Then
                 basetype = Helper.GetTypeOrTypeBuilder(Compiler, basetype)
                 m_CecilBuilder.Constraints.Add(Helper.GetTypeOrTypeReference(Compiler, basetype))
             End If
             If interfaces.Count > 0 Then
                 For i As Integer = 0 To interfaces.Count - 1
                     m_CecilBuilder.Constraints.Add(Helper.GetTypeOrTypeReference(Compiler, interfaces(i)))
                 Next
             End If
         End If
 
         m_CecilBuilder.Attributes = CType(attributes, Mono.Cecil.GenericParameterAttributes)
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="29" endline="31"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="32" endline="35"><![CDATA[
 
     Sub Init(ByVal ConstraintList As ConstraintList)
         m_ConstraintList = ConstraintList
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="36" endline="53"><![CDATA[
 
     ''' <summary>
     ''' Might very well be nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ClassConstraint() As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Nothing
         For Each constraint As Constraint In m_ConstraintList
             If constraint.Special = KS.None Then
                 If CecilHelper.IsClass(constraint.TypeName.ResolvedType) Then
                     Helper.Assert(result Is Nothing)
                     result = constraint.TypeName.ResolvedType
                 End If
             End If
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="54" endline="60"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterConstraints
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterConstraints(NewParent)
         result.Init(m_ConstraintList.clone(result))
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="61" endline="65"><![CDATA[
 
     ReadOnly Property Constraints() As ConstraintList
         Get
             Return m_Constraintlist
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="66" endline="70"><![CDATA[
     End Property
 
     <Obsolete("No code to resolve here.")> Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="71" endline="78"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ConstraintList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="79" endline="82"><![CDATA[
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.As
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="28" endline="30"><![CDATA[
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="31" endline="36"><![CDATA[
 
     Shadows Sub Add(ByVal Item As TypeParameter)
         If Me.List.Contains(Item) Then
             Throw New InternalException
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="37" endline="46"><![CDATA[
 
     Function AsTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To Me.Count - 1
             result(i) = Item(i).CecilBuilder
         Next
 
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="47" endline="55"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterList(NewParent)
         For Each item As TypeParameter In Me
             result.Add(item.clone(result))
         Next
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameters.vb" startline="28" endline="28"><![CDATA[
     Private m_TypeParameters As New TypeParameterList(Me)
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameters.vb" startline="29" endline="34"><![CDATA[
 
     Function Clone() As TypeParameters
         Dim result As New TypeParameters()
         result.Parameters.AddRange(m_TypeParameters.Clone())
         Return result
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameters.vb" startline="35" endline="39"><![CDATA[
 
     ReadOnly Property Parameters() As TypeParameterList
         Get
             Return m_TypeParameters
         End Get
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameters.vb" startline="40" endline="44"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_TypeParameters.ResolveCode(info)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameters.vb" startline="45" endline="48"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Return m_TypeParameters.ResolveTypeReferences
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameters.vb" startline="49" endline="52"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameters.vb" startline="53" endline="58"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         m_TypeParameters.Initialize(Me)
     End Sub
]]></source>
</source_elements></project>
