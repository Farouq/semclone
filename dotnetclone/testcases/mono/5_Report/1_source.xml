<clones  ngroups="301">
<clone_group groupid="1" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1553" endline="1626">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < byte.MinValue || Value > byte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < sbyte.MinValue || Value > sbyte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (float) char.MinValue || Value > (float) char.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1676" endline="1749">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (double) char.MinValue || Value > (double) char.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="2" nfragments="7" Csharpe_files="0" vb_files="7" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="74" endline="125">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U8(Info, expType)
             Case TypeCode.uInt64
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U8_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_u8_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U8_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U8_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt64_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="74" endline="125">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U2(Info, expType)
             Case TypeCode.UInt16
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U2_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_u2_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_u2_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U2_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt16_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="74" endline="125">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I2(Info, expType)
             Case TypeCode.Int16
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I2_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I2_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I2_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I2_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt16_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="74" endline="125">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I1(Info, expType)
             Case TypeCode.SByte
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I1_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I1_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I1_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I1_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToSByte_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="74" endline="125">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I8(Info, expType)
             Case TypeCode.Int64
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I8_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt64_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="74" endline="125">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I4(Info, expType)
             Case TypeCode.Int32
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I4_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I4_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I4_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I4_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt32_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="73" endline="124">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U1(Info, expType)
             Case TypeCode.Byte
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U1_Overflow(Info, expType)
             Case TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_U1_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U1_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U1_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToByte_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="3" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="561" endline="611">
<![CDATA[
 
     Shared Function GetBinaryResultType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatResultType(op1, op2)
             Case KS.GE
                 Return GetGEResultType(op1, op2)
             Case KS.GT
                 Return GetGTResultType(op1, op2)
             Case KS.LE
                 Return GetLEResultType(op1, op2)
             Case KS.LT
                 Return GetLTResultType(op1, op2)
             Case KS.Equals
                 Return GetEqualsResultType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsResultType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeResultType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotResultType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="724" endline="774">
<![CDATA[
 
     Private Shared Function GetBinaryOperandType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatOperandType(op1, op2)
             Case KS.GE
                 Return GetGEOperandType(op1, op2)
             Case KS.GT
                 Return GetGTOperandType(op1, op2)
             Case KS.LE
                 Return GetLEOperandType(op1, op2)
             Case KS.LT
                 Return GetLTOperandType(op1, op2)
             Case KS.Equals
                 Return GetEqualsOperandType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsOperandType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeOperandType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotOperandType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="4" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="5" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="139" endline="152">
<![CDATA[
 
 		internal void Write(long value)
 		{
 			if (pos + 8 > buffer.Length)
 				Grow(8);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 			buffer[pos++] = (byte)(value >> 16);
 			buffer[pos++] = (byte)(value >> 24);
 			buffer[pos++] = (byte)(value >> 32);
 			buffer[pos++] = (byte)(value >> 40);
 			buffer[pos++] = (byte)(value >> 48);
 			buffer[pos++] = (byte)(value >> 56);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1434" endline="1448">
<![CDATA[
 
 		public void Encode (long value)
 		{
 			if (pos + 8 > buffer.Length)
 				Grow (8);
 
 			buffer[pos++] = (byte) value;
 			buffer[pos++] = (byte) (value >> 8);
 			buffer[pos++] = (byte) (value >> 16);
 			buffer[pos++] = (byte) (value >> 24);
 			buffer[pos++] = (byte) (value >> 32);
 			buffer[pos++] = (byte) (value >> 40);
 			buffer[pos++] = (byte) (value >> 48);
 			buffer[pos++] = (byte) (value >> 56);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="6" nfragments="9" Csharpe_files="0" vb_files="9" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="44" endline="72">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="44" endline="74">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="7" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="23" endline="57">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitLShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__LeftShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="23" endline="58">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitRShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__RightShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="8" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="64" endline="85">
<![CDATA[
 		}
 
 		public override EventInfo[] __GetDeclaredEvents()
 		{
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.EventMap.records.Length; i++)
 			{
 				if (module.EventMap.records[i].Parent == token)
 				{
 					int evt = module.EventMap.records[i].EventList - 1;
 					int end = module.EventMap.records.Length > i + 1 ? module.EventMap.records[i + 1].EventList - 1 
 					EventInfo[] events = new EventInfo[end - evt];
 					for (int j = 0; evt < end; evt++, j++)
 					{
 						events[j] = new EventInfoImpl(module, this, evt);
 					}
 					for (int j = 0; evt < end; evt++, j++)
 					{
 						events[j] = new EventInfoImpl(module, this, evt);
 					}
 					return events;
 				}
 			}
 			for (int i = 0; i < module.EventMap.records.Length; i++)
 			{
 				if (module.EventMap.records[i].Parent == token)
 				{
 					int evt = module.EventMap.records[i].EventList - 1;
 					int end = module.EventMap.records.Length > i + 1 ? module.EventMap.records[i + 1].EventList - 1 
 					EventInfo[] events = new EventInfo[end - evt];
 					for (int j = 0; evt < end; evt++, j++)
 					{
 						events[j] = new EventInfoImpl(module, this, evt);
 					}
 					return events;
 				}
 			}
 			return Empty<EventInfo>.Array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="173" endline="193">
<![CDATA[
 
 		public override PropertyInfo[] __GetDeclaredProperties()
 		{
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.PropertyMap.records.Length; i++)
 			{
 				if (module.PropertyMap.records[i].Parent == token)
 				{
 					int property = module.PropertyMap.records[i].PropertyList - 1;
 					int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1 
 					PropertyInfo[] properties = new PropertyInfo[end - property];
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					return properties;
 				}
 			}
 			for (int i = 0; i < module.PropertyMap.records.Length; i++)
 			{
 				if (module.PropertyMap.records[i].Parent == token)
 				{
 					int property = module.PropertyMap.records[i].PropertyList - 1;
 					int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1 
 					PropertyInfo[] properties = new PropertyInfo[end - property];
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					return properties;
 				}
 			}
 			return Empty<PropertyInfo>.Array;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="9" nfragments="6" Csharpe_files="0" vb_files="6" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="133" endline="155">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32
                     Return CUInt(originalValue) 'No range checking needed.
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UInteger
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UInteger
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                     Return CULng(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New ULong
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New ULong
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16
                     Return CUShort(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UShort
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UShort
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt32
                     Return CLng(originalValue) 'No range checking needed.
                 Case TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Long
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Long
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="115" endline="137">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Decimal
                     Return CSng(originalValue) 'No range checking needed.
                 Case TypeCode.Double, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Single
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Single
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16
                     Return CShort(originalValue) 'No range checking needed.
                 Case TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Short
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Short
             End Select
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="10" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="44" endline="70">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="44" endline="70">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="11" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="779" endline="809">
<![CDATA[
 
 		public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
 		{
 			List<PropertyInfo> list = new List<PropertyInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="479" endline="509">
<![CDATA[
 
 		public EventInfo[] GetEvents(BindingFlags bindingAttr)
 		{
 			List<EventInfo> list = new List<EventInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="12" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="554" endline="578">
<![CDATA[
 		}
 
 		public CompileUnitEntry GetCompileUnit (int index)
 		{
 			if ((index < 1) || (index > ot.CompileUnitCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				CompileUnitEntry unit;
 				if (compile_unit_hash.TryGetValue (index, out unit))
 					return unit;
 
 				long old_pos = reader.BaseStream.Position;
 
 				reader.BaseStream.Position = ot.CompileUnitTableOffset +
 					CompileUnitEntry.Size * (index - 1);
 				unit = new CompileUnitEntry (this, reader);
 				compile_unit_hash.Add (index, unit);
 
 				reader.BaseStream.Position = old_pos;
 				return unit;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="511" endline="542">
<![CDATA[
 		}
 
 		internal int LineNumberCount = 0;
 		internal int LocalCount = 0;
 		internal int StringSize = 0;
 
 		internal int LineNumberSize = 0;
 		internal int ExtendedLineNumberSize = 0;
 
 		public SourceFileEntry GetSourceFile (int index)
 		{
 			if ((index < 1) || (index > ot.SourceCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				SourceFileEntry source;
 				if (source_file_hash.TryGetValue (index, out source))
 					return source;
 
 				long old_pos = reader.BaseStream.Position;
 
 				reader.BaseStream.Position = ot.SourceTableOffset +
 					SourceFileEntry.Size * (index - 1);
 				source = new SourceFileEntry (this, reader);
 				source_file_hash.Add (index, source);
 
 				reader.BaseStream.Position = old_pos;
 				return source;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="13" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1970" endline="1989">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1990" endline="2009">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="14" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="23" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMultOrMultOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMult(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Multiply_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__MultiplyObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="24" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitSubOrSubOvfOrSubOvfUn(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitSub(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Subtract_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__SubtractObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="23" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Remainder_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ModObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="15" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="182" endline="209">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][][] t1, Type[][][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="154" endline="181">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][] t1, Type[][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="125" endline="153">
<![CDATA[
 
 		// note that an empty array matches a null reference
 		internal static bool ArrayEquals(Type[] t1, Type[] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="16" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="173" endline="211">
<![CDATA[
 
     Shared Function BuiltInTypeToTypeCode(ByVal Type As BuiltInDataTypes) As TypeCode
         Select Case Type
             Case BuiltInDataTypes.Boolean
                 Return TypeCode.Boolean
             Case BuiltInDataTypes.Byte
                 Return TypeCode.Byte
             Case BuiltInDataTypes.Char
                 Return TypeCode.Char
             Case BuiltInDataTypes.Date
                 Return TypeCode.DateTime
             Case BuiltInDataTypes.Decimal
                 Return TypeCode.Decimal
             Case BuiltInDataTypes.Double
                 Return TypeCode.Double
             Case BuiltInDataTypes.Integer
                 Return TypeCode.Int32
             Case BuiltInDataTypes.Long
                 Return TypeCode.Int64
             Case BuiltInDataTypes.Object
                 Return TypeCode.Object
             Case BuiltInDataTypes.SByte
                 Return TypeCode.SByte
             Case BuiltInDataTypes.Short
                 Return TypeCode.Int16
             Case BuiltInDataTypes.Single
                 Return TypeCode.Single
             Case BuiltInDataTypes.String
                 Return TypeCode.String
             Case BuiltInDataTypes.UInteger
                 Return TypeCode.UInt32
             Case BuiltInDataTypes.ULong
                 Return TypeCode.UInt64
             Case BuiltInDataTypes.UShort
                 Return TypeCode.UInt16
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="298" endline="336">
<![CDATA[
 
     Shared Function KeywordToTypeCode(ByVal Keyword As KS) As TypeCode
         Select Case Keyword
             Case KS.Boolean
                 Return TypeCode.Boolean
             Case KS.Byte
                 Return TypeCode.Byte
             Case KS.Char
                 Return TypeCode.Char
             Case KS.Date
                 Return TypeCode.DateTime
             Case KS.Decimal
                 Return TypeCode.Decimal
             Case KS.Double
                 Return TypeCode.Double
             Case KS.Integer
                 Return TypeCode.Int32
             Case KS.Long
                 Return TypeCode.Int64
             Case KS.Object
                 Return TypeCode.Object
             Case KS.Single
                 Return TypeCode.Single
             Case KS.Short
                 Return TypeCode.Int16
             Case KS.String
                 Return TypeCode.String
             Case KS.SByte
                 Return TypeCode.SByte
             Case KS.UShort
                 Return TypeCode.UInt16
             Case KS.UInteger
                 Return TypeCode.UInt32
             Case KS.ULong
                 Return TypeCode.UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="259" endline="297">
<![CDATA[
 
     Private Shared Function getTypeIndex(ByVal special As BuiltInDataTypes) As Integer
         Select Case special
             Case BuiltInDataTypes.Boolean
                 Return 0
             Case BuiltInDataTypes.Byte
                 Return 1
             Case BuiltInDataTypes.Char
                 Return 2
             Case BuiltInDataTypes.Date
                 Return 3
             Case BuiltInDataTypes.Decimal
                 Return 4
             Case BuiltInDataTypes.Double
                 Return 5
             Case BuiltInDataTypes.Integer
                 Return 6
             Case BuiltInDataTypes.Long
                 Return 7
             Case BuiltInDataTypes.Object
                 Return 8
             Case BuiltInDataTypes.[SByte]
                 Return 9
             Case BuiltInDataTypes.Short
                 Return 10
             Case BuiltInDataTypes.Single
                 Return 11
             Case BuiltInDataTypes.String
                 Return 12
             Case BuiltInDataTypes.[UInteger]
                 Return 13
             Case BuiltInDataTypes.[ULong]
                 Return 14
             Case BuiltInDataTypes.[UShort]
                 Return 15
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="17" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="59" endline="79">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConcatenateObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Math__Pow_Double_Double)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ExponentObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="18" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1963" endline="1978">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2044" endline="2059">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="19" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="205" endline="225">
<![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((addOnMethod != null && addOnMethod.IsPublic) || (removeOnMethod != null && removeOnMethod.IsPublic) || (fireMethod != null && fireMethod.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="226" endline="247">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((addOnMethod != null && addOnMethod.IsStatic) || (removeOnMethod != null && removeOnMethod.IsStatic) || (fireMethod != null && fireMethod.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="20" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="220" endline="242">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="175" endline="197">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="21" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="44" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Target IsNot Nothing Then result = m_Target.ResolveTypeReferences AndAlso result
         If m_Start IsNot Nothing Then result = m_Start.ResolveTypeReferences AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveTypeReferences AndAlso result
         If m_Source IsNot Nothing Then result = m_Source.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="59" endline="71">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
 
         If m_Declaration IsNot Nothing Then result = m_Declaration.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="22" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1929" endline="1962">
<![CDATA[
 	}
 
 	sealed class AssemblyTable 
 	{
 		internal const int Index = 0x20;
 
 		internal struct Record
 		{
 			internal int HashAlgId;
 			internal ushort MajorVersion;
 			internal ushort MinorVersion;
 			internal ushort BuildNumber;
 			internal ushort RevisionNumber;
 			internal int Flags;
 			internal int PublicKey;
 			internal int Name;
 			internal int Culture;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].HashAlgId = mr.ReadInt32();
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKey = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].HashAlgId = mr.ReadInt32();
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKey = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2028" endline="2043">
<![CDATA[
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKeyOrToken = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKeyOrToken = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="23" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="624" endline="639">
<![CDATA[
 
 		private TypeDefImpl FindFieldOwner(int fieldIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="724" endline="740">
<![CDATA[
 		}
 
 		private TypeDefImpl FindMethodOwner(int methodIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="24" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="124" endline="133">
<![CDATA[
 	
 		internal void Write(int value)
 		{
 			if (pos + 4 > buffer.Length)
 				Grow(4);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 			buffer[pos++] = (byte)(value >> 16);
 			buffer[pos++] = (byte)(value >> 24);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1418" endline="1428">
<![CDATA[
 
 		public void Encode (int value)
 		{
 			if (pos + 4 > buffer.Length)
 				Grow (4);
 
 			buffer[pos++] = (byte) value;
 			buffer[pos++] = (byte) (value >> 8);
 			buffer[pos++] = (byte) (value >> 16);
 			buffer[pos++] = (byte) (value >> 24);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="25" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitIntDiv(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__IntDivideObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="39" endline="62">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__OrObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="39" endline="62">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitAnd(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AndObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitXOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__XorObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="26" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5504" endline="5533">
<![CDATA[
 
     ''' <summary>
     '''SyncLockStatement  
     '''	"SyncLock" Expression  StatementTerminator
     '''	   [  Block  ]
     '''	"End" "SyncLock" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSyncLockStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SyncLockStatement
         Dim result As New SyncLockStatement(Parent)
 
         Dim m_Lock As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.SyncLock)
 
         m_Lock = ParseExpression(result)
         If m_Lock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.SyncLock) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Lock, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5360" endline="5389">
<![CDATA[
 
     ''' <summary>
     ''' WithStatement  
     '''	   "With" Expression  StatementTerminator
     '''	        [  Block  ]
     '''	   "End" "With" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWithStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WithStatement
         Dim result As New WithStatement(Parent)
 
         Dim m_WithExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.With)
 
         m_WithExpression = ParseExpression(result)
         If m_WithExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_Code = ParseCodeBlock(result, IsOneLiner)
 
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.With) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_WithExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5332" endline="5359">
<![CDATA[
     ''' <summary>
     ''' WhileStatement  
     '''	   "While" BooleanExpression  StatementTerminator
     '''	         [  Block  ]
     '''	   "End" "While" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWhileStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WhileStatement
         Dim result As New WhileStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.While)
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.While) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Condition, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="27" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="251" endline="272">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((getter != null && getter.IsStatic) || (setter != null && setter.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="230" endline="250">
<![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((getter != null && getter.IsPublic) || (setter != null && setter.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="28" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="86" endline="97">
<![CDATA[
 
 		public override FieldInfo[] __GetDeclaredFields()
 		{
 			int field = module.TypeDef.records[index].FieldList - 1;
 			int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].FieldList - 1 
 			FieldInfo[] fields = new FieldInfo[end - field];
 			for (int i = 0; field < end; i++, field++)
 			{
 				fields[i] = module.GetFieldAt(this, field);
 			}
 			for (int i = 0; field < end; i++, field++)
 			{
 				fields[i] = module.GetFieldAt(this, field);
 			}
 			return fields;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="113" endline="124">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			int method = module.TypeDef.records[index].MethodList - 1;
 			int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].MethodList - 1 
 			MethodBase[] methods = new MethodBase[end - method];
 			for (int i = 0; method < end; method++, i++)
 			{
 				methods[i] = module.GetMethodAt(this, method);
 			}
 			for (int i = 0; method < end; method++, i++)
 			{
 				methods[i] = module.GetMethodAt(this, method);
 			}
 			return methods;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="29" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="174" endline="191">
<![CDATA[
 
     Private Function EmitLoadAddressCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariableLocation(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariableLocation(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="192" endline="209">
<![CDATA[
 
     Private Function EmitLoadCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariable(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="30" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7935" endline="7950">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, true))
 				Expr = Expr.Resolve (ec);
 			
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7997" endline="8012">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, false))
 				Expr = Expr.Resolve (ec);
 
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="31" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="149" endline="174">
<![CDATA[
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionInferStatement(ByVal Parent As BaseObject) As OptionInferStatement
         Dim result As New OptionInferStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Infer")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="175" endline="201">
<![CDATA[
 
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionStrictStatement(ByVal Parent As BaseObject) As OptionStrictStatement
         Dim result As New OptionStrictStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Strict")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="202" endline="225">
<![CDATA[
 
     ''' <summary>
     ''' OptionExplicitStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionExplicitStatement(ByVal Parent As BaseObject) As OptionExplicitStatement
         Dim result As New OptionExplicitStatement(Parent)
 
         Dim m_Off As Boolean
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Explicit")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30640, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="32" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="229" endline="245">
<![CDATA[
 
     Private Sub BeginFinallyBlockCecil()
         Log("BeginFinallyBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Finally)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.HandlerStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.TryEnd = ex.HandlerStart
         block.Handlers.Add(ex)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="199" endline="216">
<![CDATA[
 
     Private Sub BeginExceptFilterBlockCecil()
         Log("BeginExceptFilterBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Filter)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
 
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.FilterStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.HandlerStart = ex.FilterStart
         block.Handlers.Add(ex)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="33" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="205" endline="218">
<![CDATA[
 
     Private Function CreateImplicitTypes(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitTypes(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitTypes In Type.Members.GetSpecificMembers(Of IHasImplicitTypes)()
             result = Member.CreateImplicitTypes() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="282" endline="295">
<![CDATA[
 
     Private Function CreateImplicitMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitMembers(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitMembers In Type.Members.GetSpecificMembers(Of IHasImplicitMembers)()
             result = Member.CreateImplicitMembers() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="34" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3334" endline="3355">
<![CDATA[
 
     Private Function ParseAnd_AndAlso(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseNot(Info)
 
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3172" endline="3193">
<![CDATA[
 
     Private Function ParseMultDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseUnaryPlusMinus(Info)
 
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3220" endline="3242">
<![CDATA[
 
     Private Function ParsePlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMod(Info)
 
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3256" endline="3277">
<![CDATA[
 
     Private Function ParseBitshift(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseConcat(Info)
 
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="35" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="459" endline="473">
<![CDATA[
 
     Sub RemoveInaccessible()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsAccessible = False Then
                 Log("NOT ACCESSIBLE
                 m_Candidates(i) = Nothing
             Else
                 Log("ACCESSIBLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="504" endline="518">
<![CDATA[
 
     Sub RemoveInapplicable()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.DefineApplicability = False Then
                 Log("NOT APPLICABLE
                 m_Candidates(i) = Nothing
             Else
                 Log("APPLICABLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="36" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="114" endline="133">
<![CDATA[
 
 		internal void WriteCompressedInt(int value)
 		{
 			if (value <= 0x7F)
 			{
 				Write((byte)value);
 			}
 			else if (value <= 0x3FFF)
 			{
 				Write((byte)(0x80 | (value >> 8)));
 				Write((byte)value);
 			}
 			else
 			{
 				Write((byte)(0xC0 | (value >> 24)));
 				Write((byte)(value >> 16));
 				Write((byte)(value >> 8));
 				Write((byte)value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="177" endline="196">
<![CDATA[
 
 		internal void WriteCompressedInt(int value)
 		{
 			if (value <= 0x7F)
 			{
 				Write((byte)value);
 			}
 			else if (value <= 0x3FFF)
 			{
 				Write((byte)(0x80 | (value >> 8)));
 				Write((byte)value);
 			}
 			else
 			{
 				Write((byte)(0xC0 | (value >> 24)));
 				Write((byte)(value >> 16));
 				Write((byte)(value >> 8));
 				Write((byte)value);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="37" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="534" endline="548">
<![CDATA[
 
     Sub RemoveNarrowing()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowing Then
                 Log("NARROWING    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="519" endline="533">
<![CDATA[
 
     Sub RemoveNarrowingExceptObject()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowingExceptObject Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="38" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="353" endline="367">
<![CDATA[
 
 		private static FieldInfo GetField(Type type, string name)
 		{
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (FieldInfo field in type.__GetDeclaredFields())
 				{
 					if (field.IsPublic && !field.IsStatic && field.Name == name)
 					{
 						return field;
 					}
 				}
 				foreach (FieldInfo field in type.__GetDeclaredFields())
 				{
 					if (field.IsPublic && !field.IsStatic && field.Name == name)
 					{
 						return field;
 					}
 				}
 			}
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (FieldInfo field in type.__GetDeclaredFields())
 				{
 					if (field.IsPublic && !field.IsStatic && field.Name == name)
 					{
 						return field;
 					}
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="368" endline="382">
<![CDATA[
 
 		private static PropertyInfo GetProperty(Type type, string name)
 		{
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (property.IsPublic && !property.IsStatic && property.Name == name)
 					{
 						return property;
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (property.IsPublic && !property.IsStatic && property.Name == name)
 					{
 						return property;
 					}
 				}
 			}
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (property.IsPublic && !property.IsStatic && property.Name == name)
 					{
 						return property;
 					}
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="39" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="611" endline="639">
<![CDATA[
 	}
 
 	sealed class MethodDefTable 
 	{
 		internal const int Index = 0x06;
 		private int baseRVA;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal short ImplFlags;
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 			internal int ParamList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="525" endline="552">
<![CDATA[
 	}
 
 	sealed class TypeDefTable 
 	{
 		internal const int Index = 0x02;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Extends;
 			internal int FieldList;
 			internal int MethodList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="40" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="808" endline="821">
<![CDATA[
 
 		internal int FindOrAddRecord(Record record)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Class == record.Class
 					&& records[i].Name == record.Name
 					&& records[i].Signature == record.Signature)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Class == record.Class
 					&& records[i].Name == record.Name
 					&& records[i].Signature == record.Signature)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(record);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2160" endline="2173">
<![CDATA[
 
 		internal int FindOrAddRecord(Record rec)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Implementation == rec.Implementation
 					&& records[i].TypeName == rec.TypeName
 					&& records[i].TypeNamespace == rec.TypeNamespace)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Implementation == rec.Implementation
 					&& records[i].TypeName == rec.TypeName
 					&& records[i].TypeNamespace == rec.TypeNamespace)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="41" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="264" endline="281">
<![CDATA[
 
     Function CreateImplicitMembers() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitMembers " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitMembers = TryCast(Type, IHasImplicitMembers)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitMembers AndAlso result
 
             result = CreateImplicitMembers(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="187" endline="204">
<![CDATA[
 
     Function CreateImplicitTypes() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitTypes " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitTypes = TryCast(Type, IHasImplicitTypes)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitTypes AndAlso result
 
             result = CreateImplicitTypes(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="42" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1826" endline="1837">
<![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitStoreVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitStoreField(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitStoreVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1562" endline="1573">
<![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitLoadVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="43" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2138" endline="2149">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.Write(records[i].TypeDefId);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNamespace);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.Write(records[i].TypeDefId);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNamespace);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="450" endline="461">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Generation);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteGuidIndex(records[i].Mvid);
 				mw.WriteGuidIndex(records[i].EncId);
 				mw.WriteGuidIndex(records[i].EncBaseId);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Generation);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteGuidIndex(records[i].Mvid);
 				mw.WriteGuidIndex(records[i].EncId);
 				mw.WriteGuidIndex(records[i].EncBaseId);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="44" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="173" endline="190">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim stn As SimpleTypeName
         Dim ctn As ConstructedTypeName
 
         stn = TryCast(m_TypeName, SimpleTypeName)
         If stn IsNot Nothing Then
             result = stn.ResolveCode(Info) AndAlso result
         Else
             ctn = TryCast(m_TypeName, ConstructedTypeName)
             If ctn IsNot Nothing Then
                 result = ctn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="143" endline="161">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim atn As ArrayTypeName
         Dim natn As NonArrayTypeName
 
         atn = TryCast(m_TypeName, ArrayTypeName)
         If atn IsNot Nothing Then
             result = atn.ResolveCode(Info) AndAlso result
         Else
             natn = TryCast(m_TypeName, NonArrayTypeName)
             If natn IsNot Nothing Then
                 result = natn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="45" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2112" endline="2137">
<![CDATA[
 	}
 
 	sealed class ExportedTypeTable 
 	{
 		internal const int Index = 0x27;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeDefId;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeDefId = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeDefId = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="390" endline="449">
<![CDATA[
 		protected int rowCount;
 
 		internal sealed override int RowCount
 		{
 			get { return rowCount; }
 			set { rowCount = value; records = new T[value]; }
 		}
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			throw new InvalidOperationException();
 		}
 
 		internal int AddRecord(T newRecord)
 		{
 			if (rowCount == records.Length)
 			{
 				T[] newarr = new T[records.Length * 2];
 				Array.Copy(records, newarr, records.Length);
 				records = newarr;
 			}
 			records[rowCount++] = newRecord;
 			return rowCount;
 		}
 
 		internal int AddVirtualRecord()
 		{
 			return ++rowCount;
 		}
 
 		internal override void Write(MetadataWriter mw)
 		{
 			throw new InvalidOperationException();
 		}
 	}
 
 	sealed class ModuleTable 
 	{
 		internal const int Index = 0x00;
 
 		internal struct Record
 		{
 			internal short Generation;
 			internal int Name; // -> StringHeap
 			internal int Mvid; // -> GuidHeap
 			internal int EncId; // -> GuidHeap
 			internal int EncBaseId; // -> GuidHeap
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Generation = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Mvid = mr.ReadGuidIndex();
 				records[i].EncId = mr.ReadGuidIndex();
 				records[i].EncBaseId = mr.ReadGuidIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Generation = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Mvid = mr.ReadGuidIndex();
 				records[i].EncId = mr.ReadGuidIndex();
 				records[i].EncBaseId = mr.ReadGuidIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="46" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="80" endline="96">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= EventAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="92" endline="108">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= PropertyAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="47" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="44" endline="52">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributePositionalArgumentList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributePositionalArgumentList(NewParent)
         For Each item As AttributeArgumentExpression In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArgumentList.vb" startline="43" endline="52">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeArgumentList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeArgumentList(NewParent)
         For Each item As TypeName In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" startline="45" endline="53">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializerList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializerList(NewParent)
         For Each item As VariablePropertyInitializer In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="48" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="920" endline="935">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddBreakOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new BreakOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="936" endline="951">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddContinueOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new ContinueOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="49" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1283" endline="1292">
<![CDATA[
 
     Public Shared Function GetEvent(ByVal collection As ICollection, ByVal reference As EventReference) As EventDefinition
         For Each meth As EventDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1218" endline="1227">
<![CDATA[
 
     Public Shared Function GetField(ByVal collection As ICollection, ByVal reference As FieldReference) As FieldDefinition
         For Each field As FieldDefinition In collection
             If Not Helper.CompareNameOrdinal(field.Name, reference.Name) Then
                 Continue For
             End If
             Return field
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="50" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="118" endline="141">
<![CDATA[
 
 		internal int ReadTypeDefOrRef()
 		{
 			int codedIndex;
 			if (bigTypeDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (TypeSpecTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="408" endline="431">
<![CDATA[
 
 		internal int ReadImplementation()
 		{
 			int codedIndex;
 			if (bigImplementation)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FileTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (ExportedTypeTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="340" endline="363">
<![CDATA[
 
 		internal int ReadHasDeclSecurity()
 		{
 			int codedIndex;
 			if (bigHasDeclSecurity)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="272" endline="295">
<![CDATA[
 
 		internal int ReadHasConstant()
 		{
 			int codedIndex;
 			if (bigHasConstant)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (PropertyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="51" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1485" endline="1496">
<![CDATA[
 
 		internal FieldInfo FindField(string name, FieldSignature signature)
 		{
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (field.Name == name && field.FieldSignature.Equals(signature))
 				{
 					return field;
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (field.Name == name && field.FieldSignature.Equals(signature))
 				{
 					return field;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1473" endline="1484">
<![CDATA[
 
 		internal MethodBase FindMethod(string name, MethodSignature signature)
 		{
 			foreach (MethodBase method in __GetDeclaredMethods())
 			{
 				if (method.Name == name && method.MethodSignature.Equals(signature))
 				{
 					return method;
 				}
 			}
 			foreach (MethodBase method in __GetDeclaredMethods())
 			{
 				if (method.Name == name && method.MethodSignature.Equals(signature))
 				{
 					return method;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="52" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="474" endline="487">
<![CDATA[
 
 		public int Size
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				return 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="488" endline="502">
<![CDATA[
 		}
 
 		public PackingSize PackingSize
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				return PackingSize.Unspecified;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="53" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2095" endline="2102">
<![CDATA[
 
     Shared Function ResolveStatementCollection(ByVal Collection As IEnumerable, ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As Statement In Collection
             result = obj.ResolveStatement(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2103" endline="2110">
<![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IEnumerable, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.GenerateCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="54" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2294" endline="2304">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Number);
 				mw.Write(records[i].Flags);
 				mw.WriteTypeOrMethodDef(records[i].Owner);
 				mw.WriteStringIndex(records[i].Name);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Number);
 				mw.Write(records[i].Flags);
 				mw.WriteTypeOrMethodDef(records[i].Owner);
 				mw.WriteStringIndex(records[i].Name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2198" endline="2208">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1836" endline="1846">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MappingFlags);
 				mw.WriteMemberForwarded(records[i].MemberForwarded);
 				mw.WriteStringIndex(records[i].ImportName);
 				mw.WriteModuleRef(records[i].ImportScope);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MappingFlags);
 				mw.WriteMemberForwarded(records[i].MemberForwarded);
 				mw.WriteStringIndex(records[i].ImportName);
 				mw.WriteModuleRef(records[i].ImportScope);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="55" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="97" endline="108">
<![CDATA[
 
     Private Function DefineType(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineType AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineType(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="109" endline="120">
<![CDATA[
 
     Private Function DefineTypeHierarchy(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineTypeHierarchy AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineTypeHierarchy(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="56" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1404" endline="1412">
<![CDATA[
 
 		public void Encode (short value)
 		{
 			if (pos + 2 > buffer.Length)
 				Grow (2);
 
 			buffer[pos++] = (byte) value;
 			buffer[pos++] = (byte) (value >> 8);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="111" endline="118">
<![CDATA[
 
 		internal void Write(short value)
 		{
 			if (pos + 2 > buffer.Length)
 				Grow(2);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="57" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4994" endline="5016">
<![CDATA[
 
     ''' <summary>
     ''' ThrowStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseThrowStatement(ByVal Parent As ParsedObject) As ThrowStatement
         Dim result As New ThrowStatement(Parent)
 
         Dim m_Exception As Expression
 
         tm.AcceptIfNotInternalError(KS.Throw)
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_Exception = ParseExpression(result)
             If m_Exception Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Exception = Nothing
         End If
 
         result.Init(m_Exception)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5205" endline="5222">
<![CDATA[
 
     Private Function ParseReturnStatement(ByVal Parent As ParsedObject) As ReturnStatement
         Dim result As New ReturnStatement(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Return)
         If Not tm.CurrentToken.IsEndOfStatement Then
             m_Expression = ParseExpression(result)
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression = Nothing
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="58" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="334" endline="346">
<![CDATA[
 
 		public Type[] FindTypes(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="925" endline="937">
<![CDATA[
 
 		public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="59" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="45" endline="57">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SimpleTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleTypeName(NewParent)
         If Me.IsBuiltInTypeName Then
             result.Init(Me.AsBuiltInTypeName.Clone(result))
         ElseIf Me.IsQualifiedIdentifier Then
             result.Init(Me.AsQualifiedIdentifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="50" endline="62">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayNameModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayNameModifier(NewParent)
         If Me.IsArrayTypeModifiers Then
             result.Init(Me.AsArrayTypeModifiers.Clone(result))
         ElseIf Me.IsArraySizeInitializationModifier Then
             result.Init(Me.AsArraySizeInitializationModifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="60" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2078" endline="2086">
<![CDATA[
 
     Shared Function ResolveTypeReferencesCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             result = obj.ResolveTypeReferences AndAlso result
             'vbnc.Helper.Assert(result = (obj.Compiler.Report.Errors = 0))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2056" endline="2063">
<![CDATA[
 
     Shared Function DefineCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.Define AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="61" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1812" endline="1835">
<![CDATA[
 	}
 
 	sealed class ImplMapTable 
 	{
 		internal const int Index = 0x1C;
 
 		internal struct Record
 		{
 			internal short MappingFlags;
 			internal int MemberForwarded;
 			internal int ImportName;
 			internal int ImportScope;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2174" endline="2197">
<![CDATA[
 	}
 
 	sealed class ManifestResourceTable 
 	{
 		internal const int Index = 0x28;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Flags;
 			internal int Name;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2268" endline="2293">
<![CDATA[
 	}
 
 	sealed class GenericParamTable 
 	{
 		internal const int Index = 0x2A;
 
 		internal struct Record
 		{
 			internal short Number;
 			internal short Flags;
 			internal int Owner;
 			internal int Name;
 			// not part of the table, we use it to be able to fixup the GenericParamConstraint table
 			internal int unsortedIndex;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="62" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="51" endline="59">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_AttributePositionalArgumentList IsNot Nothing Then result = m_AttributePositionalArgumentList.ResolveCode(info) AndAlso result
         If m_VariablePropertyInitializerList IsNot Nothing Then result = m_VariablePropertyInitializerList.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="92" endline="100">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveCode(Info) AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="76" endline="85">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         If m_TypeParameter IsNot Nothing Then result = m_TypeParameter.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="63" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="42" endline="50">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArguments
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArguments(NewParent)
         If m_AttributePositionalArgumentList IsNot Nothing Then result.m_AttributePositionalArgumentList = m_AttributePositionalArgumentList.clone(result)
         If m_VariablePropertyInitializerList IsNot Nothing Then result.m_VariablePropertyInitializerList = m_VariablePropertyInitializerList.clone(result)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="68" endline="76">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializer
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializer(NewParent)
         If m_IdentifierOrKeyword IsNot Nothing Then result.m_IdentifierOrKeyword = m_IdentifierOrKeyword.Clone(result)
         If m_AttributeArgumentExpression IsNot Nothing Then result.m_AttributeArgumentExpression = m_AttributeArgumentExpression.Clone(result)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="64" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="975" endline="983">
<![CDATA[
 
     Function FindTypeWithName(ByVal Name As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.Name, Name) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="984" endline="992">
<![CDATA[
 
     Function FindTypeWithFullname(ByVal Fullname As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.FullName, Fullname) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="65" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="774" endline="787">
<![CDATA[
 
 		protected static Type[][][] BindTypeParameters(IGenericBinder binder, Type[][][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][][] expanded = new Type[types.Length][][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="760" endline="773">
<![CDATA[
 
 		protected static Type[][] BindTypeParameters(IGenericBinder binder, Type[][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][] expanded = new Type[types.Length][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="66" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="56" endline="69">
<![CDATA[
 		}
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="67" nfragments="8" Csharpe_files="0" vb_files="8" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="58" endline="69">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_First IsNot Nothing Then result = m_First.ResolveTypeReferences AndAlso result
         If m_Second IsNot Nothing Then result = m_Second.ResolveTypeReferences AndAlso result
 
         ' If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveTypeReferences AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_EventHandler IsNot Nothing Then result = m_EventHandler.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="54" endline="63">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression1 IsNot Nothing Then result = m_Expression1.ResolveTypeReferences AndAlso result
         If m_Expression2 IsNot Nothing Then result = m_Expression2.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Test IsNot Nothing Then result = m_Test.ResolveTypeReferences AndAlso result
         If m_Cases IsNot Nothing Then result = m_Cases.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="41" endline="49">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_FirstPart IsNot Nothing Then result = m_FirstPart.ResolveTypeReferences AndAlso result
         If m_SecondPart IsNot Nothing Then result = m_SecondPart.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="51" endline="58">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArraySizeInitModifier IsNot Nothing Then result = m_ArraySizeInitModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="35" endline="42">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_Arguments IsNot Nothing Then result = m_Arguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="68" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="548" endline="560">
<![CDATA[
 
     Shared Function GetUnaryResultType(ByVal op As KS, ByVal op1 As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(op1)
             Case KS.Minus
                 Return GetUnaryMinusResultType(op1)
             Case KS.Not
                 Return GetUnaryNotResultType(op1)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="612" endline="624">
<![CDATA[
 
     Shared Function GetUnaryOperandType(ByVal op As KS, ByVal operand As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(operand)
             Case KS.Minus
                 Return GetUnaryMinusResultType(operand)
             Case KS.Not
                 Return GetUnaryNotResultType(operand)
             Case Else
                 Throw New NotImplementedException
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="69" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071">
<![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="30" endline="39">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each Item As EventMemberSpecifier In Me
             result = Item.ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="70" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="428" endline="436">
<![CDATA[
 		}
 
 		public int File {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].File;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="419" endline="427">
<![CDATA[
 		}
 
 		public int CompilationUnitIndex {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].CompilationUnit;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="71" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3139" endline="3158">
<![CDATA[
 
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.FieldAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.FieldAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.FieldAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.FieldAttributes.Public
                 Return "Public"
             Case Mono.Cecil.FieldAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3159" endline="3177">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.MethodAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.MethodAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="72" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="462" endline="473">
<![CDATA[
 
 		public EventInfo GetEvent(string name, BindingFlags bindingAttr)
 		{
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="815" endline="826">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
 		{
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name)
 				{
 					return prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name)
 				{
 					return prop;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="743" endline="754">
<![CDATA[
 
 		public virtual Type GetNestedType(string name, BindingFlags bindingAttr)
 		{
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="515" endline="526">
<![CDATA[
 
 		public FieldInfo GetField(string name, BindingFlags bindingAttr)
 		{
 			foreach (FieldInfo field in GetFields(bindingAttr))
 			{
 				if (field.Name == name)
 				{
 					return field;
 				}
 			}
 			foreach (FieldInfo field in GetFields(bindingAttr))
 			{
 				if (field.Name == name)
 				{
 					return field;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="73" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="250" endline="271">
<![CDATA[
 
 		internal int ReadMethodDefOrRef()
 		{
 			int codedIndex;
 			if (bigMethodDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MemberRefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="296" endline="317">
<![CDATA[
 
 		internal int ReadHasSemantics()
 		{
 			int codedIndex;
 			if (bigHasSemantics)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (EventTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (PropertyTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="318" endline="339">
<![CDATA[
 
 		internal int ReadHasFieldMarshal()
 		{
 			int codedIndex;
 			if (bigHasFieldMarshal)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="364" endline="385">
<![CDATA[
 
 		internal int ReadTypeOrMethodDef()
 		{
 			int codedIndex;
 			if (bigTypeOrMethodDef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="386" endline="407">
<![CDATA[
 
 		internal int ReadMemberForwarded()
 		{
 			int codedIndex;
 			if (bigMemberForwarded)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="74" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="254" endline="266">
<![CDATA[
 
 		internal static int GetHashCode(Type[][][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="241" endline="253">
<![CDATA[
 
 		internal static int GetHashCode(Type[][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="75" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2037" endline="2044">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(TypeToFind, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2029" endline="2036">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypeToSearch As Mono.Cecil.TypeReference, ByVal TypesToFind As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         For i As Integer = 0 To TypesToFind.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToFind(i)
             If Helper.CompareType(t, TypeToSearch) OrElse Helper.IsSubclassOf(TypeToSearch, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="76" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="822" endline="832">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2432" endline="2442">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="77" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4812" endline="4831">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLocalVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of LocalVariableDeclaration)
             tmp = ParseLocalVariableDeclarator(Parent, Modifiers, Info)
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4832" endline="4853">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of TypeVariableDeclaration)
             'Console.WriteLine("ParseTypeVariableDeclarators...")
             tmp = ParseTypeVariableDeclarator(Parent, Modifiers, Info)
             'Console.WriteLine("Got something
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="78" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="543" endline="553">
<![CDATA[
 
 		public SourceFileEntry[] Sources {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				SourceFileEntry[] retval = new SourceFileEntry [SourceCount];
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="579" endline="589">
<![CDATA[
 
 		public CompileUnitEntry[] CompileUnits {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				CompileUnitEntry[] retval = new CompileUnitEntry [CompileUnitCount];
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="79" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="233" endline="251">
<![CDATA[
 
 		public void RemoveWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_only == null)
 				warnings_only = new List<int> ();
 
 			warnings_only.Add (id);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="214" endline="232">
<![CDATA[
 
 		public void AddWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_as_error == null)
 				warnings_as_error = new List<int> ();
 			
 			warnings_as_error.Add (id);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="80" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="294" endline="312">
<![CDATA[
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (4);
 
 			default_references.Add ("System.dll");
 			default_references.Add ("System.Xml.dll");
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core.dll");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp.dll");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="437" endline="461">
<![CDATA[
 		}
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (8);
 
 			default_references.Add ("System");
 			default_references.Add ("System.Xml");
 #if NET_2_1
 			default_references.Add ("System.Net");
 			default_references.Add ("System.Windows");
 			default_references.Add ("System.Windows.Browser");
 #endif
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="81" nfragments="10" Csharpe_files="10" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2093" endline="2102">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="506" endline="515">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteResolutionScope(records[i].ResolutionScope);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNameSpace);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteResolutionScope(records[i].ResolutionScope);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNameSpace);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1706" endline="1715">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="789" endline="798">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1578" endline="1587">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Semantics);
 				mw.WriteMethodDef(records[i].Method);
 				mw.WriteHasSemantics(records[i].Association);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Semantics);
 				mw.WriteMethodDef(records[i].Method);
 				mw.WriteHasSemantics(records[i].Association);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="855" endline="864">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1529" endline="1538">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1451" endline="1460">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1178" endline="1187">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Action);
 				mw.WriteHasDeclSecurity(records[i].Parent);
 				mw.WriteBlobIndex(records[i].PermissionSet);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Action);
 				mw.WriteHasDeclSecurity(records[i].Parent);
 				mw.WriteBlobIndex(records[i].PermissionSet);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="987" endline="996">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasCustomAttribute(records[i].Parent);
 				mw.WriteCustomAttributeType(records[i].Type);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasCustomAttribute(records[i].Parent);
 				mw.WriteCustomAttributeType(records[i].Type);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="82" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2520" endline="2528">
<![CDATA[
 
 		public static string GetMetadataName (string name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [0] == name)
 					return names [i] [1];
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [0] == name)
 					return names [i] [1];
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2506" endline="2514">
<![CDATA[
 
 		public static string GetName (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [1] == metadata_name)
 					return names [i] [0];
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [1] == metadata_name)
 					return names [i] [0];
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="83" nfragments="13" Csharpe_files="13" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1156" endline="1177">
<![CDATA[
 	}
 
 	sealed class DeclSecurityTable 
 	{
 		internal const int Index = 0x0E;
 
 		internal struct Record
 		{
 			internal short Action;
 			internal int Parent;
 			internal int PermissionSet;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="965" endline="986">
<![CDATA[
 	}
 
 	sealed class CustomAttributeTable 
 	{
 		internal const int Index = 0x0C;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int Type;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1256" endline="1265">
<![CDATA[
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].PackingSize = mr.ReadInt16();
 				records[i].ClassSize = mr.ReadInt32();
 				records[i].Parent = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].PackingSize = mr.ReadInt16();
 				records[i].ClassSize = mr.ReadInt32();
 				records[i].Parent = mr.ReadTypeDef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1429" endline="1450">
<![CDATA[
 	}
 
 	sealed class EventTable 
 	{
 		internal const int Index = 0x14;
 
 		internal struct Record
 		{
 			internal short EventFlags;
 			internal int Name;
 			internal int EventType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1507" endline="1528">
<![CDATA[
 	}
 
 	sealed class PropertyTable 
 	{
 		internal const int Index = 0x17;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Type;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1548" endline="1577">
<![CDATA[
 	}
 
 	sealed class MethodSemanticsTable 
 	{
 		internal const int Index = 0x18;
 
 		// semantics
 		internal const short Setter = 0x0001;
 		internal const short Getter = 0x0002;
 		internal const short Other = 0x0004;
 		internal const short AddOn = 0x0008;
 		internal const short RemoveOn = 0x0010;
 		internal const short Fire = 0x0020;
 
 		internal struct Record
 		{
 			internal short Semantics;
 			internal int Method;
 			internal int Association;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="833" endline="854">
<![CDATA[
 	}
 
 	sealed class ConstantTable 
 	{
 		internal const int Index = 0x0B;
 
 		internal struct Record
 		{
 			internal short Type;
 			internal int Parent;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="767" endline="788">
<![CDATA[
 	}
 
 	sealed class MemberRefTable 
 	{
 		internal const int Index = 0x0A;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1684" endline="1705">
<![CDATA[
 	}
 
 	sealed class MethodImplTable 
 	{
 		internal const int Index = 0x19;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int MethodBody;
 			internal int MethodDeclaration;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="660" endline="681">
<![CDATA[
 	}
 
 	sealed class ParamTable 
 	{
 		internal const int Index = 0x08;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal short Sequence;
 			internal int Name;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="575" endline="596">
<![CDATA[
 	}
 
 	sealed class FieldTable 
 	{
 		internal const int Index = 0x04;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2071" endline="2092">
<![CDATA[
 	}
 
 	sealed class FileTable 
 	{
 		internal const int Index = 0x26;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int Name;
 			internal int HashValue;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="484" endline="505">
<![CDATA[
 	}
 
 	sealed class TypeRefTable 
 	{
 		internal const int Index = 0x01;
 
 		internal struct Record
 		{
 			internal int ResolutionScope;
 			internal int TypeName;
 			internal int TypeNameSpace;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="84" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1380" endline="1391">
<![CDATA[
 
 		internal int FindOrAddRecord(int blob)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(blob);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1774" endline="1785">
<![CDATA[
 
 		internal int FindOrAddRecord(int str)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(str);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="85" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="377" endline="406">
<![CDATA[
 
     ''' <summary>
     ''' - All the type's members are defined (methods, constructors, properties, fields, events, operators).
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Green
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = DefineMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="354" endline="376">
<![CDATA[
 
     ''' <summary>
     ''' - Base classes for classes, modules, structures, enums, interfaces and delegates are set.
     ''' - Implemented interfaces for classes are set.
     ''' - Type parameters for classes and structures are set.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineTypeHierarchy()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypeHierarchy " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineTypeHierarchy(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="331" endline="353">
<![CDATA[
 
 
     ''' <summary>
     ''' - Types are defined with the reflection.emit namespace. 
     ''' - Only classes, modules, structures, interfaces, enums, delegates and eventnos (not a type by itself, bu an event might declare a new delegate). They are only defined, nothing else.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineType()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypes() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypes " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineType(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="86" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="758" endline="766">
<![CDATA[
 
 		int IComparer<Record>.Compare(Record x, Record y)
 		{
 			if (x.Class == y.Class)
 			{
 				return x.Interface == y.Interface ? 0 
 			}
 			return x.Class > y.Class ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2340" endline="2348">
<![CDATA[
 
 		int IComparer<Record>.Compare(Record x, Record y)
 		{
 			if (x.Owner == y.Owner)
 			{
 				return x.Number == y.Number ? 0 
 			}
 			return x.Owner > y.Owner ? 1 
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="87" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="191" endline="200">
<![CDATA[
 
 		public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="432" endline="441">
<![CDATA[
 
 		public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineNestedType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="88" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="207" endline="218">
<![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="219" endline="231">
<![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsTypeString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="89" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="37" endline="46">
<![CDATA[
 
     Function AsTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To Me.Count - 1
             result(i) = Item(i).CecilBuilder
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="53" endline="61">
<![CDATA[
 
     ReadOnly Property AsExpressions() As Expression()
         Get
             Dim result(Me.Count - 1) As Expression
             For i As Integer = 0 To Me.Count - 1
                 result(i) = Item(i).Expression
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3398" endline="3407">
<![CDATA[
 
     Shared Function ArgumentsToExpressions(ByVal Arguments As Generic.List(Of Argument)) As Expression()
         Dim result(Arguments.Count - 1) As Expression
 
         For i As Integer = 0 To Arguments.Count - 1
             result(i) = Arguments(i).Expression
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="71" endline="79">
<![CDATA[
     End Property
 
     Function ToTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
         For i As Integer = 0 To Me.Count - 1
             result(i) = Me.Item(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="90" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="668" endline="676">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement target)
 		{
 			StatementList t = (StatementList) target;
 
 			t.statements = new List<Statement> (statements.Count);
 			foreach (Statement s in statements)
 				t.statements.Add (s.Clone (clonectx));
 			foreach (Statement s in statements)
 				t.statements.Add (s.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5952" endline="5961">
<![CDATA[
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			var target = (ArrayInitializer) t;
 
 			target.elements = new List<Expression> (elements.Count);
 			foreach (var element in elements)
 				target.elements.Add (element.Clone (clonectx));
 			foreach (var element in elements)
 				target.elements.Add (element.Clone (clonectx));
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="91" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="276" endline="286">
<![CDATA[
     End Property
 
     ReadOnly Property HasPositionalArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is PositionalArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="266" endline="275">
<![CDATA[
 
     ReadOnly Property HasNamedArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is NamedArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="92" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="496" endline="502">
<![CDATA[
 
     Function IsSignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_SByte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int64)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="503" endline="509">
<![CDATA[
 
     Function IsUnsignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_Byte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt64)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="93" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="280" endline="290">
<![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MethodReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="269" endline="279">
<![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="257" endline="268">
<![CDATA[
     End Property
 
     Private Sub SetMethods(ByVal lst As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="94" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="36" endline="57">
<![CDATA[
 		{
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					builder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="466" endline="483">
<![CDATA[
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			PropertyBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="95" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="478" endline="484">
<![CDATA[
 
     Function IsIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In IntegralTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="471" endline="477">
<![CDATA[
 
     Function IsNumericType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In NumericTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="96" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="368" endline="379">
<![CDATA[
 
 		public override void SetAlgorithmId (uint value, Location loc)
 		{
 			try {
 				if (assembly_algorithm == null)
 					assembly_algorithm = typeof (AssemblyBuilder).GetField ("algid", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_algorithm.SetValue (builder, value);
 			} catch {
 				base.SetAlgorithmId (value, loc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="392" endline="403">
<![CDATA[
 
 		public override void SetFlags (uint flags, Location loc)
 		{
 			try {
 				if (assembly_flags == null)
 					assembly_flags = typeof (AssemblyBuilder).GetField ("flags", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_flags.SetValue (builder, flags);
 			} catch {
 				base.SetFlags (flags, loc);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="97" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="575" endline="584">
<![CDATA[
 
 		public override MethodInfo[] GetOtherMethods(bool nonPublic)
 		{
 			MethodInfo[] others = eventInfo.GetOtherMethods(nonPublic);
 			for (int i = 0; i < others.Length; i++)
 			{
 				others[i] = Wrap(others[i]);
 			}
 			for (int i = 0; i < others.Length; i++)
 			{
 				others[i] = Wrap(others[i]);
 			}
 			return others;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="463" endline="472">
<![CDATA[
 
 		public override MethodInfo[] GetAccessors(bool nonPublic)
 		{
 			MethodInfo[] accessors = property.GetAccessors(nonPublic);
 			for (int i = 0; i < accessors.Length; i++)
 			{
 				accessors[i] = Wrap(accessors[i]);
 			}
 			for (int i = 0; i < accessors.Length; i++)
 			{
 				accessors[i] = Wrap(accessors[i]);
 			}
 			return accessors;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="98" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="208" endline="224">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a constructorinfo.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedConstructor() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="192" endline="207">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a methodinfo.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethodInfo() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="99" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="120" endline="129">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="52" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then result = m_Clauses.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="100" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="36" endline="45">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Lock) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="38" endline="47">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Condition) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="36" endline="43">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_WithExpression) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="101" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="541" endline="548">
<![CDATA[
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Variables IsNot Nothing Then m_Variables.Initialize(Me)
         If m_Statements IsNot Nothing Then m_Statements.Initialize(Me)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="52" endline="58">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Signature IsNot Nothing Then m_Signature.Initialize(Me)
         If m_Code IsNot Nothing Then m_Code.Initialize(Me)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="102" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="103" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="734" endline="747">
<![CDATA[
 
     Shared Function IsFamilyOrAssembly(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="720" endline="733">
<![CDATA[
 
     Shared Function IsPrivate(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="104" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2220" endline="2229">
<![CDATA[
 
 		public override EventInfo[] __GetDeclaredEvents()
 		{
 			EventInfo[] events = type.__GetDeclaredEvents();
 			for (int i = 0; i < events.Length; i++)
 			{
 				events[i] = events[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < events.Length; i++)
 			{
 				events[i] = events[i].BindTypeParameters(this);
 			}
 			return events;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2230" endline="2239">
<![CDATA[
 
 		public override PropertyInfo[] __GetDeclaredProperties()
 		{
 			PropertyInfo[] properties = type.__GetDeclaredProperties();
 			for (int i = 0; i < properties.Length; i++)
 			{
 				properties[i] = properties[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < properties.Length; i++)
 			{
 				properties[i] = properties[i].BindTypeParameters(this);
 			}
 			return properties;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2185" endline="2194">
<![CDATA[
 
 		public override FieldInfo[] __GetDeclaredFields()
 		{
 			FieldInfo[] fields = type.__GetDeclaredFields();
 			for (int i = 0; i < fields.Length; i++)
 			{
 				fields[i] = fields[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < fields.Length; i++)
 			{
 				fields[i] = fields[i].BindTypeParameters(this);
 			}
 			return fields;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2205" endline="2214">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			MethodBase[] methods = type.__GetDeclaredMethods();
 			for (int i = 0; i < methods.Length; i++)
 			{
 				methods[i] = methods[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < methods.Length; i++)
 			{
 				methods[i] = methods[i].BindTypeParameters(this);
 			}
 			return methods;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2195" endline="2204">
<![CDATA[
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			Type[] interfaces = type.__GetDeclaredInterfaces();
 			for (int i = 0; i < interfaces.Length; i++)
 			{
 				interfaces[i] = interfaces[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < interfaces.Length; i++)
 			{
 				interfaces[i] = interfaces[i].BindTypeParameters(this);
 			}
 			return interfaces;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="105" nfragments="9" Csharpe_files="9" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1894" endline="1902">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1113" endline="1121">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2463" endline="2471">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteGenericParam(records[i].Owner);
 				mw.WriteTypeDefOrRef(records[i].Constraint);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteGenericParam(records[i].Owner);
 				mw.WriteTypeDefOrRef(records[i].Constraint);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1323" endline="1331">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2402" endline="2410">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMethodDefOrRef(records[i].Method);
 				mw.WriteBlobIndex(records[i].Instantiation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMethodDefOrRef(records[i].Method);
 				mw.WriteBlobIndex(records[i].Instantiation);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2238" endline="2246">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].NestedClass);
 				mw.WriteTypeDef(records[i].EnclosingClass);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].NestedClass);
 				mw.WriteTypeDef(records[i].EnclosingClass);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1490" endline="1498">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="715" endline="723">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1412" endline="1420">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="106" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="166" endline="176">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="222" endline="243">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             'If IsLocalVariable Then
             '    If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
             '    Helper.Assert(m_LocalBuilder IsNot Nothing)
             '    result = EmitVariableInitializer(Info) AndAlso result
             'ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
             '    result = EmitStaticInitializer(Info) AndAlso result
             'Else
             '    'Field builder has been defined in DefineMember
             '    'EmitVariableInitializer will be called by the constructor declaration
             'End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="107" nfragments="9" Csharpe_files="9" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1470" endline="1489">
<![CDATA[
 	}
 
 	sealed class PropertyMapTable 
 	{
 		internal const int Index = 0x15;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int PropertyList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1874" endline="1893">
<![CDATA[
 	}
 
 	sealed class FieldRVATable 
 	{
 		internal const int Index = 0x1D;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2382" endline="2401">
<![CDATA[
 	}
 
 	sealed class MethodSpecTable 
 	{
 		internal const int Index = 0x2B;
 
 		internal struct Record
 		{
 			internal int Method;
 			internal int Instantiation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1303" endline="1322">
<![CDATA[
 	}
 
 	sealed class FieldLayoutTable 
 	{
 		internal const int Index = 0x10;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2443" endline="2462">
<![CDATA[
 	}
 
 	sealed class GenericParamConstraintTable 
 	{
 		internal const int Index = 0x2C;
 
 		internal struct Record
 		{
 			internal int Owner;
 			internal int Constraint;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2218" endline="2237">
<![CDATA[
 	}
 
 	sealed class NestedClassTable 
 	{
 		internal const int Index = 0x29;
 
 		internal struct Record
 		{
 			internal int NestedClass;
 			internal int EnclosingClass;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1093" endline="1112">
<![CDATA[
 	}
 
 	sealed class FieldMarshalTable 
 	{
 		internal const int Index = 0x0D;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int NativeType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1392" endline="1411">
<![CDATA[
 	}
 
 	sealed class EventMapTable 
 	{
 		internal const int Index = 0x12;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int EventList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="108" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="893" endline="900">
<![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of GenericParameter)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="901" endline="908">
<![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="109" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2404" endline="2417">
<![CDATA[
 
     Private Function ParseUnaryPlusExpression(ByVal Info As ExpressionParseInfo) As UnaryPlusExpression
         Dim result As New UnaryPlusExpression(Info.Parent)
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Add)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2345" endline="2359">
<![CDATA[
 
 
     Private Function ParseUnaryMinusExpression(ByVal Info As ExpressionParseInfo) As UnaryMinusExpression
         Dim result As New UnaryMinusExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Minus)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="110" nfragments="16" Csharpe_files="0" vb_files="16" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1985" endline="1998">
<![CDATA[
 
     Private Function ParseCByteExpression(ByVal Parent As ParsedObject) As CByteExpression
         Dim result As New CByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1999" endline="2013">
<![CDATA[
 
     Private Function ParseCBoolExpression(ByVal Parent As ParsedObject) As CBoolExpression
         Dim result As New CBoolExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CBool)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2014" endline="2028">
<![CDATA[
 
     Private Function ParseCCharExpression(ByVal Parent As ParsedObject) As CCharExpression
         Dim result As New CCharExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CChar)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2029" endline="2043">
<![CDATA[
 
     Private Function ParseCDateExpression(ByVal Parent As ParsedObject) As CDateExpression
         Dim result As New CDateExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDate)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2044" endline="2058">
<![CDATA[
 
     Private Function ParseCDblExpression(ByVal Parent As ParsedObject) As CDblExpression
         Dim result As New CDblExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDbl)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2209" endline="2223">
<![CDATA[
 
     Private Function ParseCUShortExpression(ByVal Parent As ParsedObject) As CUShortExpression
         Dim result As New CUShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2059" endline="2073">
<![CDATA[
 
     Private Function ParseCDecExpression(ByVal Parent As ParsedObject) As CDecExpression
         Dim result As New CDecExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDec)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2074" endline="2088">
<![CDATA[
 
     Private Function ParseCIntExpression(ByVal Parent As ParsedObject) As CIntExpression
         Dim result As New CIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2089" endline="2103">
<![CDATA[
 
     Private Function ParseCLngExpression(ByVal Parent As ParsedObject) As CLngExpression
         Dim result As New CLngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CLng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2194" endline="2208">
<![CDATA[
 
     Private Function ParseCULngExpression(ByVal Parent As ParsedObject) As CULngExpression
         Dim result As New CULngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CULng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2104" endline="2118">
<![CDATA[
 
     Private Function ParseCObjExpression(ByVal Parent As ParsedObject) As CObjExpression
         Dim result As New CObjExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CObj)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2119" endline="2133">
<![CDATA[
 
     Private Function ParseCSByteExpression(ByVal Parent As ParsedObject) As CSByteExpression
         Dim result As New CSByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2134" endline="2148">
<![CDATA[
 
     Private Function ParseCShortExpression(ByVal Parent As ParsedObject) As CShortExpression
         Dim result As New CShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2149" endline="2163">
<![CDATA[
 
     Private Function ParseCSngExpression(ByVal Parent As ParsedObject) As CSngExpression
         Dim result As New CSngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2164" endline="2178">
<![CDATA[
 
     Private Function ParseCStrExpression(ByVal Parent As ParsedObject) As CStrExpression
         Dim result As New CStrExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CStr)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2179" endline="2193">
<![CDATA[
 
     Private Function ParseCUIntExpression(ByVal Parent As ParsedObject) As CUIntExpression
         Dim result As New CUIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="111" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1469" endline="1477">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeAs", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1301" endline="1309">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeIs", args);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="112" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="460" endline="466">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="467" endline="473">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="113" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="414" endline="424">
<![CDATA[
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="355" endline="365">
<![CDATA[
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="114" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="456" endline="471">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIntegerLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIntegerLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="446" endline="455">
<![CDATA[
 
     Function AcceptStringLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsStringLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="429" endline="445">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if the current token is an identifier
     ''' and advances to the next token.
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIdentifier(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIdentifier Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="115" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="507" endline="519">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="472" endline="488">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="116" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1391" endline="1398">
<![CDATA[
 
 		public void Encode (byte value)
 		{
 			if (pos == buffer.Length)
 				Grow (1);
 
 			buffer [pos++] = value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="94" endline="100">
<![CDATA[
 
 		internal void Write(byte value)
 		{
 			if (pos == buffer.Length)
 				Grow(1);
 			buffer[pos++] = value;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="117" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="617" endline="632">
<![CDATA[
 
 		/// <summary>
 		/// Returns custom name of indexer
 		/// </summary>
 		public string GetIndexerAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments [0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="633" endline="648">
<![CDATA[
 
 		/// <summary>
 		/// Returns condition of ConditionalAttribute
 		/// </summary>
 		public string GetConditionalAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments[0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="118" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2020" endline="2027">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2044" endline="2051">
<![CDATA[
 
 		public void EmitAttribute (TypeBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2028" endline="2035">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2036" endline="2043">
<![CDATA[
 
 		public void EmitAttribute (PropertyBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="119" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7108" endline="7118">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7293" endline="7300">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1655" endline="1662">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="159" endline="167">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="120" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3145" endline="3157">
<![CDATA[
 
     Private Function ParseExponent(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIdentifier(Info)
 
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3194" endline="3206">
<![CDATA[
 
     Private Function ParseIntDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMultDiv(Info)
 
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3207" endline="3219">
<![CDATA[
 
     Private Function ParseMod(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIntDiv(Info)
 
         While tm.Accept(KS.Mod)
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Mod)
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3243" endline="3255">
<![CDATA[
 
     Private Function ParseConcat(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParsePlusMinus(Info)
 
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="121" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1200" endline="1210">
<![CDATA[
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1174" endline="1184">
<![CDATA[
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="122" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="90" endline="98">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Lock.ResolveExpression(INfo) AndAlso result
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="108" endline="118">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_UsingResources.ResolveCode(Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="123" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="124" endline="135">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsBuiltInTypeName Then
                 Return AsBuiltInTypeName.Name
             ElseIf IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="136" endline="153">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The namespace or type that is imported.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             If IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             ElseIf IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="96" endline="107">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             ElseIf Me.IsSimpleTypeName Then
                 Return AsSimpleTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="191" endline="200">
<![CDATA[
 
     Overrides Function ToString() As String
         If IsConstructedTypeName Then
             Return AsConstructedTypeName.Name
         ElseIf IsSimpleTypeName Then
             Return AsSimpleTypeName.Name
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="124" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="145" endline="152">
<![CDATA[
 
 		internal void WriteParamTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="921" endline="928">
<![CDATA[
 
 		internal void WriteParamRecords(MetadataWriter mw)
 		{
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteParamRecords(mw);
 			}
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteParamRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="929" endline="936">
<![CDATA[
 
 		internal void WriteFieldRecords(MetadataWriter mw)
 		{
 			foreach (FieldBuilder fb in fields)
 			{
 				fb.WriteFieldRecords(mw);
 			}
 			foreach (FieldBuilder fb in fields)
 			{
 				fb.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="125" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="59" endline="67">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			PropertySignature other = obj as PropertySignature;
 			return other != null
 				&& other.propertyType.Equals(propertyType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="51" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			FieldSignature other = obj as FieldSignature;
 			return other != null
 				&& other.fieldType.Equals(fieldType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="126" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="54" endline="62">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeName(NewParent)
 
         result.Init(m_TypeName.Clone(result), m_ArrayTypeModifiers.Clone(result))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="61" endline="67">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstructedTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstructedTypeName(NewParent)
         result.Init(m_QualifiedIdentifier.Clone(result), m_TypeArgumentList.Clone(result))
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="127" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4795" endline="4811">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseLocalVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4778" endline="4794">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseTypeVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As Generic.List(Of TypeVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseTypeVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="128" nfragments="14" Csharpe_files="0" vb_files="14" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="68" endline="77">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="71" endline="80">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="34" endline="42">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="129" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="130" nfragments="13" Csharpe_files="0" vb_files="13" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceEventMemberDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceFunctionDeclaration.vb" startline="36" endline="43">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Function)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfacePropertyMemberDeclaration.vb" startline="33" endline="40">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceSubDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Sub)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="72" endline="79">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Interface)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MustOverridePropertyDeclaration.vb" startline="32" endline="39">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="75" endline="82">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Module)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Enum)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularPropertyDeclaration.vb" startline="35" endline="42">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="44" endline="51">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Structure)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="541" endline="548">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Class)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="183" endline="190">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Delegate)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="131" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="147" endline="154">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="52" endline="60">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then result = m_ParameterList.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="132" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="691" endline="701">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (RSA rsa, bool includePrivateKey) 
 		{
 			if (rsa == null)
 				throw new ArgumentNullException ("rsa");
 
 			if (includePrivateKey)
 				return ToCapiPrivateKeyBlob (rsa);
 			else
 				return ToCapiPublicKeyBlob (rsa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="702" endline="712">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (DSA dsa, bool includePrivateKey)
 		{
 			if (dsa == null)
 				throw new ArgumentNullException ("dsa");
 
 			if (includePrivateKey)
 				return ToCapiPrivateKeyBlob (dsa);
 			else
 				return ToCapiPublicKeyBlob (dsa);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="133" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="36" endline="43">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LSide.ResolveTypeReferences AndAlso result
         result = m_RSide.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="49" endline="58">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveTypeReferences AndAlso result
         result = m_RightExpression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="134" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="100" endline="113">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1025" endline="1038">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="135" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5223" endline="5230">
<![CDATA[
 
     Private Function ParseRedimClauses(ByVal Parent As ReDimStatement) As RedimClauses
         Dim result As New RedimClauses(Parent)
         If ParseList(Of RedimClause)(result, New ParseDelegate_Parent(Of RedimClause)(AddressOf ParseRedimClause), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2958" endline="2967">
<![CDATA[
 
     Private Function ParseExpressionList(ByVal Parent As ParsedObject) As ExpressionList
         Dim result As New ExpressionList(Parent)
 
         If ParseList(Of Expression)(result, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3510" endline="3525">
<![CDATA[
 
     ''' <summary>
     ''' VariableIdentifiers  
     '''	            VariableIdentifier  |
     '''	            VariableIdentifiers  ,  VariableIdentifier
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifiers(ByVal Parent As ParsedObject) As VariableIdentifiers
         Dim result As New VariableIdentifiers(Parent)
 
         If ParseList(Of VariableIdentifier)(result, New ParseDelegate_Parent(Of VariableIdentifier)(AddressOf ParseVariableIdentifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="136" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="57" endline="66">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Operand.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="61" endline="70">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="137" nfragments="7" Csharpe_files="0" vb_files="7" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="138" endline="146">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="31" endline="37">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_VariableInitializerList IsNot Nothing Then result = m_VariableInitializerList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="55" endline="62">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="81" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="46" endline="53">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedLabel IsNot Nothing Then result = m_ResolvedLabel.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="138" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="148" endline="160">
<![CDATA[
 		}
 
 		public string FullName
 		{
 			get
 			{
 				string str = name.FullName;
 				if (culture != null)
 				{
 					str = str.Replace("Culture=neutral", "Culture=" + culture);
 				}
 				return str;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="52" endline="61">
<![CDATA[
 
 		public override string ToString()
 		{
 			string str = name.ToString();
 			if (culture != null)
 			{
 				str = str.Replace("Culture=neutral", "Culture=" + culture);
 			}
 			return str;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="139" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1545" endline="1556">
<![CDATA[
 
 		//
 		// Encodes single field named argument per call
 		//
 		public void EncodeNamedFieldArgument (FieldSpec field, Constant value)
 		{
 			Encode ((ushort) 1);	// length
 			Encode ((byte) 0x53); // field
 			Encode (field.MemberType);
 			Encode (field.Name);
 			value.EncodeAttributeValue (null, this, field.MemberType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1533" endline="1544">
<![CDATA[
 
 		//
 		// Encodes single property named argument per call
 		//
 		public void EncodeNamedPropertyArgument (PropertySpec property, Constant value)
 		{
 			Encode ((ushort) 1);	// length
 			Encode ((byte) 0x54); // property
 			Encode (property.MemberType);
 			Encode (property.Name);
 			value.EncodeAttributeValue (null, this, property.MemberType);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="140" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="591" endline="600">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attribs |= TypeAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="267" endline="276">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attributes |= MethodAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="141" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="486" endline="507">
<![CDATA[
 
     Function GenerateMyLog() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        Private Shared ReadOnly m_LogObjectProvider As ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog) = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)" & VB.vbNewLine & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application.Log"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Log As Global.Microsoft.VisualBasic.Logging.AspLog" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Return MyProject.m_LogObjectProvider.GetInstance" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         'ProjectCodeCctor.AppendLine("            m_LogObjectProvider = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="559" endline="583">
<![CDATA[
 
     Function GenerateMyRequest() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Request"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Request As Global.System.Web.HttpRequest" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Request" & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="590" endline="614">
<![CDATA[
 
     Function GenerateMyResponse() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Response"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Response As Global.System.Web.HttpResponse" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Response    " & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="142" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" startline="75" endline="82">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Get
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Function
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="63" endline="74">
<![CDATA[
 
     ''' <summary>
     ''' Checks for the following grammar
     ''' ConstantMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Const
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="143" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="574" endline="584">
<![CDATA[
 
 		internal int ImportMember(FieldInfo member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="563" endline="573">
<![CDATA[
 
 		internal int ImportMember(MethodBase member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="144" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="709" endline="716">
<![CDATA[
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, this.arguments,
 				InstanceExpr.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Invoke", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8080" endline="8087">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, Arguments,
 				Expr.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "ArrayIndex", args);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="145" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2362" endline="2371">
<![CDATA[
 		}
 
 		internal override int GetModuleBuilderToken()
 		{
 			if (token == 0)
 			{
 				token = ((ModuleBuilder)type.Module).ImportType(this);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1600" endline="1609">
<![CDATA[
 		}
 
 		internal sealed override int GetModuleBuilderToken()
 		{
 			if (token == 0)
 			{
 				token = ((ModuleBuilder)elementType.Module).ImportType(this);
 			}
 			return token;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="146" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1326" endline="1339">
<![CDATA[
 
     ''' <summary>
     ''' Loads the boolean value onto the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Overloads Shared Sub EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Boolean)
         If Value Then
             EmitLoadI4Value(Info, 1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1150" endline="1157">
<![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Boolean)
         If I Then
             EmitLoadI4Value(Info, -1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="147" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="552" endline="562">
<![CDATA[
 
 		public void AddOperator (Operator op)
 		{
 			if (!AddMember (op))
 				return;
 
 			if (operators == null)
 				operators = new List<MemberCore> ();
 
 			operators.Add (op);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="527" endline="537">
<![CDATA[
 
 		public void AddEvent (Event e)
 		{
 			if (!AddMember (e))
 				return;
 
 			if (events == null)
 				events = new List<MemberCore> ();
 
 			events.Add (e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="327" endline="337">
<![CDATA[
 
 		public void AddConstant (Const constant)
 		{
 			if (!AddMember (constant))
 				return;
 
 			if (constants == null)
 				constants = new List<MemberCore> ();
 			
 			constants.Add (constant);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="148" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="296" endline="302">
<![CDATA[
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="313" endline="324">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="149" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="213" endline="222">
<![CDATA[
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="199" endline="212">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="172" endline="184">
<![CDATA[
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="150" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1354" endline="1366">
<![CDATA[
 	}
 
 	sealed class StandAloneSigTable 
 	{
 		internal const int Index = 0x11;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1786" endline="1798">
<![CDATA[
 	}
 
 	sealed class TypeSpecTable 
 	{
 		internal const int Index = 0x1B;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1746" endline="1758">
<![CDATA[
 	}
 
 	sealed class ModuleRefTable 
 	{
 		internal const int Index = 0x1A;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="151" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="85" endline="91">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New LiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="32" endline="38">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New BooleanLiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="152" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="909" endline="917">
<![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tR As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         If tR Is Nothing Then
             Return GetTypes(Type.GenericParameters)
         Else
             Return GetTypes(tR.GenericArguments)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="918" endline="926">
<![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Method As Mono.Cecil.MethodReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim mR As Mono.Cecil.GenericInstanceMethod = TryCast(Method, Mono.Cecil.GenericInstanceMethod)
         If mR Is Nothing Then
             Return GetTypes(Method.GenericParameters)
         Else
             Return GetTypes(mR.GenericArguments)
         End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="153" nfragments="9" Csharpe_files="9" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="263" endline="274">
<![CDATA[
 
 		internal void WriteField(int index)
 		{
 			if (bigField)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="275" endline="286">
<![CDATA[
 
 		internal void WriteMethodDef(int index)
 		{
 			if (bigMethodDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="287" endline="298">
<![CDATA[
 
 		internal void WriteParam(int index)
 		{
 			if (bigParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="299" endline="310">
<![CDATA[
 
 		internal void WriteTypeDef(int index)
 		{
 			if (bigTypeDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="311" endline="322">
<![CDATA[
 
 		internal void WriteEvent(int index)
 		{
 			if (bigEvent)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="323" endline="334">
<![CDATA[
 
 		internal void WriteProperty(int index)
 		{
 			if (bigProperty)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="335" endline="346">
<![CDATA[
 
 		internal void WriteGenericParam(int index)
 		{
 			if (bigGenericParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="347" endline="358">
<![CDATA[
 
 		internal void WriteModuleRef(int index)
 		{
 			if (bigModuleRef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="550" endline="563">
<![CDATA[
 
 		internal void WriteHasFieldMarshal(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasFieldMarshal)
 			{
 				Write(encodedToken & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="154" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="39" endline="45">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArgumentExpression
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArgumentExpression(NewParent)
         result.Init(m_Expression.Clone(result))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="54" endline="60">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterConstraints
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterConstraints(NewParent)
         result.Init(m_ConstraintList.clone(result))
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="155" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="140" endline="147">
<![CDATA[
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             If m_InstanceExpression Is Nothing AndAlso m_Classification IsNot Nothing Then
                 m_InstanceExpression = m_Classification.InstanceExpression
             End If
             Return m_InstanceExpression
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="45" endline="53">
<![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ArgumentList
         Get
             If m_Parameters Is Nothing AndAlso m_Classification IsNot Nothing Then
                 m_Parameters = m_Classification.Parameters
             End If
             Return m_Parameters
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="156" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="785" endline="793">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, false);
 			else
 				base.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="794" endline="802">
<![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, true);
 			else
 				base.EmitStatement (ec);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="157" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1255" endline="1266">
<![CDATA[
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="97" endline="112">
<![CDATA[
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			bool res = base.CheckOverrideAgainstBase (base_member);
 
 			//
 			// Check that the permissions are not being changed
 			//
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				res = false;
 			}
 
 			return res;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="158" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1367" endline="1374">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1759" endline="1766">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1799" endline="1806">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="159" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="326" endline="334">
<![CDATA[
 		}
 
 		public override Type DeclaringType
 		{
 			get
 			{
 				int owner = module.GenericParam.records[index].Owner;
 				return (owner >> 24) == TypeDefTable.Index ? module.ResolveType(owner) 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="335" endline="343">
<![CDATA[
 		}
 
 		public override MethodBase DeclaringMethod
 		{
 			get
 			{
 				int owner = module.GenericParam.records[index].Owner;
 				return (owner >> 24) == MethodDefTable.Index ? module.ResolveMethod(owner) 
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="160" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="655" endline="663">
<![CDATA[
 
 		private void WriteToken(MethodToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="646" endline="654">
<![CDATA[
 
 		private void WriteToken(FieldToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="161" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="62" endline="71">
<![CDATA[
 
 		public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, PropertyInfo[] namedProperties, object[] propertyValues, FieldInfo[] namedFields, object[] fieldValues)
 		{
 			this.con = con;
 			this.constructorArgs = constructorArgs;
 			this.namedProperties = namedProperties;
 			this.propertyValues = propertyValues;
 			this.namedFields = namedFields;
 			this.fieldValues = fieldValues;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\StandAloneMethodSig.cs" startline="39" endline="47">
<![CDATA[
 		internal __StandAloneMethodSig(bool unmanaged, CallingConvention unmanagedCallingConvention, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
 		{
 			this.unmanaged = unmanaged;
 			this.unmanagedCallingConvention = unmanagedCallingConvention;
 			this.callingConvention = callingConvention;
 			this.returnType = returnType;
 			this.parameterTypes = parameterTypes;
 			this.optionalParameterTypes = optionalParameterTypes;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="162" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1993" endline="2002">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2336" endline="2345">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="163" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="582" endline="593">
<![CDATA[
 
 		public static IList<CustomAttributeData> __GetDeclarativeSecurity(MethodBase method)
 		{
 			if ((method.Attributes & MethodAttributes.HasSecurity) != 0)
 			{
 				return method.Module.GetDeclarativeSecurity(method.MetadataToken);
 			}
 			else
 			{
 				return EmptyList;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="570" endline="581">
<![CDATA[
 
 		public static IList<CustomAttributeData> __GetDeclarativeSecurity(Type type)
 		{
 			if ((type.Attributes & TypeAttributes.HasSecurity) != 0)
 			{
 				return type.Module.GetDeclarativeSecurity(type.MetadataToken);
 			}
 			else
 			{
 				return EmptyList;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="164" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1418" endline="1426">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly(bool in_checked_context, TypeSpec target_type)
 		{
 			if (Child.Type == target_type)
 				return Child;
 
 			return Child.ConvertExplicitly (in_checked_context, target_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1249" endline="1257">
<![CDATA[
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (child.Type == target_type)
 				return child;
 
 			// FIXME
 			return child.ConvertExplicitly (in_checked_context, target_type);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="165" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1409" endline="1417">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakeByRefType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1446" endline="1454">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakePointerType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="166" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="420" endline="432">
<![CDATA[
 
     ''' <summary>
     ''' Compares two vb-names (case-insensitive)
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, StringComparison.OrdinalIgnoreCase)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="452" endline="464">
<![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareNameOrdinal(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, System.StringComparison.Ordinal)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="167" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5755" endline="5763">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Foreach target = (Foreach) t;
 
 			target.type = type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4518" endline="4526">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Conditional target = (Conditional) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.true_expr = true_expr.Clone (clonectx);
 			target.false_expr = false_expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="168" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="453" endline="459">
<![CDATA[
 			set {
 				set = value;
 				if (first == null)
 					first = value;
 
 				Parent.AddMember (set);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="440" endline="446">
<![CDATA[
 			set {
 				get = value;
 				if (first == null)
 					first = value;
 
 				Parent.AddMember (get);
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="169" nfragments="6" Csharpe_files="0" vb_files="6" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="209" endline="215">
<![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="216" endline="222">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyGroupClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="223" endline="229">
<![CDATA[
 
     Sub New(ByVal Classification As MethodGroupClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="230" endline="236">
<![CDATA[
 
     Sub New(ByVal Classification As MethodPointerClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="237" endline="243">
<![CDATA[
 
     Sub New(ByVal Classification As LateBoundAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="244" endline="250">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="170" nfragments="9" Csharpe_files="9" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="150" endline="161">
<![CDATA[
 
 		internal void WriteStringIndex(int index)
 		{
 			if (bigStrings)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="162" endline="173">
<![CDATA[
 
 		internal void WriteGuidIndex(int index)
 		{
 			if (bigGuids)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="174" endline="185">
<![CDATA[
 
 		internal void WriteBlobIndex(int index)
 		{
 			if (bigBlobs)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="513" endline="526">
<![CDATA[
 
 		internal void WriteHasDeclSecurity(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasDeclSecurity)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="499" endline="512">
<![CDATA[
 
 		internal void WriteTypeOrMethodDef(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigTypeOrMethodDef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="214" endline="225">
<![CDATA[
 
 		internal void WriteEncodedTypeDefOrRef(int encodedToken)
 		{
 			if (bigTypeDefOrRef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="226" endline="239">
<![CDATA[
 
 		internal void WriteHasCustomAttribute(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasCustomAttribute)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="457" endline="470">
<![CDATA[
 
 		internal void WriteHasSemantics(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasSemantics)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="171" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="535" endline="543">
<![CDATA[
 
 		public Attribute ResolveAssemblyAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("assembly", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="544" endline="552">
<![CDATA[
 
 		Attribute ResolveModuleAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("module", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="172" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="125" endline="134">
<![CDATA[
     End Property
 
     Public ReadOnly Property GetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Get IsNot Nothing Then
                 Return m_Get.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="141" endline="150">
<![CDATA[
     End Property
 
     Public ReadOnly Property SetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Set IsNot Nothing Then
                 Return m_Set.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="153" endline="162">
<![CDATA[
     End Property
 
     ReadOnly Property LocalBuilder() As Mono.Cecil.Cil.VariableDefinition
         Get
             If m_LocalVariable IsNot Nothing Then
                 Return m_LocalVariable.LocalBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="173" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1418" endline="1428">
<![CDATA[
 
 		public static ReferenceContainer MakeType (TypeSpec element)
 		{
 			ReferenceContainer pc;
 			if (!instances.TryGetValue (element, out pc)) {
 				pc = new ReferenceContainer (element);
 				instances.Add (element, pc);
 			}
 
 			return pc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1460" endline="1470">
<![CDATA[
 
 		public static PointerContainer MakeType (TypeSpec element)
 		{
 			PointerContainer pc;
 			if (!instances.TryGetValue (element, out pc)) {
 				pc = new PointerContainer (element);
 				instances.Add (element, pc);
 			}
 
 			return pc;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="174" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="222" endline="228">
<![CDATA[
 
     Shared Sub EmitLE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Cgt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="199" endline="205">
<![CDATA[
 
     Shared Sub EmitGE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Clt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="192" endline="198">
<![CDATA[
 
     Shared Sub EmitNotEquals(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Ceq)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="175" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3380" endline="3397">
<![CDATA[
 
     ''' <summary>
     ''' AddressOfExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddressOfExpression(ByVal Parent As ParsedObject) As AddressOfExpression
         Dim result As New AddressOfExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.AddressOf)
 
         m_Expression = ParseExpression(result)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5880" endline="5891">
<![CDATA[
 
     Private Function ParseCallStatement(ByVal Parent As ParsedObject) As CallStatement
         Dim result As New CallStatement(Parent)
 
         Dim m_Target As Expression
         tm.AcceptIfNotInternalError(KS.Call)
         m_Target = ParseExpression(result)
 
         result.Init(m_Target)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="176" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="67" endline="75">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="76" endline="84">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.PropertyReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="177" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="66" endline="78">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructor() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="79" endline="91">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructorCecil() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="178" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="443" endline="452">
<![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="550" endline="559">
<![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="179" nfragments="8" Csharpe_files="8" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="494" endline="505">
<![CDATA[
 
 		internal int ReadEvent()
 		{
 			if (bigEvent)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="482" endline="493">
<![CDATA[
 
 		internal int ReadProperty()
 		{
 			if (bigProperty)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="470" endline="481">
<![CDATA[
 
 		internal int ReadParam()
 		{
 			if (bigParam)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="458" endline="469">
<![CDATA[
 
 		internal int ReadMethodDef()
 		{
 			if (bigMethodDef)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="446" endline="457">
<![CDATA[
 
 		internal int ReadField()
 		{
 			if (bigField)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="80" endline="91">
<![CDATA[
 
 		internal int ReadBlobIndex()
 		{
 			if (bigBlobs)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="68" endline="79">
<![CDATA[
 
 		internal int ReadGuidIndex()
 		{
 			if (bigGuids)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="180" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="280" endline="288">
<![CDATA[
 
     Function IsIntegerLiteral() As Boolean
         Select Case m_TokenType
             Case TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="260" endline="269">
<![CDATA[
     End Property
 
     Function IsLiteral() As Boolean
         Select Case m_TokenType
             Case TokenType.DateLiteral, TokenType.CharLiteral, TokenType.DecimalLiteral, TokenType.DoubleLiteral, TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.SingleLiteral, TokenType.StringLiteral, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="181" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="465" endline="473">
<![CDATA[
 
 		public void AddInterfaceImplementation(Type interfaceType)
 		{
 			if (interfaces == null)
 			{
 				interfaces = new List<Type>();
 			}
 			interfaces.Add(interfaceType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="66" endline="74">
<![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="182" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="354" endline="363">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// TODO
 			LocalTemporary value_target = new LocalTemporary (type);
 
 			value_target.AddressOf (ec, AddressOp.Store);
 			ec.Emit (OpCodes.Initobj, type);
 			value_target.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1689" endline="1697">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			LocalTemporary temp_storage = new LocalTemporary(type);
 
 			temp_storage.AddressOf(ec, AddressOp.LoadStore);
 			ec.Emit(OpCodes.Initobj, type);
 			temp_storage.Emit(ec);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="183" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="99" endline="106">
<![CDATA[
 
 		public void AddDefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="107" endline="114">
<![CDATA[
 
 		public void AddUndefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = false;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="184" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="93" endline="102">
<![CDATA[
     End Property
 
     ReadOnly Property RaiseDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RaiseMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RaiseMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="83" endline="92">
<![CDATA[
     End Property
 
     ReadOnly Property RemoveDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RemoveMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RemoveMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="73" endline="82">
<![CDATA[
     End Property
 
     ReadOnly Property AddDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_AddMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_AddMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="185" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4181" endline="4197">
<![CDATA[
 	}
 
 	public class PointerArithmetic 
 		Expression left, right;
 		Binary.Operator op;
 
 		//
 		// We assume that `l' is always a pointer
 		//
 		public PointerArithmetic (Binary.Operator op, Expression l, Expression r, TypeSpec t, Location loc)
 		{
 			type = t;
 			this.loc = loc;
 			left = l;
 			right = r;
 			this.op = op;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5694" endline="5710">
<![CDATA[
 
 			#endregion
 		}
 
 		Expression type;
 		LocalVariable variable;
 		Expression expr;
 		Statement statement;
 
 		public Foreach (Expression type, LocalVariable var, Expression expr, Statement stmt, Location l)
 		{
 			this.type = type;
 			this.variable = var;
 			this.expr = expr;
 			statement = stmt;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="69" endline="246">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Class for applying custom attributes on the return type
 	/// </summary>
 	public class ReturnParameter 
 	{
 		MemberCore method;
 
 		// TODO
 		public ReturnParameter (MemberCore method, MethodBuilder mb, Location location)
 		{
 			this.method = method;
 			try {
 				builder = mb.DefineParameter (0, ParameterAttributes.None, "");			
 			}
 			catch (ArgumentOutOfRangeException) {
 				method.Compiler.Report.RuntimeMissingSupport (location, "custom attributes on the return type");
 			}
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant) {
 				method.Compiler.Report.Warning (3023, 1, a.Location,
 					"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead");
 			}
 
 			// This occurs after Warning -28
 			if (builder == null)
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.ReturnValue;
 			}
 		}
 
 		/// <summary>
 		/// Is never called
 		/// </summary>
 		public override string[] ValidAttributeTargets {
 			get {
 				return null;
 			}
 		}
 	}
 
 	public class ImplicitLambdaParameter 
 	{
 		public ImplicitLambdaParameter (string name, Location loc)
 			
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
 
 		public void SetParameterType (TypeSpec type)
 		{
 			parameter_type = type;
 		}
 	}
 
 	public class ParamsParameter 
 		public ParamsParameter (FullNamedExpression type, string name, Attributes attrs, Location loc)
 			base (type, name, Parameter.Modifier.PARAMS, attrs, loc)
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (base.Resolve (ec, index) == null)
 				return null;
 
 			var ac = parameter_type as ArrayContainer;
 			if (ac == null || ac.Rank != 1) {
 				ec.Compiler.Report.Error (225, Location, "The params parameter must be a single dimensional array");
 				return null;
 			}
 
 			return parameter_type;
 		}
 
 		public override void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			base.ApplyAttributes (mb, cb, index, pa);
 			pa.ParamArray.EmitAttribute (builder);
 		}
 	}
 
 	public class ArglistParameter 
 		// Doesn't have proper type because it's never chosen for better conversion
 		public ArglistParameter (Location loc) 
 			base (null, String.Empty, Parameter.Modifier.NONE, null, loc)
 		{
 			parameter_type = InternalType.Arglist;
 		}
 
 		public override void  ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			// Nothing to do
 		}
 
 		public override bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			return true;
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			return parameter_type;
 		}
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="44" endline="51">
<![CDATA[
 		internal PropertyBuilder(TypeBuilder typeBuilder, string name, PropertyAttributes attributes, PropertySignature sig, bool patchCallingConvention)
 		{
 			this.typeBuilder = typeBuilder;
 			this.name = name;
 			this.attributes = attributes;
 			this.sig = sig;
 			this.patchCallingConvention = patchCallingConvention;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="41" endline="48">
<![CDATA[
 		private MethodSignature(Type returnType, Type[] parameterTypes, Type[][][] modifiers, CallingConventions callingConvention, int genericParamCount)
 		{
 			this.returnType = returnType;
 			this.parameterTypes = parameterTypes;
 			this.modifiers = modifiers;
 			this.callingConvention = callingConvention;
 			this.genericParamCount = genericParamCount;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="451" endline="471">
<![CDATA[
 	}
 
 	public class For 
 		Expression Test;
 		Statement InitStatement;
 		Statement Increment;
 		public Statement Statement;
 		bool infinite, empty;
 		
 		public For (Statement init_statement,
 			    BooleanExpression test,
 			    Statement increment,
 			    Statement statement,
 			    Location l)
 		{
 			InitStatement = init_statement;
 			Test = test;
 			Increment = increment;
 			Statement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="186" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="421" endline="432">
<![CDATA[
 		}
 
 		public IList<CustomAttributeTypedArgument> ConstructorArguments
 		{
 			get
 			{
 				if (lazyConstructorArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyConstructorArguments;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="433" endline="444">
<![CDATA[
 		}
 
 		public IList<CustomAttributeNamedArgument> NamedArguments
 		{
 			get
 			{
 				if (lazyNamedArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyNamedArguments;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="187" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1100" endline="1108">
<![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddBreakOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1127" endline="1135">
<![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddContinueOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="188" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1645" endline="1653">
<![CDATA[
 
 		public void Emit (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Ldloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1654" endline="1662">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="189" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3048" endline="3057">
<![CDATA[
 		}
 
 		public override string Name {
 			get {
 				if (best_candidate != null)
 					return best_candidate.Name;
 
 				// TODO
 				return Methods.First ().Name;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3075" endline="3082">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (best_candidate != null)
 				return best_candidate.GetSignatureForError ();
 
 			return Methods.First ().GetSignatureForError ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="190" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4025" endline="4033">
<![CDATA[
 
 		public override Label PrepareForDispose (EmitContext ec, Label end)
 		{
 			if (!prepared_for_dispose) {
 				prepared_for_dispose = true;
 				dispose_try_block = ec.DefineLabel ();
 			}
 			return dispose_try_block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3897" endline="3912">
<![CDATA[
 	}
 
 	// A place where execution can restart in an iterator
 	public abstract class ResumableStatement 
 	{
 		bool prepared;
 		protected Label resume_point;
 
 		public Label PrepareForEmit (EmitContext ec)
 		{
 			if (!prepared) {
 				prepared = true;
 				resume_point = ec.DefineLabel ();
 			}
 			return resume_point;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="191" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3023" endline="3032">
<![CDATA[
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3033" endline="3041">
<![CDATA[
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="192" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="221" endline="229">
<![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="196" endline="204">
<![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="193" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1262" endline="1274">
<![CDATA[
 		}
 
 		#endregion
 
 		public abstract List<MissingType> ResolveMissingDependencies ();
 
 		public string[] ConditionalConditions ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Conditionals;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1275" endline="1282">
<![CDATA[
 
 		public ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1283" endline="1290">
<![CDATA[
 
 		public bool IsNotCLSCompliant ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.IsNotCLSCompliant;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1716" endline="1723">
<![CDATA[
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.CoClass;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1724" endline="1731">
<![CDATA[
 
 		public string GetAttributeDefaultMember ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.DefaultIndexerName;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1732" endline="1739">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.AttributeUsage;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="194" nfragments="5" Csharpe_files="0" vb_files="5" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences() AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="83" endline="92">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="40" endline="48">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="105" endline="114">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="181" endline="192">
<![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         'Helper.SetTypeOrTypeBuilder(Compiler, ParameterTypes)
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="195" nfragments="9" Csharpe_files="0" vb_files="9" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="46" endline="53">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="32" endline="38">
<![CDATA[
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AttributeArgumentExpression.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info) AndAlso result 'Helper.NotImplemented()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="64" endline="72">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Initializer.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="47" endline="56">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.ResolveExpression(info) AndAlso result
 
         Compiler.Helper.AddCheck("The expression must be classified as a value and its type must be implicitly convertible to Integer.")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="96" endline="103">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="325" endline="332">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="117" endline="125">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AssignStatement.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="66" endline="77">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Clauses.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Each clause in the statement must be classified as a variable or a property access whose type is an array type or Object, and be followed by a list of array bounds. ")
         Compiler.Helper.AddCheck("The number of the bounds must be consistent with the type of the variable; any number of bounds is allowed for Object.")
         Compiler.Helper.AddCheck("If the Preserve keyword is specified, then the expressions must also be classifiable as a value, and the new size for each dimension except for the rightmost one must be the same as the size of the existing array. ")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="196" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="97" endline="105">
<![CDATA[
     End Property
 
     ReadOnly Property AttributeArguments() As AttributeArguments
         Get
             If m_AttributeArguments Is Nothing Then
                 m_AttributeArguments = New AttributeArguments(Me)
             End If
             Return m_AttributeArguments
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="68" endline="76">
<![CDATA[
     End Property
 
     ReadOnly Property VariablePropertyInitializerList() As VariablePropertyInitializerList
         Get
             If m_VariablePropertyInitializerList Is Nothing Then
                 m_VariablePropertyInitializerList = New VariablePropertyInitializerList(Me)
             End If
             Return m_VariablePropertyInitializerList
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="60" endline="67">
<![CDATA[
 
     ReadOnly Property PositionalArgumentList() As AttributePositionalArgumentList
         Get
             If m_AttributePositionalArgumentList Is Nothing Then
                 m_AttributePositionalArgumentList = New AttributePositionalArgumentList(Me)
             End If
             Return m_AttributePositionalArgumentList
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="113" endline="121">
<![CDATA[
     End Property
 
     Property TypeParameterConstraints() As TypeParameterConstraints
         Get
             If m_TypeParameterConstraints Is Nothing Then
                 m_TypeParameterConstraints = New TypeParameterConstraints(Me)
             End If
             Return m_TypeParameterConstraints
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="197" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1249" endline="1259">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (Declarator decl)
 		{
 			if (declarators == null)
 				declarators = new List<Declarator> ();
 
 			declarators.Add (decl);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="290" endline="302">
<![CDATA[
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="198" nfragments="8" Csharpe_files="0" vb_files="8" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="47" endline="54">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="37" endline="44">
<![CDATA[
 
     Shared Function IsUnaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="64" endline="71">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="72" endline="79">
<![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="53" endline="60">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="199" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="369" endline="375">
<![CDATA[
 
 		public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes)
 		{
 			FieldBuilder fb = new FieldBuilder(this, fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes);
 			fields.Add(fb);
 			return fb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="753" endline="759">
<![CDATA[
 
 		private AssemblyBuilder DefineDynamicAssemblyImpl(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 		{
 			AssemblyBuilder asm = new AssemblyBuilder(this, name, dir, requiredPermissions, optionalPermissions, refusedPermissions);
 			dynamicAssemblies.Add(asm);
 			return asm;
  		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="200" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="373" endline="389">
<![CDATA[
 	}
 
 	//
 	// Generic lifting expression, supports all S/S? -> T/T? cases
 	//
 	public class Lifted 
 	{
 		Expression expr, null_value;
 		Unwrap unwrap;
 
 		public Lifted (Expression expr, Unwrap unwrap, TypeSpec type)
 		{
 			this.expr = expr;
 			this.unwrap = unwrap;
 			this.loc = expr.Location;
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8741" endline="8780">
<![CDATA[
 
 		private EmptyExpressionStatement ()
 		{
 			loc = Location.Null;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return null;
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// Do nothing
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 			type = TypeManager.object_type;
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			// Do nothing
 		}
 	}	
 
 	public class UserCast 
 		MethodSpec method;
 		Expression source;
 		
 		public UserCast (MethodSpec method, Expression source, Location l)
 		{
 			this.method = method;
 			this.source = source;
 			type = method.ReturnType;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="201" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="39" endline="45">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal IsResumeNext As Boolean, ByVal Label As Token, ByVal IsGotoMinusOne As Boolean, ByVal IsGotoZero As Boolean)
         MyBase.New(Parent)
         m_IsResumeNext = IsResumeNext
         m_Label = Label
         m_IsGotoMinusOne = IsGotoMinusOne
         m_IsGotoZero = IsGotoZero
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="73" endline="81">
<![CDATA[
 
     Shadows Sub Init(ByVal Condition As Expression, ByVal FalseCode As CodeBlock, ByVal TrueCode As CodeBlock, ByVal OneLiner As Boolean, ByVal ElseIfs As BaseObjects(Of ElseIfStatement))
         MyBase.Init(TrueCode)
 
         m_Condition = Condition
         m_FalseCode = FalseCode
         m_ElseIfs = ElseIfs
         m_OneLiner = OneLiner
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="202" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="58" endline="66">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="203" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1233" endline="1243">
<![CDATA[
 
 		protected override bool ResolveNamedArguments (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveNamedArguments (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1222" endline="1232">
<![CDATA[
 
 		protected override MethodSpec ResolveConstructor (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveConstructor (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="204" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="205" endline="212">
<![CDATA[
 		public MethodSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition details, TypeSpec returnType,
 			MethodBase info, AParametersCollection parameters, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.parameters = parameters;
 			this.returnType = returnType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1740" endline="1750">
<![CDATA[
 
 		public MethodData (InterfaceMemberBase member,
 				   Modifiers modifiers, MethodAttributes flags, 
 				   IMethodData method, MethodBuilder builder,
 				   GenericMethod generic, MethodSpec parent_method)
 			
 		{
 			this.builder = builder;
 			this.GenericMethod = generic;
 			this.parent_method = parent_method;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="205" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="272" endline="279">
<![CDATA[
 
     Shared Sub EmitMultOrMultOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitMultOvf(Info, OperandType)
         Else
             EmitMult(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="249" endline="256">
<![CDATA[
 
     Shared Sub EmitAddOrAddOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitAddOvf(Info, OperandType)
         Else
             EmitAdd(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="154" endline="161">
<![CDATA[
 
     Shared Sub EmitSubOrSubOvfOrSubOvfUn(ByVal Info As EmitInfo, ByVal SubType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitSubOvf(Info, SubType)
         Else
             EmitSub(Info, SubType)
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="206" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="48" endline="55">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_ReturnType = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="56" endline="63">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="64" endline="71">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="207" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="130" endline="136">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="148" endline="154">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="208" nfragments="14" Csharpe_files="14" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4395" endline="4409">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   Implements the ternary conditional operator (?
 	/// </summary>
 	public class Conditional 
 		Expression expr, true_expr, false_expr;
 
 		public Conditional (Expression expr, Expression true_expr, Expression false_expr, Location loc)
 		{
 			this.expr = expr;
 			this.true_expr = true_expr;
 			this.false_expr = false_expr;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="47" endline="54">
<![CDATA[
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3159" endline="3173">
<![CDATA[
 		}
 
 		//
 		// The types allowed to be implicitly cast from
 		// on the governing type
 		//
 		static TypeSpec [] allowed_types;
 
 		public Switch (Expression e, ExplicitBlock block, List<SwitchSection> sects, Location l)
 		{
 			Expr = e;
 			this.block = block;
 			Sections = sects;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1729" endline="1739">
<![CDATA[
 		}
 
 		public MethodData (InterfaceMemberBase member,
 				   Modifiers modifiers, MethodAttributes flags, IMethodData method)
 		{
 			this.member = member;
 			this.modifiers = modifiers;
 			this.flags = flags;
 
 			this.method = method;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="42" endline="48">
<![CDATA[
 		internal TextSection(PEWriter peWriter, CliHeader cliHeader, ModuleBuilder moduleBuilder, int strongNameSignatureLength)
 		{
 			this.peWriter = peWriter;
 			this.cliHeader = cliHeader;
 			this.moduleBuilder = moduleBuilder;
 			this.strongNameSignatureLength = (uint)strongNameSignatureLength;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="38" endline="44">
<![CDATA[
 		public SourceFile (string name, string path, int index, bool is_include)
 		{
 			this.Index = index;
 			this.Name = name;
 			this.Path = path;
 			this.IsIncludeFile = is_include;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="99" endline="106">
<![CDATA[
 
 		public CompletionMemberAccess (Expression e, string partial_name, TypeArguments targs, Location l)
 		{
 			this.expr = e;
 			this.loc = l;
 			this.partial_name = partial_name;
 			this.targs = targs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="135" endline="145">
<![CDATA[
 
 		public If (Expression bool_expr,
 			   Statement true_statement,
 			   Statement false_statement,
 			   Location l)
 		{
 			this.expr = bool_expr;
 			TrueStatement = true_statement;
 			FalseStatement = false_statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2070" endline="2077">
<![CDATA[
 
 		public Binary (Operator oper, Expression left, Expression right, Location loc)
 		{
 			this.oper = oper;
 			this.left = left;
 			this.right = right;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2096" endline="2103">
<![CDATA[
 
 		private GenericTypeInstance(Type type, Type[] args, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			this.type = type;
 			this.args = args;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="194" endline="201">
<![CDATA[
 
 		public LineNumberEntry (int file, int row, int offset, bool is_hidden)
 		{
 			this.File = file;
 			this.Row = row;
 			this.Offset = offset;
 			this.IsHidden = is_hidden;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="233" endline="263">
<![CDATA[
 
 		public override string ToString ()
 		{
 			return String.Format ("[Line {0}
 		}
 	}
 
 	public class CodeBlockEntry
 	{
 		public int Index;
 		#region This is actually written to the symbol file
 		public int Parent;
 		public Type BlockType;
 		public int StartOffset;
 		public int EndOffset;
 		#endregion
 
 		public enum Type {
 			Lexical			= 1,
 			CompilerGenerated	= 2,
 			IteratorBody		= 3,
 			IteratorDispatcher	= 4
 		}
 
 		public CodeBlockEntry (int index, int parent, Type type, int start_offset)
 		{
 			this.Index = index;
 			this.Parent = parent;
 			this.BlockType = type;
 			this.StartOffset = start_offset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="321" endline="328">
<![CDATA[
 
 		public PredefinedType (ModuleContainer module, MemberKind kind, string ns, string name)
 		{
 			this.module = module;
 			this.kind = kind;
 			this.name = name;
 			this.ns = ns;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="907" endline="921">
<![CDATA[
 		}
 	}
 
 	//
 	// A collection of imported or resolved parameters
 	//
 	public class ParametersImported 
 	{
 		public ParametersImported (IParameterData [] parameters, TypeSpec [] types, bool hasArglist, bool hasParams)
 		{
 			this.parameters = parameters;
 			this.types = types;
 			this.has_arglist = hasArglist;
 			this.has_params = hasParams;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="209" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5162" endline="5169">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Using target = (Using) t;
 
 			target.decl = (VariableDeclaration) decl.Clone (clonectx);
 			target.stmt = stmt.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4620" endline="4627">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Fixed target = (Fixed) t;
 
 			target.decl = (VariableDeclaration) decl.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="210" nfragments="6" Csharpe_files="0" vb_files="6" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="47" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_List.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="125" endline="132">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="71" endline="78">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ConstraintList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="47" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         '#If DEBUG Then
         '        Dim m1, m2 As MethodInfo
         '        m1 = Me.GetType.GetMethod("ResolveTypeReferences")
         '        m2 = GetType(BlockStatement).GetMethod("ResolveTypeReferences")
         '        Helper.Assert(m1 IsNot m2)
         '#End If
 
         result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="64" endline="71">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Targets.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="211" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="189" endline="196">
<![CDATA[
 
 		public static void CloseCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.CloseCompilerGeneratedBlock (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="197" endline="204">
<![CDATA[
 
 		public static void StartIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorBody (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="181" endline="188">
<![CDATA[
 
 		public static void OpenCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.OpenCompilerGeneratedBlock (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="205" endline="212">
<![CDATA[
 
 		public static void EndIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorBody (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="213" endline="220">
<![CDATA[
 
 		public static void StartIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorDispatcher (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="221" endline="228">
<![CDATA[
 
 		public static void EndIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorDispatcher (offset);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="212" nfragments="10" Csharpe_files="0" vb_files="10" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="59" endline="66">
<![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="77" endline="84">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="188" endline="195">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="66" endline="88">
<![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         'Dim m_MethodAttributes As MethodAttributes
         'If m_HandlerType = KS.RaiseEvent Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Private
         'Else
         '    m_MethodAttributes = m_MethodAttributes Or Me.Modifiers.GetMethodAttributeScope
         'End If
         'm_MethodAttributes = m_MethodAttributes Or MethodAttributes.SpecialName
         'If DeclaringType.IsInterface Then
         '    m_MethodAttributes = m_MethodAttributes Or Reflection.MethodAttributes.Abstract Or Reflection.MethodAttributes.Virtual Or MethodAttributes.CheckAccessOnOverride Or MethodAttributes.NewSlot
         'End If
         'If Me.IsShared Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Static
         'End If
         'MyBase.Attributes = m_MethodAttributes
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="67" endline="74">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="281" endline="288">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="141" endline="149">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="409" endline="416">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="121" endline="128">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="213" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1080" endline="1086">
<![CDATA[
 
     Public Shared Function GetSetMethod(ByVal Prop As PropertyReference) As MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.SetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1073" endline="1079">
<![CDATA[
 
     Public Shared Function GetGetMethod(ByVal Prop As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.GetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="214" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="624" endline="630">
<![CDATA[
     End Property
 
     ReadOnly Property ResolvedMember() As Mono.Cecil.MemberReference
         Get
             If m_ResolvedCandidate Is Nothing Then Return Nothing
             Return m_ResolvedCandidate.Member
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="295" endline="301">
<![CDATA[
     End Property
 
     Public ReadOnly Property FieldType() As Mono.Cecil.TypeReference Implements IFieldMember.FieldType
         Get
             If m_FieldBuilderCecil Is Nothing Then Return Nothing
             Return m_FieldBuilderCecil.FieldType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="114" endline="120">
<![CDATA[
     End Property
 
     Property ConstantValue() As Object
         Get
             If m_ParameterBuilderCecil Is Nothing Then Return Nothing
             Return m_ParameterBuilderCecil.Constant
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="166" endline="172">
<![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             If m_ParameterIdentifier Is Nothing Then Return Nothing
             Return m_ParameterIdentifier.Name
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="215" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="72" endline="79">
<![CDATA[
 
 		public void DefineLocalVariable (int index, string name)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.AddLocal (index, name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="103" endline="110">
<![CDATA[
 
 		public void DefineScopeVariable (int scope, int index)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.AddScopeVariable (scope, index);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="216" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="801" endline="808">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Return target = (Return) t;
 			// It's null for simple return;
 			if (Expr != null)
 				target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1084" endline="1091">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Throw target = (Throw) t;
 
 			if (expr != null)
 				target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9303" endline="9309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CollectionElementInitializer target = (CollectionElementInitializer) t;
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8547" endline="8554">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			IndexerExpr target = (IndexerExpr) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7074" endline="7081">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Arglist target = (Arglist) t;
 
 			if (Arguments != null)
 				target.Arguments = Arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="217" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6915" endline="6924">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (this));
 			
 			// Use typeless constant for ldarg.0 to save some
 			// space and avoid problems with anonymous stories
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="203" endline="209">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="218" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="211" endline="218">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = VerifyConstraints() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="170" endline="177">
<![CDATA[
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="219" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="169" endline="176">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Property] As Mono.Cecil.PropertyReference, ByVal InstanceExpression As Expression, ByVal Parameters As ArgumentList)
         MyBase.New(Classifications.PropertyAccess, Parent)
         m_Property = [Property]
         m_InstanceExpression = InstanceExpression
         m_Parameters = Parameters
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="84" endline="98">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="InstanceExpression">May be Nothing</param>
     ''' <param name="TypeArguments">May be Nothing</param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Name As String)
         MyBase.New(Classifications.LateBoundAccess, Parent)
         m_InstanceExpression = InstanceExpression
         m_Name = Name
         m_TypeArguments = TypeArguments
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="220" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="489" endline="495">
<![CDATA[
 
 		public CapturedScope[] CapturedScopes {
 			get {
 				CapturedScope[] retval = new CapturedScope [captured_scopes.Count];
 				captured_scopes.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="476" endline="482">
<![CDATA[
 
 		public CapturedVariable[] CapturedVariables {
 			get {
 				CapturedVariable[] retval = new CapturedVariable [captured_vars.Count];
 				captured_vars.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="221" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="124" endline="135">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="136" endline="147">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="118" endline="129">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="106" endline="117">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="222" nfragments="7" Csharpe_files="7" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1199" endline="1206">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			NullCoalescingOperator target = (NullCoalescingOperator) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="402" endline="409">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Assign _target = (Assign) t;
 
 			_target.target = target.Clone (clonectx);
 			_target.source = source.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1606" endline="1613">
<![CDATA[
 		
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Cast target = (Cast) t;
 
 			target.target_type = target_type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1278" endline="1287">
<![CDATA[
 
 		protected abstract string OperatorName { get; }
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Probe target = (Probe) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.ProbeType = ProbeType.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="443" endline="450">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			While target = (While) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.Statement = Statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="329" endline="336">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Do target = (Do) t;
 
 			target.EmbeddedStatement = EmbeddedStatement.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3862" endline="3869">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Binary target = (Binary) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="223" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="80" endline="88">
<![CDATA[
     End Property
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="42" endline="51">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         ' result = Helper.ResolveTypeReferences(m_UsingResources) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="53" endline="60">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="532" endline="540">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         'Define type parameters
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="224" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="35" endline="41">
<![CDATA[
     End Property
 
     ReadOnly Property Code() As System.Text.StringBuilder
         Get
             If m_Code Is Nothing Then m_Code = New System.Text.StringBuilder()
             Return m_Code
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="42" endline="48">
<![CDATA[
     End Property
 
     ReadOnly Property ProjectCode() As System.Text.StringBuilder
         Get
             If m_ProjectCode Is Nothing Then m_ProjectCode = New System.Text.StringBuilder
             Return m_ProjectCode
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="225" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="175" endline="184">
<![CDATA[
 		}
 
 		#endregion
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var ps = (PropertySpec) base.InflateMember (inflator);
 			ps.memberType = inflator.Inflate (memberType);
 			return ps;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="315" endline="321">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var fs = (FieldSpec) base.InflateMember (inflator);
 			fs.memberType = inflator.Inflate (memberType);
 			return fs;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="226" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="366" endline="372">
<![CDATA[
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			bw.Write (Name);
 			bw.Write (CapturedName);
 			bw.Write ((byte) Kind);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="322" endline="328">
<![CDATA[
 
 		internal void Write (MonoSymbolFile file, MyBinaryWriter bw)
 		{
 			bw.WriteLeb128 (Index);
 			bw.Write (Name);
 			bw.WriteLeb128 (BlockIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="127" endline="133">
<![CDATA[
 
 		internal void WriteParamRecord(MetadataWriter mw)
 		{
 			mw.Write(flags);
 			mw.Write(sequence);
 			mw.WriteStringIndex(nameIndex);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="227" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="173" endline="180">
<![CDATA[
 
 		public void CloseScope (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="190" endline="197">
<![CDATA[
 
 		public void CloseCompilerGeneratedBlock (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="228" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="451" endline="458">
<![CDATA[
 
 		public void SetMetaInfo (MethodInfo info)
 		{
 			if (this.metaInfo != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.metaInfo = info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="435" endline="442">
<![CDATA[
 
 		public void SetMetaInfo (MetaType info)
 		{
 			if (this.info != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.info = info;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="229" nfragments="13" Csharpe_files="0" vb_files="13" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="158" endline="164">
<![CDATA[
 
     Shared Function CreateSymbolToken(ByVal Location As Span, ByVal Symbol As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Symbol
         result.m_TokenObject = Symbol
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="102" endline="108">
<![CDATA[
 
     Shared Function CreateDoubleToken(ByVal Location As Span, ByVal Value As Double) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DoubleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="109" endline="115">
<![CDATA[
 
     Shared Function CreateInt16Token(ByVal Location As Span, ByVal Value As Short) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="144" endline="150">
<![CDATA[
 
     Shared Function CreateUInt64Token(ByVal Location As Span, ByVal Value As ULong) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="116" endline="122">
<![CDATA[
 
     Shared Function CreateInt32Token(ByVal Location As Span, ByVal Value As Integer) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="67" endline="73">
<![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="123" endline="129">
<![CDATA[
 
     Shared Function CreateInt64Token(ByVal Location As Span, ByVal Value As Long) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="81" endline="87">
<![CDATA[
 
     Shared Function CreateCharToken(ByVal Location As Span, ByVal Value As Char) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.CharLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="95" endline="101">
<![CDATA[
 
     Shared Function CreateSingleToken(ByVal Location As Span, ByVal Value As Single) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.SingleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="137" endline="143">
<![CDATA[
 
     Shared Function CreateUInt32Token(ByVal Location As Span, ByVal Value As UInteger) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="130" endline="136">
<![CDATA[
 
     Shared Function CreateUInt16Token(ByVal Location As Span, ByVal Value As UShort) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="88" endline="94">
<![CDATA[
 
     Shared Function CreateDecimalToken(ByVal Location As Span, ByVal Value As Decimal) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DecimalLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="230" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="747" endline="756">
<![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="231" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="885" endline="893">
<![CDATA[
 
 
     Shared Sub EmitConstrained(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Dim OriginalType As Mono.Cecil.TypeReference = Type
 
         Type = Helper.GetTypeOrTypeBuilder(Info.Compiler, Type)
 
         Info.ILGen.Emit(OpCodes.Constrained, Type)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1901" endline="1911">
<![CDATA[
 
     ''' <summary>
     ''' Emits a box instruction, no checks are done.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitBox(ByVal Info As EmitInfo, ByVal SourceType As Mono.Cecil.TypeReference)
         Dim OriginalDestinationType As Mono.Cecil.TypeReference = SourceType
         SourceType = Helper.GetTypeOrTypeBuilder(Info.Compiler, SourceType)
         Info.ILGen.Emit(OpCodes.Box, SourceType)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="232" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="556" endline="563">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = break_origins;
 			break_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="580" endline="587">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = continue_origins;
 			continue_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="233" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5759" endline="5768">
<![CDATA[
 		}
 
 		LocalVariable li;
 
 		public TemporaryVariableReference (LocalVariable li, Location loc)
 		{
 			this.li = li;
 			this.type = li.Type;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1387" endline="1405">
<![CDATA[
 	}
 
 	public class ImportedAssemblyDefinition 
 	{
 		readonly Assembly assembly;
 		readonly AssemblyName aname;
 		readonly MetadataImporter importer;
 		bool cls_compliant;
 		bool contains_extension_methods;
 
 		List<AssemblyName> internals_visible_to;
 		Dictionary<IAssemblyDefinition, AssemblyName> internals_visible_to_cache;
 
 		public ImportedAssemblyDefinition (Assembly assembly, MetadataImporter importer)
 		{
 			this.assembly = assembly;
 			this.aname = assembly.GetName ();
 			this.importer = importer;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="234" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="60" endline="67">
<![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal InExpression As Expression, ByVal NextExpression As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_InExpression = InExpression
         m_NextExpression = NextExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="66" endline="73">
<![CDATA[
 
     Shadows Sub Init(ByVal PreCondition As Expression, ByVal PostCondition As Expression, ByVal IsWhile As Boolean, ByVal Code As CodeBlock)
         MyBase.Init(Code)
 
         m_PreCondition = PreCondition
         m_PostCondition = PostCondition
         m_IsWhile = IsWhile
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="58" endline="65">
<![CDATA[
 
     Shadows Sub Init(ByVal Variable As Identifier, ByVal TypeName As NonArrayTypeName, ByVal [When] As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_Variable = Variable
         m_TypeName = TypeName
         m_When = [When]
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="235" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="756" endline="762">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddBreakOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="763" endline="769">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddContinueOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="770" endline="776">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement exit_stmt)
 		{
 			Parent.AddReturnOrigin (vector, exit_stmt);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="236" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="42" endline="48">
<![CDATA[
 
     Shared Function CreateIdentifierToken(ByVal Location As Span, ByVal Identifier As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Identifier
         result.m_TokenObject = Identifier
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="151" endline="157">
<![CDATA[
 
     Shared Function CreateStringLiteral(ByVal Location As Span, ByVal Value As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.StringLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="237" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="210" endline="218">
<![CDATA[
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (this.IsGenericMethodDefinition)
 			{
 				return this;
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="270" endline="279">
<![CDATA[
 		}
 
 		public override Type GetGenericTypeDefinition()
 		{
 			if (IsGenericTypeDefinition)
 			{
 				return this;
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="238" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4250" endline="4260">
<![CDATA[
 	}
 
 	public class Unchecked 
 		public Block Block;
 		
 		public Unchecked (Block b, Location loc)
 		{
 			Block = b;
 			b.Unchecked = true;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4280" endline="4290">
<![CDATA[
 	}
 
 	public class Checked 
 		public Block Block;
 		
 		public Checked (Block b, Location loc)
 		{
 			Block = b;
 			b.Unchecked = false;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="239" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="148" endline="154">
<![CDATA[
 
 		public CompileUnitEntry DefineCompilationUnit (SourceFileEntry source)
 		{
 			CompileUnitEntry entry = new CompileUnitEntry (file, source);
 			comp_units.Add (entry);
 			return entry;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="134" endline="140">
<![CDATA[
 
 		public SourceFileEntry DefineDocument (string url)
 		{
 			SourceFileEntry entry = new SourceFileEntry (file, url);
 			sources.Add (entry);
 			return entry;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="240" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="61" endline="72">
<![CDATA[
 
     ''' <summary>
     ''' Returns nothing if it is not a handles clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property HandlesClause() As HandlesClause
         Get
             Helper.Assert(m_Clause IsNot Nothing)
             Return TryCast(m_Clause, HandlesClause)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="73" endline="85">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if it is not an implements clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ImplementsClause() As MemberImplementsClause
         Get
             helper.Assert(m_clause IsNot Nothing)
             Return TryCast(m_Clause, MemberImplementsClause)
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="241" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="867" endline="877">
<![CDATA[
 		}
 
 		SavedOrigin saved_origins;
 
 		public FlowBranchingException (FlowBranching parent,
 					       ExceptionStatement stmt)
 			
 				null, stmt.loc)
 		{
 			this.stmt = stmt;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="728" endline="737">
<![CDATA[
 	}
 
 	public class FlowBranchingTryCatch 
 	{
 		TryCatch stmt;
 		public FlowBranchingTryCatch (FlowBranching parent, TryCatch stmt)
 			
 		{
 			this.stmt = stmt;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="242" nfragments="25" Csharpe_files="25" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1445" endline="1486">
<![CDATA[
 	}
 
 	//
 	// The information about a user-perceived local variable
 	//
 	public class LocalVariable 
 	{
 		[Flags]
 		public enum Flags
 		{
 			Used = 1,
 			IsThis = 1 << 1,
 			AddressTaken = 1 << 2,
 			CompilerGenerated = 1 << 3,
 			Constant = 1 << 4,
 			ForeachVariable = 1 << 5,
 			FixedVariable = 1 << 6,
 			UsingVariable = 1 << 7,
 //			DefinitelyAssigned = 1 << 8,
 			IsLocked = 1 << 9,
 
 			ReadonlyMask = ForeachVariable | FixedVariable | UsingVariable
 		}
 
 		TypeSpec type;
 		readonly string name;
 		readonly Location loc;
 		readonly Block block;
 		Flags flags;
 		Constant const_value;
 
 		public VariableInfo VariableInfo;
 		HoistedVariable hoisted_variant;
 
 		LocalBuilder builder;
 
 		public LocalVariable (Block block, string name, Location loc)
 		{
 			this.block = block;
 			this.name = name;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8032" endline="8049">
<![CDATA[
 	}
 
 	/// <summary>
 	///   An Element Access expression.
 	///
 	///   During semantic analysis these are transformed into 
 	///   IndexerAccess, ArrayAccess or a PointerArithmetic.
 	/// </summary>
 	public class ElementAccess 
 		public Arguments Arguments;
 		public Expression Expr;
 
 		public ElementAccess (Expression e, Arguments args, Location loc)
 		{
 			Expr = e;
 			this.loc = loc;
 			this.Arguments = args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="73" endline="89">
<![CDATA[
 	}
 
 	public sealed class LocalBuilder
 	{
 		private readonly Type localType;
 		private readonly int index;
 		private readonly bool pinned;
 		internal string name;
 		internal int startOffset;
 		internal int endOffset;
 
 		internal LocalBuilder(Type localType, int index, bool pinned)
 		{
 			this.localType = localType;
 			this.index = index;
 			this.pinned = pinned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4853" endline="5519">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
 
 		#region Properties
 
 		public override bool IsLockedByStatement {
 			get {
 				return pi.IsLocked;
 			}
 			set	{
 				pi.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return (pi.Parameter.ModFlags & Parameter.Modifier.ISBYREF) != 0; }
 		}
 
 		bool HasOutModifier {
 			get { return pi.Parameter.ModFlags == Parameter.Modifier.OUT; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return pi.Parameter.HoistedVariant;
 		}
 
 		//
 		// A ref or out parameter is classified as a moveable variable, even 
 		// if the argument given for the parameter is a fixed variable
 		//		
 		public override bool IsFixed {
 			get { return !IsRef; }
 		}
 
 		public override string Name {
 			get { return Parameter.Name; }
 		}
 
 		public Parameter Parameter {
 			get { return pi.Parameter; }
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return pi.VariableInfo; }
 		}
 
 		protected override ILocalVariable Variable {
 			get { return Parameter; }
 		}
 
 		#endregion
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			// HACK
 			if (ec.IsInProbingMode)
 				return true;
 			
 			if (!ec.DoFlowAnalysis || !HasOutModifier || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			ec.Report.Error (269, loc, "Use of unassigned out parameter `{0}'", Name);
 			return false;
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			Parameter.HasAddressTaken = true;
 		}
 
 		void SetAssigned (ResolveContext ec)
 		{
 			if (HasOutModifier && ec.DoFlowAnalysis)
 				ec.CurrentBranching.SetAssigned (VariableInfo);
 		}
 
 		bool DoResolveBase (ResolveContext ec)
 		{
 			type = pi.ParameterType;
 			eclass = ExprClass.Variable;
 
 			//
 			// If we are referencing a parameter from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (pi)) {
 				if (Parameter.HasAddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (IsRef) {
 					ec.Report.Error (1628, loc,
 						"Parameter `{0}' cannot be used inside `{1}' when using `ref' or `out' modifier",
 						Name, ec.CurrentAnonymousMethod.ContainerType);
 				}
 
 				if (ec.IsVariableCapturingRequired && !pi.Block.ParametersBlock.IsExpressionTree) {
 					AnonymousMethodStorey storey = pi.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureParameter (ec, this);
 				}
 			}
 
 			return true;
 		}
 
 		public override int GetHashCode ()
 		{
 			return Name.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			ParameterReference pr = obj as ParameterReference;
 			if (pr == null)
 				return false;
 
 			return Name == pr.Name;
 		}
 
 		public override void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			//
 			// ParameterReferences might already be a reference
 			//
 			if (IsRef) {
 				EmitLoad (ec);
 				return;
 			}
 
 			base.AddressOf (ec, mode);
 		}
 		
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			// Nothing to clone
 			return;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			return Parameter.ExpressionTreeVariableReference ();
 		}
 
 		//
 		// Notice that for ref/out parameters, the type exposed is not the
 		// same type exposed externally.
 		//
 		// for "ref int a"
 		//   externally we expose "int&"
 		//   here we expose       "int".
 		//
 		// We record this in "is_ref".  This means that the type system can treat
 		// the type as it is expected, but when we generate the code, we generate
 		// the alternate kind of code.
 		//
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			// HACK
 			if (ec.IsInProbingMode)
 				return this;
 
 			if (HasOutModifier && ec.DoFlowAnalysis &&
 			    (!ec.OmitStructFlowAnalysis || !VariableInfo.TypeInfo.IsStruct) && !IsAssigned (ec, loc))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			SetAssigned (ec);
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		static public void EmitLdArg (EmitContext ec, int x)
 		{
 			switch (x) {
 			case 0
 			case 1
 			case 2
 			case 3
 			default
 				if (x > byte.MaxValue)
 					ec.Emit (OpCodes.Ldarg, x);
 				else
 					ec.Emit (OpCodes.Ldarg_S, (byte) x);
 				break;
 			}
 		}
 	}
 	
 	/// <summary>
 	///   Invocation of methods or delegates.
 	/// </summary>
 	public class Invocation 
 	{
 		protected Arguments arguments;
 		protected Expression expr;
 		protected MethodGroupExpr mg;
 		
 		public Invocation (Expression expr, Arguments arguments)
 		{
 			this.expr = expr;		
 			this.arguments = arguments;
 			if (expr != null)
 				loc = expr.Location;
 		}
 
 		#region Properties
 		public Arguments Arguments {
 			get {
 				return arguments;
 			}
 		}
 		
 		public Expression Expression {
 			get {
 				return expr;
 			}
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
 
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance = mg.IsInstance ?
 				mg.InstanceExpression.CreateExpressionTree (ec) 
 				new NullLiteral (loc);
 
 			var args = Arguments.CreateForExpressionTree (ec, arguments,
 				instance,
 				mg.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression member_expr;
 			var atn = expr as ATypeNameExpression;
 			if (atn != null) {
 				member_expr = atn.LookupNameExpression (ec, MemberLookupRestrictions.InvocableOnly | MemberLookupRestrictions.ReadAccess);
 				if (member_expr != null)
 					member_expr = member_expr.Resolve (ec);
 			} else {
 				member_expr = expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			}
 
 			if (member_expr == null)
 				return null;
 
 			//
 			// Next, evaluate all the expressions in the argument list
 			//
 			bool dynamic_arg = false;
 			if (arguments != null)
 				arguments.Resolve (ec, out dynamic_arg);
 
 			TypeSpec expr_type = member_expr.Type;
 			if (expr_type == InternalType.Dynamic)
 				return DoResolveDynamic (ec, member_expr);
 
 			mg = member_expr as MethodGroupExpr;
 			Expression invoke = null;
 
 			if (mg == null) {
 				if (expr_type != null && TypeManager.IsDelegateType (expr_type)) {
 					invoke = new DelegateInvocation (member_expr, arguments, loc);
 					invoke = invoke.Resolve (ec);
 					if (invoke == null || !dynamic_arg)
 						return invoke;
 				} else {
 					if (member_expr is RuntimeValueExpression) {
 						ec.Report.Error (Report.RuntimeErrorId, loc, "Cannot invoke a non-delegate type `{0}'",
 							member_expr.Type.GetSignatureForError ()); ;
 						return null;
 					}
 
 					MemberExpr me = member_expr as MemberExpr;
 					if (me == null) {
 						member_expr.Error_UnexpectedKind (ec, ResolveFlags.MethodGroup, loc);
 						return null;
 					}
 
 					ec.Report.Error (1955, loc, "The member `{0}' cannot be used as method or delegate",
 							member_expr.GetSignatureForError ());
 					return null;
 				}
 			}
 
 			if (invoke == null) {
 				mg = DoResolveOverload (ec);
 				if (mg == null)
 					return null;
 			}
 
 			if (dynamic_arg)
 				return DoResolveDynamic (ec, member_expr);
 
 			var method = mg.BestCandidate;
 			type = mg.BestCandidateReturnType;
 		
 			if (arguments == null && method.DeclaringType == TypeManager.object_type && method.Name == Destructor.MetadataName) {
 				if (mg.IsBase)
 					ec.Report.Error (250, loc, "Do not directly call your base class Finalize method. It is called automatically from your destructor");
 				else
 					ec.Report.Error (245, loc, "Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available");
 				return null;
 			}
 
 			IsSpecialMethodInvocation (ec, method, loc);
 			
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		protected virtual Expression DoResolveDynamic (ResolveContext ec, Expression memberExpr)
 		{
 			Arguments args;
 			DynamicMemberBinder dmb = memberExpr as DynamicMemberBinder;
 			if (dmb != null) {
 				args = dmb.Arguments;
 				if (arguments != null)
 					args.AddRange (arguments);
 			} else if (mg == null) {
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				args.Insert (0, new Argument (memberExpr));
 				this.expr = null;
 			} else {
 				if (mg.IsBase) {
 					ec.Report.Error (1971, loc,
 						"The base call to method `{0}' cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access",
 						mg.Name);
 					return null;
 				}
 
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				MemberAccess ma = expr as MemberAccess;
 				if (ma != null) {
 					var left_type = ma.LeftExpression as TypeExpr;
 					if (left_type != null) {
 						args.Insert (0, new Argument (new TypeOf (left_type, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						//
 						// Any value type has to be pass as by-ref to get back the same
 						// instance on which the member was called
 						//
 						var mod = TypeManager.IsValueType (ma.LeftExpression.Type) ? Argument.AType.Ref 
 						args.Insert (0, new Argument (ma.LeftExpression.Resolve (ec), mod));
 					}
 				} else {	// is SimpleName
 					if (ec.IsStatic) {
 						args.Insert (0, new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						args.Insert (0, new Argument (new This (loc).Resolve (ec)));
 					}
 				}
 			}
 
 			return new DynamicInvocation (expr as ATypeNameExpression, args, loc).Resolve (ec);
 		}
 
 		protected virtual MethodGroupExpr DoResolveOverload (ResolveContext ec)
 		{
 			return mg.OverloadResolve (ec, ref arguments, null, OverloadResolver.Restrictions.None);
 		}
 
 		static MetaType[] GetVarargsTypes (MethodSpec mb, Arguments arguments)
 		{
 			AParametersCollection pd = mb.Parameters;
 
 			Argument a = arguments[pd.Count - 1];
 			Arglist list = (Arglist) a.Expr;
 
 			return list.ArgumentTypes;
 		}
 
 		//
 		// If a member is a method or event, or if it is a constant, field or property of either a delegate type
 		// or the type dynamic, then the member is invocable
 		//
 		public static bool IsMemberInvocable (MemberSpec member)
 		{
 			switch (member.Kind) {
 			case MemberKind.Event
 				return true;
 			case MemberKind.Field
 			case MemberKind.Property
 				var m = member as IInterfaceMemberSpec;
 				return m.MemberType.IsDelegate || m.MemberType == InternalType.Dynamic;
 			default
 				return false;
 			}
 		}
 
 		public static bool IsSpecialMethodInvocation (ResolveContext ec, MethodSpec method, Location loc)
 		{
 			if (!method.IsReservedMethod)
 				return false;
 
 			if (ec.HasSet (ResolveContext.Options.InvokeSpecialName) || ec.CurrentMemberDefinition.IsCompilerGenerated)
 				return false;
 
 			ec.Report.SymbolRelatedToPreviousError (method);
 			ec.Report.Error (571, loc, "`{0}'
 				method.GetSignatureForError ());
 	
 			return true;
 		}
 
 		//
 		// Used to decide whether call or callvirt is needed
 		//
 		static bool IsVirtualCallRequired (Expression instance, MethodSpec method)
 		{
 			//
 			// There are 2 scenarious where we emit callvirt
 			//
 			// Case 1
 			// Case 2
 			// correct NRE exception when the method is called
 			//
 			var decl_type = method.DeclaringType;
 			if (decl_type.IsStruct || decl_type.IsEnum)
 				return false;
 
 			if (instance is BaseThis)
 				return false;
 
 			//
 			// It's non-virtual and will never be null
 			//
 			if (!method.IsVirtual && (instance is This || instance is New || instance is ArrayCreation || instance is DelegateCreation))
 				return false;
 
 			return true;
 		}
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
 		
 		// `dup_args' leaves an extra copy of the arguments on the stack
 		// `omit_args' does not leave any arguments at all.
 		// So, basically, you could make one call with `dup_args' set to true,
 		// and then another with `omit_args' set to true, and the two calls
 		// would have the same set of arguments. However, each argument would
 		// only have been evaluated once.
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc,
 		                             bool dup_args, bool omit_args)
 		{
 			LocalTemporary this_arg = null;
 
 			// Speed up the check by not doing it on not allowed targets
 			if (method.ReturnType == TypeManager.void_type && method.IsConditionallyExcluded (loc))
 				return;
 
 			OpCode call_op;
 			TypeSpec iexpr_type;
 
 			if (method.IsStatic) {
 				iexpr_type = null;
 				call_op = OpCodes.Call;
 			} else {
 				iexpr_type = instance_expr.Type;
 
 				if (IsVirtualCallRequired (instance_expr, method)) {
 					call_op = OpCodes.Callvirt;
 				} else {
 					call_op = OpCodes.Call;
 				}
 
 				//
 				// If this is ourselves, push "this"
 				//
 				if (!omit_args) {
 					TypeSpec t = iexpr_type;
 
 					//
 					// Push the instance expression
 					//
 					if ((iexpr_type.IsStruct && (call_op == OpCodes.Callvirt || (call_op == OpCodes.Call && method.DeclaringType == iexpr_type))) ||
 						iexpr_type.IsGenericParameter || TypeManager.IsNullableType (method.DeclaringType)) {
 						//
 						// If the expression implements IMemoryLocation, then
 						// we can optimize and use AddressOf on the
 						// return.
 						//
 						// If not we have to use some temporary storage for
 						// it.
 						var iml = instance_expr as IMemoryLocation;
 						if (iml != null) {
 							iml.AddressOf (ec, AddressOp.LoadStore);
 						} else {
 							LocalTemporary temp = new LocalTemporary (iexpr_type);
 							instance_expr.Emit (ec);
 							temp.Store (ec);
 							temp.AddressOf (ec, AddressOp.Load);
 						}
 
 						// avoid the overhead of doing this all the time.
 						if (dup_args)
 							t = ReferenceContainer.MakeType (iexpr_type);
 					} else if (iexpr_type.IsEnum || iexpr_type.IsStruct) {
 						instance_expr.Emit (ec);
 						ec.Emit (OpCodes.Box, iexpr_type);
 						t = iexpr_type = TypeManager.object_type;
 					} else {
 						instance_expr.Emit (ec);
 					}
 
 					if (dup_args) {
 						ec.Emit (OpCodes.Dup);
 						if (Arguments != null && Arguments.Count != 0) {
 							this_arg = new LocalTemporary (t);
 							this_arg.Store (ec);
 						}
 					}
 				}
 			}
 
 			if (!omit_args && Arguments != null) {
 				var dup_arg_exprs = Arguments.Emit (ec, dup_args);
 				if (dup_args) {
 					this_arg.Emit (ec);
 					LocalTemporary lt;
 					foreach (var dup in dup_arg_exprs) {
 						dup.Emit (ec);
 						lt = dup as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 			}
 
 			if (call_op == OpCodes.Callvirt && (iexpr_type.IsGenericParameter || iexpr_type.IsStruct)) {
 				ec.Emit (OpCodes.Constrained, iexpr_type);
 			}
 
 			if (method.Parameters.HasArglist) {
 				var varargs_types = GetVarargsTypes (method, Arguments);
 				ec.Emit (call_op, method, varargs_types);
 				return;
 			}
 
 			//
 			// If you have
 			// this.DoFoo ();
 			// and DoFoo is not virtual, you can omit the callvirt,
 			// because you don't need the null checking behavior.
 			//
 			ec.Emit (call_op, method);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			mg.EmitCall (ec, arguments);
 		}
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return MakeExpression (ctx, mg.InstanceExpression, mg.BestCandidate, arguments);
 		}
 
 		public static SLE.Expression MakeExpression (BuilderContext ctx, Expression instance, MethodSpec mi, Arguments args)
 		{
 #if STATIC
 			throw new NotSupportedException ();
 #else
 			var instance_expr = instance == null ? null 
 			return SLE.Expression.Call (instance_expr, (MethodInfo) mi.GetMetaInfo (), Arguments.MakeExpression (args, ctx));
 #endif
 		}
 	}
 
 	//
 	// Implements simple new expression 
 	//
 	public class New 
 	{
 		protected Arguments arguments;
 
 		//
 		// During bootstrap, it contains the RequestedType,
 		// but if `type' is not null, it *might* contain a NewDelegate
 		// (because of field multi-initialization)
 		//
 		protected Expression RequestedType;
 
 		protected MethodSpec method;
 
 		public New (Expression requested_type, Arguments arguments, Location l)
 		{
 			RequestedType = requested_type;
 			this.arguments = arguments;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="968" endline="998">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Mode 
 			IsIncrement    = 0,
 			IsDecrement    = 1,
 			IsPre          = 0,
 			IsPost         = 2,
 			
 			PreIncrement   = 0,
 			PreDecrement   = IsDecrement,
 			PostIncrement  = IsPost,
 			PostDecrement  = IsPost | IsDecrement
 		}
 
 		Mode mode;
 		bool is_expr, recurse;
 
 		Expression expr;
 
 		// Holds the real operation
 		Expression operation;
 
 		static TypeSpec[] predefined;
 
 		public UnaryMutator (Mode m, Expression e, Location loc)
 		{
 			mode = m;
 			this.loc = loc;
 			expr = e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4549" endline="4561">
<![CDATA[
 		}
 
 
 		VariableDeclaration decl;
 		Statement statement;
 		bool has_ret;
 
 		public Fixed (VariableDeclaration decl, Statement stmt, Location l)
 		{
 			this.decl = decl;
 			statement = stmt;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9058" endline="9073">
<![CDATA[
 	}
 
 	//
 	// Implements the `stackalloc' keyword
 	//
 	public class StackAlloc 
 		TypeSpec otype;
 		Expression t;
 		Expression count;
 		
 		public StackAlloc (Expression type, Expression count, Location l)
 		{
 			t = type;
 			this.count = count;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="61" endline="80">
<![CDATA[
 		}
 	}
 
 	//
 	// A set of parsed constraints for a type parameter
 	//
 	public class Constraints
 	{
 		SimpleMemberName tparam;
 		List<FullNamedExpression> constraints;
 		Location loc;
 		bool resolved;
 		bool resolving;
 		
 		public Constraints (SimpleMemberName tparam, List<FullNamedExpression> constraints, Location loc)
 		{
 			this.tparam = tparam;
 			this.constraints = constraints;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="851" endline="867">
<![CDATA[
 	}
 
 	public class LabeledStatement 
 		string name;
 		bool defined;
 		bool referenced;
 		Label label;
 		Block block;
 
 		FlowBranching.UsageVector vectors;
 		
 		public LabeledStatement (string name, Block block, Location l)
 		{
 			this.name = name;
 			this.block = block;
 			this.loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1814" endline="1836">
<![CDATA[
 		}
 	}
 
 	//
 	// A type expression of generic type with type arguments
 	//
 	class GenericTypeExpr 
 	{
 		TypeArguments args;
 		TypeSpec open_type;
 		bool constraints_checked;
 
 		/// <summary>
 		///   Instantiate the generic type `t' with the type arguments `args'.
 		///   Use this constructor if you already know the fully resolved
 		///   generic type.
 		/// </summary>		
 		public GenericTypeExpr (TypeSpec open_type, TypeArguments args, Location l)
 		{
 			this.open_type = open_type;
 			loc = l;
 			this.args = args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="358" endline="371">
<![CDATA[
 	}
 
 	sealed class ParameterInfoImpl 
 	{
 		private readonly MethodDefImpl method;
 		private readonly int position;
 		private readonly int index;
 
 		internal ParameterInfoImpl(MethodDefImpl method, int position, int index)
 		{
 			this.method = method;
 			this.position = position;
 			this.index = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1221" endline="1241">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Base class for the `Is' and `As' classes. 
 	/// </summary>
 	///
 	/// <remarks>
 	///   FIXME
 	///   size. 
 	/// </remarks>
 	public abstract class Probe 
 		public Expression ProbeType;
 		protected Expression expr;
 		protected TypeExpr probe_type_expr;
 		
 		public Probe (Expression expr, Expression probe_type, Location l)
 		{
 			ProbeType = probe_type;
 			loc = l;
 			this.expr = expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="922" endline="928">
<![CDATA[
 
 		public ParametersImported (IParameterData[] param, TypeSpec[] types, bool hasParams)
 		{
 			this.parameters = param;
 			this.types = types;
 			this.has_params = hasParams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="256" endline="267">
<![CDATA[
 	}
 
 	public class Do 
 		public Expression expr;
 		public Statement  EmbeddedStatement;
 
 		public Do (Statement statement, BooleanExpression bool_expr, Location l)
 		{
 			expr = bool_expr;
 			EmbeddedStatement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1296" endline="1309">
<![CDATA[
 		}
 
 		protected ParametersBlock block;
 
 		public TypeSpec ReturnType;
 
 		object return_label;
 
 		protected AnonymousExpression (ParametersBlock block, TypeSpec return_type, Location loc)
 		{
 			this.ReturnType = return_type;
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="337" endline="349">
<![CDATA[
 	}
 
 	public class While 
 		public Expression expr;
 		public Statement Statement;
 		bool infinite, empty;
 
 		public While (BooleanExpression bool_expr, Statement statement, Location l)
 		{
 			this.expr = bool_expr;
 			Statement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="240" endline="256">
<![CDATA[
 		}
 
 		readonly Arguments arguments;
 		protected IDynamicBinder binder;
 		protected Expression binder_expr;
 
 		// Used by BinderFlags
 		protected CSharpBinderFlags flags;
 
 		TypeSpec binder_type;
 
 		public DynamicExpressionStatement (IDynamicBinder binder, Arguments args, Location loc)
 		{
 			this.binder = binder;
 			this.arguments = args;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2076" endline="2082">
<![CDATA[
 
 		protected ATypeNameExpression (string name, TypeArguments targs, Location l)
 		{
 			this.name = name;
 			this.targs = targs;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="692" endline="708">
<![CDATA[
 	}
 
 	//
 	// Invocation converted to delegate Invoke call
 	//
 	class DelegateInvocation 
 	{
 		readonly Expression InstanceExpr;
 		Arguments arguments;
 		MethodSpec method;
 		
 		public DelegateInvocation (Expression instance_expr, Arguments args, Location loc)
 		{
 			this.InstanceExpr = instance_expr;
 			this.arguments = args;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="633" endline="650">
<![CDATA[
 	}
 	
 	//
 	// A delegate-creation-expression, invoked from the `New' class 
 	//
 	public class NewDelegate 
 	{
 		public Arguments Arguments;
 
 		//
 		// This constructor is invoked from the `New' expression
 		//
 		public NewDelegate (TypeSpec type, Arguments Arguments, Location loc)
 		{
 			this.type = type;
 			this.Arguments = Arguments;
 			this.loc  = loc; 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="611" endline="625">
<![CDATA[
 
 		#endregion
 	}
 
 	//
 	// Created from the conversion code
 	//
 	public class ImplicitDelegateCreation 
 	{
 		ImplicitDelegateCreation (TypeSpec t, MethodGroupExpr mg, Location l)
 		{
 			type = t;
 			this.method_group = mg;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1019" endline="1031">
<![CDATA[
 	}
 
 	public class NullCoalescingOperator 
 	{
 		Expression left, right;
 		Unwrap unwrap;
 
 		public NullCoalescingOperator (Expression left, Expression right, Location loc)
 		{
 			this.left = left;
 			this.right = right;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="44" endline="50">
<![CDATA[
 
 		private FieldSignature(Type fieldType, Type[] optionalCustomModifiers, Type[] requiredCustomModifiers)
 		{
 			this.fieldType = fieldType;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="86" endline="98">
<![CDATA[
 	}
 	
 	public class CompletionMemberAccess 
 		Expression expr;
 		string partial_name;
 		TypeArguments targs;
 		
 		public CompletionMemberAccess (Expression e, string partial_name, Location l)
 		{
 			this.expr = e;
 			this.loc = l;
 			this.partial_name = partial_name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1207" endline="1221">
<![CDATA[
 	}
 
 	public class LiftedUnaryMutator 
 	{
 		public readonly UnaryMutator.Mode Mode;
 		Expression expr;
 		UnaryMutator underlying;
 		Unwrap unwrap;
 
 		public LiftedUnaryMutator (UnaryMutator.Mode mode, Expression expr, Location loc)
 		{
 			this.expr = expr;
 			this.Mode = mode;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="243" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1402" endline="1409">
<![CDATA[
 		public AnonymousMethodBody (ParametersCompiled parameters,
 					ParametersBlock block, TypeSpec return_type, TypeSpec delegate_type,
 					Location loc)
 			
 		{
 			this.type = delegate_type;
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="591" endline="603">
<![CDATA[
 		}
 
 		// Used for underlying binary operator
 		readonly Binary.Operator op;
 		Expression right;
 		Expression left;
 
 		public CompoundAssign (Binary.Operator op, Expression target, Expression source, Location loc)
 			
 		{
 			right = source;
 			this.op = op;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="244" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="537" endline="546">
<![CDATA[
 	}
 
 	class DynamicConstructorBinder 
 	{
 		public DynamicConstructorBinder (TypeSpec type, Arguments args, Location loc)
 			
 		{
 			this.type = type;
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="624" endline="635">
<![CDATA[
 	}
 
 	class DynamicInvocation 
 	{
 		ATypeNameExpression member;
 
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 			this.member = member;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="736" endline="828">
<![CDATA[
 	}
 
 	//
 	// Any member binder which can be source and target of assignment
 	//
 	abstract class DynamicMemberAssignable 
 	{
 		Expression setter;
 		Arguments setter_args;
 
 		protected DynamicMemberAssignable (Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			//
 			// DoResolve always uses getter
 			//
 			return CreateCallSiteBinder (ec, args, false);
 		}
 
 		protected abstract Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet);
 
 		protected virtual Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			var setter_args = new Arguments (Arguments.Count + 1);
 			setter_args.AddRange (Arguments);
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				right_side.DoResolveLValue (rc, this);
 				return null;
 			}
 
 			if (DoResolveCore (rc)) {
 				setter_args = CreateSetterArguments (rc, right_side);
 				setter = CreateCallSiteBinder (rc, setter_args, true);
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, false);
 			else
 				base.Emit (ec);
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, true);
 			else
 				base.EmitStatement (ec);
 		}
 
 		#region IAssignMethod Members
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			EmitCall (ec, setter, setter_args, !leave_copy);
 		}
 
 		#endregion
 	}
 
 	class DynamicUnaryConversion 
 	{
 		readonly string name;
 
 		public DynamicUnaryConversion (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 			base.binder = this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="245" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="136" endline="142">
<![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ParameterList
         Get
             Helper.Assert(m_ParameterList IsNot Nothing)
             Return m_ParameterList
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="134" endline="140">
<![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_ExpressionType IsNot Nothing)
             Return m_ExpressionType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="137" endline="143">
<![CDATA[
     End Property
 
     Property Type() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_Type IsNot Nothing)
             Return m_Type
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="246" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="117" endline="123">
<![CDATA[
 
     Sub Init(ByVal IsAssembly As Boolean, ByVal IsModule As Boolean, ByVal SimpleTypeName As SimpleTypeName, ByVal AttributeArguments As AttributeArguments)
         m_IsAssembly = IsAssembly
         m_IsModule = IsModule
         m_SimpleTypeName = SimpleTypeName
         m_AttributeArguments = AttributeArguments
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="76" endline="82">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier, ByVal TypeName As TypeName, ByVal Expression As Expression)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
         m_TypeName = TypeName
         m_Expression = Expression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="37" endline="43">
<![CDATA[
 
     Sub Init(ByVal Target As Expression, ByVal Start As Expression, ByVal Length As Expression, ByVal Source As Expression)
         m_Target = Target
         m_Start = Start
         m_Length = Length
         m_Source = Source
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="247" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="384" endline="390">
<![CDATA[
 
 		public override Type[] GetRequiredCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetRequiredCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="376" endline="383">
<![CDATA[
 		}
 
 		public override Type[] GetOptionalCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetOptionalCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="248" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1342" endline="1348">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			Child = Child.Resolve (rc);
 			this.eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="171" endline="177">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="249" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="71" endline="83">
<![CDATA[
 
 		//
 		// This routine must be overrided in derived classes and make copies
 		// of all the data that might be modified if resolved
 		// 
 		protected abstract void CloneTo (CloneContext clonectx, Statement target);
 
 		public Statement Clone (CloneContext clonectx)
 		{
 			Statement s = (Statement) this.MemberwiseClone ();
 			CloneTo (clonectx, s);
 			return s;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="906" endline="927">
<![CDATA[
 				String.Format (
 					"CloneTo not implemented for expression {0}", this.GetType ()));
 		}
 
 		//
 		// Clones an expression created by the parser.
 		//
 		// We only support expressions created by the parser so far, not
 		// expressions that have been resolved (many more classes would need
 		// to implement CloneTo).
 		//
 		// This infrastructure is here merely for Lambda expressions which
 		// compile the same code using different type values for the same
 		// arguments to find the correct overload
 		//
 		public virtual Expression Clone (CloneContext clonectx)
 		{
 			Expression cloned = (Expression) MemberwiseClone ();
 			CloneTo (clonectx, cloned);
 
 			return cloned;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="250" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="28" endline="34">
<![CDATA[
 		public NullableType (TypeExpr underlying, Location l)
 		{
 			this.underlying = underlying;
 			loc = l;
 
 			eclass = ExprClass.Type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="57" endline="82">
<![CDATA[
 	}
 
 	#region Dynamic runtime binder expressions
 
 	//
 	// Expression created from runtime dynamic object value by dynamic binder
 	//
 	public class RuntimeValueExpression 
 	{
 #if !NET_4_0
 		public class DynamicMetaObject
 		{
 			public TypeSpec RuntimeType;
 			public TypeSpec LimitType;
 			public SLE.Expression Expression;
 		}
 #endif
 
 		readonly DynamicMetaObject obj;
 
 		public RuntimeValueExpression (DynamicMetaObject obj, TypeSpec type)
 		{
 			this.obj = obj;
 			this.type = type;
 			this.eclass = ExprClass.Variable;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="251" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resource.vb" startline="64" endline="73">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a new resource with the specified values.
     ''' </summary>
     Sub New(ByVal Filename As String, ByVal Identifier As String, Optional ByVal [Public] As Boolean = True)
         Me.m_Filename = Filename
         Me.m_Identifier = Identifier
         Me.m_Public = [Public]
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" startline="50" endline="61">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Initializing constructor.
     ''' </summary>
     ''' <param name="LeftSide"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, Optional ByVal LeftSide As Boolean = False, Optional ByVal IsInTypeOf As Boolean = False)
         m_IsLeftSide = LeftSide
         m_IsInTypeOf = IsInTypeOf
         m_Parent = Parent
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="252" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="169" endline="175">
<![CDATA[
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="328" endline="334">
<![CDATA[
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed |
 					base.TypeAttr;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="253" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\StopStatement.vb" startline="30" endline="38">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ' Helper.NotImplemented()
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Diagnostics_Debugger__Break)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" startline="34" endline="41">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__EndApp)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="254" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="132" endline="138">
<![CDATA[
 
 		public FlowBranchingTryCatch StartFlowBranching (TryCatch stmt)
 		{
 			FlowBranchingTryCatch branching = new FlowBranchingTryCatch (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="139" endline="145">
<![CDATA[
 
 		public FlowBranchingException StartFlowBranching (ExceptionStatement stmt)
 		{
 			FlowBranchingException branching = new FlowBranchingException (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="146" endline="152">
<![CDATA[
 
 		public FlowBranchingLabeled StartFlowBranching (LabeledStatement stmt)
 		{
 			FlowBranchingLabeled branching = new FlowBranchingLabeled (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="255" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="134" endline="141">
<![CDATA[
 		}
 
 		private uint MetadataRVA
 		{
 			get
 			{
 				return (StrongNameSignatureRVA + StrongNameSignatureLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="118" endline="125">
<![CDATA[
 		}
 
 		internal uint StrongNameSignatureRVA
 		{
 			get
 			{
 				return (ResourcesRVA + ResourcesLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="256" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1432" endline="1440">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (1945, loc, "An expression tree cannot contain an anonymous method expression");
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7049" endline="7055">
<![CDATA[
 		}
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (1952, loc, "An expression tree cannot contain a method with variable arguments");
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="257" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="162" endline="168">
<![CDATA[
 
 		public static void DefineCapturedParameter (int scope_id, string name,
 							    string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedParameter (scope_id, name, captured_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="155" endline="161">
<![CDATA[
 
 		public static void DefineCapturedLocal (int scope_id, string name,
 							string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedLocal (scope_id, name, captured_name);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="258" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="718" endline="1185">
<![CDATA[
 				switch (ExplicitTarget) {
 				case "return"
 				case "param"
 				case "field"
 				case "method"
 				case "property"
 				case "module"
 				}
 				throw new InternalErrorException ("Unknown explicit target
 			}
 				
 			StringBuilder sb = new StringBuilder ();
 			foreach (string s in valid_targets) {
 				sb.Append (s);
 				sb.Append (", ");
 			}
 			sb.Remove (sb.Length - 2, 2);
 			Report.Error (657, Location, "`{0}' is not a valid attribute location for this declaration. " +
 				"Valid attribute locations for this declaration are `{1}'", ExplicitTarget, sb.ToString ());
 			return false;
 		}
 
 		/// <summary>
 		/// Tests permitted SecurityAction for assembly or other types
 		/// </summary>
 		protected virtual bool IsSecurityActionValid (bool for_assembly)
 		{
 			SecurityAction action = GetSecurityActionValue ();
 
 			switch (action) {
 #pragma warning disable 618
 			case SecurityAction.Demand
 			case SecurityAction.Assert
 			case SecurityAction.Deny
 			case SecurityAction.PermitOnly
 			case SecurityAction.LinkDemand
 			case SecurityAction.InheritanceDemand
 				if (!for_assembly)
 					return true;
 				break;
 
 			case SecurityAction.RequestMinimum
 			case SecurityAction.RequestOptional
 			case SecurityAction.RequestRefuse
 				if (for_assembly)
 					return true;
 				break;
 #pragma warning restore 618
 
 			default
 				Error_AttributeEmitError ("SecurityAction is out of range");
 				return false;
 			}
 
 			Error_AttributeEmitError (String.Concat ("SecurityAction `", action, "' is not valid for this declaration"));
 			return false;
 		}
 
 		System.Security.Permissions.SecurityAction GetSecurityActionValue ()
 		{
 			return (SecurityAction) ((Constant) PosArguments[0].Expr).GetValue ();
 		}
 
 		/// <summary>
 		/// Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
 		/// </summary>
 		/// <returns></returns>
 		public void ExtractSecurityPermissionSet (MethodSpec ctor, ref SecurityType permissions)
 		{
 #if STATIC
 			object[] values = new object [PosArguments.Count];
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 
 			PropertyInfo[] prop;
 			object[] prop_values;
 			if (named_values == null) {
 				prop = null;
 				prop_values = null;
 			} else {
 				prop = new PropertyInfo[named_values.Count];
 				prop_values = new object [named_values.Count];
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			var cab = new CustomAttributeBuilder ((ConstructorInfo) ctor.GetMetaInfo (), values, prop, prop_values);
 			permissions.Add (cab);
 #else
 			Type orig_assembly_type = null;
 
 			if (Type.MemberDefinition is TypeContainer) {
 				if (!RootContext.StdLib) {
 					orig_assembly_type = System.Type.GetType (Type.GetMetaInfo ().FullName);
 				} else {
 					string orig_version_path = Environment.GetEnvironmentVariable ("__SECURITY_BOOTSTRAP_DB");
 					if (orig_version_path == null) {
 						Error_AttributeEmitError ("security custom attributes can not be referenced from defining assembly");
 						return;
 					}
 
 					if (orig_sec_assembly == null) {
 						string file = Path.Combine (orig_version_path, Path.GetFileName (RootContext.OutputFile));
 						orig_sec_assembly = Assembly.LoadFile (file);
 					}
 
 					orig_assembly_type = orig_sec_assembly.GetType (Type.GetMetaInfo ().FullName, true);
 					if (orig_assembly_type == null) {
 						Report.Warning (-112, 1, Location, "Self-referenced security attribute `{0}' " +
 								"was not found in previous version of assembly");
 						return;
 					}
 				}
 			}
 
 			SecurityAttribute sa;
 			object[] args;
 
 			// For all non-selfreferencing security attributes we can avoid all hacks
 			if (orig_assembly_type == null) {
 				args = new object[PosArguments.Count];
 				for (int j = 0; j < args.Length; ++j) {
 					args[j] = ((Constant) PosArguments[j].Expr).GetValue ();
 				}
 
 				sa = (SecurityAttribute) Activator.CreateInstance (Type.GetMetaInfo (), args);
 
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						pi.SetValue (sa, ((Constant) named_values [i].Value.Expr).GetValue (), null);
 					}
 				}
 			} else {
 				// HACK
 				args = new object[] { GetSecurityActionValue () };
 				sa = (SecurityAttribute) Activator.CreateInstance (orig_assembly_type, args);
 
 				// All types are from newly created assembly but for invocation with old one we need to convert them
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo emited_pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						// FIXME
 						// TODO
 						PropertyInfo pi = orig_assembly_type.GetProperty (emited_pi.Name);
 
 						pi.SetValue (sa, ((Constant) named_values[i].Value.Expr).GetValue (), null);
 					}
 				}
 			}
 
 			IPermission perm;
 			perm = sa.CreatePermission ();
 			SecurityAction action = (SecurityAction) args [0];
 
 			// IS is correct because for corlib we are using an instance from old corlib
 			if (!(perm is System.Security.CodeAccessPermission)) {
 				switch (action) {
 				case SecurityAction.Demand
 					action = (SecurityAction)13;
 					break;
 				case SecurityAction.LinkDemand
 					action = (SecurityAction)14;
 					break;
 				case SecurityAction.InheritanceDemand
 					action = (SecurityAction)15;
 					break;
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			PermissionSet ps;
 			if (!permissions.TryGetValue (action, out ps)) {
 				if (sa is PermissionSetAttribute)
 					ps = new PermissionSet (sa.Unrestricted ? PermissionState.Unrestricted 
 				else
 					ps = new PermissionSet (PermissionState.None);
 
 				permissions.Add (action, ps);
 			} else if (!ps.IsUnrestricted () && (sa is PermissionSetAttribute) && sa.Unrestricted) {
 				ps = ps.Union (new PermissionSet (PermissionState.Unrestricted));
 				permissions [action] = ps;
 			}
 			ps.AddPermission (perm);
 #endif
 		}
 
 		public Constant GetNamedValue (string name)
 		{
 			if (named_values == null)
 				return null;
 
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 
 			return null;
 		}
 
 		public CharSet GetCharSetValue ()
 		{
 			return (CharSet)System.Enum.Parse (typeof (CharSet), ((Constant) PosArguments [0].Expr).GetValue ().ToString ());
 		}
 
 		public bool HasField (string fieldName)
 		{
 			if (named_values == null)
 				return false;
 
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 
 			return false;
 		}
 
 		//
 		// Returns true for MethodImplAttribute with MethodImplOptions.InternalCall value
 		// 
 		public bool IsInternalCall ()
 		{
 			MethodImplOptions options = 0;
 			if (PosArguments.Count == 1) {
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			} else if (HasField ("Value")) {
 				var named = GetNamedValue ("Value");
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), named.GetValue ().ToString ());
 			}
 
 			return (options & MethodImplOptions.InternalCall) != 0;
 		}
 
 		//
 		// Returns true for StructLayoutAttribute with LayoutKind.Explicit value
 		// 
 		public bool IsExplicitLayoutKind ()
 		{
 			if (PosArguments == null || PosArguments.Count != 1)
 				return false;
 
 			var value = (LayoutKind) System.Enum.Parse (typeof (LayoutKind), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			return value == LayoutKind.Explicit;
 		}
 
 		public Expression GetParameterDefaultValue ()
 		{
 			if (PosArguments == null)
 				return null;
 
 			return PosArguments[0].Expr;
 		}
 
 		public override bool Equals (object obj)
 		{
 			Attribute a = obj as Attribute;
 			if (a == null)
 				return false;
 
 			return Type == a.Type && Target == a.Target;
 		}
 
 		public override int GetHashCode ()
 		{
 			return type.GetHashCode () ^ Target.GetHashCode ();
 		}
 
 		/// <summary>
 		/// Emit attribute for Attributable symbol
 		/// </summary>
 		public void Emit (Dictionary<Attribute, List<Attribute>> allEmitted)
 		{
 			var ctor = Resolve ();
 			if (ctor == null)
 				return;
 
 			var predefined = context.Module.PredefinedAttributes;
 
 			AttributeUsageAttribute usage_attr = Type.GetAttributeUsage (predefined.AttributeUsage);
 			if ((usage_attr.ValidOn & Target) == 0) {
 				Report.Error (592, Location, "The attribute `{0}' is not valid on this declaration type. " +
 					      "It is valid on `{1}' declarations only",
 					GetSignatureForError (), GetValidTargets ());
 				return;
 			}
 
 			byte[] cdata;
 			if (PosArguments == null && named_values == null) {
 				cdata = AttributeEncoder.Empty;
 			} else {
 				AttributeEncoder encoder = new AttributeEncoder ();
 
 				if (PosArguments != null) {
 					var param_types = ctor.Parameters.Types;
 					for (int j = 0; j < PosArguments.Count; ++j) {
 						var pt = param_types[j];
 						var arg_expr = PosArguments[j].Expr;
 						if (j == 0) {
 							if (Type == predefined.IndexerName || Type == predefined.Conditional) {
 								string v = ((StringConstant) arg_expr).Value;
 								if (!Tokenizer.IsValidIdentifier (v) || Tokenizer.IsKeyword (v)) {
 									context.Compiler.Report.Error (633, arg_expr.Location,
 										"The argument to the `{0}' attribute must be a valid identifier", GetSignatureForError ());
 								}
 							} else if (Type == predefined.Guid) {
 								try {
 									string v = ((StringConstant) arg_expr).Value;
 									new Guid (v);
 								} catch (Exception e) {
 									Error_AttributeEmitError (e.Message);
 									return;
 								}
 							} else if (Type == predefined.AttributeUsage) {
 								int v = ((IntConstant) ((EnumConstant) arg_expr).Child).Value;
 								if (v == 0) {
 									context.Compiler.Report.Error (591, Location, "Invalid value for argument to `{0}' attribute",
 										"System.AttributeUsage");
 								}
 							} else if (Type == predefined.MarshalAs) {
 								if (PosArguments.Count == 1) {
 									var u_type = (UnmanagedType) System.Enum.Parse (typeof (UnmanagedType), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 									if (u_type == UnmanagedType.ByValArray && !(Owner is FieldBase)) {
 										Error_AttributeEmitError ("Specified unmanaged type is only valid on fields");
 									}
 								}
 							} else if (Type == predefined.DllImport) {
 								if (PosArguments.Count == 1) {
 									var value = ((Constant) PosArguments[0].Expr).GetValue () as string;
 									if (string.IsNullOrEmpty (value))
 										Error_AttributeEmitError ("DllName cannot be empty");
 								}
 							} else if (Type == predefined.MethodImpl && pt == TypeManager.short_type &&
 								!System.Enum.IsDefined (typeof (MethodImplOptions), ((Constant) arg_expr).GetValue ().ToString ())) {
 								Error_AttributeEmitError ("Incorrect argument value.");
 								return;
 							}
 						}
 
 						arg_expr.EncodeAttributeValue (context, encoder, pt);
 					}
 				}
 
 				if (named_values != null) {
 					encoder.Encode ((ushort) named_values.Count);
 					foreach (var na in named_values) {
 						if (na.Key is FieldExpr)
 							encoder.Encode ((byte) 0x53);
 						else
 							encoder.Encode ((byte) 0x54);
 
 						encoder.Encode (na.Key.Type);
 						encoder.Encode (na.Value.Name);
 						na.Value.Expr.EncodeAttributeValue (context, encoder, na.Key.Type);
 					}
 				} else {
 					encoder.EncodeEmptyNamedArguments ();
 				}
 
 				cdata = encoder.ToArray ();
 			}
 
 			try {
 				foreach (Attributable target in targets)
 					target.ApplyAttributeBuilder (this, ctor, cdata, predefined);
 			} catch (Exception e) {
 				Error_AttributeEmitError (e.Message);
 				return;
 			}
 
 			if (!usage_attr.AllowMultiple && allEmitted != null) {
 				if (allEmitted.ContainsKey (this)) {
 					var a = allEmitted [this];
 					if (a == null) {
 						a = new List<Attribute> (2);
 						allEmitted [this] = a;
 					}
 					a.Add (this);
 				} else {
 					allEmitted.Add (this, null);
 				}
 			}
 
 			if (!RootContext.VerifyClsCompliance)
 				return;
 
 			// Here we are testing attribute arguments for array usage (error 3016)
 			if (Owner.IsClsComplianceRequired ()) {
 				if (PosArguments != null)
 					PosArguments.CheckArrayAsAttribute (context.Compiler);
 			
 				if (NamedArguments == null)
 					return;
 
 				NamedArguments.CheckArrayAsAttribute (context.Compiler);
 			}
 		}
 
 		private Expression GetValue () 
 		{
 			if (PosArguments == null || PosArguments.Count < 1)
 				return null;
 
 			return PosArguments [0].Expr;
 		}
 
 		public string GetString () 
 		{
 			Expression e = GetValue ();
 			if (e is StringConstant)
 				return ((StringConstant)e).Value;
 			return null;
 		}
 
 		public bool GetBoolean () 
 		{
 			Expression e = GetValue ();
 			if (e is BoolConstant)
 				return ((BoolConstant)e).Value;
 			return false;
 		}
 
 		public TypeSpec GetArgumentType ()
 		{
 			TypeOf e = GetValue () as TypeOf;
 			if (e == null)
 				return null;
 			return e.TypeArgument;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			throw new NotSupportedException ("ET");
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 	}
 	
 
 	/// <summary>
 	/// For global attributes (assembly, module) we need special handling.
 	/// Attributes can be located in the several files
 	/// </summary>
 	public class GlobalAttribute 
 	{
 		public readonly NamespaceEntry ns;
 
 		public GlobalAttribute (NamespaceEntry ns, string target, ATypeNameExpression expression,
 					Arguments[] args, Location loc, bool nameEscaped)
 			base (target, expression, args, loc, nameEscaped)
 		{
 			this.ns = ns;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2229" endline="2235">
<![CDATA[
 
 		public GenericMethod (NamespaceEntry ns, DeclSpace parent, MemberName name, TypeParameter[] tparams,
 					  FullNamedExpression return_type, ParametersCompiled parameters)
 			
 		{
 			this.type_params = tparams;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="259" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2637" endline="2645">
<![CDATA[
 
     Private Function ParseMeExpression(ByVal Parent As ParsedObject) As MeExpression
         Dim result As MeExpression
 
         tm.AcceptIfNotInternalError(KS.Me)
         result = New MeExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2628" endline="2636">
<![CDATA[
 
     Private Function ParseMyBaseExpression(ByVal Parent As ParsedObject) As MyBaseExpression
         Dim result As MyBaseExpression
 
         tm.AcceptIfNotInternalError(KS.MyBase)
         result = New MyBaseExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2619" endline="2627">
<![CDATA[
 
     Private Function ParseMyClassExpression(ByVal Parent As ParsedObject) As MyClassExpression
         Dim result As MyClassExpression
 
         tm.AcceptIfNotInternalError(KS.MyClass)
         result = New MyClassExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="260" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="278" endline="285">
<![CDATA[
 
     ''' <summary>
     ''' Saves the message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function SaveMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(True, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="270" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Shows the multiline message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message() As Messages, ByVal Location As Span, ByVal ParamArray Parameters()() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="253" endline="260">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="261" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="190" endline="196">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Value As Expression)
         Me.New(DirectCast(Parent, ParsedObject))
         m_Type = Value.ExpressionType
         m_Value = Value
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="183" endline="189">
<![CDATA[
 
     Sub New(ByVal ParentAndValue As Expression)
         Me.New(DirectCast(ParentAndValue, ParsedObject))
         m_Type = ParentAndValue.ExpressionType
         m_Value = ParentAndValue
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="262" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="694" endline="701">
<![CDATA[
 
 		public SourceFileEntry (MonoSymbolFile file, string file_name,
 					byte[] guid, byte[] checksum)
 			
 		{
 			this.guid = guid;
 			this.hash = checksum;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="174" endline="180">
<![CDATA[
 
 		public NamedArgument (string name, Location loc, Expression expr, AType modifier)
 			
 		{
 			this.Name = name;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1796" endline="1802">
<![CDATA[
 
 		public TypeParameterName (string name, Attributes attrs, Variance variance, Location loc)
 			
 		{
 			attributes = attrs;
 			this.variance = variance;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="263" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="564" endline="570">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (break_origins);
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="588" endline="594">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (continue_origins);
 			return vector;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="264" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1049" endline="1059">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Stobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Stobj, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1060" endline="1070">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Ldobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="265" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="315" endline="321">
<![CDATA[
 
 		internal LocalVariableEntry (MonoSymbolFile file, MyBinaryReader reader)
 		{
 			Index = reader.ReadLeb128 ();
 			Name = reader.ReadString ();
 			BlockIndex = reader.ReadLeb128 ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="359" endline="365">
<![CDATA[
 
 		internal CapturedVariable (MyBinaryReader reader)
 		{
 			Name = reader.ReadString ();
 			CapturedName = reader.ReadString ();
 			Kind = (CapturedKind) reader.ReadByte ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="266" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2423" endline="2432">
<![CDATA[
 
 		#region Properties
 
 		//
 		// Block has been converted to expression tree
 		//
 		public bool IsExpressionTree {
 			get {
 				return (flags & Flags.IsExpressionTree) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2078" endline="2084">
<![CDATA[
 
 		#region Properties
 
 		public bool IsCompound {
 			get {
 				return (state & State.Compound) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="988" endline="997">
<![CDATA[
 		}
 
 		//
 		// Return true when this member is a generic in C# terms
 		// A nested non-generic type of generic type will return false
 		//
 		public bool IsGeneric {
 			get {
 				return (state & StateFlags.IsGeneric) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2173" endline="2181">
<![CDATA[
 		}
  
 		/// <summary>
 		/// Method container contains GetHashCode method
 		/// </summary>
 		public bool HasGetHashCode {
 			get {
 				return (cached_method & CachedMethods.GetHashCode) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2165" endline="2172">
<![CDATA[
 
 		/// <summary>
 		/// Method container contains Equals method
 		/// </summary>
 		public bool HasEquals {
 			get {
 				return (cached_method & CachedMethods.Equals) != 0;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="267" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\EventInfo.cs" startline="32" endline="45">
<![CDATA[
 		}
 
 		public abstract EventAttributes Attributes { get; }
 		public abstract MethodInfo GetAddMethod(bool nonPublic);
 		public abstract MethodInfo GetRaiseMethod(bool nonPublic);
 		public abstract MethodInfo GetRemoveMethod(bool nonPublic);
 		public abstract MethodInfo[] GetOtherMethods(bool nonPublic);
 		public abstract Type EventHandlerType { get; }
 		internal abstract bool IsPublic { get; }
 		internal abstract bool IsStatic { get; }
 
 		public bool IsSpecialName
 		{
 			get { return (Attributes & EventAttributes.SpecialName) != 0; }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ParameterInfo.cs" startline="50" endline="64">
<![CDATA[
 
 		public abstract string Name { get; }
 		public abstract Type ParameterType { get; }
 		public abstract ParameterAttributes Attributes { get; }
 		public abstract int Position { get; }
 		public abstract object RawDefaultValue { get; }
 		public abstract Type[] GetOptionalCustomModifiers();
 		public abstract Type[] GetRequiredCustomModifiers();
 		public abstract MemberInfo Member { get; }
 		public abstract int MetadataToken { get; }
 		internal abstract Module Module { get; }
 
 		public bool IsIn
 		{
 			get { return (Attributes & ParameterAttributes.In) != 0; }
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="268" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="153" endline="159">
<![CDATA[
 
 		public FlowBranchingIterator StartFlowBranching (Iterator iterator, FlowBranching parent)
 		{
 			FlowBranchingIterator branching = new FlowBranchingIterator (parent, iterator);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="160" endline="166">
<![CDATA[
 
 		public FlowBranchingToplevel StartFlowBranching (ParametersBlock stmt, FlowBranching parent)
 		{
 			FlowBranchingToplevel branching = new FlowBranchingToplevel (parent, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="269" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="305" endline="320">
<![CDATA[
 	}
 
 	public class PredefinedType
 	{
 		string name;
 		string ns;
 		int arity;
 		MemberKind kind;
 		ModuleContainer module;
 		protected TypeSpec type;
 
 		public PredefinedType (ModuleContainer module, MemberKind kind, string ns, string name, int arity)
 			
 		{
 			this.arity = arity;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1613" endline="1623">
<![CDATA[
 	}
 
 	class ImportedGenericMethodDefinition 
 	{
 		readonly TypeParameterSpec[] tparams;
 
 		public ImportedGenericMethodDefinition (MethodInfo provider, TypeSpec type, AParametersCollection parameters, TypeParameterSpec[] tparams, MetadataImporter importer)
 			
 		{
 			this.tparams = tparams;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="270" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3649" endline="3657">
<![CDATA[
 
     Shared Function GetEventAccess(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetEventAttributes([Event])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3640" endline="3648">
<![CDATA[
 
     Shared Function GetPropertyAccess(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetPropertyAttributes([Property])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="271" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="142" endline="154">
<![CDATA[
 
 			#endregion
 		}
 
 		public AQueryClause next;
 		public QueryBlock block;
 
 		protected AQueryClause (QueryBlock block, Expression expr, Location loc)
 			 
 		{
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="141" endline="153">
<![CDATA[
 	}
 
 	public class ConstInitializer 
 	{
 		bool in_transit;
 		readonly FieldBase field;
 
 		public ConstInitializer (FieldBase field, Expression value, Location loc)
 			
 		{
 			this.loc = loc;
 			this.field = field;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1550" endline="1564">
<![CDATA[
 		}
 	}
 	
 	//
 	// This represents a typecast in the source language.
 	//
 	public class Cast 
 		Expression target_type;
 
 		public Cast (Expression cast_type, Expression expr, Location loc)
 			
 		{
 			this.target_type = cast_type;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="272" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="595" endline="604">
<![CDATA[
 	}
 	
 	public class StatementExpression 
 		ExpressionStatement expr;
 		
 		public StatementExpression (ExpressionStatement expr)
 		{
 			this.expr = expr;
 			loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1982" endline="1995">
<![CDATA[
 	}
 
 	//
 	// Standard composite pattern
 	//
 	public abstract class CompositeExpression 
 	{
 		protected Expression expr;
 
 		protected CompositeExpression (Expression expr)
 		{
 			this.expr = expr;
 			this.loc = expr.Location;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="273" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="277" endline="283">
<![CDATA[
 
 		#region Properties
 
 		public bool IsReadOnly {
 			get {
 				return (Modifiers & Modifiers.READONLY) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="253" endline="259">
<![CDATA[
 		}
 
 		// When is virtual or abstract
 		public bool IsVirtual {
 			get {
 				return (Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE)) != 0;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="274" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New PropertyAccessClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="275" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="462" endline="472">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteGuidIndex()
 				.WriteGuidIndex()
 				.WriteGuidIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2060" endline="2070">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(12)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="276" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyClassExpression.vb" startline="31" endline="39">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="36" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="277" nfragments="14" Csharpe_files="14" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="725" endline="731">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.short_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="843" endline="849">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.ushort_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="412" endline="418">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.byte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="619" endline="625">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.sbyte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1892" endline="1898">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1766" endline="1772">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.decimal_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1638" endline="1644">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.double_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1515" endline="1521">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.float_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1398" endline="1404">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1136" endline="1142">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="955" endline="961">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="495" endline="501">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.char_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="340" endline="346">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.bool_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="278" nfragments="33" Csharpe_files="33" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="150" endline="174">
<![CDATA[
 				AppendResults (results, partial_name, r);
 			}
 
 			throw new CompletionResult (partial_name == null ? "" 
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompletionMemberAccess target = (CompletionMemberAccess) t;
 
 			if (targs != null)
 				target.targs = targs.Clone ();
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	public class CompletionElementInitializer 
 		string partial_name;
 		
 		public CompletionElementInitializer (string partial_name, Location l)
 		{
 			this.partial_name = partial_name;
 			this.loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3921" endline="3938">
<![CDATA[
 	}
 
 	// Base class for statements that are implemented in terms of try...finally
 	public abstract class ExceptionStatement 
 	{
 		bool code_follows;
 		Iterator iter;
 		List<ResumableStatement> resume_points;
 		int first_resume_pc;
 		protected Statement stmt;
 		Label dispose_try_block;
 		bool prepared_for_dispose, emitted_dispose;
 
 		protected ExceptionStatement (Statement stmt, Location loc)
 		{
 			this.stmt = stmt;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="60" endline="69">
<![CDATA[
 	}
 	
 	public class CompletionSimpleName 
 		public string Prefix;
 		
 		public CompletionSimpleName (string prefix, Location l)
 		{
 			this.loc = l;
 			this.Prefix = prefix;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5408" endline="5579">
<![CDATA[
 	}
 
 	abstract class PropertyOrIndexerExpr<T> 
 	{
 		// getter and setter can be different for base calls
 		MethodSpec getter, setter;
 		protected T best_candidate;
 
 		protected LocalTemporary temp;
 		protected bool prepared;
 
 		protected PropertyOrIndexerExpr (Location l)
 		{
 			loc = l;
 		}
 
 		#region Properties
 
 		public MethodSpec Getter {
 			get {
 				return getter;
 			}
 			set {
 				getter = value;
 			}
 		}
 
 		public MethodSpec Setter {
 			get {
 				return setter;
 			}
 			set {
 				setter = value;
 			}
 		}
 
 		#endregion
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, null);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.Resolve (ec);
 			}
 
 			if (!ResolveGetter (ec))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				// TODO
 				INamedBlockVariable variable = null;
 				if (best_candidate != null && ec.CurrentBlock.ParametersBlock.TopBlock.GetLocalName (best_candidate.Name, ec.CurrentBlock, ref variable) && variable is Linq.RangeVariable) {
 					ec.Report.Error (1939, loc, "A range variable `{0}' may not be passes as `ref' or `out' parameter",
 						best_candidate.Name);
 				} else {
 					right_side.DoResolveLValue (ec, this);
 				}
 				return null;
 			}
 
 			// if the property/indexer returns a value type, and we try to set a field in it
 			if (right_side == EmptyExpression.LValueMemberAccess || right_side == EmptyExpression.LValueMemberOutAccess) {
 				Error_CannotModifyIntermediateExpressionValue (ec);
 			}
 
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, right_side);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.ResolveLValue (ec, right_side);
 			}
 
 			if (!ResolveSetter (ec))
 				return null;
 
 			return this;
 		}
 
 		//
 		// Implements the IAssignMethod interface for assignments
 		//
 		public abstract void Emit (EmitContext ec, bool leave_copy);
 		public abstract void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load);
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public abstract SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source);
 
 		protected abstract Expression OverloadResolve (ResolveContext rc, Expression right_side);
 
 		bool ResolveGetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasGet) {
 				if (InstanceExpression != EmptyExpression.Null) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate);
 					rc.Report.Error (154, loc, "The property or indexer `{0}' cannot be used in this context because it lacks the `get' accessor",
 						best_candidate.GetSignatureForError ());
 					return false;
 				}
 			} else if (!best_candidate.Get.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					rc.Report.Error (271, loc, "The property or indexer `{0}' cannot be used in this context because the get accessor is inaccessible",
 						TypeManager.CSharpSignature (best_candidate));
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					ErrorIsInaccesible (rc, best_candidate.Get.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility) {
 				CheckProtectedMemberAccess (rc, best_candidate.Get);
 			}
 
 			getter = CandidateToBaseOverride (rc, best_candidate.Get);
 			return true;
 		}
 
 		bool ResolveSetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasSet) {
 				rc.Report.Error (200, loc, "Property or indexer `{0}' cannot be assigned to (it is read-only)",
 					GetSignatureForError ());
 				return false;
 			}
 
 			if (!best_candidate.Set.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					rc.Report.Error (272, loc, "The property or indexer `{0}' cannot be used in this context because the set accessor is inaccessible",
 						GetSignatureForError ());
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					ErrorIsInaccesible (rc, best_candidate.Set.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility)
 				CheckProtectedMemberAccess (rc, best_candidate.Set);
 
 			setter = CandidateToBaseOverride (rc, best_candidate.Set);
 			return true;
 		}
 	}
 
 	/// <summary>
 	///   Fully resolved expression that evaluates to an Event
 	/// </summary>
 	public class EventExpr 
 	{
 		readonly EventSpec spec;
 		MethodSpec op;
 
 		public EventExpr (EventSpec spec, Location loc)
 		{
 			this.spec = spec;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2979" endline="4697">
<![CDATA[
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
 
 		public MethodGroupExpr (MethodSpec m, TypeSpec type, Location loc)
 			
 		{
 		}
 
 		#region Properties
 
 		public MethodSpec BestCandidate {
 			get {
 				return best_candidate;
 			}
 		}
 
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return;
 			}
 		}
 
 		protected override TypeSpec DeclaringType {
 			get {
 				return queried_type;
 			}
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override string Name {
 			get {
 				if (best_candidate != null)
 					return best_candidate.Name;
 
 				// TODO
 				return Methods.First ().Name;
 			}
 		}
 
 		#endregion
 
 		//
 		// When best candidate is already know this factory can be used
 		// to avoid expensive overload resolution to be called
 		//
 		// NOTE
 		//
 		public static MethodGroupExpr CreatePredefined (MethodSpec best, TypeSpec queriedType, Location loc)
 		{
 			return new MethodGroupExpr (best, queriedType, loc) {
 				best_candidate = best,
 				best_candidate_return = best.ReturnType
 			};
 		}
 
 		public override string GetSignatureForError ()
 		{
 			if (best_candidate != null)
 				return best_candidate.GetSignatureForError ();
 
 			return Methods.First ().GetSignatureForError ();
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (best_candidate == null) {
 				ec.Report.Error (1953, loc, "An expression tree cannot contain an expression with method group");
 				return null;
 			}
 
 			if (best_candidate.IsConditionallyExcluded (loc))
 				ec.Report.Error (765, loc,
 					"Partial methods with only a defining declaration or removed conditional methods cannot be used in an expression tree");
 			
 			return new TypeOfMethod (best_candidate, loc);
 		}
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			this.eclass = ExprClass.MethodGroup;
 
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (ec);
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotSupportedException ();
 		}
 		
 		public void EmitCall (EmitContext ec, Arguments arguments)
 		{
 			Invocation.EmitCall (ec, InstanceExpression, best_candidate, arguments, loc);			
 		}
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			ec.Report.Error (428, loc, "Cannot convert method group `{0}' to non-delegate type `{1}'. Consider using parentheses to invoke the method",
 				Name, TypeManager.CSharpName (target));
 		}
 
 		public static bool IsExtensionMethodArgument (Expression expr)
 		{
 			//
 			// LAMESPEC
 			//
 			return !(expr is TypeExpr) && !(expr is BaseThis);
 		}
 
 		/// <summary>
 		///   Find the Applicable Function Members (7.4.2.1)
 		///
 		///   me
 		///       it might contain constructors or methods (or anything
 		///       that maps to a method).
 		///
 		///   Arguments
 		///
 		///   loc
 		///        location for "probing" purposes.
 		///
 		///   Returns
 		///            that is the best match of me on Arguments.
 		///
 		/// </summary>
 		public virtual MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments args, OverloadResolver.IErrorHandler cerrors, OverloadResolver.Restrictions restr)
 		{
 			// TODO
 			if (best_candidate != null && best_candidate.Kind == MemberKind.Destructor)
 				return this;
 
 			var r = new OverloadResolver (Methods, type_arguments, restr, loc);
 			if ((restr & OverloadResolver.Restrictions.NoBaseMembers) == 0) {
 				r.BaseMembersProvider = this;
 			}
 
 			if (cerrors != null)
 				r.CustomErrors = cerrors;
 
 			// TODO
 			best_candidate = r.ResolveMember<MethodSpec> (ec, ref args);
 			if (best_candidate == null)
 				return r.BestCandidateIsDynamic ? this 
 
 			// Overload resolver had to create a new method group, all checks bellow have already been executed
 			if (r.BestCandidateNewMethodGroup != null)
 				return r.BestCandidateNewMethodGroup;
 
 			if (best_candidate.Kind == MemberKind.Method && (restr & OverloadResolver.Restrictions.ProbingOnly) == 0) {
 				if (InstanceExpression != null) {
 					if (best_candidate.IsExtensionMethod && args[0].Expr == InstanceExpression) {
 						InstanceExpression = null;
 					} else {
 						if (best_candidate.IsStatic && simple_name != null) {
 							InstanceExpression = ProbeIdenticalTypeName (ec, InstanceExpression, simple_name);
 						}
 
 						InstanceExpression.Resolve (ec);
 					}
 				}
 
 				ResolveInstanceExpression (ec, null);
 				if (InstanceExpression != null)
 					CheckProtectedMemberAccess (ec, best_candidate);
 			}
 
 			var base_override = CandidateToBaseOverride (ec, best_candidate);
 			if (base_override == best_candidate) {
 				best_candidate_return = r.BestCandidateReturnType;
 			} else {
 				best_candidate = base_override;
 				best_candidate_return = best_candidate.ReturnType;
 			}
 
 			return this;
 		}
 
 		public override MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			simple_name = original;
 			return base.ResolveMemberAccess (ec, left, original);
 		}
 
 		public override void SetTypeArguments (ResolveContext ec, TypeArguments ta)
 		{
 			type_arguments = ta;
 		}
 
 		#region IBaseMembersProvider Members
 
 		public virtual IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
 
 		public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			return MemberCache.FindMember (queried_type, new MemberFilter ((MethodSpec) member),
 				BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
 
 		//
 		// Extension methods lookup after ordinary methods candidates failed to apply
 		//
 		public virtual MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			if (InstanceExpression == null)
 				return null;
 
 			InstanceExpression = InstanceExpression.Resolve (rc);
 			if (!IsExtensionMethodArgument (InstanceExpression))
 				return null;
 
 			int arity = type_arguments == null ? 0 
 			NamespaceEntry methods_scope = null;
 			var methods = rc.LookupExtensionMethod (InstanceExpression.Type, Methods[0].Name, arity, ref methods_scope);
 			if (methods == null)
 				return null;
 
 			var emg = new ExtensionMethodGroupExpr (methods, methods_scope, InstanceExpression, loc);
 			emg.SetTypeArguments (rc, type_arguments);
 			return emg;
 		}
 
 		#endregion
 	}
 
 	public struct OverloadResolver
 	{
 		[Flags]
 		public enum Restrictions
 		{
 			None = 0,
 			DelegateInvoke = 1,
 			ProbingOnly	= 1 << 1,
 			CovariantDelegate = 1 << 2,
 			NoBaseMembers = 1 << 3,
 			BaseMembersIncluded = 1 << 4
 		}
 
 		public interface IBaseMembersProvider
 		{
 			IList<MemberSpec> GetBaseMembers (TypeSpec baseType);
 			IParametersMember GetOverrideMemberParameters (MemberSpec member);
 			MethodGroupExpr LookupExtensionMethod (ResolveContext rc);
 		}
 
 		public interface IErrorHandler
 		{
 			bool AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous);
 			bool ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument a, int index);
 			bool NoArgumentMatch (ResolveContext rc, MemberSpec best);
 			bool TypeInferenceFailed (ResolveContext rc, MemberSpec best);
 		}
 
 		sealed class NoBaseMembers 
 		{
 			public static readonly IBaseMembersProvider Instance = new NoBaseMembers ();
 
 			public IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 			{
 				return null;
 			}
 
 			public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 			{
 				return null;
 			}
 
 			public MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 			{
 				return null;
 			}
 		}
 
 		struct AmbiguousCandidate
 		{
 			public readonly MemberSpec Member;
 			public readonly bool Expanded;
 			public readonly AParametersCollection Parameters;
 
 			public AmbiguousCandidate (MemberSpec member, AParametersCollection parameters, bool expanded)
 			{
 				Member = member;
 				Parameters = parameters;
 				Expanded = expanded;
 			}
 		}
 
 		Location loc;
 		IList<MemberSpec> members;
 		TypeArguments type_arguments;
 		IBaseMembersProvider base_provider;
 		IErrorHandler custom_errors;
 		Restrictions restrictions;
 		MethodGroupExpr best_candidate_extension_group;
 		TypeSpec best_candidate_return_type;
 
 		SessionReportPrinter lambda_conv_msgs;
 		ReportPrinter prev_recorder;
 
 		public OverloadResolver (IList<MemberSpec> members, Restrictions restrictions, Location loc)
 			
 		{
 		}
 
 		public OverloadResolver (IList<MemberSpec> members, TypeArguments targs, Restrictions restrictions, Location loc)
 			
 		{
 			if (members == null || members.Count == 0)
 				throw new ArgumentException ("empty members set");
 
 			this.members = members;
 			this.loc = loc;
 			type_arguments = targs;
 			this.restrictions = restrictions;
 			if (IsDelegateInvoke)
 				this.restrictions |= Restrictions.NoBaseMembers;
 
 			base_provider = NoBaseMembers.Instance;
 		}
 
 		#region Properties
 
 		public IBaseMembersProvider BaseMembersProvider {
 			get {
 				return base_provider;
 			}
 			set {
 				base_provider = value;
 			}
 		}
 
 		public bool BestCandidateIsDynamic { get; set; }
 
 		//
 		// Best candidate was found in newly created MethodGroupExpr, used by extension methods
 		//
 		public MethodGroupExpr BestCandidateNewMethodGroup {
 			get {
 				return best_candidate_extension_group;
 			}
 		}
 
 		//
 		// Return type can be different between best candidate and closest override
 		//
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return_type;
 			}
 		}
 
 		public IErrorHandler CustomErrors {
 			get {
 				return custom_errors;
 			}
 			set {
 				custom_errors = value;
 			}
 		}
 
 		TypeSpec DelegateType {
 			get {
 				if ((restrictions & Restrictions.DelegateInvoke) == 0)
 					throw new InternalErrorException ("Not running in delegate mode", loc);
 
 				return members [0].DeclaringType;
 			}
 		}
 
 		bool IsProbingOnly {
 			get {
 				return (restrictions & Restrictions.ProbingOnly) != 0;
 			}
 		}
 
 		bool IsDelegateInvoke {
 			get {
 				return (restrictions & Restrictions.DelegateInvoke) != 0;
 			}
 		}
 
 		#endregion
 
 		//
 		//  7.4.3.3  Better conversion from expression
 		//  Returns 
 		//              2    if a->q is better,
 		//              0 if neither is better
 		//
 		static int BetterExpressionConversion (ResolveContext ec, Argument a, TypeSpec p, TypeSpec q)
 		{
 			TypeSpec argument_type = a.Type;
 
 			//
 			// If argument is an anonymous function
 			//
 			if (argument_type == InternalType.AnonymousMethod && RootContext.Version > LanguageVersion.ISO_2) {
 				//
 				// p and q are delegate types or expression tree types
 				//
 				if (p.GetDefinition () == TypeManager.expression_type || q.GetDefinition () == TypeManager.expression_type) {
 					if (q.MemberDefinition != p.MemberDefinition) {
 						return 0;
 					}
 
 					//
 					// Uwrap delegate from Expression<T>
 					//
 					q = TypeManager.GetTypeArguments (q)[0];
 					p = TypeManager.GetTypeArguments (p)[0];
 				}
 
 				var p_m = Delegate.GetInvokeMethod (ec.Compiler, p);
 				var q_m = Delegate.GetInvokeMethod (ec.Compiler, q);
 
 				//
 				// With identical parameter lists
 				//
 				if (!TypeSpecComparer.Equals (p_m.Parameters.Types,q_m.Parameters.Types))
 					return 0;
 
 				p = p_m.ReturnType;
 				q = q_m.ReturnType;
 
 				//
 				// if p is void returning, and q has a return type Y, then C2 is the better conversion.
 				//
 				if (p == TypeManager.void_type) {
 					return q != TypeManager.void_type ? 2 
 				}
 
 				//
 				// if p has a return type Y, and q is void returning, then C1 is the better conversion.
 				//
 				if (q == TypeManager.void_type) {
 					return p != TypeManager.void_type ? 1
 				}
 			} else {
 				if (argument_type == p)
 					return 1;
 
 				if (argument_type == q)
 					return 2;
 			}
 
 			return BetterTypeConversion (ec, p, q);
 		}
 
 		//
 		// 7.4.3.4  Better conversion from type
 		//
 		public static int BetterTypeConversion (ResolveContext ec, TypeSpec p, TypeSpec q)
 		{
 			if (p == null || q == null)
 				throw new InternalErrorException ("BetterTypeConversion got a null conversion");
 
 			if (p == TypeManager.int32_type) {
 				if (q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.int64_type) {
 				if (q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.sbyte_type) {
 				if (q == TypeManager.byte_type || q == TypeManager.ushort_type ||
 					q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.short_type) {
 				if (q == TypeManager.ushort_type || q == TypeManager.uint32_type ||
 					q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 2;
 			}
 
 			if (q == TypeManager.int32_type) {
 				if (p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.int64_type) {
 				if (p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == TypeManager.sbyte_type) {
 				if (p == TypeManager.byte_type || p == TypeManager.ushort_type ||
 					p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.short_type) {
 				if (p == TypeManager.ushort_type || p == TypeManager.uint32_type ||
 					p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 1;
 			}
 
 			// FIXME
 
 			// TODO
 			Expression p_tmp = new EmptyExpression (p);
 			Expression q_tmp = new EmptyExpression (q);
 
 			bool p_to_q = Convert.ImplicitConversionExists (ec, p_tmp, q);
 			bool q_to_p = Convert.ImplicitConversionExists (ec, q_tmp, p);
 
 			if (p_to_q && !q_to_p)
 				return 1;
 
 			if (q_to_p && !p_to_q)
 				return 2;
 
 			return 0;
 		}
 
 		/// <summary>
 		///   Determines "Better function" between candidate
 		///   and the current best match
 		/// </summary>
 		/// <remarks>
 		///    Returns a boolean indicating 
 		///     false if candidate ain't better
 		///     true  if candidate is better than the current best match
 		/// </remarks>
 		static bool BetterFunction (ResolveContext ec, Arguments args, MemberSpec candidate, AParametersCollection cparam, bool candidate_params,
 			MemberSpec best, AParametersCollection bparam, bool best_params)
 		{
 			AParametersCollection candidate_pd = ((IParametersMember) candidate).Parameters;
 			AParametersCollection best_pd = ((IParametersMember) best).Parameters;
 
 			bool better_at_least_one = false;
 			bool same = true;
 			int args_count = args == null ? 0 
 			int j = 0;
 			Argument a = null;
 			TypeSpec ct, bt;
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 
 			if (better_at_least_one)
 				return true;
 
 			//
 			// This handles the case
 			//
 			//   Add (float f1, float f2, float f3);
 			//   Add (params decimal [] foo);
 			//
 			// The call Add (3, 4, 5) should be ambiguous.  Without this check, the
 			// first candidate would've chosen as better.
 			//
 			if (!same && !a.IsDefaultArgument)
 				return false;
 
 			//
 			// The two methods have equal non-optional parameter types, apply tie-breaking rules
 			//
 
 			//
 			// This handles the following cases
 			//
 			//  Foo (int i) is better than Foo (int i, long l = 0)
 			//  Foo (params int[] args) is better than Foo (int i = 0, params int[] args)
 			//
 			// Prefer non-optional version
 			//
 			// LAMESPEC
 			//
 			if (candidate_params == best_params && candidate_pd.Count != best_pd.Count) {
 				if (candidate_pd.Count >= best_pd.Count)
 					return false;
 
 				if (j < candidate_pd.Count && candidate_pd.FixedParameters[j].HasDefaultValue)
 					return false;
 
 				return true;
 			}
 
 			//
 			// One is a non-generic method and second is a generic method, then non-generic is better
 			//
 			if (best.IsGeneric != candidate.IsGeneric)
 				return best.IsGeneric;
 
 			//
 			// This handles the following cases
 			//
 			//   Trim () is better than Trim (params char[] chars)
 			//   Concat (string s1, string s2, string s3) is better than
 			//     Concat (string s1, params string [] srest)
 			//   Foo (int, params int [] rest) is better than Foo (params int [] rest)
 			//
 			// Prefer non-expanded version
 			//
 			if (candidate_params != best_params)
 				return best_params;
 
 			int candidate_param_count = candidate_pd.Count;
 			int best_param_count = best_pd.Count;
 
 			if (candidate_param_count != best_param_count)
 				// can only happen if (candidate_params && best_params)
 				return candidate_param_count > best_param_count && best_pd.HasParams;
 
 			//
 			// Both methods have the same number of parameters, and the parameters have equal types
 			// Pick the "more specific" signature using rules over original (non-inflated) types
 			//
 			var candidate_def_pd = ((IParametersMember) candidate.MemberDefinition).Parameters;
 			var best_def_pd = ((IParametersMember) best.MemberDefinition).Parameters;
 
 			bool specific_at_least_once = false;
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 
 			if (specific_at_least_once)
 				return true;
 
 			return false;
 		}
 
 		public static void Error_ConstructorMismatch (ResolveContext rc, TypeSpec type, int argCount, Location loc)
 		{
 			rc.Report.Error (1729, loc,
 				"The type `{0}' does not contain a constructor that takes `{1}' arguments",
 				type.GetSignatureForError (), argCount.ToString ());
 		}
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
 
 		//
 		// Tests argument compatibility with the parameter
 		// The possible return values are
 		// 0 - success
 		// 1 - modifier mismatch
 		// 2 - type mismatch
 		// -1 - dynamic binding required
 		//
 		int IsArgumentCompatible (ResolveContext ec, Argument argument, Parameter.Modifier param_mod, TypeSpec parameter)
 		{
 			//
 			// Types have to be identical when ref or out modifer
 			// is used and argument is not of dynamic type
 			//
 			if ((argument.Modifier | param_mod) != 0) {
 				if (argument.Type != parameter) {
 					//
 					// Do full equality check after quick path
 					//
 					if (!TypeSpecComparer.IsEqual (argument.Type, parameter)) {
 						//
 						// Using dynamic for ref/out parameter can still succeed at runtime
 						//
 						if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 							return -1;
 
 						return 2;
 					}
 				}
 
 				if (argument.Modifier != param_mod) {
 					//
 					// Using dynamic for ref/out parameter can still succeed at runtime
 					//
 					if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 						return -1;
 
 					return 1;
 				}
 
 			} else {
 				if (argument.Type == InternalType.Dynamic && (restrictions & Restrictions.CovariantDelegate) == 0)
 					return -1;
 
 				//
 				// Deploy custom error reporting for lambda methods. When probing lambda methods
 				// keep all errors reported in separate set and once we are done and no best
 				// candidate found, this set is used to report more details about what was wrong
 				// with lambda body
 				//
 				if (argument.Expr.Type == InternalType.AnonymousMethod) {
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 				}
 
 				if (!Convert.ImplicitConversionExists (ec, argument.Expr, parameter)) {
 					if (lambda_conv_msgs != null) {
 						lambda_conv_msgs.EndSession ();
 					}
 
 					return 2;
 				}
 			}
 
 			return 0;
 		}
 
 		static TypeSpec MoreSpecific (TypeSpec p, TypeSpec q)
 		{
 			if (TypeManager.IsGenericParameter (p) && !TypeManager.IsGenericParameter (q))
 				return q;
 			if (!TypeManager.IsGenericParameter (p) && TypeManager.IsGenericParameter (q))
 				return p;
 
 			var ac_p = p as ArrayContainer;
 			if (ac_p != null) {
 				var ac_q = ((ArrayContainer) q);
 				TypeSpec specific = MoreSpecific (ac_p.Element, ac_q.Element);
 				if (specific == ac_p.Element)
 					return p;
 				if (specific == ac_q.Element)
 					return q;
 			} else if (TypeManager.IsGenericType (p)) {
 				var pargs = TypeManager.GetTypeArguments (p);
 				var qargs = TypeManager.GetTypeArguments (q);
 
 				bool p_specific_at_least_once = false;
 				bool q_specific_at_least_once = false;
 
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 
 				if (p_specific_at_least_once && !q_specific_at_least_once)
 					return p;
 				if (!p_specific_at_least_once && q_specific_at_least_once)
 					return q;
 			}
 
 			return null;
 		}
 
 		//
 		// Find the best method from candidate list
 		//
 		public T ResolveMember<T> (ResolveContext rc, ref Arguments args) where T 
 		{
 			List<AmbiguousCandidate> ambiguous_candidates = null;
 
 			MemberSpec best_candidate;
 			Arguments best_candidate_args = null;
 			bool best_candidate_params = false;
 			bool best_candidate_dynamic = false;
 			int best_candidate_rate;
 			IParametersMember best_parameter_member = null;
 
 			int args_count = args != null ? args.Count 
 
 			Arguments candidate_args = args;
 			bool error_mode = false;
 			var current_type = rc.CurrentType;
 			MemberSpec invocable_member = null;
 
 			// Be careful, cannot return until error reporter is restored
 			while (true) {
 				best_candidate = null;
 				best_candidate_rate = int.MaxValue;
 
 				var type_members = members;
 				try {
 
 					do {
 						for (int i = 0; i < type_members.Count; ++i) {
 							var member = type_members[i];
 
 							//
 							// Methods in a base class are not candidates if any method in a derived
 							// class is applicable
 							//
 							if ((member.Modifiers & Modifiers.OVERRIDE) != 0)
 								continue;
 
 							if (!error_mode) {
 								if (!member.IsAccessible (current_type))
 									continue;
 
 								if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (current_type))
 									continue;
 							}
 
 							IParametersMember pm = member as IParametersMember;
 							if (pm == null) {
 								//
 								// Will use it later to report ambiguity between best method and invocable member
 								//
 								if (Invocation.IsMemberInvocable (member))
 									invocable_member = member;
 
 								continue;
 							}
 
 							//
 							// Overload resolution is looking for base member but using parameter names
 							// and default values from the closest member. That means to do expensive lookup
 							// for the closest override for virtual or abstract members
 							//
 							if ((member.Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 								var override_params = base_provider.GetOverrideMemberParameters (member);
 								if (override_params != null)
 									pm = override_params;
 							}
 
 							//
 							// Check if the member candidate is applicable
 							//
 							bool params_expanded_form = false;
 							bool dynamic_argument = false;
 							TypeSpec rt = pm.MemberType;
 							int candidate_rate = IsApplicable (rc, ref candidate_args, args_count, ref member, pm, ref params_expanded_form, ref dynamic_argument, ref rt);
 
 							//
 							// How does it score compare to others
 							//
 							if (candidate_rate < best_candidate_rate) {
 								best_candidate_rate = candidate_rate;
 								best_candidate = member;
 								best_candidate_args = candidate_args;
 								best_candidate_params = params_expanded_form;
 								best_candidate_dynamic = dynamic_argument;
 								best_parameter_member = pm;
 								best_candidate_return_type = rt;
 							} else if (candidate_rate == 0) {
 								//
 								// The member look is done per type for most operations but sometimes
 								// it's not possible like for binary operators overload because they
 								// are unioned between 2 sides
 								//
 								if ((restrictions & Restrictions.BaseMembersIncluded) != 0) {
 									if (TypeSpec.IsBaseClass (best_candidate.DeclaringType, member.DeclaringType, true))
 										continue;
 								}
 
 								bool is_better;
 								if (best_candidate.DeclaringType.IsInterface && member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 									//
 									// We pack all interface members into top level type which makes the overload resolution
 									// more complicated for interfaces. We accomodate for this by removing methods with same
 									// signature when building the cache hence this path should not really be hit often
 									//
 									// Example
 									// interface IA { void Foo (int arg); }
 									// interface IB 
 									//
 									// IB
 									//
 									is_better = true;
 									if (ambiguous_candidates != null) {
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										}
 
 										if (is_better)
 											ambiguous_candidates = null;
 									}
 								} else {
 									// Is the new candidate better
 									is_better = BetterFunction (rc, candidate_args, member, pm.Parameters, params_expanded_form, best_candidate, best_parameter_member.Parameters, best_candidate_params);
 								}
 
 								if (is_better) {
 									best_candidate = member;
 									best_candidate_args = candidate_args;
 									best_candidate_params = params_expanded_form;
 									best_candidate_dynamic = dynamic_argument;
 									best_parameter_member = pm;
 									best_candidate_return_type = rt;
 								} else {
 									// It's not better but any other found later could be but we are not sure yet
 									if (ambiguous_candidates == null)
 										ambiguous_candidates = new List<AmbiguousCandidate> ();
 
 									ambiguous_candidates.Add (new AmbiguousCandidate (member, pm.Parameters, params_expanded_form));
 								}
 							}
 
 							// Restore expanded arguments
 							if (candidate_args != args)
 								candidate_args = args;
 						}
 					} while (best_candidate_rate != 0 && (type_members = base_provider.GetBaseMembers (type_members[0].DeclaringType.BaseType)) != null);
 				} finally {
 					if (prev_recorder != null)
 						rc.Report.SetPrinter (prev_recorder);
 				}
 
 				//
 				// We've found exact match
 				//
 				if (best_candidate_rate == 0)
 					break;
 
 				//
 				// Try extension methods lookup when no ordinary method match was found and provider enables it
 				//
 				if (!error_mode) {
 					var emg = base_provider.LookupExtensionMethod (rc);
 					if (emg != null) {
 						emg = emg.OverloadResolve (rc, ref args, null, restrictions);
 						if (emg != null) {
 							best_candidate_extension_group = emg;
 							return (T) (MemberSpec) emg.BestCandidate;
 						}
 					}
 				}
 
 				// Don't run expensive error reporting mode for probing
 				if (IsProbingOnly)
 					return null;
 
 				if (error_mode)
 					break;
 
 				lambda_conv_msgs = null;
 				error_mode = true;
 			}
 
 			//
 			// No best member match found, report an error
 			//
 			if (best_candidate_rate != 0 || error_mode) {
 				ReportOverloadError (rc, best_candidate, best_parameter_member, best_candidate_args, best_candidate_params);
 				return null;
 			}
 
 			if (best_candidate_dynamic) {
 				if (args[0].ArgType == Argument.AType.ExtensionType) {
 					rc.Report.Error (1973, loc,
 						"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' cannot be dynamically dispatched. Consider calling the method without the extension method syntax",
 						args [0].Type.GetSignatureForError (), best_candidate.Name, best_candidate.GetSignatureForError ());
 				}
 
 				BestCandidateIsDynamic = true;
 				return null;
 			}
 
 			if (ambiguous_candidates != null) {
 				//
 				// Now check that there are no ambiguities i.e the selected method
 				// should be better than all the others
 				//
 				for (int ix = 0; ix < ambiguous_candidates.Count; ix++) {
 					var candidate = ambiguous_candidates [ix];
 
 					if (!BetterFunction (rc, best_candidate_args, best_candidate, best_parameter_member.Parameters, best_candidate_params, candidate.Member, candidate.Parameters, candidate.Expanded)) {
 						var ambiguous = candidate.Member;
 						if (custom_errors == null || !custom_errors.AmbiguousCandidates (rc, best_candidate, ambiguous)) {
 							rc.Report.SymbolRelatedToPreviousError (best_candidate);
 							rc.Report.SymbolRelatedToPreviousError (ambiguous);
 							rc.Report.Error (121, loc, "The call is ambiguous between the following methods or properties
 								best_candidate.GetSignatureForError (), ambiguous.GetSignatureForError ());
 						}
 
 						return (T) best_candidate;
 					}
 				}
 			}
 
 			if (invocable_member != null) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.SymbolRelatedToPreviousError (invocable_member);
 				rc.Report.Warning (467, 2, loc, "Ambiguity between method `{0}' and invocable non-method `{1}'. Using method group",
 					best_candidate.GetSignatureForError (), invocable_member.GetSignatureForError ());
 			}
 
 			//
 			// And now check if the arguments are all
 			// compatible, perform conversions if
 			// necessary etc. and return if everything is
 			// all right
 			//
 			if (!VerifyArguments (rc, ref best_candidate_args, best_candidate, best_parameter_member, best_candidate_params))
 				return null;
 
 			if (best_candidate == null)
 				return null;
 
 			//
 			// Check ObsoleteAttribute on the best method
 			//
 			ObsoleteAttribute oa = best_candidate.GetAttributeObsolete ();
 			if (oa != null && !rc.IsObsolete)
 				AttributeTester.Report_ObsoleteMessage (oa, best_candidate.GetSignatureForError (), loc, rc.Report);
 
 			var dep = best_candidate.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			best_candidate.MemberDefinition.SetIsUsed ();
 
 			args = best_candidate_args;
 			return (T) best_candidate;
 		}
 
 		public MethodSpec ResolveOperator (ResolveContext rc, ref Arguments args)
 		{
 			return ResolveMember<MethodSpec> (rc, ref args);
 		}
 
 		void ReportArgumentMismatch (ResolveContext ec, int idx, MemberSpec method,
 													Argument a, AParametersCollection expected_par, TypeSpec paramType)
 		{
 			if (custom_errors != null && custom_errors.ArgumentMismatch (ec, method, a, idx))
 				return;
 
 			if (a is CollectionElementInitializer.ElementInitializerArgument) {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				if ((expected_par.FixedParameters[idx].ModFlags & Parameter.Modifier.ISBYREF) != 0) {
 					ec.Report.Error (1954, loc, "The best overloaded collection initalizer method `{0}' cannot have 'ref', or `out' modifier",
 						TypeManager.CSharpSignature (method));
 					return;
 				}
 				ec.Report.Error (1950, loc, "The best overloaded collection initalizer method `{0}' has some invalid arguments",
 					  TypeManager.CSharpSignature (method));
 			} else if (IsDelegateInvoke) {
 				ec.Report.Error (1594, loc, "Delegate `{0}' has some invalid arguments",
 					DelegateType.GetSignatureForError ());
 			} else {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				ec.Report.Error (1502, loc, "The best overloaded method match for `{0}' has some invalid arguments",
 					method.GetSignatureForError ());
 			}
 
 			Parameter.Modifier mod = idx >= expected_par.Count ? 0 
 
 			string index = (idx + 1).ToString ();
 			if (((mod & (Parameter.Modifier.REF | Parameter.Modifier.OUT)) ^
 				(a.Modifier & (Parameter.Modifier.REF | Parameter.Modifier.OUT))) != 0) {
 				if ((mod & Parameter.Modifier.ISBYREF) == 0)
 					ec.Report.Error (1615, loc, "Argument `#{0}' does not require `{1}' modifier. Consider removing `{1}' modifier",
 						index, Parameter.GetModifierSignature (a.Modifier));
 				else
 					ec.Report.Error (1620, loc, "Argument `#{0}' is missing `{1}' modifier",
 						index, Parameter.GetModifierSignature (mod));
 			} else {
 				string p1 = a.GetSignatureForError ();
 				string p2 = TypeManager.CSharpName (paramType);
 
 				if (p1 == p2) {
 					ec.Report.ExtraInformation (loc, "(equally named types possibly from different assemblies in previous ");
 					ec.Report.SymbolRelatedToPreviousError (a.Expr.Type);
 					ec.Report.SymbolRelatedToPreviousError (paramType);
 				}
 
 				ec.Report.Error (1503, loc,
 					"Argument `#{0}' cannot convert `{1}' expression to type `{2}'", index, p1, p2);
 			}
 		}
 
 		//
 		// We have failed to find exact match so we return error info about the closest match
 		//
 		void ReportOverloadError (ResolveContext rc, MemberSpec best_candidate, IParametersMember pm, Arguments args, bool params_expanded)
 		{
 			int ta_count = type_arguments == null ? 0 
 			int arg_count = args == null ? 0 
 
 			if (ta_count != best_candidate.Arity && (ta_count > 0 || ((IParametersMember) best_candidate).Parameters.IsEmpty)) {
 				var mg = new MethodGroupExpr (new [] { best_candidate }, best_candidate.DeclaringType, loc);
 				mg.Error_TypeArgumentsCannotBeUsed (rc.Report, loc, best_candidate, ta_count);
 				return;
 			}
 
 			if (lambda_conv_msgs != null) {
 				if (lambda_conv_msgs.Merge (rc.Report.Printer))
 					return;
 			}
 
 			//
 			// For candidates which match on parameters count report more details about incorrect arguments
 			//
 			if (pm != null) {
 				int unexpanded_count = ((IParametersMember) best_candidate).Parameters.HasParams ? pm.Parameters.Count - 1 
 				if (pm.Parameters.Count == arg_count || params_expanded || unexpanded_count == arg_count) {
 					// Reject any inaccessible member
 					if (!best_candidate.IsAccessible (rc.CurrentType) || !best_candidate.DeclaringType.IsAccessible (rc.CurrentType)) {
 						rc.Report.SymbolRelatedToPreviousError (best_candidate);
 						Expression.ErrorIsInaccesible (rc, best_candidate.GetSignatureForError (), loc);
 						return;
 					}
 
 					var ms = best_candidate as MethodSpec;
 					if (ms != null && ms.IsGeneric) {
 						bool constr_ok = true;
 						if (ms.TypeArguments != null)
 							constr_ok = new ConstraintChecker (rc.MemberContext).CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc);
 
 						if (ta_count == 0) {
 							if (custom_errors != null && custom_errors.TypeInferenceFailed (rc, best_candidate))
 								return;
 
 							if (constr_ok) {
 								rc.Report.Error (411, loc,
 									"The type arguments for method `{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly",
 									ms.GetGenericMethodDefinition ().GetSignatureForError ());
 							}
 
 							return;
 						}
 					}
 
 					VerifyArguments (rc, ref args, best_candidate, pm, params_expanded);
 					return;
 				}
 			}
 
 			//
 			// We failed to find any method with correct argument count, report best candidate
 			//
 			if (custom_errors != null && custom_errors.NoArgumentMatch (rc, best_candidate))
 				return;
 
 			if (best_candidate.Kind == MemberKind.Constructor) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				Error_ConstructorMismatch (rc, best_candidate.DeclaringType, arg_count, loc);
 			} else if (IsDelegateInvoke) {
 				rc.Report.SymbolRelatedToPreviousError (DelegateType);
 				rc.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					DelegateType.GetSignatureForError (), arg_count.ToString ());
 			} else {
 				string name = best_candidate.Kind == MemberKind.Indexer ? "this" 
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.Error (1501, loc, "No overload for method `{0}' takes `{1}' arguments",
 					name, arg_count.ToString ());
 			}
 		}
 
 		bool VerifyArguments (ResolveContext ec, ref Arguments args, MemberSpec member, IParametersMember pm, bool chose_params_expanded)
 		{
 			var pd = pm.Parameters;
 			TypeSpec[] ptypes = ((IParametersMember) member).Parameters.Types;
 
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 			int a_idx = 0, a_pos = 0;
 			Argument a = null;
 			ArrayInitializer params_initializers = null;
 			bool has_unsafe_arg = pm.MemberType.IsPointer;
 			int arg_count = args == null ? 0 
 
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 
 			if (a_idx != arg_count) {
 				ReportArgumentMismatch (ec, a_pos, member, a, pd, pt);
 				return false;
 			}
 
 			//
 			// Fill not provided arguments required by params modifier
 			//
 			if (params_initializers == null && pd.HasParams && arg_count + 1 == pd.Count) {
 				if (args == null)
 					args = new Arguments (1);
 
 				pt = ptypes[pd.Count - 1];
 				pt = TypeManager.GetElementType (pt);
 				has_unsafe_arg |= pt.IsPointer;
 				params_initializers = new ArrayInitializer (0, loc);
 			}
 
 			//
 			// Append an array argument with all params arguments
 			//
 			if (params_initializers != null) {
 				args.Add (new Argument (
 					new ArrayCreation (new TypeExpression (pt, loc), params_initializers, loc).Resolve (ec)));
 				arg_count++;
 			}
 
 			if (has_unsafe_arg && !ec.IsUnsafe) {
 				Expression.UnsafeError (ec, loc);
 			}
 
 			//
 			// We could infer inaccesible type arguments
 			//
 			if (type_arguments == null && member.IsGeneric) {
 				var ms = (MethodSpec) member;
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 			}
 
 			return true;
 		}
 	}
 
 	public class ConstantExpr 
 	{
 		ConstSpec constant;
 
 		public ConstantExpr (ConstSpec constant, Location loc)
 		{
 			this.constant = constant;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="694" endline="706">
<![CDATA[
 		}
 	}
 
 	public class MissingType 
 	{
 		readonly string full_name;
 		readonly MissingAssembly assembly;
 
 		public MissingType (string typeName, MissingAssembly assembly)
 		{
 			this.full_name = typeName;
 			this.assembly = assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1641" endline="1654">
<![CDATA[
 	}
 	
 	//
 	// C# 2.0 Default value expression
 	//
 	public class DefaultValueExpression 
 	{
 		Expression expr;
 
 		public DefaultValueExpression (Expression expr, Location loc)
 		{
 			this.expr = expr;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="100" endline="291">
<![CDATA[
 		private readonly int position;
 
 		private sealed class DummyModule 
 		{
 			internal DummyModule()
 				
 			{
 			}
 
 			public override bool Equals(object obj)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int GetHashCode()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ToString()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int MDStreamVersion
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Assembly Assembly
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			internal override Type GetTypeImpl(string typeName)
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override void GetTypesImpl(List<Type> list)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string FullyQualifiedName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override string Name
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Guid ModuleVersionId
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ResolveString(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ScopeName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override AssemblyName[] __GetReferencedAssemblies()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override Type GetModuleType()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override ByteReader GetBlob(int blobIndex)
 			{
 				throw new InvalidOperationException();
 			}
 		}
 
 		internal static Type Make(int position)
 		{
 			return module.CanonicalizeType(new UnboundGenericMethodParameter(position));
 		}
 
 		private UnboundGenericMethodParameter(int position)
 		{
 			this.position = position;
 		}
 
 		public override bool Equals(object obj)
 		{
 			UnboundGenericMethodParameter other = obj as UnboundGenericMethodParameter;
 			return other != null && other.position == position;
 		}
 
 		public override int GetHashCode()
 		{
 			return position;
 		}
 
 		public override string Namespace
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override string Name
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override int MetadataToken
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Module Module
 		{
 			get { return module; }
 		}
 
 		public override int GenericParameterPosition
 		{
 			get { return position; }
 		}
 
 		public override Type DeclaringType
 		{
 			get { return null; }
 		}
 
 		public override MethodBase DeclaringMethod
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Type[] GetGenericParameterConstraints()
 		{
 			throw new InvalidOperationException();
 		}
 
 		public override GenericParameterAttributes GenericParameterAttributes
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			return binder.BindMethodParameter(this);
 		}
 	}
 
 	sealed class GenericTypeParameter 
 	{
 		private readonly ModuleReader module;
 		private readonly int index;
 
 		internal GenericTypeParameter(ModuleReader module, int index)
 		{
 			this.module = module;
 			this.index = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9317" endline="9334">
<![CDATA[
 	}
 	
 	//
 	// A block of object or collection initializers
 	//
 	public class CollectionOrObjectInitializers 
 	{
 		IList<Expression> initializers;
 		bool is_collection_initialization;
 		
 		public static readonly CollectionOrObjectInitializers Empty = 
 			new CollectionOrObjectInitializers (Array.AsReadOnly (new Expression [0]), Location.Null);
 
 		public CollectionOrObjectInitializers (IList<Expression> initializers, Location loc)
 		{
 			this.initializers = initializers;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="44" endline="253">
<![CDATA[
 
 		bool is_double_colon;
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    TypeArguments args, Location loc)
 			
 		{
 			if (args != null && args.Count > 0)
 				this.TypeArguments = args;
 		}
 
 		public MemberName (string name)
 			
 		{ }
 
 		public MemberName (string name, Location loc)
 			
 		{ }
 
 		public MemberName (string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (string alias, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right, Location loc)
 			
 		{
 			if (right.is_double_colon)
 				throw new InternalErrorException ("Cannot append double_colon member name");
 			this.Left = (right.Left == null) ? left 
 		}
 
 		// TODO
 		public string GetName ()
 		{
 			return GetName (false);
 		}
 
 		public int Arity {
 			get {
 				return TypeArguments == null ? 0 
 			}
 		}
 
 		public bool IsGeneric {
 			get {
 				if (TypeArguments != null)
 					return true;
 				else if (Left != null)
 					return Left.IsGeneric;
 				else
 					return false;
 			}
 		}
 
 		public string GetName (bool is_generic)
 		{
 			string name = is_generic ? Basename 
 			if (Left != null)
 				return Left.GetName (is_generic) + (is_double_colon ? "
 
 			return name;
 		}
 
 		public ATypeNameExpression GetTypeExpression ()
 		{
 			if (Left == null) {
 				if (TypeArguments != null)
 					return new SimpleName (Name, TypeArguments, Location);
 				
 				return new SimpleName (Name, Location);
 			}
 
 			if (is_double_colon) {
 				if (Left.Left != null)
 					throw new InternalErrorException ("The left side of a 
 				return new QualifiedAliasMember (Left.Name, Name, TypeArguments, Location);
 			}
 
 			Expression lexpr = Left.GetTypeExpression ();
 			return new MemberAccess (lexpr, Name, TypeArguments, Location);
 		}
 
 		public MemberName Clone ()
 		{
 			MemberName left_clone = Left == null ? null 
 			return new MemberName (left_clone, Name, is_double_colon, TypeArguments, Location);
 		}
 
 		public string Basename {
 			get {
 				if (TypeArguments != null)
 					return MakeName (Name, TypeArguments);
 				return Name;
 			}
 		}
 
 		public string GetSignatureForError ()
 		{
 			string append = TypeArguments == null ? "" 
 			if (Left == null)
 				return Name + append;
 			string connect = is_double_colon ? "
 			return Left.GetSignatureForError () + connect + Name + append;
 		}
 
 		public override bool Equals (object other)
 		{
 			return Equals (other as MemberName);
 		}
 
 		public bool Equals (MemberName other)
 		{
 			if (this == other)
 				return true;
 			if (other == null || Name != other.Name)
 				return false;
 			if (is_double_colon != other.is_double_colon)
 				return false;
 
 			if ((TypeArguments != null) &&
 			    (other.TypeArguments == null || TypeArguments.Count != other.TypeArguments.Count))
 				return false;
 
 			if ((TypeArguments == null) && (other.TypeArguments != null))
 				return false;
 
 			if (Left == null)
 				return other.Left == null;
 
 			return Left.Equals (other.Left);
 		}
 
 		public override int GetHashCode ()
 		{
 			int hash = Name.GetHashCode ();
 			for (MemberName n = Left; n != null; n = n.Left)
 				hash ^= n.Name.GetHashCode ();
 			if (is_double_colon)
 				hash ^= 0xbadc01d;
 
 			if (TypeArguments != null)
 				hash ^= TypeArguments.Count << 5;
 
 			return hash & 0x7FFFFFFF;
 		}
 
 		public int CountTypeArguments {
 			get {
 				if (TypeArguments != null)
 					return TypeArguments.Count;
 				else if (Left != null)
 					return Left.CountTypeArguments; 
 				else
 					return 0;
 			}
 		}
 
 		public static string MakeName (string name, TypeArguments args)
 		{
 			if (args == null)
 				return name;
 
 			return name + "`" + args.Count;
 		}
 
 		public static string MakeName (string name, int count)
 		{
 			return name + "`" + count;
 		}
 	}
 
 	public class SimpleMemberName
 	{
 		public string Value;
 		public Location Location;
 
 		public SimpleMemberName (string name, Location loc)
 		{
 			this.Value = name;
 			this.Location = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2986" endline="3007">
<![CDATA[
 	}
 	
 	public class SwitchLabel {
 		Expression label;
 		object converted;
 		Location loc;
 
 		Label il_label;
 		bool  il_label_set;
 		Label il_label_code;
 		bool  il_label_code_set;
 
 		public static readonly object NullStringCase = new object ();
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4527" endline="4703">
<![CDATA[
 	}
 
 	public abstract class VariableReference 
 		LocalTemporary temp;
 
 		#region Abstract
 		public abstract HoistedVariable GetHoistedVariable (AnonymousExpression ae);
 
 		public abstract bool IsLockedByStatement { get; set; }
 
 		public abstract bool IsFixed { get; }
 		public abstract bool IsRef { get; }
 		public abstract string Name { get; }
 		public abstract void SetHasAddressTaken ();
 
 		//
 		// Variable IL data, it has to be protected to encapsulate hoisted variables
 		//
 		protected abstract ILocalVariable Variable { get; }
 		
 		//
 		// Variable flow-analysis data
 		//
 		public abstract VariableInfo VariableInfo { get; }
 		#endregion
 
 		public virtual void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (IsLockedByStatement) {
 				rc.Report.Warning (728, 2, loc,
 					"Possibly incorrect assignment to `{0}' which is the argument to a using or lock statement",
 					Name);
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			// do nothing
 		}
 
 		//
 		// This method is used by parameters that are references, that are
 		// being passed as references
 		// is already stored in the parameter, not the address of the pointer,
 		// and not the value of the variable).
 		//
 		public void EmitLoad (EmitContext ec)
 		{
 			Variable.Emit (ec);
 		}
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
 
 
 		public HoistedVariable GetHoistedVariable (ResolveContext rc)
 		{
 			return GetHoistedVariable (rc.CurrentAnonymousMethod);
 		}
 
 		public HoistedVariable GetHoistedVariable (EmitContext ec)
 		{
 			return GetHoistedVariable (ec.CurrentAnonymousMethod);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Name;
 		}
 
 		public bool IsHoisted {
 			get { return GetHoistedVariable ((AnonymousExpression) null) != null; }
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="972" endline="985">
<![CDATA[
 	}
 
 	/// <summary>
 	///   `goto case' statement
 	/// </summary>
 	public class GotoCase 
 		Expression expr;
 		SwitchLabel sl;
 		
 		public GotoCase (Expression e, Location l)
 		{
 			expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4689" endline="4867">
<![CDATA[
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return local_info.VariableInfo; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return local_info.HoistedVariant;
 		}
 
 		#region Properties
 
 		//		
 		// A local variable is always fixed
 		//
 		public override bool IsFixed {
 			get {
 				return true;
 			}
 		}
 
 		public override bool IsLockedByStatement {
 			get {
 				return local_info.IsLocked;
 			}
 			set {
 				local_info.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return false; }
 		}
 
 		public override string Name {
 			get { return local_info.Name; }
 		}
 
 		#endregion
 
 		public bool VerifyAssigned (ResolveContext ec)
 		{
 			VariableInfo variable_info = local_info.VariableInfo;
 			return variable_info == null || variable_info.IsAssigned (ec, loc);
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			local_info.AddressTaken = true;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			Arguments arg = new Arguments (1);
 			arg.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", arg);
 		}
 
 		void DoResolveBase (ResolveContext ec)
 		{
 			VerifyAssigned (ec);
 
 			//
 			// If we are referencing a variable from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (local_info)) {
 				if (local_info.AddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (ec.IsVariableCapturingRequired) {
 					AnonymousMethodStorey storey = local_info.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureLocalVariable (ec, local_info);
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			type = local_info.Type;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			// is out param
 			if (right_side == EmptyExpression.OutAccess.Instance)
 				local_info.SetIsUsed ();
 
 			if (local_info.IsReadonly && !ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.UsingInitializerScope)) {
 				int code;
 				string msg;
 				if (right_side == EmptyExpression.OutAccess.Instance) {
 					code = 1657; msg = "Cannot pass `{0}' as a ref or out argument because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberAccess) {
 					code = 1654; msg = "Cannot assign to members of `{0}' because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberOutAccess) {
 					code = 1655; msg = "Cannot pass members of `{0}' as ref or out arguments because it is a `{1}'";
 				} else if (right_side == EmptyExpression.UnaryAddress) {
 					code = 459; msg = "Cannot take the address of {1} `{0}'";
 				} else {
 					code = 1656; msg = "Cannot assign to `{0}' because it is a `{1}'";
 				}
 				ec.Report.Error (code, loc, msg, Name, local_info.GetReadOnlyContext ());
 			} else if (VariableInfo != null) {
 				VariableInfo.SetAssigned (ec);
 			}
 
 			DoResolveBase (ec);
 
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		public override int GetHashCode ()
 		{
 			return local_info.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			LocalVariableReference lvr = obj as LocalVariableReference;
 			if (lvr == null)
 				return false;
 
 			return local_info == lvr.local_info;
 		}
 
 		protected override ILocalVariable Variable {
 			get { return local_info; }
 		}
 
 		public override string ToString ()
 		{
 			return String.Format ("{0} ({1}
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing
 		}
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8826" endline="8842">
<![CDATA[
 	}
 
 	//
 	// Holds additional type specifiers like ?, *, []
 	//
 	public class ComposedTypeSpecifier
 	{
 		public static readonly ComposedTypeSpecifier SingleDimension = new ComposedTypeSpecifier (1, Location.Null);
 
 		public readonly int Dimension;
 		public readonly Location Location;
 
 		public ComposedTypeSpecifier (int specifier, Location loc)
 		{
 			this.Dimension = specifier;
 			this.Location = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="192" endline="695">
<![CDATA[
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
 
 		#region Properties
 
 		public DefaultParameterValueExpression DefaultValue {
 			get {
 				return default_expr as DefaultParameterValueExpression;
 			}
 			set {
 				default_expr = value;
 			}
 		}
 
 		Expression IParameterData.DefaultValue {
 			get {
 				var expr = default_expr as DefaultParameterValueExpression;
 				return expr == null ? default_expr 
 			}
 		}
 
 		bool HasOptionalExpression {
 			get {
 				return default_expr is DefaultParameterValueExpression;
 			}
 		}
 
 		public Location Location {
 			get {
 				return loc;
 			}
 		}
 
 		public TypeSpec Type {
 			get {
 				return parameter_type;
 			}
 		}
 
 		public FullNamedExpression TypeExpression  {
 			get {
 				return texpr;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.In && ModFlags == Modifier.OUT) {
 				a.Report.Error (36, a.Location, "An out parameter cannot have the `In' attribute");
 				return;
 			}
 
 			if (a.Type == pa.ParamArray) {
 				a.Report.Error (674, a.Location, "Do not use `System.ParamArrayAttribute'. Use the `params' keyword instead");
 				return;
 			}
 
 			if (a.Type == pa.Out && (ModFlags & Modifier.REF) == Modifier.REF &&
 			    !OptAttributes.Contains (pa.In)) {
 				a.Report.Error (662, a.Location,
 					"Cannot specify only `Out' attribute on a ref parameter. Use both `In' and `Out' attributes or neither");
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				a.Report.Warning (3022, 1, a.Location, "CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead");
 			}
 
 			if (a.Type == pa.DefaultParameterValue || a.Type == pa.OptionalParameter) {
 				if (HasOptionalExpression) {
 					a.Report.Error (1745, a.Location,
 						"Cannot specify `{0}' attribute on optional parameter `{1}'",
 						TypeManager.CSharpName (a.Type).Replace ("Attribute", ""), Name);
 				}
 
 				if (a.Type == pa.DefaultParameterValue)
 					return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 		
 		public virtual bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			if (parameter_type == null)
 				return true;
 
 			return member.IsAccessibleAs (parameter_type);
 		}
 
 		public static void Reset ()
 		{
 			parameter_expr_tree_type = null;
 		}
 
 		// <summary>
 		//   Resolve is used in method definitions
 		// </summary>
 		public virtual TypeSpec Resolve (IMemberContext rc, int index)
 		{
 			if (parameter_type != null)
 				return parameter_type;
 
 			if (attributes != null)
 				attributes.AttachTo (this, rc);
 
 			var expr = texpr.ResolveAsTypeTerminal (rc, false);
 			if (expr == null)
 				return null;
 
 			this.idx = index;
 			texpr = expr;
 			parameter_type = texpr.Type;
 	
 			if ((modFlags & Parameter.Modifier.ISBYREF) != 0 &&
 				TypeManager.IsSpecialType (parameter_type)) {
 				rc.Compiler.Report.Error (1601, Location, "Method or delegate parameter cannot be of type `{0}'",
 					GetSignatureForError ());
 				return null;
 			}
 
 			TypeManager.CheckTypeVariance (parameter_type,
 				(modFlags & Parameter.Modifier.ISBYREF) != 0 ? Variance.None 
 				rc);
 
 			if (parameter_type.IsStatic) {
 				rc.Compiler.Report.Error (721, Location, "`{0}'
 					texpr.GetSignatureForError ());
 				return parameter_type;
 			}
 
 			if ((modFlags & Modifier.This) != 0 && (parameter_type.IsPointer || parameter_type == InternalType.Dynamic)) {
 				rc.Compiler.Report.Error (1103, Location, "The extension method cannot be of type `{0}'",
 					TypeManager.CSharpName (parameter_type));
 			}
 
 			return parameter_type;
 		}
 
 		public void ResolveDefaultValue (ResolveContext rc)
 		{
 			//
 			// Default value was specified using an expression
 			//
 			if (default_expr != null) {
 				((DefaultParameterValueExpression)default_expr).Resolve (rc, this);
 				return;
 			}
 
 			if (attributes == null)
 				return;
 			
 			var opt_attr = attributes.Search (rc.Module.PredefinedAttributes.OptionalParameter);
 			var def_attr = attributes.Search (rc.Module.PredefinedAttributes.DefaultParameterValue);
 			if (def_attr != null) {
 				if (def_attr.Resolve () == null)
 					return;
 
 				var default_expr_attr = def_attr.GetParameterDefaultValue ();
 				if (default_expr_attr == null)
 					return;
 
 				var dpa_rc = def_attr.CreateResolveContext ();
 				default_expr = default_expr_attr.Resolve (dpa_rc);
 
 				if (default_expr is BoxedCast)
 					default_expr = ((BoxedCast) default_expr).Child;
 
 				Constant c = default_expr as Constant;
 				if (c == null) {
 					if (parameter_type == TypeManager.object_type) {
 						rc.Compiler.Report.Error (1910, default_expr.Location,
 							"Argument of type `{0}' is not applicable for the DefaultParameterValue attribute",
 							default_expr.Type.GetSignatureForError ());
 					} else {
 						rc.Compiler.Report.Error (1909, default_expr.Location,
 							"The DefaultParameterValue attribute is not applicable on parameters of type `{0}'",
 							default_expr.Type.GetSignatureForError ()); ;
 					}
 
 					default_expr = null;
 					return;
 				}
 
 				if (TypeSpecComparer.IsEqual (default_expr.Type, parameter_type) ||
 					(default_expr is NullConstant && TypeManager.IsReferenceType (parameter_type) && !parameter_type.IsGenericParameter) ||
 					TypeSpecComparer.IsEqual (parameter_type, TypeManager.object_type)) {
 					return;
 				}
 
 				//
 				// LAMESPEC
 				// User operators returning same type as parameter type are considered
 				// valid for this attribute only
 				//
 				// struct S { public static implicit operator S (int i) {} }
 				//
 				// void M ([DefaultParameterValue (3)]S s)
 				//
 				var expr = Convert.ImplicitUserConversion (dpa_rc, default_expr, parameter_type, loc);
 				if (expr != null && TypeSpecComparer.IsEqual (expr.Type, parameter_type)) {
 					return;
 				}
 				
 				rc.Compiler.Report.Error (1908, default_expr.Location, "The type of the default value should match the type of the parameter");
 				return;
 			}
 
 			if (opt_attr != null) {
 				default_expr = EmptyExpression.MissingValue;
 			}
 		}
 
 		public bool HasDefaultValue {
 			get { return default_expr != null; }
 		}
 
 		public bool HasExtensionMethodModifier {
 			get { return (modFlags & Modifier.This) != 0; }
 		}
 
 		//
 		// Hoisted parameter variant
 		//
 		public HoistedVariable HoistedVariant {
 			get {
 				return hoisted_variant;
 			}
 			set {
 				hoisted_variant = value;
 			}
 		}
 
 		public Modifier ModFlags {
 			get { return modFlags & ~Modifier.This; }
 		}
 
 		public string Name {
 			get { return name; }
 			set { name = value; }
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Parameter;
 			}
 		}
 
 		public virtual string GetSignatureForError ()
 		{
 			string type_name;
 			if (parameter_type != null)
 				type_name = TypeManager.CSharpName (parameter_type);
 			else
 				type_name = texpr.GetSignatureForError ();
 
 			string mod = GetModifierSignature (modFlags);
 			if (mod.Length > 0)
 				return String.Concat (mod, " ", type_name);
 
 			return type_name;
 		}
 
 		public static string GetModifierSignature (Modifier mod)
 		{
 			switch (mod) {
 			case Modifier.OUT
 				return "out";
 			case Modifier.PARAMS
 				return "params";
 			case Modifier.REF
 				return "ref";
 			case Modifier.This
 				return "this";
 			default
 				return "";
 			}
 		}
 
 		public void IsClsCompliant (IMemberContext ctx)
 		{
 			if (parameter_type.IsCLSCompliant ())
 				return;
 
 			ctx.Compiler.Report.Warning (3001, 1, Location,
 				"Argument type `{0}' is not CLS-compliant", parameter_type.GetSignatureForError ());
 		}
 
 		public virtual void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			if (builder != null)
 				throw new InternalErrorException ("builder already exists");
 
 			var pattrs = ParametersCompiled.GetParameterAttribute (modFlags);
 			if (HasOptionalExpression)
 				pattrs |= ParameterAttributes.Optional;
 
 			if (mb == null)
 				builder = cb.DefineParameter (index, pattrs, Name);
 			else
 				builder = mb.DefineParameter (index, pattrs, Name);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (HasDefaultValue) {
 				//
 				// Emit constant values for true constants only, the other
 				// constant-like expressions will rely on default value expression
 				//
 				var def_value = DefaultValue;
 				Constant c = def_value != null ? def_value.Child as Constant 
 				if (c != null) {
 					if (default_expr.Type == TypeManager.decimal_type) {
 						pa.DecimalConstant.EmitAttribute (builder, (decimal) c.GetValue (), c.Location);
 					} else {
 						builder.SetConstant (c.GetValue ());
 					}
 				} else if (default_expr.Type.IsStruct) {
 					//
 					// Handles special case where default expression is used with value-type
 					//
 					// void Foo (S s = default (S)) {}
 					//
 					builder.SetConstant (null);
 				}
 			}
 
 			if (parameter_type != null) {
 				if (parameter_type == InternalType.Dynamic) {
 					pa.Dynamic.EmitAttribute (builder);
 				} else if (parameter_type.HasDynamicElement) {
 					pa.Dynamic.EmitAttribute (builder, parameter_type, Location);
 				}
 			}
 		}
 
 		public Parameter Clone ()
 		{
 			Parameter p = (Parameter) MemberwiseClone ();
 			if (attributes != null)
 				p.attributes = attributes.Clone ();
 
 			return p;
 		}
 
 		public ExpressionStatement CreateExpressionTreeVariable (BlockContext ec)
 		{
 			if ((modFlags & Modifier.ISBYREF) != 0)
 				ec.Report.Error (1951, Location, "An expression tree parameter cannot use `ref' or `out' modifier");
 
 			expr_tree_variable = TemporaryVariableReference.Create (ResolveParameterExpressionType (ec, Location).Type, ec.CurrentBlock.ParametersBlock, Location);
 			expr_tree_variable = (TemporaryVariableReference) expr_tree_variable.Resolve (ec);
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (new TypeOf (
 				new TypeExpression (parameter_type, Location), Location)));
 			arguments.Add (new Argument (new StringConstant (Name, Location)));
 			return new SimpleAssign (ExpressionTreeVariableReference (),
 				Expression.CreateExpressionFactoryCall (ec, "Parameter", null, arguments, Location));
 		}
 
 		public void Emit (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			ParameterReference.EmitLdArg (ec, arg_idx);
 		}
 
 		public void EmitAssign (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			if (arg_idx <= 255)
 				ec.Emit (OpCodes.Starg_S, (byte) arg_idx);
 			else
 				ec.Emit (OpCodes.Starg, arg_idx);
 		}
 
 		public void EmitAddressOf (EmitContext ec)
 		{
 			int arg_idx = idx;
 
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			bool is_ref = (ModFlags & Modifier.ISBYREF) != 0;
 			if (is_ref) {
 				ParameterReference.EmitLdArg (ec, arg_idx);
 			} else {
 				if (arg_idx <= 255)
 					ec.Emit (OpCodes.Ldarga_S, (byte) arg_idx);
 				else
 					ec.Emit (OpCodes.Ldarga, arg_idx);
 			}
 		}
 
 		public TemporaryVariableReference ExpressionTreeVariableReference ()
 		{
 			return expr_tree_variable;
 		}
 
 		//
 		// System.Linq.Expressions.ParameterExpression type
 		//
 		public static TypeExpr ResolveParameterExpressionType (IMemberContext ec, Location location)
 		{
 			if (parameter_expr_tree_type != null)
 				return parameter_expr_tree_type;
 
 			TypeSpec p_type = ec.Module.PredefinedTypes.ParameterExpression.Resolve (location);
 			parameter_expr_tree_type = new TypeExpression (p_type, location).
 				ResolveAsTypeTerminal (ec, false);
 
 			return parameter_expr_tree_type;
 		}
 
 		public void Warning_UselessOptionalParameter (Report Report)
 		{
 			Report.Warning (1066, 1, Location,
 				"The default value specified for optional parameter `{0}' will never be used",
 				Name);
 		}
 	}
 
 	//
 	// Imported or resolved parameter information
 	//
 	public class ParameterData 
 	{
 		readonly string name;
 		readonly Parameter.Modifier modifiers;
 		readonly Expression default_value;
 
 		public ParameterData (string name, Parameter.Modifier modifiers)
 		{
 			this.name = name;
 			this.modifiers = modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4628" endline="4642">
<![CDATA[
 	}
 
 	public class Catch 
 	{
 		Block block;
 		LocalVariable li;
 		FullNamedExpression type_expr;
 		CompilerAssign assign;
 		TypeSpec type;
 		
 		public Catch (Block block, Location loc)
 		{
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1042" endline="1051">
<![CDATA[
 	}
 	
 	public class Throw 
 		Expression expr;
 		
 		public Throw (Expression expr, Location l)
 		{
 			this.expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5892" endline="5909">
<![CDATA[
 	}
 
 	//
 	// Array initializer expression, the expression is allowed in
 	// variable or field initialization only which makes it tricky as
 	// the type has to be infered based on the context either from field
 	// type or variable type (think of multiple declarators)
 	//
 	public class ArrayInitializer 
 	{
 		List<Expression> elements;
 		BlockVariableDeclaration variable;
 
 		public ArrayInitializer (List<Expression> init, Location loc)
 		{
 			elements = init;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1122" endline="1248">
<![CDATA[
 
 			public AttributeUsageAttribute AttributeUsage;
 			public ObsoleteAttribute Obsolete;
 			public string[] Conditionals;
 			public string DefaultIndexerName;
 			public bool IsNotCLSCompliant;
 			public TypeSpec CoClass;
 			
 			public static AttributesBag Read (MemberInfo mi, MetadataImporter importer)
 			{
 				AttributesBag bag = null;
 				List<string> conditionals = null;
 
 				// It should not throw any loading exception
 				IList<CustomAttributeData> attrs = CustomAttributeData.GetCustomAttributes (mi);
 
 				string ns, name;
 				foreach (var a in attrs) {
 					importer.GetCustomAttributeTypeName (a, out ns, out name);
 					if (name == "ObsoleteAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						var args = a.ConstructorArguments;
 
 						if (args.Count == 1) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value);
 						} else if (args.Count == 2) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value, (bool) args[1].Value);
 						} else {
 							bag.Obsolete = new ObsoleteAttribute ();
 						}
 
 						continue;
 					}
 
 					if (name == "ConditionalAttribute") {
 						if (ns != "System.Diagnostics")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						if (conditionals == null)
 							conditionals = new List<string> (2);
 
 						conditionals.Add ((string) a.ConstructorArguments[0].Value);
 						continue;
 					}
 
 					if (name == "CLSCompliantAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						bag.IsNotCLSCompliant = !(bool) a.ConstructorArguments[0].Value;
 						continue;
 					}
 
 					// Type only attributes
 					if (mi.MemberType == MemberTypes.TypeInfo || mi.MemberType == MemberTypes.NestedType) {
 						if (name == "DefaultMemberAttribute") {
 							if (ns != "System.Reflection")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.DefaultIndexerName = (string) a.ConstructorArguments[0].Value;
 							continue;
 						}
 
 						if (name == "AttributeUsageAttribute") {
 							if (ns != "System")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.AttributeUsage = new AttributeUsageAttribute ((AttributeTargets) a.ConstructorArguments[0].Value);
 							foreach (var named in a.NamedArguments) {
 								if (named.MemberInfo.Name == "AllowMultiple")
 									bag.AttributeUsage.AllowMultiple = (bool) named.TypedValue.Value;
 								else if (named.MemberInfo.Name == "Inherited")
 									bag.AttributeUsage.Inherited = (bool) named.TypedValue.Value;
 							}
 							continue;
 						}
 
 						// Interface only attribute
 						if (name == "CoClassAttribute") {
 							if (ns != "System.Runtime.InteropServices")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.CoClass = importer.ImportType ((MetaType) a.ConstructorArguments[0].Value);
 							continue;
 						}
 					}
 				}
 
 				if (bag == null)
 					return Default;
 
 				if (conditionals != null)
 					bag.Conditionals = conditionals.ToArray ();
 				
 				return bag;
 			}
 		}
 
 		protected readonly MemberInfo provider;
 		protected AttributesBag cattrs;
 		protected readonly MetadataImporter importer;
 
 		public ImportedDefinition (MemberInfo provider, MetadataImporter importer)
 		{
 			this.provider = provider;
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="786" endline="1264">
<![CDATA[
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
 
 		protected Method (DeclSpace parent, FullNamedExpression return_type, Modifiers mod, Modifiers amod,
 					MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		public override TypeParameter[] CurrentTypeParameters {
 			get {
 				if (GenericMethod != null)
 					return GenericMethod.CurrentTypeParameters;
 
 				return null;
 			}
 		}
 
 		public override bool HasUnresolvedConstraints {
 			get {
 				if (CurrentTypeParameters == null)
 					return false;
 
 				// When overriding base method constraints are fetched from
 				// base method but to find it we have to resolve parameters
 				// to find exact base method match
 				if (IsExplicitImpl || (ModFlags & Modifiers.OVERRIDE) != 0)
 					return base_method == null;
 
 				// Even for non-override generic method constraints check has to be
 				// delayed after all constraints are resolved
 				return true;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				// TODO
 				return CurrentTypeParameters.Select (l => l.Type).ToArray ();
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return CurrentTypeParameters == null ? 0 
 			}
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
 
 		void Error_DuplicateEntryPoint (Method b)
 		{
 			Report.Error (17, b.Location,
 				"Program `{0}' has more than one entry point defined
 				b.Module.Builder.ScopeName, b.GetSignatureForError ());
 		}
 
 		bool IsEntryPoint ()
 		{
 			if (ReturnType != TypeManager.void_type &&
 				ReturnType != TypeManager.int32_type)
 				return false;
 
 			if (parameters.IsEmpty)
 				return true;
 
 			if (parameters.Count > 1)
 				return false;
 
 			var ac = parameters.Types [0] as ArrayContainer;
 			return ac != null && ac.Rank == 1 && ac.Element == TypeManager.string_type &&
 					(parameters[0].ModFlags & ~Parameter.Modifier.PARAMS) == Parameter.Modifier.NONE;
 		}
 
 		public override FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			if (arity == 0) {
 				TypeParameter[] tp = CurrentTypeParameters;
 				if (tp != null) {
 					TypeParameter t = TypeParameter.FindTypeParameter (tp, name);
 					if (t != null)
 						return new TypeParameterExpr (t, loc);
 				}
 			}
 
 			return base.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				if (IsExplicitImpl) {
 					Error_ConditionalAttributeIsNotValid ();
 					return;
 				}
 
 				if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 					Report.Error (243, Location, "Conditional not valid on `{0}' because it is an override method", GetSignatureForError ());
 					return;
 				}
 
 				if (ReturnType != TypeManager.void_type) {
 					Report.Error (578, Location, "Conditional not valid on `{0}' because its return type is not void", GetSignatureForError ());
 					return;
 				}
 
 				if (IsInterface) {
 					Report.Error (582, Location, "Conditional not valid on interface members");
 					return;
 				}
 
 				if (MethodData.implementing != null) {
 					Report.SymbolRelatedToPreviousError (MethodData.implementing.DeclaringType);
 					Report.Error (629, Location, "Conditional member `{0}' cannot implement interface member `{1}'",
 						GetSignatureForError (), TypeManager.CSharpSignature (MethodData.implementing));
 					return;
 				}
 
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		protected virtual void DefineTypeParameters ()
 		{
 			var tparams = CurrentTypeParameters;
 
 			TypeParameterSpec[] base_tparams = null;
 			TypeParameterSpec[] base_decl_tparams = TypeParameterSpec.EmptyTypes;
 			TypeSpec[] base_targs = TypeSpec.EmptyTypes;
 			if (((ModFlags & Modifiers.OVERRIDE) != 0 || IsExplicitImpl)) {
 				if (base_method != null) {
 					base_tparams = base_method.GenericDefinition.TypeParameters;
 				
 					if (base_method.DeclaringType.IsGeneric) {
 						base_decl_tparams = base_method.DeclaringType.MemberDefinition.TypeParameters;
 
 						var base_type_parent = CurrentType;
 						while (base_type_parent.BaseType != base_method.DeclaringType) {
 							base_type_parent = base_type_parent.BaseType;
 						}
 
 						base_targs = base_type_parent.BaseType.TypeArguments;
 					}
 
 					if (base_method.IsGeneric) {
 						ObsoleteAttribute oa;
 						foreach (var base_tp in base_tparams) {
 							oa = base_tp.BaseType.GetAttributeObsolete ();
 							if (oa != null) {
 								AttributeTester.Report_ObsoleteMessage (oa, base_tp.BaseType.GetSignatureForError (), Location, Report);
 							}
 
 							if (base_tp.InterfacesDefined != null) {
 								foreach (var iface in base_tp.InterfacesDefined) {
 									oa = iface.GetAttributeObsolete ();
 									if (oa != null) {
 										AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 									}
 								}
 							}
 						}
 
 						if (base_decl_tparams.Length != 0) {
 							base_decl_tparams = base_decl_tparams.Concat (base_tparams).ToArray ();
 							base_targs = base_targs.Concat (tparams.Select<TypeParameter, TypeSpec> (l => l.Type)).ToArray ();
 						} else {
 							base_decl_tparams = base_tparams;
 							base_targs = tparams.Select (l => l.Type).ToArray ();
 						}
 					}
 				} else if (MethodData.implementing != null) {
 					base_tparams = MethodData.implementing.GenericDefinition.TypeParameters;
 					if (MethodData.implementing.DeclaringType.IsGeneric) {
 						base_decl_tparams = MethodData.implementing.DeclaringType.MemberDefinition.TypeParameters;
 						foreach (var iface in Parent.CurrentType.Interfaces) {
 							if (iface == MethodData.implementing.DeclaringType) {
 								base_targs = iface.TypeArguments;
 								break;
 							}
 						}
 					}
 				}
 			}
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 
 				if (!tp.ResolveConstraints (this))
 					continue;
 
 				//
 				// Copy base constraints for override/explicit methods
 				//
 				if (base_tparams != null) {
 					var base_tparam = base_tparams[i];
 					var local_tparam = tp.Type;
 					local_tparam.SpecialConstraint = base_tparam.SpecialConstraint;
 
 					var inflator = new TypeParameterInflator (CurrentType, base_decl_tparams, base_targs);
 					base_tparam.InflateConstraints (inflator, local_tparam);
 
 					//
 					// Check all type argument constraints for possible collision
 					// introduced by inflating inherited constraints in this context
 					//
 					// Conflict example
 					//
 					// class A<T> { virtual void Foo<U> () where U 
 					// class B 
 					//
 					var local_tparam_targs = local_tparam.TypeArguments;
 					if (local_tparam_targs != null) {					
 						for (int ii = 0; ii < local_tparam_targs.Length; ++ii) {
 							var ta = local_tparam_targs [ii];
 							if (!ta.IsClass && !ta.IsStruct)
 								continue;
 
 							if (Constraints.CheckConflictingInheritedConstraint (local_tparam, ta, this, Location)) {
 								local_tparam.ChangeTypeArgumentToBaseType (ii);
 							}
 						}
 					}
 
 					continue;
 				}
 				
 				if (MethodData.implementing != null) {
 					var base_tp = MethodData.implementing.Constraints[i];
 					if (!tp.Type.HasSameConstraintsImplementation (base_tp)) {
 						Report.SymbolRelatedToPreviousError (MethodData.implementing);
 						Report.Error (425, Location,
 							"The constraints for type parameter `{0}' of method `{1}' must match the constraints for type parameter `{2}' of interface method `{3}'. Consider using an explicit interface implementation instead",
 							tp.GetSignatureForError (), GetSignatureForError (), base_tp.GetSignatureForError (), MethodData.implementing.GetSignatureForError ());
 					}
 				}
 			}
 		}
 
 		//
 		// Creates the type
 		//
 		public override bool Define ()
 		{
 			if (type_expr.Type == TypeManager.void_type && parameters.IsEmpty && MemberName.Arity == 0 && MemberName.Name == Destructor.MetadataName) {
 				Report.Warning (465, 1, Location, "Introducing `Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?");
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (partialMethodImplementation != null && IsPartialDefinition)
 				MethodBuilder = partialMethodImplementation.MethodBuilder;
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ReturnType)) {
 				Error1599 (Location, ReturnType, Report);
 				return false;
 			}
 
 			if (CurrentTypeParameters == null) {
 				if (base_method != null) {
 					if (parameters.Count == 1 && ParameterTypes[0] == TypeManager.object_type && Name == "Equals")
 						Parent.PartialContainer.Mark_HasEquals ();
 					else if (parameters.IsEmpty && Name == "GetHashCode")
 						Parent.PartialContainer.Mark_HasGetHashCode ();
 				}
 					
 			} else {
 				DefineTypeParameters ();
 			}
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			if ((ModFlags & Modifiers.STATIC) == 0)
 				return true;
 
 			if (parameters.HasExtensionMethodType) {
 				if (Parent.PartialContainer.IsStatic && !Parent.IsGeneric) {
 					if (!Parent.IsTopLevel)
 						Report.Error (1109, Location, "`{0}'
 							GetSignatureForError ());
 
 					PredefinedAttribute pa = Module.PredefinedAttributes.Extension;
 					if (!pa.IsDefined) {
 						Report.Error (1110, Location,
 							"`{0}'
 							GetSignatureForError ());
 					}
 
 					ModFlags |= Modifiers.METHOD_EXTENSION;
 					Parent.PartialContainer.ModFlags |= Modifiers.METHOD_EXTENSION;
 					Spec.DeclaringType.SetExtensionMethodContainer ();
 					Parent.Module.HasExtensionMethod = true;
 				} else {
 					Report.Error (1106, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 
 			//
 			// This is used to track the Entry Point,
 			//
 			if (RootContext.NeedsEntryPoint &&
 				Name == "Main" &&
 				(RootContext.MainClass == null ||
 				RootContext.MainClass == Parent.TypeBuilder.FullName)){
 				if (IsEntryPoint ()) {
 
 					if (Parent.DeclaringAssembly.EntryPoint == null) {
 						if (Parent.IsGeneric || MemberName.IsGeneric) {
 							Report.Warning (402, 4, Location, "`{0}'
 								GetSignatureForError ());
 						} else {
 							SetIsUsed ();
 							Parent.DeclaringAssembly.EntryPoint = this;
 						}
 					} else {
 						Error_DuplicateEntryPoint (Parent.DeclaringAssembly.EntryPoint);
 						Error_DuplicateEntryPoint (this);
 					}
 				} else {
 					Report.Warning (28, 4, Location, "`{0}' has the wrong signature to be an entry point",
 						GetSignatureForError ());
 				}
 			}
 
 			return true;
 		}
 
 		//
 		// Emits the code
 		// 
 		public override void Emit ()
 		{
 			try {
 				if (IsPartialDefinition) {
 					//
 					// Use partial method implementation builder for partial method declaration attributes
 					//
 					if (partialMethodImplementation != null) {
 						MethodBuilder = partialMethodImplementation.MethodBuilder;
 					}
 
 					return;
 				}
 				
 				if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.PartialDefinitionExists) == 0) {
 					Report.Error (759, Location, "A partial method `{0}' implementation is missing a partial method declaration",
 						GetSignatureForError ());
 				}
 
 				if (CurrentTypeParameters != null) {
 					var ge = type_expr as GenericTypeExpr;
 					if (ge != null)
 						ge.CheckConstraints (this);
 
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 				}
 
 				base.Emit ();
 				
 				if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 					Module.PredefinedAttributes.Extension.EmitAttribute (MethodBuilder);
 			} catch {
 				Console.WriteLine ("Internal compiler error at {0}
 						   Location, MethodBuilder);
 				throw;
 			}
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			// TODO
 			if (overload is Operator)
 				return overload.EnableOverloadChecks (this);
 
 			if (overload is Indexer)
 				return false;
 
 			return base.EnableOverloadChecks (overload);
 		}
 
 		public static void Error1599 (Location loc, TypeSpec t, Report Report)
 		{
 			Report.Error (1599, loc, "Method or delegate cannot return type `{0}'", TypeManager.CSharpName (t));
 		}
 
 		protected override bool ResolveMemberType ()
 		{
 			if (GenericMethod != null) {
 				MethodBuilder = Parent.TypeBuilder.DefineMethod (GetFullName (MemberName), flags);
 				if (!GenericMethod.Define (this))
 					return false;
 			}
 
 			return base.ResolveMemberType ();
 		}
 
 		public void SetPartialDefinition (Method methodDefinition)
 		{
 			caching_flags |= Flags.PartialDefinitionExists;
 			methodDefinition.partialMethodImplementation = this;
 
 			// Ensure we are always using method declaration parameters
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 
 			if (methodDefinition.attributes == null)
 				return;
 
 			if (attributes == null) {
 				attributes = methodDefinition.attributes;
 			} else {
 				attributes.Attrs.AddRange (methodDefinition.attributes.Attrs);
 			}
 		}
 	}
 
 	public abstract class ConstructorInitializer 
 	{
 		Arguments argument_list;
 		MethodSpec base_ctor;
 
 		public ConstructorInitializer (Arguments argument_list, Location loc)
 		{
 			this.argument_list = argument_list;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="106" endline="790">
<![CDATA[
 	}
 	
 	//
 	//   Unary implements unary expressions.
 	//
 	public class Unary 
 	{
 		public enum Operator 
 			UnaryPlus, UnaryNegation, LogicalNot, OnesComplement,
 			AddressOf,  TOP
 		}
 
 		static TypeSpec[][] predefined_operators;
 
 		public readonly Operator Oper;
 		public Expression Expr;
 		Expression enum_conversion;
 
 		public Unary (Operator op, Expression expr, Location loc)
 		{
 			Oper = op;
 			Expr = expr;
 			this.loc = loc;
 		}
 
 		// <summary>
 		//   This routine will attempt to simplify the unary expression when the
 		//   argument is a constant.
 		// </summary>
 		Constant TryReduceConstant (ResolveContext ec, Constant e)
 		{
 			if (e is EmptyConstantCast)
 				return TryReduceConstant (ec, ((EmptyConstantCast) e).child);
 			
 			if (e is SideEffectConstant) {
 				Constant r = TryReduceConstant (ec, ((SideEffectConstant) e).value);
 				return r == null ? null 
 			}
 
 			TypeSpec expr_type = e.Type;
 			
 			switch (Oper){
 			case Operator.UnaryPlus
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type || expr_type == TypeManager.uint32_type ||
 				    expr_type == TypeManager.int64_type || expr_type == TypeManager.uint64_type ||
 				    expr_type == TypeManager.float_type || expr_type == TypeManager.double_type ||
 				    expr_type == TypeManager.decimal_type) {
 					return e;
 				}
 				
 				return null;
 				
 			case Operator.UnaryNegation
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (-((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (-((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (-((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (-((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (-((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type) {
 					int value = ((IntConstant)e).Value;
 					if (value == int.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new IntConstant (-value, e.Location);
 				}
 				if (expr_type == TypeManager.int64_type) {
 					long value = ((LongConstant)e).Value;
 					if (value == long.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new LongConstant (-value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint32_type) {
 					UIntLiteral uil = e as UIntLiteral;
 					if (uil != null) {
 						if (uil.Value == int.MaxValue + (uint) 1)
 							return new IntLiteral (int.MinValue, e.Location);
 						return new LongLiteral (-uil.Value, e.Location);
 					}
 					return new LongConstant (-((UIntConstant)e).Value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint64_type) {
 					ULongLiteral ull = e as ULongLiteral;
 					if (ull != null && ull.Value == 9223372036854775808)
 						return new LongLiteral (long.MinValue, e.Location);
 					return null;
 				}
 				
 				if (expr_type == TypeManager.float_type) {
 					FloatLiteral fl = e as FloatLiteral;
 					// For better error reporting
 					if (fl != null)
 						return new FloatLiteral (-fl.Value, e.Location);
 
 					return new FloatConstant (-((FloatConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.double_type) {
 					DoubleLiteral dl = e as DoubleLiteral;
 					// For better error reporting
 					if (dl != null)
 						return new DoubleLiteral (-dl.Value, e.Location);
 
 					return new DoubleConstant (-((DoubleConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.decimal_type)
 					return new DecimalConstant (-((DecimalConstant)e).Value, e.Location);
 				
 				return null;
 				
 			case Operator.LogicalNot
 				if (expr_type != TypeManager.bool_type)
 					return null;
 				
 				bool b = (bool)e.GetValue ();
 				return new BoolConstant (!b, e.Location);
 				
 			case Operator.OnesComplement
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (~((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (~((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (~((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (~((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (~((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type)
 					return new IntConstant (~((IntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint32_type)
 					return new UIntConstant (~((UIntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.int64_type)
 					return new LongConstant (~((LongConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint64_type){
 					return new ULongConstant (~((ULongConstant)e).Value, e.Location);
 				}
 				if (e is EnumConstant) {
 					e = TryReduceConstant (ec, ((EnumConstant)e).Child);
 					if (e != null)
 						e = new EnumConstant (e, expr_type);
 					return e;
 				}
 				return null;
 			}
 			throw new Exception ("Can not constant fold
 		}
 		
 		protected virtual Expression ResolveOperator (ResolveContext ec, Expression expr)
 		{
 			eclass = ExprClass.Value;
 
 			if (predefined_operators == null)
 				CreatePredefinedOperatorsTable ();
 
 			TypeSpec expr_type = expr.Type;
 			Expression best_expr;
 
 			//
 			// Primitive types first
 			//
 			if (TypeManager.IsPrimitiveType (expr_type)) {
 				best_expr = ResolvePrimitivePredefinedType (expr);
 				if (best_expr == null)
 					return null;
 
 				type = best_expr.Type;
 				Expr = best_expr;
 				return this;
 			}
 
 			//
 			// E operator ~(E x);
 			//
 			if (Oper == Operator.OnesComplement && TypeManager.IsEnumType (expr_type))
 				return ResolveEnumOperator (ec, expr);
 
 			return ResolveUserType (ec, expr);
 		}
 
 		protected virtual Expression ResolveEnumOperator (ResolveContext ec, Expression expr)
 		{
 			TypeSpec underlying_type = EnumSpec.GetUnderlyingType (expr.Type);
 			Expression best_expr = ResolvePrimitivePredefinedType (EmptyCast.Create (expr, underlying_type));
 			if (best_expr == null)
 				return null;
 
 			Expr = best_expr;
 			enum_conversion = Convert.ExplicitNumericConversion (new EmptyExpression (best_expr.Type), underlying_type);
 			type = expr.Type;
 			return EmptyCast.Create (this, type);
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return CreateExpressionTree (ec, null);
 		}
 
 		Expression CreateExpressionTree (ResolveContext ec, Expression user_op)
 		{
 			string method_name;
 			switch (Oper) {
 			case Operator.AddressOf
 				Error_PointerInsideExpressionTree (ec);
 				return null;
 			case Operator.UnaryNegation
 				if (ec.HasSet (ResolveContext.Options.CheckedScope) && user_op == null && !IsFloat (type))
 					method_name = "NegateChecked";
 				else
 					method_name = "Negate";
 				break;
 			case Operator.OnesComplement
 			case Operator.LogicalNot
 				method_name = "Not";
 				break;
 			case Operator.UnaryPlus
 				method_name = "UnaryPlus";
 				break;
 			default
 				throw new InternalErrorException ("Unknown unary operator " + Oper.ToString ());
 			}
 
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (Expr.CreateExpressionTree (ec)));
 			if (user_op != null)
 				args.Add (new Argument (user_op));
 
 			return CreateExpressionFactoryCall (ec, method_name, args);
 		}
 
 		static void CreatePredefinedOperatorsTable ()
 		{
 			predefined_operators = new TypeSpec [(int) Operator.TOP] [];
 
 			//
 			// 7.6.1 Unary plus operator
 			//
 			predefined_operators [(int) Operator.UnaryPlus] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.2 Unary minus operator
 			//
 			predefined_operators [(int) Operator.UnaryNegation] = new TypeSpec [] {
 				TypeManager.int32_type, 
 				TypeManager.int64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.3 Logical negation operator
 			//
 			predefined_operators [(int) Operator.LogicalNot] = new TypeSpec [] {
 				TypeManager.bool_type
 			};
 
 			//
 			// 7.6.4 Bitwise complement operator
 			//
 			predefined_operators [(int) Operator.OnesComplement] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type
 			};
 		}
 
 		//
 		// Unary numeric promotions
 		//
 		static Expression DoNumericPromotion (Operator op, Expression expr)
 		{
 			TypeSpec expr_type = expr.Type;
 			if ((op == Operator.UnaryPlus || op == Operator.UnaryNegation || op == Operator.OnesComplement) &&
 				expr_type == TypeManager.byte_type || expr_type == TypeManager.sbyte_type ||
 				expr_type == TypeManager.short_type || expr_type == TypeManager.ushort_type ||
 				expr_type == TypeManager.char_type)
 				return Convert.ImplicitNumericConversion (expr, TypeManager.int32_type);
 
 			if (op == Operator.UnaryNegation && expr_type == TypeManager.uint32_type)
 				return Convert.ImplicitNumericConversion (expr, TypeManager.int64_type);
 
 			return expr;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (Oper == Operator.AddressOf) {
 				return ResolveAddressOf (ec);
 			}
 
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			if (Expr.Type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (Expr));
 				return new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (Expr.Type))
 				return new Nullable.LiftedUnaryOperator (Oper, Expr, loc).Resolve (ec);
 
 			//
 			// Attempt to use a constant folding operation.
 			//
 			Constant cexpr = Expr as Constant;
 			if (cexpr != null) {
 				cexpr = TryReduceConstant (ec, cexpr);
 				if (cexpr != null)
 					return cexpr.Resolve (ec);
 			}
 
 			Expression expr = ResolveOperator (ec, Expr);
 			if (expr == null)
 				Error_OperatorCannotBeApplied (ec, loc, OperName (Oper), Expr.Type);
 			
 			//
 			// Reduce unary operator on predefined types
 			//
 			if (expr == this && Oper == Operator.UnaryPlus)
 				return Expr;
 
 			return expr;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right)
 		{
 			return null;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			EmitOperator (ec, type);
 		}
 
 		protected void EmitOperator (EmitContext ec, TypeSpec type)
 		{
 			switch (Oper) {
 			case Operator.UnaryPlus
 				Expr.Emit (ec);
 				break;
 				
 			case Operator.UnaryNegation
 				if (ec.HasSet (EmitContext.Options.CheckedScope) && !IsFloat (type)) {
 					ec.Emit (OpCodes.Ldc_I4_0);
 					if (type == TypeManager.int64_type)
 						ec.Emit (OpCodes.Conv_U8);
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Sub_Ovf);
 				} else {
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 				}
 				
 				break;
 				
 			case Operator.LogicalNot
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				ec.Emit (OpCodes.Ceq);
 				break;
 				
 			case Operator.OnesComplement
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Not);
 				break;
 				
 			case Operator.AddressOf
 				((IMemoryLocation)Expr).AddressOf (ec, AddressOp.LoadStore);
 				break;
 				
 			default
 				throw new Exception ("This should not happen
 						     + Oper.ToString ());
 			}
 
 			//
 			// Same trick as in Binary expression
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
 
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			if (Oper == Operator.LogicalNot)
 				Expr.EmitBranchable (ec, target, !on_true);
 			else
 				base.EmitBranchable (ec, target, on_true);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			Expr.EmitSideEffect (ec);
 		}
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Location loc, string oper, TypeSpec t)
 		{
 			ec.Report.Error (23, loc, "The `{0}' operator cannot be applied to operand of type `{1}'",
 				oper, TypeManager.CSharpName (t));
 		}
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (Oper) {
 			case Operator.OnesComplement
 				return "OnesComplement";
 			case Operator.LogicalNot
 				return "Not";
 			case Operator.UnaryNegation
 				return "Negate";
 			case Operator.UnaryPlus
 				return "UnaryPlus";
 			default
 				throw new NotImplementedException ("Unknown express type operator " + Oper.ToString ());
 			}
 		}
 
 		static bool IsFloat (TypeSpec t)
 		{
 			return t == TypeManager.float_type || t == TypeManager.double_type;
 		}
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			var expr = Expr.MakeExpression (ctx);
 			bool is_checked = ctx.HasSet (BuilderContext.Options.CheckedScope);
 
 			switch (Oper) {
 			case Operator.UnaryNegation
 				return is_checked ? SLE.Expression.NegateChecked (expr) 
 			case Operator.LogicalNot
 				return SLE.Expression.Not (expr);
 #if NET_4_0
 			case Operator.OnesComplement
 				return SLE.Expression.OnesComplement (expr);
 #endif
 			default
 				throw new NotImplementedException (Oper.ToString ());
 			}
 		}
 
 		public static void Reset ()
 		{
 			predefined_operators = null;
 		}
 
 		Expression ResolveAddressOf (ResolveContext ec)
 		{
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			Expr = Expr.DoResolveLValue (ec, EmptyExpression.UnaryAddress);
 			if (Expr == null || Expr.eclass != ExprClass.Variable) {
 				ec.Report.Error (211, loc, "Cannot take the address of the given expression");
 				return null;
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, Expr.Type, loc)) {
 				return null;
 			}
 
 			IVariableReference vr = Expr as IVariableReference;
 			bool is_fixed;
 			if (vr != null) {
 				VariableInfo vi = vr.VariableInfo;
 				if (vi != null) {
 					if (vi.LocalInfo != null)
 						vi.LocalInfo.SetIsUsed ();
 
 					//
 					// A variable is considered definitely assigned if you take its address.
 					//
 					vi.SetAssigned (ec);
 				}
 
 				is_fixed = vr.IsFixed;
 				vr.SetHasAddressTaken ();
 
 				if (vr.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, vr, loc);
 				}
 			} else {
 				IFixedExpression fe = Expr as IFixedExpression;
 				is_fixed = fe != null && fe.IsFixed;
 			}
 
 			if (!is_fixed && !ec.HasSet (ResolveContext.Options.FixedInitializerScope)) {
 				ec.Report.Error (212, loc, "You can only take the address of unfixed expression inside of a fixed statement initializer");
 			}
 
 			type = PointerContainer.MakeType (Expr.Type);
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		Expression ResolvePrimitivePredefinedType (Expression expr)
 		{
 			expr = DoNumericPromotion (Oper, expr);
 			TypeSpec expr_type = expr.Type;
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				if (t == expr_type)
 					return expr;
 			}
 			return null;
 		}
 
 		//
 		// Perform user-operator overload resolution
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression expr)
 		{
 			CSharp.Operator.OpType op_type;
 			switch (Oper) {
 			case Operator.LogicalNot
 				op_type = CSharp.Operator.OpType.LogicalNot; break;
 			case Operator.OnesComplement
 				op_type = CSharp.Operator.OpType.OnesComplement; break;
 			case Operator.UnaryNegation
 				op_type = CSharp.Operator.OpType.UnaryNegation; break;
 			case Operator.UnaryPlus
 				op_type = CSharp.Operator.OpType.UnaryPlus; break;
 			default
 				throw new InternalErrorException (Oper.ToString ());
 			}
 
 			var methods = MemberCache.GetUserOperator (expr.Type, op_type, false);
 			if (methods == null)
 				return null;
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (expr));
 
 			var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var oper = res.ResolveOperator (ec, ref args);
 
 			if (oper == null)
 				return null;
 
 			Expr = args [0].Expr;
 			return new UserOperatorCall (oper, args, CreateExpressionTree, expr.Location);
 		}
 
 		//
 		// Unary user type overload resolution
 		//
 		Expression ResolveUserType (ResolveContext ec, Expression expr)
 		{
 			Expression best_expr = ResolveUserOperator (ec, expr);
 			if (best_expr != null)
 				return best_expr;
 
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				Expression oper_expr = Convert.ImplicitUserConversion (ec, expr, t, expr.Location);
 				if (oper_expr == null)
 					continue;
 
 				//
 				// decimal type is predefined but has user-operators
 				//
 				if (oper_expr.Type == TypeManager.decimal_type)
 					oper_expr = ResolveUserType (ec, oper_expr);
 				else
 					oper_expr = ResolvePrimitivePredefinedType (oper_expr);
 
 				if (oper_expr == null)
 					continue;
 
 				if (best_expr == null) {
 					best_expr = oper_expr;
 					continue;
 				}
 
 				int result = OverloadResolver.BetterTypeConversion (ec, best_expr.Type, t);
 				if (result == 0) {
 					ec.Report.Error (35, loc, "Operator `{0}' is ambiguous on an operand of type `{1}'",
 						OperName (Oper), TypeManager.CSharpName (expr.Type));
 					break;
 				}
 
 				if (result == 2)
 					best_expr = oper_expr;
 			}
 			
 			if (best_expr == null)
 				return null;
 			
 			//
 			// HACK
 			//
 			if (best_expr.Type == TypeManager.decimal_type)
 				return best_expr;			
 
 			Expr = best_expr;
 			type = best_expr.Type;
 			return this;			
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Unary target = (Unary) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
 	}
 
 	//
 	// Unary operators are turned into Indirection expressions
 	// after semantic analysis (this is so we can take the address
 	// of an indirection).
 	//
 	public class Indirection 
 		Expression expr;
 		LocalTemporary temporary;
 		bool prepared;
 		
 		public Indirection (Expression expr, Location l)
 		{
 			this.expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7082" endline="7095">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the typeof operator
 	/// </summary>
 	public class TypeOf 
 		FullNamedExpression QueriedType;
 		TypeSpec typearg;
 
 		public TypeOf (FullNamedExpression queried_type, Location l)
 		{
 			QueriedType = queried_type;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7220" endline="7292">
<![CDATA[
 	}
 
 	class TypeOfMethod 
 	{
 		public TypeOfMethod (MethodSpec method, Location loc)
 			
 		{
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (member.IsConstructor) {
 				type = ec.Module.PredefinedTypes.ConstructorInfo.Resolve (loc);
 			} else {
 				type = ec.Module.PredefinedTypes.MethodInfo.Resolve (loc);
 			}
 
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
 
 		protected override string GetMethodName {
 			get { return "GetMethodFromHandle"; }
 		}
 
 		protected override PredefinedType GetDeclaringType (PredefinedTypes types)
 		{
 			return types.MethodBase;
 		}
 
 		protected override PredefinedType GetRuntimeHandle (PredefinedTypes types)
 		{
 			return types.RuntimeMethodHandle;
 		}
 
 		protected override MethodSpec TypeFromHandle {
 			get {
 				return TypeManager.methodbase_get_type_from_handle;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle = value;
 			}
 		}
 
 		protected override MethodSpec TypeFromHandleGeneric {
 			get {
 				return TypeManager.methodbase_get_type_from_handle_generic;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle_generic = value;
 			}
 		}
 	}
 
 	abstract class TypeOfMember<T> 
 	{
 		protected readonly T member;
 
 		protected TypeOfMember (T member, Location loc)
 		{
 			this.member = member;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8157" endline="8176">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements array access 
 	/// </summary>
 	public class ArrayAccess 
 		//
 		// Points to our "data" repository
 		//
 		ElementAccess ea;
 
 		LocalTemporary temp, expr_copy;
 		Expression[] prepared_arguments;
 		bool prepared;
 		
 		public ArrayAccess (ElementAccess ea_data, Location l)
 		{
 			ea = ea_data;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7402" endline="7416">
<![CDATA[
 		}
 	}
 
 	/// <summary>
 	///   Implements the sizeof expression
 	/// </summary>
 	public class SizeOf 
 		readonly Expression QueriedType;
 		TypeSpec type_queried;
 		
 		public SizeOf (Expression queried_type, Location l)
 		{
 			this.QueriedType = queried_type;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1306" endline="1318">
<![CDATA[
 	}
 
 	public class ImportedModuleDefinition
 	{
 		readonly Module module;
 		bool cls_compliant;
 		readonly MetadataImporter importer;
 		
 		public ImportedModuleDefinition (Module module, MetadataImporter importer)
 		{
 			this.module = module;
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="701" endline="713">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the return statement
 	/// </summary>
 	public class Return 
 	{
 		protected Expression Expr;
 		public Return (Expression expr, Location l)
 		{
 			Expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="523" endline="534">
<![CDATA[
 	}
 
 	sealed class GenericEventInfo 
 	{
 		private readonly Type typeInstance;
 		private readonly EventInfo eventInfo;
 
 		internal GenericEventInfo(Type typeInstance, EventInfo eventInfo)
 		{
 			this.typeInstance = typeInstance;
 			this.eventInfo = eventInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7471" endline="7928">
<![CDATA[
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, TypeArguments targs, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, int arity, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			if (alias == GlobalAlias) {
 				expr = ec.Module.GlobalRootNamespace;
 				return base.ResolveAsTypeStep (ec, silent);
 			}
 
 			int errors = ec.Compiler.Report.Errors;
 			expr = ec.LookupNamespaceAlias (alias);
 			if (expr == null) {
 				if (errors == ec.Compiler.Report.Errors)
 					ec.Compiler.Report.Error (432, loc, "Alias `{0}' not found", alias);
 				return null;
 			}
 
 			FullNamedExpression fne = base.ResolveAsTypeStep (ec, silent);
 			if (fne == null)
 				return null;
 
 			if (expr.eclass == ExprClass.Type) {
 				if (!silent) {
 					ec.Compiler.Report.Error (431, loc,
 						"Alias `{0}' cannot be used with '
 				}
 				return null;
 			}
 
 			return fne;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return ResolveAsTypeStep (ec, false);
 		}
 
 		protected override void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			rc.Compiler.Report.Error (687, loc,
 				"A namespace alias qualifier `{0}' did not resolve to a namespace or a type",
 				GetSignatureForError ());
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name = Name;
 			if (targs != null) {
 				name = Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return alias + "
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			return DoResolve (rc);
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing 
 		}
 	}
 
 	/// <summary>
 	///   Implements the member access expression
 	/// </summary>
 	public class MemberAccess 
 	{
 		protected Expression expr;
 
 		public MemberAccess (Expression expr, string id)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, TypeArguments args, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, int arity, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public Expression LeftExpression {
 			get {
 				return expr;
 			}
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return DoResolveName (ec, null);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			return DoResolveName (ec, right_side);
 		}
 
 		Expression DoResolveName (ResolveContext rc, Expression right_side)
 		{
 			Expression e = LookupNameExpression (rc, right_side == null ? MemberLookupRestrictions.ReadAccess 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 					e.Error_UnexpectedKind (rc, ResolveFlags.VariableOrValue, loc);
 					return null;
 				}
 
 				e = e.ResolveLValue (rc, right_side);
 			} else {
 				e = e.Resolve (rc, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 			}
 
 			return e;
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			var sn = expr as SimpleName;
 			const ResolveFlags flags = ResolveFlags.VariableOrValue | ResolveFlags.Type;
 
 			//
 			// Resolve the expression with flow analysis turned off, we'll do the definite
 			// assignment checks later.  This is because we don't know yet what the expression
 			// will resolve to - it may resolve to a FieldExpr and in this case we must do the
 			// definite assignment check on the actual field and not on the whole struct.
 			//
 			using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 				if (sn != null) {
 					expr = sn.LookupNameExpression (rc, MemberLookupRestrictions.ReadAccess | MemberLookupRestrictions.ExactArity);
 
 					// Call resolve on expression which does have type set as we need expression type
 					// TODO
 					if (expr is VariableReference || expr is ConstantExpr || expr is Linq.TransparentMemberAccess) {
 						using (rc.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 							expr = expr.Resolve (rc);
 						}
 					} else if (expr is TypeParameterExpr) {
 						expr.Error_UnexpectedKind (rc, flags, sn.Location);
 						expr = null;
 					}
 				} else {
 					expr = expr.Resolve (rc, flags);
 				}
 			}
 
 			if (expr == null)
 				return null;
 
 			Namespace ns = expr as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 					return null;
 				}
 
 				if (HasTypeArguments)
 					return new GenericTypeExpr (retval.Type, targs, loc);
 
 				return retval;
 			}
 
 			MemberExpr me;
 			TypeSpec expr_type = expr.Type;
 			if (expr_type == InternalType.Dynamic) {
 				me = expr as MemberExpr;
 				if (me != null)
 					me.ResolveInstanceExpression (rc, null);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new DynamicMemberBinder (Name, args, loc);
 			}
 
 			const MemberKind dot_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.Delegate | MemberKind.Enum |
 				MemberKind.Interface | MemberKind.TypeParameter | MemberKind.ArrayType;
 
 			if ((expr_type.Kind & dot_kinds) == 0 || expr_type == TypeManager.void_type) {
 				if (expr_type == InternalType.Null && rc.Compiler.IsRuntimeBinder)
 					rc.Report.Error (Report.RuntimeErrorId, loc, "Cannot perform member binding on `null' value");
 				else
 					Unary.Error_OperatorCannotBeApplied (rc, loc, ".", expr_type);
 				return null;
 			}
 
 			var current_type = rc.CurrentType;
 			var lookup_arity = Arity;
 			bool errorMode = false;
 			Expression member_lookup;
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 
 			TypeExpr texpr = member_lookup as TypeExpr;
 			if (texpr != null) {
 				if (!(expr is TypeExpr)) {
 					me = expr as MemberExpr;
 					if (me == null || me.ProbeIdenticalTypeName (rc, expr, sn) == expr) {
 						rc.Report.Error (572, loc, "`{0}'
 							Name, member_lookup.GetSignatureForError ());
 						return null;
 					}
 				}
 
 				if (!texpr.Type.IsAccessible (rc.CurrentType)) {
 					rc.Report.SymbolRelatedToPreviousError (member_lookup.Type);
 					ErrorIsInaccesible (rc, member_lookup.Type.GetSignatureForError (), loc);
 					return null;
 				}
 
 				if (HasTypeArguments) {
 					return new GenericTypeExpr (member_lookup.Type, targs, loc);
 				}
 
 				return member_lookup;
 			}
 
 			me = member_lookup as MemberExpr;
 
 			if (sn != null && me.IsStatic)
 				expr = me.ProbeIdenticalTypeName (rc, expr, sn);
 
 			me = me.ResolveMemberAccess (rc, expr, sn);
 
 			if (Arity > 0) {
 				if (!targs.Resolve (rc))
 					return null;
 
 				me.SetTypeArguments (rc, targs);
 			}
 
 			if (sn != null && (!TypeManager.IsValueType (expr_type) || me is PropertyExpr)) {
 				if (me.IsInstance) {
 					LocalVariableReference var = expr as LocalVariableReference;
 					if (var != null && !var.VerifyAssigned (rc))
 						return null;
 				}
 			}
 
 			return me;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			return ResolveNamespaceOrType (ec, silent);
 		}
 
 		public FullNamedExpression ResolveNamespaceOrType (IMemberContext rc, bool silent)
 		{
 			FullNamedExpression expr_resolved = expr.ResolveAsTypeStep (rc, silent);
 
 			if (expr_resolved == null)
 				return null;
 
 			Namespace ns = expr_resolved as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					if (!silent)
 						ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 				} else if (HasTypeArguments) {
 					retval = new GenericTypeExpr (retval.Type, targs, loc).ResolveAsTypeStep (rc, silent);
 				}
 
 				return retval;
 			}
 
 			TypeExpr tnew_expr = expr_resolved.ResolveAsTypeTerminal (rc, false);
 			if (tnew_expr == null)
 				return null;
 
 			TypeSpec expr_type = tnew_expr.Type;
 			if (TypeManager.IsGenericParameter (expr_type)) {
 				rc.Compiler.Report.Error (704, loc, "A nested type cannot be specified through a type parameter `{0}'",
 					tnew_expr.GetSignatureForError ());
 				return null;
 			}
 
 			TypeSpec nested = null;
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			
 			TypeExpr texpr;
 			if (Arity > 0) {
 				if (HasTypeArguments) {
 					texpr = new GenericTypeExpr (nested, targs, loc);
 				} else {
 					texpr = new GenericOpenTypeExpr (nested, loc);
 				}
 			} else {
 				texpr = new TypeExpression (nested, loc);
 			}
 
 			return texpr.ResolveAsTypeStep (rc, false);
 		}
 
 		protected virtual void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			var nested = MemberCache.FindNestedType (expr_type, Name, -System.Math.Max (1, Arity));
 
 			if (nested != null) {
 				Error_TypeArgumentsCannotBeUsed (rc.Compiler.Report, expr.Location, nested, Arity);
 				return;
 			}
 
 			var any_other_member = MemberLookup (null, rc.CurrentType, expr_type, Name, 0, MemberLookupRestrictions.None, loc);
 			if (any_other_member != null) {
 				any_other_member.Error_UnexpectedKind (rc.Compiler.Report, null, "type", loc);
 				return;
 			}
 
 			rc.Compiler.Report.Error (426, loc, "The nested type `{0}' does not exist in the type `{1}'",
 				Name, expr_type.GetSignatureForError ());
 		}
 
 		protected override void Error_TypeDoesNotContainDefinition (ResolveContext ec, TypeSpec type, string name)
 		{
 			if (RootContext.Version > LanguageVersion.ISO_2 && !ec.Compiler.IsRuntimeBinder && MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (1061, loc,
 					"Type `{0}' does not contain a definition for `{1}' and no extension method `{1}' of type `{0}' could be found (are you missing a using directive or an assembly reference?)",
 					type.GetSignatureForError (), name);
 				return;
 			}
 
 			base.Error_TypeDoesNotContainDefinition (ec, type, name);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return expr.GetSignatureForError () + "." + base.GetSignatureForError ();
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	/// <summary>
 	///   Implements checked expressions
 	/// </summary>
 	public class CheckedExpr 
 
 		public Expression Expr;
 
 		public CheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7977" endline="7990">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the unchecked expression
 	/// </summary>
 	public class UnCheckedExpr 
 
 		public Expression Expr;
 
 		public UnCheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="279" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="433" endline="440">
<![CDATA[
 		}
 
 		internal override Type GetTypeImpl(string typeName)
 		{
 			TypeBuilder type;
 			fullNameToType.TryGetValue(typeName, out type);
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="566" endline="572">
<![CDATA[
 
 		public Location[] GetLocations (object element)
 		{
 			Location[] found;
 			simple_locs.TryGetValue (element, out found);
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="573" endline="579">
<![CDATA[
 
 		public MemberLocations GetMemberLocation (MemberCore element)
 		{
 			MemberLocations found;
 			member_locs.TryGetValue (element, out found);
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="400" endline="406">
<![CDATA[
 
 		public RootNamespace GetRootNamespace (string name)
 		{
 			RootNamespace rn;
 			alias_ns.TryGetValue (name, out rn);
 			return rn;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="280" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1669" endline="1680">
<![CDATA[
 
 		protected abstract string GetSuffix();
 
 		protected abstract Type Wrap(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
 	}
 
 	sealed class ArrayType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ArrayType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1886" endline="1958">
<![CDATA[
 		}
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodInfo method;
 			private readonly Type type;
 			private readonly int pos;
 
 			internal ParameterInfoImpl(MethodInfo method, Type type, int pos)
 			{
 				this.method = method;
 				this.type = type;
 				this.pos = pos;
 			}
 
 			public override Type ParameterType
 			{
 				get { return type; }
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return pos; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { return null; }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method.IsConstructor ? (MethodBase)new ConstructorInfoImpl(method) 
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x8000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 	}
 
 	sealed class ByRefType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ByRefType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1999" endline="2006">
<![CDATA[
 	}
 
 	sealed class PointerType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new PointerType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="281" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="526" endline="567">
<![CDATA[
 
 		public void AddBlockMap (Block from, Block to)
 		{
 			block_map.Add (from, to);
 		}
 
 		public Block LookupBlock (Block from)
 		{
 			Block result;
 			if (!block_map.TryGetValue (from, out result)) {
 				result = (Block) from.Clone (this);
 			}
 
 			return result;
 		}
 
 		///
 		/// Remaps block to cloned copy if one exists.
 		///
 		public Block RemapBlockCopy (Block from)
 		{
 			Block mapped_to;
 			if (!block_map.TryGetValue (from, out mapped_to))
 				return from;
 
 			return mapped_to;
 		}
 	}
 
 	//
 	// Main compiler context
 	//
 	public class CompilerContext
 	{
 		readonly Report report;
 		readonly BuildinTypes buildin_types;
 
 		public CompilerContext (Report report)
 		{
 			this.report = report;
 			this.buildin_types = new BuildinTypes ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="830" endline="839">
<![CDATA[
 		}
 
 		Dictionary<TypeSpec, Expression> compatibles;
 		public ParametersBlock Block;
 
 		public AnonymousMethodExpression (Location loc)
 		{
 			this.loc = loc;
 			this.compatibles = new Dictionary<TypeSpec, Expression> ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="282" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="531" endline="556">
<![CDATA[
 		}
 	}
 
 	//
 	// The Field class is used to represents class/struct fields during parsing.
 	//
 	public class Field 
 		// <summary>
 		//   Modifiers allowed in a class declaration
 		// </summary>
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.STATIC |
 			Modifiers.VOLATILE |
 			Modifiers.UNSAFE |
 			Modifiers.READONLY;
 
 		public Field (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name,
 			      Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="340" endline="363">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Fixed buffer implementation
 	/// </summary>
 	public class FixedField 
 	{
 		public const string FixedElementName = "FixedElementField";
 		static int GlobalCounter = 0;
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="283" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="206" endline="212">
<![CDATA[
 
 		static void Error_InvalidNamedArgumentType (ResolveContext rc, NamedArgument name)
 		{
 			rc.Report.Error (655, name.Location,
 				"`{0}' is not a valid named attribute argument because it is not a valid attribute parameter type",
 				name.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="198" endline="205">
<![CDATA[
 
 		static void Error_InvalidNamedArgument (ResolveContext rc, NamedArgument name)
 		{
 			rc.Report.Error (617, name.Location, "`{0}' is not a valid named attribute argument. Named attribute arguments " +
 				      "must be fields which are not readonly, static, const or read-write properties which are " +
 				      "public and not static",
 			      name.Name);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="284" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1765" endline="1780">
<![CDATA[
 		}
 	}
 
 	//
 	// Opcode casts expression with 2 opcodes but only
 	// single expression tree node
 	//
 	class OpcodeCastDuplex 
 	{
 		readonly OpCode second;
 
 		public OpcodeCastDuplex (Expression child, TypeSpec returnType, OpCode first, OpCode second)
 			
 		{
 			this.second = second;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9495" endline="9506">
<![CDATA[
 
 			#endregion
 		}
 
 		CollectionOrObjectInitializers initializers;
 		IMemoryLocation instance;
 
 		public NewInitialize (FullNamedExpression requested_type, Arguments arguments, CollectionOrObjectInitializers initializers, Location l)
 			
 		{
 			this.initializers = initializers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8998" endline="9013">
<![CDATA[
 	}
 
 
 	//
 	// This class is used to represent the address of an array, used
 	// only by the Fixed statement, this generates "&a [0]" construct
 	// for fixed (char *pa = a)
 	//
 	public class ArrayPtr 
 		TypeSpec array_type;
 		
 		public ArrayPtr (Expression array, TypeSpec array_type, Location l)
 			base (array, array_type, l)
 		{
 			this.array_type = array_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="268" endline="276">
<![CDATA[
 		}
 
 		protected RangeVariable identifier;
 
 		protected ARangeVariableQueryClause (QueryBlock block, RangeVariable identifier, Expression expr, Location loc)
 			
 		{
 			this.identifier = identifier;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1569" endline="1579">
<![CDATA[
 	}
 
 	class ImportedParameterMemberDefinition 
 	{
 		readonly AParametersCollection parameters;
 
 		public ImportedParameterMemberDefinition (MethodBase provider, TypeSpec type, AParametersCollection parameters, MetadataImporter importer)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="636" endline="644">
<![CDATA[
 
 		//
 		// When a return type is known not to be dynamic
 		//
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="285" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2150" endline="2159">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1979" endline="1988">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(16)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="645" endline="654">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.WriteParam()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1847" endline="1856">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMemberForwarded()
 				.WriteStringIndex()
 				.WriteModuleRef()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="286" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="283" endline="289">
<![CDATA[
 
 		internal static float Int32BitsToSingle(int v)
 		{
 			SingleConverter c = new SingleConverter();
 			c.i = v;
 			return c.f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="267" endline="282">
<![CDATA[
 	}
 
 	[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
 	struct SingleConverter
 	{
 		[System.Runtime.InteropServices.FieldOffset(0)]
 		private int i;
 		[System.Runtime.InteropServices.FieldOffset(0)]
 		private float f;
 
 		internal static int SingleToInt32Bits(float v)
 		{
 			SingleConverter c = new SingleConverter();
 			c.f = v;
 			return c.i;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="287" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9137" endline="9150">
<![CDATA[
 	}
 
 	//
 	// An object initializer expression
 	//
 	public class ElementInitializer 
 	{
 		public readonly string Name;
 
 		public ElementInitializer (string name, Expression initializer, Location loc)
 			
 		{
 			this.Name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7462" endline="7476">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the qualified-alias-member (
 	/// </summary>
 	public class QualifiedAliasMember 
 	{
 		readonly string alias;
 		public static readonly string GlobalAlias = "global";
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="558" endline="750">
<![CDATA[
 	}
 
 	class DynamicIndexBinder 
 	{
 		bool can_be_mutator;
 
 		public DynamicIndexBinder (Arguments args, Location loc)
 			
 		{
 		}
 
 		public DynamicIndexBinder (CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			can_be_mutator = true;
 			return base.DoResolve (ec);
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
 
 		protected override Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			//
 			// Indexer has arguments which complicates things as the setter and getter
 			// are called in two steps when unary mutator is used. We have to make a
 			// copy of all variable arguments to not duplicate any side effect.
 			//
 			// ++d[++arg, Foo ()]
 			//
 
 			if (!can_be_mutator)
 				return base.CreateSetterArguments (rc, rhs);
 
 			var setter_args = new Arguments (Arguments.Count + 1);
 			for (int i = 0; i < Arguments.Count; ++i) {
 				var expr = Arguments[i].Expr;
 
 				if (expr is Constant || expr is VariableReference || expr is This) {
 					setter_args.Add (Arguments [i]);
 					continue;
 				}
 
 				LocalVariable temp = LocalVariable.CreateCompilerGenerated (expr.Type, rc.CurrentBlock, loc);
 				expr = new SimpleAssign (temp.CreateReferenceExpression (rc, expr.Location), expr).Resolve (rc);
 				Arguments[i].Expr = temp.CreateReferenceExpression (rc, expr.Location).Resolve (rc);
 				setter_args.Add (Arguments [i].Clone (expr));
 			}
 
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
 	}
 
 	class DynamicInvocation 
 	{
 		ATypeNameExpression member;
 
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 			this.member = member;
 		}
 
 		//
 		// When a return type is known not to be dynamic
 		//
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 		}
 
 		public static DynamicInvocation CreateSpecialNameInvoke (ATypeNameExpression member, Arguments args, Location loc)
 		{
 			return new DynamicInvocation (member, args, loc) {
 				flags = CSharpBinderFlags.InvokeSpecialName
 			};
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (member != null ? 5 
 			bool is_member_access = member is MemberAccess;
 
 			CSharpBinderFlags call_flags;
 			if (!is_member_access && member is SimpleName) {
 				call_flags = CSharpBinderFlags.InvokeSimpleName;
 				is_member_access = true;
 			} else {
 				call_flags = 0;
 			}
 
 			binder_args.Add (new Argument (new BinderFlags (call_flags, this)));
 
 			if (is_member_access)
 				binder_args.Add (new Argument (new StringLiteral (member.Name, member.Location)));
 
 			if (member != null && member.HasTypeArguments) {
 				TypeArguments ta = member.TypeArguments;
 				if (ta.Resolve (ec)) {
 					var targs = new ArrayInitializer (ta.Count, loc);
 					foreach (TypeSpec t in ta.Arguments)
 						targs.Add (new TypeOf (new TypeExpression (t, loc), loc));
 
 					binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (targs, loc)));
 				}
 			} else if (is_member_access) {
 				binder_args.Add (new Argument (new NullLiteral (loc)));
 			}
 
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 
 			Expression real_args;
 			if (args == null) {
 				// Cannot be null because .NET trips over
 				real_args = new ArrayCreation (
 					new MemberAccess (GetBinderNamespace (loc), "CSharpArgumentInfo", loc),
 					new ArrayInitializer (0, loc), loc);
 			} else {
 				real_args = new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc);
 			}
 
 			binder_args.Add (new Argument (real_args));
 
 			return new Invocation (GetBinder (is_member_access ? "InvokeMember" 
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			flags |= CSharpBinderFlags.ResultDiscarded;
 			base.EmitStatement (ec);
 		}
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
 
 		public DynamicMemberBinder (string name, CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
 	}
 
 	//
 	// Any member binder which can be source and target of assignment
 	//
 	abstract class DynamicMemberAssignable 
 	{
 		Expression setter;
 		Arguments setter_args;
 
 		protected DynamicMemberAssignable (Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="288" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="102" endline="108">
<![CDATA[
     End Property
 
     ReadOnly Property AsArrayTypeName() As ArrayTypeName
         Get
             Helper.Assert(IsArray)
             Return DirectCast(m_TypeName, ArrayTypeName)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="95" endline="101">
<![CDATA[
     End Property
 
     ReadOnly Property AsNonArrayTypeName() As NonArrayTypeName
         Get
             Helper.Assert(IsNotArray)
             Return DirectCast(m_TypeName, NonArrayTypeName)
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="289" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="743" endline="749">
<![CDATA[
 
 		public override void Error_AlreadyDeclared (string name, INamedBlockVariable variable, string reason)
 		{
 			TopBlock.Report.Error (1931, variable.Location,
 				"A range variable `{0}' conflicts with a previous declaration of `{0}'",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="750" endline="756">
<![CDATA[
 
 		public override void Error_AlreadyDeclared (string name, INamedBlockVariable variable)
 		{
 			TopBlock.Report.Error (1930, variable.Location,
 				"A range variable `{0}' has already been declared in this scope",
 				name);		
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="290" nfragments="8" Csharpe_files="8" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7970" endline="7976">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CheckedExpr target = (CheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8025" endline="8031">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnCheckedExpr target = (UnCheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="82" endline="88">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Yield target = (Yield) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1035" endline="1041">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			GotoCase target = (GotoCase) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1698" endline="1711">
<![CDATA[
 
 #if NET_4_0 && !STATIC
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return SLE.Expression.Default (type.GetMetaInfo ());
 		}
 #endif
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			DefaultValueExpression target = (DefaultValueExpression) t;
 			
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1214" endline="1220">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnaryMutator target = (UnaryMutator) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="767" endline="773">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Unary target = (Unary) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7908" endline="7914">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="291" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="291" endline="299">
<![CDATA[
 	}
 
 	public class Wrap 
 	{
 		private Wrap (Expression expr, TypeSpec type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="329" endline="340">
<![CDATA[
 	}
 
 	//
 	// Represents null literal lifted to nullable type
 	//
 	public class LiftedNull 
 	{
 		private LiftedNull (TypeSpec nullable_type, Location loc)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1440" endline="1454">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This kind of cast is used to encapsulate Value Types in objects.
 	///
 	///   The effect of it is to box the value type emitted by the previous
 	///   operation.
 	/// </summary>
 	public class BoxedCast 
 
 		public BoxedCast (Expression expr, TypeSpec target_type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="292" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="299" endline="314">
<![CDATA[
 	}
 
 	public struct LocalVariableEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly int Index;
 		public readonly string Name;
 		public readonly int BlockIndex;
 		#endregion
 
 		public LocalVariableEntry (int index, string name, int block)
 		{
 			this.Index = index;
 			this.Name = name;
 			this.BlockIndex = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="335" endline="358">
<![CDATA[
 	}
 
 	public struct CapturedVariable
 	{
 		#region This is actually written to the symbol file
 		public readonly string Name;
 		public readonly string CapturedName;
 		public readonly CapturedKind Kind;
 		#endregion
 
 		public enum CapturedKind 
 		{
 			Local,
 			Parameter,
 			This
 		}
 
 		public CapturedVariable (string name, string captured_name,
 					 CapturedKind kind)
 		{
 			this.Name = name;
 			this.CapturedName = captured_name;
 			this.Kind = kind;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="95" endline="101">
<![CDATA[
 
 		public void SetLocalSymInfo(string name, int startOffset, int endOffset)
 		{
 			this.name = name;
 			this.startOffset = startOffset;
 			this.endOffset = endOffset;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="293" nfragments="9" Csharpe_files="9" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1539" endline="1547">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1188" endline="1196">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasDeclSecurity()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1461" endline="1469">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="865" endline="873">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasConstant()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2305" endline="2313">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteTypeOrMethodDef()
 				.WriteStringIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1588" endline="1596">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMethodDef()
 				.WriteHasSemantics()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2209" endline="2217">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2103" endline="2111">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="294" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4273" endline="4279">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unchecked target = (Unchecked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4335" endline="4341">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unsafe target = (Unsafe) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="295" nfragments="7" Csharpe_files="7" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1543" endline="1553">
<![CDATA[
 	}
 
 	class ImportedMemberDefinition 
 	{
 		readonly TypeSpec type;
 
 		public ImportedMemberDefinition (MemberInfo member, TypeSpec type, MetadataImporter importer)
 			
 		{
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="706" endline="716">
<![CDATA[
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4755" endline="4764">
<![CDATA[
 	}
 
 	public class TryFinally 
 		Block fini;
 
 		public TryFinally (Statement stmt, Block fini, Location loc)
 			 
 		{
 			this.fini = fini;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5078" endline="5086">
<![CDATA[
 		}
 
 		VariableDeclaration decl;
 
 		public Using (VariableDeclaration decl, Statement stmt, Location loc)
 			
 		{
 			this.decl = decl;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1737" endline="1747">
<![CDATA[
 	}
 	
 	class OpcodeCast 
 	{
 		readonly OpCode op;
 		
 		public OpcodeCast (Expression child, TypeSpec return_type, OpCode op)
 			
 		{
 			this.op = op;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4094" endline="4105">
<![CDATA[
 	}
 
 	public class Lock 
 		Expression expr;
 		TemporaryVariableReference expr_copy;
 		TemporaryVariableReference lock_taken;
 			
 		public Lock (Expression expr, Statement stmt, Location loc)
 			
 		{
 			this.expr = expr;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="296" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="833" endline="840">
<![CDATA[
 		}
 
 		static readonly string[] attribute_targets = new string [] { "event" };
 
 		public EventProperty (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="571" endline="579">
<![CDATA[
 	}
 
 	public class FlowBranchingContinuable 
 	{
 		UsageVector continue_origins;
 
 		public FlowBranchingContinuable (FlowBranching parent, BranchingType type, SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="547" endline="555">
<![CDATA[
 	}
 
 	public class FlowBranchingBreakable 
 	{
 		UsageVector break_origins;
 
 		public FlowBranchingBreakable (FlowBranching parent, BranchingType type, SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="297" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="87" endline="95">
<![CDATA[
 	}
 
 	public class ParenthesizedExpression 
 	{
 		public ParenthesizedExpression (Expression expr)
 			
 		{
 			loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4320" endline="4332">
<![CDATA[
 	}
 
 	//
 	// A boolean-expression is an expression that yields a result
 	// of type bool
 	//
 	public class BooleanExpression 
 	{
 		public BooleanExpression (Expression expr)
 			
 		{
 			this.loc = expr.Location;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="298" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="168" endline="174">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="213" endline="219">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="299" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="74" endline="82">
<![CDATA[
     End Property
 
     Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="196" endline="203">
<![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="300" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="190" endline="205">
<![CDATA[
 
 		public enum Operation {
 			//
 			// If you change this, review the whole InterfaceMethod routine as there
 			// are a couple of assumptions on these three states
 			//
 			Lookup, ClearOne, ClearAll
 		}
 
 		/// <summary>
 		///   Whether the specified method is an interface method implementation
 		/// </summary>
 		public MethodSpec IsInterfaceMethod (MemberName name, TypeSpec ifaceType, MethodData method)
 		{
 			return InterfaceMethod (name, ifaceType, method, Operation.Lookup);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1230" endline="1246">
<![CDATA[
 
 
 		/// <summary>
 		///   Attempts to apply the `Standard Implicit
 		///   Conversion' rules to the expression `expr' into
 		///   the `target_type'.  It returns a new expression
 		///   that can be used in a context that expects a
 		///   `target_type'.
 		///
 		///   This is different from `ImplicitConversion' in that the
 		///   user defined implicit conversions are excluded.
 		/// </summary>
 		static public Expression ImplicitConversionStandard (ResolveContext ec, Expression expr,
 								     TypeSpec target_type, Location loc)
 		{
 			return ImplicitConversionStandard (ec, expr, target_type, loc, false);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="301" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="960" endline="967">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Implicit conversions
 		/// </summary>
 		static public Expression ImplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, true, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="968" endline="975">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Explicit conversions
 		/// </summary>
 		static Expression ExplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, false, loc);
 		}
]]>
</clone_fragment>
</clone_group>
</clones>
