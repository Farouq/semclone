<clones>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="84" endline="119">
<![CDATA[
 		{
 			switch (br.ReadByte())
 			{
 				case ELEMENT_TYPE_CLASS
 				case ELEMENT_TYPE_VALUETYPE
 					break;
 				default
 					throw new BadImageFormatException();
 			}
 			Type type = ReadTypeDefOrRefEncoded(module, br, context);
 			if (!type.IsGenericTypeDefinition)
 			{
 				throw new BadImageFormatException();
 			}
 			int genArgCount = br.ReadCompressedInt();
 			Type[] args = new Type[genArgCount];
 			Type[][] reqmod = null;
 			Type[][] optmod = null;
 			for (int i = 0; i < genArgCount; i++)
 			{
 				// LAMESPEC the Type production (23.2.12) doesn't include CustomMod* for genericinst, but C++ uses it, the verifier allows it and ildasm also supports it
 				CustomModifiers mods = ReadCustomModifiers(module, br, context);
 				if (mods.required != null || mods.optional != null)
 				{
 					if (reqmod == null)
 					{
 						reqmod = new Type[genArgCount][];
 						optmod = new Type[genArgCount][];
 					}
 					reqmod[i] = mods.required;
 					optmod[i] = mods.optional;
 				}
 				args[i] = ReadType(module, br, context);
 			}
 			for (int i = 0; i < genArgCount; i++)
 			{
 				// LAMESPEC the Type production (23.2.12) doesn't include CustomMod* for genericinst, but C++ uses it, the verifier allows it and ildasm also supports it
 				CustomModifiers mods = ReadCustomModifiers(module, br, context);
 				if (mods.required != null || mods.optional != null)
 				{
 					if (reqmod == null)
 					{
 						reqmod = new Type[genArgCount][];
 						optmod = new Type[genArgCount][];
 					}
 					reqmod[i] = mods.required;
 					optmod[i] = mods.optional;
 				}
 				args[i] = ReadType(module, br, context);
 			}
 			return GenericTypeInstance.Make(type, args, reqmod, optmod);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="172" endline="216">
<![CDATA[
 
 		internal static PropertySignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			byte flags = br.ReadByte();
 			if ((flags & PROPERTY) == 0)
 			{
 				throw new BadImageFormatException();
 			}
 			CallingConventions callingConvention = CallingConventions.Standard;
 			if ((flags & HASTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.HasThis;
 			}
 			if ((flags & EXPLICITTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.ExplicitThis;
 			}
 			Type returnType;
 			Type[] returnTypeRequiredCustomModifiers;
 			Type[] returnTypeOptionalCustomModifiers;
 			Type[] parameterTypes;
 			Type[][] parameterRequiredCustomModifiers;
 			Type[][] parameterOptionalCustomModifiers;
 			int paramCount = br.ReadCompressedInt();
 			ReadCustomModifiers(module, br, context, out returnTypeRequiredCustomModifiers, out returnTypeOptionalCustomModifiers);
 			returnType = ReadRetType(module, br, context);
 			parameterTypes = new Type[paramCount];
 			parameterRequiredCustomModifiers = null;
 			parameterOptionalCustomModifiers = null;
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (IsCustomModifier(br.PeekByte()))
 				{
 					if (parameterOptionalCustomModifiers == null)
 					{
 						parameterOptionalCustomModifiers = new Type[parameterTypes.Length][];
 						parameterRequiredCustomModifiers = new Type[parameterTypes.Length][];
 					}
 					ReadCustomModifiers(module, br, context, out parameterRequiredCustomModifiers[i], out parameterOptionalCustomModifiers[i]);
 				}
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (IsCustomModifier(br.PeekByte()))
 				{
 					if (parameterOptionalCustomModifiers == null)
 					{
 						parameterOptionalCustomModifiers = new Type[parameterTypes.Length][];
 						parameterRequiredCustomModifiers = new Type[parameterTypes.Length][];
 					}
 					ReadCustomModifiers(module, br, context, out parameterRequiredCustomModifiers[i], out parameterOptionalCustomModifiers[i]);
 				}
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			return new PropertySignature(callingConvention, returnType, returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers,
 				parameterTypes, parameterOptionalCustomModifiers, parameterRequiredCustomModifiers);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1409" endline="1417">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakeByRefType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1446" endline="1454">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakePointerType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="403" endline="411">
<![CDATA[
 
 		protected abstract void AddSibling (UsageVector uv);
 
 		protected abstract UsageVector Merge ();
 
 		public UsageVector MergeChild (FlowBranching child)
 		{
 			return CurrentUsageVector.MergeChild (child.Merge (), true);
  		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="539" endline="546">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			Report.Debug (2, "  MERGING SIBLINGS", Name);
 			UsageVector vector = UsageVector.MergeSiblings (sibling_list, Location);
 			Report.Debug (2, "  MERGING SIBLINGS DONE", Name, vector);
 			return vector;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="556" endline="563">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = break_origins;
 			break_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="564" endline="570">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (break_origins);
 			return vector;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="580" endline="587">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = continue_origins;
 			continue_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="588" endline="594">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (continue_origins);
 			return vector;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="756" endline="762">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddBreakOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="763" endline="769">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddContinueOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="770" endline="776">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement exit_stmt)
 		{
 			Parent.AddReturnOrigin (vector, exit_stmt);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="749" endline="757">
<![CDATA[
 		}
 		
 		/// <summary>
 		///   Reports that we were expecting `expr' to be of class `expected'
 		/// </summary>
 		public void Error_UnexpectedKind (Report r, MemberCore mc, string expected, Location loc)
 		{
 			Error_UnexpectedKind (r, mc, expected, ExprClassName, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="906" endline="927">
<![CDATA[
 				String.Format (
 					"CloneTo not implemented for expression {0}", this.GetType ()));
 		}
 
 		//
 		// Clones an expression created by the parser.
 		//
 		// We only support expressions created by the parser so far, not
 		// expressions that have been resolved (many more classes would need
 		// to implement CloneTo).
 		//
 		// This infrastructure is here merely for Lambda expressions which
 		// compile the same code using different type values for the same
 		// arguments to find the correct overload
 		//
 		public virtual Expression Clone (CloneContext clonectx)
 		{
 			Expression cloned = (Expression) MemberwiseClone ();
 			CloneTo (clonectx, cloned);
 
 			return cloned;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="928" endline="937">
<![CDATA[
 
 		//
 		// Implementation of expression to expression tree conversion
 		//
 		public abstract Expression CreateExpressionTree (ResolveContext ec);
 
 		protected Expression CreateExpressionFactoryCall (ResolveContext ec, string name, Arguments args)
 		{
 			return CreateExpressionFactoryCall (ec, name, null, args, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="203" endline="209">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MemberInfo.cs" startline="43" endline="53">
<![CDATA[
 		}
 
 		public abstract Module Module
 		{
 			get;
 		}
 
 		public bool IsDefined(Type attributeType, bool inherit)
 		{
 			return CustomAttributeData.__GetCustomAttributes(this, attributeType, inherit).Count != 0;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="299" endline="310">
<![CDATA[
 		}
 
 		// .NET 4.0 API
 		public virtual Type GetEnumUnderlyingType()
 		{
 			if (!this.IsEnum)
 			{
 				throw new ArgumentException();
 			}
 			CheckBaked();
 			return GetEnumUnderlyingTypeImpl();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1153" endline="1161">
<![CDATA[
 
 		public Type __MakeGenericType(Type[] typeArguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			if (!this.IsGenericTypeDefinition)
 			{
 				throw new InvalidOperationException();
 			}
 			return GenericTypeInstance.Make(this, Util.Copy(typeArguments), Util.Copy(requiredCustomModifiers), Util.Copy(optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="209" endline="220">
<![CDATA[
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			if (type != null)
 			{
 				return binder.BindTypeParameter(this);
 			}
 			else
 			{
 				return binder.BindMethodParameter(this);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="326" endline="332">
<![CDATA[
 
 		public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			MethodBuilder mb = CreateMethodBuilder(name, attributes, callingConvention);
 			mb.SetSignature(returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 			return mb;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="381" endline="387">
<![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, CallingConventions.Standard, true, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="388" endline="395">
<![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, callingConvention, false, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="726" endline="740">
<![CDATA[
 		}
 
 		public override string Name
 		{
 			get
 			{
 				if (this.IsNested)
 				{
 					return nameOrFullName;
 				}
 				else
 				{
 					return base.Name;
 				}
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="741" endline="749">
<![CDATA[
 		}
 
 		public override string Namespace
 		{
 			get
 			{
 				// for some reason, TypeBuilder doesn't return null (and mcs depends on this)
 				return base.Namespace ?? "";
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="315" endline="321">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var fs = (FieldSpec) base.InflateMember (inflator);
 			fs.memberType = inflator.Inflate (memberType);
 			return fs;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="364" endline="379">
<![CDATA[
 
 		#region Properties
 
 		//
 		// Explicit struct layout set by parent
 		//
 		public CharSet? CharSet {
 			get; set;
 		}		
 
 		#endregion
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ImplicitConversionRequired (rc, TypeManager.int32_type, Location);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1120" endline="1130">
<![CDATA[
 		
 		public int peek_token ()
 		{
 			int the_token;
 
 			PushPosition ();
 			the_token = token ();
 			PopPosition ();
 			
 			return the_token;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3280" endline="3295">
<![CDATA[
 
 		public string GetFullName (string name)
 		{
 			if (!IsExplicitImpl)
 				return name;
 
 			//
 			// When dealing with explicit members a full interface type
 			// name is added to member name to avoid possible name conflicts
 			//
 			// We use CSharpName which gets us full name with benefit of
 			// replacing predefined names which saves some space and name
 			// is still unique
 			//
 			return TypeManager.CSharpName (InterfaceType) + "." + name;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="97" endline="112">
<![CDATA[
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			bool res = base.CheckOverrideAgainstBase (base_member);
 
 			//
 			// Check that the permissions are not being changed
 			//
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				res = false;
 			}
 
 			return res;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="113" endline="121">
<![CDATA[
 
 		protected override bool CheckBase ()
 		{
 			// Check whether arguments were correct.
 			if (!DefineParameters (parameters))
 				return false;
 
 			return base.CheckBase ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="848" endline="855">
<![CDATA[
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="71" endline="83">
<![CDATA[
 
 		//
 		// This routine must be overrided in derived classes and make copies
 		// of all the data that might be modified if resolved
 		// 
 		protected abstract void CloneTo (CloneContext clonectx, Statement target);
 
 		public Statement Clone (CloneContext clonectx)
 		{
 			Statement s = (Statement) this.MemberwiseClone ();
 			CloneTo (clonectx, s);
 			return s;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="106" endline="117">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="118" endline="129">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="38" endline="48">
<![CDATA[
 		}
 
 		internal abstract int RowCount { get; set; }
 
 		internal abstract void Write(MetadataWriter mw);
 		internal abstract void Read(MetadataReader mr);
 
 		internal int GetLength(MetadataWriter md)
 		{
 			return RowCount * GetRowSize(new RowSizeCalc(md));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5040" endline="5048">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			SetAssigned (ec);
 			return base.DoResolveLValue (ec, right_side);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="789" endline="797">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			rc.Report.Error (1947, loc,
 				"A range variable `{0}' cannot be assigned to. Consider using `let' clause to store the value",
 				Name);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="278" endline="284">
<![CDATA[
 
 		internal int Add(Guid guid)
 		{
 			Debug.Assert(!frozen);
 			list.Add(guid);
 			return list.Count;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="175" endline="184">
<![CDATA[
 		}
 
 		#endregion
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var ps = (PropertySpec) base.InflateMember (inflator);
 			ps.memberType = inflator.Inflate (memberType);
 			return ps;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="559" endline="568">
<![CDATA[
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			IsTypePermitted ();
 
 			if (MemberType.IsStatic)
 				Error_StaticReturnType ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1255" endline="1266">
<![CDATA[
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="841" endline="849">
<![CDATA[
 
 		public override bool Define()
 		{
 			if (!base.Define ())
 				return false;
 
 			SetIsUsed ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1610" endline="1616">
<![CDATA[
 		}
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			return DeclaringType.GetSignatureForError () + ".this" + parameters.GetSignatureForError ("[", "]", parameters.Count);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1617" endline="1623">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var spec = (IndexerSpec) base.InflateMember (inflator);
 			spec.parameters = parameters.Inflate (inflator);
 			return spec;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="304" endline="311">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool AddMember (MemberCore symbol)
 		{
 			return AddToContainer (symbol, symbol.MemberName.Basename);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="169" endline="175">
<![CDATA[
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="236" endline="242">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.enum_type;
 			base_class = base_type_expr;
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="31" endline="45">
<![CDATA[
 
 		/// <remarks>
 		///   This is different from ToString in that ToString
 		///   is supposed to be there for debugging purposes,
 		///   and is not guaranteed to be useful for anything else,
 		///   AsString() will provide something that can be used
 		///   for round-tripping C# code.  Maybe it can be used
 		///   for IL assembly as well.
 		/// </remarks>
 		public abstract string AsString ();
 
 		override public string ToString ()
 		{
 			return this.GetType ().Name + " (" + AsString () + ")";
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="105" endline="112">
<![CDATA[
 
 		//
 		//  Returns a constant instance based on Type
 		//
 		public static Constant CreateConstant (ResolveContext rc, TypeSpec t, object v, Location loc)
 		{
 			return CreateConstantFromValue (t, v, loc).Resolve (rc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1314" endline="1321">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec target_type)
 		{
 			// FIXME
 			if (!Convert.ImplicitStandardConversionExists (this, target_type))
 				return null;
 			return child.ConvertImplicitly (rc, target_type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1342" endline="1348">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			Child = Child.Resolve (rc);
 			this.eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3213" endline="3219">
<![CDATA[
 
 		#region IBaseMembersProvider Members
 
 		public virtual IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5782" endline="5788">
<![CDATA[
 		}
 
 		public static TemporaryVariableReference Create (TypeSpec type, Block block, Location loc)
 		{
 			var li = LocalVariable.CreateCompilerGenerated (type, block, loc);
 			return new TemporaryVariableReference (li, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5822" endline="5828">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source)
 		{
 			li.CreateBuilder (ec);
 
 			EmitAssign (ec, source, false, false);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="328" endline="334">
<![CDATA[
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed |
 					base.TypeAttr;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="358" endline="364">
<![CDATA[
 
 
 		public static MethodSpec GetConstructor (CompilerContext ctx, TypeSpec container_type, TypeSpec delType)
 		{
 			var ctor = MemberCache.FindMember (delType, MemberFilter.Constructor (null), BindingRestriction.DeclaredOnly);
 			return (MethodSpec) ctor;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="626" endline="632">
<![CDATA[
 
 		static public Expression Create (ResolveContext ec, MethodGroupExpr mge,
 						 TypeSpec target_type, Location loc)
 		{
 			ImplicitDelegateCreation d = new ImplicitDelegateCreation (target_type, mge, loc);
 			return d.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="118" endline="125">
<![CDATA[
 		}
 
 		internal uint StrongNameSignatureRVA
 		{
 			get
 			{
 				return (ResourcesRVA + ResourcesLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="134" endline="141">
<![CDATA[
 		}
 
 		private uint MetadataRVA
 		{
 			get
 			{
 				return (StrongNameSignatureRVA + StrongNameSignatureLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="423" endline="429">
<![CDATA[
 
 		public ReportPrinter SetPrinter (ReportPrinter printer)
 		{
 			ReportPrinter old = this.printer;
 			this.printer = printer;
 			return old;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="657" endline="663">
<![CDATA[
 
 	string GetTypeName (Type t)
 	{
 		StringBuilder sb = new StringBuilder ();
 		GetTypeName (sb, t);
 		return sb.ToString ();
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="915" endline="927">
<![CDATA[
 
 //	static Comparer TypeComparer = new Comparer (new ComparerFunc (CompareType));
 
 //	static Type [] Sort (Type [] types)
 //	{
 //		Array.Sort (types, TypeComparer);
 //		return types;
 //	}
 	
 	static int CompareMemberInfo (object a, object b)
 	{
 		return string.Compare (((MemberInfo) a).Name, ((MemberInfo) b).Name);
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1221" endline="1233">
<![CDATA[
 
   /** the generated parser, with debugging messages.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @param yydebug debug message writer implementing yyDebug, or null.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
 				 {
     this.debug = (yydebug.yyDebug)yyd;
     return yyparse(yyLex);
   }
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6215" endline="6222">
<![CDATA[
 
 string ConsumeStoredComment ()
 {
 	string s = tmpComment;
 	tmpComment = null;
 	Lexer.doc_state = XmlCommentState.Allowed;
 	return s;
 }
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="154" endline="162">
<![CDATA[
 		}
 
 		public override bool IsGenericMethodDefinition
 		{
 			get
 			{
 				PopulateGenericArguments();
 				return typeArgs.Length > 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="168" endline="174">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="255" endline="261">
<![CDATA[
 		}
 
 		internal override MethodBase BindTypeParameters(Type type)
 		{
 			System.Diagnostics.Debug.Assert(methodArgs == null);
 			return new GenericMethodInstance(declaringType.BindTypeParameters(type), method, null);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="586" endline="594">
<![CDATA[
 
 	//
 	// Returns the ConstructorInfo for "args"
 	//
 	public static MethodSpec GetPredefinedConstructor (TypeSpec t, Location loc, params TypeSpec [] args)
 	{
 		var pc = ParametersCompiled.CreateFullyResolved (args);
 		return GetPredefinedMember (t, MemberFilter.Constructor (pc), false, loc) as MethodSpec;
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="595" endline="604">
<![CDATA[
 
 	//
 	// Returns the method specification for a method named `name' defined
 	// in type `t' which takes arguments of types `args'
 	//
 	public static MethodSpec GetPredefinedMethod (TypeSpec t, string name, Location loc, params TypeSpec [] args)
 	{
 		var pc = ParametersCompiled.CreateFullyResolved (args);
 		return GetPredefinedMethod (t, MemberFilter.Method (name, 0, pc, null), false, loc);
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="912" endline="920">
<![CDATA[
 
 	/// <summary>
 	///   Check whether `type' and `parent' are both instantiations of the same
 	///   generic type.  Note that we do not check the type parameters here.
 	/// </summary>
 	public static bool IsInstantiationOfSameGenericType (TypeSpec type, TypeSpec parent)
 	{
 		return type == parent || type.MemberDefinition == parent.MemberDefinition;
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="340" endline="346">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.bool_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="495" endline="501">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.char_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="955" endline="961">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1136" endline="1142">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1398" endline="1404">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1515" endline="1521">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.float_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1638" endline="1644">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.double_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1766" endline="1772">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.decimal_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1892" endline="1898">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="960" endline="967">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Implicit conversions
 		/// </summary>
 		static public Expression ImplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, true, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="968" endline="975">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Explicit conversions
 		/// </summary>
 		static Expression ExplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, false, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1230" endline="1246">
<![CDATA[
 
 
 		/// <summary>
 		///   Attempts to apply the `Standard Implicit
 		///   Conversion' rules to the expression `expr' into
 		///   the `target_type'.  It returns a new expression
 		///   that can be used in a context that expects a
 		///   `target_type'.
 		///
 		///   This is different from `ImplicitConversion' in that the
 		///   user defined implicit conversions are excluded.
 		/// </summary>
 		static public Expression ImplicitConversionStandard (ResolveContext ec, Expression expr,
 								     TypeSpec target_type, Location loc)
 		{
 			return ImplicitConversionStandard (ec, expr, target_type, loc, false);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3023" endline="3032">
<![CDATA[
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3033" endline="3041">
<![CDATA[
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3897" endline="3912">
<![CDATA[
 	}
 
 	// A place where execution can restart in an iterator
 	public abstract class ResumableStatement 
 	{
 		bool prepared;
 		protected Label resume_point;
 
 		public Label PrepareForEmit (EmitContext ec)
 		{
 			if (!prepared) {
 				prepared = true;
 				resume_point = ec.DefineLabel ();
 			}
 			return resume_point;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4025" endline="4033">
<![CDATA[
 
 		public override Label PrepareForDispose (EmitContext ec, Label end)
 		{
 			if (!prepared_for_dispose) {
 				prepared_for_dispose = true;
 				dispose_try_block = ec.DefineLabel ();
 			}
 			return dispose_try_block;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="276" endline="285">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			base.DoResolve (rc);
 
 			if (type != null)
 				type = NullableInfo.GetUnderlyingType (type);
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="346" endline="353">
<![CDATA[
 
 		public static Constant CreateFromExpression (ResolveContext ec, Expression e)
 		{
 			ec.Report.Warning (458, 2, e.Location, "The result of the expression is always `null' of type `{0}'",
 				TypeManager.CSharpName (e.Type));
 
 			return ReducedExpression.Create (Create (e.Type, e.Location), e);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="595" endline="603">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (user_operator != null)
 				return user_operator.CreateExpressionTree (ec);
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="412" endline="418">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.byte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="619" endline="625">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.sbyte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="725" endline="731">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.short_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="843" endline="849">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.ushort_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2306" endline="2317">
<![CDATA[
 
 		protected override bool DoDefineMembers ()
 		{
 			CheckProtectedModifier ();
 
 			base.DoDefineMembers ();
 
 			if (default_static_constructor != null)
 				default_static_constructor.Define ();
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1034" endline="1040">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var tps = (TypeParameterSpec) MemberwiseClone ();
 			InflateConstraints (inflator, tps);
 			return tps;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1520" endline="1527">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null)
 				info = CreateMetaInfo (null);
 
 			return info;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="646" endline="653">
<![CDATA[
 		}
 
 		Options flags;
 
 		public bool HasSet (Options options)
 		{
 			return (this.flags & options) == options;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="326" endline="332">
<![CDATA[
 
 		public virtual TypeSpec ResolveType ()
 		{
 			if (Type == null && !resolve_error)
 				ResolveAttributeType ();
 			return Type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1211" endline="1221">
<![CDATA[
 
 		protected override TypeExpr ResolveAsTypeTerminal (Expression expr, IMemberContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveAsTypeTerminal (expr, ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1222" endline="1232">
<![CDATA[
 
 		protected override MethodSpec ResolveConstructor (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveConstructor (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1233" endline="1243">
<![CDATA[
 
 		protected override bool ResolveNamedArguments (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveNamedArguments (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1605" endline="1611">
<![CDATA[
 
 		public byte[] ToArray ()
 		{
 			byte[] buf = new byte[pos];
 			Array.Copy (buffer, buf, pos);
 			return buf;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="82" endline="91">
<![CDATA[
 		}
 
 		#endregion
 
 		public Argument Clone (Expression expr)
 		{
 			Argument a = (Argument) MemberwiseClone ();
 			a.Expr = expr;
 			return a;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="202" endline="237">
<![CDATA[
 
 		public static LineNumberEntry Null = new LineNumberEntry (0, 0, 0);
 
 		private class OffsetComparerClass 
 		{
 			public int Compare (LineNumberEntry l1, LineNumberEntry l2)
 			{
 				if (l1.Offset < l2.Offset)
 					return -1;
 				else if (l1.Offset > l2.Offset)
 					return 1;
 				else
 					return 0;
 			}
 		}
 
 		private class RowComparerClass 
 		{
 			public int Compare (LineNumberEntry l1, LineNumberEntry l2)
 			{
 				if (l1.Row < l2.Row)
 					return -1;
 				else if (l1.Row > l2.Row)
 					return 1;
 				else
 					return 0;
 			}
 		}
 
 		public static readonly IComparer<LineNumberEntry> OffsetComparer = new OffsetComparerClass ();
 		public static readonly IComparer<LineNumberEntry> RowComparer = new RowComparerClass ();
 
 		public override string ToString ()
 		{
 			return String.Format ("[Line {0}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="645" endline="652">
<![CDATA[
 
 		public NamespaceEntry[] Namespaces {
 			get {
 				ReadData ();
 				NamespaceEntry[] retval = new NamespaceEntry [namespaces.Count];
 				namespaces.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="900" endline="906">
<![CDATA[
 
 		internal static LineNumberTable Read (MonoSymbolFile file, MyBinaryReader br)
 		{
 			LineNumberTable lnt = new LineNumberTable (file);
 			lnt.DoRead (file, br);
 			return lnt;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1187" endline="1194">
<![CDATA[
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			return IsDecrement ? "Decrement" 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4787" endline="4794">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6915" endline="6924">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (this));
 			
 			// Use typeless constant for ldarg.0 to save some
 			// space and avoid problems with anonymous stories
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8341" endline="8349">
<![CDATA[
 
 		public SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source)
 		{
 #if NET_4_0
 			return SLE.Expression.ArrayAccess (ea.Expr.MakeExpression (ctx), MakeExpressionArguments (ctx));
 #else
 			throw new NotImplementedException ();
 #endif
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8560" endline="8566">
<![CDATA[
 
 		#region IBaseMembersProvider Members
 
 		IList<MemberSpec> OverloadResolver.IBaseMembersProvider.GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8608" endline="8616">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (831, loc, "An expression tree may not contain a base access");
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8756" endline="8762">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 			type = TypeManager.object_type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9310" endline="9316">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			base.expr = new AddMemberAccess (ec.CurrentInitializerVariable, loc);
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="94" endline="104">
<![CDATA[
 
 		public ImportedModuleDefinition ImportModule (Module module, RootNamespace targetNamespace)
 		{
 			var module_definition = new ImportedModuleDefinition (module, this);
 			module_definition.ReadAttributes ();
 
 			var all_types = module.GetTypes ();
 			ImportTypes (all_types, targetNamespace, false);
 
 			return module_definition;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="996" endline="1007">
<![CDATA[
 
 		public delegate void Simple ();
 		
 		/// <summary>
 		///   Times the execution of the given delegate
 		/// </summary>
 		static public TimeSpan Time (Simple a)
 		{
 			DateTime start = DateTime.Now;
 			a ();
 			return DateTime.Now - start;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="109" endline="119">
<![CDATA[
 		}
 
 		// <summary>
 		//   Starts a new code branching.  This inherits the state of all local
 		//   variables and parameters from the current branching.
 		// </summary>
 		public FlowBranching StartFlowBranching (FlowBranching.BranchingType type, Location loc)
 		{
 			current_flow_branching = FlowBranching.CreateBranching (CurrentBranching, type, null, loc);
 			return current_flow_branching;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="120" endline="131">
<![CDATA[
 
 		// <summary>
 		//   Starts a new code branching for block `block'.
 		// </summary>
 		public FlowBranching StartFlowBranching (Block block)
 		{
 			Set (Options.DoFlowAnalysis);
 
 			current_flow_branching = FlowBranching.CreateBranching (
 				CurrentBranching, FlowBranching.BranchingType.Block, block, block.StartLocation);
 			return current_flow_branching;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="132" endline="138">
<![CDATA[
 
 		public FlowBranchingTryCatch StartFlowBranching (TryCatch stmt)
 		{
 			FlowBranchingTryCatch branching = new FlowBranchingTryCatch (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="139" endline="145">
<![CDATA[
 
 		public FlowBranchingException StartFlowBranching (ExceptionStatement stmt)
 		{
 			FlowBranchingException branching = new FlowBranchingException (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="146" endline="152">
<![CDATA[
 
 		public FlowBranchingLabeled StartFlowBranching (LabeledStatement stmt)
 		{
 			FlowBranchingLabeled branching = new FlowBranchingLabeled (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="153" endline="159">
<![CDATA[
 
 		public FlowBranchingIterator StartFlowBranching (Iterator iterator, FlowBranching parent)
 		{
 			FlowBranchingIterator branching = new FlowBranchingIterator (parent, iterator);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="160" endline="166">
<![CDATA[
 
 		public FlowBranchingToplevel StartFlowBranching (ParametersBlock stmt, FlowBranching parent)
 		{
 			FlowBranchingToplevel branching = new FlowBranchingToplevel (parent, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="235" endline="242">
<![CDATA[
 
 		protected Field AddCompilerGeneratedField (string name, FullNamedExpression type)
 		{
 			const Modifiers mod = Modifiers.INTERNAL | Modifiers.COMPILER_GENERATED;
 			Field f = new Field (this, type, mod, new MemberName (name, Location), null);
 			AddField (f);
 			return f;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1669" endline="1680">
<![CDATA[
 
 		protected abstract string GetSuffix();
 
 		protected abstract Type Wrap(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
 	}
 
 	sealed class ArrayType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ArrayType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1757" endline="1766">
<![CDATA[
 	}
 
 	sealed class MultiArrayType 
 	{
 		private readonly int rank;
 
 		internal static Type Make(Type type, int rank, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new MultiArrayType(type, rank, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1886" endline="1958">
<![CDATA[
 		}
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodInfo method;
 			private readonly Type type;
 			private readonly int pos;
 
 			internal ParameterInfoImpl(MethodInfo method, Type type, int pos)
 			{
 				this.method = method;
 				this.type = type;
 				this.pos = pos;
 			}
 
 			public override Type ParameterType
 			{
 				get { return type; }
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return pos; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { return null; }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method.IsConstructor ? (MethodBase)new ConstructorInfoImpl(method) 
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x8000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 	}
 
 	sealed class ByRefType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ByRefType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1999" endline="2006">
<![CDATA[
 	}
 
 	sealed class PointerType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new PointerType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="23" endline="45">
<![CDATA[
 
 		private ReferenceEquality ()
 		{
 		}
 
 		public bool Equals (T x, T y)
 		{
 			return ReferenceEquals (x, y);
 		}
 
 		public int GetHashCode (T obj)
 		{
 			return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode (obj);
 		}
 	}
 
 	public class Tuple<T1, T2> 
 	{
 		public Tuple (T1 item1, T2 item2)
 		{
 			Item1 = item1;
 			Item2 = item2;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="54" endline="61">
<![CDATA[
 
 		#region IEquatable<Tuple<T1,T2>> Members
 
 		public bool Equals (Tuple<T1, T2> other)
 		{
 			return EqualityComparer<T1>.Default.Equals (Item1, other.Item1) &&
 				EqualityComparer<T2>.Default.Equals (Item2, other.Item2);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="213" endline="219">
<![CDATA[
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return IsGeneric ? GenericDefinition.TypeParametersCount 
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="290" endline="300">
<![CDATA[
 		}
 
 		#endregion
 
 		public MethodSpec GetGenericMethodDefinition ()
 		{
 			if (!IsGeneric && !DeclaringType.IsGeneric)
 				return this;
 
 			return MemberCache.GetMember (declaringType, this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="124" endline="135">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="136" endline="147">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="706" endline="717">
<![CDATA[
 
 		// note that context is slightly different from the calling assembly (System.Type.GetType),
 		// because context is passed to the AssemblyResolve event as the RequestingAssembly
 		public Type GetType(Assembly context, string assemblyQualifiedTypeName, bool throwOnError)
 		{
 			TypeNameParser parser = TypeNameParser.Parse(assemblyQualifiedTypeName, throwOnError);
 			if (parser.Error)
 			{
 				return null;
 			}
 			return parser.GetType(this, context, throwOnError, assemblyQualifiedTypeName);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="745" endline="752">
<![CDATA[
 
 #if NET_4_0
 		[Obsolete]
 #endif
 		public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 		{
 			return DefineDynamicAssemblyImpl(name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="190" endline="205">
<![CDATA[
 
 		public enum Operation {
 			//
 			// If you change this, review the whole InterfaceMethod routine as there
 			// are a couple of assumptions on these three states
 			//
 			Lookup, ClearOne, ClearAll
 		}
 
 		/// <summary>
 		///   Whether the specified method is an interface method implementation
 		/// </summary>
 		public MethodSpec IsInterfaceMethod (MemberName name, TypeSpec ifaceType, MethodData method)
 		{
 			return InterfaceMethod (name, ifaceType, method, Operation.Lookup);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="108" endline="114">
<![CDATA[
 		}
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			iterator = ec.CurrentIterator;
 			return Yield.CheckContext (ec, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="517" endline="524">
<![CDATA[
 
 		public override EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			EmitContext ec = new EmitContext (this, ig, MemberType);
 
 			ec.CurrentAnonymousMethod = host.Iterator;
 			return ec;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="171" endline="177">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="262" endline="268">
<![CDATA[
 		}
 
 		FieldSpec CreateSiteField (EmitContext ec, FullNamedExpression type)
 		{
 			var site_container = ec.CreateDynamicSite ();
 			return site_container.CreateCallSiteField (type, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="645" endline="651">
<![CDATA[
 
 		public static DynamicInvocation CreateSpecialNameInvoke (ATypeNameExpression member, Arguments args, Location loc)
 		{
 			return new DynamicInvocation (member, args, loc) {
 				flags = CSharpBinderFlags.InvokeSpecialName
 			};
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="478" endline="490">
<![CDATA[
 		}
 
 		internal CustomAttributeBuilder DecodeBlob(Assembly asm)
 		{
 			if (blob == null)
 			{
 				return this;
 			}
 			else
 			{
 				return ToData(asm).__ToBuilder();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="205" endline="211">
<![CDATA[
 
 		public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
 		{
 			ModuleBuilder module = new ModuleBuilder(this, name, fileName, emitSymbolInfo);
 			modules.Add(module);
 			return module;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="80" endline="87">
<![CDATA[
 
 		internal FieldSignature ExpandTypeParameters(Type declaringType)
 		{
 			return new FieldSignature(
 				fieldType.BindTypeParameters(declaringType),
 				BindTypeParameters(declaringType, optionalCustomModifiers),
 				BindTypeParameters(declaringType, requiredCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="213" endline="219">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2758" endline="2764">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			TypeExpr[] ifaces = base.ResolveBaseTypes (out base_class);
 			base_type = TypeManager.value_type;
 			return ifaces;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="87" endline="93">
<![CDATA[
 
     Shared Function EmitBeginExceptionBlock(ByVal Info As EmitInfo) As Label
         Helper.Assert(Info.InExceptionFilter = False)
         Dim result As Label
         result = Info.ILGen.BeginExceptionBlock
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="107" endline="116">
<![CDATA[
     End Property
 
     ReadOnly Property OperandTypeCode() As TypeCode
         Get
             Dim result As TypeCode
 
             result = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, LeftType, RightType)
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BuiltInTypeExpression.vb" startline="41" endline="47">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
 
             'Return New TypeDescriptor(TypeResolution.BuiltInTypeToType(m_Type))
             Return Compiler.TypeResolution.BuiltInTypeToType(m_Type)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="84" endline="90">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal EventInfo As Mono.Cecil.EventReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.new(Classifications.EventAccess, Parent)
         m_EventInfo = EventInfo
         m_InstanceExpression = InstanceExpression
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="124" endline="133">
<![CDATA[
 
     Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, New ArgumentList(Parent, m_Parameters), ResolvedMethod)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="137" endline="143">
<![CDATA[
     End Property
 
     Property Type() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_Type IsNot Nothing)
             Return m_Type
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="183" endline="189">
<![CDATA[
 
     Sub New(ByVal ParentAndValue As Expression)
         Me.New(DirectCast(ParentAndValue, ParsedObject))
         m_Type = ParentAndValue.ExpressionType
         m_Value = ParentAndValue
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="190" endline="196">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Value As Expression)
         Me.New(DirectCast(Parent, ParsedObject))
         m_Type = Value.ExpressionType
         m_Value = Value
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="77" endline="83">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Constant As Object, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
         m_Value = Constant
         m_ExpressionType = ExpressionType
 
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="157" endline="168">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The default implementation throws an internal exception.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Overridable ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(m_Classification IsNot Nothing)
             Return m_Classification.ConstantValue
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="348" endline="359">
<![CDATA[
 
     Function DereferenceByRef() As Expression
         Dim result As Expression
 
         If CecilHelper.IsByRef(ExpressionType) Then
             result = New DeRefExpression(Me, Me)
         Else
             result = Me
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="481" endline="487">
<![CDATA[
 
 #End Region
 
     Overridable ReadOnly Property AsString() As String
         Get
             Return "<String representation of " & Me.GetType.FullName & " not implemented>"
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="40" endline="48">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadToken(Info, m_TypeName.ResolvedType)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GlobalExpression.vb" startline="36" endline="42">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
 
         Classification = New NamespaceClassification(Me, New GlobalNamespace(Me))
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="134" endline="140">
<![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_ExpressionType IsNot Nothing)
             Return m_ExpressionType
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="36" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyClassExpression.vb" startline="31" endline="39">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NothingConstantExpression.vb" startline="23" endline="30">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Emitter.EmitLoadNull(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="53" endline="61">
<![CDATA[
 
 #If DEBUG Then
     Protected MustOverride Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
 #End If
     MustOverride ReadOnly Property Keyword() As KS
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(Enums.UnaryOperators)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="53" endline="59">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             Dim value As Object = Expression.ConstantValue
             Return value
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="285" endline="295">
<![CDATA[
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="420" endline="432">
<![CDATA[
 
     ''' <summary>
     ''' Compares two vb-names (case-insensitive)
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, StringComparison.OrdinalIgnoreCase)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="437" endline="451">
<![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String, ByVal Ordinal As Boolean) As Boolean
         If Ordinal Then
             Return CompareNameOrdinal(Value1, Value2)
         Else
             Return CompareName(Value1, Value2)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="452" endline="464">
<![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareNameOrdinal(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, System.StringComparison.Ordinal)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3086" endline="3093">
<![CDATA[
 
     Shared Function IsParamArrayParameter(ByVal Context As BaseObject, ByVal Parameter As Mono.Cecil.ParameterReference) As Boolean
         Dim result As Boolean
         Dim pD As Mono.Cecil.ParameterDefinition = CecilHelper.FindDefinition(Parameter)
         result = CecilHelper.IsDefined(pD.CustomAttributes, Context.Compiler.TypeCache.System_ParamArrayAttribute)
         LogResolutionMessage(Context.Compiler, "IsParamArrayParameter
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="89" endline="95">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal strMsg As String)
         MyBase.new()
         m_Message = "There has been an internal error in the compiler
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="480" endline="490">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the flattened cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattened(ByVal Name As String, ByVal From As Mono.Cecil.TypeReference) As MemberCacheEntry
         Return LookupFlattened(Name, Helper.GetVisibility(Compiler, From, m_Type))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="491" endline="499">
<![CDATA[
 
     Public Function LookupFlattened(ByVal Name As String, ByVal Visibility As MemberVisibility) As MemberCacheEntry
         Dim result As MemberCacheEntry = Nothing
 
         Load(Name, Visibility)
 
         m_FlattenedCacheInsensitive(Visibility).TryGetValue(Name, result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="591" endline="600">
<![CDATA[
 
 End Class
 
 Public Class MemberCacheEntry
     Public Name As String
     Public Members As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
     Sub New(ByVal Name As String)
     Public Members As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
     Sub New(ByVal Name As String)
         Me.Name = Name
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="40" endline="46">
<![CDATA[
 
     Function AddNamespace(ByVal [Namespace] As String) As TypeDictionary
         Dim result As New TypeDictionary()
         Helper.Assert(MyBase.ContainsKey([Namespace]) = False)
         MyBase.Add([Namespace], result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="47" endline="62">
<![CDATA[
 
     ''' <summary>
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal [Namespace] As String) As TypeDictionary
         Get
             If MyBase.ContainsKey([Namespace]) Then
                 Return MyBase.Item([Namespace])
             Else
                 Return TypeDictionary.EmptyDictionary
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="253" endline="260">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="261" endline="269">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessageNoLocation(ByVal Message As Messages, ByVal ParamArray Parameters() As String) As Boolean
         Dim Location As Span = Nothing
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="270" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Shows the multiline message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message() As Messages, ByVal Location As Span, ByVal ParamArray Parameters()() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="278" endline="285">
<![CDATA[
 
     ''' <summary>
     ''' Saves the message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function SaveMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(True, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resources.vb" startline="41" endline="49">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' A new resource list.
     ''' </summary>	
     Sub New(ByVal Compiler As Compiler, ByVal LinkedResources As Boolean)
         m_Compiler = Compiler
         m_IsLinkedResources = LinkedResources
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="56" endline="71">
<![CDATA[
 
     ''' <summary>
     ''' Returns nothing if the specified key is not found.
     ''' </summary>
     ''' <param name="key"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal key As String) As Mono.Cecil.TypeReference
         Get
             If MyBase.ContainsKey(key) Then
                 Return MyBase.Item(key)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="162" endline="175">
<![CDATA[
 
 
     ''' <summary>
     ''' Searches for the type with the specified name.
     ''' </summary>
     ''' <param name="Name">The type's name to search for. Not case-sensitive.</param>
     ''' <param name="OnlyCreatedTypes">Specifes whether to search in all types, or only in types compiled now.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function [GetType](ByVal Name As String, ByVal OnlyCreatedTypes As Boolean) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         result.AddRange(Me.GetType(Name, Types, OnlyCreatedTypes))
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="446" endline="454">
<![CDATA[
 
     Function MakeGenericParameter(ByVal Parent As ParsedObject, ByVal OpenParameter As Mono.Cecil.ParameterReference, ByVal ParameterType As Mono.Cecil.TypeReference) As Mono.Cecil.ParameterReference
         Dim result As Mono.Cecil.ParameterReference
 
         'result = New GenericParameterDescriptor(Parent, ParameterType, OpenParameter)
         result = Nothing 
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="196" endline="203">
<![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="61" endline="72">
<![CDATA[
 
     ''' <summary>
     ''' Returns nothing if it is not a handles clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property HandlesClause() As HandlesClause
         Get
             Helper.Assert(m_Clause IsNot Nothing)
             Return TryCast(m_Clause, HandlesClause)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="73" endline="85">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if it is not an implements clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ImplementsClause() As MemberImplementsClause
         Get
             helper.Assert(m_clause IsNot Nothing)
             Return TryCast(m_Clause, MemberImplementsClause)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="44" endline="53">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Bases IsNot Nothing)
         result = Helper.ResolveTypeReferencesCollection(m_Bases)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="692" endline="698">
<![CDATA[
     End Property
 
     ReadOnly Property DefinedParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Get
             If m_DefinedParameters Is Nothing Then m_DefinedParameters = Helper.GetParameters(Compiler, Member)
             Return m_DefinedParameters
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifier(ByVal Modifier As KS) As Modifiers
         m_ModifierMask = m_ModifierMask Or KSToMask(Modifier)
         Return Me
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="62" endline="71">
<![CDATA[
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifiers(ByVal Modifier As ModifierMasks) As Modifiers
         m_ModifierMask = m_ModifierMask Or Modifier
         Return Me
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="136" endline="142">
<![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ParameterList
         Get
             Helper.Assert(m_ParameterList IsNot Nothing)
             Return m_ParameterList
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2619" endline="2627">
<![CDATA[
 
     Private Function ParseMyClassExpression(ByVal Parent As ParsedObject) As MyClassExpression
         Dim result As MyClassExpression
 
         tm.AcceptIfNotInternalError(KS.MyClass)
         result = New MyClassExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2628" endline="2636">
<![CDATA[
 
     Private Function ParseMyBaseExpression(ByVal Parent As ParsedObject) As MyBaseExpression
         Dim result As MyBaseExpression
 
         tm.AcceptIfNotInternalError(KS.MyBase)
         result = New MyBaseExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2637" endline="2645">
<![CDATA[
 
     Private Function ParseMeExpression(ByVal Parent As ParsedObject) As MeExpression
         Dim result As MeExpression
 
         tm.AcceptIfNotInternalError(KS.Me)
         result = New MeExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5150" endline="5158">
<![CDATA[
 
     ''' <summary>
     ''' EndStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEndStatement(ByVal Parent As ParsedObject) As EndStatement
         tm.AcceptIfNotInternalError(KS.End)
         Return New EndStatement(Parent)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParseTypeInfo.vb" startline="36" endline="42">
<![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler, ByVal Attributes As Attributes, ByVal [Namespace] As String, ByVal BaseType As IType)
         MyBase.New(Compiler, Attributes)
         m_Namespace = [Namespace]
         m_BaseType = BaseType
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="146" endline="153">
<![CDATA[
 
     Overridable Function CreateTypeConversion() As Boolean
         Dim result As Boolean = True
 
         m_RSide = Helper.CreateTypeConversion(Me, m_RSide, m_LSide.ExpressionType, result)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\PowerAssignStatement.vb" startline="32" endline="39">
<![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Dim result As Expression = New ExponentExpression(Me, LSide, RSide)
         result = ConversionExpression.GetTypeConversion(Me, result, LSide.ExpressionType)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="40" endline="47">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitBranchOrLeave(Info, m_Destination.GetLabel(Info), Me, m_Destination)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="48" endline="55">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.MarkLabel(Info, GetLabel(Info))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="64" endline="70">
<![CDATA[
 
     Function GetLabel(ByVal Info As EmitInfo) As Label
         If m_LabelBuilder.HasValue = False Then
             m_LabelBuilder = Emitter.DefineLabel(Info)
         End If
         Return m_LabelBuilder.Value
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="100" endline="111">
<![CDATA[
 
     Function GenerateVariableCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.IsRHS, "With variables can't be assigned to...")
 
         If Info.IsRHS Then
             Emitter.EmitLoadVariable(Info, m_WithVariable)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="130" endline="140">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The end column of the span.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public ReadOnly Property EndColumn() As Byte
         Get
             Return m_EndColumn + m_Column
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="42" endline="48">
<![CDATA[
 
     Shared Function CreateIdentifierToken(ByVal Location As Span, ByVal Identifier As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Identifier
         result.m_TokenObject = Identifier
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="67" endline="73">
<![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="81" endline="87">
<![CDATA[
 
     Shared Function CreateCharToken(ByVal Location As Span, ByVal Value As Char) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.CharLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="88" endline="94">
<![CDATA[
 
     Shared Function CreateDecimalToken(ByVal Location As Span, ByVal Value As Decimal) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DecimalLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="95" endline="101">
<![CDATA[
 
     Shared Function CreateSingleToken(ByVal Location As Span, ByVal Value As Single) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.SingleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="102" endline="108">
<![CDATA[
 
     Shared Function CreateDoubleToken(ByVal Location As Span, ByVal Value As Double) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DoubleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="109" endline="115">
<![CDATA[
 
     Shared Function CreateInt16Token(ByVal Location As Span, ByVal Value As Short) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="116" endline="122">
<![CDATA[
 
     Shared Function CreateInt32Token(ByVal Location As Span, ByVal Value As Integer) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="123" endline="129">
<![CDATA[
 
     Shared Function CreateInt64Token(ByVal Location As Span, ByVal Value As Long) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="130" endline="136">
<![CDATA[
 
     Shared Function CreateUInt16Token(ByVal Location As Span, ByVal Value As UShort) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="137" endline="143">
<![CDATA[
 
     Shared Function CreateUInt32Token(ByVal Location As Span, ByVal Value As UInteger) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="144" endline="150">
<![CDATA[
 
     Shared Function CreateUInt64Token(ByVal Location As Span, ByVal Value As ULong) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="151" endline="157">
<![CDATA[
 
     Shared Function CreateStringLiteral(ByVal Location As Span, ByVal Value As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.StringLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="158" endline="164">
<![CDATA[
 
     Shared Function CreateSymbolToken(ByVal Location As Span, ByVal Symbol As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Symbol
         result.m_TokenObject = Symbol
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="958" endline="967">
<![CDATA[
 
     ''' <summary>
     ''' Checks whether the specified Type is defined in the current compiling assembly
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedHere(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Helper.Assert(Member IsNot Nothing)
         Return Member.DeclaringType.Module.Assembly Is Compiler.AssemblyBuilderCecil
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="196" endline="202">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="74" endline="82">
<![CDATA[
     End Property
 
     Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="39" endline="47">
<![CDATA[
     End Property
 
     Private Function GetTypeAttributes() As Mono.Cecil.TypeAttributes
         Dim result As Mono.Cecil.TypeAttributes
 
         result = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="247" endline="258">
<![CDATA[
 
     ''' <summary>
     ''' Eats the current token if if coincides, if not shows a 
     ''' message "Expected
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         Return AcceptIfNotError(Special, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="331" endline="340">
<![CDATA[
     ''' <summary>
     ''' GotoNewline defaults to false for this overload.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal ParamArray MessageParameters() As String) As Boolean
         Return AcceptIfNotError(Special, Message, False, MessageParameters)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="95" endline="101">
<![CDATA[
     End Property
 
     ReadOnly Property AsNonArrayTypeName() As NonArrayTypeName
         Get
             Helper.Assert(IsNotArray)
             Return DirectCast(m_TypeName, NonArrayTypeName)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="102" endline="108">
<![CDATA[
     End Property
 
     ReadOnly Property AsArrayTypeName() As ArrayTypeName
         Get
             Helper.Assert(IsArray)
             Return DirectCast(m_TypeName, ArrayTypeName)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="382" endline="397">
<![CDATA[
 
 		public abstract UsageVector CurrentUsageVector {
 			get;
 		}				
 
 		// <summary>
 		//   Creates a sibling of the current usage vector.
 		// </summary>
 		public virtual void CreateSibling (Block block, SiblingType type)
 		{
 			UsageVector vector = new UsageVector (
 				type, Parent.CurrentUsageVector, block, Location);
 			AddSibling (vector);
 
 			Report.Debug (1, "  CREATED SIBLING", CurrentUsageVector);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="403" endline="411">
<![CDATA[
 
 		protected abstract void AddSibling (UsageVector uv);
 
 		protected abstract UsageVector Merge ();
 
 		public UsageVector MergeChild (FlowBranching child)
 		{
 			return CurrentUsageVector.MergeChild (child.Merge (), true);
  		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="539" endline="546">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			Report.Debug (2, "  MERGING SIBLINGS", Name);
 			UsageVector vector = UsageVector.MergeSiblings (sibling_list, Location);
 			Report.Debug (2, "  MERGING SIBLINGS DONE", Name, vector);
 			return vector;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="556" endline="563">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = break_origins;
 			break_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="564" endline="570">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (break_origins);
 			return vector;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="580" endline="587">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = continue_origins;
 			continue_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="588" endline="594">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (continue_origins);
 			return vector;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="671" endline="677">
<![CDATA[
 		}
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Report.Error (139, loc, "No enclosing loop out of which to break or continue");
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="684" endline="692">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement stmt)
 		{
 			vector = vector.Clone ();
 			vector.Location = stmt.loc;
 			vector.Next = return_origins;
 			return_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="756" endline="762">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddBreakOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="763" endline="769">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddContinueOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="770" endline="776">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement exit_stmt)
 		{
 			Parent.AddReturnOrigin (vector, exit_stmt);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="906" endline="927">
<![CDATA[
 				String.Format (
 					"CloneTo not implemented for expression {0}", this.GetType ()));
 		}
 
 		//
 		// Clones an expression created by the parser.
 		//
 		// We only support expressions created by the parser so far, not
 		// expressions that have been resolved (many more classes would need
 		// to implement CloneTo).
 		//
 		// This infrastructure is here merely for Lambda expressions which
 		// compile the same code using different type values for the same
 		// arguments to find the correct overload
 		//
 		public virtual Expression Clone (CloneContext clonectx)
 		{
 			Expression cloned = (Expression) MemberwiseClone ();
 			CloneTo (clonectx, cloned);
 
 			return cloned;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="928" endline="937">
<![CDATA[
 
 		//
 		// Implementation of expression to expression tree conversion
 		//
 		public abstract Expression CreateExpressionTree (ResolveContext ec);
 
 		protected Expression CreateExpressionFactoryCall (ResolveContext ec, string name, Arguments args)
 		{
 			return CreateExpressionFactoryCall (ec, name, null, args, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MemberInfo.cs" startline="43" endline="53">
<![CDATA[
 		}
 
 		public abstract Module Module
 		{
 			get;
 		}
 
 		public bool IsDefined(Type attributeType, bool inherit)
 		{
 			return CustomAttributeData.__GetCustomAttributes(this, attributeType, inherit).Count != 0;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="181" endline="187">
<![CDATA[
 
 		public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes)
 		{
 			this.attr = genericParameterAttributes;
 			// for now we'll back patch the table
 			this.ModuleBuilder.GenericParam.PatchAttribute(paramPseudoIndex, genericParameterAttributes);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="298" endline="305">
<![CDATA[
 
 		private MethodBuilder CreateMethodBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention)
 		{
 			this.ModuleBuilder.MethodDef.AddVirtualRecord();
 			MethodBuilder mb = new MethodBuilder(this, name, attributes, callingConvention);
 			methods.Add(mb);
 			return mb;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="326" endline="332">
<![CDATA[
 
 		public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			MethodBuilder mb = CreateMethodBuilder(name, attributes, callingConvention);
 			mb.SetSignature(returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 			return mb;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="369" endline="375">
<![CDATA[
 
 		public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes)
 		{
 			FieldBuilder fb = new FieldBuilder(this, fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes);
 			fields.Add(fb);
 			return fb;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="741" endline="749">
<![CDATA[
 		}
 
 		public override string Namespace
 		{
 			get
 			{
 				// for some reason, TypeBuilder doesn't return null (and mcs depends on this)
 				return base.Namespace ?? "";
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="127" endline="135">
<![CDATA[
 
 		public static int DefineNamespace (string name, CompileUnitEntry source,
 						   string[] using_clauses, int parent)
 		{
 			if (symwriter != null)
 				return symwriter.DefineNamespace (name, source, using_clauses, parent);
 			else
 				return -1;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1262" endline="1274">
<![CDATA[
 		}
 
 		#endregion
 
 		public abstract List<MissingType> ResolveMissingDependencies ();
 
 		public string[] ConditionalConditions ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Conditionals;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1275" endline="1282">
<![CDATA[
 
 		public ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Obsolete;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1283" endline="1290">
<![CDATA[
 
 		public bool IsNotCLSCompliant ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.IsNotCLSCompliant;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1651" endline="1657">
<![CDATA[
 
 		#region Properties
 
 		public IAssemblyDefinition DeclaringAssembly {
 			get {
 				return importer.GetAssemblyDefinition (provider.Module.Assembly);
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1716" endline="1723">
<![CDATA[
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.CoClass;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1724" endline="1731">
<![CDATA[
 
 		public string GetAttributeDefaultMember ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.DefaultIndexerName;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1732" endline="1739">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.AttributeUsage;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="315" endline="321">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var fs = (FieldSpec) base.InflateMember (inflator);
 			fs.memberType = inflator.Inflate (memberType);
 			return fs;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="364" endline="379">
<![CDATA[
 
 		#region Properties
 
 		//
 		// Explicit struct layout set by parent
 		//
 		public CharSet? CharSet {
 			get; set;
 		}		
 
 		#endregion
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ImplicitConversionRequired (rc, TypeManager.int32_type, Location);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1120" endline="1130">
<![CDATA[
 		
 		public int peek_token ()
 		{
 			int the_token;
 
 			PushPosition ();
 			the_token = token ();
 			PopPosition ();
 			
 			return the_token;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1701" endline="1707">
<![CDATA[
 
 		int peek_char2 ()
 		{
 			if (putback_char != -1)
 				return putback_char;
 			return reader.Peek ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="109" endline="120">
<![CDATA[
 
 		protected override bool DoResolveParameters (ResolveContext rc)
 		{
 			//
 			// Only explicit parameters can be resolved at this point
 			//
 			if (HasExplicitParameters) {
 				return Parameters.Resolve (rc);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3280" endline="3295">
<![CDATA[
 
 		public string GetFullName (string name)
 		{
 			if (!IsExplicitImpl)
 				return name;
 
 			//
 			// When dealing with explicit members a full interface type
 			// name is added to member name to avoid possible name conflicts
 			//
 			// We use CSharpName which gets us full name with benefit of
 			// replacing predefined names which saves some space and name
 			// is still unique
 			//
 			return TypeManager.CSharpName (InterfaceType) + "." + name;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="848" endline="855">
<![CDATA[
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1432" endline="1440">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (1945, loc, "An expression tree cannot contain an anonymous method expression");
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="71" endline="83">
<![CDATA[
 
 		//
 		// This routine must be overrided in derived classes and make copies
 		// of all the data that might be modified if resolved
 		// 
 		protected abstract void CloneTo (CloneContext clonectx, Statement target);
 
 		public Statement Clone (CloneContext clonectx)
 		{
 			Statement s = (Statement) this.MemberwiseClone ();
 			CloneTo (clonectx, s);
 			return s;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="106" endline="117">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="118" endline="129">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="38" endline="48">
<![CDATA[
 		}
 
 		internal abstract int RowCount { get; set; }
 
 		internal abstract void Write(MetadataWriter mw);
 		internal abstract void Read(MetadataReader mr);
 
 		internal int GetLength(MetadataWriter md)
 		{
 			return RowCount * GetRowSize(new RowSizeCalc(md));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2088" endline="2094">
<![CDATA[
 
 		#region Properties
 
 		protected int Arity {
 			get {
 				return targs == null ? 0 
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1836" endline="1846">
<![CDATA[
 		}
 
 		#endregion
 
 		public Block CreateSwitchBlock (Location start)
 		{
 			// FIXME
 			var new_block = new Block (this, start, start);
 			new_block.IsCompilerGenerated = true;
 			return new_block;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="789" endline="797">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			rc.Report.Error (1947, loc,
 				"A range variable `{0}' cannot be assigned to. Consider using `let' clause to store the value",
 				Name);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="278" endline="284">
<![CDATA[
 
 		internal int Add(Guid guid)
 		{
 			Debug.Assert(!frozen);
 			list.Add(guid);
 			return list.Count;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="175" endline="184">
<![CDATA[
 		}
 
 		#endregion
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var ps = (PropertySpec) base.InflateMember (inflator);
 			ps.memberType = inflator.Inflate (memberType);
 			return ps;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="559" endline="568">
<![CDATA[
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			IsTypePermitted ();
 
 			if (MemberType.IsStatic)
 				Error_StaticReturnType ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="590" endline="598">
<![CDATA[
 
 		protected bool DefineAccessors ()
 		{
 			first.Define (Parent);
 			if (AccessorSecond != null)
 				AccessorSecond.Define (Parent);
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1583" endline="1592">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			parameters.VerifyClsCompliance (this);
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1610" endline="1616">
<![CDATA[
 		}
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			return DeclaringType.GetSignatureForError () + ".this" + parameters.GetSignatureForError ("[", "]", parameters.Count);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1617" endline="1623">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var spec = (IndexerSpec) base.InflateMember (inflator);
 			spec.parameters = parameters.Inflate (inflator);
 			return s