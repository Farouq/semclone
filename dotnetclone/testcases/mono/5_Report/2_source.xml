<clones  ngroups="215">
<clone_group groupid="1" nfragments="16" Csharpe_files="16" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1553" endline="1626">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < byte.MinValue || Value > byte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < sbyte.MinValue || Value > sbyte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (float) char.MinValue || Value > (float) char.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1676" endline="1749">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (double) char.MinValue || Value > (double) char.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1312" endline="1378">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < Int32.MinValue || Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue || Value > UInt32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1008" endline="1069">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1189" endline="1247">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1451" endline="1503">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value > Byte.MaxValue)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context && Value > ((ulong) SByte.MaxValue))
 					throw new OverflowException ();
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context && Value > ((ulong) Int16.MaxValue))
 					throw new OverflowException ();
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value > UInt16.MaxValue)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if  (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context && Value > Int64.MaxValue)
 					throw new OverflowException ();
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value > Char.MaxValue)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="778" endline="831">
<![CDATA[
 		}		
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="672" endline="713">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short) Value, Location);
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			} if (target_type == TypeManager.int32_type)
 				  return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			} if (target_type == TypeManager.int64_type)
 				  return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="896" endline="944">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="566" endline="607">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}					
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="450" endline="483">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short) Value, Location);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort) Value, Location);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char) Value, Location);
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="113" endline="158">
<![CDATA[
 
 		public static Constant CreateConstantFromValue (TypeSpec t, object v, Location loc)
 		{
 			if (t == TypeManager.int32_type)
 				return new IntConstant ((int) v, loc);
 			if (t == TypeManager.string_type)
 				return new StringConstant ((string) v, loc);
 			if (t == TypeManager.uint32_type)
 				return new UIntConstant ((uint) v, loc);
 			if (t == TypeManager.int64_type)
 				return new LongConstant ((long) v, loc);
 			if (t == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) v, loc);
 			if (t == TypeManager.float_type)
 				return new FloatConstant ((float) v, loc);
 			if (t == TypeManager.double_type)
 				return new DoubleConstant ((double) v, loc);
 			if (t == TypeManager.short_type)
 				return new ShortConstant ((short)v, loc);
 			if (t == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)v, loc);
 			if (t == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)v, loc);
 			if (t == TypeManager.byte_type)
 				return new ByteConstant ((byte)v, loc);
 			if (t == TypeManager.char_type)
 				return new CharConstant ((char)v, loc);
 			if (t == TypeManager.bool_type)
 				return new BoolConstant ((bool) v, loc);
 			if (t == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) v, loc);
 			if (TypeManager.IsEnumType (t)) {
 				var real_type = EnumSpec.GetUnderlyingType (t);
 				return new EnumConstant (CreateConstantFromValue (real_type, v, loc).Resolve (null), t);
 			}
 			if (v == null) {
 				if (TypeManager.IsNullableType (t))
 					return Nullable.LiftedNull.Create (t, loc);
 
 				if (TypeManager.IsReferenceType (t))
 					return new NullConstant (t, loc);
 			}
 
 			throw new InternalErrorException ("Constant value `{0}' has unexpected underlying type `{1}'",
 				v, TypeManager.CSharpName (t));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1947" endline="1992">
<![CDATA[
 
 		public static Expression ExplicitUnsafe (Expression expr, TypeSpec target_type)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			if (target_type.IsPointer){
 				if (expr_type.IsPointer)
 					return EmptyCast.Create (expr, target_type);
 
 				if (expr_type == TypeManager.sbyte_type ||
 					expr_type == TypeManager.short_type ||
 					expr_type == TypeManager.int32_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I);
 
 				if (expr_type == TypeManager.ushort_type ||
 					expr_type == TypeManager.uint32_type ||
 					expr_type == TypeManager.byte_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U);
 
 				if (expr_type == TypeManager.int64_type)
 					return new ConvCast (expr, target_type, ConvCast.Mode.I8_I);
 
 				if (expr_type == TypeManager.uint64_type)
 					return new ConvCast (expr, target_type, ConvCast.Mode.U8_I);
 			}
 
 			if (expr_type.IsPointer){
 				if (target_type == TypeManager.sbyte_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I1);
 				if (target_type == TypeManager.byte_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U1);
 				if (target_type == TypeManager.short_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I2);
 				if (target_type == TypeManager.ushort_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U2);
 				if (target_type == TypeManager.int32_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I4);
 				if (target_type == TypeManager.uint32_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U4);
 				if (target_type == TypeManager.int64_type)
 					return new ConvCast (expr, target_type, ConvCast.Mode.I_I8);
 				if (target_type == TypeManager.uint64_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U8);
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1082" endline="1125">
<![CDATA[
 
 		/// <summary>
 		///   Attempts to perform an implicit constant conversion of the IntConstant
 		///   into a different data type using casts (See Implicit Constant
 		///   Expression Conversions)
 		/// </summary>
 		Constant TryImplicitIntConversion (TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type) {
 				if (Value >= SByte.MinValue && Value <= SByte.MaxValue)
 					return new SByteConstant ((sbyte) Value, loc);
 			} 
 			else if (target_type == TypeManager.byte_type) {
 				if (Value >= Byte.MinValue && Value <= Byte.MaxValue)
 					return new ByteConstant ((byte) Value, loc);
 			} 
 			else if (target_type == TypeManager.short_type) {
 				if (Value >= Int16.MinValue && Value <= Int16.MaxValue)
 					return new ShortConstant ((short) Value, loc);
 			} 
 			else if (target_type == TypeManager.ushort_type) {
 				if (Value >= UInt16.MinValue && Value <= UInt16.MaxValue)
 					return new UShortConstant ((ushort) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint32_type) {
 				if (Value >= 0)
 					return new UIntConstant ((uint) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint64_type) {
 				//
 				// we can optimize this case
 				// always fits on a uint64.  But we need an opcode
 				// to do it.
 				//
 				if (Value >= 0)
 					return new ULongConstant ((ulong) Value, loc);
 			} 
 			else if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, loc);
 			else if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5535" endline="5576">
<![CDATA[
 		}
 
 		#endregion
 
 		/// <summary>
 		/// Converts complex core type syntax like 'new int ()' to simple constant
 		/// </summary>
 		public static Constant Constantify (TypeSpec t, Location loc)
 		{
 			if (t == TypeManager.int32_type)
 				return new IntConstant (0, loc);
 			if (t == TypeManager.uint32_type)
 				return new UIntConstant (0, loc);
 			if (t == TypeManager.int64_type)
 				return new LongConstant (0, loc);
 			if (t == TypeManager.uint64_type)
 				return new ULongConstant (0, loc);
 			if (t == TypeManager.float_type)
 				return new FloatConstant (0, loc);
 			if (t == TypeManager.double_type)
 				return new DoubleConstant (0, loc);
 			if (t == TypeManager.short_type)
 				return new ShortConstant (0, loc);
 			if (t == TypeManager.ushort_type)
 				return new UShortConstant (0, loc);
 			if (t == TypeManager.sbyte_type)
 				return new SByteConstant (0, loc);
 			if (t == TypeManager.byte_type)
 				return new ByteConstant (0, loc);
 			if (t == TypeManager.char_type)
 				return new CharConstant ('\0', loc);
 			if (t == TypeManager.bool_type)
 				return new BoolConstant (false, loc);
 			if (t == TypeManager.decimal_type)
 				return new DecimalConstant (0, loc);
 			if (TypeManager.IsEnumType (t))
 				return new EnumConstant (Constantify (EnumSpec.GetUnderlyingType (t), loc), t);
 			if (TypeManager.IsNullableType (t))
 				return Nullable.LiftedNull.Create (t, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1846" endline="1874">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)Value, loc);
 			if (target_type == TypeManager.byte_type)
 				return new ByteConstant ((byte)Value, loc);
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short)Value, loc);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)Value, loc);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int)Value, loc);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint)Value, loc);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long)Value, loc);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong)Value, loc);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char)Value, loc);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float)Value, loc);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double)Value, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="2" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1305" endline="1386">
<![CDATA[
 
     Public Shared Function ConvertToSByte(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CSByte(i)
                 Return True
             Case TypeCode.Byte
                 Dim i As Byte = DirectCast(Source, Byte)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, "SByte")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "SByte")
             Case TypeCode.Decimal
                 Dim i As Decimal = DirectCast(Source, Decimal)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int16
                 Dim i As Short = DirectCast(Source, Short)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int32
                 Dim i As Integer = DirectCast(Source, Integer)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int64
                 Dim i As Long = DirectCast(Source, Long)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.SByte
                 result = Source
                 Return True
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "SByte", "String")
             Case TypeCode.UInt16
                 Dim i As UShort = DirectCast(Source, UShort)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.UInt32
                 Dim i As UInteger = DirectCast(Source, UInteger)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.UInt64
                 Dim i As ULong = DirectCast(Source, ULong)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.DBNull
                 result = CSByte(0)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "SByte")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="929" endline="1010">
<![CDATA[
 
     Public Shared Function ConvertToByte(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CByte(i)
                 Return True
             Case TypeCode.Byte
                 result = Source
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, "Byte")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Byte")
             Case TypeCode.Decimal
                 Dim i As Decimal = DirectCast(Source, Decimal)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Int16
                 Dim i As Short = DirectCast(Source, Short)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Int32
                 Dim i As Integer = DirectCast(Source, Integer)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Int64
                 Dim i As Long = DirectCast(Source, Long)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.SByte
                 Dim i As SByte = DirectCast(Source, SByte)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.UInt16
                 Dim i As UShort = DirectCast(Source, UShort)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.UInt32
                 Dim i As UInteger = DirectCast(Source, UInteger)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.UInt64
                 Dim i As ULong = DirectCast(Source, ULong)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.DBNull
                 result = CByte(0)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Byte")
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="3" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="64" endline="156">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim lvalue, rvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing OrElse rvalue Is Nothing Then
                 Return Nothing
             Else
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, tlvalue, trvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Dim tmp As UShort = CUShort(lvalue) * CUShort(rvalue)
                         If tmp < Byte.MinValue OrElse tmp > Byte.MaxValue Then
                             Return tmp
                         Else
                             Return CByte(lvalue) * CByte(rvalue)
                         End If
                     Case TypeCode.SByte
                         Dim tmp As Short = CShort(lvalue) * CShort(rvalue)
                         If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                             Return tmp
                         Else
                             Return CSByte(lvalue) * CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         Dim tmp As Integer = CInt(lvalue) * CInt(rvalue)
                         If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                             Return tmp
                         Else
                             Return CShort(lvalue) * CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Dim tmp As UInteger = CUInt(lvalue) * CUInt(rvalue)
                         If tmp > UShort.MaxValue Then
                             Return tmp
                         Else
                             Return CUShort(lvalue) * CUShort(rvalue)
                         End If
                     Case TypeCode.Int32
                         Dim tmp As Long = CLng(lvalue) * CLng(rvalue)
                         If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                             Return tmp
                         Else
                             Return CInt(lvalue) * CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Dim tmp As ULong = CULng(lvalue) * CULng(rvalue)
                         If tmp > UInteger.MaxValue Then
                             Return tmp
                         Else
                             Return CUInt(lvalue) * CUInt(rvalue)
                         End If
                     Case TypeCode.Int64
                         Dim tmp As Double
                         If CLng(rvalue) < 0 Then
                             tmp = Long.MaxValue / -CLng(rvalue)
                         Else
                             tmp = Long.MaxValue / CLng(rvalue)
                         End If
                         If CLng(lvalue) < 0 AndAlso -CLng(lvalue) > tmp OrElse CLng(lvalue) > tmp Then
                             Return CDec(lvalue) * CDec(rvalue)
                         Else
                             Return CLng(lvalue) * CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         If CULng(lvalue) > ULong.MaxValue / CULng(rvalue) Then
                             Return CDec(lvalue) * CDec(rvalue)
                         Else
                             Return CULng(lvalue) * CULng(rvalue)
                         End If
                     Case TypeCode.Double
                         Return CDbl(lvalue) * CDbl(rvalue) 'No overflow possible
                     Case TypeCode.Single
                         Return CSng(lvalue) * CSng(rvalue) 'No overflow possible
                     Case TypeCode.Decimal
                         Return CDec(lvalue) * CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="98" endline="191">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) & CStr(rvalue)
                 End If
 
                 Dim csmallest As TypeCode
                 csmallest = vbnc.TypeConverter.GetBinaryAddResultType(clvalue, crvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Dim tmp As UShort = CUShort(lvalue) + CUShort(rvalue)
                         If tmp < Byte.MinValue OrElse tmp > Byte.MaxValue Then
                             Return tmp
                         Else
                             Return CByte(tmp)
                         End If
                     Case TypeCode.SByte
                         Dim tmp As Short = CShort(lvalue) + CShort(rvalue)
                         If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                             Return tmp
                         Else
                             Return CSByte(tmp)
                         End If
                     Case TypeCode.Int16
                         Dim tmp As Integer = CInt(lvalue) + CInt(rvalue)
                         If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                             Return tmp
                         Else
                             Return CShort(tmp)
                         End If
                     Case TypeCode.UInt16
                         Dim tmp As UInteger = CUInt(lvalue) + CUInt(rvalue)
                         If tmp > UShort.MaxValue Then
                             Return tmp
                         Else
                             Return CUShort(tmp)
                         End If
                     Case TypeCode.Int32
                         Dim tmp As Long = CLng(lvalue) + CLng(rvalue)
                         If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                             Return tmp
                         Else
                             Return CInt(tmp)
                         End If
                     Case TypeCode.UInt32
                         Dim tmp As ULong = CULng(lvalue) + CULng(rvalue)
                         If tmp > UInteger.MaxValue Then
                             Return tmp
                         Else
                             Return CUInt(tmp)
                         End If
                     Case TypeCode.Int64
                         Dim tmp As Double = CLng(lvalue) + CLng(rvalue)
                         If tmp < Long.MinValue OrElse tmp > Long.MaxValue Then
                             Return tmp
                         Else
                             Return CLng(tmp)
                         End If
                     Case TypeCode.UInt64
                         Dim tmp As Double = CULng(lvalue) + CULng(rvalue)
                         If tmp < ULong.MinValue OrElse tmp > ULong.MaxValue Then
                             Return tmp
                         Else
                             Return CULng(tmp)
                         End If
                     Case TypeCode.Double
                         Return CDbl(lvalue) + CDbl(rvalue) 'No overflow possible
                     Case TypeCode.Single
                         Return CSng(lvalue) + CSng(rvalue) 'No overflow possible
                     Case TypeCode.Decimal
                         Return CDec(lvalue) + CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="70" endline="155">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = vbnc.TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, tlvalue, trvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         If CByte(lvalue) < CByte(rvalue) Then
                             Return CSByte(lvalue) - CSByte(rvalue)
                         Else
                             Return CByte(lvalue) - CByte(rvalue)
                         End If
                     Case TypeCode.SByte
                         Dim tmp As Short = CShort(lvalue) - CShort(rvalue)
                         If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                             Return tmp
                         Else
                             Return CSByte(tmp)
                         End If
                     Case TypeCode.Int16
                         Dim tmp As Integer = CInt(lvalue) - CInt(rvalue)
                         If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                             Return tmp
                         Else
                             Return CShort(tmp)
                         End If
                     Case TypeCode.UInt16
                         If CUShort(lvalue) < CUShort(rvalue) Then
                             Return CShort(lvalue) - CShort(rvalue)
                         Else
                             Return CUShort(lvalue) - CUShort(rvalue)
                         End If
                     Case TypeCode.Int32
                         Dim tmp As Long = CLng(lvalue) - CLng(rvalue)
                         If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                             Return tmp
                         Else
                             Return CInt(tmp)
                         End If
                     Case TypeCode.UInt32
                         If CUInt(lvalue) < CUInt(rvalue) Then
                             Return CInt(lvalue) - CInt(rvalue)
                         Else
                             Return CUInt(lvalue) - CUInt(rvalue)
                         End If
                     Case TypeCode.Int64
                         Dim tmp As Double = CLng(lvalue) - CLng(rvalue)
                         If tmp < Long.MinValue OrElse tmp > Long.MaxValue Then
                             Return tmp
                         Else
                             Return CLng(tmp)
                         End If
                     Case TypeCode.UInt64
                         If CULng(lvalue) < CULng(rvalue) Then
                             Return CLng(lvalue) - CLng(rvalue)
                         Else
                             Return CULng(lvalue) - CULng(rvalue)
                         End If
                     Case TypeCode.Double
                         Return CDbl(lvalue) - CDbl(rvalue) 'No overflow possible
                     Case TypeCode.Single
                         Return CSng(lvalue) - CSng(rvalue) 'No overflow possible
                     Case TypeCode.Decimal
                         Return CDec(lvalue) - CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="4" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1057" endline="1096">
<![CDATA[
 
     Public Shared Function ConvertToDateTime(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Boolean", "Date")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Byte", "Date")
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Date")
             Case TypeCode.DateTime
                 result = Source
                 Return True
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Decimal", "Date")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30533, Context.Location)
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Short", "Date")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Integer", "Date")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Long", "Date")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "SByte", "Date")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Single", "Date")
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Date")
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UShort", "Date")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UInteger", "Date")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "ULong", "Date")
             Case TypeCode.DBNull
                 result = New Date()
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Date")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1423" endline="1463">
<![CDATA[
 
     Public Shared Function ConvertToString(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Boolean", "String")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.Char
                 result = CStr(DirectCast(Source, Char))
                 Return True
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Date", "String")
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Decimal", "String")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Double", "String")
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Short", "String")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Integer", "String")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Long", "String")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "SByte", "String")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Single", "String")
             Case TypeCode.String
                 result = Source
                 Return True
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UShort", "String")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UInteger", "String")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "ULong", "String")
             Case TypeCode.DBNull
                 result = Nothing
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "String")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1011" endline="1056">
<![CDATA[
 
     Public Shared Function ConvertToChar(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Boolean", "Char")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Byte")
             Case TypeCode.Char
                 result = Source
                 Return True
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "DateTime", "Char")
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Decimal", "Char")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Double", "Char")
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Short")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Integer")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Long")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "SByte")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Single", "Char")
             Case TypeCode.String
                 Dim str As String = DirectCast(Source, String)
                 If str.Length >= 1 Then
                     result = str(0)
                 Else
                     result = CChar(Nothing)
                 End If
                 Return True
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "UShort")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "UInteger")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "ULong")
             Case TypeCode.DBNull
                 result = VB.Chr(0)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Char")
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="5" nfragments="8" Csharpe_files="0" vb_files="8" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="84" endline="148">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <= CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <= CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <= CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <= CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <= CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <= CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <= CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <= CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <= CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <= CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <= CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <= CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <= CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <= CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <= CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <= CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="78" endline="142">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) >= CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) >= CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) >= CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) >= CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) >= CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) >= CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) >= CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) >= CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) >= CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) >= CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) >= CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) >= CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) >= CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) >= CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) >= CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) >= CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="75" endline="136">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <> CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <> CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <> CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 End If
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetNotEqualsOperandType(clvalue, crvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <> CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <> CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <> CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <> CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <> CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <> CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <> CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <> CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <> CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <> CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <> CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" startline="80" endline="144">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) = CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) = CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) = CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) = CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) = CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) = CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) = CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) = CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) = CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) = CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) = CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) = CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) = CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) = CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) = CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) = CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" startline="78" endline="142">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) < CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) < CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) < CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) < CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) < CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) < CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) < CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) < CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) < CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) < CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) < CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) < CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) < CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) < CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) < CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) < CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" startline="78" endline="142">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) > CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) > CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) > CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) > CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) > CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) > CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) > CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) > CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) > CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) > CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) > CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) > CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) > CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) > CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) > CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) > CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RealDivisionExpression.vb" startline="62" endline="132">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetRealDivResultType(clvalue, crvalue)
 
                 If CDbl(rvalue) = 0 Then
                     Helper.AddError(Me, "Divide by zero")
                     Return Double.NaN
                 End If
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) / CByte(rvalue)
                     Case TypeCode.SByte
                         If CSByte(lvalue) = SByte.MinValue AndAlso CSByte(rvalue) = -1 Then
                             Return CShort(lvalue) / CShort(rvalue)
                         Else
                             Return CSByte(lvalue) / CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         If CShort(lvalue) = Short.MinValue AndAlso CShort(rvalue) = -1 Then
                             Return CInt(lvalue) / CInt(rvalue)
                         Else
                             Return CShort(lvalue) / CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) / CUShort(rvalue)
                     Case TypeCode.Int32
                         If CInt(lvalue) = Integer.MinValue AndAlso CInt(rvalue) = -1 Then
                             Return CLng(lvalue) / CLng(rvalue)
                         Else
                             Return CInt(lvalue) / CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) / CUInt(rvalue)
                     Case TypeCode.Int64
                         If CLng(lvalue) = Long.MinValue AndAlso CLng(rvalue) = -1 Then
                             Return CDec(lvalue) / CDec(rvalue)
                         Else
                             Return CLng(lvalue) / CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         Return CULng(lvalue) / CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) / CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) / CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) / CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="60" endline="135">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
                 If CDbl(rvalue) = 0 Then
                     Helper.Stop() 'TODO
                 End If
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) \ CByte(rvalue)
                     Case TypeCode.SByte
                         If CSByte(lvalue) = SByte.MinValue AndAlso CSByte(rvalue) = -1 Then
                             Return CShort(lvalue) \ CShort(rvalue)
                         Else
                             Return CSByte(lvalue) \ CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         If CShort(lvalue) = Short.MinValue AndAlso CShort(rvalue) = -1 Then
                             Return CInt(lvalue) \ CInt(rvalue)
                         Else
                             Return CShort(lvalue) \ CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) \ CUShort(rvalue)
                     Case TypeCode.Int32
                         If CInt(lvalue) = Integer.MinValue AndAlso CInt(rvalue) = -1 Then
                             Return CLng(lvalue) \ CLng(rvalue)
                         Else
                             Return CInt(lvalue) \ CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) / CUInt(rvalue)
                     Case TypeCode.Int64
                         If CLng(lvalue) = Long.MinValue AndAlso CLng(rvalue) = -1 Then
                             'Return CDec(lvalue) \ CDec(rvalue)
                             Throw New InternalException(Me)
                         Else
                             Return CLng(lvalue) \ CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         Return CULng(lvalue) \ CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) \ CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) \ CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) \ CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="6" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="359" endline="427">
<![CDATA[
 
     Public Shared Function InflateType(ByVal original As TypeReference, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
         Dim originalDef As TypeDefinition = TryCast(original, TypeDefinition)
 
         If parameters Is Nothing AndAlso arguments Is Nothing Then Return original
 
         If originalDef IsNot Nothing Then
             If originalDef.GenericParameters.Count = 0 Then Return original
             Dim result As New GenericInstanceType(originalDef)
             For i As Integer = 0 To originalDef.GenericParameters.Count - 1
                 Dim tG As GenericParameter = originalDef.GenericParameters(i)
                 If tG.Owner Is originalDef Then
                     result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), parameters, arguments))
                 Else
                     result.GenericArguments.Add(originalDef.GenericParameters(i))
                 End If
             Next
             Return result
         End If
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         Dim genParam As GenericParameter = TryCast(original, GenericParameter)
         If genParam IsNot Nothing Then
             If Not TypeOf genParam.Owner Is TypeReference Then
                 For i As Integer = 0 To parameters.Count - 1
                     If parameters(i).Owner Is genParam.Owner AndAlso parameters(i).Position = genParam.Position Then
                         Return arguments(i)
                     End If
                 Next
                 Return genParam
             End If
             Helper.Assert(genParam.Position < arguments.Count)
             Return arguments.Item(genParam.Position)
         End If
 
         If genericType IsNot Nothing Then
             Dim result As New GenericInstanceType(CecilHelper.FindDefinition(genericType.ElementType))
             For i As Integer = 0 To result.ElementType.GenericParameters.Count - 1
                 result.GenericArguments.Add(InflateType(genericType.GenericArguments(i), parameters, arguments))
             Next
             Return result
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = InflateType(spec.ElementType, parameters, arguments)
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf reference IsNot Nothing Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         Else
             Return original
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="271" endline="358">
<![CDATA[
 
     Public Shared Function InflateType(ByVal original As TypeReference, ByVal container As TypeReference) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
         Dim originalDef As TypeDefinition = TryCast(original, TypeDefinition)
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim genericCollection As GenericInstanceType = TryCast(container, GenericInstanceType)
         Dim containerDef As TypeDefinition
 
         If genericCollection Is Nothing Then
             Return original
             Throw New ArgumentException("The type to inflate with isn't generic.")
         End If
 
         If originalDef IsNot Nothing Then
             If originalDef.GenericParameters.Count = 0 Then Return original
             Dim result As New GenericInstanceType(originalDef)
             For i As Integer = 0 To originalDef.GenericParameters.Count - 1
                 Dim tG As GenericParameter = originalDef.GenericParameters(i)
                 If tG.Owner Is originalDef Then
                     result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), container))
                 Else
                     result.GenericArguments.Add(originalDef.GenericParameters(i))
                 End If
             Next
             Return result
         End If
 
         containerDef = CecilHelper.FindDefinition(container)
 
         If containerDef IsNot Nothing Then
             parameters = containerDef.GenericParameters
         Else
             parameters = genericCollection.ElementType.GenericParameters
         End If
         arguments = genericCollection.GenericArguments
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         Dim genParam As GenericParameter = TryCast(original, GenericParameter)
         If genParam IsNot Nothing Then
             If Not TypeOf genParam.Owner Is TypeReference Then Return genParam
             Helper.Assert(genParam.Position < arguments.Count)
             Return arguments.Item(genParam.Position)
         End If
 
         If genericType IsNot Nothing Then
             Dim result As New GenericInstanceType(genericType.ElementType)
             'originalDef = CecilHelper.FindDefinition(original)
             'For i As Integer = 0 To originalDef.GenericParameters.Count - 1
             '    For j As Integer = 0 To parameters.Count - 1
             '        If parameters(j) Is originalDef.GenericParameters(i) Then
             '            result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), container))
             '            Exit For
             '        End If
             '    Next
             'Next
             For i As Integer = 0 To genericType.GenericArguments.Count - 1
                 result.GenericArguments.Add(InflateType(genericType.GenericArguments(i), container))
             Next
             'Helper.Assert(result.GenericArguments.Count = parameters.Count)
             Return result
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = InflateType(spec.ElementType, container)
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf reference IsNot Nothing Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         Else
             Return original
         End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="7" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="87" endline="195">
<![CDATA[
 
 		static public RSA FromCapiPrivateKeyBlob (byte[] blob, int offset) 
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			RSAParameters rsap = new RSAParameters ();
 			try {
 				if ((blob [offset]   != 0x07) ||				// PRIVATEKEYBLOB (0x07)
 				    (blob [offset+1] != 0x02) ||				// Version (0x02)
 				    (blob [offset+2] != 0x00) ||				// Reserved (word)
 				    (blob [offset+3] != 0x00) ||
 				    (ToUInt32LE (blob, offset+8) != 0x32415352))	// DWORD magic = RSA2
 					throw new CryptographicException ("Invalid blob header");
 				
 				// ALGID (CALG_RSA_SIGN, CALG_RSA_KEYX, ...)
 				// int algId = ToInt32LE (blob, offset+4);
 
 				// DWORD bitlen
 				int bitLen = ToInt32LE (blob, offset+12);
 
 				// DWORD public exponent
 				byte[] exp = new byte [4];
 				Buffer.BlockCopy (blob, offset+16, exp, 0, 4);
 				Array.Reverse (exp);
 				rsap.Exponent = Trim (exp);
 			
 				int pos = offset+20;
 				// BYTE modulus[rsapubkey.bitlen/8];
 				int byteLen = (bitLen >> 3);
 				rsap.Modulus = new byte [byteLen];
 				Buffer.BlockCopy (blob, pos, rsap.Modulus, 0, byteLen);
 				Array.Reverse (rsap.Modulus);
 				pos += byteLen;
 
 				// BYTE prime1[rsapubkey.bitlen/16];
 				int byteHalfLen = (byteLen >> 1);
 				rsap.P = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.P, 0, byteHalfLen);
 				Array.Reverse (rsap.P);
 				pos += byteHalfLen;
 
 				// BYTE prime2[rsapubkey.bitlen/16];
 				rsap.Q = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.Q, 0, byteHalfLen);
 				Array.Reverse (rsap.Q);
 				pos += byteHalfLen;
 
 				// BYTE exponent1[rsapubkey.bitlen/16];
 				rsap.DP = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.DP, 0, byteHalfLen);
 				Array.Reverse (rsap.DP);
 				pos += byteHalfLen;
 
 				// BYTE exponent2[rsapubkey.bitlen/16];
 				rsap.DQ = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.DQ, 0, byteHalfLen);
 				Array.Reverse (rsap.DQ);
 				pos += byteHalfLen;
 
 				// BYTE coefficient[rsapubkey.bitlen/16];
 				rsap.InverseQ = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.InverseQ, 0, byteHalfLen);
 				Array.Reverse (rsap.InverseQ);
 				pos += byteHalfLen;
 
 				// ok, this is hackish but CryptoAPI support it so...
 				// note
 				// http
 				rsap.D = new byte [byteLen]; // must be allocated
 				if (pos + byteLen + offset <= blob.Length) {
 					// BYTE privateExponent[rsapubkey.bitlen/8];
 					Buffer.BlockCopy (blob, pos, rsap.D, 0, byteLen);
 					Array.Reverse (rsap.D);
 				}
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 
 #if NET_2_1
 			RSA rsa = RSA.Create ();
 			rsa.ImportParameters (rsap);
 #else
 			RSA rsa = null;
 			try {
 				rsa = RSA.Create ();
 				rsa.ImportParameters (rsap);
 			}
 			catch (CryptographicException ce) {
 				// this may cause problem when this code is run under
 				// the SYSTEM identity on Windows (e.g. ASP.NET). See
 				// http
 				try {
 					CspParameters csp = new CspParameters ();
 					csp.Flags = CspProviderFlags.UseMachineKeyStore;
 					rsa = new RSACryptoServiceProvider (csp);
 					rsa.ImportParameters (rsap);
 				}
 				catch {
 					// rethrow original, not the later, exception if this fails
 					throw ce;
 				}
 			}
 #endif
 			return rsa;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="201" endline="280">
<![CDATA[
 
 		static public DSA FromCapiPrivateKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			DSAParameters dsap = new DSAParameters ();
 			try {
 				if ((blob [offset] != 0x07) ||				// PRIVATEKEYBLOB (0x07)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x32535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.X = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.X, 0, 20);
 				Array.Reverse (dsap.X);
 				pos += 20;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 
 #if NET_2_1
 			DSA dsa = (DSA)DSA.Create ();
 			dsa.ImportParameters (dsap);
 #else
 			DSA dsa = null;
 			try {
 				dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 			}
 			catch (CryptographicException ce) {
 				// this may cause problem when this code is run under
 				// the SYSTEM identity on Windows (e.g. ASP.NET). See
 				// http
 				try {
 					CspParameters csp = new CspParameters ();
 					csp.Flags = CspProviderFlags.UseMachineKeyStore;
 					dsa = new DSACryptoServiceProvider (csp);
 					dsa.ImportParameters (dsap);
 				}
 				catch {
 					// rethrow original, not the later, exception if this fails
 					throw ce;
 				}
 			}
 #endif
 			return dsa;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="477" endline="533">
<![CDATA[
 
 		static public DSA FromCapiPublicKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			try {
 				if ((blob [offset] != 0x06) ||				// PUBLICKEYBLOB (0x06)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x31535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				DSAParameters dsap = new DSAParameters ();
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.Y = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.Y, 0, bytelen);
 				Array.Reverse (dsap.Y);
 				pos += bytelen;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 
 				DSA dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 				return dsa;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="8" nfragments="94" Csharpe_files="0" vb_files="94" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6166" endline="6256">
<![CDATA[
     ''' <summary>
     ''' ClassDeclaration  
     '''	[  Attributes  ]  [  ClassModifier+  ]  "Class"  Identifier  [  TypeParameters  ]  StatementTerminator
     '''	[  ClassBase  ]
     '''	[  TypeImplementsClause+  ]
     '''	[  ClassMemberDeclaration+  ]
     '''	"End" "Class" StatementTerminator
     ''' 
     ''' ClassBase 
     ''' </summary>
     ''' <param name="Parent">Should be the declaring type of the assembly itself it is not a nested type.</param>
     ''' <param name="Attributes"></param>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseClassDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As ClassDeclaration
         Dim result As ClassDeclaration
         Dim partialType As PartialTypeDeclaration
 
         Dim m_Attributes As Attributes
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeParameters As TypeParameters
         Dim m_Inherits As NonArrayTypeName
         Dim m_DeclaringType As TypeDeclaration
 
         m_DeclaringType = TryCast(Parent, TypeDeclaration)
         Helper.Assert(m_DeclaringType IsNot Nothing OrElse TypeOf Parent Is AssemblyDeclaration)
 
         m_Attributes = Attributes
         m_Modifiers = ParseModifiers(ModifierMasks.ClassModifiers)
 
         tm.AcceptIfNotInternalError(KS.Class)
 
         m_Identifier = ParseIdentifier(CType(Nothing, ParsedObject))
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(Nothing)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeParameters = Nothing
         End If
 
         'Here we have enough information to know if it's a partial type or not
         partialType = GetPartialType(Parent, m_Identifier, m_TypeParameters, m_Modifiers, True, [Namespace])
 
         result = TryCast(partialType, ClassDeclaration)
         If result Is Nothing Then
             If partialType IsNot Nothing Then
                 Helper.AddError(tm.Compiler, tm.CurrentLocation, "Partial types must be either all classes or all structures.")
             Else
                 'Error message has already been shown
             End If
             Return Nothing
         End If
 
         m_Identifier.Parent = result
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         If tm.Accept(KS.Inherits) Then
             m_Inherits = ParseNonArrayTypeName(result)
             If m_Inherits Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Inherits = Nothing
         End If
         If m_Inherits IsNot Nothing Then result.AddInheritsClause(m_Inherits)
 
         If TypeImplementsClauses.IsMe(tm) Then
             result.Implements = ParseTypeImplementsClauses(result)
             If result.Implements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Class) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result.CustomAttributes IsNot Nothing Then
             result.CustomAttributes.AddRange(Attributes)
         Else
             result.CustomAttributes = Attributes
         End If
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6500" endline="6567">
<![CDATA[
 
     ''' <summary>
     ''' StructureDeclaration  
     '''	[  Attributes  ]  [  StructureModifier+  ]  "Structure" Identifier  [  TypeParameters  ]	StatementTerminator
     '''	[  TypeImplementsClause+  ]
     '''	[  StructMemberDeclaration+  ]
     '''	"End" "Structure"  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseStructureDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As StructureDeclaration
         Dim result As StructureDeclaration = Nothing
         Dim partialType As PartialTypeDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeParameters As TypeParameters
         Dim m_DeclaringType As TypeDeclaration
         Dim m_Attributes As Attributes
 
         m_DeclaringType = TryCast(Parent, TypeDeclaration)
         Helper.Assert(m_DeclaringType IsNot Nothing OrElse TypeOf Parent Is AssemblyDeclaration)
 
         m_Attributes = Attributes
         m_Modifiers = ParseModifiers(ModifierMasks.StructureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Structure)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(result)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeParameters = Nothing
         End If
 
         'Here we have enough information to know if it's a partial type or not
         partialType = GetPartialType(Parent, m_Identifier, m_TypeParameters, m_Modifiers, False, [Namespace])
 
         result = TryCast(partialType, StructureDeclaration)
         If result Is Nothing Then
             If partialType IsNot Nothing Then
                 Helper.AddError(tm.Compiler, tm.CurrentLocation, "Partial types must be either all classes or all structures.")
             Else
                 'Error message has already been shown
             End If
             Return Nothing
         End If
 
         m_Identifier.Parent = result
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         result.Implements = ParseTypeImplementsClauses(result)
         If result.Implements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Structure) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4128" endline="4184">
<![CDATA[
 
     ''' <summary>
     ''' ConversionOperatorDeclaration    
     '''	[  Attributes  ]  [  ConversionOperatorModifier+  ]  "Operator" "CType" "("  Operand  ")"
     '''		[  "As"  [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConversionOperatorDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ConversionOperatorDeclaration
         Dim result As New ConversionOperatorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Operator As Token = Nothing
         Dim m_Operand As Operand = Nothing
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConversionOperatorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Operator)
 
         If vbnc.ConversionOperatorDeclaration.IsOverloadableConversionOperator(tm.CurrentToken) Then
             m_Operator = tm.CurrentToken 
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Operand = ParseOperand(result)
         If m_Operand Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Operator) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Operator, m_Operand, m_ReturnTypeAttributes, m_TypeName, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6404" endline="6459">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Interface" Identifier  [  TypeParameters  ]  StatementTerminator
     '''	[  InterfaceBase+  ]
     '''	[  InterfaceMemberDeclaration+  ]
     '''	"End" "Interface" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As InterfaceDeclaration
         Dim result As InterfaceDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_GenericName As Identifier
         Dim m_TypeParameters As TypeParameters
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Interface)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(Parent)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_GenericName = Helper.CreateGenericTypename(m_Identifier, m_TypeParameters)
         Else
             m_TypeParameters = Nothing
             m_GenericName = m_Identifier
         End If
 
         result = New InterfaceDeclaration(Parent, [Namespace], m_GenericName, m_TypeParameters)
 
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         If InterfaceBases.IsMe(tm) Then
             result.InterfaceBases = ParseInterfaceBases(result)
             If result.InterfaceBases Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If ParseInterfaceMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Interface) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4240" endline="4321">
<![CDATA[
 
 
     ''' <summary>
     ''' BinaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator"  OverloadableBinaryOperator
     '''		"("  Operand  ","  Operand  ")"  [ "As"  [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' 
     ''' UnaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator" OverloadableUnaryOperator 
     '''     "("  Operand  ")" 		[  "As" [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' OverloadableUnaryOperator  
     ''' </summary>
     ''' <remarks></remarks>
 
     Private Function ParseOperatorDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As OperatorDeclaration
         Dim result As New OperatorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_OperatorSymbol As KS
         Dim m_OperatorIdentifier As String = Nothing
         Dim m_Operand1 As Operand
         Dim m_Operand2 As Operand
         Dim m_TypeName As TypeName
         Dim m_ReturnTypeAttributes As New Attributes(Parent)
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.OperatorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Operator)
 
         If vbnc.OperatorDeclaration.IsOverloadableOperator(tm.CurrentToken) Then
             If tm.CurrentToken.IsIdentifier Then
                 m_OperatorIdentifier = DirectCast(tm.Reader.TokenData, String)
             Else
                 m_OperatorSymbol = tm.CurrentToken.Symbol
             End If
             tm.NextToken()
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Operand1 = ParseOperand(result)
         If m_Operand1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) Then
             m_Operand2 = ParseOperand(result)
             If m_Operand2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Operand2 = Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Operator) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_OperatorIdentifier, m_OperatorSymbol, m_Operand1, m_Operand2, m_ReturnTypeAttributes, m_TypeName, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4614" endline="4681">
<![CDATA[
 
     ''' <summary>
     ''' ExternalFunctionDeclaration  
     '''	[  Attributes  ]  [  ExternalMethodModifier+  ]  "Declare" [  CharsetModifier  ] "Function" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  [  As  [  Attributes  ]  TypeName  ]
     '''		StatementTerminator
     ''' 
     ''' CharsetModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalFunctionDeclaration
         Dim result As New ExternalFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS = KS.None
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList, m_ReturnTypeAttributes, m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5936" endline="6003">
<![CDATA[
 
     ''' <summary>
     ''' ForStatement  
     '''	   "For" LoopControlVariable  "="  Expression  "To"  Expression  [  "Step"  Expression  ]  StatementTerminator
     '''	      [ Block  ]
     '''	   "Next" [  NextExpressionList  ]  StatementTerminator
     ''' LoopControlVariable  
     '''	   Identifier  [  ArrayNameModifier  ] "As" TypeName  |
     '''	   Expression
     ''' NextExpressionList  
     '''	   Expression  |
     '''	   NextExpressionList "," Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseForStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ForStatement
         Dim result As New ForStatement(Parent)
 
         Dim m_LoopControlVariable As LoopControlVariable
         Dim m_LoopStartExpression As Expression
         Dim m_LoopEndExpression As Expression
         Dim m_LoopStepExpression As Expression
         Dim m_NextExpressionList As ExpressionList
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.For)
         m_LoopControlVariable = ParseLoopControlVariable(result)
         If m_LoopControlVariable Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LoopStartExpression = ParseExpression(result)
         If m_LoopStartExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.To) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LoopEndExpression = ParseExpression(result)
         If m_LoopEndExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Step) Then
             m_LoopStepExpression = ParseExpression(result)
             If m_LoopStepExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_LoopStepExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Next) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30084, tm.CurrentLocation)
             Return result
         End If
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_NextExpressionList = New ExpressionList(result)
             If ParseList(Of Expression)(m_NextExpressionList, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         Else
             m_NextExpressionList = Nothing
         End If
 
         result.Init(m_LoopControlVariable, m_LoopStartExpression, m_LoopEndExpression, m_LoopStepExpression, m_NextExpressionList, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1809" endline="1877">
<![CDATA[
 
     ''' <summary>
     ''' AddHandlerDeclaration  
     '''	[  Attributes  ]  "AddHandler" "(" ParameterList ")" LineTerminator
     '''	[  Block  ]
     '''	"End" "AddHandler" StatementTerminator
     ''' 
     ''' RemoveHandlerDeclaration  
     '''	[  Attributes  ]  "RemoveHandler" "("  ParameterList  ")"  LineTerminator
     '''	[  Block  ]
     '''	"End" "RemoveHandler" StatementTerminator
     ''' 
     ''' LAMESPEC
     ''' RemoveHandlerDeclaration  
     '''	[  Attributes  ]  "RemoveHandler" "("  [ ParameterList  ] ")"  LineTerminator
     '''	[  Block  ]
     '''	"End" "RemoveHandler" StatementTerminator
     ''' 
     ''' RaiseEventDeclaration  
     '''	[  Attributes  ]  "RaiseEvent" (  ParameterList  )  LineTerminator
     '''	[  Block  ]
     '''	"End" "RaiseEvent" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCustomEventHandlerDeclaration(ByVal Parent As EventDeclaration, ByVal Info As ParseAttributableInfo, ByVal EventName As Identifier, ByVal EventModifiers As Modifiers) As CustomEventHandlerDeclaration
         Dim result As New CustomEventHandlerDeclaration(Parent)
 
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Block As CodeBlock
         Dim m_HandlerType As KS
         Dim m_Modifiers As Modifiers
 
         If tm.CurrentToken.Equals(KS.AddHandler, KS.RemoveHandler, KS.RaiseEvent) Then
             m_HandlerType = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.RParenthesis) = False Then
             If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, m_HandlerType) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_ParameterList Is Nothing Then m_ParameterList = New ParameterList(result)
 
         If m_HandlerType = KS.RaiseEvent Then
             m_Modifiers = New Modifiers(ModifierMasks.Private)
         Else
             m_Modifiers = EventModifiers
         End If
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_ParameterList, m_Block, m_HandlerType, EventName)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4555" endline="4613">
<![CDATA[
 
     ''' <summary>
     ''' ExternalSubDeclaration 
     ''' 	[  Attributes  ]  [  ExternalMethodModifier+  ] "Declare" [  CharsetModifier  ] "Sub" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalSubDeclaration
         Dim result As New ExternalSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
 
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1650" endline="1708">
<![CDATA[
 
     ''' <summary>
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" TypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' 
     ''' LAMESPEC!!! Using the following
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" NonArrayTypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCustomEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As CustomEventDeclaration
         Dim result As New CustomEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeName As NonArrayTypeName
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
         Dim m_EventAccessorDeclarations As EventAccessorDeclarations = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError("Custom")
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_TypeName = ParseNonArrayTypeName(result)
         If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_EventAccessorDeclarations = ParseEventAccessorDeclarations(result, m_Identifier, m_Modifiers)
         If m_EventAccessorDeclarations Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Event) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_TypeName, m_ImplementsClause)
 
         result.AddMethod = m_EventAccessorDeclarations.AddHandler
         result.RemoveMethod = m_EventAccessorDeclarations.RemoveHandler
         result.RaiseMethod = m_EventAccessorDeclarations.RaiseEvent
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3526" endline="3570">
<![CDATA[
 
     ''' <summary>
     ''' ConstructorMemberDeclaration  
     ''' [  Attributes  ]  [  ConstructorModifier+  ]  "Sub" "New" [  "("  [  ParameterList  ]  ")"  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Sub" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstructorMember(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Signature As SubSignature
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstructorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
         tm.AcceptIfNotInternalError(KS.[New])
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         m_Signature = New SubSignature(result, "", m_ParameterList)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Sub) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5289" endline="5331">
<![CDATA[
 
     ''' <summary>
     ''' MidAssignmentStatement  
     '''	   "Mid" [ "$" ]  "("  Expression "," Expression  [ "," Expression  ] ")"  =  Expression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseMidAssignmentStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As MidAssignStatement
         Dim result As New MidAssignStatement(Parent)
 
         Dim m_Target As Expression
         Dim m_Start As Expression
         Dim m_Length As Expression
         Dim m_Source As Expression
 
         tm.AcceptIfNotInternalError("Mid")
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Target = ParseExpression(result)
         If m_Target Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Start = ParseExpression(result)
         If m_Start Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) Then
             m_Length = ParseExpression(result)
             If m_Length Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Length = Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.Accept(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Source = ParseExpression(result)
         If m_Source Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Target, m_Start, m_Length, m_Source)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3656" endline="3699">
<![CDATA[
 
     ''' <summary>
     ''' PropertySetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  "Set" [  (  ParameterList  )  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Set" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertySetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertySetDeclaration
         Dim result As New PropertySetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
         tm.AcceptIfNotInternalError(KS.Set)
 
         If tm.Accept(KS.LParenthesis) Then
             If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Set) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block, m_ParameterList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5892" endline="5935">
<![CDATA[
 
     ''' <summary>
     ''' ForEachStatement  
     '''	   "For" "Each" LoopControlVariable "In" Expression  StatementTerminator
     '''	         [  Block  ]
     '''	   "Next" [Expression  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseForEachStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ForEachStatement
         Dim result As New ForEachStatement(Parent)
 
         Dim m_LoopControlVariable As LoopControlVariable
         Dim m_InExpression As Expression
         Dim m_NextExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.For)
         tm.AcceptIfNotInternalError(KS.Each)
 
         m_LoopControlVariable = ParseLoopControlVariable(result)
         If m_LoopControlVariable Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.In) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_InExpression = ParseExpression(result)
         If m_InExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Next) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_NextExpression = ParseExpression(result)
             If m_NextExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_NextExpression = Nothing
         End If
 
         result.Init(m_LoopControlVariable, m_InExpression, m_NextExpression, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4322" endline="4370">
<![CDATA[
 
     ''' <summary>
     ''' FunctionDeclaration  
     '''	[  Attributes  ]  [  ProcedureModifier+  ]  "Function" FunctionSignature  [  HandlesOrImplements  ]
     '''		LineTerminator
     '''	Block
     '''	"End" "Function" StatementTerminator
     ''' 
     ''' MustOverrideFunctionDeclaration  
     '''	[  Attributes  ]  [  MustOverrideProcedureModifier+  ]  "Function" FunctionSignature
     '''		[  HandlesOrImplements  ]  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As FunctionDeclaration
         Dim result As New FunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_HandlesOrImplements As HandlesOrImplements = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverrideProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.HandlesOrImplements.IsMe(tm) Then
             m_HandlesOrImplements = ParseHandlesOrImplements(result)
             If m_HandlesOrImplements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.MustOverride) = False Then
             m_Block = ParseCodeBlock(result, False)
             If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             If tm.AcceptIfNotError(KS.End, KS.Function) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_HandlesOrImplements, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6359" endline="6403">
<![CDATA[
 
     ''' <summary>
     ''' EnumDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Enum"  Identifier  [  "As"  IntegralTypeName  ]  StatementTerminator
     '''	   EnumMemberDeclaration+
     '''	"End" "Enum"  StatementTerminator
     ''' 
     ''' LAMESPEC
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As EnumDeclaration
         Dim result As EnumDeclaration
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_QualifiedName As KS = KS.Integer
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Enum)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If tm.CurrentToken.Equals(Enums.IntegralTypeNames) Then
                 m_QualifiedName = tm.CurrentToken.Keyword
                 tm.NextToken()
             Else
                 Helper.AddError(Compiler, tm.CurrentLocation, "Enum type must be integral")
             End If
         End If
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result = New EnumDeclaration(Parent, [Namespace], m_Identifier, m_QualifiedName)
 
         If ParseEnumMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Enum) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4371" endline="4417">
<![CDATA[
 
     ''' <summary>
     ''' SubDeclaration  
     '''	[  Attributes  ]  [  ProcedureModifier+  ] "Sub" SubSignature  [  HandlesOrImplements  ]  LineTerminator
     '''	Block
     '''	"End" "Sub" StatementTerminator
     ''' 
     ''' MustOverrideSubDeclaration  
     '''	[  Attributes  ]  [  MustOverrideProcedureModifier+  ] "Sub" SubSignature  [  HandlesOrImplements  ]
     '''		StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As SubDeclaration
         Dim result As New SubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
         Dim m_HandlesOrImplements As HandlesOrImplements = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverrideProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.HandlesOrImplements.IsMe(tm) Then
             m_HandlesOrImplements = ParseHandlesOrImplements(result)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.MustOverride) = False Then
             m_Block = ParseCodeBlock(result, False)
             If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             If tm.AcceptIfNotError(KS.End, KS.Sub) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_HandlesOrImplements, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6004" endline="6039">
<![CDATA[
 
     Private Function ParseCaseClause(ByVal Parent As ParsedObject) As CaseClause
         Dim result As New CaseClause(Parent)
 
         Dim m_Expression1 As Expression
         Dim m_Expression2 As Expression = Nothing
         Dim m_Comparison As KS
 
         If tm.Accept(KS.Is) Then
             If tm.CurrentToken.Equals(CaseClause.RelationalOperators) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30239, tm.CurrentLocation)
                 m_Comparison = KS.Equals
             Else
                 m_Comparison = tm.CurrentToken.Symbol
                 tm.NextToken()
             End If
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.Equals(CaseClause.RelationalOperators) Then
             m_Comparison = tm.CurrentToken.Symbol
             tm.NextToken()
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.Accept(KS.To) Then
                 m_Expression2 = ParseExpression(result)
                 If m_Expression2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         result.Init(m_Expression1, m_Expression2, m_Comparison)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2442" endline="2487">
<![CDATA[
 
     ''' <summary>
     ''' LoopControlVariable  
     '''	   Identifier  [  ArrayNameModifier  ] "As" TypeName  |
     '''	   Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLoopControlVariable(ByVal Parent As ParsedObject) As LoopControlVariable
         Dim result As New LoopControlVariable(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
         Dim m_TypeName As TypeName = Nothing
         Dim m_Expression As Expression = Nothing
 
         'First try first option
         Dim tmpANM As ArrayNameModifier = Nothing
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim doExpression As Boolean = True
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If m_Identifier IsNot Nothing Then
             If ArrayNameModifier.CanBeMe(tm) Then
                 tmpANM = ParseArrayNameModifier(result)
                 If tmpANM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tmpANM Is Nothing AndAlso tm.Accept(KS.As) Then
                 m_ArrayNameModifier = tmpANM
                 m_TypeName = ParseTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 doExpression = False
             End If
         End If
 
         If doExpression Then
             tm.RestoreToPoint(iCurrent)
             m_Expression = ParseExpression(New ExpressionParseInfo(result, True))
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             tm.IgnoreRestoredPoint()
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier, m_TypeName, m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5652" endline="5691">
<![CDATA[
 
     ''' <summary>
     ''' CatchStatement  
     '''	   "Catch" [  Identifier "As" NonArrayTypeName  ]  [ "When" BooleanExpression  ]  StatementTerminator
     '''	      [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCatchStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CatchStatement
         Dim result As New CatchStatement(Parent)
 
         Dim m_Code As CodeBlock
         Dim m_Variable As Identifier = Nothing
         Dim m_When As Expression = Nothing
         Dim m_TypeName As NonArrayTypeName = Nothing
 
         tm.AcceptIfNotInternalError(KS.Catch)
 
         If tm.AcceptEndOfStatement(IsOneLiner) = False Then
             m_Variable = ParseIdentifier(result)
             If m_Variable IsNot Nothing Then
                 If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = ParseNonArrayTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.Accept(KS.When) Then
                 m_When = ParseExpression(result)
                 If m_When Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Variable, m_TypeName, m_When, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="555" endline="591">
<![CDATA[
 
     ''' <summary>
     ''' Attribute          
     ''' AttributeModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttribute(ByVal Parent As ParsedObject) As Attribute
         Dim result As New Attribute(Parent)
 
         Dim m_IsAssembly As Boolean
         Dim m_IsModule As Boolean
         Dim m_SimpleTypeName As SimpleTypeName = Nothing
         Dim m_AttributeArguments As AttributeArguments = Nothing
 
         If tm.Accept("Assembly") Then
             m_IsAssembly = True
             If tm.AcceptIfNotError(KS.Colon) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.Accept(KS.Module) Then
             m_IsModule = True
             If tm.AcceptIfNotError(KS.Colon) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_SimpleTypeName = ParseSimpleTypeName(result)
         If m_SimpleTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_AttributeArguments = ParseAttributeArguments(result)
                 If m_AttributeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_IsAssembly, m_IsModule, m_SimpleTypeName, m_AttributeArguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3700" endline="3734">
<![CDATA[
 
     ''' <summary>
     ''' PropertyGetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  Get  LineTerminator
     '''	[  Block  ]
     '''	End  Get  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertyGetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertyGetDeclaration
         Dim result As New PropertyGetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
 
         tm.AcceptIfNotInternalError(KS.Get)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Get) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6460" endline="6499">
<![CDATA[
 
     ''' <summary>
     ''' ModuleDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Module"  Identifier  StatementTerminator
     '''	[  ModuleMemberDeclaration+  ]
     '''	"End" "Module" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseModuleDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As ModuleDeclaration
         Dim result As ModuleDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Name As Identifier
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Module)
 
         m_Name = ParseIdentifier()
         If m_Name Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result = New ModuleDeclaration(Parent, [Namespace], m_Name)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Module) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result.CustomAttributes IsNot Nothing Then
             result.CustomAttributes.AddRange(Attributes)
         Else
             result.CustomAttributes = Attributes
         End If
         result.Modifiers = m_Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5608" endline="5651">
<![CDATA[
 
     ''' <summary>
     '''TryStatement  
     '''	"Try" StatementTerminator
     '''	   [  Block  ]
     '''	[  CatchStatement+  ]
     '''	[  FinallyStatement  ]
     '''	"End" "Try" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTryStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As TryStatement
         Dim result As New TryStatement(Parent)
 
         Dim m_TryCode As CodeBlock
         Dim m_FinallyBlock As CodeBlock
         Dim m_Catches As BaseObjects(Of CatchStatement)
 
         tm.AcceptIfNotInternalError(KS.Try)
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_TryCode = ParseCodeBlock(result, IsOneLiner)
         If m_TryCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Catches = New BaseObjects(Of CatchStatement)(result)
         While tm.CurrentToken = KS.Catch
             Dim newCatch As CatchStatement
             newCatch = ParseCatchStatement(result, IsOneLiner)
             m_Catches.Add(newCatch)
         End While
         While tm.CurrentToken = KS.Catch
             Dim newCatch As CatchStatement
             newCatch = ParseCatchStatement(result, IsOneLiner)
             m_Catches.Add(newCatch)
         End While
 
         If tm.Accept(KS.Finally) Then
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_FinallyBlock = ParseCodeBlock(result, IsOneLiner)
             If m_FinallyBlock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_FinallyBlock = Nothing
         End If
 
         If tm.Accept(KS.End, KS.Try) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Catches, m_TryCode, m_FinallyBlock)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4464" endline="4502">
<![CDATA[
 
     ''' <summary>
     ''' EventMemberSpecifier  
     '''  QualifiedIdentifier  "."  IdentifierOrKeyword  |
     '''  MyBase  "."  IdentifierOrKeyword  |
     '''	 Me  "."  IdentifierOrKeyword
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEventMemberSpecifier(ByVal Parent As ParsedObject) As EventMemberSpecifier
         Dim result As New EventMemberSpecifier(Parent)
 
         Dim m_First As Expression
         Dim m_Second As IdentifierOrKeyword
 
         If tm.CurrentToken = KS.MyBase Then
             m_First = ParseMyBaseExpression(result)
         ElseIf tm.CurrentToken = KS.Me Then
             m_First = ParseMeExpression(result)
         Else
             Dim id As Identifier
             id = ParseIdentifier(result)
             If id Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             Dim sne As New SimpleNameExpression(result)
             sne.Init(id, New TypeArgumentList(sne))
             m_First = sne
         End If
         If m_First Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Dot) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Second = ParseIdentifierOrKeyword(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4729" endline="4761">
<![CDATA[
 
     ''' <summary>
     ''' ConstantDeclarator  
     ''' TODO
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstantDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal Modifiers As Modifiers) As ConstantDeclaration
         Dim result As New ConstantDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName = Nothing
         Dim m_ConstantExpression As Expression = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ConstantExpression = ParseExpression(result)
         If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(Modifiers, m_Identifier, m_TypeName, m_ConstantExpression)
 
         'Don't parse a StatementTerminator as the VB spec says.
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3931" endline="3974">
<![CDATA[
 
     ''' <summary>
     ''' Parameter            
     ''' ParameterModifier    
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameter(ByVal Parent As ParsedObject) As Parameter
         Helper.Assert(TypeOf Parent Is ParameterList)
         Dim result As New Parameter(DirectCast(Parent, ParameterList))
 
         Dim m_Attributes As New Attributes(result)
         Dim m_Modifiers As Modifiers
         Dim m_ParameterIdentifier As ParameterIdentifier
         Dim m_TypeName As TypeName
         Dim m_ConstantExpression As Expression
 
         If vbnc.Attributes.IsMe(tm) Then
             ParseAttributes(result, m_Attributes)
         End If
 
         m_Modifiers = ParseModifiers(ModifierMasks.ParameterModifiers)
 
         m_ParameterIdentifier = ParseParameterIdentifier(result)
         If m_ParameterIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         result.Init(m_Attributes, m_Modifiers, m_ParameterIdentifier, m_TypeName, m_ConstantExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5765" endline="5802">
<![CDATA[
 
     ''' <summary>
     ''' ElseIfStatement  
     '''	   "ElseIf" BooleanExpression  [  Then  ]  StatementTerminator
     '''	        [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseElseIfStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ElseIfStatement
         Dim result As New ElseIfStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         If tm.Accept(KS.Else) Then
             'This is not in the spec, but MS is accepting it anyway.
             'See test Bugs/aspnet2.vb for a test case.
             tm.AcceptIfNotInternalError(KS.If)
         Else
             tm.AcceptIfNotInternalError(KS.ElseIf)
         End If
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         'ElseIf cannot be a oneliner...
         tm.Accept(KS.Then) '"Then" is not required.
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If IsOneLiner Then
             Helper.AddError(Compiler, tm.CurrentLocation)
             'TODO
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_Condition)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6040" endline="6072">
<![CDATA[
 
     ''' <summary>
     ''' AddHandlerStatement  
     ''' RemoveHandlerStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddOrRemoveHandlerStatement(ByVal Parent As ParsedObject) As AddOrRemoveHandlerStatement
         Dim result As New AddOrRemoveHandlerStatement(Parent)
 
         Dim m_Event As Expression
         Dim m_EventHandler As Expression
         Dim m_IsAddHandler As Boolean
 
         If tm.Accept(KS.AddHandler) Then
             m_IsAddHandler = True
         ElseIf tm.Accept(KS.RemoveHandler) Then
             m_IsAddHandler = False
         Else
             Throw New InternalException(result)
         End If
 
         m_Event = ParseExpression(result)
         If m_Event Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_EventHandler = ParseExpression(result)
         If m_EventHandler Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Event, m_EventHandler, m_IsAddHandler)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3792" endline="3823">
<![CDATA[
 
     ''' <summary>
     ''' FunctionSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionSignature(ByVal Parent As ParsedObject) As FunctionSignature
         Dim result As New FunctionSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
         Dim m_ReturnTypeAttributes As New Attributes(result)
         Dim m_TypeName As TypeName = Nothing
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             If Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList, m_ReturnTypeAttributes, m_TypeName, New Span(m_Identifier.Location, tm.CurrentLocation))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5803" endline="5839">
<![CDATA[
 
     ''' <summary>
     ''' SelectStatement  
     '''	   "Select" [ "Case" ]  Expression  StatementTerminator
     '''	        [  CaseStatement+  ]
     '''	        [  CaseElseStatement  ]
     '''	   "End" "Select" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSelectStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SelectStatement
         Dim result As New SelectStatement(Parent)
 
         Dim m_Test As Expression
         Dim m_Cases As BaseObjects(Of CaseStatement)
 
         tm.AcceptIfNotInternalError(KS.Select)
 
         tm.Accept(KS.Case) '"Case" is not required
 
         m_Test = ParseExpression(result)
         If m_Test Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Cases = New BaseObjects(Of CaseStatement)(result)
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
 
         If tm.Accept(KS.End, KS.Select) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Test, m_Cases)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4094" endline="4127">
<![CDATA[
 
     ''' <summary>
     ''' MustOverridePropertyMemberDeclaration  
     '''	[  Attributes  ]  [  MustOverridePropertyModifier+  ]  "Property" FunctionSignature  [  ImplementsClause  ]
     '''		StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseMustOverridePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As MustOverridePropertyDeclaration
         Dim result As New MustOverridePropertyDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverridePropertyModifiers)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, , , m_ImplementsClause)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1211" endline="1243">
<![CDATA[
 
     ''' <summary>
     ''' SimpleTypeName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleTypeName(ByVal Parent As ParsedObject) As SimpleTypeName
         Dim result As New SimpleTypeName(Parent)
 
         If BuiltInTypeName.IsBuiltInTypeName(tm) Then
             Dim m_BuiltInTypeName As BuiltInTypeName
             m_BuiltInTypeName = ParseBuiltinTypeName(result)
             If m_BuiltInTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_BuiltInTypeName)
         Else
             Dim m_QualifiedIdentifier As QualifiedIdentifier
 
             If QualifiedIdentifier.CanBeQualifiedIdentifier(tm) = False Then
                 If tm.CurrentToken.IsKeyword Then
                     Compiler.Report.ShowMessage(Messages.VBNC30180, tm.CurrentLocation)
                     tm.NextToken()
                 End If
                 Return Nothing
             End If
 
             m_QualifiedIdentifier = ParseQualifiedIdentifier(result)
             If m_QualifiedIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_QualifiedIdentifier)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1772" endline="1808">
<![CDATA[
 
     ''' <summary>
     ''' RegularEventMemberDeclaration  
     ''' 	[  Attributes  ]  [  EventModifiers+  ]  "Event"  Identifier  ParametersOrType  [  ImplementsClause  ] StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRegularEventDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As RegularEventDeclaration
         Dim result As New RegularEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
         Dim m_ImplementsClause As MemberImplementsClause
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ImplementsClause = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, m_ImplementsClause)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="890" endline="921">
<![CDATA[
 
     ''' <summary>
     ''' ArraySizeInitializationModifier  
     ''' LAMESPEC this might be correct? REMOVED, CURRENTLY USING ^ SPEC!
     ''' ArraySizeInitializationModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArraySizeInitializationModifer(ByVal Parent As ParsedObject) As ArraySizeInitializationModifier
         Dim result As New ArraySizeInitializationModifier(Parent)
 
         Dim m_BoundList As BoundList = Nothing
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers = Nothing
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_BoundList = ParseBoundList(result)
         If m_BoundList Is Nothing Then
             If m_ShowErrors = False Then Return Nothing
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayTypeModifiers.CanBeMe(tm) Then
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(result)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_BoundList, m_ArrayTypeModifiers)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2518" endline="2546">
<![CDATA[
 
     ''' <summary>
     ''' DelegateCreationExpression 
     ''' ObjectCreationExpression   
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateOrObjectCreationExpression(ByVal Parent As ParsedObject) As DelegateOrObjectCreationExpression
         Dim result As New DelegateOrObjectCreationExpression(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
 
         tm.AcceptIfNotInternalError(KS.[New])
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_ArgumentList = ParseArgumentList(result)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
 
         result.Init(m_NonArrayTypeName, m_ArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4185" endline="4212">
<![CDATA[
 
     ''' <summary>
     ''' EnumMemberDeclaration  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal EnumIndex As Integer) As EnumMemberDeclaration
         Dim result As New EnumMemberDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ConstantExpression As Expression
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(EnumIndex, m_Identifier, m_ConstantExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3439" endline="3471">
<![CDATA[
 
     ''' <summary>
     ''' "TypeOf" Expression "Is" TypeName
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeOfExpression(ByVal Parent As ParsedObject) As TypeOfExpression
         Dim result As New TypeOfExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_Is As Boolean
         Dim m_Type As TypeName
 
         tm.AcceptIfNotInternalError(KS.TypeOf)
 
         m_Expression = ParseExpression(New ExpressionParseInfo(result, False, True))
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Is) Then
             m_Is = True
         ElseIf tm.Accept(KS.IsNot) Then
             m_Is = False
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Type = ParseTypeName(result)
         If m_Type Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression, m_Is, m_Type)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5840" endline="5879">
<![CDATA[
 
     ''' <summary>
     ''' CaseStatement  
     '''	   "Case" CaseClauses  StatementTerminator
     '''	        [  Block  ]
     ''' CaseElseStatement  
     '''	   "Case" "Else" StatementTerminator
     '''	   [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCaseStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CaseStatement
         Dim result As New CaseStatement(Parent)
 
         Dim m_IsElse As Boolean
         Dim m_Clauses As CaseClauses
         Dim m_Block As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Case)
         If tm.Accept(KS.Else) Then
             m_IsElse = True
             m_Clauses = Nothing
         Else
             m_Clauses = New CaseClauses(result)
             If ParseList(Of CaseClause)(m_Clauses, New ParseDelegate_Parent(Of CaseClause)(AddressOf ParseCaseClause), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         m_Block = ParseCodeBlock(result, IsOneLiner)
         If m_Block Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_IsElse, m_Clauses, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3879" endline="3905">
<![CDATA[
 
     ''' <summary>
     ''' TypeParameterConstraints  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameterConstraints(ByVal Parent As ParsedObject) As TypeParameterConstraints
         Dim result As New TypeParameterConstraints(Parent)
 
         tm.AcceptIfNotInternalError(KS.As)
 
         Dim m_ConstraintList As New ConstraintList(result)
 
         If tm.Accept(KS.LBrace) Then
             If ParseList(Of Constraint)(m_ConstraintList, New ParseDelegate_Parent(Of Constraint)(AddressOf ParseConstraint), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Dim tmpConstraint As Constraint = Nothing
             tmpConstraint = ParseConstraint(result)
             m_ConstraintList = New ConstraintList(result, tmpConstraint)
         End If
 
         result.Init(m_ConstraintList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="398" endline="429">
<![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim qi As QualifiedIdentifier
 
         qi = ParseQualifiedIdentifier(result)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result IsNot Nothing AndAlso tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             Dim ctn As ConstructedTypeName = Nothing
             tm.RestoreToPoint(iCurrent)
             ctn = ParseConstructedTypeName(result)
             If ctn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(ctn)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(qi)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2594" endline="2618">
<![CDATA[
 
     Private Function ParseNamedArgument(ByVal Parent As ParsedObject) As NamedArgument
         Dim result As New NamedArgument(Parent)
         Dim Name As String
         Dim Expression As Expression = Nothing
 
         If tm.CurrentToken.IsIdentifier Then
             Name = tm.CurrentToken.Identifier
         ElseIf tm.CurrentToken.IsKeyword Then
             Name = tm.CurrentToken.Identifier
         Else
             Throw New InternalException(result)
         End If
         tm.NextToken()
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
 
         Expression = ParseExpression(result)
         If Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.Init(Name, Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5332" endline="5359">
<![CDATA[
     ''' <summary>
     ''' WhileStatement  
     '''	   "While" BooleanExpression  StatementTerminator
     '''	         [  Block  ]
     '''	   "End" "While" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWhileStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WhileStatement
         Dim result As New WhileStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.While)
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.While) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Condition, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5360" endline="5389">
<![CDATA[
 
     ''' <summary>
     ''' WithStatement  
     '''	   "With" Expression  StatementTerminator
     '''	        [  Block  ]
     '''	   "End" "With" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWithStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WithStatement
         Dim result As New WithStatement(Parent)
 
         Dim m_WithExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.With)
 
         m_WithExpression = ParseExpression(result)
         If m_WithExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_Code = ParseCodeBlock(result, IsOneLiner)
 
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.With) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_WithExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5504" endline="5533">
<![CDATA[
 
     ''' <summary>
     '''SyncLockStatement  
     '''	"SyncLock" Expression  StatementTerminator
     '''	   [  Block  ]
     '''	"End" "SyncLock" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSyncLockStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SyncLockStatement
         Dim result As New SyncLockStatement(Parent)
 
         Dim m_Lock As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.SyncLock)
 
         m_Lock = ParseExpression(result)
         If m_Lock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.SyncLock) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Lock, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2224" endline="2253">
<![CDATA[
 
     ''' <summary>
     ''' VariableIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifier(ByVal Parent As ParsedObject) As VariableIdentifier
         Dim result As New VariableIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier
 
         If tm.CurrentToken.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ArrayNameModifier = Nothing
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2254" endline="2289">
<![CDATA[
 
     ''' <summary>
     ''' RaiseEventStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRaiseEventStatement(ByVal Parent As ParsedObject) As RaiseEventStatement
         Dim result As New RaiseEventStatement(Parent)
 
         Dim m_Event As SimpleNameExpression
         Dim m_Arguments As ArgumentList
         Dim m_Identifier As IdentifierOrKeyword
 
         tm.AcceptIfNotInternalError(KS.RaiseEvent)
 
         m_Identifier = ParseIdentifierOrKeyword(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Event = New SimpleNameExpression(result)
         m_Event.Identifier = New Identifier(m_Event, m_Identifier.Identifier, m_Identifier.Location, TypeCharacters.Characters.None)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_Arguments = ParseArgumentList(result)
                 If m_Arguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_Arguments = New ArgumentList(result)
             End If
         Else
             m_Arguments = Nothing
         End If
 
         result.Init(m_Event, m_Arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4945" endline="4966">
<![CDATA[
 
     Private Function ParseInterfacePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfacePropertyMemberDeclaration
         Dim result As New InterfacePropertyMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfacePropertyModifier)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1709" endline="1738">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceEventMemberDeclaration  
     '''	[  Attributes  ]  [  InterfaceEventModifiers+  ]  "Event"  Identifier  ParametersOrType  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceEventMemberDeclaration
         Dim result As New InterfaceEventMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
 
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceEventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="863" endline="889">
<![CDATA[
 
     ''' <summary>
     ''' ArrayNameModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayNameModifier(ByVal Parent As ParsedObject) As ArrayNameModifier
         Dim result As New ArrayNameModifier(Parent)
 
         If ArrayTypeModifiers.CanBeMe(tm) Then
             Dim newATM As ArrayTypeModifiers
             newATM = ParseArrayTypeModifiers(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(newATM)
         ElseIf ArraySizeInitializationModifier.CanBeMe(tm) Then
             Dim newASIM As ArraySizeInitializationModifier
             newASIM = ParseArraySizeInitializationModifer(result)
             If newASIM Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             result.Init(newASIM)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3824" endline="3845">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeParameters  
     ''' CHANGED
     ''' </summary>
     ''' <remarks></remarks>
     ''' 
     Private Function ParseTypeParameters(ByVal Parent As ParsedObject) As TypeParameters
         Dim result As New TypeParameters()
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptIfNotError(KS.Of) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseList(Of TypeParameter)(result.Parameters, New ParseDelegate_Parent(Of TypeParameter)(AddressOf ParseTypeParameter), result.Parameters) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1959" endline="1984">
<![CDATA[
 
     ''' <summary>
     ''' DictionaryAccessExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDictionaryAccessExpression(ByVal Parent As ParsedObject, ByVal FirstPart As Expression) As DictionaryAccessExpression
         Dim result As New DictionaryAccessExpression(Parent)
 
         Dim m_FirstPart As Expression
         Dim m_SecondPart As IdentifierOrKeyword
 
         m_FirstPart = FirstPart
         If m_FirstPart IsNot Nothing Then m_FirstPart.Parent = result
         tm.AcceptIfNotInternalError(KS.Exclamation)
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_SecondPart = ParseIdentifierOrKeyword(result)
             If m_SecondPart Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_FirstPart, m_SecondPart)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="922" endline="946">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceBase   
     ''' InterfaceBases  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceBases(ByVal Parent As ParsedObject) As InterfaceBases
         Dim result As New InterfaceBases(Parent)
         Dim tmp As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         If tmp.Count <= 0 Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2418" endline="2441">
<![CDATA[
 
     Private Function ParseArrayInitializerExpression(ByVal Parent As ParsedObject) As ArrayInitializerExpression
         Dim result As New ArrayInitializerExpression(Parent)
 
         Dim m_Initializers As New Expressions()
 
         tm.AcceptIfNotInternalError(KS.LBrace)
 
         If tm.CurrentToken <> KS.RBrace Then
             Do
                 Dim newExp As Expression
                 newExp = ParseExpression(result)
                 If newExp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 m_Initializers.Add(newExp)
             Loop While tm.Accept(KS.Comma)
         End If
 
         If tm.Accept(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Initializers)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2646" endline="2672">
<![CDATA[
     ''' <summary>
     ''' A single identifier followed by an optional type argument list.
     ''' 
     ''' SimpleNameExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleNameExpression(ByVal Parent As ParsedObject) As SimpleNameExpression
         Dim result As New SimpleNameExpression(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeArgumentList As TypeArgumentList
 
         m_Identifier = ParseIdentifier(result)
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             m_TypeArgumentList = ParseTypeArgumentList(result)
             If m_TypeArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             'If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented()
         Else
             m_TypeArgumentList = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="814" endline="839">
<![CDATA[
 
     ''' <summary>
     ''' ArrayElementInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayElementInitializer(ByVal Parent As ParsedObject) As ArrayElementInitializer
         Dim result As New ArrayElementInitializer(Parent)
 
         Dim m_VariableInitializerList As VariableInitializerList
 
         m_VariableInitializerList = New VariableInitializerList(result)
 
         tm.AcceptIfNotInternalError(KS.LBrace)
         If tm.Accept(KS.RBrace) = False Then
 
             If ParseList(Of VariableInitializer)(m_VariableInitializerList, New ParseDelegate_Parent(Of VariableInitializer)(AddressOf ParseVariableInitializer), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_VariableInitializerList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4213" endline="4239">
<![CDATA[
 
     ''' <summary>
     ''' Operand  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOperand(ByVal Parent As ParsedObject) As Operand
         Dim result As New Operand(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName
 
         tm.Accept(KS.ByVal)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4503" endline="4528">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceSubDeclaration  
     ''' [  Attributes  ]  [  InterfaceProcedureModifier+  ]  "Sub" SubSignature  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceSubDeclaration
         Dim result As New InterfaceSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="121" endline="148">
<![CDATA[
     ''' <summary>
     ''' OptionCompareStatement  
     ''' CompareOption  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionCompareStatement(ByVal Parent As BaseObject) As OptionCompareStatement
         Dim result As New OptionCompareStatement(Parent)
 
         Dim m_IsBinary As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Compare")
 
         If tm.Accept("Text") Then
             m_IsBinary = False
         ElseIf tm.Accept("Binary") Then
             m_IsBinary = True
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30207, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsBinary)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1739" endline="1771">
<![CDATA[
 
     ''' <summary>
     ''' ParametersOrType  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParametersOrType(ByVal Parent As ParsedObject) As ParametersOrType
         Dim result As New ParametersOrType(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ParameterList As ParameterList
 
         If tm.Accept(KS.As) Then
             m_NonArrayTypeName = ParseNonArrayTypeName(result)
             result.Init(m_NonArrayTypeName)
         Else
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.LParenthesis) Then
                 If tm.Accept(KS.RParenthesis) = False Then
                     If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
                     If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Else
                     m_ParameterList = New ParameterList(result)
                 End If
                 result.Init(m_ParameterList)
             Else
                 result.Init(m_ParameterList)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="721" endline="767">
<![CDATA[
 
 
 
     ''' <summary>
     ''' Type | QualifiedIdentifier ( Of [TypeArityList] )
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseGetTypeTypeName(ByVal Parent As GetTypeExpression) As GetTypeTypeName
         'TypeName |
         'QualifiedIdentifier (Of [TypeArityList])
         'TypeArityList 
         ' , |
         ' TypeParameterList ,
         Dim result As New GetTypeTypeName(Parent)
 
         'First try to parse as typename, if no 
         'success try as qualifiedidentifier.
         Dim m_TypeName As TypeName
         Dim iCurPos As RestorablePoint = tm.GetRestorablePoint
 
         m_TypeName = ParseTypeName(result)
         If m_TypeName Is Nothing Then
             tm.RestoreToPoint(iCurPos)
 
             Dim qn As QualifiedIdentifier
 
             qn = ParseQualifiedIdentifier(result)
             If qn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             tm.AcceptIfNotInternalError(KS.LParenthesis)
             tm.AcceptIfNotError(KS.Of)
 
             Dim typeArity As Integer = 1
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
 
             tm.AcceptIfNotError(KS.RParenthesis)
 
             result.Init(qn, typeArity)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(m_TypeName)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1933" endline="1958">
<![CDATA[
 
     Private Function ParseIdentifierOrKeywordWithTypeArguments(ByVal Parent As ParsedObject) As IdentifierOrKeywordWithTypeArguments
         Dim result As New IdentifierOrKeywordWithTypeArguments(Parent)
 
         Dim m_TypeArguments As TypeArgumentList
         Dim m_Token As Token
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_Token = tm.CurrentToken
             tm.NextToken()
         Else
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Return Nothing
         End If
 
         If tm.CurrentToken.Equals(KS.LParenthesis) AndAlso tm.PeekToken.Equals(KS.Of) Then
             m_TypeArguments = ParseTypeArgumentList(result)
             If m_TypeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeArguments = Nothing
         End If
 
         result.Init(m_Token, m_TypeArguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3846" endline="3878">
<![CDATA[
 
     ''' <summary>
     ''' TypeParameter  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameter(ByVal Parent As ParsedObject) As TypeParameter
         Dim result As New TypeParameter(Parent)
         Dim m_Identifier As Identifier
         Dim m_TypeParameterConstraints As TypeParameterConstraints
         Dim parentList As TypeParameterList
 
         Helper.Assert(TypeOf Parent Is TypeParameterList)
 
         parentList = DirectCast(Parent, TypeParameterList)
         result.GenericParameterPosition = parentList.Count + 1
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             result.Identifier = m_Identifier
         End If
 
         If TypeParameterConstraints.CanBeMe(tm) Then
             m_TypeParameterConstraints = ParseTypeParameterConstraints(result)
             If m_TypeParameterConstraints Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.TypeParameterConstraints = m_TypeParameterConstraints
         Else
             m_TypeParameterConstraints = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2488" endline="2517">
<![CDATA[
 
     ''' <summary>
     ''' NewExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseNewExpression(ByVal Parent As ParsedObject) As NewExpression
         Dim result As New NewExpression(Parent)
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim bShowingErrors As Boolean
 
         Dim ace As ArrayCreationExpression
 
         bShowingErrors = Me.ShowErrors
         Me.m_ShowErrors = False
         ace = ParseArrayCreationExpression(result)
         Me.m_ShowErrors = bShowingErrors
 
         If ace IsNot Nothing Then
             tm.IgnoreRestoredPoint()
             result.Init(ace)
         Else
             tm.RestoreToPoint(iCurrent)
             Dim doce As DelegateOrObjectCreationExpression
             doce = ParseDelegateOrObjectCreationExpression(result)
             If doce Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(doce)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="947" endline="971">
<![CDATA[
 
     ''' <summary>
     ''' TypeImplementsClause  
     ''' Implements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeImplementsClauses(ByVal Parent As ParsedObject) As TypeImplementsClauses
         Dim result As New TypeImplementsClauses(Parent)
 
         Dim m_Clauses As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2322" endline="2344">
<![CDATA[
 
     ''' <summary>
     ''' ParenthesizedExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParenthesizedExpression(ByVal Parent As ParsedObject) As ParenthesizedExpression
         Dim result As New ParenthesizedExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_Expression = ParseExpression(result)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4529" endline="4554">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceFunctionDeclaration  
     '''	[  Attributes  ]  [  InterfaceProcedureModifier+  ] "Function" FunctionSignature  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceFunctionDeclaration
         Dim result As New InterfaceFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2290" endline="2321">
<![CDATA[
 
     ''' <summary>
     ''' InvocationExpression
     ''' IndexExpression
     ''' Note that for the index expression the parenthesis are not optional.
     ''' This is reflected by the fact that m_ArgumentList is not nothing if 
     ''' parenthesis are provided.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInvocationOrIndexExpression(ByVal Parent As ParsedObject, ByVal First As Expression) As InvocationOrIndexExpression
         Dim result As New InvocationOrIndexExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_ArgumentList As ArgumentList
 
         m_Expression = First
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(result)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(result)
             End If
         Else
             m_ArgumentList = Nothing
         End If
 
         result.Init(m_Expression, m_ArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2993" endline="3012">
<![CDATA[
     ''' <summary>
     ''' GetTypeExpression 
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseGetTypeExpression(ByVal Parent As ParsedObject) As GetTypeExpression
         Dim result As New GetTypeExpression(Parent)
 
         tm.AcceptIfNotInternalError(KS.GetType)
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Dim m_TypeName As GetTypeTypeName
         m_TypeName = ParseGetTypeTypeName(result)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6083" endline="6103">
<![CDATA[
 
     ''' <summary>
     ''' ImportsStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsStatement(ByVal Parent As ParsedObject) As ImportsStatement
         Dim result As New ImportsStatement(Parent)
 
         Dim m_Clauses As ImportsClauses
 
         tm.AcceptIfNotInternalError(KS.Imports)
 
         m_Clauses = ParseImportsClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4418" endline="4441">
<![CDATA[
 
     ''' <summary>
     ''' HandlesOrImplements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesOrImplements(ByVal Parent As ParsedObject) As HandlesOrImplements
         Dim result As New HandlesOrImplements(Parent)
 
         If vbnc.HandlesClause.IsMe(tm) Then
             Dim m_Clause As HandlesClause
             m_Clause = ParseHandlesClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         ElseIf vbnc.MemberImplementsClause.IsMe(tm) Then
             Dim m_Clause As MemberImplementsClause
             m_Clause = ParseImplementsClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="294" endline="315">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClause(ByVal Parent As ParsedObject) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(tm) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5159" endline="5182">
<![CDATA[
 
     ''' <summary>
     '''ContinueStatement  
     '''ContinueKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseContinueStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ContinueStatement
         Dim result As New ContinueStatement(Parent)
 
         Dim m_ContinueWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Continue)
         If tm.CurrentToken.Equals(KS.Do, KS.For, KS.While) Then
             m_ContinueWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30781, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_ContinueWhat)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="656" endline="681">
<![CDATA[
 
     Private Delegate Function ParseDelegate_Parent(Of T)(ByVal Parent As ParsedObject) As T
 
     ''' <summary>
     ''' VariablePropertyInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariablePropertyInitializer(ByVal Parent As ParsedObject) As VariablePropertyInitializer
         Dim result As New VariablePropertyInitializer(Parent)
 
         Dim m_IdentifierOrKeyword As IdentifierOrKeyword
         Dim m_AttributeArgumentExpression As AttributeArgumentExpression
 
         m_IdentifierOrKeyword = ParseIdentifierOrKeyword(result)
         If m_IdentifierOrKeyword Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_AttributeArgumentExpression = ParseAttributeArgumentExpression(result)
         If m_AttributeArgumentExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IdentifierOrKeyword, m_AttributeArgumentExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3975" endline="3997">
<![CDATA[
 
     ''' <summary>
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameterIdentifier(ByVal Parent As Parameter) As ParameterIdentifier
         Dim result As New ParameterIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="348" endline="375">
<![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsAliasClause(ByVal Parent As ParsedObject) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_Second = ParseImportsNamespaceClause(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5205" endline="5222">
<![CDATA[
 
     Private Function ParseReturnStatement(ByVal Parent As ParsedObject) As ReturnStatement
         Dim result As New ReturnStatement(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Return)
         If Not tm.CurrentToken.IsEndOfStatement Then
             m_Expression = ParseExpression(result)
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression = Nothing
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4994" endline="5016">
<![CDATA[
 
     ''' <summary>
     ''' ThrowStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseThrowStatement(ByVal Parent As ParsedObject) As ThrowStatement
         Dim result As New ThrowStatement(Parent)
 
         Dim m_Exception As Expression
 
         tm.AcceptIfNotInternalError(KS.Throw)
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_Exception = ParseExpression(result)
             If m_Exception Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Exception = Nothing
         End If
 
         result.Init(m_Exception)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="202" endline="225">
<![CDATA[
 
     ''' <summary>
     ''' OptionExplicitStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionExplicitStatement(ByVal Parent As BaseObject) As OptionExplicitStatement
         Dim result As New OptionExplicitStatement(Parent)
 
         Dim m_Off As Boolean
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Explicit")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30640, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="149" endline="174">
<![CDATA[
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionInferStatement(ByVal Parent As BaseObject) As OptionInferStatement
         Dim result As New OptionInferStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Infer")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="175" endline="201">
<![CDATA[
 
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionStrictStatement(ByVal Parent As BaseObject) As OptionStrictStatement
         Dim result As New OptionStrictStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Strict")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4682" endline="4704">
<![CDATA[
 
     ''' <summary>
     ''' AliasClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAliasClause(ByVal Parent As ParsedObject) As AliasClause
         Dim result As New AliasClause(Parent)
 
         Dim m_StringLiteral As Token = Nothing
 
         tm.AcceptIfNotInternalError(KS.Alias)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4705" endline="4728">
<![CDATA[
 
     ''' <summary>
     ''' LibraryClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLibraryClause(ByVal Parent As ParsedObject) As LibraryClause
         Dim result As New LibraryClause(Parent)
 
         Dim m_StringLiteral As Token
 
         tm.AcceptIfNotInternalError(KS.Lib)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             m_StringLiteral = Nothing
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1109" endline="1128">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeArgumentList 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeArgumentList(ByVal Parent As ParsedObject) As TypeArgumentList
         Dim result As New TypeArgumentList(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
         tm.AcceptIfNotInternalError(KS.Of)
 
         If ParseList(Of TypeName)(result, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
             Return Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1189" endline="1210">
<![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifier  
     ''' RankList  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifier(ByVal Parent As ParsedObject) As ArrayTypeModifier
         Dim result As New ArrayTypeModifier(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         Dim m_Ranks As Integer
         Do
             m_Ranks += 1
         Loop While tm.Accept(KS.Comma)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Ranks)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4059" endline="4080">
<![CDATA[
 
     ''' <summary>
     ''' ConstantMemberDeclaration  
     ''' </summary>
     ''' <remarks>
     ''' </remarks>
     Private Function ParseConstantMemberDeclarations(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstantModifiers)
 
         tm.AcceptIfNotInternalError(KS.Const)
         m_Modifiers.AddModifiers(ModifierMasks.Const)
 
         result = ParseConstantDeclarations(Parent, Info.Attributes, m_Modifiers)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3906" endline="3930">
<![CDATA[
 
     ''' <summary>
     ''' Constraint  
     ''' LAMESPEC? Using the following
     ''' Constraint  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstraint(ByVal Parent As ParsedObject) As Constraint
         Dim result As New Constraint(Parent)
 
         Dim m_Special As KS
         Dim m_TypeName As TypeName = Nothing
 
         If tm.CurrentToken.Equals(KS.[New], KS.Class, KS.Structure) Then
             m_Special = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_TypeName, m_Special)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5032" endline="5059">
<![CDATA[
 
     ''' <summary>
     ''' RedimStatement  
     ''' RedimClauses  
     '''	   RedimClause  |
     '''	   RedimClauses  ","  RedimClause
     ''' RedimClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseReDimStatement(ByVal Parent As ParsedObject) As ReDimStatement
         Dim result As New ReDimStatement(Parent)
 
         Dim m_IsPreserve As Boolean
         Dim m_Clauses As RedimClauses
 
         tm.AcceptIfNotInternalError(KS.ReDim)
         If tm.CurrentToken.Equals("Preserve") Then
             m_IsPreserve = True
             tm.NextToken()
         End If
 
         m_Clauses = ParseRedimClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsPreserve, m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1899" endline="1932">
<![CDATA[
 
     ''' <summary>
     ''' MemberAccessExpression 
     ''' MemberAccessBase 
     ''' 
     ''' TODO
     ''' LAMESPEC
     ''' MemberAccessExpression 
     ''' </summary>
     ''' <param name="FirstExpression"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseMemberAccessExpression(ByVal Parent As ParsedObject, ByVal FirstExpression As Expression) As MemberAccessExpression
         Dim result As New MemberAccessExpression(Parent)
 
         Dim m_First As Expression
         Dim m_Second As IdentifierOrKeywordWithTypeArguments
 
         m_First = FirstExpression 'Might be nothing.
         If m_First IsNot Nothing Then m_First.Parent = result
         'According to the language specification, the dot is optional,
         'but that doesn't seem to be correct... so let's make it 
         'required
         tm.AcceptIfNotInternalError(KS.Dot)
         'Specifically, this is not a MemberAccessExpression without the
         'dot, so it is an internal error.
 
         m_Second = ParseIdentifierOrKeywordWithTypeArguments(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1129" endline="1168">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeName 
     ''' 
     ''' ArrayTypeName          
     ''' ArrayTypeModifiers     
     ''' ArrayTypeModifier      
     ''' RankList               
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeName(ByVal Parent As ParsedObject) As TypeName
         Dim result As New TypeName(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers
         Dim m_ArrayTypeName As ArrayTypeName
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If m_NonArrayTypeName Is Nothing Then Return Nothing
 
         If ArrayTypeName.CanBeArrayTypeModifier(tm) Then
             m_ArrayTypeName = New ArrayTypeName(Parent)
 
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(m_ArrayTypeName)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             m_NonArrayTypeName.Parent = m_ArrayTypeName
 
             m_ArrayTypeName.Init(m_NonArrayTypeName, m_ArrayTypeModifiers)
 
             result.Init(m_ArrayTypeName)
         Else
             result.Init(m_NonArrayTypeName)
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="272" endline="293">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(str) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="840" endline="862">
<![CDATA[
 
     ''' <summary>
     ''' VariableInitializer  
     ''' RegularInitializer 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableInitializer(ByVal Parent As ParsedObject) As VariableInitializer
         Dim result As New VariableInitializer(Parent)
 
         If ArrayElementInitializer.CanBeMe(tm) Then
             Dim newAEI As ArrayElementInitializer
             newAEI = ParseArrayElementInitializer(Parent)
             If newAEI Is Nothing Then Return Nothing
             result.Init(newAEI)
         Else
             Dim newExp As Expression
             newExp = ParseExpression(Parent)
             If newExp Is Nothing Then Return Nothing
             result.Init(newExp)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5130" endline="5149">
<![CDATA[
 
     ''' <summary>
     ''' ExitStatement  
     ''' ExitKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExitStatement(ByVal Parent As ParsedObject) As ExitStatement
         Dim m_ExitWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Exit)
         If tm.CurrentToken.Equals(KS.Sub, KS.Function, KS.Property, KS.Do, KS.For, KS.Try, KS.While, KS.Select) Then
             m_ExitWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30240, tm.CurrentLocation)
             Return Nothing
         End If
 
         Return New ExitStatement(Parent, m_ExitWhat)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="9" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="58" endline="113">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim isByRef As Boolean = CecilHelper.IsByRef(Info.DesiredType)
 
         If m_Variable.InstanceExpression IsNot Nothing Then
             Dim exp As Mono.Cecil.TypeReference = m_Variable.InstanceExpression.ExpressionType
             If CecilHelper.IsValueType(exp) AndAlso CecilHelper.IsByRef(exp) = False Then
                 exp = CecilHelper.MakeByRefType(exp)
             End If
             result = m_Variable.InstanceExpression.GenerateCode(Info.Clone(Me, exp)) AndAlso result
         End If
 
         If m_Variable.FieldInfo IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, m_Variable.FieldInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         ElseIf m_Variable.LocalBuilder IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, m_Variable.LocalBuilder)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         ElseIf m_Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(m_Variable.InstanceExpression Is Nothing)
             If Info.IsRHS Then
                 Emitter.EmitLoadParameter(Info, m_Variable.ParameterInfo)
                 If CecilHelper.IsByRef(m_Variable.ParameterInfo.ParameterType) Then
                     Emitter.EmitLoadIndirect(Info, m_Variable.ParameterInfo.ParameterType)
                 End If
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         ElseIf m_Variable.ArrayVariable IsNot Nothing Then
             result = Helper.EmitLoadArrayElement(Info, m_Variable.ArrayVariable, m_Variable.Arguments) AndAlso result
         ElseIf m_Variable.Expression IsNot Nothing Then
             result = m_Variable.Expression.GenerateCode(Info) AndAlso result
         ElseIf m_Variable.Method IsNot Nothing Then
             Emitter.EmitLoadVariable(Info, m_Variable.Method.DefaultReturnVariable)
         Else
             Throw New InternalException(Me)
         End If
 
         If CecilHelper.IsByRef(Info.DesiredType) Then
             Dim elementType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, CecilHelper.GetElementType(Info.DesiredType))
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = Emitter.DeclareLocal(Info, elementType)
 
             Emitter.EmitStoreVariable(Info, local)
             Emitter.EmitLoadVariableLocation(Info, local)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="187" endline="242">
<![CDATA[
     End Property
 
 
     ''' <summary>
     ''' Loads the value of the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info) AndAlso result
         End If
 
         If FieldInfo IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, FieldInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf LocalBuilder IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, LocalBuilder)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf ParameterInfo IsNot Nothing Then
             Helper.Assert(m_InstanceExpression Is Nothing)
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, ParameterInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf m_ArrayVariable IsNot Nothing Then
             result = Helper.EmitLoadArrayElement(Info, m_ArrayVariable, m_Arguments) AndAlso result
         ElseIf m_Expression IsNot Nothing Then
             result = m_Expression.GenerateCode(Info) AndAlso result
         Else
             Throw New InternalException(Me)
         End If
 
         If CecilHelper.IsByRef(Info.DesiredType) Then
             Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(Info.DesiredType)
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = Emitter.DeclareLocal(Info, elementType)
 
             Emitter.EmitStoreVariable(Info, local)
             Emitter.EmitLoadVariableLocation(Info, local)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="10" nfragments="9" Csharpe_files="0" vb_files="9" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="265" endline="319">
<![CDATA[
 
     Function RuleAdditionSubtractionStringConcat(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleMod(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Minus, KS.Add)
             Dim DoAdd As Boolean
             DoAdd = CurrentToken.Equals(KS.Add)
             NextToken()
             RuleMod(RSide)
 
             Dim bErr As Boolean
             If TypeOf LSide Is String AndAlso TypeOf RSide Is String Then
                 'String concat
                 LSide = CStr(LSide) & CStr(RSide)
             Else
                 Dim op1, op2 As Double
                 If TypeOf LSide Is String Then
                     op1 = Double.Parse(DirectCast(LSide, String))
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 ElseIf TypeOf RSide Is String Then
                     op2 = Double.Parse(DirectCast(RSide, String))
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 Else
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 End If
 
 
                 If bErr Then
                     LSide = CDbl(0)
                 ElseIf DoAdd Then
                     LSide = op1 + op2
                 Else
                     LSide = op1 - op2
                 End If
             End If
         End While
         While CurrentToken.Equals(KS.Minus, KS.Add)
             Dim DoAdd As Boolean
             DoAdd = CurrentToken.Equals(KS.Add)
             NextToken()
             RuleMod(RSide)
 
             Dim bErr As Boolean
             If TypeOf LSide Is String AndAlso TypeOf RSide Is String Then
                 'String concat
                 LSide = CStr(LSide) & CStr(RSide)
             Else
                 Dim op1, op2 As Double
                 If TypeOf LSide Is String Then
                     op1 = Double.Parse(DirectCast(LSide, String))
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 ElseIf TypeOf RSide Is String Then
                     op2 = Double.Parse(DirectCast(RSide, String))
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 Else
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 End If
 
 
                 If bErr Then
                     LSide = CDbl(0)
                 ElseIf DoAdd Then
                     LSide = op1 + op2
                 Else
                     LSide = op1 - op2
                 End If
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="346" endline="385">
<![CDATA[
 
     Function RuleArithmeticBitshift(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleStringConcat(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="159" endline="199">
<![CDATA[
 
     Function RuleMultiplicationAndRealDivision(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleUnaryNegation(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="200" endline="233">
<![CDATA[
 
     Function RuleIntegerDivision(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleMultiplicationAndRealDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.IntDivision)
             NextToken()
             RuleMultiplicationAndRealDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf CLng(op2) = 0 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                 LSide = CDbl(0)
             Else
                 LSide = CDbl(CLng(op1) \ CLng(op2))
             End If
         End While
         While CurrentToken.Equals(KS.IntDivision)
             NextToken()
             RuleMultiplicationAndRealDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf CLng(op2) = 0 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                 LSide = CDbl(0)
             Else
                 LSide = CDbl(CLng(op1) \ CLng(op2))
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="482" endline="516">
<![CDATA[
 
     Function RuleOr_OrElse(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleAnd_AndAlso(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="447" endline="481">
<![CDATA[
 
     Function RuleAnd_AndAlso(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleNot(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="234" endline="264">
<![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="517" endline="547">
<![CDATA[
 
     Function RuleXor(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleOr_OrElse(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="105" endline="135">
<![CDATA[
 
     Function RuleExponent(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIdentifier(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="11" nfragments="6" Csharpe_files="0" vb_files="6" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1260" endline="1304">
<![CDATA[
 
     Public Shared Function ConvertToInt64(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Long"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CLng(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0L
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1170" endline="1214">
<![CDATA[
 
     Public Shared Function ConvertToInt16(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Short"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CShort(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0S
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1554" endline="1598">
<![CDATA[
 
     Public Shared Function ConvertToUInt64(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "ULong"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CULng(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0UL
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1215" endline="1259">
<![CDATA[
 
     Public Shared Function ConvertToInt32(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Integer"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CInt(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0I
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1464" endline="1508">
<![CDATA[
 
     Public Shared Function ConvertToUInt16(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "UShort"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CUShort(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0US
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1509" endline="1553">
<![CDATA[
 
     Public Shared Function ConvertToUInt32(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "UInteger"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CUInt(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0UI
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="12" nfragments="29" Csharpe_files="0" vb_files="29" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="34" endline="88">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 'Nothing to do
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.SByte, TypeCode.Int16, TypeCode.Int32
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.Int64
                 Emitter.EmitLoadI8Value(Info, 0L, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.UInt64
                 Emitter.EmitLoadI8Value(Info, 0UL, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitLoadR8Value(Info, 0.0, expType)
                 Emitter.EmitEquals(Info, expType)
                 Emitter.EmitLoadI4Value(Info, 0I, Info.Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Info.Compiler.TypeCache.System_Boolean)
             Case TypeCode.Single
                 Emitter.EmitLoadR4Value(Info, 0.0!, expType)
                 Emitter.EmitEquals(Info, expType)
                 Emitter.EmitLoadI4Value(Info, 0I, Info.Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Info.Compiler.TypeCache.System_Boolean)
             Case TypeCode.Object
                 Helper.Assert(Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object IsNot Nothing, "MS_VB_CS_Conversions_ToBoolean__Object Is Nothing")
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Helper.Assert(Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_String IsNot Nothing, "MS_VB_CS_Conversions_ToBoolean__String Is Nothing")
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_String)
             Case TypeCode.Decimal
                 Helper.Assert(Info.Compiler.TypeCache.System_Convert__ToBoolean_Decimal IsNot Nothing, "System_Convert_ToBoolean__Decimal Is Nothing")
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToBoolean_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="69" endline="122">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Boolean)
             Case TypeCode.String
                 'Nothing to do
             Case TypeCode.Char
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Char)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_DateTime)
             Case TypeCode.SByte, TypeCode.Int16
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Int32)
             Case TypeCode.Int32
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Int32)
             Case TypeCode.Int64
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Int64)
             Case TypeCode.Byte
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Byte)
             Case TypeCode.UInt16, TypeCode.UInt32
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_UInt32)
             Case TypeCode.UInt64
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_UInt64)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Double)
             Case TypeCode.Single
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Single)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_String__ctor_Array)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'No conversion necessary
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_String__ctor_Array)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99999, Expression.Location, "Can't convert")
                 End If
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="75" endline="132">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U4(Info, expType)
             Case TypeCode.UInt32
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U4_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16
                 'nothing to do
                 'Emitter.EmitConv_U4_Overflow_Underflow(Info, expType)
             Case TypeCode.UInt32
                 'nothing to do
             Case TypeCode.UInt64
                 'nothing to do
                 Emitter.EmitConv_U4_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U4_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U4_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUInteger_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUInteger_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUInteger_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt32_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="74" endline="125">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U2(Info, expType)
             Case TypeCode.UInt16
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U2_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_u2_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_u2_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U2_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt16_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="74" endline="125">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I4(Info, expType)
             Case TypeCode.Int32
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I4_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I4_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I4_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I4_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt32_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="74" endline="125">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I8(Info, expType)
             Case TypeCode.Int64
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I8_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt64_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="74" endline="125">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I2(Info, expType)
             Case TypeCode.Int16
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I2_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I2_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I2_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I2_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt16_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="74" endline="125">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I1(Info, expType)
             Case TypeCode.SByte
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I1_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I1_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I1_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I1_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToSByte_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="74" endline="125">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U8(Info, expType)
             Case TypeCode.uInt64
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U8_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_u8_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U8_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U8_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt64_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="73" endline="124">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U1(Info, expType)
             Case TypeCode.Byte
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U1_Overflow(Info, expType)
             Case TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_U1_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U1_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U1_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToByte_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="71" endline="123">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Boolean)
             Case TypeCode.Decimal
                 'Nothing to do
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16
                 Emitter.EmitConv_I4_Overflow(Info, expType)
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int32)
             Case TypeCode.Int32
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int32)
             Case TypeCode.Int64
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int64)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_U8_Overflow_Underflow(Info, expType)
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_UInt64)
             Case TypeCode.Double
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Double)
             Case TypeCode.Single
                 If Expression.IsConstant Then
                     'VBC BUG? This seems to be a bug in vbc.exe.
                     Emitter.EmitLoadDecimalValue(Info, New Decimal(CDbl(Expression.ConstantValue)))
                 Else
                     'CORRECT CODE.
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Single)
                 End If
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="74" endline="120">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Double
                 'Nothing to do
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToDouble_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="71" endline="114">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Single
                 'Nothing to do
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToSingle_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="34" endline="70">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Info.Compiler.TypeCache.System_Double.Name, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Double
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30533, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_Object)
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="34" endline="67">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 'Nothing to do
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32007, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Double, TypeCode.DateTime, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToChar_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'Nothing to do
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToChar_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="81" endline="114">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Info.Compiler.TypeCache.System_Double.Name, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Double
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30533, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="44" endline="74">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="44" endline="72">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="44" endline="70">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="44" endline="70">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="78" endline="109">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 'Nothing to do
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32007, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.String
                 'OK
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case Else
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="13" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="335" endline="384">
<![CDATA[
 
 		//
 		// Emits the right opcode to load from an array
 		//
 		public void EmitArrayLoad (ArrayContainer ac)
 		{
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetGetMethod ());
 				return;
 			}
 
 			var type = ac.Element;
 			if (TypeManager.IsEnumType (type))
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.byte_type || type == TypeManager.bool_type)
 				Emit (OpCodes.Ldelem_U1);
 			else if (type == TypeManager.sbyte_type)
 				Emit (OpCodes.Ldelem_I1);
 			else if (type == TypeManager.short_type)
 				Emit (OpCodes.Ldelem_I2);
 			else if (type == TypeManager.ushort_type || type == TypeManager.char_type)
 				Emit (OpCodes.Ldelem_U2);
 			else if (type == TypeManager.int32_type)
 				Emit (OpCodes.Ldelem_I4);
 			else if (type == TypeManager.uint32_type)
 				Emit (OpCodes.Ldelem_U4);
 			else if (type == TypeManager.uint64_type)
 				Emit (OpCodes.Ldelem_I8);
 			else if (type == TypeManager.int64_type)
 				Emit (OpCodes.Ldelem_I8);
 			else if (type == TypeManager.float_type)
 				Emit (OpCodes.Ldelem_R4);
 			else if (type == TypeManager.double_type)
 				Emit (OpCodes.Ldelem_R8);
 			else if (type == TypeManager.intptr_type)
 				Emit (OpCodes.Ldelem_I);
 			else if (TypeManager.IsStruct (type)) {
 				Emit (OpCodes.Ldelema, type);
 				Emit (OpCodes.Ldobj, type);
 			} else if (type.IsGenericParameter) {
 				Emit (OpCodes.Ldelem, type);
 			} else if (type.IsPointer)
 				Emit (OpCodes.Ldelem_I);
 			else
 				Emit (OpCodes.Ldelem_Ref);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="496" endline="539">
<![CDATA[
 
 		//
 		// Load the object from the pointer.  
 		//
 		public void EmitLoadFromPtr (TypeSpec t)
 		{
 			if (t == TypeManager.int32_type)
 				ig.Emit (OpCodes.Ldind_I4);
 			else if (t == TypeManager.uint32_type)
 				ig.Emit (OpCodes.Ldind_U4);
 			else if (t == TypeManager.short_type)
 				ig.Emit (OpCodes.Ldind_I2);
 			else if (t == TypeManager.ushort_type)
 				ig.Emit (OpCodes.Ldind_U2);
 			else if (t == TypeManager.char_type)
 				ig.Emit (OpCodes.Ldind_U2);
 			else if (t == TypeManager.byte_type)
 				ig.Emit (OpCodes.Ldind_U1);
 			else if (t == TypeManager.sbyte_type)
 				ig.Emit (OpCodes.Ldind_I1);
 			else if (t == TypeManager.uint64_type)
 				ig.Emit (OpCodes.Ldind_I8);
 			else if (t == TypeManager.int64_type)
 				ig.Emit (OpCodes.Ldind_I8);
 			else if (t == TypeManager.float_type)
 				ig.Emit (OpCodes.Ldind_R4);
 			else if (t == TypeManager.double_type)
 				ig.Emit (OpCodes.Ldind_R8);
 			else if (t == TypeManager.bool_type)
 				ig.Emit (OpCodes.Ldind_I1);
 			else if (t == TypeManager.intptr_type)
 				ig.Emit (OpCodes.Ldind_I);
 			else if (t.IsEnum) {
 				if (t == TypeManager.enum_type)
 					ig.Emit (OpCodes.Ldind_Ref);
 				else
 					EmitLoadFromPtr (EnumSpec.GetUnderlyingType (t));
 			} else if (TypeManager.IsStruct (t) || TypeManager.IsGenericParameter (t))
 				Emit (OpCodes.Ldobj, t);
 			else if (t.IsPointer)
 				ig.Emit (OpCodes.Ldind_I);
 			else
 				ig.Emit (OpCodes.Ldind_Ref);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="385" endline="426">
<![CDATA[
 
 		//
 		// Emits the right opcode to store to an array
 		//
 		public void EmitArrayStore (ArrayContainer ac)
 		{
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetSetMethod ());
 				return;
 			}
 
 			var type = ac.Element;
 
 			if (type.IsEnum)
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.byte_type || type == TypeManager.sbyte_type || type == TypeManager.bool_type)
 				Emit (OpCodes.Stelem_I1);
 			else if (type == TypeManager.short_type || type == TypeManager.ushort_type || type == TypeManager.char_type)
 				Emit (OpCodes.Stelem_I2);
 			else if (type == TypeManager.int32_type || type == TypeManager.uint32_type)
 				Emit (OpCodes.Stelem_I4);
 			else if (type == TypeManager.int64_type || type == TypeManager.uint64_type)
 				Emit (OpCodes.Stelem_I8);
 			else if (type == TypeManager.float_type)
 				Emit (OpCodes.Stelem_R4);
 			else if (type == TypeManager.double_type)
 				Emit (OpCodes.Stelem_R8);
 			else if (type == TypeManager.intptr_type)
 				Emit (OpCodes.Stobj, type);
 			else if (TypeManager.IsStruct (type))
 				Emit (OpCodes.Stobj, type);
 			else if (type.IsGenericParameter)
 				Emit (OpCodes.Stelem, type);
 			else if (type.IsPointer)
 				Emit (OpCodes.Stelem_I);
 			else
 				Emit (OpCodes.Stelem_Ref);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="14" nfragments="5" Csharpe_files="0" vb_files="5" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="155" endline="216">
<![CDATA[
 
     Function GenerateMyApplication() As Boolean
         Dim result As Boolean = True
         Dim _MyApplicationDefine As Define
         Dim _MyApplication As String
 
         _MyApplicationDefine = Compiler.CommandLine.Define("_MYAPPLICATIONTYPE")
         If _MyApplicationDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain
                     _MyApplication = "Console"
                 Case MyTypes.Windows
                     _MyApplication = "Windows"
                 Case MyTypes.WindowsForms
                     _MyApplication = "WindowsForms"
                 Case Else
                     _MyApplication = String.Empty
             End Select
         Else
             _MyApplication = _MyApplicationDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyApplication
             Case "Console"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.ApplicationBase"
             Case "WindowsForms"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase"
             Case Else
                 Return True
         End Select
 
         Code.AppendLine("    <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
         Code.AppendLine("    Friend Class MyApplication")
         Code.Append("        Inherits ") 
         'Code.AppendLine("        Public Sub New()")
         'Code.AppendLine("        End Sub")
         If Compiler.CommandLine.Target = CommandLine.Targets.Winexe AndAlso baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" Then
             Code.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _")
             Code.AppendLine("        <Global.System.Diagnostics.DebuggerHidden()> _")
             Code.AppendLine("        <Global.System.STAThread()> _")
             Code.AppendLine("        Friend Shared Sub Main(ByVal Args As String())")
             Code.AppendLine("            Global.System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering)")
             Code.AppendLine("            $GLOBALMY$.MyProject.Application.Run(Args)")
             Code.AppendLine("        End Sub")
         End If
         Code.AppendLine("    End Class")
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_AppObjectProvider As ThreadSafeObjectProvider(Of $GLOBALMY$.MyApplication) = New ThreadSafeObjectProvider(Of $GLOBALMY$.MyApplication)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Application As $GLOBALMY$.MyApplication")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_AppObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="508" endline="558">
<![CDATA[
 
     Function GenerateMyComputer() As Boolean
         Dim result As Boolean = True
         Dim _MyComputerDefine As Define
         Dim _MyComputer As String
 
         _MyComputerDefine = Compiler.CommandLine.Define("_MYCOMPUTERTYPE")
         If _MyComputerDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms
                     _MyComputer = "Windows"
                 Case MyTypes.Web, MyTypes.WebControl
                     _MyComputer = "Web"
                 Case Else
                     _MyComputer = String.Empty
             End Select
         Else
             _MyComputer = _MyComputerDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyComputer
             Case "Web"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.ServerComputer"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.Computer"
             Case Else
                 Return True
         End Select
 
         Code.AppendLine("    <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
         Code.AppendLine("    Friend Class MyComputer")
         Code.Append("        Inherits ") 
         Code.AppendLine("        <Global.System.Diagnostics.DebuggerHidden()> _")
         Code.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("        Public Sub New()")
         Code.AppendLine("        End Sub")
         Code.AppendLine("    End Class")
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_ComputerObjectProvider As ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer) = New ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Computer"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Computer As $GLOBALMY$.MyComputer")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_ComputerObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="217" endline="256">
<![CDATA[
 
     Function GenerateMyUser() As Boolean
         Dim result As Boolean = True
         Dim _MyUserDefine As Define
         Dim _MyUser As String
 
         _MyUserDefine = Compiler.CommandLine.Define("_MYUSERTYPE")
         If _MyUserDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms
                     _MyUser = "Windows"
                 Case MyTypes.Web, MyTypes.WebControl
                     _MyUser = "Web"
                 Case Else
                     _MyUser = String.Empty
             End Select
         Else
             _MyUser = _MyUserDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyUser
             Case "Web"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WebUser"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.User"
             Case Else
                 Return True
         End Select
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_UserObjectProvider As ThreadSafeObjectProvider(Of Z) = New ThreadSafeObjectProvider(Of Z)".Replace("Z", baseClass))
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.User"")> _")
         ProjectCode.Append("        Friend Shared ReadOnly Property User As ") 
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_UserObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="257" endline="354">
<![CDATA[
 
     Function GenerateMyForms() As Boolean
         Dim result As Boolean = True
         Dim _MyFormsDefine As Define
         Dim _MyForms As Boolean
 
         _MyFormsDefine = Compiler.CommandLine.Define("_MYFORMS")
         If _MyFormsDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.WindowsFormsWithCustomSubMain, MyTypes.WindowsForms
                     _MyForms = True
                 Case Else
                     _MyForms = False
             End Select
         Else
             _MyForms = CBool(_MyFormsDefine.Value)
         End If
 
         If Not _MyForms Then Return True
 
         Compiler.CommandLine.References.Add("System.Windows.Forms.dll")
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Windows.Forms.Form"", ""Create__Instance__"", ""Dispose__Instance__"", ""My.MyProject.Forms"")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyForms" & VB.vbNewLine & _
        "            <Global.System.ThreadStatic> _" & VB.vbNewLine & _
        "            Private Shared m_FormBeingCreated As Global.System.Collections.Hashtable" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As {Global.System.Windows.Forms.Form, New})(ByVal Instance As T) As T" & VB.vbNewLine & _
        "                If Instance IsNot Nothing AndAlso Instance.IsDisposed = False" & VB.vbNewLine & _
        "                    Return Instance" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                Dim TType As Type = GetType(T)" & VB.vbNewLine & _
        "                If m_FormBeingCreated Is Nothing Then" & VB.vbNewLine & _
        "                    m_FormBeingCreated = New Global.System.Collections.Hashtable()" & VB.vbNewLine & _
        "                ElseIf m_FormBeingCreated.ContainsKey(TType) Then" & VB.vbNewLine & _
        "                    Throw New InvalidOperationException(""There is a reference to a default instance from the constructor of a form, which leads to infinite recursion. Please refer to the form itself using 'Me' from within the constructor."")" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                m_FormBeingCreated.Add(TType, Nothing)" & VB.vbNewLine & _
        "                Try" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)()" & VB.vbNewLine & _
        "                Catch ex As Global.System.Reflection.TargetInvocationException" & VB.vbNewLine & _
        "                    Throw New Global.System.InvalidOperationException(""See inner exception"", ex.InnerException)" & VB.vbNewLine & _
        "                Finally" & VB.vbNewLine & _
        "                    m_FormBeingCreated.Remove(TType)" & VB.vbNewLine & _
        "                End Try" & VB.vbNewLine & _
        "                Return Nothing" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T As Global.System.Windows.Forms.Form)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance.Dispose()" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyForms)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared m_MyFormsObjectProvider As ThreadSafeObjectProvider(Of MyForms) = New ThreadSafeObjectProvider(Of MyForms)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Forms"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Forms As MyForms")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyFormsObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="355" endline="434">
<![CDATA[
 
     Function GenerateMyWebServices() As Boolean
         Dim result As Boolean = True
         Dim _MyWebServicesDefine As Define
         Dim _MyWebServices As Boolean
 
         _MyWebServicesDefine = Compiler.CommandLine.Define("_MYWEBSERVICES")
         If _MyWebServicesDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms, MyTypes.WebControl
                     _MyWebServices = True
                 Case Else
                     _MyWebServices = False
             End Select
         Else
             _MyWebServices = CBool(_MyWebServicesDefine.Value)
         End If
 
         If Not _MyWebServices Then Return True
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Web.Services.Protocols.SoapHttpClientProtocol"", ""Create__Instance__"", ""Dispose__Instance__"", """")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyWebServices" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As New)(ByVal instance As T) As T" & VB.vbNewLine & _
        "                If (instance Is Nothing) Then" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                Return instance" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyWebServices)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_MyWebServicesObjectProvider As ThreadSafeObjectProvider(Of MyWebServices) = New ThreadSafeObjectProvider(Of MyWebServices)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.WebServices"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property WebServices As MyWebServices")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyWebServicesObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="15" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1097" endline="1136">
<![CDATA[
 
     Public Shared Function ConvertToDecimal(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CDec(i)
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Decimal")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Decimal")
             Case TypeCode.Decimal
                 result = Source
                 Return True
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Decimal.MinValue AndAlso i <= Decimal.MaxValue Then
                     result = CDec(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CDec(CLng(Source))
                 Return True
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= Decimal.MinValue AndAlso i <= Decimal.MaxValue Then
                     result = CDec(i)
                     Return True
                 End If
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Decimal")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CDec(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0D
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Decimal")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1387" endline="1422">
<![CDATA[
 
     Public Shared Function ConvertToSingle(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = CSng(DirectCast(Source, Boolean))
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Single")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Single")
             Case TypeCode.Decimal
                 result = CSng(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Single.MinValue AndAlso i <= Single.MaxValue Then
                     result = CSng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CSng(CLng(Source))
                 Return True
             Case TypeCode.Single
                 result = Source
                 Return True
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Single")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CSng(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0.0!
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Single")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1137" endline="1169">
<![CDATA[
 
     Public Shared Function ConvertToDouble(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = CDbl(DirectCast(Source, Boolean))
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Double")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30532, Context.Location)
             Case TypeCode.Decimal
                 result = CDbl(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 result = Source
                 Return True
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CDbl(CLng(Source))
                 Return True
             Case TypeCode.Single
                 result = CDbl(DirectCast(Source, Single))
                 Return True
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Double")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CDbl(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0.0R
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Double")
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="16" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="384" endline="421">
<![CDATA[
 
     Function TypeToKeyword(ByVal Type As Mono.Cecil.TypeReference) As KS
         If Helper.CompareType(Type, Compiler.TypeCache.System_Boolean) Then
             Return KS.Boolean
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Byte) Then
             Return KS.Byte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Char) Then
             Return KS.Char
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DateTime) Then
             Return KS.Date
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Decimal) Then
             Return KS.Decimal
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Double) Then
             Return KS.Double
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int32) Then
             Return KS.Integer
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int64) Then
             Return KS.Long
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Object) Then
             Return KS.Object
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int16) Then
             Return KS.Short
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Single) Then
             Return KS.Single
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_String) Then
             Return KS.String
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_SByte) Then
             Return KS.[SByte]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) Then
             Return KS.[UShort]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) Then
             Return KS.[UInteger]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt64) Then
             Return KS.[ULong]
         Else
             Return KS.None
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="380" endline="419">
<![CDATA[
 
     Shared Function GetTypeCode(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode
         If Helper.IsEnum(Compiler, Type) Then
             Return GetTypeCode(Compiler, Helper.GetEnumType(Compiler, Type))
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Byte) Then
             Return TypeCode.Byte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Boolean) Then
             Return TypeCode.Boolean
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Char) Then
             Return TypeCode.Char
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DateTime) Then
             Return TypeCode.DateTime
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DBNull) Then
             Return TypeCode.DBNull
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Decimal) Then
             Return TypeCode.Decimal
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Double) Then
             Return TypeCode.Double
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int16) Then
             Return TypeCode.Int16
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int32) Then
             Return TypeCode.Int32
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int64) Then
             Return TypeCode.Int64
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_SByte) Then
             Return TypeCode.SByte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Single) Then
             Return TypeCode.Single
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_String) Then
             Return TypeCode.String
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) Then
             Return TypeCode.UInt16
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) Then
             Return TypeCode.UInt32
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt64) Then
             Return TypeCode.UInt64
         Else
             Return TypeCode.Object
         End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="17" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="576" endline="617">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			MetaType[] required_modifier = null;
 			if ((ModFlags & Modifiers.VOLATILE) != 0) {
 				var mod = Module.PredefinedTypes.IsVolatile.Resolve (Location);
 				if (mod != null)
 					required_modifier = new MetaType[] { mod.GetMetaInfo () };
 			}
 
 			FieldBuilder = Parent.TypeBuilder.DefineField (
 				Name, member_type.GetMetaInfo (), required_modifier, null, ModifiersExtensions.FieldAttr (ModFlags));
 
 			spec = new FieldSpec (Parent.Definition, this, MemberType, FieldBuilder, ModFlags);
 
 			// Don't cache inaccessible fields
 			if ((ModFlags & Modifiers.BACKING_FIELD) == 0) {
 				Parent.MemberCache.AddMember (spec);
 			}
 
 			if (initializer != null) {
 				((TypeContainer) Parent).RegisterFieldForInitialization (this,
 					new FieldInitializer (spec, initializer, this));
 			}
 
 			if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Fields.IndexOf (this);
 				foreach (var d in declarators) {
 					var f = new Field (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					if (d.Initializer != null)
 						f.initializer = d.Initializer;
 
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 				foreach (var d in declarators) {
 					var f = new Field (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					if (d.Initializer != null)
 						f.initializer = d.Initializer;
 
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="34" endline="76">
<![CDATA[
 
 		/// <summary>
 		///   Defines the constant in the @parent
 		/// </summary>
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!member_type.IsConstantCompatible) {
 				Error_InvalidConstantType (member_type, Location, Report);
 			}
 
 			FieldAttributes field_attr = FieldAttributes.Static | ModifiersExtensions.FieldAttr (ModFlags);
 			// Decimals cannot be emitted into the constant blob.  So, convert to 'readonly'.
 			if (member_type == TypeManager.decimal_type) {
 				field_attr |= FieldAttributes.InitOnly;
 			} else {
 				field_attr |= FieldAttributes.Literal;
 			}
 
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, MemberType.GetMetaInfo (), field_attr);
 			spec = new ConstSpec (Parent.Definition, this, MemberType, FieldBuilder, ModFlags, initializer);
 
 			Parent.MemberCache.AddMember (spec);
 
 			if ((field_attr & FieldAttributes.InitOnly) != 0)
 				Parent.PartialContainer.RegisterFieldForInitialization (this,
 					new FieldInitializer (spec, initializer, this));
 
 			if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Constants.IndexOf (this);
 				foreach (var d in declarators) {
 					var c = new Const (Parent, t, ModFlags & ~Modifiers.STATIC, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					c.initializer = d.Initializer;
 					((ConstInitializer) c.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Constants.Insert (++index, c);
 				}
 				foreach (var d in declarators) {
 					var c = new Const (Parent, t, ModFlags & ~Modifiers.STATIC, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					c.initializer = d.Initializer;
 					((ConstInitializer) c.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Constants.Insert (++index, c);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="18" nfragments="6" Csharpe_files="0" vb_files="6" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="78" endline="135">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) OrElse CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) Or CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) Or CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) Or CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) Or CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) Or CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) Or CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) Or CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) Or CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) Or CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) Or CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) Or CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="78" endline="136">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) AndAlso CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) And CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) And CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) And CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) And CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) And CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) And CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) And CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) And CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) And CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) And CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) And CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="64" endline="114">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
 
             If lvalue Is Nothing Then lvalue = 0
             If rvalue Is Nothing Then rvalue = 0
 
             Dim tlvalue, trvalue As Mono.Cecil.TypeReference
             Dim clvalue, crvalue As TypeCode
             tlvalue = CecilHelper.GetType(Compiler, lvalue)
             clvalue = Helper.GetTypeCode(Compiler, tlvalue)
             trvalue = CecilHelper.GetType(Compiler, rvalue)
             crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
             Dim smallest As Mono.Cecil.TypeReference
             Dim csmallest As TypeCode
             smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
             Helper.Assert(smallest IsNot Nothing)
             csmallest = Helper.GetTypeCode(Compiler, smallest)
 
             Select Case csmallest
                 Case TypeCode.Byte
                     Return CByte(lvalue) Mod CByte(rvalue)
                 Case TypeCode.SByte
                     Return CSByte(lvalue) Mod CSByte(rvalue)
                 Case TypeCode.Int16
                     Return CShort(lvalue) Mod CShort(rvalue)
                 Case TypeCode.UInt16
                     Return CUShort(lvalue) Mod CUShort(rvalue)
                 Case TypeCode.Int32
                     Return CInt(lvalue) Mod CInt(rvalue)
                 Case TypeCode.UInt32
                     Return CUInt(lvalue) Mod CUInt(rvalue)
                 Case TypeCode.Int64
                     Return CLng(lvalue) Mod CLng(rvalue)
                 Case TypeCode.UInt64
                     Return CULng(lvalue) Mod CULng(rvalue)
                 Case TypeCode.Double
                     Return CDbl(lvalue) Mod CDbl(rvalue)
                 Case TypeCode.Single
                     Return CSng(lvalue) Mod CSng(rvalue)
                 Case TypeCode.Decimal
                     Return CDec(lvalue) Mod CDec(rvalue)
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="60" endline="118">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) Xor CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) Xor CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) Xor CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) Xor CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) Xor CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) Xor CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) Xor CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) Xor CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) Xor CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) xor CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) xor CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) Xor CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="84" endline="135">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim shifts As Integer 'This needs to be an integer.
                 Dim tmpShifts As Object = Nothing
                 If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
                     Helper.Stop() 'Add error.
                 Else
                     shifts = CInt(tmpShifts)
                 End If
 
                 Dim tlvalue As Mono.Cecil.TypeReference
                 Dim clvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
                 Select Case clvalue
                     Case TypeCode.Byte
                         Return CByte(lvalue) >> shifts
                     Case TypeCode.SByte
                         Return CSByte(lvalue) >> shifts
                     Case TypeCode.Int16
                         Return CShort(lvalue) >> shifts
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) >> shifts
                     Case TypeCode.Int32
                         Return CInt(lvalue) >> shifts
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) >> shifts
                     Case TypeCode.Int64
                         Return CLng(lvalue) >> shifts
                     Case TypeCode.UInt64
                         Return CULng(lvalue) >> shifts
                     Case TypeCode.Double
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="83" endline="134">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim shifts As Integer 'This needs to be an integer.
                 Dim tmpShifts As Object = Nothing
                 If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
                     Helper.Stop() 'Add error.
                 Else
                     shifts = CInt(tmpShifts)
                 End If
 
                 Dim tlvalue As Mono.Cecil.TypeReference
                 Dim clvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
                 Select Case clvalue
                     Case TypeCode.Byte
                         Return CByte(lvalue) << shifts
                     Case TypeCode.SByte
                         Return CSByte(lvalue) << shifts
                     Case TypeCode.Int16
                         Return CShort(lvalue) << shifts
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) << shifts
                     Case TypeCode.Int32
                         Return CInt(lvalue) << shifts
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) << shifts
                     Case TypeCode.Int64
                         Return CLng(lvalue) << shifts
                     Case TypeCode.UInt64
                         Return CULng(lvalue) << shifts
                     Case TypeCode.Double
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="19" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2687" endline="2730">
<![CDATA[
 
     Shared Function GetMostEncompassedType(ByVal Compiler As Compiler, ByVal Types As Generic.List(Of TypeReference)) As TypeReference
         Dim result() As Boolean
 
         '?	If an intrinsic widening conversion exists from a type A to a type B, and if neither A nor B are interfaces, then A is encompassed by B, and B encompasses A.
         '?	The most encompassing type in a set of types is the one type that encompasses all other types in the set. 
         '   If no single type encompasses all other types, then the set has no most encompassing type. 
         '   In intuitive terms, the most encompassing type is the ?largest? type in the set?the one type to 
         '   which each of the other types can be converted through a widening conversion.
         '?	The most encompassed type in a set of types is the one type that is encompassed by all other types in the set. 
         '   If no single type is encompassed by all other types, then the set has no most encompassed type. 
         '   In intuitive terms, the most encompassed type is the ?smallest? type in the set?the one type that 
         '   can be converted to each of the other types through a narrowing conversion.
 
         If Types Is Nothing OrElse Types.Count = 0 Then Return Nothing
         If Types.Count = 1 Then Return Types(0)
 
         ReDim result(Types.Count - 1)
         For i As Integer = 0 To result.Length - 1
             result(i) = True
         Next
 
         For i As Integer = 0 To result.Length - 1
             For j As Integer = i + 1 To result.Length - 1
                 If result(j) AndAlso IsFirstEncompassingSecond(Compiler, Types(i), Types(j)) Then
                     result(j) = False
                 ElseIf result(i) AndAlso IsFirstEncompassingSecond(Compiler, Types(j), Types(i)) Then
                     result(i) = False
                 End If
             Next
         Next
 
         Dim count As Integer
         Dim index As Integer
         For i As Integer = 0 To result.Length - 1
             If result(i) Then
                 count += 1
                 index = i
             End If
         Next
 
         If count <> 1 Then Return Nothing
         Return Types(index)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3917" endline="3962">
<![CDATA[
 
     Shared Function GetDominantType(ByVal Compiler As Compiler, ByVal types As Generic.List(Of TypeReference)) As TypeReference
         Dim implicit() As Boolean
         Dim count As Integer
         Dim index As Integer
 
         'Given a set of types, it is often necessary in situations such as type inference to determine the dominant type of the set. 
 
         If types Is Nothing OrElse types.Count = 0 Then Return Nothing
         If types.Count = 1 Then Return types(0)
 
         ReDim implicit(types.Count - 1)
 
         For i As Integer = 0 To implicit.Length - 1
             implicit(i) = True
         Next
 
         'The dominant type of a set of types is determined by first removing any types that one or more other types do not have an implicit conversion to. 
         For i As Integer = 0 To types.Count - 1
             For j As Integer = 0 To types.Count - 1
                 If i = j Then Continue For
                 If Compiler.TypeResolution.IsImplicitlyConvertible(Compiler, types(i), types(j)) = False Then
                     implicit(j) = False
                     Exit For
                 End If
             Next
         Next
 
         count = 0
         For i As Integer = 0 To implicit.Length - 1
             If implicit(i) Then
                 index = i
                 count += 1
             End If
         Next
 
         'If there are no types left at this point, there is no dominant type. 
         If count = 0 Then Return Nothing
 
         'The dominant type is then the most encompassed of the remaining types. 
         If count = 1 Then Return types(index)
 
         'The dominant type is then the most encompassed of the remaining types. 
         'If there is more than one type that is most encompassed, then there is no dominant type. 
         Return GetMostEncompassedType(Compiler, types)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="20" nfragments="22" Csharpe_files="0" vb_files="22" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" startline="23" endline="64">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Boolean, TypeCode.Char
                 Emitter.EmitEquals(Info, OperandType)
             Case TypeCode.DateTime
                 Helper.Assert(Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime IsNot Nothing, "Date_Compare__Date_Date Is Nothing")
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Helper.Assert(Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal IsNot Nothing, "Decimal_Compare__Decimal_Decimal Is Nothing")
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean IsNot Nothing, "MS_VB_CS_Operators_ConditionalCompareObjectEqual__Object_Object_Bool Is Nothing")
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 'Compiler.Report.WriteLine("MS_VB_CS_Operators_ConditionalCompareObjectEqual__Object_Object_Bool
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Helper.Assert(Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean IsNot Nothing, "MS_VB_CS_Operators_CompareString__String_String_Bool Is Nothing")
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 'Compiler.Report.WriteLine("MS_VB_CS_Operators_CompareString__String_String_Bool
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="23" endline="58">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Boolean, TypeCode.Char
                 Emitter.EmitNotEquals(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitNotEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitnotEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectNotEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitNotEquals(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="46" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="23" endline="58">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitRShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__RightShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="23" endline="57">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitLShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__LeftShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LikeExpression.vb" startline="24" endline="52">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Dim cmInfo As EmitInfo = Info.Clone(Me, True, False, Compiler.TypeCache.MS_VB_CompareMethod)
         If Info.IsOptionCompareText Then
             Emitter.EmitLoadValue(cminfo, Microsoft.VisualBasic.CompareMethod.Text)
         Else
             Emitter.EmitLoadValue(cmInfo, Microsoft.VisualBasic.CompareMethod.Binary)
         End If
 
         Select Case MyBase.OperandTypeCode
             Case TypeCode.String
                 Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_LikeOperator__LikeString_String_String_CompareMethod)
             Case TypeCode.Object
                 'Helper.Assert(Helper.CompareType(ExpressionType, Compiler.TypeCache.Object))
                 Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_LikeOperator__LikeObject_Object_Object_CompareMethod)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="24" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitSubOrSubOvfOrSubOvfUn(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitSub(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Subtract_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__SubtractObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="23" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Remainder_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ModObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="23" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMultOrMultOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMult(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Multiply_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__MultiplyObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="59" endline="79">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConcatenateObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Math__Pow_Double_Double)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ExponentObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RealDivisionExpression.vb" startline="23" endline="46">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitRealDiv(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Divide_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__DivideObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="39" endline="62">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitAnd(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AndObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitIntDiv(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__IntDivideObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="39" endline="62">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__OrObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitXOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__XorObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="30" endline="53">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case Me.OperandTypeCode
 
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Boolean)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitNot(Info, OperandType)
             Case TypeCode.Object
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__NotObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="30" endline="52">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Decimal
             Case TypeCode.Single, TypeCode.Double
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__PlusObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="21" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="704" endline="792">
<![CDATA[
 
 #if NET_2_0
 	void WriteGenericConstraints (Type [] args)
 	{
 
 		foreach (Type t in args) {
 			bool first = true;
 			Type[] ifaces = TypeGetInterfaces (t, true);
 			
 			GenericParameterAttributes attrs = t.GenericParameterAttributes & GenericParameterAttributes.SpecialConstraintMask;
 			GenericParameterAttributes [] interesting = {
 				GenericParameterAttributes.ReferenceTypeConstraint,
 				GenericParameterAttributes.NotNullableValueTypeConstraint,
 				GenericParameterAttributes.DefaultConstructorConstraint
 			};
 			
 			if (t.BaseType != typeof (object) || ifaces.Length != 0 || attrs != 0) {
 				o.Write (" where ");
 				o.Write (FormatType (t));
 				o.Write (" 
 			}
 
 			if (t.BaseType != typeof (object)) {
 				o.Write (FormatType (t.BaseType));
 				first = false;
 			}
 
 			foreach (Type iface in ifaces) {
 				if (!first)
 					o.Write (", ");
 				first = false;
 				
 				o.Write (FormatType (iface));
 			}
 
 			foreach (GenericParameterAttributes a in interesting) {
 				if ((attrs & a) == 0)
 					continue;
 				
 				if (!first)
 					o.Write (", ");
 				first = false;
 				
 				switch (a) {
 				case GenericParameterAttributes.ReferenceTypeConstraint
 					o.Write ("class");
 					break;
 				case GenericParameterAttributes.NotNullableValueTypeConstraint
 					o.Write ("struct");
 					break;
 				case GenericParameterAttributes.DefaultConstructorConstraint
 					o.Write ("new ()");
 					break;
 				}
 			}
 		}
 	}
 #endif
  
 	string OperatorFromName (string name)
 	{
 		switch (name) {
 		case "op_UnaryPlus"
 		case "op_UnaryNegation"
 		case "op_LogicalNot"
 		case "op_OnesComplement"
 		case "op_Increment"
 		case "op_Decrement"
 		case "op_True"
 		case "op_False"
 		case "op_Addition"
 		case "op_Subtraction"
 		case "op_Multiply"
 		case "op_Division"
 		case "op_Modulus"
 		case "op_BitwiseAnd"
 		case "op_BitwiseOr"
 		case "op_ExclusiveOr"
 		case "op_LeftShift"
 		case "op_RightShift"
 		case "op_Equality"
 		case "op_Inequality"
 		case "op_GreaterThan"
 		case "op_LessThan"
 		case "op_GreaterThanOrEqual"
 		case "op_LessThanOrEqual"
 		default
 		}
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="542" endline="571">
<![CDATA[
 		}
 
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			switch (Name) {
 			case "Int32"
 			case "Int64"
 			case "String"
 			case "Boolean"
 			case "Void"
 			case "Object"
 			case "UInt32"
 			case "Int16"
 			case "UInt16"
 			case "UInt64"
 			case "Single"
 			case "Double"
 			case "Decimal"
 			case "Char"
 			case "Byte"
 			case "SByte"
 			}
 
 			if (ns.Length == 0)
 				return name;
 
 			return FullName;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="22" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2717" endline="2777">
<![CDATA[
 
 		public void AddLabel (string name, LabeledStatement label)
 		{
 			if (labels == null)
 				labels = new Dictionary<string, object> ();
 
 			object value;
 			if (!labels.TryGetValue (name, out value)) {
 				labels.Add (name, label);
 				return;
 			}
 
 			LabeledStatement existing = value as LabeledStatement;
 			List<LabeledStatement> existing_list;
 			if (existing != null) {
 				existing_list = new List<LabeledStatement> ();
 				existing_list.Add (existing);
 				labels[name] = existing_list;
 			} else {
 				existing_list = (List<LabeledStatement>) value;
 			}
 
 			//
 			// A collision checking between labels
 			//
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (label.Block == b) {
 					Report.SymbolRelatedToPreviousError (existing.loc, name);
 					Report.Error (140, label.loc, "The label `{0}' is a duplicate", name);
 					break;
 				}
 
 				// Collision with parent
 				b = label.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (label.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (label.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (label.Block == b) {
 					Report.SymbolRelatedToPreviousError (existing.loc, name);
 					Report.Error (140, label.loc, "The label `{0}' is a duplicate", name);
 					break;
 				}
 
 				// Collision with parent
 				b = label.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (label.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 
 			existing_list.Add (label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2659" endline="2716">
<![CDATA[
 
 		public override void AddLocalName (string name, INamedBlockVariable li)
 		{
 			if (names == null)
 				names = new Dictionary<string, object> ();
 
 			object value;
 			if (!names.TryGetValue (name, out value)) {
 				names.Add (name, li);
 				return;
 			}
 
 			INamedBlockVariable existing = value as INamedBlockVariable;
 			List<INamedBlockVariable> existing_list;
 			if (existing != null) {
 				existing_list = new List<INamedBlockVariable> ();
 				existing_list.Add (existing);
 				names[name] = existing_list;
 			} else {
 				existing_list = (List<INamedBlockVariable>) value;
 			}
 
 			//
 			// A collision checking between local names
 			//
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (li.Block == b) {
 					li.Block.Error_AlreadyDeclared (name, li);
 					break;
 				}
 
 				// Collision with parent
 				b = li.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "parent or current");
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "parent or current");
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (li.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "child");
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (li.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "child");
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (li.Block == b) {
 					li.Block.Error_AlreadyDeclared (name, li);
 					break;
 				}
 
 				// Collision with parent
 				b = li.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "parent or current");
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (li.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "child");
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 
 			existing_list.Add (li);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="23" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1613" endline="1661">
<![CDATA[
 
 		// <summary>
 		//   Performs an `and' operation on the bit vector.  The `new_vector' may have
 		//   a different size than the current one.
 		// </summary>
 		private MyBitVector And (MyBitVector new_vector)
 		{
 			if (Count == 0)
 				return this;
 
 			var o = new_vector.vector != null ? new_vector.vector 
 
 			if (o == null) {
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				return this;
 			}
 
 			if (o.Count == 0) {
 				SetAll (false);
 				return this;
 			}
 
 			if (Count == o.Count) {
 				if (vector == null) {
 					if (shared == null) {
 						shared = new_vector.MakeShared (Count);
 						return this;
 					}
 					initialize_vector ();
 				}
 				vector.And (o);
 				return this;
 			}
 
 			int min = o.Count;
 			if (Count < min)
 				min = Count;
 
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1568" endline="1612">
<![CDATA[
 		}
 
 		// <summary>
 		//   Performs an `or' operation on the bit vector.  The `new_vector' may have a
 		//   different size than the current one.
 		// </summary>
 		private MyBitVector Or (MyBitVector new_vector)
 		{
 			if (Count == 0 || new_vector.Count == 0)
 				return this;
 
 			var o = new_vector.vector != null ? new_vector.vector 
 
 			if (o == null) {
 				int n = new_vector.Count;
 				if (n < Count) {
 					for (int i = 0; i < n; ++i)
 						this [i] = true;
 					for (int i = 0; i < n; ++i)
 						this [i] = true;
 				} else {
 					SetAll (true);
 				}
 				return this;
 			}
 
 			if (Count == o.Count) {
 				if (vector == null) {
 					if (shared == null)
 						return this;
 					initialize_vector ();
 				}
 				vector.Or (o);
 				return this;
 			}
 
 			int min = o.Count;
 			if (Count < min)
 				min = Count;
 
 			for (int i = 0; i < min; i++) {
 				if (o [i])
 					this [i] = true;
 			}
 			for (int i = 0; i < min; i++) {
 				if (o [i])
 					this [i] = true;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="24" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="532" endline="574">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Arguments As Mono.Collections.Generic.Collection(Of TypeReference), Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Member.GenericParameters
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
 
         If Member.GenericParameters.Count = 0 Then Return Member
 
         returnType = CecilHelper.ResolveType(Member.ReturnType, parameters, Arguments)
         returnType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, returnType)
         result = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         For i As Integer = 0 To Member.GenericParameters.Count - 1
             result.GenericParameters.Add(Member.GenericParameters(i))
             reflectableMember.GenericParameters.Add(Member.GenericParameters(i))
         Next
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, parameters, Arguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="575" endline="647">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Type As Mono.Cecil.TypeReference, Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
         Dim genericArguments As Mono.Collections.Generic.Collection(Of TypeReference) = Nothing
         Dim genericParameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Nothing
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
         Dim declType As TypeReference = Nothing
 
         GetGenericArgsAndParams(Type, genericParameters, genericArguments)
 
         'If genericType Is Nothing Then
         '    Dim declType As TypeReference = Type
         '    While declType.IsNested
         '        Dim genType As GenericInstanceType = TryCast(declType, Mono.Cecil.GenericInstanceType)
         '        If genType IsNot Nothing Then
         '            If genericArguments Is Nothing Then genericArguments = New GenericArgumentCollection(Nothing)
         '            For Each arg As TypeReference In genType.GenericArguments
         '                genericArguments.Add(arg)
         '            Next
         '        End If
         '    End While
         '    Return Member
         'Else
         '    genericArguments = genericType.GenericArguments
         '    genericParameters = tD.GenericParameters
         'End If
 
         If genericParameters Is Nothing AndAlso genericArguments Is Nothing AndAlso tD Is Type AndAlso tD.Module Is Compiler.CurrentCompiler.ModuleBuilderCecil Then
             Return Member
         End If
 
         If Emittable Then
             returnType = Member.ReturnType
         Else
             returnType = CecilHelper.InflateType(Member.ReturnType, genericParameters, genericArguments)
         End If
         result = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         'If Member.DeclaringType.GenericParameters.Count > 0 AndAlso Not False Then
         '    Dim tmp As New GenericInstanceType(Member.DeclaringType)
         '    For i As Integer = 0 To Member.DeclaringType.GenericParameters.Count - 1
         '        tmp.GenericArguments.Add(Member.DeclaringType.GenericParameters(i))
         '    Next
         '    result.DeclaringType = tmp
         'End If
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, genericParameters, genericArguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="25" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="353" endline="406">
<![CDATA[
 
 		static public byte[] ToCapiPrivateKeyBlob (DSA dsa)
 		{
 			DSAParameters p = dsa.ExportParameters (true);
 			int keyLength = p.P.Length; // in bytes
 
 			// header + P + Q + G + X + count + seed
 			byte[] blob = new byte [16 + keyLength + 20 + keyLength + 20 + 4 + 20];
 
 			blob [0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x22;	// ALGID
 			blob [8] = 0x44;	// Magic
 			blob [9] = 0x53;
 			blob [10] = 0x53;
 			blob [11] = 0x32;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];
 			blob [13] = bitlen [1];
 			blob [14] = bitlen [2];
 			blob [15] = bitlen [3];
 
 			int pos = 16;
 			byte[] part = p.P;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Q;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			part = p.G;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.X;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
 			pos += 4;
 
 			part = p.Seed;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 
 			return blob;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="570" endline="625">
<![CDATA[
 
 		static public byte[] ToCapiPublicKeyBlob (DSA dsa)
 		{
 			DSAParameters p = dsa.ExportParameters (false);
 			int keyLength = p.P.Length; // in bytes
 
 			// header + P + Q + G + Y + count + seed
 			byte[] blob = new byte [16 + keyLength + 20 + keyLength + keyLength + 4 + 20];
 
 			blob [0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x22;	// ALGID
 			blob [8] = 0x44;	// Magic
 			blob [9] = 0x53;
 			blob [10] = 0x53;
 			blob [11] = 0x31;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];
 			blob [13] = bitlen [1];
 			blob [14] = bitlen [2];
 			blob [15] = bitlen [3];
 
 			int pos = 16;
 			byte[] part;
 
 			part = p.P;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Q;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			part = p.G;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Y;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
 			pos += 4;
 
 			part = p.Seed;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 
 			return blob;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="26" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="601" endline="637">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2175" endline="2208">
<![CDATA[
 		}
 
 		public virtual void Emit (DeclSpace parent)
 		{
 			method_data.Emit (parent);
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (method_data.MethodBuilder);
 			if (((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0))
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (method_data.MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			block = null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="27" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="724" endline="774">
<![CDATA[
 
     Private Shared Function GetBinaryOperandType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatOperandType(op1, op2)
             Case KS.GE
                 Return GetGEOperandType(op1, op2)
             Case KS.GT
                 Return GetGTOperandType(op1, op2)
             Case KS.LE
                 Return GetLEOperandType(op1, op2)
             Case KS.LT
                 Return GetLTOperandType(op1, op2)
             Case KS.Equals
                 Return GetEqualsOperandType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsOperandType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeOperandType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotOperandType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="561" endline="611">
<![CDATA[
 
     Shared Function GetBinaryResultType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatResultType(op1, op2)
             Case KS.GE
                 Return GetGEResultType(op1, op2)
             Case KS.GT
                 Return GetGTResultType(op1, op2)
             Case KS.LE
                 Return GetLEResultType(op1, op2)
             Case KS.LT
                 Return GetLTResultType(op1, op2)
             Case KS.Equals
                 Return GetEqualsResultType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsResultType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeResultType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotResultType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="28" nfragments="5" Csharpe_files="0" vb_files="5" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1682" endline="1732">
<![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified address.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ByRefType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadIndirect(ByVal Info As EmitInfo, ByVal ByRefType As Mono.Cecil.TypeReference)
         ByRefType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ByRefType)
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ByRefType)
         Select Case Helper.GetTypeCode(Info.Compiler, elementtype)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldind_U1)
             Case TypeCode.SByte
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldind_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldind_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldind_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldind_I4)
             Case TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldind_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldind_R8)
             Case TypeCode.String, TypeCode.DBNull
                 Info.ILGen.Emit(OpCodes.Ldind_Ref)
             Case TypeCode.Object
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.ILGen.Emit(OpCodes.Ldind_Ref)
                 End If
             Case TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Ldobj, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal))
             Case Else
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
                 End If
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="975" endline="1007">
<![CDATA[
 
     Shared Sub LoadElement(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldelem_U1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldelem_U2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldelem_U4)
             Case TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.SByte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldelem_I1)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldelem_I2)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldelem_I4)
             Case TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldelem_R8)
             Case TypeCode.DateTime, TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Ldelema, ElementType)
                 Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Ldelem_Ref)
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1008" endline="1048">
<![CDATA[
 
 
     ''' <summary>
     ''' Type = the type of the element. (not of the array.)
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreElement(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Int32, TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Stelem_I4)
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Stelem_I1)
             Case TypeCode.Int16, TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Stelem_I2)
             Case TypeCode.Int64, TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Stelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Stelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Stelem_R8)
             Case TypeCode.DateTime, TypeCode.Decimal
                 EmitStoreObject(Info, ElementType)
                 Return
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Stelem_Ref)
             Case TypeCode.Object
                 If CecilHelper.IsValueType(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stobj, ElementType)
                 ElseIf CecilHelper.IsGenericParameter(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stelem_Any, ElementType)
                 Else
                     Info.ILGen.Emit(OpCodes.Stelem_Ref)
                 End If
             Case Else
                 Helper.Stop()
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="942" endline="974">
<![CDATA[
 
     Shared Sub EmitLoadElement(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldelem_U1)
             Case TypeCode.SByte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldelem_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldelem_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldelem_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldelem_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldelem_I4)
             Case TypeCode.UInt64, TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldelem_R8)
             Case TypeCode.Object, TypeCode.String, TypeCode.DateTime, TypeCode.Decimal
                 If CecilHelper.IsValueType(ElementType) Then
                     Throw New InternalException("")
                 Else
                     Info.ILGen.Emit(OpCodes.Ldelem_Ref)
                 End If
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1838" endline="1868">
<![CDATA[
 
     Shared Sub EmitStoreIndirect(ByVal Info As EmitInfo, ByVal ByRefType As Mono.Cecil.TypeReference)
         ByRefType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ByRefType)
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ByRefType)
         Select Case Helper.GetTypeCode(Info.Compiler, elementtype)
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Stind_I1)
             Case TypeCode.Int16, TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Stind_I2)
             Case TypeCode.Int32, TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Stind_I4)
             Case TypeCode.Int64, TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Stind_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Stind_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Stind_R8)
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Stind_Ref)
             Case TypeCode.DateTime, TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Stobj, elementtype)
             Case TypeCode.Object
                 If CecilHelper.IsValueType(elementtype) Then
                     Info.ILGen.Emit(OpCodes.Stobj, elementtype)
                 Else
                     Info.ILGen.Emit(OpCodes.Stind_Ref)
                 End If
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="29" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="585" endline="620">
<![CDATA[
 
 		public MethodInfo[] GetMethods(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<MethodInfo> list = new List<MethodInfo>();
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				MethodInfo mi = mb as MethodInfo;
 				if (mi != null
 					&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(mi);
 				}
 			}
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				MethodInfo mi = mb as MethodInfo;
 				if (mi != null
 					&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(mi);
 				}
 			}
 			if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 			{
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 				}
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="532" endline="561">
<![CDATA[
 
 		public FieldInfo[] GetFields(BindingFlags bindingAttr)
 		{
 			List<FieldInfo> list = new List<FieldInfo>();
 			CheckBaked();
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(field);
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(field);
 				}
 			}
 			if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 			{
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 				}
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="30" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="406" endline="455">
<![CDATA[
 
     Public Shared Function EmitLateCall(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateCall
 
         '1 - the instance expression
         If LateBoundAccess.InstanceExpression IsNot Nothing Then
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Object))
         End If
 
         '2 - Type
         If LateBoundAccess.LateBoundType Is Nothing Then
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         Else
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         '8 - Ignore return
         Emitter.EmitLoadI4Value(Info, 1)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean)
 
         Emitter.EmitPop(Info, Info.Compiler.TypeCache.System_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="291" endline="337">
<![CDATA[
 
     Public Shared Function EmitLateGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateGet
 
         If LateBoundAccess.InstanceExpression Is Nothing Then
             '1 - the instance expression (none in this case)
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
             '2 - Type 
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         Else
             '1 - the instance expression
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
             '2 - Type  - we have the instance, so no need to pass the type here.
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="31" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="243" endline="280">
<![CDATA[
 
 		//
 		// Member-cache does not contain base members but it does
 		// contain all base interface members, so the Lookup code
 		// can use simple inheritance rules.
 		//
 		public void AddInterface (TypeSpec iface)
 		{
 			var cache = iface.MemberCache;
 
 			IList<MemberSpec> list;
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 			}
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 			}
 
 			// Add also all base interfaces
 			if (iface.Interfaces != null) {
 				foreach (var base_iface in iface.Interfaces)
 					AddInterface (base_iface);
 				foreach (var base_iface in iface.Interfaces)
 					AddInterface (base_iface);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="209" endline="242">
<![CDATA[
 
 		//
 		// For cases where we need to union cache members
 		//
 		public void AddBaseType (TypeSpec baseType)
 		{
 			var cache = baseType.MemberCache;
 
 			IList<MemberSpec> list;
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 			}
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="32" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="120" endline="156">
<![CDATA[
 
 		internal override void WriteSig(ModuleBuilder module, ByteBuffer bb)
 		{
 			byte flags = PROPERTY;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes == null ? 0 
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
 			WriteType(module, bb, propertyType);
 			if (parameterTypes != null)
 			{
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
 					}
 					if (parameterOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
 					}
 					if (parameterOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="666" endline="704">
<![CDATA[
 
 		internal static void WritePropertySig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			byte flags = PROPERTY;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes == null ? 0 
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, returnTypeRequiredCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, returnTypeOptionalCustomModifiers);
 			WriteType(module, bb, returnType);
 			if (parameterTypes != null)
 			{
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="619" endline="651">
<![CDATA[
 
 		// managed calling convention
 		internal static void WriteStandAloneMethodSig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
 		{
 			byte flags = 0;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes.Length + optionalParameterTypes.Length);
 			WriteType(module, bb, returnType);
 			foreach (Type t in parameterTypes)
 			{
 				WriteType(module, bb, t);
 			}
 			foreach (Type t in parameterTypes)
 			{
 				WriteType(module, bb, t);
 			}
 			if (optionalParameterTypes.Length > 0)
 			{
 				bb.Write(SENTINEL);
 				foreach (Type t in optionalParameterTypes)
 				{
 					WriteType(module, bb, t);
 				}
 				foreach (Type t in optionalParameterTypes)
 				{
 					WriteType(module, bb, t);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="33" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="23" endline="67">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadtrue, endexp As Label
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
           
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="34" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="216" endline="258">
<![CDATA[
 
     Function TypeCodeToType(ByVal Code As TypeCode) As Mono.Cecil.TypeReference
         Select Case Code
             Case TypeCode.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case TypeCode.Byte
                 Return Compiler.TypeCache.System_Byte
             Case TypeCode.Char
                 Return Compiler.TypeCache.System_Char
             Case TypeCode.DateTime
                 Return Compiler.TypeCache.System_DateTime
             Case TypeCode.DBNull
                 Throw New InternalException("")
             Case TypeCode.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case TypeCode.Double
                 Return Compiler.TypeCache.System_Double
             Case TypeCode.Empty
                 Throw New InternalException("")
             Case TypeCode.Int16
                 Return Compiler.TypeCache.System_Int16
             Case TypeCode.Int32
                 Return Compiler.TypeCache.System_Int32
             Case TypeCode.Int64
                 Return Compiler.TypeCache.System_Int64
             Case TypeCode.Object
                 Return Compiler.TypeCache.System_Object
             Case TypeCode.SByte
                 Return Compiler.TypeCache.System_SByte
             Case TypeCode.Single
                 Return Compiler.TypeCache.System_Single
             Case TypeCode.String
                 Return Compiler.TypeCache.System_String
             Case TypeCode.UInt16
                 Return Compiler.TypeCache.System_UInt16
             Case TypeCode.UInt32
                 Return Compiler.TypeCache.System_UInt32
             Case TypeCode.UInt64
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="337" endline="383">
<![CDATA[
 
     ''' <summary>
     ''' Returns the type of the specified keyword. Throws an internalexception if the keyword isn't a type.
     ''' </summary>
     ''' <param name="Keyword"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ''' 
     Function KeywordToType(ByVal Keyword As KS) As Mono.Cecil.TypeReference
         Select Case Keyword
             Case KS.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case KS.Byte
                 Return Compiler.TypeCache.System_Byte
             Case KS.Char
                 Return Compiler.TypeCache.System_Char
             Case KS.Date
                 Return Compiler.TypeCache.System_DateTime
             Case KS.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case KS.Double
                 Return Compiler.TypeCache.System_Double
             Case KS.Integer
                 Return Compiler.TypeCache.System_Int32
             Case KS.Long
                 Return Compiler.TypeCache.System_Int64
             Case KS.Object
                 Return Compiler.TypeCache.System_Object
             Case KS.Single
                 Return Compiler.TypeCache.System_Single
             Case KS.Short
                 Return Compiler.TypeCache.System_Int16
             Case KS.String
                 Return Compiler.TypeCache.System_String
             Case KS.[SByte]
                 Return Compiler.TypeCache.System_SByte
             Case KS.[UShort]
                 Return Compiler.TypeCache.System_UInt16
             Case KS.[UInteger]
                 Return Compiler.TypeCache.System_UInt32
             Case KS.[ULong]
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 'Throw New InternalException("Don't know if this can actually happen, though. KS = " & Keyword.ToString)
                 Return Nothing
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="787" endline="826">
<![CDATA[
 
     Public Overloads Shared Function [GetType](ByVal Compiler As Compiler, ByVal value As Object) As Mono.Cecil.TypeReference
         If value Is Nothing Then Throw New InternalException("'Nothing' doesn't have a type")
         Select Case Type.GetTypeCode(value.GetType)
             Case TypeCode.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case TypeCode.Byte
                 Return Compiler.TypeCache.System_Byte
             Case TypeCode.Char
                 Return Compiler.TypeCache.System_Char
             Case TypeCode.DateTime
                 Return Compiler.TypeCache.System_DateTime
             Case TypeCode.DBNull
                 Return Compiler.TypeCache.System_DBNull
             Case TypeCode.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case TypeCode.Double
                 Return Compiler.TypeCache.System_Double
             Case TypeCode.Int16
                 Return Compiler.TypeCache.System_Int16
             Case TypeCode.Int32
                 Return Compiler.TypeCache.System_Int32
             Case TypeCode.Int64
                 Return Compiler.TypeCache.System_Int64
             Case TypeCode.SByte
                 Return Compiler.TypeCache.System_SByte
             Case TypeCode.Single
                 Return Compiler.TypeCache.System_Single
             Case TypeCode.String
                 Return Compiler.TypeCache.System_String
             Case TypeCode.UInt16
                 Return Compiler.TypeCache.System_UInt16
             Case TypeCode.UInt32
                 Return Compiler.TypeCache.System_UInt32
             Case TypeCode.UInt64
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 Throw New InternalException(String.Format("No constant value can be of the type '{0}'", value.GetType.FullName))
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="35" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="139" endline="152">
<![CDATA[
 
 		internal void Write(long value)
 		{
 			if (pos + 8 > buffer.Length)
 				Grow(8);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 			buffer[pos++] = (byte)(value >> 16);
 			buffer[pos++] = (byte)(value >> 24);
 			buffer[pos++] = (byte)(value >> 32);
 			buffer[pos++] = (byte)(value >> 40);
 			buffer[pos++] = (byte)(value >> 48);
 			buffer[pos++] = (byte)(value >> 56);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1434" endline="1448">
<![CDATA[
 
 		public void Encode (long value)
 		{
 			if (pos + 8 > buffer.Length)
 				Grow (8);
 
 			buffer[pos++] = (byte) value;
 			buffer[pos++] = (byte) (value >> 8);
 			buffer[pos++] = (byte) (value >> 16);
 			buffer[pos++] = (byte) (value >> 24);
 			buffer[pos++] = (byte) (value >> 32);
 			buffer[pos++] = (byte) (value >> 40);
 			buffer[pos++] = (byte) (value >> 48);
 			buffer[pos++] = (byte) (value >> 56);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="36" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="161" endline="195">
<![CDATA[
 		}
 
 		internal void Bake()
 		{
 			EventTable.Record rec = new EventTable.Record();
 			rec.EventFlags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.EventType = eventtype;
 			int token = 0x14000000 | typeBuilder.ModuleBuilder.Event.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (addOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.AddOn, addOnMethod.MetadataToken, token);
 			}
 			if (removeOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.RemoveOn, removeOnMethod.MetadataToken, token);
 			}
 			if (fireMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Fire, fireMethod.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="191" endline="220">
<![CDATA[
 
 		internal void Bake()
 		{
 			PropertyTable.Record rec = new PropertyTable.Record();
 			rec.Flags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.Type = typeBuilder.ModuleBuilder.GetSignatureBlobIndex(sig);
 			int token = 0x17000000 | typeBuilder.ModuleBuilder.Property.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (getter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Getter, getter.MetadataToken, token);
 			}
 			if (setter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Setter, setter.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="37" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="94" endline="119">
<![CDATA[
 
     Private Function CreateAddHandlerCode(ByVal Info As EmitInfo) As Boolean
         Helper.Assert([EventParent].EventField IsNot Nothing)
         If Me.IsShared = False Then
             With Info.ILGen
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_1)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         Else
             With Info.ILGen
                 .Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_0)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         End If
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="69" endline="93">
<![CDATA[
 
     Private Function CreateRemoveHandlerCode(ByVal Info As EmitInfo) As Boolean
         If Me.IsShared = False Then
             With Info.ILGen
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_1)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Remove), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         Else
             With Info.ILGen
                 .Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_0)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Remove), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         End If
         Return True
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="38" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="824" endline="865">
<![CDATA[
 
 		/// <summary>
 		///  Finds "most encompassing type" according to the spec (13.4.2)
 		///  amongst the types in the given set
 		/// </summary>
 		static TypeSpec FindMostEncompassingType (IList<TypeSpec> types)
 		{
 			TypeSpec best = null;
 
 			if (types.Count == 0)
 				return null;
 
 			if (types.Count == 1)
 				return types [0];
 
 			EmptyExpression expr = EmptyExpression.Grab ();
 
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (best);
 				if (ImplicitStandardConversionExists (expr, t))
 					best = t;
 			}
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (best);
 				if (ImplicitStandardConversionExists (expr, t))
 					best = t;
 			}
 
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				expr.SetType (t);
 				if (!ImplicitStandardConversionExists (expr, best)) {
 					best = null;
 					break;
 				}
 			}
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				expr.SetType (t);
 				if (!ImplicitStandardConversionExists (expr, best)) {
 					best = null;
 					break;
 				}
 			}
 
 			EmptyExpression.Release (expr);
 
 			return best;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="789" endline="823">
<![CDATA[
 
 		/// <summary>
 		///  Finds "most encompassed type" according to the spec (13.4.2)
 		///  amongst the methods in the MethodGroupExpr
 		/// </summary>
 		public static TypeSpec FindMostEncompassedType (IEnumerable<TypeSpec> types)
 		{
 			TypeSpec best = null;
 			EmptyExpression expr = EmptyExpression.Grab ();
 
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (t);
 				if (ImplicitStandardConversionExists (expr, best))
 					best = t;
 			}
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (t);
 				if (ImplicitStandardConversionExists (expr, best))
 					best = t;
 			}
 
 			expr.SetType (best);
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				if (!ImplicitStandardConversionExists (expr, t)) {
 					best = null;
 					break;
 				}
 			}
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				if (!ImplicitStandardConversionExists (expr, t)) {
 					best = null;
 					break;
 				}
 			}
 
 			EmptyExpression.Release (expr);
 
 			return best;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="39" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5507" endline="5538">
<![CDATA[
 
 		public abstract SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source);
 
 		protected abstract Expression OverloadResolve (ResolveContext rc, Expression right_side);
 
 		bool ResolveGetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasGet) {
 				if (InstanceExpression != EmptyExpression.Null) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate);
 					rc.Report.Error (154, loc, "The property or indexer `{0}' cannot be used in this context because it lacks the `get' accessor",
 						best_candidate.GetSignatureForError ());
 					return false;
 				}
 			} else if (!best_candidate.Get.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					rc.Report.Error (271, loc, "The property or indexer `{0}' cannot be used in this context because the get accessor is inaccessible",
 						TypeManager.CSharpSignature (best_candidate));
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					ErrorIsInaccesible (rc, best_candidate.Get.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility) {
 				CheckProtectedMemberAccess (rc, best_candidate.Get);
 			}
 
 			getter = CandidateToBaseOverride (rc, best_candidate.Get);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5539" endline="5564">
<![CDATA[
 
 		bool ResolveSetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasSet) {
 				rc.Report.Error (200, loc, "Property or indexer `{0}' cannot be assigned to (it is read-only)",
 					GetSignatureForError ());
 				return false;
 			}
 
 			if (!best_candidate.Set.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					rc.Report.Error (272, loc, "The property or indexer `{0}' cannot be used in this context because the set accessor is inaccessible",
 						GetSignatureForError ());
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					ErrorIsInaccesible (rc, best_candidate.Set.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility)
 				CheckProtectedMemberAccess (rc, best_candidate.Set);
 
 			setter = CandidateToBaseOverride (rc, best_candidate.Set);
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="40" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="255" endline="291">
<![CDATA[
 		}
 
 		public void BeginCatchBlock(Type exceptionType)
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				if (exceptionType == null)
 				{
 					Emit(OpCodes.Endfilter);
 				}
 				else
 				{
 					Emit(OpCodes.Leave, block.labelEnd);
 				}
 			}
 			stackHeight = 0;
 			UpdateStack(1);
 			if (block.tryLength == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else if (exceptionType != null)
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = block.labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = block.tryLength;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			block.handlerOffset = code.Position;
 			block.exceptionType = exceptionType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="323" endline="360">
<![CDATA[
 
 		private ExceptionBlock BeginFinallyFilterFaultBlock()
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				Emit(OpCodes.Leave, block.labelEnd);
 			}
 			if (block.handlerOffset == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				Label labelEnd;
 				if (exceptionBlockAssistanceMode != EBAM_COMPAT)
 				{
 					labelEnd = block.labelEnd;
 				}
 				else
 				{
 					MarkLabel(block.labelEnd);
 					labelEnd = DefineLabel();
 					Emit(OpCodes.Leave, labelEnd);
 				}
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = code.Position - block.tryOffset;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			stackHeight = 0;
 			return block;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="41" nfragments="11" Csharpe_files="0" vb_files="11" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="116" endline="140">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.String
                     If CStr(originalValue).Length = 1 Then
                         Return CChar(originalValue)
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, ExpressionType.ToString)
                         Return New Char
                     End If
                 Case TypeCode.Char
                     Return CChar(originalValue)
                 Case TypeCode.DBNull
                     Return VB.ChrW(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, ExpressionType.ToString)
                     Return New Char
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="125" endline="149">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte
                     Return CByte(originalValue) 'No range checking needed.
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CByte(0)
                     End If
                 Case TypeCode.DBNull
                     Return CByte(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CByte(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16
                     Return CUShort(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UShort
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UShort
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16
                     Return CShort(originalValue) 'No range checking needed.
                 Case TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Short
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Short
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                     Return CULng(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New ULong
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New ULong
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt32
                     Return CLng(originalValue) 'No range checking needed.
                 Case TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Long
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Long
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="115" endline="137">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Decimal
                     Return CSng(originalValue) 'No range checking needed.
                 Case TypeCode.Double, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Single
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Single
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="133" endline="155">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32
                     Return CUInt(originalValue) 'No range checking needed.
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UInteger
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UInteger
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="124" endline="146">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Decimal
                     Return CDec(originalValue) 'No range checking needed.
                 Case TypeCode.Single, TypeCode.Double, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Expression.Location, ExpressionType.ToString)
                         Return New Decimal
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Expression.Location, originalValue.ToString, ExpressionType.ToString)
                     Return New Decimal
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.SByte
                     Return CSByte(originalValue) 'No range checking needed.
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New SByte
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CSByte(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="42" nfragments="2206" Csharpe_files="1391" vb_files="808" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="201" endline="221">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Report.Trace("{0}
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
 
         result = MyBase.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If m_NewExpression IsNot Nothing Then
             result = m_NewExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
         End If
 
         If m_VariableInitializer IsNot Nothing Then
             result = m_VariableInitializer.ResolveCode(New ExpressionResolveInfo(Compiler, VariableType)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="111" endline="125">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_LoopStartExpression IsNot Nothing Then result = m_LoopStartExpression.ResolveTypeReferences AndAlso result
         If m_LoopEndExpression IsNot Nothing Then result = m_LoopEndExpression.ResolveTypeReferences AndAlso result
         If m_LoopStepExpression IsNot Nothing Then result = m_LoopStepExpression.ResolveTypeReferences AndAlso result
         If m_NextExpressionList IsNot Nothing Then result = m_NextExpressionList.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="154" endline="169">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then result = m_ImplementsClause.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_AddMethod IsNot Nothing Then result = m_AddMethod.ResolveTypeReferences AndAlso result
         If m_RemoveMethod IsNot Nothing Then result = m_RemoveMethod.ResolveTypeReferences AndAlso result
         If m_RaiseMethod IsNot Nothing Then result = m_RaiseMethod.ResolveTypeReferences AndAlso result
 
         Helper.Assert(EventType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="93" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Target.ResolveExpression(Info) AndAlso result
         result = m_Start.ResolveExpression(info) AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveExpression(Info) AndAlso result
         result = m_Source.ResolveExpression(info) AndAlso result
 
         If Not m_Target.Classification.IsVariableClassification AndAlso Not m_Target.Classification.IsPropertyAccessClassification Then
             If m_Target.Classification.CanBePropertyAccessClassification Then
                 m_Target = m_Target.ReclassifyToPropertyAccessExpression()
                 result = m_Target.ResolveExpression(Info) AndAlso result
             Else
                 result = False
             End If
         End If
 
         Compiler.Helper.AddCheck("The first argument is the target of the assignment and must be classified as a variable or a property access whose type is implicitly convertible to and from String. ")
         Compiler.Helper.AddCheck("The second parameter is the 1-based start position that corresponds to where the assignment should begin in the target string and must be classified as a value whose type must be implicitly convertible to Integer")
         Compiler.Helper.AddCheck("The optional third parameter is the number of characters from the right-side value to assign into the target string and must be classified as a value whose type is implicitly convertible to Integer")
         Compiler.Helper.AddCheck("The right side is the source string and must be classified as a value whose type is implicitly convertible to String.")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="186" endline="209">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ParametersOrType.ResolveTypeReferences AndAlso result
         If EventType IsNot Nothing Then
             'Nothing to do
         ElseIf Type IsNot Nothing Then
             Helper.Assert(EventType Is Nothing)
             EventType = Type.ResolvedType
         ElseIf Parameters IsNot Nothing Then
             Helper.Assert(EventType IsNot Nothing OrElse ImplementsClause IsNot Nothing)
         Else
             Throw New InternalException(Me)
         End If
 
         If m_ImplicitEventDelegate IsNot Nothing Then
             result = m_ImplicitEventDelegate.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="145" endline="164">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             If IsLocalVariable Then
                 If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
                 Helper.Assert(m_LocalBuilder IsNot Nothing)
                 result = EmitVariableInitializer(Info) AndAlso result
             ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
                 result = DefineField() AndAlso result
                 result = EmitStaticInitializer(Info) AndAlso result
             End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="199" endline="218">
<![CDATA[
 
     Public Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         result = m_Signature.ResolveCode(Info) AndAlso result
 
         If m_Get IsNot Nothing Then result = m_Get.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If Modifiers.Is(ModifierMasks.Default) Then
             Dim tp As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
             result = tp.SetDefaultAttribute(Me.Name) AndAlso result
         End If
 
         UpdateDefinition()
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="160" endline="173">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_Signature IsNot Nothing Then result = m_Signature.ResolveTypeReferences AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveTypeReferences AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveTypeReferences AndAlso result
 
         If m_MemberImplementsClause IsNot Nothing Then result = m_MemberImplementsClause.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="44" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Target IsNot Nothing Then result = m_Target.ResolveTypeReferences AndAlso result
         If m_Start IsNot Nothing Then result = m_Start.ResolveTypeReferences AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveTypeReferences AndAlso result
         If m_Source IsNot Nothing Then result = m_Source.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="59" endline="71">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
 
         If m_Declaration IsNot Nothing Then result = m_Declaration.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="186" endline="197">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_InExpression IsNot Nothing Then result = m_InExpression.ResolveTypeReferences AndAlso result
         If m_NextExpression IsNot Nothing Then result = m_NextExpression.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="146" endline="157">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If m_Condition IsNot Nothing Then result = m_Condition.ResolveTypeReferences AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveTypeReferences AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="124" endline="150">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Event.ResolveExpression(Info) AndAlso result
         result = m_EventHandler.ResolveExpression(info) AndAlso result
 
         If result = False Then Return result
 
         Dim delegatetp As Mono.Cecil.TypeReference = m_Event.Classification.AsEventAccess.Type
 
         If m_EventHandler.Classification.IsMethodPointerClassification Then
             'result = m_EventHandler.Classification.AsMethodPointerClassification.Resolve(delegatetp) AndAlso result
             m_EventHandler = m_EventHandler.ReclassifyMethodPointerToValueExpression(delegatetp)
             result = m_EventHandler.ResolveExpression(Info) AndAlso result
             'result = Helper.VerifyValueClassification(m_EventHandler, Info) AndAlso result
         ElseIf m_EventHandler.Classification.IsValueClassification = False AndAlso m_EventHandler.Classification.CanBeValueClassification Then
             m_EventHandler = m_EventHandler.ReclassifyToValueExpression()
             result = m_EventHandler.ResolveExpression(Info) AndAlso result
         End If
 
         Helper.Assert(m_EventHandler.Classification.IsValueClassification)
 
         Compiler.Helper.AddCheck("The first argument must be an expression that is classified as an event access and the second argument must be an expression that is classified as a value. ")
         Compiler.Helper.AddCheck("The second argument's type must be the delegate type associated with the event access.")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="87" endline="105">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
 
             If result AndAlso m_Expression.Classification.IsMethodGroupClassification Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             ElseIf result AndAlso m_Expression.Classification.IsPropertyGroupClassification Then
                 m_Expression = m_Expression.ReclassifyToPropertyAccessExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="117" endline="135">
<![CDATA[
     End Property
 
     Protected Overridable Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         result = m_RightExpression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return False
 
         If m_LeftExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_LeftExpression, Info) AndAlso result
         End If
 
         If m_RightExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_RightExpression, Info) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="229" endline="257">
<![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         If m_Get IsNot Nothing Then
             result = m_Get.DefineMember() AndAlso result
         End If
 
         If m_Set IsNot Nothing Then
             result = m_Set.DefineMember AndAlso result
         End If
 
         Dim name As String
         Dim attributes As Mono.Cecil.PropertyAttributes
         Dim returnType As Mono.Cecil.TypeReference
         Dim parameterTypes() As Mono.Cecil.TypeReference
 
         name = Me.Name
         attributes = 0 'Mono.Cecil.PropertyAttributes.None
         returnType = Me.Signature.ReturnType
         parameterTypes = Me.Signature.Parameters.ToTypeArray
 
         Helper.SetTypeOrTypeBuilder(Compiler, parameterTypes)
         returnType = Helper.GetTypeOrTypeBuilder(Compiler, returnType)
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="49" endline="59">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_ArrayElementInitializer IsNot Nothing Then result = m_ArrayElementInitializer.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="34" endline="53">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsLHS Then
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateindexSet(Info) AndAlso result
             Else
                 result = EmitLateSet(Info) AndAlso result
             End If
         Else
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateIndexGet(Info) AndAlso result
             Else
                 result = EmitLateGet(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="219" endline="228">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="258" endline="268">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Get IsNot Nothing Then result = m_Get.GenerateCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.GenerateCode(Info) AndAlso result
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="113" endline="128">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             result = m_TypeName.ResolveTypeReferences AndAlso result
         End If
 
         If m_When IsNot Nothing Then
             result = m_When.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="89" endline="99">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Catches IsNot Nothing Then result = m_Catches.ResolveTypeReferences() AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="345" endline="366">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = DefineOverrides() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Me.IsPropertyHandlesHandler Then
             result = GeneratePropertyHandlers() AndAlso result
         ElseIf Me.HasMethodBody Then
             Helper.Assert(m_Code IsNot Nothing)
 
             'Create the default return variable
             If Me.HasReturnValue Then
                 m_DefaultReturnVariable = Emitter.DeclareLocal(Info, ReturnType)
             End If
 
             result = m_Code.GenerateCode(Me) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="299" endline="314">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences AndAlso result
         If result = False Then Return result
 
         ReturnType = m_Signature.ReturnType
 
         If m_Code IsNot Nothing Then result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="323" endline="336">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         result = ResolveOverrides() AndAlso result
         result = m_Signature.ResolveCode(Info) AndAlso result
 
         If m_Code IsNot Nothing Then
             result = m_Code.ResolveCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="49" endline="71">
<![CDATA[
 
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(info) AndAlso result
             If result AndAlso m_Expression.Classification.IsValueClassification = False Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If result = False Then Return result
 
         If m_Expression IsNot Nothing Then
             Dim method As IMethod
             method = Me.FindFirstParent(Of IMethod)()
             m_Expression = Helper.CreateTypeConversion(Me, m_Expression, method.Signature.ReturnType, result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="73" endline="91">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Classification = New ValueClassification(Me)
 
         If m_Expression.Classification.IsValueClassification Then
         ElseIf m_Expression.Classification.CanBeValueClassification Then
             m_Expression = m_Expression.ReclassifyToValueExpression()
             result = m_Expression.ResolveExpression(Info) AndAlso result
         Else
             result = Helper.AddError(Me) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="56" endline="71">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfaceBases IsNot Nothing Then
             result = m_InterfaceBases.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_InterfaceBases.Bases.Length - 1
                 AddInterface(m_InterfaceBases.Bases(i).ResolvedType)
             Next
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="87" endline="103">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Test.ResolveExpression(Info) AndAlso result
         If result = False Then Return False
 
         result = Helper.VerifyValueClassification(m_Test, Info) AndAlso result
         If result = False Then Return False
 
         m_CachedTest = New CachedExpression(m_Test, m_Test)
 
         result = m_Cases.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Check that there is at most one else block, and only at the end.")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="53" endline="72">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_PropertyGroup.IsResolved = False OrElse m_PropertyGroup.ResolvedProperty Is Nothing Then
             result = m_PropertyGroup.ResolveGroup(New ArgumentList(Me)) AndAlso result
         End If
 
         If result = False Then
             Return False
         End If
 
         m_ExpressionType = m_PropertyGroup.ResolvedProperty.PropertyType
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="143" endline="161">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim atn As ArrayTypeName
         Dim natn As NonArrayTypeName
 
         atn = TryCast(m_TypeName, ArrayTypeName)
         If atn IsNot Nothing Then
             result = atn.ResolveCode(Info) AndAlso result
         Else
             natn = TryCast(m_TypeName, NonArrayTypeName)
             If natn IsNot Nothing Then
                 result = natn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="173" endline="190">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim stn As SimpleTypeName
         Dim ctn As ConstructedTypeName
 
         stn = TryCast(m_TypeName, SimpleTypeName)
         If stn IsNot Nothing Then
             result = stn.ResolveCode(Info) AndAlso result
         Else
             ctn = TryCast(m_TypeName, ConstructedTypeName)
             If ctn IsNot Nothing Then
                 result = ctn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="44" endline="54">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = m_NonArrayTypeName.ResolvedType
         End If
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="79" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Catches.ResolveCode(Info) AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveCode(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="61" endline="73">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then
             result = m_ParameterList.ResolveTypeReferences AndAlso result
         End If
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="76" endline="85">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         If m_TypeParameter IsNot Nothing Then result = m_TypeParameter.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="51" endline="59">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_AttributePositionalArgumentList IsNot Nothing Then result = m_AttributePositionalArgumentList.ResolveCode(info) AndAlso result
         If m_VariablePropertyInitializerList IsNot Nothing Then result = m_VariablePropertyInitializerList.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="92" endline="100">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveCode(Info) AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="35" endline="42">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_Arguments IsNot Nothing Then result = m_Arguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="58" endline="69">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_First IsNot Nothing Then result = m_First.ResolveTypeReferences AndAlso result
         If m_Second IsNot Nothing Then result = m_Second.ResolveTypeReferences AndAlso result
 
         ' If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveTypeReferences AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_EventHandler IsNot Nothing Then result = m_EventHandler.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="54" endline="63">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression1 IsNot Nothing Then result = m_Expression1.ResolveTypeReferences AndAlso result
         If m_Expression2 IsNot Nothing Then result = m_Expression2.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="51" endline="58">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArraySizeInitModifier IsNot Nothing Then result = m_ArraySizeInitModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="41" endline="49">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_FirstPart IsNot Nothing Then result = m_FirstPart.ResolveTypeReferences AndAlso result
         If m_SecondPart IsNot Nothing Then result = m_SecondPart.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Test IsNot Nothing Then result = m_Test.ResolveTypeReferences AndAlso result
         If m_Cases IsNot Nothing Then result = m_Cases.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="96" endline="110">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If HandlesClause IsNot Nothing Then
             result = HandlesClause.ResolveTypeReferences AndAlso result
         ElseIf ImplementsClause IsNot Nothing Then
             result = ImplementsClause.ResolveTypeReferences AndAlso result
         Else
             Helper.Stop()
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" startline="53" endline="64">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Exception IsNot Nothing Then
             result = m_Exception.ResolveExpression(Info) AndAlso result
             If result = False Then Return result
             result = Helper.VerifyValueClassification(m_Exception, Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="152" endline="163">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveCode(info) AndAlso result
         If m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="211" endline="224">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedType Is Nothing Then
             Helper.Assert(m_SimpleTypeName IsNot Nothing, "SimpleTypeName Is Nothing
             result = m_SimpleTypeName.ResolveTypeReferences(True) AndAlso result
             m_ResolvedType = m_SimpleTypeName.ResolvedType
         End If
         result = m_ResolvedType IsNot Nothing AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="126" endline="141">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
         End If
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="141" endline="151">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         result = MyBase.ResolveCode(info) AndAlso result
 
         Helper.Assert(m_ReturnType IsNot Nothing OrElse Compiler.Report.Errors > 0)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="26" endline="38">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_DestinationType IsNot Nothing Then
             result = m_DestinationType.ResolveTypeReferences AndAlso result
             m_ResolvedDestinationType = m_DestinationType.ResolvedType
             Helper.Assert(CecilHelper.IsByRef(m_ResolvedDestinationType) = False)
         End If
 
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="168" endline="178">
<![CDATA[
 
     Overridable Overloads Function ResolveTypeReferences(ByVal ResolveTypeParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveTypeReferences AndAlso result
         If ResolveTypeParameters = True AndAlso m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="54" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Type IsNot Nothing Then
             result = m_Type.ResolveTypeReferences AndAlso result
             EventType = m_Type.ResolvedType
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="129" endline="147">
<![CDATA[
 
     ''' <summary>
     ''' This creates the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Declaration IsNot Nothing Then
             result = m_Declaration.DefineLocalVariable(Info) AndAlso result
             result = m_Declaration.GenerateCode(Info) AndAlso result
         Else
             'm_LoopVariableBuilder()
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="84" endline="100">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Target.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Target.Classification.IsMethodGroupClassification Then
             Dim tmp As New InvocationOrIndexExpression(Me)
             tmp.Init(m_Target, New ArgumentList(tmp))
             result = tmp.ResolveExpression(Info) AndAlso result
             m_Target = tmp
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="80" endline="99">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_WithExpression.ResolveExpression(Info) AndAlso result
 
         If result Then
             If CecilHelper.IsValueType(m_WithExpression.ExpressionType) AndAlso m_WithExpression.Classification.IsVariableClassification Then
                 m_WithVariableExpression = m_WithExpression
             Else
                 m_WithVariableExpression = New CompilerGeneratedExpression(Me, New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateVariableCode), m_WithExpression.ExpressionType)
                 result = m_WithVariableExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="73" endline="90">
<![CDATA[
 
     Public NotOverridable Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveStatement(Info) AndAlso result
 
         If result = False Then Return result
 
         result = CheckIndexedStatement(Info, TryCast(LSide, InvocationOrIndexExpression)) AndAlso result
 
         m_CompoundExpression = ResolveStatement(LSide, RSide)
 
         result = m_CompoundExpression.ResolveExpression(Info) AndAlso result
 
         m_CompoundExpression = Helper.CreateTypeConversion(Me, m_CompoundExpression, LSide.ExpressionType, result)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="207" endline="223">
<![CDATA[
 
     Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_TypeName Is Nothing AndAlso Location.File(Compiler).IsOptionStrictOn Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30209, Me.Location) AndAlso result
         End If
 
         If m_ConstantExpression Is Nothing Then
             Helper.AddError(Me, "No constant expression.")
             Return False
         End If
 
         result = ResolveConstantValue(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="112" endline="128">
<![CDATA[
 
     ''' <summary>
     ''' Loads the loop control variable onto the stack
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitLoadVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             Emitter.EmitLoadVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False)) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="96" endline="106">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then
             result = m_Clauses.ResolveStatements(Info) AndAlso result
         End If
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="228" endline="236">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="73" endline="87">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="79" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_Condition, Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="34" endline="46">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.LateBoundAccess.Name Is Nothing Then
             result = EmitLateIndexGet(Info) AndAlso result
         Else
             result = EmitLateGet(Info) AndAlso result
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="130" endline="139">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveCode(Info) AndAlso result
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="176" endline="184">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_ConstantExpression IsNot Nothing Then result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="145" endline="155">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameterConstraints IsNot Nothing Then
             result = m_TypeParameterConstraints.ResolveTypeReferences AndAlso result
             result = DefineParameterConstraints() AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="41" endline="52">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameters IsNot Nothing Then
             result = m_TypeParameters.ResolveTypeReferences AndAlso result
         End If
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="52" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then result = m_Clauses.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="25" endline="32">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="120" endline="129">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="73" endline="86">
<![CDATA[
 
     Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal Destination As Mono.Cecil.ParameterDefinition) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.GenerateCode(Info) AndAlso result
         Else
             Helper.Assert(Destination IsNot Nothing)
             Helper.Assert(Destination.IsOptional)
             Emitter.EmitLoadValue(Info, Destination.Constant)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="30" endline="41">
<![CDATA[
 
     Private Function CheckIndexedStatement(ByVal Info As ResolveInfo, ByVal InvocationExpression As InvocationOrIndexExpression) As Boolean
         Dim result As Boolean = True
 
         If InvocationExpression Is Nothing Then Return result
 
         If InvocationExpression.Classification.IsVariableClassification AndAlso CecilHelper.IsArray(InvocationExpression.Expression.ExpressionType) Then
             result = ResolveIndexedStatement(Info, InvocationExpression) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="155" endline="166">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_GeneratedCode = False Then
             If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.GenerateCode(Info) AndAlso result
 
             m_GeneratedCode = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="89" endline="106">
<![CDATA[
 
     Function DefineHandlesOrImplements() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then
             Dim hclause As HandlesClause = m_HandlesOrImplements.HandlesClause
             Dim iclause As MemberImplementsClause = m_HandlesOrImplements.ImplementsClause
             If hclause IsNot Nothing Then
                 'Helper.NotImplemented()
             ElseIf iclause IsNot Nothing Then
                 result = iclause.DefineImplements(Me.CecilBuilder)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="107" endline="123">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         If Info.IsRHS Then
             result = GenerateCodeAsValue(Info) AndAlso result
         ElseIf Info.IsLHS Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="227" endline="243">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveTypeReferences " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveTypeReferences(type) AndAlso result
         Next
 
         result = m_Attributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="89" endline="100">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="517" endline="535">
<![CDATA[
     ''' <summary>
     ''' AttributeBlock  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeBlock(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         tm.AcceptIfNotInternalError(KS.LT)
 
         If ParseAttributeList(Parent, Attributes) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result = tm.AcceptIfNotError(KS.GT) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="30" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Local Is Nothing Then
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
             m_Local = Emitter.DeclareLocal(Info, m_Expression.ExpressionType)
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Emitter.EmitLoadVariable(Info, m_Local)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="50" endline="66">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the instance expression onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="107" endline="119">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info Is Nothing Then
             Info = New EmitInfo(Me)
         End If
 
         result = DefineHandlesOrImplements() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="210" endline="219">
<![CDATA[
 
     Private Function EmitStoreCounterInstanceExpression(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
 
         If Data.InstanceExpression IsNot Nothing Then
             result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="55" endline="66">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info) AndAlso result
         End If
 
         Emitter.EmitLoadVariable(Info, m_Field)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" startline="40" endline="52">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Exception Is Nothing Then
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Rethrow)
         Else
             result = m_Exception.GenerateCode(Info.Clone(Me, True, False, m_Exception.ExpressionType)) AndAlso result
             Emitter.EmitThrow(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="178" endline="187">
<![CDATA[
 
     Public Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then result = m_ImplementsClause.ResolveCode(Info) AndAlso result
 
         Helper.Assert(EventType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="125" endline="136">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_Event.ResolveExpression(Info) AndAlso result
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Compiler.Helper.AddCheck("The result of the expression must be classified as an event access for an event defined in the class itself; ")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="52" endline="61">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_PreCondition, m_PostCondition) AndAlso result
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="73" endline="84">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim method As Mono.Cecil.MethodReference
 
         method = CecilHelper.FindDefinition(m_PropertyGroup.ResolvedProperty).GetMethod
         method = CecilHelper.GetCorrectMember(method, m_PropertyGroup.ResolvedProperty.DeclaringType)
 
         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_PropertyGroup.InstanceExpression, m_PropertyGroup.Parameters, method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="171" endline="182">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         BaseType = Compiler.TypeCache.System_MulticastDelegate
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences(False) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="36" endline="45">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Lock) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="36" endline="43">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_WithExpression) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="38" endline="47">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Condition) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="54" endline="63">
<![CDATA[
 
     Public Function Parse(ByVal RootNamespace As String, ByVal assembly As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = ParseAssemblyDeclaration(RootNamespace, assembly) AndAlso result
 
         result = Compiler.Report.Errors = 0 AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="108" endline="118">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_UsingResources.ResolveCode(Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="90" endline="98">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Lock.ResolveExpression(INfo) AndAlso result
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="407" endline="416">
<![CDATA[
 
     Function EmitAttributes() As Boolean
         Dim result As Boolean = True
 
         If m_Attributes IsNot Nothing Then
             result = m_Attributes.GenerateCode(Nothing) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="147" endline="154">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="52" endline="60">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then result = m_ParameterList.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="121" endline="130">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         result = Helper.ResolveTypeReferences(m_ConstantExpression) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="311" endline="320">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.CustomAttributes IsNot Nothing Then
             result = Me.CustomAttributes.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="30" endline="38">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Expression) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="118" endline="127">
<![CDATA[
 
 
     Public Function ResolveEarly() As Boolean
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
         result = ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="49" endline="58">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveTypeReferences AndAlso result
         result = m_RightExpression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LSide.ResolveTypeReferences AndAlso result
         result = m_RSide.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="36" endline="43">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="81" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="46" endline="53">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedLabel IsNot Nothing Then result = m_ResolvedLabel.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="57" endline="66">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Operand.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="138" endline="146">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="61" endline="70">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="31" endline="37">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_VariableInitializerList IsNot Nothing Then result = m_VariableInitializerList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="55" endline="62">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="41" endline="57">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_ExpressionType = m_Variable.Type
 
         If m_ExpressionType IsNot Nothing AndAlso CecilHelper.IsByRef(m_ExpressionType) Then
             m_ExpressionType = CecilHelper.GetElementType(m_ExpressionType)
         End If
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="65" endline="76">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lInfo As EmitInfo = Info.Clone(Me, RSide)
 
         Helper.Assert(LSide.Classification.IsVariableClassification OrElse LSide.Classification.IsPropertyAccessClassification)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="311" endline="323">
<![CDATA[
 
     Function ResolveAddressOfExpression(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim aoe As AddressOfExpression = TryCast(Me, AddressOfExpression)
 
         If aoe Is Nothing Then
             result = False
         Else
             result = aoe.Resolve(DelegateType) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="166" endline="176">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="222" endline="243">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             'If IsLocalVariable Then
             '    If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
             '    Helper.Assert(m_LocalBuilder IsNot Nothing)
             '    result = EmitVariableInitializer(Info) AndAlso result
             'ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
             '    result = EmitStaticInitializer(Info) AndAlso result
             'Else
             '    'Field builder has been defined in DefineMember
             '    'EmitVariableInitializer will be called by the constructor declaration
             'End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="68" endline="77">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="71" endline="80">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="34" endline="42">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6104" endline="6120">
<![CDATA[
 
     ''' <summary>
     ''' Parses a imports statement as specified on the commandline.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Shared Function ParseImportsStatement(ByVal Parent As ImportsStatement, ByVal str As String) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Parent IsNot Nothing)
         Helper.Assert(Parent.Clauses IsNot Nothing)
 
         result = ParseImportsClauses(Parent.Clauses, str) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="51" endline="59">
<![CDATA[
 
     Public Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         result = AddAttribute() AndAlso result
         result = MyBase.DefineType() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="102" endline="115">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsVariableDeclaration Then
             result = m_VariableDeclaration.GenerateCode(Info.Clone(Me, True, False, UsingVariableType)) AndAlso result
             UsingVariable = m_VariableDeclaration.LocalBuilder
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="157" endline="186">
<![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeDeclarations.Length - 1
             Dim type As TypeDeclaration = m_TypeDeclarations(i)
 
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Green
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveCode " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = type.ResolveCode(Info) AndAlso result
             Compiler.VerifyConsistency(result, type.Location)
         Next
 
         result = m_Attributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="417" endline="453">
<![CDATA[
 
     ''' <summary>
     ''' - All code is emitted for fields with initializers.
     ''' - All the code is emitted for each and every method, constructor, operator and property.
     ''' - Classes, modules, structures, methods, constructors, properties, events, operators should implement IEmittable.Emit(Info as EmitInfo)
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Emit() As Boolean
         Dim result As Boolean = True
 
         result = EmitAttributes() AndAlso result
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Yellow
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Emit " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = Emit(type) AndAlso result
         Next
 
         SetFileVersion()
         SetAdditionalAttributes()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2150" endline="2168">
<![CDATA[
 		}
 
 		public override bool IsVisible
 		{
 			get
 			{
 				if (base.IsVisible)
 				{
 					foreach (Type arg in args)
 					{
 						if (!arg.IsVisible)
 						{
 							return false;
 						}
 					}
 					foreach (Type arg in args)
 					{
 						if (!arg.IsVisible)
 						{
 							return false;
 						}
 					}
 					return true;
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2087" endline="2094">
<![CDATA[
 
     Shared Function ResolveTypeReferences(ByVal ParamArray Collection As ParsedObject()) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             If obj IsNot Nothing Then result = obj.ResolveTypeReferences AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="354" endline="376">
<![CDATA[
 
     ''' <summary>
     ''' - Base classes for classes, modules, structures, enums, interfaces and delegates are set.
     ''' - Implemented interfaces for classes are set.
     ''' - Type parameters for classes and structures are set.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineTypeHierarchy()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypeHierarchy " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineTypeHierarchy(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="331" endline="353">
<![CDATA[
 
 
     ''' <summary>
     ''' - Types are defined with the reflection.emit namespace. 
     ''' - Only classes, modules, structures, interfaces, enums, delegates and eventnos (not a type by itself, bu an event might declare a new delegate). They are only defined, nothing else.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineType()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypes() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypes " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineType(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="377" endline="406">
<![CDATA[
 
     ''' <summary>
     ''' - All the type's members are defined (methods, constructors, properties, fields, events, operators).
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Green
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = DefineMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="296" endline="310">
<![CDATA[
 
     Function ResolveMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="100" endline="114">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         Helper.Assert(VariableType IsNot Nothing)
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="536" endline="554">
<![CDATA[
 
     ''' <summary>
     ''' AttributeList  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeList(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         Do
             Dim Attribute As Attribute
             Attribute = ParseAttribute(Parent)
             If Attribute Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Attributes.Add(Attribute)
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="482" endline="499">
<![CDATA[
 
     ''' <summary>
     '''  Attributes 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         While AttributeBlock.IsMe(tm)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
         While AttributeBlock.IsMe(tm)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="45" endline="59">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Expression As Expression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             result = Expression.GenerateCode(Info.Clone(Expression, True, False, Expression.ExpressionType)) AndAlso result
             If CecilHelper.IsValueType(Expression.ExpressionType) OrElse CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
                 Emitter.EmitBox(Info, Expression.ExpressionType)
             End If
         Else
             Throw New InternalException(Expression)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="36" endline="46">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
         Emitter.EmitConversion(m_ErrNumber.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="74" endline="86">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim casestmt As CaseStatement = Me.FindFirstParent(Of CaseStatement)()
         Dim selectstmt As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         result = m_ComparisonExpression.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
 
         Emitter.EmitBranchIfTrue(Info, casestmt.StartCode)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
 
         Emitter.EmitLoadIndirect(Info, m_Expression.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="55" endline="69">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info)
         Else
             result = True
         End If
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="109" endline="117">
<![CDATA[
 
     Private Function EmitStringToCharArray(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Expression.GenerateCode(Info.Clone(Info.Context, Compiler.TypeCache.System_String)) AndAlso result
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToCharArrayRankOne_String)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="68" endline="81">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveTypeReferences AndAlso result
         'Not necessary.'result = m_ArrayTypeModifiers.ResolveCode AndAlso result
 
         Dim tp As Mono.Cecil.TypeReference = m_TypeName.ResolvedType
         tp = m_ArrayTypeModifiers.CreateArrayType(tp)
         m_ResolvedType = tp
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="54" endline="65">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_ExpressionType = m_PropertyAccess.Type
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="91" endline="101">
<![CDATA[
 
     Friend NotOverridable Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         'result = m_CompoundExpression.GenerateCode(Info.Clone(True, False, LSide.ExpressionType)) AndAlso result
 
         Dim lInfo As EmitInfo = Info.Clone(Me, m_CompoundExpression)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
         Classification = m_Expression.Classification
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="49" endline="57">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="48" endline="56">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_Destination = Me.FindFirstParent(Of CodeBlock).FindLabel(m_GotoWhere)
         result = m_Destination IsNot Nothing AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="76" endline="84">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.PropertyReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="67" endline="75">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="116" endline="123">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_TypeName, m_ArgumentList, m_VariableInitializer) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="66" endline="77">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim propD As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(m_PropertyAccess.ResolvedProperty)
         Dim methodD As Mono.Cecil.MethodReference = propD.GetMethod
         Dim methodR As Mono.Cecil.MethodReference = CecilHelper.GetCorrectMember(methodD, m_PropertyAccess.ResolvedProperty.DeclaringType, True)
         Dim methodE As Mono.Cecil.MethodReference = Helper.GetMethodOrMethodReference(Compiler, methodR)
 
         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_PropertyAccess.InstanceExpression, m_PropertyAccess.Parameters, methodE) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="64" endline="74">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_Object
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Me.FindDefaultConstructors()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="204" endline="213">
<![CDATA[
 
     Function DefineOverrides() As Boolean
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then
             result = m_ImplementsClause.DefineImplements(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="44" endline="54">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.Classification IsNot Nothing Then
             Me.Classification = New ValueClassification(Me, m_Field.FieldType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="35" endline="42">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         result = LiteralExpression.IsMe(tm) OrElse ParenthesizedExpression.IsMe(tm) OrElse InstanceExpression.IsMe(tm) OrElse SimpleNameExpression.IsMe(tm) OrElse AddressOfExpression.IsMe(tm)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="315" endline="322">
<![CDATA[
 
     Public Overridable Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         result = m_Signature.Parameters.ResolveParameters(Info, True) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="35" endline="43">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_ValueType
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="77" endline="85">
<![CDATA[
 
     Function Resolve(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.Resolve(DelegateType) AndAlso result
         m_ExpressionType = DelegateType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="590" endline="614">
<![CDATA[
 
     Function GenerateMyResponse() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Response"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Response As Global.System.Web.HttpResponse" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Response    " & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="559" endline="583">
<![CDATA[
 
     Function GenerateMyRequest() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Request"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Request As Global.System.Web.HttpRequest" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Request" & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="486" endline="507">
<![CDATA[
 
     Function GenerateMyLog() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        Private Shared ReadOnly m_LogObjectProvider As ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog) = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)" & VB.vbNewLine & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application.Log"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Log As Global.Microsoft.VisualBasic.Logging.AspLog" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Return MyProject.m_LogObjectProvider.GetInstance" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         'ProjectCodeCctor.AppendLine("            m_LogObjectProvider = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1693" endline="1700">
<![CDATA[
 
 		public bool IsAssigned (BlockContext ec)
 		{
 			if (VariableInfo == null)
 				throw new Exception ();
 
 			return !ec.DoFlowAnalysis || ec.CurrentBranching.IsAssigned (VariableInfo);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="398" endline="406">
<![CDATA[
 
     Function GenerateMy() As Boolean
         Dim result As Boolean = True
         Dim generator As New MyGenerator(Me)
 
         result = generator.Generate() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="46" endline="53">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="96" endline="103">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="66" endline="77">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Clauses.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Each clause in the statement must be classified as a variable or a property access whose type is an array type or Object, and be followed by a list of array bounds. ")
         Compiler.Helper.AddCheck("The number of the bounds must be consistent with the type of the variable; any number of bounds is allowed for Object.")
         Compiler.Helper.AddCheck("If the Preserve keyword is specified, then the expressions must also be classifiable as a value, and the new size for each dimension except for the rightmost one must be the same as the size of the existing array. ")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="117" endline="125">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AssignStatement.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="325" endline="332">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="47" endline="56">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.ResolveExpression(info) AndAlso result
 
         Compiler.Helper.AddCheck("The expression must be classified as a value and its type must be implicitly convertible to Integer.")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info) AndAlso result 'Helper.NotImplemented()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="64" endline="72">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Initializer.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="32" endline="38">
<![CDATA[
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AttributeArgumentExpression.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="57" endline="65">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Helper.GenerateCodeCollection(m_Clauses, Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="49" endline="61">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Expressions.Length - 1
             result = m_Expressions(i).ResolveExpression(Info) AndAlso result
             If result Then
                 m_Expressions(i) = Helper.CreateTypeConversion(Me, m_Expressions(i), Compiler.TypeCache.System_Int32, result)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="55" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeParameters.Length - 1
             If m_TypeParameters(i) IsNot Nothing Then
                 result = m_TypeParameters(i).ResolveTypeReferences() AndAlso result
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="45" endline="57">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim nullExp As New NothingConstantExpression(Me)
         result = nullExp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
         For i As Integer = 0 To m_Targets.Count - 1
             Dim exp As Expression = DirectCast(m_Targets.Item(i), Expression)
             result = exp.GenerateCode(Info.Clone(Me, nullExp)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="144" endline="165">
<![CDATA[
 		}
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				if (declaringType.ContainsGenericParameters)
 				{
 					return true;
 				}
 				if (methodArgs != null)
 				{
 					foreach (Type type in methodArgs)
 					{
 						if (type.ContainsGenericParameters)
 						{
 							return true;
 						}
 					}
 					foreach (Type type in methodArgs)
 					{
 						if (type.ContainsGenericParameters)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="72" endline="90">
<![CDATA[
 	}
 
 	static class ArrayComparer
 	{
 		public static bool IsEqual<T> (T[] array1, T[] array2)
 		{
 			if (array1 == null || array2 == null)
 				return array1 == array2;
 
 			var eq = EqualityComparer<T>.Default;
 
 			for (int i = 0; i < array1.Length; ++i) {
 				if (!eq.Equals (array1[i], array2[i])) {
 					return false;
 				}
 			}
 			for (int i = 0; i < array1.Length; ++i) {
 				if (!eq.Equals (array1[i], array2[i])) {
 					return false;
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="663" endline="674">
<![CDATA[
 
 		Expression ResolvePrimitivePredefinedType (Expression expr)
 		{
 			expr = DoNumericPromotion (Oper, expr);
 			TypeSpec expr_type = expr.Type;
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				if (t == expr_type)
 					return expr;
 			}
 			foreach (TypeSpec t in predefined) {
 				if (t == expr_type)
 					return expr;
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="265" endline="283">
<![CDATA[
 		}
 
 		public virtual bool ContainsGenericParameters
 		{
 			get
 			{
 				if (this.IsGenericParameter)
 				{
 					return true;
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="861" endline="876">
<![CDATA[
 
 		private static bool MatchParameterTypes(ParameterInfo[] parameters, Type[] types)
 		{
 			if (parameters.Length == types.Length)
 			{
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (!parameters[i].ParameterType.Equals(types[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (!parameters[i].ParameterType.Equals(types[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="909" endline="924">
<![CDATA[
 
 		public Type GetInterface(string name, bool ignoreCase)
 		{
 			if (ignoreCase)
 			{
 				throw new NotImplementedException();
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (type.FullName == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (type.FullName == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1502" endline="1514">
<![CDATA[
 
 		protected override bool IsNotCLSCompliant ()
 		{
 			if (base.IsNotCLSCompliant ())
 				return true;
 
 			foreach (var ta in TypeArguments) {
 				if (ta.MemberDefinition.IsNotCLSCompliant ())
 					return true;
 			}
 			foreach (var ta in TypeArguments) {
 				if (ta.MemberDefinition.IsNotCLSCompliant ())
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1480" endline="1495">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			if (type_params != null) {
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1473" endline="1484">
<![CDATA[
 
 		internal MethodBase FindMethod(string name, MethodSignature signature)
 		{
 			foreach (MethodBase method in __GetDeclaredMethods())
 			{
 				if (method.Name == name && method.MethodSignature.Equals(signature))
 				{
 					return method;
 				}
 			}
 			foreach (MethodBase method in __GetDeclaredMethods())
 			{
 				if (method.Name == name && method.MethodSignature.Equals(signature))
 				{
 					return method;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1485" endline="1496">
<![CDATA[
 
 		internal FieldInfo FindField(string name, FieldSignature signature)
 		{
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (field.Name == name && field.FieldSignature.Equals(signature))
 				{
 					return field;
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (field.Name == name && field.FieldSignature.Equals(signature))
 				{
 					return field;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="125" endline="139">
<![CDATA[
 		}
 
 		public override Module[] GetLoadedModules(bool getResourceModules)
 		{
 			List<Module> list = new List<Module>();
 			list.Add(manifestModule);
 			foreach (Module m in externalModules)
 			{
 				if (m != null)
 				{
 					list.Add(m);
 				}
 			}
 			foreach (Module m in externalModules)
 			{
 				if (m != null)
 				{
 					list.Add(m);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="369" endline="384">
<![CDATA[
 
 		private static bool IsEqual(byte[] b1, byte[] b2)
 		{
 			if (b1.Length != b2.Length)
 			{
 				return false;
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="69" endline="78">
<![CDATA[
 
 		protected override bool HasVolatileModifier (MetaType[] modifiers)
 		{
 			foreach (var t in modifiers) {
 				if (t.Name == "IsVolatile" && t.Namespace == CompilerServicesNamespace)
 					return true;
 			}
 			foreach (var t in modifiers) {
 				if (t.Name == "IsVolatile" && t.Namespace == CompilerServicesNamespace)
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\MetadataRW.cs" startline="87" endline="99">
<![CDATA[
 
 		private static bool IsBig(int bitsUsed, params Table[] tables)
 		{
 			int limit = 1 << (16 - bitsUsed);
 			foreach (Table table in tables)
 			{
 				if (table.RowCount >= limit)
 				{
 					return true;
 				}
 			}
 			foreach (Table table in tables)
 			{
 				if (table.RowCount >= limit)
 				{
 					return true;
 				}
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="462" endline="473">
<![CDATA[
 
 		public EventInfo GetEvent(string name, BindingFlags bindingAttr)
 		{
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="720" endline="731">
<![CDATA[
 
 		public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
 		{
 			foreach (ConstructorInfo constructor in GetConstructors(bindingAttr))
 			{
 				if (constructor.MethodSignature.MatchParameterTypes(types))
 				{
 					return constructor;
 				}
 			}
 			foreach (ConstructorInfo constructor in GetConstructors(bindingAttr))
 			{
 				if (constructor.MethodSignature.MatchParameterTypes(types))
 				{
 					return constructor;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="743" endline="754">
<![CDATA[
 
 		public virtual Type GetNestedType(string name, BindingFlags bindingAttr)
 		{
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="515" endline="526">
<![CDATA[
 
 		public FieldInfo GetField(string name, BindingFlags bindingAttr)
 		{
 			foreach (FieldInfo field in GetFields(bindingAttr))
 			{
 				if (field.Name == name)
 				{
 					return field;
 				}
 			}
 			foreach (FieldInfo field in GetFields(bindingAttr))
 			{
 				if (field.Name == name)
 				{
 					return field;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="815" endline="826">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
 		{
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name)
 				{
 					return prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name)
 				{
 					return prop;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="254" endline="266">
<![CDATA[
 
 		internal static int GetHashCode(Type[][][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="241" endline="253">
<![CDATA[
 
 		internal static int GetHashCode(Type[][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1354" endline="1367">
<![CDATA[
 
 		// This returns true if this type directly (i.e. not inherited from the base class) implements the interface.
 		// Note that a complicating factor is that the interface itself can be implemented by an interface that extends it.
 		private bool IsDirectlyImplementedInterface(Type interfaceType)
 		{
 			foreach (Type iface in __GetDeclaredInterfaces())
 			{
 				if (interfaceType.IsAssignableFrom(iface))
 				{
 					return true;
 				}
 			}
 			foreach (Type iface in __GetDeclaredInterfaces())
 			{
 				if (interfaceType.IsAssignableFrom(iface))
 				{
 					return true;
 				}
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="3205" endline="3214">
<![CDATA[
 
 		public bool UnfixedVariableExists {
 			get {
 				foreach (TypeSpec ut in fixed_types) {
 					if (ut == null)
 						return true;
 				}
 				foreach (TypeSpec ut in fixed_types) {
 					if (ut == null)
 						return true;
 				}
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="585" endline="594">
<![CDATA[
 
 		public static TypeParameter FindTypeParameter (TypeParameter[] tparams, string name)
 		{
 			foreach (var tp in tparams) {
 				if (tp.Name == name)
 					return tp;
 			}
 			foreach (var tp in tparams) {
 				if (tp.Name == name)
 					return tp;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="187" endline="204">
<![CDATA[
 
     Function CreateImplicitTypes() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitTypes " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitTypes = TryCast(Type, IHasImplicitTypes)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitTypes AndAlso result
 
             result = CreateImplicitTypes(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="264" endline="281">
<![CDATA[
 
     Function CreateImplicitMembers() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitMembers " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitMembers = TryCast(Type, IHasImplicitMembers)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitMembers AndAlso result
 
             result = CreateImplicitMembers(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="63" endline="73">
<![CDATA[
 
     Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To Count - 1
             Dim pO As BaseObject = TryCast(CObj(Item(i)), BaseObject)
             If pO IsNot Nothing Then
                 result = pO.ResolveCode(Info) AndAlso result
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3109" endline="3121">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Type()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         For Each t As Type In Types
             Helper.Assert(t IsNot Nothing)
             result &= sep & t.ToString
             sep = ", "
         Next
 
         Return "{" & result & "}"
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="925" endline="937">
<![CDATA[
 
 		public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="334" endline="346">
<![CDATA[
 
 		public Type[] FindTypes(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="56" endline="69">
<![CDATA[
 		}
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="968" endline="974">
<![CDATA[
 
     Function FindType(ByVal FullName As String) As TypeDeclaration
         For Each type As TypeDeclaration In Me.Types
             If Helper.CompareName(type.FullName, FullName) Then Return type
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="82" endline="89">
<![CDATA[
 
     Overrides Function ToString() As String
         Dim result As String = ""
         For Each atn As ArrayTypeModifier In m_ArrayTypeModifiers
             result &= atn.ToString
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="37" endline="44">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_List.Count - 1
             result = m_List(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="311" endline="323">
<![CDATA[
 
 		internal Type GetEnumUnderlyingTypeImpl()
 		{
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (!field.IsStatic)
 				{
 					// the CLR assumes that an enum has only one instance field, so we can do the same
 					return field.FieldType;
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (!field.IsStatic)
 				{
 					// the CLR assumes that an enum has only one instance field, so we can do the same
 					return field.FieldType;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="88" endline="95">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_Handlers.Length - 1
             result = m_Handlers(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="191" endline="200">
<![CDATA[
 
 		public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="432" endline="441">
<![CDATA[
 
 		public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineNestedType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1872" endline="1881">
<![CDATA[
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameterInfos = new ParameterInfo[parameterTypes.Length];
 			for (int i = 0; i < parameterInfos.Length; i++)
 			{
 				parameterInfos[i] = new ParameterInfoImpl(this, parameterTypes[i], i);
 			}
 			for (int i = 0; i < parameterInfos.Length; i++)
 			{
 				parameterInfos[i] = new ParameterInfoImpl(this, parameterTypes[i], i);
 			}
 			return parameterInfos;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="575" endline="584">
<![CDATA[
 
 		public override MethodInfo[] GetOtherMethods(bool nonPublic)
 		{
 			MethodInfo[] others = eventInfo.GetOtherMethods(nonPublic);
 			for (int i = 0; i < others.Length; i++)
 			{
 				others[i] = Wrap(others[i]);
 			}
 			for (int i = 0; i < others.Length; i++)
 			{
 				others[i] = Wrap(others[i]);
 			}
 			return others;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="463" endline="472">
<![CDATA[
 
 		public override MethodInfo[] GetAccessors(bool nonPublic)
 		{
 			MethodInfo[] accessors = property.GetAccessors(nonPublic);
 			for (int i = 0; i < accessors.Length; i++)
 			{
 				accessors[i] = Wrap(accessors[i]);
 			}
 			for (int i = 0; i < accessors.Length; i++)
 			{
 				accessors[i] = Wrap(accessors[i]);
 			}
 			return accessors;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2185" endline="2194">
<![CDATA[
 
 		public override FieldInfo[] __GetDeclaredFields()
 		{
 			FieldInfo[] fields = type.__GetDeclaredFields();
 			for (int i = 0; i < fields.Length; i++)
 			{
 				fields[i] = fields[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < fields.Length; i++)
 			{
 				fields[i] = fields[i].BindTypeParameters(this);
 			}
 			return fields;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2195" endline="2204">
<![CDATA[
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			Type[] interfaces = type.__GetDeclaredInterfaces();
 			for (int i = 0; i < interfaces.Length; i++)
 			{
 				interfaces[i] = interfaces[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < interfaces.Length; i++)
 			{
 				interfaces[i] = interfaces[i].BindTypeParameters(this);
 			}
 			return interfaces;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2205" endline="2214">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			MethodBase[] methods = type.__GetDeclaredMethods();
 			for (int i = 0; i < methods.Length; i++)
 			{
 				methods[i] = methods[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < methods.Length; i++)
 			{
 				methods[i] = methods[i].BindTypeParameters(this);
 			}
 			return methods;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2220" endline="2229">
<![CDATA[
 
 		public override EventInfo[] __GetDeclaredEvents()
 		{
 			EventInfo[] events = type.__GetDeclaredEvents();
 			for (int i = 0; i < events.Length; i++)
 			{
 				events[i] = events[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < events.Length; i++)
 			{
 				events[i] = events[i].BindTypeParameters(this);
 			}
 			return events;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="69" endline="79">
<![CDATA[
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = method.GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2230" endline="2239">
<![CDATA[
 
 		public override PropertyInfo[] __GetDeclaredProperties()
 		{
 			PropertyInfo[] properties = type.__GetDeclaredProperties();
 			for (int i = 0; i < properties.Length; i++)
 			{
 				properties[i] = properties[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < properties.Length; i++)
 			{
 				properties[i] = properties[i].BindTypeParameters(this);
 			}
 			return properties;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="288" endline="299">
<![CDATA[
 
 		internal int Hash()
 		{
 			int hash = 0;
 			int len = this.Length;
 			for (int i = 0; i < len; i++)
 			{
 				hash *= 37;
 				hash ^= buffer[i];
 			}
 			for (int i = 0; i < len; i++)
 			{
 				hash *= 37;
 				hash ^= buffer[i];
 			}
 			return hash;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4081" endline="4093">
<![CDATA[
 
     Private Function ParseConstantDeclarations(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal Modifiers As Modifiers) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Do
             Dim newCD As ConstantDeclaration = Nothing
             newCD = ParseConstantDeclaration(Parent, New ParseAttributableInfo(Parent.Compiler, Attributes), Modifiers)
             If newCD Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Add(newCD)
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4832" endline="4853">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of TypeVariableDeclaration)
             'Console.WriteLine("ParseTypeVariableDeclarators...")
             tmp = ParseTypeVariableDeclarator(Parent, Modifiers, Info)
             'Console.WriteLine("Got something
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4812" endline="4831">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLocalVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of LocalVariableDeclaration)
             tmp = ParseLocalVariableDeclarator(Parent, Modifiers, Info)
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="500" endline="516">
<![CDATA[
     ''' <summary>
     '''  Parses attributes (if any). Always returns something.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject) As Attributes
         Dim result As New Attributes(Parent)
 
         If Attributes.IsMe(tm) Then
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="45" endline="60">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim falseLabel As Label = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, falseLabel)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, ParentAsIfStatement.EndLabel)
 
         Emitter.MarkLabel(Info, falseLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="102" endline="111">
<![CDATA[
 
     Private Function GenerateCodeForPreserve(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_ArrayType)) AndAlso result
         Emitter.EmitCastClass(Info, m_Expression.ExpressionType, Compiler.TypeCache.System_Array)
         result = GenerateCodeForNewArray(Info) AndAlso result
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Utils__CopyArray_Array_Array)
         Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Array, m_ArrayType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="30" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Expression.GenerateCode(Info.Clone(Me, ExpressionType)) AndAlso result
 
         If CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
             Emitter.EmitBox(Info, Expression.ExpressionType)
         End If
 
         Emitter.EmitIsInst(Info, Expression.ExpressionType, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="388" endline="405">
<![CDATA[
 
     Public Shared Function EmitLateIndexSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - The arguments
         '3 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1281" endline="1289">
<![CDATA[
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BoxExpression.vb" startline="60" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim tp As TypeReference
 
         result = m_Expression.GenerateCode(Info) AndAlso result
 
         tp = m_Expression.ExpressionType
         If CecilHelper.IsByRef(tp) Then
             tp = CecilHelper.GetElementType(tp)
         End If
         Emitter.EmitBox(Info, tp)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="85" endline="94">
<![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Helper.Assert(Me.DeclaringType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="115" endline="124">
<![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="83" endline="92">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences() AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="40" endline="48">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="181" endline="192">
<![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         'Helper.SetTypeOrTypeBuilder(Compiler, ParameterTypes)
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="105" endline="114">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="45" endline="51">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="68" endline="75">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="140" endline="147">
<![CDATA[
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             If m_InstanceExpression Is Nothing AndAlso m_Classification IsNot Nothing Then
                 m_InstanceExpression = m_Classification.InstanceExpression
             End If
             Return m_InstanceExpression
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="45" endline="53">
<![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ArgumentList
         Get
             If m_Parameters Is Nothing AndAlso m_Classification IsNot Nothing Then
                 m_Parameters = m_Classification.Parameters
             End If
             Return m_Parameters
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="47" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_List.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="125" endline="132">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="412" endline="419">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = GenerateCodeInternal(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="47" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         '#If DEBUG Then
         '        Dim m1, m2 As MethodInfo
         '        m1 = Me.GetType.GetMethod("ResolveTypeReferences")
         '        m2 = GetType(BlockStatement).GetMethod("ResolveTypeReferences")
         '        Helper.Assert(m1 IsNot m2)
         '#End If
 
         result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="64" endline="71">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Targets.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="71" endline="78">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ConstraintList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="188" endline="195">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="141" endline="149">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="62" endline="69">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Expressions) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="66" endline="88">
<![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         'Dim m_MethodAttributes As MethodAttributes
         'If m_HandlerType = KS.RaiseEvent Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Private
         'Else
         '    m_MethodAttributes = m_MethodAttributes Or Me.Modifiers.GetMethodAttributeScope
         'End If
         'm_MethodAttributes = m_MethodAttributes Or MethodAttributes.SpecialName
         'If DeclaringType.IsInterface Then
         '    m_MethodAttributes = m_MethodAttributes Or Reflection.MethodAttributes.Abstract Or Reflection.MethodAttributes.Virtual Or MethodAttributes.CheckAccessOnOverride Or MethodAttributes.NewSlot
         'End If
         'If Me.IsShared Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Static
         'End If
         'MyBase.Attributes = m_MethodAttributes
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="67" endline="74">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="59" endline="66">
<![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="77" endline="84">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="281" endline="288">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="409" endline="416">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="121" endline="128">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="170" endline="177">
<![CDATA[
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="211" endline="218">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = VerifyConstraints() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="349" endline="356">
<![CDATA[
 
     Overridable Function DefineType() As Boolean Implements IDefinableType.DefineType
         Dim result As Boolean = True
 
         Helper.Assert(BaseType IsNot Nothing OrElse Me.CecilType.IsInterface)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="80" endline="88">
<![CDATA[
     End Property
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="42" endline="51">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         ' result = Helper.ResolveTypeReferences(m_UsingResources) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="53" endline="60">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="532" endline="540">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         'Define type parameters
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="199" endline="210">
<![CDATA[
 
 		internal override Type GetGenericMethodArgument(int index)
 		{
 			if (methodArgs == null)
 			{
 				return method.GetGenericMethodArgument(index);
 			}
 			else
 			{
 				return methodArgs[index];
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="85" endline="91">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New LiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="187" endline="198">
<![CDATA[
 
 		public override Type[] GetGenericArguments()
 		{
 			if (methodArgs == null)
 			{
 				return method.GetGenericArguments();
 			}
 			else
 			{
 				return (Type[])methodArgs.Clone();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="32" endline="38">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New BooleanLiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="730" endline="738">
<![CDATA[
 
 		public int AddResumePoint (ResumableStatement stmt)
 		{
 			if (resume_points == null)
 				resume_points = new List<ResumableStatement> ();
 
 			resume_points.Add (stmt);
 			return resume_points.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="164" endline="172">
<![CDATA[
 
 		public int OpenScope (int start_offset)
 		{
 			if (current_method == null)
 				return 0;
 
 			current_method.StartBlock (CodeBlockEntry.Type.Lexical, start_offset);
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="209" endline="220">
<![CDATA[
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			if (type != null)
 			{
 				return binder.BindTypeParameter(this);
 			}
 			else
 			{
 				return binder.BindMethodParameter(this);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="134" endline="148">
<![CDATA[
 
     ''' <summary>
     ''' Reclassifies the method group to a value, at the same time the method
     ''' group might be resolved using an empty argument list.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function ReclassifyToValue() As ValueClassification
         Dim result As ValueClassification
         If m_Resolved = False Then
             Me.ResolveGroup(New ArgumentList(Me.Parent))
         End If
         result = New ValueClassification(Me)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3091" endline="3098">
<![CDATA[
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="153" endline="162">
<![CDATA[
     End Property
 
     ReadOnly Property LocalBuilder() As Mono.Cecil.Cil.VariableDefinition
         Get
             If m_LocalVariable IsNot Nothing Then
                 Return m_LocalVariable.LocalBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="125" endline="134">
<![CDATA[
     End Property
 
     Public ReadOnly Property GetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Get IsNot Nothing Then
                 Return m_Get.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="141" endline="150">
<![CDATA[
     End Property
 
     Public ReadOnly Property SetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Set IsNot Nothing Then
                 Return m_Set.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6761" endline="6769">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			if (type == null)
 				type = ec.CurrentType;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="39" endline="46">
<![CDATA[
 
     ReadOnly Property Identifier() As String
         Get
             If m_Identifier IsNot Nothing Then
                 Return m_Identifier
             End If
             Return m_IdentifierOrKeyword.Identifier
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1104" endline="1111">
<![CDATA[
 
 		public TypeInfo GetSubStruct (string name)
 		{
 			if (struct_info == null)
 				return null;
 
 			return struct_info.GetStructField (name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1096" endline="1103">
<![CDATA[
 
 		public int GetFieldIndex (string name)
 		{
 			if (struct_info == null)
 				return 0;
 
 			return struct_info [name];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="379" endline="388">
<![CDATA[
 
     Overridable Function DefineOverrides() As Boolean
         Dim result As Boolean = True
 
         If m_MethodOverrides IsNot Nothing Then
             Throw New NotImplementedException
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="44" endline="53">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Bases IsNot Nothing)
         result = Helper.ResolveTypeReferencesCollection(m_Bases)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="73" endline="81">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Identifier
         Dim result As Identifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         result = New Identifier(NewParent)
         result.Init(m_Name, Location, m_TypeCharacter)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="154" endline="170">
<![CDATA[
     End Property
 
     Private m_FakeGenerator As EmitLog
     ''' <summary>
     ''' The ILGenerator used to emit the code.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ILGen() As EmitLog
         Get
             If m_FakeGenerator Is Nothing Then
                 m_FakeGenerator = New EmitLog(Compiler)
                 m_FakeGenerator.CilBody = CilBody
             End If
             Return m_FakeGenerator
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="551" endline="569">
<![CDATA[
 
     ''' <summary>
     ''' This function returns a COPY of the members list in the cache.
     ''' To be avoided if possible.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupMembersFlattened(ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim tmp As MemberCacheEntry
 
         tmp = LookupFlattened(Name)
         If tmp IsNot Nothing Then
             result.AddRange(tmp.Members)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="74" endline="82">
<![CDATA[
 
 		public Constant ImplicitConversionRequired (ResolveContext ec, TypeSpec type, Location loc)
 		{
 			Constant c = ConvertImplicitly (ec, type);
 			if (c == null)
 				Error_ValueCannotBeConverted (ec, loc, type, false);
 
 			return c;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="54" endline="60">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterConstraints
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterConstraints(NewParent)
         result.Init(m_ConstraintList.clone(result))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="39" endline="45">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArgumentExpression
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArgumentExpression(NewParent)
         result.Init(m_Expression.Clone(result))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="44" endline="54">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim tpparent As IType = Me.FindFirstParent(Of IType)()
         m_ExpressionType = tpparent.BaseType
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="165" endline="174">
<![CDATA[
 
     ''' <summary>
     ''' OverloadableUnaryOperator  
     ''' </summary>
     ''' <param name="token"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsOverloadableUnaryOperator(ByVal token As Token) As Boolean
         Return token = KS.Add OrElse token = KS.Minus OrElse token = KS.Not OrElse token.Equals("IsTrue") OrElse token.Equals("IsFalse")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="264" endline="273">
<![CDATA[
 	
 	BindingFlags DefaultFlags {
 		get {
 			BindingFlags f = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
 			
 			if (declared_only)
 				f |= BindingFlags.DeclaredOnly;
 			
 			return f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1450" endline="1459">
<![CDATA[
 
 		public bool IsFieldAssigned (MyBitVector vector, string field_name)
 		{
 			int field_idx = TypeInfo.GetFieldIndex (field_name);
 
 			if (field_idx == 0)
 				return true;
 
 			return vector [Offset + field_idx];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="97" endline="104">
<![CDATA[
 
 		public virtual Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (ArgType == AType.Default)
 				ec.Report.Error (854, Expr.Location, "An expression tree cannot contain an invocation which uses optional parameter");
 
 			return Expr.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="402" endline="415">
<![CDATA[
 
 		public virtual ModuleBuilder CreateModuleBuilder ()
 		{
 			if (file_name == null)
 				throw new NotSupportedException ("transient module in static assembly");
 
 			var module_name = Path.GetFileName (file_name);
 
 			// Always initialize module without symbolInfo. We could be framework dependent
 			// but returned ISymbolWriter does not have all what we need therefore some
 			// adaptor will be needed for now we alwayas emit MDB format when generating
 			// debug info
 			return Builder.DefineDynamicModule (module_name, module_name, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="89" endline="99">
<![CDATA[
 
 		internal Module ToModule(Assembly assembly)
 		{
 			if (module.Assembly != null)
 			{
 				throw new InvalidOperationException();
 			}
 			imported = true;
 			module.SetAssembly(assembly);
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2362" endline="2371">
<![CDATA[
 		}
 
 		internal override int GetModuleBuilderToken()
 		{
 			if (token == 0)
 			{
 				token = ((ModuleBuilder)type.Module).ImportType(this);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1600" endline="1609">
<![CDATA[
 		}
 
 		internal sealed override int GetModuleBuilderToken()
 		{
 			if (token == 0)
 			{
 				token = ((ModuleBuilder)elementType.Module).ImportType(this);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="467" endline="474">
<![CDATA[
 
 		public bool IsCompilerGenerated {
 			get	{
 				if ((mod_flags & Modifiers.COMPILER_GENERATED) != 0)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="77" endline="85">
<![CDATA[
 
 		public ILGenerator GetILGenerator(int streamSize)
 		{
 			if (ilgen == null)
 			{
 				ilgen = new ILGenerator(typeBuilder.ModuleBuilder, streamSize);
 			}
 			return ilgen;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="155" endline="163">
<![CDATA[
 
 		public int DefineNamespace (string name, CompileUnitEntry unit,
 					    string[] using_clauses, int parent)
 		{
 			if ((unit == null) || (using_clauses == null))
 				throw new NullReferenceException ();
 
 			return unit.DefineNamespace (name, using_clauses, parent);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="209" endline="218">
<![CDATA[
 
 		//
 		// Keeps result of non-variable expression
 		//
 		LocalTemporary LocalVariable {
 			get {
 				if (temp == null)
 					temp = new LocalTemporary (expr.Type);
 				return temp;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="152" endline="160">
<![CDATA[
 
 		public byte[] GetSignature()
 		{
 			if (module == null)
 			{
 				throw new NotSupportedException();
 			}
 			return GetSignature(module).ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ResumeStatement.vb" startline="70" endline="81">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Helper.AddCheck("Resume statement can only occur in methods with no structured exception handling.")
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         block.HasUnstructuredExceptionHandling = True
         block.HasResume = True
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="298" endline="307">
<![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal Types() As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Types.Length = Me.Count)
 
         For i As Integer = 0 To Count - 1
             result = Item(i).GenerateCode(Info.Clone(Me, True, False, Types(i)), Nothing) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="80" endline="98">
<![CDATA[
 
     ''' <summary>
     ''' Resolves either all optional parameters or all non-optional parameters.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="OptionalParameters"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function ResolveParameters(ByVal Info As ResolveInfo, ByVal OptionalParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Count - 1
             If Me(i).Modifiers.Is(ModifierMasks.Optional) = OptionalParameters Then
                 result = Me(i).ResolveCode(Info) AndAlso result
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="72" endline="86">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.DefineLabel(Info)
 
         For i As Integer = 0 To m_Cases.Count - 1
             Dim stmt As CaseStatement = m_Cases(i)
             result = stmt.GenerateCode(Info) AndAlso result
         Next
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="530" endline="537">
<![CDATA[
     Function AcceptAll(ByVal ParamArray Specials() As KS) As Boolean
         Dim i As Integer
         AcceptAll = True
         For i = 0 To Specials.Length - 1
             AcceptAll = PeekToken(i).Equals(Specials(i)) AndAlso AcceptAll
         Next
         If AcceptAll Then NextToken(Specials.Length)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2120" endline="2129">
<![CDATA[
 
     Shared Function CloneExpressionArray(ByVal Expressions() As Expression, ByVal NewParent As ParsedObject) As Expression()
         Dim result(Expressions.GetUpperBound(0)) As Expression
         For i As Integer = 0 To result.GetUpperBound(0)
             If Expressions(i) IsNot Nothing Then
                 result(i) = Expressions(i).Clone(NewParent)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="291" endline="306">
<![CDATA[
 
     ''' <summary>
     ''' The name of the method. (Any method actually, since they should all have the same name).
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property MethodName() As String
         Get
             For i As Integer = 0 To m_Group.Count - 1
                 If m_Group(i) IsNot Nothing Then
                     Return m_Group(i).Name
                 End If
             Next
             Throw New InternalException(Me)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="132" endline="141">
<![CDATA[
     End Property
 
     ReadOnly Property CandidatesLeft() As Integer
         Get
             Dim result As Integer
             For i As Integer = 0 To m_Candidates.Count - 1
                 If m_Candidates(i) IsNot Nothing Then result += 1
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="549" endline="562">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveTypeReferences AndAlso result
         Next
 
         For i As Integer = 0 To m_Statements.Count - 1
             result = m_Statements(i).ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="95" endline="108">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Signature.Parameters IsNot Nothing Then
             For i As Integer = 0 To Signature.Parameters.Count - 1
                 result = Signature.Parameters(i).GenerateCode(Info) AndAlso result
             Next
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2111" endline="2119">
<![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IList, ByVal Info As EmitInfo, ByVal Types As Mono.Cecil.TypeReference()) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Collection.Count = Types.Length)
         For i As Integer = 0 To Collection.Count - 1
             result = DirectCast(Collection(i), IBaseObject).GenerateCode(Info.Clone(Info.Context, Info.IsRHS, Info.IsExplicitConversion, Types(i))) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1618" endline="1636">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance () || !IsExposedFromAssembly ()) {
 				return false;
 			}
 
 			if (!parameters.IsEmpty && Parent.Definition.IsAttribute) {
 				foreach (TypeSpec param in parameters.Types) {
 					if (param.IsArray) {
 						return true;
 					}
 				}
 				foreach (TypeSpec param in parameters.Types) {
 					if (param.IsArray) {
 						return true;
 					}
 				}
 			}
 
 			has_compliant_args = true;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2840" endline="2859">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (iface_exprs != null) {
 				foreach (var iface in iface_exprs) {
 					if (iface.Type.IsCLSCompliant ())
 						continue;
 
 					Report.SymbolRelatedToPreviousError (iface.Type);
 					Report.Warning (3027, 1, Location, "`{0}' is not CLS-compliant because base interface `{1}' is not CLS-compliant",
 						GetSignatureForError (), TypeManager.CSharpName (iface.Type));
 				}
 				foreach (var iface in iface_exprs) {
 					if (iface.Type.IsCLSCompliant ())
 						continue;
 
 					Report.SymbolRelatedToPreviousError (iface.Type);
 					Report.Warning (3027, 1, Location, "`{0}' is not CLS-compliant because base interface `{1}' is not CLS-compliant",
 						GetSignatureForError (), TypeManager.CSharpName (iface.Type));
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1155" endline="1171">
<![CDATA[
 
 		public bool IsConditionallyExcluded (Location loc)
 		{
 			if ((Kind & (MemberKind.Class | MemberKind.Method)) == 0)
 				return false;
 
 			var conditions = MemberDefinition.ConditionalConditions ();
 			if (conditions == null)
 				return false;
 
 			foreach (var condition in conditions) {
 				if (loc.CompilationUnit.IsConditionalDefined (condition))
 					return false;
 			}
 			foreach (var condition in conditions) {
 				if (loc.CompilationUnit.IsConditionalDefined (condition))
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1400" endline="1420">
<![CDATA[
 		}
 
 		#endregion
 
 		public static bool ContainsTypeParameter (TypeSpec type)
 		{
 			if (type.Kind == MemberKind.TypeParameter)
 				return true;
 
 			var element_container = type as ElementTypeSpec;
 			if (element_container != null)
 				return ContainsTypeParameter (element_container.Element);
 
 			foreach (var t in type.TypeArguments) {
 				if (ContainsTypeParameter (t)) {
 					return true;
 				}
 			}
 			foreach (var t in type.TypeArguments) {
 				if (ContainsTypeParameter (t)) {
 					return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="719" endline="737">
<![CDATA[
 		}
 
 		//
 		// Returns whether the type parameter is "known to be a reference type"
 		//
 		public bool IsReferenceType {
 			get {
 				if ((spec & SpecialConstraint.Class) != 0 || HasTypeConstraint)
 					return true;
 
 				if (targs != null) {
 					foreach (var ta in targs) {
 						if (TypeManager.IsReferenceType (ta))
 							return true;
 					}
 					foreach (var ta in targs) {
 						if (TypeManager.IsReferenceType (ta))
 							return true;
 					}
 				}
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7161" endline="7178">
<![CDATA[
 
 		static bool ContainsDynamicType (TypeSpec type)
 		{
 			if (type == InternalType.Dynamic)
 				return true;
 
 			var element_container = type as ElementTypeSpec;
 			if (element_container != null)
 				return ContainsDynamicType (element_container.Element);
 
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2273" endline="2291">
<![CDATA[
 		}
 
 		public override string FullName
 		{
 			get
 			{
 				if (this.ContainsGenericParameters)
 				{
 					return null;
 				}
 				StringBuilder sb = new StringBuilder(base.FullName);
 				sb.Append('[');
 				foreach (Type type in args)
 				{
 					sb.Append('[').Append(type.AssemblyQualifiedName.Replace("]", "\\]")).Append(']');
 				}
 				foreach (Type type in args)
 				{
 					sb.Append('[').Append(type.AssemblyQualifiedName.Replace("]", "\\]")).Append(']');
 				}
 				sb.Append(']');
 				return sb.ToString();
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="223" endline="240">
<![CDATA[
 
 		internal static int GetHashCode(Type[] types)
 		{
 			if (types == null)
 			{
 				return 0;
 			}
 			int h = 0;
 			foreach (Type t in types)
 			{
 				if (t != null)
 				{
 					h *= 3;
 					h ^= t.GetHashCode();
 				}
 			}
 			foreach (Type t in types)
 			{
 				if (t != null)
 				{
 					h *= 3;
 					h ^= t.GetHashCode();
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="888" endline="903">
<![CDATA[
 		}
 
 		public static bool Equals (TypeSpec[] x, TypeSpec[] y)
 		{
 			if (x == y)
 				return true;
 
 			if (x.Length != y.Length)
 				return false;
 
 			for (int i = 0; i < x.Length; ++i)
 				if (!IsEqual (x[i], y[i]))
 					return false;
 			for (int i = 0; i < x.Length; ++i)
 				if (!IsEqual (x[i], y[i]))
 					return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2959" endline="2975">
<![CDATA[
 
 		int IsUnfixed (TypeSpec type)
 		{
 			if (!type.IsGenericParameter)
 				return -1;
 
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (tp_args[i] == type) {
 					if (fixed_types[i] != null)
 						break;
 
 					return i;
 				}
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (tp_args[i] == type) {
 					if (fixed_types[i] != null)
 						break;
 
 					return i;
 				}
 			}
 
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1026" endline="1040">
<![CDATA[
 
 		public static bool IsValidIdentifier (string s)
 		{
 			if (s == null || s.Length == 0)
 				return false;
 
 			if (!is_identifier_start_character (s [0]))
 				return false;
 			
 			for (int i = 1; i < s.Length; i ++)
 				if (! is_identifier_part_character (s [i]))
 					return false;
 			for (int i = 1; i < s.Length; i ++)
 				if (! is_identifier_part_character (s [i]))
 					return false;
 			
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1971" endline="1990">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Checks all type arguments againts type parameters constraints
 		// NOTE
 		//
 		public bool CheckAll (MemberSpec context, TypeSpec[] targs, TypeParameterSpec[] tparams, Location loc)
 		{
 			for (int i = 0; i < tparams.Length; i++) {
 				if (ignore_inferred_dynamic && targs[i] == InternalType.Dynamic)
 					continue;
 
 				if (!CheckConstraint (context, targs [i], tparams [i], loc))
 					return false;
 			}
 			for (int i = 0; i < tparams.Length; i++) {
 				if (ignore_inferred_dynamic && targs[i] == InternalType.Dynamic)
 					continue;
 
 				if (!CheckConstraint (context, targs [i], tparams [i], loc))
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="466" endline="479">
<![CDATA[
 
 		public static System.Linq.Expressions.Expression[] MakeExpression (Arguments args, BuilderContext ctx)
 		{
 			if (args == null || args.Count == 0)
 				return null;
 
 			var exprs = new System.Linq.Expressions.Expression [args.Count];
 			for (int i = 0; i < exprs.Length; ++i) {
 				Argument a = args.args [i];
 				exprs[i] = a.Expr.MakeExpression (ctx);
 			}
 			for (int i = 0; i < exprs.Length; ++i) {
 				Argument a = args.args [i];
 				exprs[i] = a.Expr.MakeExpression (ctx);
 			}
 
 			return exprs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="746" endline="759">
<![CDATA[
 
 		protected static Type[] BindTypeParameters(IGenericBinder binder, Type[] types)
 		{
 			if (types == null || types.Length == 0)
 			{
 				return Type.EmptyTypes;
 			}
 			Type[] expanded = new Type[types.Length];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = types[i].BindTypeParameters(binder);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = types[i].BindTypeParameters(binder);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="97" endline="110">
<![CDATA[
 
 		internal static Type[][] Copy(Type[][] types)
 		{
 			if (types == null || types.Length == 0)
 			{
 				return types;
 			}
 			Type[][] newArray = new Type[types.Length][];
 			for (int i = 0; i < newArray.Length; i++)
 			{
 				newArray[i] = Copy(types[i]);
 			}
 			for (int i = 0; i < newArray.Length; i++)
 			{
 				newArray[i] = Copy(types[i]);
 			}
 			return newArray;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="111" endline="124">
<![CDATA[
 
 		internal static T[] ToArray<T, V>(List<V> list, T[] empty) where V 
 		{
 			if (list == null || list.Count == 0)
 			{
 				return empty;
 			}
 			T[] array = new T[list.Count];
 			for (int i = 0; i < array.Length; i++)
 			{
 				array[i] = list[i];
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				array[i] = list[i];
 			}
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="147" endline="161">
<![CDATA[
 
 		private int GetLength(MetadataWriter mw)
 		{
 			int len = 4 + 4 + 8 + 8;
 			foreach (Table table in mw.ModuleBuilder.GetTables())
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					len += 4;	// row count
 					len += table.GetLength(mw);
 				}
 			}
 			foreach (Table table in mw.ModuleBuilder.GetTables())
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					len += 4;	// row count
 					len += table.GetLength(mw);
 				}
 			}
 			// note that we pad one extra (unexplained) byte
 			return len + 1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2292" endline="2307">
<![CDATA[
 		}
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder(type.FullName);
 			sb.Append('[');
 			string sep = "";
 			foreach (Type arg in args)
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			foreach (Type arg in args)
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			sb.Append(']');
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="88" endline="102">
<![CDATA[
 
 		public override Type[] GetTypes()
 		{
 			if (externalModules.Length == 0)
 			{
 				return manifestModule.GetTypes();
 			}
 
 			List<Type> list = new List<Type>();
 			foreach (Module module in GetModules(false))
 			{
 				list.AddRange(module.GetTypes());
 			}
 			foreach (Module module in GetModules(false))
 			{
 				list.AddRange(module.GetTypes());
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="41" endline="55">
<![CDATA[
 		}
 
 		public sealed override Type BaseType
 		{
 			get
 			{
 				foreach (Type type in GetGenericParameterConstraints())
 				{
 					if (!type.IsInterface && !type.IsGenericParameter)
 					{
 						return type;
 					}
 				}
 				foreach (Type type in GetGenericParameterConstraints())
 				{
 					if (!type.IsInterface && !type.IsGenericParameter)
 					{
 						return type;
 					}
 				}
 				return this.IsValueType ? this.Module.universe.System_ValueType 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1255" endline="1262">
<![CDATA[
 
     Public Shared Function CompareParameterTypes(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         For i As Integer = 0 To a.Count - 1
             If Helper.CompareType(a(i).ParameterType, b(i).ParameterType) = False Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="760" endline="773">
<![CDATA[
 
 		public Type[] GetNestedTypes(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<Type> list = new List<Type>();
 			foreach (Type type in __GetDeclaredTypes())
 			{
 				if (BindingFlagsMatch(type.IsNestedPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in __GetDeclaredTypes())
 			{
 				if (BindingFlagsMatch(type.IsNestedPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="426" endline="440">
<![CDATA[
 
 		internal object GetFieldValue(string name)
 		{
 			if (namedFields != null)
 			{
 				for (int i = 0; i < namedFields.Length; i++)
 				{
 					if (namedFields[i].Name == name)
 					{
 						return fieldValues[i];
 					}
 				}
 				for (int i = 0; i < namedFields.Length; i++)
 				{
 					if (namedFields[i].Name == name)
 					{
 						return fieldValues[i];
 					}
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="643" endline="659">
<![CDATA[
 
 		public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
 		{
 			MethodInfo found = null;
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name)
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name)
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="228" endline="239">
<![CDATA[
 
 		internal override void GetTypesImpl(List<Type> list)
 		{
 			PopulateTypeDef();
 			foreach (TypeDefImpl type in typeDefs)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (TypeDefImpl type in typeDefs)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="3190" endline="3204">
<![CDATA[
 
 		void RemoveDependentTypes (List<TypeSpec> types, TypeSpec returnType)
 		{
 			int idx = IsUnfixed (returnType);
 			if (idx >= 0) {
 				types [idx] = null;
 				return;
 			}
 
 			if (TypeManager.IsGenericType (returnType)) {
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (returnType)) {
 					RemoveDependentTypes (types, t);
 				}
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (returnType)) {
 					RemoveDependentTypes (types, t);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="84" endline="96">
<![CDATA[
 
 		public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, Signature.PROPERTY);
 			sig.returnType = returnType;
 			sig.returnTypeOptionalCustomModifiers = Type.EmptyTypes;
 			sig.returnTypeRequiredCustomModifiers = Type.EmptyTypes;
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="140" endline="151">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = CallingConventions.Standard;
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="488" endline="499">
<![CDATA[
 
 		protected static void WriteCustomModifiers(ModuleBuilder module, ByteBuffer bb, byte mod, Type[] modifiers)
 		{
 			if (modifiers != null)
 			{
 				foreach (Type type in modifiers)
 				{
 					bb.Write(mod);
 					bb.WriteTypeDefOrRefEncoded(module.GetTypeTokenForMemberRef(type));
 				}
 				foreach (Type type in modifiers)
 				{
 					bb.Write(mod);
 					bb.WriteTypeDefOrRefEncoded(module.GetTypeTokenForMemberRef(type));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="368" endline="382">
<![CDATA[
 
 		private static PropertyInfo GetProperty(Type type, string name)
 		{
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (property.IsPublic && !property.IsStatic && property.Name == name)
 					{
 						return property;
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (property.IsPublic && !property.IsStatic && property.Name == name)
 					{
 						return property;
 					}
 				}
 			}
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (property.IsPublic && !property.IsStatic && property.Name == name)
 					{
 						return property;
 					}
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="670" endline="686">
<![CDATA[
 
 		public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
 		{
 			MethodInfo found = null;
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="353" endline="367">
<![CDATA[
 
 		private static FieldInfo GetField(Type type, string name)
 		{
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (FieldInfo field in type.__GetDeclaredFields())
 				{
 					if (field.IsPublic && !field.IsStatic && field.Name == name)
 					{
 						return field;
 					}
 				}
 				foreach (FieldInfo field in type.__GetDeclaredFields())
 				{
 					if (field.IsPublic && !field.IsStatic && field.Name == name)
 					{
 						return field;
 					}
 				}
 			}
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (FieldInfo field in type.__GetDeclaredFields())
 				{
 					if (field.IsPublic && !field.IsStatic && field.Name == name)
 					{
 						return field;
 					}
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="827" endline="843">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, Type returnType)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="844" endline="860">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, Type[] types)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2623" endline="2638">
<![CDATA[
 		
 		bool AllTypesAreFixed (TypeSpec[] types)
 		{
 			foreach (TypeSpec t in types) {
 				if (t.IsGenericParameter) {
 					if (!IsFixed (t))
 						return false;
 					continue;
 				}
 
 				if (TypeManager.IsGenericType (t))
 					return AllTypesAreFixed (TypeManager.GetTypeArguments (t));
 			}
 			foreach (TypeSpec t in types) {
 				if (t.IsGenericParameter) {
 					if (!IsFixed (t))
 						return false;
 					continue;
 				}
 
 				if (TypeManager.IsGenericType (t))
 					return AllTypesAreFixed (TypeManager.GetTypeArguments (t));
 			}
 			
 			return true;
 		}		
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="416" endline="426">
<![CDATA[
 
 		private static void AddMembers(List<MemberInfo> list, MemberFilter filter, object filterCriteria, MemberInfo[] members)
 		{
 			foreach (MemberInfo member in members)
 			{
 				if (filter == null || filter(member, filterCriteria))
 				{
 					list.Add(member);
 				}
 			}
 			foreach (MemberInfo member in members)
 			{
 				if (filter == null || filter(member, filterCriteria))
 				{
 					list.Add(member);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="773" endline="790">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			MethodBase[] methods = new MethodBase[this.methods.Count];
 			for (int i = 0; i < methods.Length; i++)
 			{
 				MethodBuilder mb = this.methods[i];
 				if (mb.IsConstructor)
 				{
 					methods[i] = new ConstructorInfoImpl(mb);
 				}
 				else
 				{
 					methods[i] = mb;
 				}
 			}
 			for (int i = 0; i < methods.Length; i++)
 			{
 				MethodBuilder mb = this.methods[i];
 				if (mb.IsConstructor)
 				{
 					methods[i] = new ConstructorInfoImpl(mb);
 				}
 				else
 				{
 					methods[i] = mb;
 				}
 			}
 			return methods;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="572" endline="584">
<![CDATA[
 
 		private static void AddInterfaces(List<Type> list, Type type)
 		{
 			type.CheckBaked();
 			foreach (Type iface in type.__GetDeclaredInterfaces())
 			{
 				if (!list.Contains(iface))
 				{
 					list.Add(iface);
 					AddInterfaces(list, iface);
 				}
 			}
 			foreach (Type iface in type.__GetDeclaredInterfaces())
 			{
 				if (!list.Contains(iface))
 				{
 					list.Add(iface);
 					AddInterfaces(list, iface);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2109" endline="2122">
<![CDATA[
 
 		static bool HasDynamicTypeArgument (TypeSpec[] targs)
 		{
 			for (int i = 0; i < targs.Length; ++i) {
 				var targ = targs [i];
 				if (targ == InternalType.Dynamic)
 					return true;
 
 				if (HasDynamicTypeArgument (targ.TypeArguments))
 					return true;
 			}
 			for (int i = 0; i < targs.Length; ++i) {
 				var targ = targs [i];
 				if (targ == InternalType.Dynamic)
 					return true;
 
 				if (HasDynamicTypeArgument (targ.TypeArguments))
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="774" endline="787">
<![CDATA[
 
 		protected static Type[][][] BindTypeParameters(IGenericBinder binder, Type[][][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][][] expanded = new Type[types.Length][][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="760" endline="773">
<![CDATA[
 
 		protected static Type[][] BindTypeParameters(IGenericBinder binder, Type[][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][] expanded = new Type[types.Length][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="137" endline="150">
<![CDATA[
 
 		internal static Type[] ReadMethodSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.ReadByte() != GENERICINST)
 			{
 				throw new BadImageFormatException();
 			}
 			Type[] args = new Type[br.ReadCompressedInt()];
 			for (int i = 0; i < args.Length; i++)
 			{
 				args[i] = ReadType(module, br, context);
 			}
 			for (int i = 0; i < args.Length; i++)
 			{
 				args[i] = ReadType(module, br, context);
 			}
 			return args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2369" endline="2381">
<![CDATA[
 
 		internal int FindFirstByOwner(int token)
 		{
 			// TODO use binary search (if sorted)
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="105" endline="114">
<![CDATA[
 
 		public void InitializeBuildinTypes (BuildinTypes buildin, Assembly corlib)
 		{
 			//
 			// Setup mapping for build-in types to avoid duplication of their definition
 			//
 			foreach (var type in buildin.AllTypes) {
 				buildin_types.Add (corlib.GetType (type.FullName), type);
 			}
 			foreach (var type in buildin.AllTypes) {
 				buildin_types.Add (corlib.GetType (type.FullName), type);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1289" endline="1298">
<![CDATA[
 
 		public TypeParameterSpec Mutate (TypeParameterSpec tp)
 		{
 			for (int i = 0; i < mvar.Length; ++i) {
 				if (mvar[i].Type == tp)
 					return var[i].Type;
 			}
 			for (int i = 0; i < mvar.Length; ++i) {
 				if (mvar[i].Type == tp)
 					return var[i].Type;
 			}
 
 			return tp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2529" endline="2538">
<![CDATA[
 
 		public static OpType? GetType (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2520" endline="2528">
<![CDATA[
 
 		public static string GetMetadataName (string name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [0] == name)
 					return names [i] [1];
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [0] == name)
 					return names [i] [1];
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2506" endline="2514">
<![CDATA[
 
 		public static string GetName (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [1] == metadata_name)
 					return names [i] [0];
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [1] == metadata_name)
 					return names [i] [0];
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1593" endline="1612">
<![CDATA[
 		}
 
 		#endregion
 
 		public override List<MissingType> ResolveMissingDependencies ()
 		{
 			var missing = base.ResolveMissingDependencies ();
 			foreach (var pt in parameters.Types) {
 				var m = pt.GetMissingDependencies ();
 				if (m == null)
 					continue;
 
 				if (missing == null)
 					missing = new List<MissingType> ();
 
 				missing.AddRange (m);
 			}
 			foreach (var pt in parameters.Types) {
 				var m = pt.GetMissingDependencies ();
 				if (m == null)
 					continue;
 
 				if (missing == null)
 					missing = new List<MissingType> ();
 
 				missing.AddRange (m);
 			}
 
 			return missing;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="577" endline="596">
<![CDATA[
 
     ''' <summary>
     ''' Removes private members if they are from an external assembly.
     ''' </summary>
     ''' <param name="Members"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterExternalInaccessible(ByVal Compiler As Compiler, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
         For i As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(i)
             If (IsPrivate(member) OrElse IsFriend(member)) AndAlso Compiler.Assembly.IsDefinedHere(CecilHelper.FindDefinition(member.DeclaringType)) = False Then
                 Continue For
             End If
             result.Add(member)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="187" endline="201">
<![CDATA[
     End Property
 
     Public Function VerifyParameterNamesDoesntMatchFunctionName() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Parameters.Count - 1
             Dim p As Parameter = Parameters(i)
 
             If Helper.CompareName(p.Name, Name) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30530, Me.Location)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="831" endline="844">
<![CDATA[
 
     Public Shared Function GetCustomAttributes(ByVal Attributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal AttributeType As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim result As Mono.Collections.Generic.Collection(Of CustomAttribute) = Nothing
 
         For i As Integer = 0 To Attributes.Count - 1
             Dim attrib As CustomAttribute = Attributes(i)
             If Helper.CompareType(AttributeType, attrib.Constructor.DeclaringType) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of CustomAttribute)()
                 result.Add(attrib)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="860" endline="871">
<![CDATA[
 
     Public Shared Function GetAttributes(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim result As Mono.Collections.Generic.Collection(Of CustomAttribute) = Nothing
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of CustomAttribute)()
                 result.Add(Attribute)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1148" endline="1158">
<![CDATA[
 
     Public Shared Function FindProperties(ByVal properties As Mono.Collections.Generic.Collection(Of PropertyDefinition), ByVal name As String) As Mono.Collections.Generic.Collection(Of PropertyDefinition)
         Dim result As Mono.Collections.Generic.Collection(Of PropertyDefinition) = Nothing
         For i As Integer = 0 To properties.Count - 1
             If Helper.CompareNameOrdinal(properties(i).Name, name) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of PropertyDefinition)
                 result.Add(properties(i))
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="984" endline="992">
<![CDATA[
 
     Function FindTypeWithFullname(ByVal Fullname As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.FullName, Fullname) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="975" endline="983">
<![CDATA[
 
     Function FindTypeWithName(ByVal Name As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.Name, Name) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="565" endline="576">
<![CDATA[
 
     Shared Function GetInstanceConstructors(ByVal type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference)
         Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference) = CecilHelper.GetConstructors(type)
 
         For i As Integer = 0 To ctors.Count - 1
             Dim ctor As Mono.Cecil.MethodReference = DirectCast(ctors(i), Mono.Cecil.MethodReference)
             If Helper.IsShared(ctor) = False Then result.Add(ctor)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclarations.vb" startline="77" endline="90">
<![CDATA[
     End Property
 
     Function GetSpecificMembers(Of T)() As Generic.List(Of T)
         Dim result As New Generic.List(Of T)
 
         For i As Integer = 0 To Count - 1
             Dim obj As IMember = Me.Item(i)
             If TypeOf obj Is T Then
                 result.Add(CType(CObj(obj), T))
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3094" endline="3108">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Mono.Cecil.TypeReference()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         If Types IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In Types
                 Helper.Assert(t IsNot Nothing)
                 result &= sep & t.ToString
                 sep = ", "
             Next
         End If
 
         Return "{" & result & "}"
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2255" endline="2267">
<![CDATA[
 
 		internal List<int> GetNestedClasses(int enclosingClass)
 		{
 			List<int> nestedClasses = new List<int>();
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].EnclosingClass == enclosingClass)
 				{
 					nestedClasses.Add(records[i].NestedClass);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].EnclosingClass == enclosingClass)
 				{
 					nestedClasses.Add(records[i].NestedClass);
 				}
 			}
 			return nestedClasses;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="68" endline="79">
<![CDATA[
     End Property
 
     Function FindAssemblyDefinition(ByVal Fullname As String) As Mono.Cecil.AssemblyDefinition
         For i As Integer = 0 To m_CecilAssemblies.Count - 1
             Dim a As Mono.Cecil.AssemblyDefinition
             a = m_CecilAssemblies(i)
             If Helper.CompareNameOrdinal(a.Name.FullName, Fullname) Then
                 Return a
             End If
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="852" endline="859">
<![CDATA[
 
     Public Shared Function IsDefined(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Boolean
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1141" endline="1147">
<![CDATA[
 
     Public Shared Function FindField(ByVal fields As Mono.Collections.Generic.Collection(Of FieldDefinition), ByVal name As String) As FieldDefinition
         For i As Integer = 0 To fields.Count - 1
             If Helper.CompareNameOrdinal(fields(i).Name, name) Then Return fields(i)
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="55" endline="62">
<![CDATA[
     End Property
 
     Function FindNamespace(ByVal A As String, ByVal B As String) As [Namespace]
         For i As Integer = 0 To Count - 1
             If Item(i).Equals(A, B) Then Return Item(i)
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ConstructorInfo.cs" startline="49" endline="59">
<![CDATA[
 		}
 
 		public sealed override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = GetMethodInfo().GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="398" endline="520">
<![CDATA[
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodBuilder method;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(MethodBuilder method, int parameter)
 			{
 				this.method = method;
 				this.parameter = parameter;
 			}
 
 			private ParameterBuilder ParameterBuilder
 			{
 				get
 				{
 					if (method.parameters != null)
 					{
 						foreach (ParameterBuilder pb in method.parameters)
 						{
 							if (pb.Position == parameter)
 							{
 								return pb;
 							}
 						}
 					}
 					return null;
 				}
 			}
 
 			public override string Name
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.Name 
 				}
 			}
 
 			public override Type ParameterType
 			{
 				get { return parameter == -1 ? method.returnType 
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? (ParameterAttributes)pb.Attributes 
 				}
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.HasDefault) != 0)
 					{
 						return method.ModuleBuilder.Constant.GetRawConstantValue(method.ModuleBuilder, pb.PseudoToken);
 					}
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.Optional) != 0)
 					{
 						return Missing.Value;
 					}
 					return null;
 				}
 			}
 
 			private Type[] GetCustomModifiers(int optOrReq)
 			{
 				if (method.modifiers == null || method.modifiers[parameter + 1] == null)
 				{
 					return Type.EmptyTypes;
 				}
 				return Util.Copy(method.modifiers[parameter + 1][optOrReq]);
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return GetCustomModifiers(0);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return GetCustomModifiers(1);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method; }
 			}
 
 			public override int MetadataToken
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.PseudoToken 
 				}
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[parameterTypes.Length];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertyInfo.cs" startline="33" endline="116">
<![CDATA[
 		}
 
 		public abstract PropertyAttributes Attributes { get; }
 		public abstract bool CanRead { get; }
 		public abstract bool CanWrite { get; }
 		public abstract MethodInfo GetGetMethod(bool nonPublic);
 		public abstract MethodInfo GetSetMethod(bool nonPublic);
 		public abstract MethodInfo[] GetAccessors(bool nonPublic);
 		public abstract object GetRawConstantValue();
 		internal abstract bool IsPublic { get; }
 		internal abstract bool IsStatic { get; }
 		internal abstract PropertySignature PropertySignature { get; }
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly PropertyInfo property;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(PropertyInfo property, int parameter)
 			{
 				this.property = property;
 				this.parameter = parameter;
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override Type ParameterType
 			{
 				get { return property.PropertySignature.GetParameter(parameter); }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return property.PropertySignature.GetOptionalCustomModifiers(parameter);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return property.PropertySignature.GetRequiredCustomModifiers(parameter);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return property; }
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x08000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return property.Module; }
 			}
 		}
 
 		public ParameterInfo[] GetIndexParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[this.PropertySignature.ParameterCount];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="364" endline="373">
<![CDATA[
 
     ''' <summary>
     ''' Finds all the non-nested types in the compiling code and loads them into the lists.
     ''' </summary>
     ''' <remarks></remarks>
     Public Sub LoadCompiledTypes()
         For Each t As TypeDeclaration In Compiler.theAss.Types
             LoadType(t.CecilType)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="162" endline="174">
<![CDATA[
 
     ReadOnly Property GenericParameterAttributes() As Mono.Cecil.GenericParameterAttributes
         Get
             Dim result As Mono.Cecil.GenericParameterAttributes
 
             If m_TypeParameterConstraints IsNot Nothing Then
                 For i As Integer = 0 To m_TypeParameterConstraints.Constraints.Count - 1
                     result = result Or m_TypeParameterConstraints.Constraints(i).SpecialConstraintAttribute
                 Next
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2029" endline="2036">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypeToSearch As Mono.Cecil.TypeReference, ByVal TypesToFind As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         For i As Integer = 0 To TypesToFind.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToFind(i)
             If Helper.CompareType(t, TypeToSearch) OrElse Helper.IsSubclassOf(TypeToSearch, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2037" endline="2044">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(TypeToFind, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="58" endline="67">
<![CDATA[
 
     Public MemberCache As New Generic.Dictionary(Of Mono.Cecil.TypeReference, MemberCache)(New TypeComparer)
 
     ReadOnly Property Corlib As AssemblyDefinition
         Get
             For i As Integer = 0 To m_CecilAssemblies.Count - 1
                 If Helper.CompareNameOrdinal(m_CecilAssemblies(i).Name.Name, "mscorlib") Then Return m_CecilAssemblies(i)
             Next
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="165" endline="172">
<![CDATA[
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="169" endline="176">
<![CDATA[
 
     Function IsNamespaceExact(ByVal A As String, ByVal B As String) As Boolean
         For i As Integer = 0 To Me.Count - 1
             Dim ns As [Namespace] = Me.Item(i)
             If ns.Equals(A, B) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="46" endline="55">
<![CDATA[
 
     Sub Init(ByVal Elements As Expression())
         m_VariableInitializerList = New VariableInitializerList(Me)
         For Each e As Expression In Elements
             Dim vi As VariableInitializer
             vi = New VariableInitializer(Me)
             vi.Init(e)
             m_VariableInitializerList.Add(vi)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="710" endline="719">
<![CDATA[
 
 		internal static void WriteMethodSpec(ModuleBuilder module, ByteBuffer bb, Type[] genArgs)
 		{
 			bb.Write(GENERICINST);
 			bb.WriteCompressedInt(genArgs.Length);
 			foreach (Type arg in genArgs)
 			{
 				WriteType(module, bb, arg);
 			}
 			foreach (Type arg in genArgs)
 			{
 				WriteType(module, bb, arg);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="301" endline="311">
<![CDATA[
 
 		internal void AddTypeForwarder(Type type)
 		{
 			ExportType(type);
 			foreach (Type nested in type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic))
 			{
 				// we export all nested types (i.e. even the private ones)
 				// (this behavior is the same as the C# compiler)
 				AddTypeForwarder(nested);
 			}
 			foreach (Type nested in type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic))
 			{
 				// we export all nested types (i.e. even the private ones)
 				// (this behavior is the same as the C# compiler)
 				AddTypeForwarder(nested);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2315" endline="2322">
<![CDATA[
 		}
 
 		public new void VerifyClsCompliance ()
 		{
 			foreach (TypeParameter tp in TypeParameters) {
 				tp.VerifyClsCompliance ();
 			}
 			foreach (TypeParameter tp in TypeParameters) {
 				tp.VerifyClsCompliance ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2021" endline="2028">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Cecil.TypeReference(), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Length - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(t, TypeToFind) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="520" endline="529">
<![CDATA[
 
     Function AcceptAny(ByVal ParamArray Keywords() As KS) As Boolean
         Dim i As Integer
         For i = 0 To Keywords.Length - 1
             If Accept(Keywords(i)) Then
                 Return True
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="738" endline="745">
<![CDATA[
 
     Public Shared Function MakeGenericMethod(ByVal Method As MethodReference, ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.GenericInstanceMethod
         Dim result As New Mono.Cecil.GenericInstanceMethod(Method)
         For i As Integer = 0 To Types.Length - 1
             result.GenericArguments.Add(Types(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2778" endline="2792">
<![CDATA[
 
 		//
 		// Creates an arguments set from all parameters, useful for method proxy calls
 		//
 		public Arguments GetAllParametersArguments ()
 		{
 			int count = parameters.Count;
 			Arguments args = new Arguments (count);
 			for (int i = 0; i < count; ++i) {
 				var arg_expr = GetParameterReference (i, parameter_info[i].Location);
 				args.Add (new Argument (arg_expr));
 			}
 			for (int i = 0; i < count; ++i) {
 				var arg_expr = GetParameterReference (i, parameter_info[i].Location);
 				args.Add (new Argument (arg_expr));
 			}
 
 			return args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1214" endline="1220">
<![CDATA[
   protected string[] yyExpecting (int state) {
     int [] tokens = yyExpectingTokens (state);
     string [] result = new string[tokens.Length];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n]];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n]];
     return result;
   }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="311" endline="322">
<![CDATA[
 
 		private static IList<CustomAttributeTypedArgument> ReadConstructorArguments(Assembly asm, ByteReader br, ConstructorInfo constructor)
 		{
 			MethodSignature sig = constructor.MethodSignature;
 			int count = sig.GetParameterCount();
 			List<CustomAttributeTypedArgument> list = new List<CustomAttributeTypedArgument>(count);
 			for (int i = 0; i < count; i++)
 			{
 				list.Add(ReadFixedArg(asm, br, sig.GetParameterType(i)));
 			}
 			for (int i = 0; i < count; i++)
 			{
 				list.Add(ReadFixedArg(asm, br, sig.GetParameterType(i)));
 			}
 			return list.AsReadOnly();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="173" endline="180">
<![CDATA[
 
 		public void SetInterfaceConstraints(params Type[] interfaceConstraints)
 		{
 			foreach (Type type in interfaceConstraints)
 			{
 				AddConstraint(type);
 			}
 			foreach (Type type in interfaceConstraints)
 			{
 				AddConstraint(type);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="334" endline="343">
<![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="851" endline="860">
<![CDATA[
 
 		internal string[] GetManifestResourceNames()
 		{
 			string[] names = new string[ManifestResource.records.Length];
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				names[i] = GetString(ManifestResource.records[i].Name);
 			}
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				names[i] = GetString(ManifestResource.records[i].Name);
 			}
 			return names;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1178" endline="1188">
<![CDATA[
 
 		public ParametersCompiled Clone ()
 		{
 			ParametersCompiled p = (ParametersCompiled) MemberwiseClone ();
 
 			p.parameters = new IParameterData [parameters.Length];
 			for (int i = 0; i < Count; ++i)
 				p.parameters [i] = this [i].Clone ();
 			for (int i = 0; i < Count; ++i)
 				p.parameters [i] = this [i].Clone ();
 
 			return p;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="981" endline="993">
<![CDATA[
 
 		//
 		// TODO
 		// as the underlying type is not Parameter and some methods will fail to cast
 		//
 		public static AParametersCollection CreateFullyResolved (TypeSpec[] types)
 		{
 			var pd = new ParameterData [types.Length];
 			for (int i = 0; i < pd.Length; ++i)
 				pd[i] = new ParameterData (null, Parameter.Modifier.NONE, null);
 			for (int i = 0; i < pd.Length; ++i)
 				pd[i] = new ParameterData (null, Parameter.Modifier.NONE, null);
 
 			return new ParametersCompiled (pd, types);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2359" endline="2368">
<![CDATA[
 
 		internal int[] GetIndexFixup()
 		{
 			int[] array = new int[rowCount];
 			for (int i = 0; i < rowCount; i++)
 			{
 				array[records[i].unsortedIndex] = i;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				array[records[i].unsortedIndex] = i;
 			}
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1169" endline="1188">
<![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifiers  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifiers(ByVal Parent As ParsedObject) As ArrayTypeModifiers
         Dim result As New ArrayTypeModifiers(Parent)
 
         Dim tmp As New Generic.List(Of ArrayTypeModifier)
         Do
             Dim newATM As ArrayTypeModifier
             newATM = ParseArrayTypeModifier(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             tmp.Add(newATM)
         Loop While ArrayTypeModifier.CanBeMe(tm)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4442" endline="4463">
<![CDATA[
 
     ''' <summary>
     ''' HandlesClause  
     ''' LAMESPEC
     ''' HandlesClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesClause(ByVal Parent As ParsedObject) As HandlesClause
         Dim result As New HandlesClause(Parent)
 
         Dim m_List As New EventHandlesList(result)
 
         tm.AcceptIfNotInternalError(KS.Handles)
 
         If ParseList(Of EventMemberSpecifier)(m_List, New ParseDelegate_Parent(Of EventMemberSpecifier)(AddressOf ParseEventMemberSpecifier), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_List)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3998" endline="4013">
<![CDATA[
 
     Private Function ParseImplementsClause(ByVal Parent As ParsedObject) As MemberImplementsClause
         Dim result As New MemberImplementsClause(Parent)
 
         Dim m_ImplementsList As New MemberImplementsList(Parent)
 
         tm.AcceptIfNotInternalError(KS.Implements)
 
         If ParseList(Of InterfaceMemberSpecifier)(m_ImplementsList, New ParseDelegate_Parent(Of InterfaceMemberSpecifier)(AddressOf ParseInterfaceMemberSpecifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_ImplementsList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="62" endline="78">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         Emitter.MarkLabel(Info, m_NextIteration)
         result = m_Condition.GenerateCode(Info.Clone(Me, True, , Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, EndLabel)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, m_NextIteration)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="338" endline="356">
<![CDATA[
 
     Public Shared Function EmitLateIndexGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexGet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
         '2 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="612" endline="623">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			if (goto_stmt.Target != stmt.Name)
 				return Parent.AddGotoOrigin (vector, goto_stmt);
 
 			// backward jump
 			goto_stmt.SetResolvedTarget (stmt);
 			actual.MergeOrigins (vector.Clone ());
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="202" endline="209">
<![CDATA[
 
     Public Function ResolveAndGetConstantValue(ByRef value As Object) As Boolean Implements IFieldMember.ResolveAndGetConstantValue
         If m_ResolvedMember = False Then
             If ResolveMember(ResolveInfo.Default(Compiler)) = False Then Return False
         End If
         value = ConstantValue
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="43" endline="49">
<![CDATA[
 
     Function TypesAsArray() As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         ReDim result(Me.Count - 1)
         MyBase.Values.CopyTo(result, 0)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1583" endline="1592">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			parameters.VerifyClsCompliance (this);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3349" endline="3368">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Main member define entry
 		//
 		public override bool Define ()
 		{
 			DoMemberTypeIndependentChecks ();
 
 			//
 			// Returns false only when type resolution failed
 			//
 			if (!ResolveMemberType ())
 				return false;
 
 			DoMemberTypeDependentChecks ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="72" endline="79">
<![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="64" endline="71">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="47" endline="54">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="37" endline="44">
<![CDATA[
 
     Shared Function IsUnaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="53" endline="60">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1359" endline="1368">
<![CDATA[
 
 		#region Properties
 
 		public override TypeSpec BaseType {
 			get {
 				if (cache == null || (state & StateFlags.PendingBaseTypeInflate) != 0)
 					InitializeMemberCache (true);
 
 				return base.BaseType;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="147" endline="156">
<![CDATA[
 		}
 
 		public EventToken GetEventToken()
 		{
 			if (lazyPseudoToken == 0)
 			{
 				lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			}
 			return new EventToken(lazyPseudoToken);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="205" endline="213">
<![CDATA[
 		}
 
 		public MemberCache MemberCache {
 			get {
 				if (cache == null || (state & StateFlags.PendingMemberCacheMembers) != 0)
 					InitializeMemberCache (false);
 
 				return cache;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="698" endline="709">
<![CDATA[
 		}
 
 		//
 		// Unexpanded interfaces list
 		//
 		public TypeSpec[] InterfacesDefined {
 			get {
 				if (ifaces_defined == null && ifaces != null)
 					ifaces_defined = ifaces.ToArray ();
 
 				return ifaces_defined;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="220" endline="228">
<![CDATA[
 		}
 
 		public TypeParameterSpec[] Constraints {
 			get {
 				if (constraints == null && IsGeneric)
 					constraints = GenericDefinition.TypeParameters;
 
 				return constraints;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="62" endline="70">
<![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             If m_ArgumentsTypesAsString Is Nothing Then
                 m_ArgumentsTypesAsString = "(" & m_Arguments.ArgumentsTypesAsString & ")"
             End If
             Return m_ArgumentsTypesAsString
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="47" endline="58">
<![CDATA[
 
 		internal int PseudoToken
 		{
 			get
 			{
 				if (lazyPseudoToken == 0)
 				{
 					// we lazily create the token, because if we don't need it we don't want the token fixup cost
 					lazyPseudoToken = moduleBuilder.AllocPseudoToken();
 				}
 				return lazyPseudoToken;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="128" endline="140">
<![CDATA[
 		}
 
 		//
 		// For compiled constants we have to resolve the value as there could be constant dependecies. This
 		// is needed for imported constants too to get the right context type
 		//
 		public Constant GetConstant (ResolveContext rc)
 		{
 			if (value.eclass != ExprClass.Value)
 				value = value.Resolve (rc);
 
 			return (Constant) value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1694" endline="1700">
<![CDATA[
 
 		int peek_char ()
 		{
 			if (putback_char == -1)
 				putback_char = reader.Read ();
 			return putback_char;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="152" endline="163">
<![CDATA[
 		}
 
 		internal uint DebugDirectoryLength
 		{
 			get
 			{
 				if (DebugDirectoryContentsLength != 0)
 				{
 					return 28;
 				}
 				return 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="40" endline="48">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadToken(Info, m_TypeName.ResolvedType)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\StopStatement.vb" startline="30" endline="38">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ' Helper.NotImplemented()
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Diagnostics_Debugger__Break)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" startline="34" endline="41">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__EndApp)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="841" endline="849">
<![CDATA[
 
 		public override bool Define()
 		{
 			if (!base.Define ())
 				return false;
 
 			SetIsUsed ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="300" endline="310">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			TypeCast child_cast = child as TypeCast;
 			if (child_cast != null) {
 				child.Type = type;
 				return child_cast.CreateExpressionTree (ec);
 			}
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="432" endline="445">
<![CDATA[
 
 		private int ReadToken(int table, bool big)
 		{
 			int rid;
 			if (big)
 			{
 				rid = br.ReadInt32();
 			}
 			else
 			{
 				rid = br.ReadUInt16();
 			}
 			return rid | (table << 24);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="142" endline="157">
<![CDATA[
 		}
 
 		public override GenericParameterAttributes GenericParameterAttributes
 		{
 			get
 			{
 				if (type != null)
 				{
 					type.CheckBaked();
 				}
 				else
 				{
 					method.CheckBaked();
 				}
 				return attr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1319" endline="1330">
<![CDATA[
 		}
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, null, callingConvention, 0);
 				}
 				return methodSignature;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="479" endline="490">
<![CDATA[
 
 		private string GetTypeName(int typeNamespace, int typeName)
 		{
 			if (typeNamespace == 0)
 			{
 				return GetString(typeName);
 			}
 			else
 			{
 				return GetString(typeNamespace) + "." + GetString(typeName);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="167" endline="179">
<![CDATA[
 
 		private static Type ReadTypeOrVoid(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.PeekByte() == ELEMENT_TYPE_VOID)
 			{
 				br.ReadByte();
 				return module.universe.System_Void;
 			}
 			else
 			{
 				return ReadType(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1544" endline="1553">
<![CDATA[
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is Indexer) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			return base.EnableOverloadChecks (overload);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="335" endline="349">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The filename to report to the user in errors.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property FileNameToReport() As String
         Get
             If m_FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars) >= 0 Then
                 Return m_FileName
             End If
             Return System.IO.Path.Combine(m_RelativePath, System.IO.Path.GetFileName(m_FileName))
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="218" endline="225">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (Name == null)
 				return field.GetSignatureForError ();
 
 			return field.Parent.GetSignatureForError () + "." + Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7056" endline="7067">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			type = InternalType.Arglist;
 			if (Arguments != null) {
 				bool dynamic;	// Can be ignored as there is always only 1 overload
 				Arguments.Resolve (ec, out dynamic);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="243" endline="258">
<![CDATA[
 
 		//
 		// Creates a link between hoisted variable block and the anonymous method storey
 		//
 		// An anonymous method can reference variables from any outer block, but they are
 		// hoisted in their own ExplicitBlock. When more than one block is referenced we
 		// need to create another link between those variable storeys
 		//
 		public void AddReferenceFromChildrenBlock (ExplicitBlock block)
 		{
 			if (children_references == null)
 				children_references = new List<ExplicitBlock> ();
 
 			if (!children_references.Contains (block))
 				children_references.Add (block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="711" endline="725">
<![CDATA[
 		}
 
 		public override string FullName
 		{
 			get
 			{
 				if (this.IsNested)
 				{
 					return this.DeclaringType.FullName + "+" + nameOrFullName;
 				}
 				else
 				{
 					return nameOrFullName;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2150" endline="2158">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (targs != null) {
 				return Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="462" endline="473">
<![CDATA[
 
 		public TypeToken GetTypeToken(Type type)
 		{
 			if (type.Module == this)
 			{
 				return new TypeToken(type.GetModuleBuilderToken());
 			}
 			else
 			{
 				return new TypeToken(ImportType(type));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="330" endline="340">
<![CDATA[
 
 		private static bool ParsePublicKeyToken(string str, out string publicKeyToken)
 		{
 			if (str == null)
 			{
 				publicKeyToken = null;
 				return false;
 			}
 			publicKeyToken = str.ToLowerInvariant();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1409" endline="1417">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakeByRefType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="105" endline="112">
<![CDATA[
 
 		public string GetSignatureForError ()
 		{
 			if (Expr.eclass == ExprClass.MethodGroup)
 				return Expr.ExprClassName;
 
 			return TypeManager.CSharpName (Expr.Type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1249" endline="1257">
<![CDATA[
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (child.Type == target_type)
 				return child;
 
 			// FIXME
 			return child.ConvertExplicitly (in_checked_context, target_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1446" endline="1454">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakePointerType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1418" endline="1426">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly(bool in_checked_context, TypeSpec target_type)
 		{
 			if (Child.Type == target_type)
 				return Child;
 
 			return Child.ConvertExplicitly (in_checked_context, target_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="319" endline="329">
<![CDATA[
 
 		private static bool ParseCulture(string str, out string culture)
 		{
 			if (str == null)
 			{
 				culture = null;
 				return false;
 			}
 			culture = str;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="478" endline="490">
<![CDATA[
 		}
 
 		internal CustomAttributeBuilder DecodeBlob(Assembly asm)
 		{
 			if (blob == null)
 			{
 				return this;
 			}
 			else
 			{
 				return ToData(asm).__ToBuilder();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="458" endline="469">
<![CDATA[
 
 		internal int ReadMethodDef()
 		{
 			if (bigMethodDef)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="470" endline="481">
<![CDATA[
 
 		internal int ReadParam()
 		{
 			if (bigParam)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="446" endline="457">
<![CDATA[
 
 		internal int ReadField()
 		{
 			if (bigField)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="523" endline="533">
<![CDATA[
 
 		public override Module ManifestModule
 		{
 			get
 			{
 				if (pseudoManifestModule == null)
 				{
 					pseudoManifestModule = new ManifestModule(this);
 				}
 				return pseudoManifestModule;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="482" endline="493">
<![CDATA[
 
 		internal int ReadProperty()
 		{
 			if (bigProperty)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="494" endline="505">
<![CDATA[
 
 		internal int ReadEvent()
 		{
 			if (bigEvent)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="80" endline="91">
<![CDATA[
 
 		internal int ReadBlobIndex()
 		{
 			if (bigBlobs)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="68" endline="79">
<![CDATA[
 
 		internal int ReadGuidIndex()
 		{
 			if (bigGuids)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="433" endline="444">
<![CDATA[
 		}
 
 		public IList<CustomAttributeNamedArgument> NamedArguments
 		{
 			get
 			{
 				if (lazyNamedArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyNamedArguments;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="421" endline="432">
<![CDATA[
 		}
 
 		public IList<CustomAttributeTypedArgument> ConstructorArguments
 		{
 			get
 			{
 				if (lazyConstructorArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyConstructorArguments;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="595" endline="603">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (user_operator != null)
 				return user_operator.CreateExpressionTree (ec);
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="160" endline="166">
<![CDATA[
 
 		public string Basename {
 			get {
 				if (TypeArguments != null)
 					return MakeName (Name, TypeArguments);
 				return Name;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="560" endline="568">
<![CDATA[
 
 		public SourceFileEntry SourceFile {
 			get {
 				if (creating)
 					return source;
 
 				ReadData ();
 				return source;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3048" endline="3057">
<![CDATA[
 		}
 
 		public override string Name {
 			get {
 				if (best_candidate != null)
 					return best_candidate.Name;
 
 				// TODO
 				return Methods.First ().Name;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3075" endline="3082">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (best_candidate != null)
 				return best_candidate.GetSignatureForError ();
 
 			return Methods.First ().GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="220" endline="228">
<![CDATA[
 		}
 
 		public MemberCache MemberCacheTypes {
 			get {
 				if (cache == null)
 					InitializeMemberCache (true);
 
 				return cache;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="54" endline="62">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeName(NewParent)
 
         result.Init(m_TypeName.Clone(result), m_ArrayTypeModifiers.Clone(result))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="61" endline="67">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstructedTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstructedTypeName(NewParent)
         result.Init(m_QualifiedIdentifier.Clone(result), m_TypeArgumentList.Clone(result))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="37" endline="43">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As BoundList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New BoundList(NewParent)
         result.Init(Helper.CloneExpressionArray(m_Expressions, result))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="106" endline="112">
<![CDATA[
 
     Overridable Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SubSignature
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SubSignature(NewParent)
         CloneTo(result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="331" endline="343">
<![CDATA[
 		}
 
 		public LocalVariableEntry[] Locals {
 			get {
 				if (_locals == null)
 					return new LocalVariableEntry [0];
 				else {
 					LocalVariableEntry[] retval =
 						new LocalVariableEntry [_locals.Count];
 					_locals.CopyTo (retval, 0);
 					return retval;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="312" endline="321">
<![CDATA[
 
 		public CodeBlockEntry[] Blocks {
 			get {
 				if (_blocks == null)
 					return new CodeBlockEntry [0];
 
 				CodeBlockEntry[] retval = new CodeBlockEntry [_blocks.Count];
 				_blocks.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="353" endline="362">
<![CDATA[
 
 		public ScopeVariable[] ScopeVariables {
 			get {
 				if (_scope_vars == null)
 					return new ScopeVariable [0];
 
 				ScopeVariable[] retval = new ScopeVariable [_scope_vars.Count];
 				_scope_vars.CopyTo (retval);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="249" endline="256">
<![CDATA[
     End Property
 
     Public ReadOnly Property GetParameters() As Mono.Cecil.ParameterDefinition() Implements IMethod.GetParameters
         Get
             Helper.Assert(m_Signature IsNot Nothing)
             Helper.Assert(m_Signature.Parameters IsNot Nothing)
             Return m_Signature.Parameters.AsParameterInfo
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="213" endline="222">
<![CDATA[
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="199" endline="212">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="172" endline="184">
<![CDATA[
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="572" endline="584">
<![CDATA[
 		
 		//
 		// For queries like `from a orderby a select a'
 		// the projection is transparent and select clause can be safely removed 
 		//
 		public bool IsRequired (Parameter parameter)
 		{
 			SimpleName sn = expr as SimpleName;
 			if (sn == null)
 				return true;
 
 			return sn.Name != parameter.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="868" endline="877">
<![CDATA[
 
 		public Label LabelTarget (EmitContext ec)
 		{
 			if (defined)
 				return label;
 
 			label = ec.DefineLabel ();
 			defined = true;
 			return label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="680" endline="687">
<![CDATA[
 
 		public bool IsComImport {
 			get {
 				if (OptAttributes == null)
 					return false;
 
 				return OptAttributes.Contains (Module.PredefinedAttributes.ComImport);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1528" endline="1535">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (TypeManager.IsNullableType (open_type))
 				return targs[0].GetSignatureForError () + "?";
 
 			return base.GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2355" endline="2362">
<![CDATA[
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				if (default_static_constructor == null)
 					return base.TypeAttr | TypeAttributes.BeforeFieldInit;
 
 				return base.TypeAttr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="228" endline="236">
<![CDATA[
 		}
 
 		public static string MakeName (string name, TypeArguments args)
 		{
 			if (args == null)
 				return name;
 
 			return name + "`" + args.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="970" endline="977">
<![CDATA[
 
 		public Expression GetParameterDefaultValue ()
 		{
 			if (PosArguments == null)
 				return null;
 
 			return PosArguments[0].Expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="334" endline="341">
<![CDATA[
 		
 		public virtual bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			if (parameter_type == null)
 				return true;
 
 			return member.IsAccessibleAs (parameter_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1262" endline="1274">
<![CDATA[
 		}
 
 		#endregion
 
 		public abstract List<MissingType> ResolveMissingDependencies ();
 
 		public string[] ConditionalConditions ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Conditionals;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1275" endline="1282">
<![CDATA[
 
 		public ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1283" endline="1290">
<![CDATA[
 
 		public bool IsNotCLSCompliant ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.IsNotCLSCompliant;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="726" endline="740">
<![CDATA[
 		}
 
 		public override string Name
 		{
 			get
 			{
 				if (this.IsNested)
 				{
 					return nameOrFullName;
 				}
 				else
 				{
 					return base.Name;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1382" endline="1390">
<![CDATA[
 		}
 
 		public override IList<TypeSpec> Interfaces {
 			get {
 				if (cache == null)
 					InitializeMemberCache (true);
 
 				return base.Interfaces;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1724" endline="1731">
<![CDATA[
 
 		public string GetAttributeDefaultMember ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.DefaultIndexerName;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1732" endline="1739">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.AttributeUsage;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1716" endline="1723">
<![CDATA[
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.CoClass;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1701" endline="1707">
<![CDATA[
 
 		int peek_char2 ()
 		{
 			if (putback_char != -1)
 				return putback_char;
 			return reader.Peek ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="338" endline="349">
<![CDATA[
 
 		public TypeContainer AddTypeContainer (TypeContainer tc)
 		{
 			if (!AddMemberType (tc))
 				return tc;
 
 			if (types == null)
 				types = new List<TypeContainer> ();
 
 			types.Add (tc);
 			return tc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="411" endline="421">
<![CDATA[
 
 		public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype)
 		{
 			if (events == null)
 			{
 				events = new List<EventBuilder>();
 			}
 			EventBuilder eb = new EventBuilder(this, name, attributes, eventtype);
 			events.Add(eb);
 			return eb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1025" endline="1038">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="100" endline="113">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1230" endline="1239">
<![CDATA[
 
 		public void __AddAssemblyReference(AssemblyName assemblyName)
 		{
 			if (referencedAssemblyNames == null)
 			{
 				referencedAssemblyNames = new List<AssemblyName>();
 			}
 			FindOrAddAssemblyRef(assemblyName);
 			referencedAssemblyNames.Add((AssemblyName)assemblyName.Clone());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1073" endline="1083">
<![CDATA[
 			
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (expr == null)
 				ec.Emit (OpCodes.Rethrow);
 			else {
 				expr.Emit (ec);
 
 				ec.Emit (OpCodes.Throw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="591" endline="600">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attribs |= TypeAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="267" endline="276">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attributes |= MethodAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="327" endline="337">
<![CDATA[
 
 		public void AddConstant (Const constant)
 		{
 			if (!AddMember (constant))
 				return;
 
 			if (constants == null)
 				constants = new List<MemberCore> ();
 			
 			constants.Add (constant);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="527" endline="537">
<![CDATA[
 
 		public void AddEvent (Event e)
 		{
 			if (!AddMember (e))
 				return;
 
 			if (events == null)
 				events = new List<MemberCore> ();
 
 			events.Add (e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="549" endline="559">
<![CDATA[
 
 		public void AddFile (SourceFileEntry file)
 		{
 			if (!creating)
 				throw new InvalidOperationException ();
 
 			if (include_files == null)
 				include_files = new List<SourceFileEntry> ();
 
 			include_files.Add (file);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="552" endline="562">
<![CDATA[
 
 		public void AddOperator (Operator op)
 		{
 			if (!AddMember (op))
 				return;
 
 			if (operators == null)
 				operators = new List<MemberCore> ();
 
 			operators.Add (op);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="468" endline="483">
<![CDATA[
 
 		//
 		// This is the first method which is called during the resolving
 		// process; we're called immediately after creating the type parameters
 		// with SRE (by calling `DefineGenericParameters()' on the TypeBuilder /
 		// MethodBuilder).
 		//
 		public void Define (GenericTypeParameterBuilder type, TypeSpec declaringType)
 		{
 			if (builder != null)
 				throw new InternalErrorException ();
 
 			this.builder = type;
 			spec.DeclaringType = declaringType;
 			spec.SetMetaInfo (type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="206" endline="213">
<![CDATA[
 
 		public LocalBuilder DeclareLocal (TypeSpec type, bool pinned)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				type = CurrentAnonymousMethod.Storey.Mutator.Mutate (type);
 
 			return ig.DeclareLocal (type.GetMetaInfo (), pinned);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="77" endline="86">
<![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			PatchCallingConvention(mdBuilder);
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="666" endline="702">
<![CDATA[
 	}
 
 	//
 	// Default message recorder, it uses two types of message groups.
 	// Common messages
 	// Merged messages
 	//
 	// Used by the Lambda expressions to compile the code with various
 	// parameter values, or by attribute resolver
 	//
 	class SessionReportPrinter 
 	{
 		List<AbstractMessage> session_messages;
 		//
 		// A collection of exactly same messages reported in all sessions
 		//
 		List<AbstractMessage> common_messages;
 
 		//
 		// A collection of unique messages reported in all sessions
 		//
 		List<AbstractMessage> merged_messages;
 
 		public override void Print (AbstractMessage msg)
 		{
 			//
 			// This line is useful when debugging recorded messages
 			//
 			// Console.WriteLine ("RECORDING
 
 			if (session_messages == null)
 				session_messages = new List<AbstractMessage> ();
 
 			session_messages.Add (msg);
 
 			base.Print (msg);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="256" endline="264">
<![CDATA[
 		}
 
 		public void Store (EmitContext ec)
 		{
 			if (builder == null)
 				builder = ec.GetTemporaryLocal (type);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="440" endline="446">
<![CDATA[
 			set {
 				get = value;
 				if (first == null)
 					first = value;
 
 				Parent.AddMember (get);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="453" endline="459">
<![CDATA[
 			set {
 				set = value;
 				if (first == null)
 					first = value;
 
 				Parent.AddMember (set);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="275" endline="282">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (DoResolveCore (ec))
 				binder_expr = binder.CreateCallSiteBinder (ec, arguments);
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="54" endline="61">
<![CDATA[
 		}
 
 		internal byte PeekByte()
 		{
 			if (pos == end)
 				throw new BadImageFormatException();
 			return buffer[pos];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="54" endline="62">
<![CDATA[
 
     Public Property ConstantValue() As Object
         Get
             If m_ResolvedMember = False Then
                 'Helper.StopIfDebugging()
                 ResolveMember(ResolveInfo.Default(Compiler))
             End If
             Return m_FieldBuilderCecil.Constant
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="465" endline="473">
<![CDATA[
 
 		public void AddInterfaceImplementation(Type interfaceType)
 		{
 			if (interfaces == null)
 			{
 				interfaces = new List<Type>();
 			}
 			interfaces.Add(interfaceType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="107" endline="114">
<![CDATA[
 
 		public void AddUndefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="99" endline="106">
<![CDATA[
 
 		public void AddDefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3897" endline="3912">
<![CDATA[
 	}
 
 	// A place where execution can restart in an iterator
 	public abstract class ResumableStatement 
 	{
 		bool prepared;
 		protected Label resume_point;
 
 		public Label PrepareForEmit (EmitContext ec)
 		{
 			if (!prepared) {
 				prepared = true;
 				resume_point = ec.DefineLabel ();
 			}
 			return resume_point;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4025" endline="4033">
<![CDATA[
 
 		public override Label PrepareForDispose (EmitContext ec, Label end)
 		{
 			if (!prepared_for_dispose) {
 				prepared_for_dispose = true;
 				dispose_try_block = ec.DefineLabel ();
 			}
 			return dispose_try_block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="171" endline="181">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddModule (ImportedModuleDefinition module)
 		{
 			if (added_modules == null) {
 				added_modules = new List<ImportedModuleDefinition> ();
 				added_modules.Add (module);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="66" endline="74">
<![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="363" endline="371">
<![CDATA[
 		}
 
 		public void AddScopeVariable (int scope, int index)
 		{
 			if (_scope_vars == null)
 				_scope_vars = new List<ScopeVariable> ();
 			_scope_vars.Add (
 				new ScopeVariable (scope, index));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="290" endline="302">
<![CDATA[
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="414" endline="422">
<![CDATA[
 		}
 
 		public void SetIgnoreWarning (int code)
 		{
 			if (warning_ignore_table == null)
 				warning_ignore_table = new HashSet<int> ();
 
 			warning_ignore_table.Add (code);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1249" endline="1259">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (Declarator decl)
 		{
 			if (declarators == null)
 				declarators = new List<Declarator> ();
 
 			declarators.Add (decl);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="114" endline="124">
<![CDATA[
 		}
 
 		public bool IsGeneric {
 			get {
 				if (TypeArguments != null)
 					return true;
 				else if (Left != null)
 					return Left.IsGeneric;
 				else
 					return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="546" endline="556">
<![CDATA[
 		}
 
 		public bool IsDefaultInitializer {
 			get {
 				Constant c = source as Constant;
 				if (c == null)
 					return false;
 				
 				FieldExpr fe = (FieldExpr)target;
 				return c.IsDefaultInitializer (fe.Type);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1238" endline="1245">
<![CDATA[
 			get {
 				if (is_generic)
 					return true;
 				else if (Parent != null)
 					return Parent.IsGeneric;
 				else
 					return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="404" endline="412">
<![CDATA[
 		}
 
 		public int Column {
 			get {
 				if (token == 0)
 					return 1;
 				int col = (int) (token & column_mask);
 				return col == 255 ? 1 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3220" endline="3228">
<![CDATA[
 
 		public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			return MemberCache.FindMember (queried_type, new MemberFilter ((MethodSpec) member),
 				BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="743" endline="749">
<![CDATA[
     End Property
 
     ReadOnly Property ParamArrayExpression() As ArrayCreationExpression
         Get
             If m_IsParamArray = False Then Return Nothing
             Return DirectCast(m_ExactArguments(m_ExactArguments.Count - 1).Expression, ArrayCreationExpression)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="870" endline="878">
<![CDATA[
 		}
 
 		public bool IsUnsafe {
 			get {
 				if ((ModFlags & Modifiers.UNSAFE) != 0)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1477" endline="1486">
<![CDATA[
 
 		public VariableInfo GetSubStruct (string name)
 		{
 			TypeInfo type = TypeInfo.GetSubStruct (name);
 
 			if (type == null)
 				return null;
 
 			return new VariableInfo (this, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2507" endline="2517">
<![CDATA[
 
 		protected abstract TypeExpr DoResolveAsTypeStep (IMemberContext ec);
 
 		public override bool Equals (object obj)
 		{
 			TypeExpr tobj = obj as TypeExpr;
 			if (tobj == null)
 				return false;
 
 			return Type == tobj.Type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2494" endline="2501">
<![CDATA[
 		{
 			TypeExpr t = DoResolveAsTypeStep (ec);
 			if (t == null)
 				return null;
 
 			eclass = ExprClass.Type;
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="485" endline="492">
<![CDATA[
 
 		protected override bool AddMemberType (TypeContainer ds)
 		{
 			if (!AddToContainer (ds, ds.Name))
 				return false;
 			ds.NamespaceEntry.NS.AddType (ds.Definition);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4975" endline="4983">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			ParameterReference pr = obj as ParameterReference;
 			if (pr == null)
 				return false;
 
 			return Name == pr.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4830" endline="4838">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			LocalVariableReference lvr = obj as LocalVariableReference;
 			if (lvr == null)
 				return false;
 
 			return local_info == lvr.local_info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="63" endline="77">
<![CDATA[
 		}
 
 		internal uint ImportAddressTableLength
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return 8;
 				}
 				else
 				{
 					return 16;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2698" endline="2706">
<![CDATA[
 
 		bool CheckFieldTypeCycle (TypeSpec ts)
 		{
 			var fts = ts.MemberDefinition as Struct;
 			if (fts == null)
 				return true;
 
 			return CheckStructCycles (fts);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="824" endline="830">
<![CDATA[
     End Property
 
     ReadOnly Property ParamArrayParameter() As Mono.Cecil.ParameterDefinition
         Get
             If m_IsParamArray = False Then Return Nothing
             Return m_DefinedParameters(m_DefinedParameters.Count - 1)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="861" endline="869">
<![CDATA[
 		}
 
 		public bool IsObsolete {
 			get {
 				if (GetAttributeObsolete () != null)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="832" endline="840">
<![CDATA[
 		}
 
 		public bool HasExtensionMethodType {
 			get {
 				if (Count == 0)
 					return false;
 
 				return FixedParameters [0].HasExtensionMethodModifier;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="443" endline="452">
<![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="550" endline="559">
<![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="663" endline="670">
<![CDATA[
 
 		public override bool IsUsed {
 			get {
 				if (IsExplicitImpl)
 					return true;
 
 				return Get.IsUsed | Set.IsUsed;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="111" endline="119">
<![CDATA[
 
 		public void MarkSequencePoint (int offset, SourceFileEntry file, int line, int column,
 					       bool is_hidden)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.MarkSequencePoint (offset, file, line, column, is_hidden);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6959" endline="6968">
<![CDATA[
 		}
 
 		public override bool Equals (object obj)
 		{
 			This t = obj as This;
 			if (t == null)
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="103" endline="110">
<![CDATA[
 
 		public void DefineScopeVariable (int scope, int index)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.AddScopeVariable (scope, index);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="72" endline="79">
<![CDATA[
 
 		public void DefineLocalVariable (int index, string name)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.AddLocal (index, name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="181" endline="189">
<![CDATA[
 
 		public void OpenCompilerGeneratedBlock (int start_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.StartBlock (CodeBlockEntry.Type.CompilerGenerated,
 						   start_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="173" endline="180">
<![CDATA[
 
 		public void CloseScope (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="190" endline="197">
<![CDATA[
 
 		public void CloseCompilerGeneratedBlock (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3322" endline="3333">
<![CDATA[
 
     Private Function ParseNot(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryNotExpression
 
         If tm.CurrentToken = KS.Not Then
             result = ParseUnaryNotExpression(Info)
         Else
             Return ParseComparison(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="570" endline="581">
<![CDATA[
 
 		public static IList<CustomAttributeData> __GetDeclarativeSecurity(Type type)
 		{
 			if ((type.Attributes & TypeAttributes.HasSecurity) != 0)
 			{
 				return type.Module.GetDeclarativeSecurity(type.MetadataToken);
 			}
 			else
 			{
 				return EmptyList;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="582" endline="593">
<![CDATA[
 
 		public static IList<CustomAttributeData> __GetDeclarativeSecurity(MethodBase method)
 		{
 			if ((method.Attributes & MethodAttributes.HasSecurity) != 0)
 			{
 				return method.Module.GetDeclarativeSecurity(method.MetadataToken);
 			}
 			else
 			{
 				return EmptyList;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="711" endline="718">
<![CDATA[
 		
 	public static bool IsValueType (TypeSpec t)
 	{
 		if (t.IsGenericParameter)
 			return ((TypeParameterSpec) t).IsValueType;
 
 		return t.IsStruct || IsEnumType (t);
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="187" endline="197">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (statement != null) {
 				statement.EmitStatement (ec);
 				ec.Emit (OpCodes.Ret);
 				return;
 			}
 
 			base.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="119" endline="129">
<![CDATA[
 		}
 
 		public override MethodBody GetMethodBody()
 		{
 			IKVM.Reflection.Reader.MethodDefImpl md = method as IKVM.Reflection.Reader.MethodDefImpl;
 			if (md != null)
 			{
 				return md.GetMethodBody(this);
 			}
 			throw new NotSupportedException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="187" endline="194">
<![CDATA[
 
 		public void Load (EmitContext ec)
 		{
 			if (expr is VariableReference)
 				expr.Emit (ec);
 			else
 				LocalVariable.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="217" endline="228">
<![CDATA[
 
 		/// <summary>
 		/// Need to pass type as the constant can require a boxing
 		/// and in such case no optimization is possible
 		/// </summary>
 		public bool IsDefaultInitializer (TypeSpec type)
 		{
 			if (type == Type)
 				return IsDefaultValue;
 
 			return this is NullLiteral;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="33" endline="39">
<![CDATA[
 
     Function GetTypes(ByVal [Namespace] As String) As TypeDictionary
         If Me.ContainsKey([Namespace]) = False Then
             Return Me.AddNamespace([Namespace])
         End If
         Return MyBase.Item([Namespace])
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1520" endline="1527">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null)
 				info = CreateMetaInfo (null);
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="109" endline="120">
<![CDATA[
 
 		protected override bool DoResolveParameters (ResolveContext rc)
 		{
 			//
 			// Only explicit parameters can be resolved at this point
 			//
 			if (HasExplicitParameters) {
 				return Parameters.Resolve (rc);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2038" endline="2046">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			if (expr == null)
 				return;
 
 			ShimExpression target = (ShimExpression) t;
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="692" endline="698">
<![CDATA[
     End Property
 
     ReadOnly Property DefinedParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Get
             If m_DefinedParameters Is Nothing Then m_DefinedParameters = Helper.GetParameters(Compiler, Member)
             Return m_DefinedParameters
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="333" endline="340">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (Type != null)
 				return TypeManager.CSharpName (Type);
 
 			return expression.GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Private Function GetValueType(ByVal tp As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(tp IsNot Nothing)
         If TypeOf tp Is ByReferenceType Then
             Return tp.GetElementType
         Else
             Return tp
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="89" endline="96">
<![CDATA[
     Function FindFirstParentOfCodeBlock(Of T)() As T
         Dim cb As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         If cb IsNot Nothing Then
             Return cb.FindFirstParent(Of T)()
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="909" endline="917">
<![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tR As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         If tR Is Nothing Then
             Return GetTypes(Type.GenericParameters)
         Else
             Return GetTypes(tR.GenericArguments)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="918" endline="926">
<![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Method As Mono.Cecil.MethodReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim mR As Mono.Cecil.GenericInstanceMethod = TryCast(Method, Mono.Cecil.GenericInstanceMethod)
         If mR Is Nothing Then
             Return GetTypes(Method.GenericParameters)
         Else
             Return GetTypes(mR.GenericArguments)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="80" endline="87">
<![CDATA[
 
     Function GetCache(ByVal Type As Mono.Cecil.TypeReference) As MemberCache
         If MemberCache.ContainsKey(Type) Then
             Return MemberCache(Type)
         Else
             Return New MemberCache(Compiler, Type)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="53" endline="63">
<![CDATA[
     End Property
 
     ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Dim exp As Expression = InitializerExpression
             If exp IsNot Nothing Then
                 Return exp.ExpressionType
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="62" endline="78">
<![CDATA[
 
     ''' <summary>
     ''' Looks an list of all TypeBase objects which has the specified Name. 
     '''	If no TypeBase found, returns nothing
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <remarks></remarks>
     Shadows ReadOnly Property Item(ByVal Name As String) As Generic.List(Of INameable)
         Get
             'Name = Name.ToLower
             If m_lstCollections.ContainsKey(Name) Then
                 Return m_lstCollections.Item(Name).Values
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1970" endline="1977">
<![CDATA[
 
     Shared Function CreateGenericTypename(ByVal Typename As String, ByVal TypeArgumentCount As Integer) As String
         If TypeArgumentCount = 0 Then
             Return Typename
         Else
             Return String.Concat(Typename, "`", TypeArgumentCount.ToString)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="38" endline="54">
<![CDATA[
 
     ''' <summary>
     ''' Loops up the namespace of the specified namespace.
     ''' Returns nothing if nothing is found.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Overloads ReadOnly Property Item(ByVal Name As String) As [Namespace]
         Get
             If ContainsKey(Name) Then
                 Return m_Hashed(Name)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="65" endline="72">
<![CDATA[
 
     Overrides Function ToString() As String
         If m_Global Then
             Return "Global." & m_Name
         Else
             Return m_Name
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="73" endline="82">
<![CDATA[
     End Property
 
     ReadOnly Property AddDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_AddMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_AddMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="83" endline="92">
<![CDATA[
     End Property
 
     ReadOnly Property RemoveDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RemoveMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RemoveMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="93" endline="102">
<![CDATA[
     End Property
 
     ReadOnly Property RaiseDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RaiseMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RaiseMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="32" endline="41">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property AsString() As String
         Get
             If m_Expression Is Nothing Then
                 Return "Nothing"
             Else
                 Return m_Expression.AsString
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1408" endline="1414">
<![CDATA[
 
     Shared Function GetReturnType(ByVal Member As MemberReference) As TypeReference
         Dim mr As MethodReference = TryCast(Member, MethodReference)
         If mr IsNot Nothing Then Return mr.ReturnType
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2135" endline="2150">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' If there is only one shared compiler, that one is returned, otherwise nothing is returned.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared ReadOnly Property SharedCompiler() As Compiler
         Get
             If m_SharedCompilers.Count = 1 Then
                 Return m_SharedCompilers(0)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="828" endline="835">
<![CDATA[
 
     Shared Function FilterByName(ByVal Types As TypeDictionary, ByVal Name As String) As Mono.Cecil.TypeReference
         If Types.ContainsKey(Name) Then
             Return Types(Name)
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="808" endline="817">
<![CDATA[
 
 		#region Properties
 
 		public override TypeParameter[] CurrentTypeParameters {
 			get {
 				if (GenericMethod != null)
 					return GenericMethod.CurrentTypeParameters;
 
 				return null;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="589" endline="597">
<![CDATA[
 
 		public Parameter Clone ()
 		{
 			Parameter p = (Parameter) MemberwiseClone ();
 			if (attributes != null)
 				p.attributes = attributes.Clone ();
 
 			return p;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="276" endline="285">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			base.DoResolve (rc);
 
 			if (type != null)
 				type = NullableInfo.GetUnderlyingType (type);
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6736" endline="6744">
<![CDATA[
 
 		protected override Expression ResolveArrayElement (ResolveContext ec, Expression element)
 		{
 			element = element.Resolve (ec);
 			if (element != null)
 				best_type_inference.AddExpression (element);
 
 			return element;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="699" endline="705">
<![CDATA[
     End Property
 
     ReadOnly Property DefinedParametersTypes() As Mono.Cecil.TypeReference()
         Get
             If m_DefinedParametersTypes Is Nothing Then m_DefinedParametersTypes = Helper.GetTypes(DefinedParameters)
             Return m_DefinedParametersTypes
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="90" endline="98">
<![CDATA[
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="97" endline="105">
<![CDATA[
     End Property
 
     ReadOnly Property AttributeArguments() As AttributeArguments
         Get
             If m_AttributeArguments Is Nothing Then
                 m_AttributeArguments = New AttributeArguments(Me)
             End If
             Return m_AttributeArguments
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="60" endline="67">
<![CDATA[
 
     ReadOnly Property PositionalArgumentList() As AttributePositionalArgumentList
         Get
             If m_AttributePositionalArgumentList Is Nothing Then
                 m_AttributePositionalArgumentList = New AttributePositionalArgumentList(Me)
             End If
             Return m_AttributePositionalArgumentList
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="68" endline="76">
<![CDATA[
     End Property
 
     ReadOnly Property VariablePropertyInitializerList() As VariablePropertyInitializerList
         Get
             If m_VariablePropertyInitializerList Is Nothing Then
                 m_VariablePropertyInitializerList = New VariablePropertyInitializerList(Me)
             End If
             Return m_VariablePropertyInitializerList
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="706" endline="712">
<![CDATA[
     End Property
 
     ReadOnly Property ReturnType As TypeReference
         Get
             If m_ReturnType Is Nothing Then m_ReturnType = Helper.GetReturnType(m_Member)
             Return m_ReturnType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="113" endline="121">
<![CDATA[
     End Property
 
     Property TypeParameterConstraints() As TypeParameterConstraints
         Get
             If m_TypeParameterConstraints Is Nothing Then
                 m_TypeParameterConstraints = New TypeParameterConstraints(Me)
             End If
             Return m_TypeParameterConstraints
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="248" endline="262">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Property BaseType() As Mono.Cecil.TypeReference Implements IType.BaseType
         Get
             If m_CecilType Is Nothing Then
                 Return Nothing
             End If
             Return m_CecilType.BaseType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="295" endline="301">
<![CDATA[
     End Property
 
     Public ReadOnly Property FieldType() As Mono.Cecil.TypeReference Implements IFieldMember.FieldType
         Get
             If m_FieldBuilderCecil Is Nothing Then Return Nothing
             Return m_FieldBuilderCecil.FieldType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="624" endline="630">
<![CDATA[
     End Property
 
     ReadOnly Property ResolvedMember() As Mono.Cecil.MemberReference
         Get
             If m_ResolvedCandidate Is Nothing Then Return Nothing
             Return m_ResolvedCandidate.Member
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="114" endline="120">
<![CDATA[
     End Property
 
     Property ConstantValue() As Object
         Get
             If m_ParameterBuilderCecil Is Nothing Then Return Nothing
             Return m_ParameterBuilderCecil.Constant
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="166" endline="172">
<![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             If m_ParameterIdentifier Is Nothing Then Return Nothing
             Return m_ParameterIdentifier.Name
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="80" endline="88">
<![CDATA[
     End Property
 
     ReadOnly Property Handlers() As Generic.List(Of AddOrRemoveHandlerStatement)
         Get
             If m_Handlers Is Nothing Then
                 m_Handlers = New Generic.List(Of AddOrRemoveHandlerStatement)
             End If
             Return m_Handlers
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1146" endline="1153">
<![CDATA[
 
 		public TypeSpec GetArgumentType ()
 		{
 			TypeOf e = GetValue () as TypeOf;
 			if (e == null)
 				return null;
 			return e.TypeArgument;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="79" endline="88">
<![CDATA[
 
 		internal Assembly ToAssembly()
 		{
 			if (imported)
 			{
 				throw new InvalidOperationException();
 			}
 			imported = true;
 			return module.Assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="242" endline="250">
<![CDATA[
 
 		internal void DefineCapturedScope (int scope_id, int id, string captured_name)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedScope (id, captured_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3030" endline="3038">
<![CDATA[
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1918" endline="1931">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Creates fully resolved expression switcher
 		//
 		public static Constant Create (Constant expr, Expression original_expr)
 		{
 			if (expr.eclass == ExprClass.Unresolved)
 				throw new ArgumentException ("Unresolved expression");
 
 			return new ReducedConstantExpression (expr, original_expr);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1314" endline="1321">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec target_type)
 		{
 			// FIXME
 			if (!Convert.ImplicitStandardConversionExists (this, target_type))
 				return null;
 			return child.ConvertImplicitly (rc, target_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3280" endline="3295">
<![CDATA[
 
 		public string GetFullName (string name)
 		{
 			if (!IsExplicitImpl)
 				return name;
 
 			//
 			// When dealing with explicit members a full interface type
 			// name is added to member name to avoid possible name conflicts
 			//
 			// We use CSharpName which gets us full name with benefit of
 			// replacing predefined names which saves some space and name
 			// is still unique
 			//
 			return TypeManager.CSharpName (InterfaceType) + "." + name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="349" endline="357">
<![CDATA[
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (gtpb == null)
 			{
 				throw new InvalidOperationException();
 			}
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3039" endline="3047">
<![CDATA[
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="698" endline="705">
<![CDATA[
 
 		internal MyBinaryReader BinaryReader {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				return reader;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NothingConstantExpression.vb" startline="23" endline="30">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Emitter.EmitLoadNull(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="40" endline="46">
<![CDATA[
 
     Function AddNamespace(ByVal [Namespace] As String) As TypeDictionary
         Dim result As New TypeDictionary()
         Helper.Assert(MyBase.ContainsKey([Namespace]) = False)
         MyBase.Add([Namespace], result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="958" endline="967">
<![CDATA[
 
     ''' <summary>
     ''' Checks whether the specified Type is defined in the current compiling assembly
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedHere(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Helper.Assert(Member IsNot Nothing)
         Return Member.DeclaringType.Module.Assembly Is Compiler.AssemblyBuilderCecil
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="73" endline="85">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if it is not an implements clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ImplementsClause() As MemberImplementsClause
         Get
             helper.Assert(m_clause IsNot Nothing)
             Return TryCast(m_Clause, MemberImplementsClause)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="61" endline="72">
<![CDATA[
 
     ''' <summary>
     ''' Returns nothing if it is not a handles clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property HandlesClause() As HandlesClause
         Get
             Helper.Assert(m_Clause IsNot Nothing)
             Return TryCast(m_Clause, HandlesClause)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="157" endline="168">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The default implementation throws an internal exception.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Overridable ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(m_Classification IsNot Nothing)
             Return m_Classification.ConstantValue
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="136" endline="142">
<![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ParameterList
         Get
             Helper.Assert(m_ParameterList IsNot Nothing)
             Return m_ParameterList
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="134" endline="140">
<![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_ExpressionType IsNot Nothing)
             Return m_ExpressionType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="137" endline="143">
<![CDATA[
     End Property
 
     Property Type() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_Type IsNot Nothing)
             Return m_Type
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="120" endline="128">
<![CDATA[
 
 		public SourceMethodBuilder OpenMethod (ICompileUnit file, int ns_id, IMethodDef method)
 		{
 			SourceMethodBuilder builder = new SourceMethodBuilder (file, ns_id, method);
 			current_method_stack.Push (current_method);
 			current_method = builder;
 			methods.Add (current_method);
 			return builder;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="44" endline="52">
<![CDATA[
 
     ReadOnly Property Constants() As Generic.List(Of EnumMemberDeclaration)
         Get
             If m_Constants Is Nothing Then
                 m_Constants = Members.GetSpecificMembers(Of EnumMemberDeclaration)()
                 Helper.Assert(m_Constants.Count = Members.Count)
             End If
             Return m_Constants
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4563" endline="4573">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (IsLockedByStatement) {
 				rc.Report.Warning (728, 2, loc,
 					"Possibly incorrect assignment to `{0}' which is the argument to a using or lock statement",
 					Name);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="96" endline="103">
<![CDATA[
     End Property
 
     Public Sub AddCustomAttribute(ByVal Attribute As Attribute)
         If m_CustomAttributes Is Nothing Then
             m_CustomAttributes = New Attributes(Me)
         End If
         m_CustomAttributes.Add(Attribute)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3510" endline="3525">
<![CDATA[
 
     ''' <summary>
     ''' VariableIdentifiers  
     '''	            VariableIdentifier  |
     '''	            VariableIdentifiers  ,  VariableIdentifier
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifiers(ByVal Parent As ParsedObject) As VariableIdentifiers
         Dim result As New VariableIdentifiers(Parent)
 
         If ParseList(Of VariableIdentifier)(result, New ParseDelegate_Parent(Of VariableIdentifier)(AddressOf ParseVariableIdentifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5223" endline="5230">
<![CDATA[
 
     Private Function ParseRedimClauses(ByVal Parent As ReDimStatement) As RedimClauses
         Dim result As New RedimClauses(Parent)
         If ParseList(Of RedimClause)(result, New ParseDelegate_Parent(Of RedimClause)(AddressOf ParseRedimClause), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="226" endline="239">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClauses  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClauses(ByVal Parent As ImportsStatement) As ImportsClauses
         Dim result As New ImportsClauses(Parent)
 
         If ParseList(Of ImportsClause)(result, New ParseDelegate_Parent(Of ImportsClause)(AddressOf ParseImportsClause), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2958" endline="2967">
<![CDATA[
 
     Private Function ParseExpressionList(ByVal Parent As ParsedObject) As ExpressionList
         Dim result As New ExpressionList(Parent)
 
         If ParseList(Of Expression)(result, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="850" endline="863">
<![CDATA[
 
     Shared Function GetDefaultGenericConstructor(ByVal closedResolvedType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim candidates As Mono.Collections.Generic.Collection(Of MethodDefinition)
 
         candidates = CecilHelper.FindDefinition(closedResolvedType).Methods
         result = GetDefaultConstructor(candidates)
 
         If result IsNot Nothing Then
             result = CecilHelper.GetCorrectMember(result, closedResolvedType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4863" endline="4877">
<![CDATA[
 
     Private Function ParseTypeVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
         Dim tmp As Boolean
 
         'Console.Write("ParseTypeVariableDeclarator...")
         tmp = ParseVariableDeclarator(Parent, Modifiers, Info, result, False)
         'Console.WriteLine("tmp
         If tmp = False Then
             'Console.WriteLine("tmp was false")
             Return Nothing
         End If
         'Console.WriteLine("tmp was true")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" startline="42" endline="56">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim m As Object
         Dim method As IMethod
 
         Compiler.Helper.AddCheck("End statements may not be used in programs that are not executable (for example, DLLs). ")
 
         m = FindMethod()
         method = TryCast(m, IMethod)
         If method IsNot Nothing Then
             method.CecilBuilder.ImplAttributes = Mono.Cecil.MethodImplAttributes.NoInlining Or Mono.Cecil.MethodImplAttributes.NoOptimization
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1382" endline="1397">
<![CDATA[
 
 		/// <summary>
 		///   Attempts to implicitly convert `source' into `target_type', using
 		///   ImplicitConversion.  If there is no implicit conversion, then
 		///   an error is signaled
 		/// </summary>
 		static public Expression ImplicitConversionRequired (ResolveContext ec, Expression source,
 								     TypeSpec target_type, Location loc)
 		{
 			Expression e = ImplicitConversion (ec, source, target_type, loc);
 			if (e != null)
 				return e;
 
 			source.Error_ValueCannotBeConverted (ec, loc, target_type, false);
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="85" endline="130">
<![CDATA[
 	}
 
 	public interface ISourceFile
 	{
 		SourceFileEntry Entry {
 			get;
 		}
 	}
 
 	public interface ICompileUnit
 	{
 		CompileUnitEntry Entry {
 			get;
 		}
 	}
 
 	public interface IMethodDef
 	{
 		string Name {
 			get;
 		}
 
 		int Token {
 			get;
 		}
 	}
 
 #if !CECIL
 	// TODO
 	internal class MonoDebuggerSupport
 	{
 		static GetMethodTokenFunc get_method_token;
 		static GetGuidFunc get_guid;
 
 		delegate int GetMethodTokenFunc (MethodBase method);
 		delegate Guid GetGuidFunc (Module module);
 
 		static Delegate create_delegate (Type type, Type delegate_type, string name)
 		{
 			MethodInfo mi = type.GetMethod (name, BindingFlags.Static |
 							BindingFlags.NonPublic);
 			if (mi == null)
 				throw new Exception ("Can't find " + name);
 
 			return Delegate.CreateDelegate (delegate_type, mi);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim tp As TypeDeclaration
         tp = Me.FindFirstParent(Of TypeDeclaration)()
         m_ExpressionType = tp.CecilType
 
         '        Classification = New ValueClassification(Me, m_ExpressionType)
         'SPECBUG
         Classification = New VariableClassification(Me, Me, m_ExpressionType)
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2588" endline="2599">
<![CDATA[
 
 		//
 		// FIXME
 		// layout?
 		//
 		protected override TypeAttributes TypeAttr {
 			get {
 				TypeAttributes ta = base.TypeAttr | TypeAttributes.AutoLayout | TypeAttributes.Class;
 				if (IsStatic)
 					ta |= StaticClassAttribute;
 				return ta;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1278" endline="1288">
<![CDATA[
 
 		public TypeSpec Mutate (TypeSpec ts)
 		{
 			TypeSpec value;
 			if (mutated_typespec.TryGetValue (ts, out value))
 				return value;
 
 			value = ts.Mutate (this);
 			mutated_typespec.Add (ts, value);
 			return value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1122" endline="1129">
<![CDATA[
 
 		private Expression GetValue () 
 		{
 			if (PosArguments == null || PosArguments.Count < 1)
 				return null;
 
 			return PosArguments [0].Expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1466" endline="1476">
<![CDATA[
 
 		public void SetFieldAssigned (MyBitVector vector, string field_name)
 		{
 			int field_idx = TypeInfo.GetFieldIndex (field_name);
 
 			if (field_idx == 0)
 				return;
 
 			vector [Offset + field_idx] = true;
 			is_ever_assigned = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="948" endline="956">
<![CDATA[
 
 		protected static TypeExpr CreateExpressionTypeExpression (ResolveContext ec, Location loc)
 		{
 			var t = ec.Module.PredefinedTypes.Expression.Resolve (loc);
 			if (t == null)
 				return null;
 
 			return new TypeExpression (t, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="458" endline="466">
<![CDATA[
 		}
 
 		public CompilationUnit CompilationUnit {
 			get {
 				int index = CompilationUnitIndex;
 				if (index == 0)
 					return null;
 				return (CompilationUnit) source_list [index - 1];
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="437" endline="457">
<![CDATA[
 		}
 
 		// The ISymbolDocumentWriter interface is used by the symbol writer to
 		// describe a single source file - for each source file there's exactly
 		// one corresponding ISymbolDocumentWriter instance.
 		//
 		// This class has an internal hash table mapping source document names
 		// to such ISymbolDocumentWriter instances - so there's exactly one
 		// instance per document.
 		//
 		// This property returns the ISymbolDocumentWriter instance which belongs
 		// to the location's source file.
 		//
 		// If we don't have a symbol writer, this property is always null.
 		public SourceFile SourceFile {
 			get {
 				int index = File;
 				if (index == 0)
 					return null;
 				return (SourceFile) source_list [index - 1];
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1428" endline="1436">
<![CDATA[
 
 		public void SetAssigned (MyBitVector vector)
 		{
 			if (Length == 1)
 				vector [Offset] = true;
 			else
 				vector.SetRange (Offset, Length);
 			is_ever_assigned = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="843" endline="850">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (label == null)
 				throw new InternalErrorException ("goto emitted before target resolved");
 			Label l = label.LabelTarget (ec);
 			ec.Emit (unwind_protect ? OpCodes.Leave 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="96" endline="108">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If IsConstant = False Then Throw New InternalException(Me)
 
             Dim rvalue, lvalue As String
 
             lvalue = CStr(m_LeftExpression.ConstantValue)
             rvalue = CStr(m_RightExpression.ConstantValue)
 
             Return lvalue & rvalue
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="702" endline="712">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (DSA dsa, bool includePrivateKey)
 		{
 			if (dsa == null)
 				throw new ArgumentNullException ("dsa");
 
 			if (includePrivateKey)
 				return ToCapiPrivateKeyBlob (dsa);
 			else
 				return ToCapiPublicKeyBlob (dsa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="691" endline="701">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (RSA rsa, bool includePrivateKey) 
 		{
 			if (rsa == null)
 				throw new ArgumentNullException ("rsa");
 
 			if (includePrivateKey)
 				return ToCapiPrivateKeyBlob (rsa);
 			else
 				return ToCapiPublicKeyBlob (rsa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1010" endline="1019">
<![CDATA[
 		}
 
 		public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if (genericTypeArguments != null || genericMethodArguments != null)
 			{
 				throw new NotImplementedException();
 			}
 			return types[(metadataToken & 0xFFFFFF) - 1];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="103" endline="114">
<![CDATA[
 
 		internal void Finish()
 		{
 			if (bb != null)
 			{
 				throw new InvalidOperationException();
 			}
 			bb = new ByteBuffer(1024);
 			linkOffsets = new List<int>();
 			root.Write(bb, linkOffsets);
 			root = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8796" endline="8805">
<![CDATA[
 			
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			ObsoleteAttribute oa = method.GetAttributeObsolete ();
 			if (oa != null)
 				AttributeTester.Report_ObsoleteMessage (oa, GetSignatureForError (), loc, ec.Report);
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3399" endline="3412">
<![CDATA[
 
 		//
 		// Consumes the saved xml comment lines (if any)
 		// as for current target member or type.
 		//
 		public string consume_doc_comment ()
 		{
 			if (xml_comment_buffer.Length > 0) {
 				string ret = xml_comment_buffer.ToString ();
 				reset_doc_comment ();
 				return ret;
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3023" endline="3032">
<![CDATA[
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3033" endline="3041">
<![CDATA[
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="135" endline="143">
<![CDATA[
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="727" endline="737">
<![CDATA[
 
 		/// <summary>
 		/// Returns true if MemberCore is explicitly marked with CLSCompliantAttribute
 		/// </summary>
 		protected bool HasClsCompliantAttribute {
 			get {
 				if ((caching_flags & Flags.HasCompliantAttribute_Undetected) != 0)
 					IsNotCLSCompliant ();
 				
 				return (caching_flags & Flags.HasClsCompliantAttribute) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="408" endline="415">
<![CDATA[
 
 		public TypeSpec Resolve (Location loc)
 		{
 			if (type == null)
 				type = Resolve (module, kind, ns, name, arity, loc);
 
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="788" endline="796">
<![CDATA[
 
 		protected static Type[] BindTypeParameters(IGenericBinder binder, Type[][][] types, int index, int optOrReq)
 		{
 			if (types == null || types[index] == null)
 			{
 				return null;
 			}
 			return BindTypeParameters(binder, types[index][optOrReq]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="512" endline="520">
<![CDATA[
 		}
 
 		protected override void AddSibling (UsageVector sibling)
 		{
 			if (sibling_list != null && sibling_list.Type == SiblingType.Block)
 				throw new InternalErrorException ("Blocks don't have sibling flow paths");
 			sibling.Next = sibling_list;
 			sibling_list = sibling;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="529" endline="537">
<![CDATA[
 
 		public RawModule OpenRawModule(Stream stream, string location)
 		{
 			if (!stream.CanRead || !stream.CanSeek)
 			{
 				throw new NotSupportedException();
 			}
 			return new RawModule(new ModuleReader(null, this, stream, location));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="35" endline="41">
<![CDATA[
     End Property
 
     ReadOnly Property Code() As System.Text.StringBuilder
         Get
             If m_Code Is Nothing Then m_Code = New System.Text.StringBuilder()
             Return m_Code
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="42" endline="48">
<![CDATA[
     End Property
 
     ReadOnly Property ProjectCode() As System.Text.StringBuilder
         Get
             If m_ProjectCode Is Nothing Then m_ProjectCode = New System.Text.StringBuilder
             Return m_ProjectCode
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="232" endline="241">
<![CDATA[
 
 		internal void DefineCapturedVariable (int scope_id, string name, string captured_name,
 						      CapturedVariable.CapturedKind kind)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedVariable (name, captured_name, kind);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4093" endline="4101">
<![CDATA[
 
 		IList<MemberSpec> CreateConcatMethodCandidates ()
 		{
 			if (concat_members == null) {
 				concat_members = MemberCache.FindMembers (type, "Concat", true);
 			}
 
 			return concat_members;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="220" endline="227">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (builder == null)
 				throw new InternalErrorException ("Emit without Store, or after Release");
 
 			ec.Emit (OpCodes.Ldloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="160" endline="168">
<![CDATA[
 		}
 
 		public PropertyInfo MetaInfo {
 			get {
 				if ((state & StateFlags.PendingMetaInflate) != 0)
 					throw new NotSupportedException ();
 
 				return info;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="150" endline="159">
<![CDATA[
     End Property
 #End If
 
     Function AcceptSequence(ByVal ParamArray ks As KS()) As Boolean
         For i As Integer = 0 To ks.GetUpperBound(0)
             If Me.PeekToken(i).Equals(ks(i)) = False Then Return False
         Next
         Me.NextToken(ks.GetUpperBound(0) + 1)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="904" endline="913">
<![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Cecil.ParameterReference()) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Length - 1)
         For i As Integer = 0 To Parameters.GetUpperBound(0)
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="914" endline="923">
<![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Count - 1)
         For i As Integer = 0 To Parameters.Count - 1
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1584" endline="1593">
<![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenParameters As Mono.Collections.Generic.Collection(Of ParameterReference), ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.ParameterReference()
         Dim result(OpenParameters.Count - 1) As Mono.Cecil.ParameterReference
 
         For i As Integer = 0 To result.Length - 1
             result(i) = ApplyTypeArguments(Parent, OpenParameters(i), TypeParameters, TypeArguments)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="82" endline="98">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a string array with all the namespaces.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property NamespacesAsString() As String()
         Get
             Dim result(Count - 1) As String
             Dim tmp() As [Namespace] = Me.ToArray
             For i As Integer = 0 To Count - 1
                 result(i) = tmp(i).Name
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="309" endline="316">
<![CDATA[
 
     Sub RemoveInvalid()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim m As MemberCandidate = m_Candidates(i)
             If m Is Nothing Then Continue For
             If IsValidCandidate(m) = False Then m_Candidates(i) = Nothing
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="280" endline="290">
<![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MethodReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="269" endline="279">
<![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="257" endline="268">
<![CDATA[
     End Property
 
     Private Sub SetMethods(ByVal lst As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="494" endline="503">
<![CDATA[
 
     Sub ExpandParamArrays()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             candidate.ExpandParamArray()
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="58" endline="65">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As String) As LiteralTypeCharacters_Characters
         chr = chr.ToUpperInvariant
         For i As Integer = 0 To m_Characters.GetUpperBound(0)
             If m_Characters(i).Equals(chr, StringComparison.Ordinal) Then Return CType(i + 1, LiteralTypeCharacters_Characters)
         Next
         Return LiteralTypeCharacters_Characters.None
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="336" endline="350">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Compares this token to any of the specified tokens. 
     ''' Returns true if any token matches.
     ''' </summary>
     ''' <param name="AnySpecial"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overloads Function Equals(ByVal AnySpecial() As KS) As Boolean
         For i As Integer = 0 To VB.UBound(AnySpecial)
             If Equals(AnySpecial(i)) = True Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="563" endline="586">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveCode(Info) AndAlso result
         Next
 
         'We may add statements as we go.
         Dim counter As Integer = 0
         Dim count As Integer = m_Statements.Count
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="713" endline="724">
<![CDATA[
 
 		static public string ToHex (byte[] input) 
 		{
 			if (input == null)
 				return null;
 
 			StringBuilder sb = new StringBuilder (input.Length * 2);
 			foreach (byte b in input) {
 				sb.Append (b.ToString ("X2", CultureInfo.InvariantCulture));
 			}
 			foreach (byte b in input) {
 				sb.Append (b.ToString ("X2", CultureInfo.InvariantCulture));
 			}
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1089" endline="1111">
<![CDATA[
 
 		public bool Resolve (IMemberContext ec)
 		{
 			if (types != null)
 				return true;
 			
 			types = new TypeSpec [Count];
 			
 			bool ok = true;
 			Parameter p;
 			for (int i = 0; i < FixedParameters.Length; ++i) {
 				p = this [i];
 				TypeSpec t = p.Resolve (ec, i);
 				if (t == null) {
 					ok = false;
 					continue;
 				}
 
 				types [i] = t;
 			}
 			for (int i = 0; i < FixedParameters.Length; ++i) {
 				p = this [i];
 				TypeSpec t = p.Resolve (ec, i);
 				if (t == null) {
 					ok = false;
 					continue;
 				}
 
 				types [i] = t;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2691" endline="2713">
<![CDATA[
 
 		//
 		// All unfixed type variables Xi are fixed for which all of the following hold
 		// a, There is at least one type variable Xj that depends on Xi
 		// b, Xi has a non-empty set of bounds
 		// 
 		public bool FixDependentTypes (ResolveContext ec, ref bool fixed_any)
 		{
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (fixed_types[i] != null)
 					continue;
 
 				if (bounds[i] == null)
 					continue;
 
 				if (!FixType (ec, i))
 					return false;
 				
 				fixed_any = true;
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (fixed_types[i] != null)
 					continue;
 
 				if (bounds[i] == null)
 					continue;
 
 				if (!FixType (ec, i))
 					return false;
 				
 				fixed_any = true;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="488" endline="502">
<![CDATA[
 		}
 
 		public PackingSize PackingSize
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				return PackingSize.Unspecified;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="474" endline="487">
<![CDATA[
 
 		public int Size
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				return 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7037" endline="7048">
<![CDATA[
 
 		public MetaType[] ArgumentTypes {
 		    get {
 				if (Arguments == null)
 					return MetaType.EmptyTypes;
 
 				var retval = new MetaType[Arguments.Count];
 		        for (int i = 0; i < retval.Length; i++)
 					retval[i] = Arguments[i].Expr.Type.GetMetaInfo ();
 		        for (int i = 0; i < retval.Length; i++)
 					retval[i] = Arguments[i].Expr.Type.GetMetaInfo ();
 
 		        return retval;
 		    }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="718" endline="728">
<![CDATA[
 
 		public Assembly[] GetAssemblies()
 		{
 			Assembly[] array = new Assembly[assemblies.Count + dynamicAssemblies.Count];
 			assemblies.CopyTo(array);
 			for (int i = 0, j = assemblies.Count; j < array.Length; i++, j++)
 			{
 				array[j] = dynamicAssemblies[i];
 			}
 			for (int i = 0, j = assemblies.Count; j < array.Length; i++, j++)
 			{
 				array[j] = dynamicAssemblies[i];
 			}
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="887" endline="903">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="698" endline="714">
<![CDATA[
 
 		public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<ConstructorInfo> list = new List<ConstructorInfo>();
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				ConstructorInfo constructor = mb as ConstructorInfo;
 				if (constructor != null
 					&& BindingFlagsMatch(constructor.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(constructor.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(constructor);
 				}
 			}
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				ConstructorInfo constructor = mb as ConstructorInfo;
 				if (constructor != null
 					&& BindingFlagsMatch(constructor.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(constructor.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(constructor);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="280" endline="296">
<![CDATA[
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder(this.FullName);
 			string sep = "[";
 			foreach (Type arg in GetGenericArguments())
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			foreach (Type arg in GetGenericArguments())
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			if (sep != "[")
 			{
 				sb.Append(']');
 			}
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="262" endline="270">
<![CDATA[
 
     Private Function IsMatch(ByVal Types As Mono.Cecil.TypeReference(), ByVal Parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If Parameters.Count = 0 AndAlso (Types Is Nothing OrElse Types.Length = 0) Then Return True
         If Parameters.Count <> Types.Length Then Return False
         For j As Integer = 0 To Parameters.Count - 1
             If Helper.CompareType(Parameters(j).ParameterType, Types(j)) = False Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1334" endline="1342">
<![CDATA[
 
     Public Shared Function AreSame(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         If a.Count = 0 Then Return True
         For i As Integer = 0 To a.Count - 1
             If Not AreSame(a(i).ParameterType, b(i).ParameterType) Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="248" endline="261">
<![CDATA[
 
     Protected Function GetProperty(ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String, ByVal ParamArray Types() As Mono.Cecil.TypeReference) As Mono.Cecil.PropertyDefinition
         If Type Is Nothing Then Return Nothing
         Dim properties As Mono.Collections.Generic.Collection(Of PropertyDefinition)
         properties = CecilHelper.FindProperties(Type.Properties, Name)
         For i As Integer = 0 To properties.Count - 1
             Dim prop As Mono.Cecil.PropertyDefinition = properties(i)
             Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = prop.Parameters
 
             If IsMatch(Types, params) Then Return prop
         Next
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="671" endline="682">
<![CDATA[
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="301" endline="308">
<![CDATA[
 
     Function IsValidCandidate(ByVal candidate As MemberCandidate) As Boolean
         If CecilHelper.IsValidType(candidate.ReturnType) = False Then Return False
         For j As Integer = 0 To candidate.DefinedParametersTypes.Length - 1
             If CecilHelper.IsValidType(candidate.DefinedParametersTypes(j)) = False Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="911" endline="923">
<![CDATA[
 
 		public Constant GetNamedValue (string name)
 		{
 			if (named_values == null)
 				return null;
 
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="861" endline="872">
<![CDATA[
 
 		internal ManifestResourceInfo GetManifestResourceInfo(string resourceName)
 		{
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				if (resourceName == GetString(ManifestResource.records[i].Name))
 				{
 					return new ManifestResourceInfo(this, i);
 				}
 			}
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				if (resourceName == GetString(ManifestResource.records[i].Name))
 				{
 					return new ManifestResourceInfo(this, i);
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1224" endline="1234">
<![CDATA[
 
 		public TypeSpec Inflate (TypeParameterSpec tp)
 		{
 			for (int i = 0; i < tparams.Length; ++i)
 				if (tparams [i] == tp)
 					return targs[i];
 			for (int i = 0; i < tparams.Length; ++i)
 				if (tparams [i] == tp)
 					return targs[i];
 
 			// This can happen when inflating nested types
 			// without type arguments specified
 			return tp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="357" endline="369">
<![CDATA[
 
 		internal void WriteMethodRefSig(ModuleBuilder module, ByteBuffer bb, Type[] optionalParameterTypes)
 		{
 			WriteSigImpl(module, bb, parameterTypes.Length + optionalParameterTypes.Length);
 			if (optionalParameterTypes.Length > 0)
 			{
 				bb.Write(SENTINEL);
 				foreach (Type type in optionalParameterTypes)
 				{
 					WriteType(module, bb, type);
 				}
 				foreach (Type type in optionalParameterTypes)
 				{
 					WriteType(module, bb, type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="32" endline="40">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParameterTypes() As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         If ParameterTypes IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In ParameterTypes
                 Add("", t)
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="67" endline="78">
<![CDATA[
 
 		static private byte[] Trim (byte[] array) 
 		{
 			for (int i=0; i < array.Length; i++) {
 				if (array [i] != 0x00) {
 					byte[] result = new byte [array.Length - i];
 					Buffer.BlockCopy (array, i, result, 0, result.Length);
 					return result;
 				}
 			}
 			for (int i=0; i < array.Length; i++) {
 				if (array [i] != 0x00) {
 					byte[] result = new byte [array.Length - i];
 					Buffer.BlockCopy (array, i, result, 0, result.Length);
 					return result;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="103" endline="122">
<![CDATA[
 		}
 
 		public bool IsAttribute {
 			get {
 				if (!IsClass)
 					return false;
 
 				var type = this;
 				do {
 					if (type.IsGeneric)
 						return false;
 
 					if (type == TypeManager.attribute_type)
 						return true;
 					
 					type = type.base_type;
 				} while (type != null);
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2061" endline="2070">
<![CDATA[
 
 		bool IsTokenIdentifierEqual (char[] identifier)
 		{
 			for (int i = 0; i < identifier.Length; ++i) {
 				if (identifier[i] != id_builder[i])
 					return false;
 			}
 			for (int i = 0; i < identifier.Length; ++i) {
 				if (identifier[i] != id_builder[i])
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="579" endline="589">
<![CDATA[
 
 		public CompileUnitEntry[] CompileUnits {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				CompileUnitEntry[] retval = new CompileUnitEntry [CompileUnitCount];
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="543" endline="553">
<![CDATA[
 
 		public SourceFileEntry[] Sources {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				SourceFileEntry[] retval = new SourceFileEntry [SourceCount];
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="175" endline="186">
<![CDATA[
 
 		private int GetModuleIndex(string name)
 		{
 			for (int i = 0; i < manifestModule.File.records.Length; i++)
 			{
 				if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
 				{
 					return i;
 				}
 			}
 			for (int i = 0; i < manifestModule.File.records.Length; i++)
 			{
 				if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
 				{
 					return i;
 				}
 			}
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1290" endline="1302">
<![CDATA[
 
 		internal void GetLayout(int token, ref int pack, ref int size)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Parent == token)
 				{
 					pack = records[i].PackingSize;
 					size = records[i].ClassSize;
 					break;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Parent == token)
 				{
 					pack = records[i].PackingSize;
 					size = records[i].ClassSize;
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1231" endline="1255">
<![CDATA[
 	}
 
 	sealed class ClassLayoutTable 
 	{
 		internal const int Index = 0x0f;
 
 		internal struct Record
 		{
 			internal short PackingSize;
 			internal int ClassSize;
 			internal int Parent;
 		}
 
 		internal void AddOrReplaceRecord(Record rec)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Parent == rec.Parent)
 				{
 					records[i] = rec;
 					return;
 				}
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Parent == rec.Parent)
 				{
 					records[i] = rec;
 					return;
 				}
 			}
 			AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1774" endline="1785">
<![CDATA[
 
 		internal int FindOrAddRecord(int str)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(str);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="276" endline="287">
<![CDATA[
 
 		internal bool Match(int pos, ByteBuffer bb2, int pos2, int len)
 		{
 			for (int i = 0; i < len; i++)
 			{
 				if (buffer[pos + i] != bb2.buffer[pos2 + i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < len; i++)
 			{
 				if (buffer[pos + i] != bb2.buffer[pos2 + i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1380" endline="1391">
<![CDATA[
 
 		internal int FindOrAddRecord(int blob)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(blob);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2494" endline="2503">
<![CDATA[
 
 		public ParameterInfo GetParameterInfo (Parameter p)
 		{
 			for (int i = 0; i < parameters.Count; ++i) {
 				if (parameters[i] == p)
 					return parameter_info[i];
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				if (parameters[i] == p)
 					return parameter_info[i];
 			}
 
 			throw new ArgumentException ("Invalid parameter");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="799" endline="811">
<![CDATA[
 
 		//
 		// Returns the parameter information based on the name
 		//
 		public int GetParameterIndexByName (string name)
 		{
 			for (int idx = 0; idx < Count; ++idx) {
 				if (parameters [idx].Name == name)
 					return idx;
 			}
 			for (int idx = 0; idx < Count; ++idx) {
 				if (parameters [idx].Name == name)
 					return idx;
 			}
 
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2682" endline="2690">
<![CDATA[
 
 		public bool FixAllTypes (ResolveContext ec)
 		{
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (!FixType (ec, i))
 					return false;
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (!FixType (ec, i))
 					return false;
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="218" endline="226">
<![CDATA[
 
 		private static void WriteUTF16Z(ByteBuffer bb, string str)
 		{
 			foreach (char c in str)
 			{
 				bb.Write((short)c);
 			}
 			foreach (char c in str)
 			{
 				bb.Write((short)c);
 			}
 			bb.Write((short)0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="822" endline="832">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2432" endline="2442">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1112" endline="1129">
<![CDATA[
 
 		public void ResolveDefaultValues (MemberCore m)
 		{
 			ResolveContext rc = null;
 			for (int i = 0; i < parameters.Length; ++i) {
 				Parameter p = (Parameter) parameters [i];
 
 				//
 				// Try not to enter default values resolution if there are is not any default value possible
 				//
 				if (p.HasDefaultValue || p.OptAttributes != null) {
 					if (rc == null)
 						rc = new ResolveContext (m);
 
 					p.ResolveDefaultValue (rc);
 				}
 			}
 			for (int i = 0; i < parameters.Length; ++i) {
 				Parameter p = (Parameter) parameters [i];
 
 				//
 				// Try not to enter default values resolution if there are is not any default value possible
 				//
 				if (p.HasDefaultValue || p.OptAttributes != null) {
 					if (rc == null)
 						rc = new ResolveContext (m);
 
 					p.ResolveDefaultValue (rc);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="746" endline="753">
<![CDATA[
 
     Public Shared Function GetNestedType(ByVal Type As TypeReference, ByVal Name As String) As TypeReference
         Dim tD As TypeDefinition = FindDefinition(Type)
         For i As Integer = 0 To tD.NestedTypes.Count - 1
             If Helper.CompareName(tD.NestedTypes(i).Name, Name) Then Return tD.NestedTypes(i)
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1159" endline="1172">
<![CDATA[
 
     Public Shared Function FindConstructor(ByVal Methods As Mono.Collections.Generic.Collection(Of MethodDefinition), ByVal [Shared] As Boolean, ByVal parameters() As TypeReference) As MethodReference
         For i As Integer = 0 To Methods.Count - 1
             Dim mr As MethodDefinition = Methods(i)
 
             If mr.IsConstructor = False Then Continue For
             If mr.IsStatic Then
                 If [Shared] Then Return mr
                 Continue For
             End If
             If Helper.CompareTypes(Helper.GetParameterTypes(Compiler.CurrentCompiler, mr), parameters) Then Return mr
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="47" endline="55">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterList(NewParent)
         For i As Integer = 0 To Me.Count - 1
             result.Add(Me.Item(i).Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="59" endline="68">
<![CDATA[
 
     Public Shared Function GetMembers(ByVal Type As Mono.Cecil.GenericParameter) As Mono.Collections.Generic.Collection(Of MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of MemberReference)()
 
         For i As Integer = 0 To Type.Constraints.Count - 1
             AddRange(result, GetMembers(Type.Constraints(i)))
         Next
         AddRange(result, GetMembers(BaseObject.m_Compiler.TypeCache.System_Object))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="893" endline="900">
<![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of GenericParameter)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="901" endline="908">
<![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="434" endline="449">
<![CDATA[
 
 		internal IList<CustomAttributeData> GetDeclarativeSecurity(int metadataToken)
 		{
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			// TODO use binary search?
 			for (int i = 0; i < DeclSecurity.records.Length; i++)
 			{
 				if (DeclSecurity.records[i].Parent == metadataToken)
 				{
 					int action = DeclSecurity.records[i].Action;
 					int permissionSet = DeclSecurity.records[i].PermissionSet;
 					CustomAttributeData.ReadDeclarativeSecurity(this.Assembly, list, action, GetBlob(permissionSet));
 				}
 			}
 			for (int i = 0; i < DeclSecurity.records.Length; i++)
 			{
 				if (DeclSecurity.records[i].Parent == metadataToken)
 				{
 					int action = DeclSecurity.records[i].Action;
 					int permissionSet = DeclSecurity.records[i].PermissionSet;
 					CustomAttributeData.ReadDeclarativeSecurity(this.Assembly, list, action, GetBlob(permissionSet));
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="98" endline="112">
<![CDATA[
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			int token = this.MetadataToken;
 			List<Type> list = new List<Type>();
 			// TODO use binary search?
 			for (int i = 0; i < module.InterfaceImpl.records.Length; i++)
 			{
 				if (module.InterfaceImpl.records[i].Class == token)
 				{
 					list.Add(module.ResolveType(module.InterfaceImpl.records[i].Interface, this));
 				}
 			}
 			for (int i = 0; i < module.InterfaceImpl.records.Length; i++)
 			{
 				if (module.InterfaceImpl.records[i].Class == token)
 				{
 					list.Add(module.ResolveType(module.InterfaceImpl.records[i].Interface, this));
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="158" endline="172">
<![CDATA[
 
 		public override Type[] __GetDeclaredTypes()
 		{
 			int token = this.MetadataToken;
 			List<Type> list = new List<Type>();
 			// TODO use binary search?
 			for (int i = 0; i < module.NestedClass.records.Length; i++)
 			{
 				if (module.NestedClass.records[i].EnclosingClass == token)
 				{
 					list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
 				}
 			}
 			for (int i = 0; i < module.NestedClass.records.Length; i++)
 			{
 				if (module.NestedClass.records[i].EnclosingClass == token)
 				{
 					list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1857" endline="1868">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MemberForwarded))
 				{
 					records[i].MemberForwarded = moduleBuilder.ResolvePseudoToken(records[i].MemberForwarded);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MemberForwarded))
 				{
 					records[i].MemberForwarded = moduleBuilder.ResolvePseudoToken(records[i].MemberForwarded);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="817" endline="828">
<![CDATA[
 
 		public string GetSignatureForError (string start, string end, int count)
 		{
 			StringBuilder sb = new StringBuilder (start);
 			for (int i = 0; i < count; ++i) {
 				if (i != 0)
 					sb.Append (", ");
 				sb.Append (ParameterDesc (i));
 			}
 			for (int i = 0; i < count; ++i) {
 				if (i != 0)
 					sb.Append (", ");
 				sb.Append (ParameterDesc (i));
 			}
 			sb.Append (end);
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="987" endline="996">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasCustomAttribute(records[i].Parent);
 				mw.WriteCustomAttributeType(records[i].Type);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasCustomAttribute(records[i].Parent);
 				mw.WriteCustomAttributeType(records[i].Type);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1529" endline="1538">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1706" endline="1715">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2093" endline="2102">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="789" endline="798">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1178" endline="1187">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Action);
 				mw.WriteHasDeclSecurity(records[i].Parent);
 				mw.WriteBlobIndex(records[i].PermissionSet);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Action);
 				mw.WriteHasDeclSecurity(records[i].Parent);
 				mw.WriteBlobIndex(records[i].PermissionSet);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="855" endline="864">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1451" endline="1460">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1578" endline="1587">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Semantics);
 				mw.WriteMethodDef(records[i].Method);
 				mw.WriteHasSemantics(records[i].Association);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Semantics);
 				mw.WriteMethodDef(records[i].Method);
 				mw.WriteHasSemantics(records[i].Association);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="506" endline="515">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteResolutionScope(records[i].ResolutionScope);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNameSpace);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteResolutionScope(records[i].ResolutionScope);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNameSpace);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1263" endline="1269">
<![CDATA[
 
     Private Shared Sub AddPropertyUnlessSignatureMatches(ByVal properties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference), ByVal prop As Mono.Cecil.PropertyReference)
         For i As Integer = 0 To properties.Count - 1
             If Helper.CompareParameterTypes(prop.Parameters, properties(i).Parameters) = True Then Return
         Next
         properties.Add(prop)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="37" endline="46">
<![CDATA[
 
     Function AsTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To Me.Count - 1
             result(i) = Item(i).CecilBuilder
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3398" endline="3407">
<![CDATA[
 
     Shared Function ArgumentsToExpressions(ByVal Arguments As Generic.List(Of Argument)) As Expression()
         Dim result(Arguments.Count - 1) As Expression
 
         For i As Integer = 0 To Arguments.Count - 1
             result(i) = Arguments(i).Expression
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="53" endline="61">
<![CDATA[
 
     ReadOnly Property AsExpressions() As Expression()
         Get
             Dim result(Me.Count - 1) As Expression
             For i As Integer = 0 To Me.Count - 1
                 result(i) = Item(i).Expression
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="71" endline="79">
<![CDATA[
     End Property
 
     Function ToTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
         For i As Integer = 0 To Me.Count - 1
             result(i) = Me.Item(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1978" endline="1985">
<![CDATA[
 
     Shared Function CreateArray(Of T)(ByVal Value As T, ByVal Length As Integer) As T()
         Dim result(Length - 1) As T
         For i As Integer = 0 To Length - 1
             result(i) = Value
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="60" endline="70">
<![CDATA[
 
     ReadOnly Property AsParameterInfo() As Mono.Cecil.ParameterDefinition()
         Get
             If m_ParameterInfos Is Nothing Then
                 ReDim m_ParameterInfos(Me.Count - 1)
                 For i As Integer = 0 To Count - 1
                     m_ParameterInfos(i) = Me(i).CecilBuilder
                 Next
             End If
             Return m_ParameterInfos
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArgumentList.vb" startline="32" endline="42">
<![CDATA[
 
     ReadOnly Property ArgumentCollection() As Mono.Collections.Generic.Collection(Of TypeReference)
         Get
             If m_ArgumentCollection Is Nothing Then
                 m_ArgumentCollection = New Mono.Collections.Generic.Collection(Of TypeReference)()
                 For i As Integer = 0 To Count - 1
                     m_ArgumentCollection.Add(Item(i).ResolvedType)
                 Next
             End If
             Return m_ArgumentCollection
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1360" endline="1369">
<![CDATA[
 
 		internal void Write (MonoSymbolFile file, MyBinaryWriter bw)
 		{
 			bw.Write (Name);
 			bw.WriteLeb128 (Index);
 			bw.WriteLeb128 (Parent);
 			bw.WriteLeb128 (UsingClauses.Length);
 			foreach (string uc in UsingClauses)
 				bw.Write (uc);
 			foreach (string uc in UsingClauses)
 				bw.Write (uc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1465" endline="1472">
<![CDATA[
 
 		internal static void InplaceBindTypeParameters(IGenericBinder binder, Type[] types)
 		{
 			for (int i = 0; i < types.Length; i++)
 			{
 				types[i] = types[i].BindTypeParameters(binder);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				types[i] = types[i].BindTypeParameters(binder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="94" endline="123">
<![CDATA[
 
     '''' <summary>
     '''' Checks that all types are equal.
     '''' Returns nothing if types are not equal.
     '''' </summary>
     '''' <param name="Types"></param>
     '''' <returns></returns>
     '''' <remarks></remarks>
     'Private Function CheckUniqueType(ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
     '    Helper.Assert(Types.Length >= 1)
     '    For i As Integer = 1 To Types.Length - 1
     '        If Helper.CompareType(Types(0), Types(i)) = False Then Return Nothing
     '    Next
     '    Return Types(0)
     'End Function
 
     ''' <summary>
     ''' Checks that all types are equal.
     ''' Returns nothing if types are not equal.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function CheckUniqueType(ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(Types.Length >= 1)
         For i As Integer = 1 To Types.Length - 1
             If Helper.CompareType(Types(0), Types(i)) = False Then Return Nothing
         Next
         Return Types(0)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="219" endline="226">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For i As Integer = 0 To m_TypeDeclarations.Length - 1
             m_TypeDeclarations(i).Initialize(Me)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="230" endline="237">
<![CDATA[
 
 		public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			for (int i = 0; i < arguments.Length; i++)
 			{
 				AddArgument(arguments[i], false, requiredCustomModifiers[i], optionalCustomModifiers[i]);
 			}
 			for (int i = 0; i < arguments.Length; i++)
 			{
 				AddArgument(arguments[i], false, requiredCustomModifiers[i], optionalCustomModifiers[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="607" endline="617">
<![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			typeFlags |= TypeFlags.IsGenericTypeDefinition;
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1412" endline="1420">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1470" endline="1489">
<![CDATA[
 	}
 
 	sealed class PropertyMapTable 
 	{
 		internal const int Index = 0x15;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int PropertyList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2463" endline="2471">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteGenericParam(records[i].Owner);
 				mw.WriteTypeDefOrRef(records[i].Constraint);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteGenericParam(records[i].Owner);
 				mw.WriteTypeDefOrRef(records[i].Constraint);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="715" endline="723">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1490" endline="1498">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2402" endline="2410">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMethodDefOrRef(records[i].Method);
 				mw.WriteBlobIndex(records[i].Instantiation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMethodDefOrRef(records[i].Method);
 				mw.WriteBlobIndex(records[i].Instantiation);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1392" endline="1411">
<![CDATA[
 	}
 
 	sealed class EventMapTable 
 	{
 		internal const int Index = 0x12;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int EventList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2443" endline="2462">
<![CDATA[
 	}
 
 	sealed class GenericParamConstraintTable 
 	{
 		internal const int Index = 0x2C;
 
 		internal struct Record
 		{
 			internal int Owner;
 			internal int Constraint;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1113" endline="1121">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2238" endline="2246">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].NestedClass);
 				mw.WriteTypeDef(records[i].EnclosingClass);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].NestedClass);
 				mw.WriteTypeDef(records[i].EnclosingClass);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2382" endline="2401">
<![CDATA[
 	}
 
 	sealed class MethodSpecTable 
 	{
 		internal const int Index = 0x2B;
 
 		internal struct Record
 		{
 			internal int Method;
 			internal int Instantiation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1093" endline="1112">
<![CDATA[
 	}
 
 	sealed class FieldMarshalTable 
 	{
 		internal const int Index = 0x0D;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int NativeType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1323" endline="1331">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1303" endline="1322">
<![CDATA[
 	}
 
 	sealed class FieldLayoutTable 
 	{
 		internal const int Index = 0x10;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2218" endline="2237">
<![CDATA[
 	}
 
 	sealed class NestedClassTable 
 	{
 		internal const int Index = 0x29;
 
 		internal struct Record
 		{
 			internal int NestedClass;
 			internal int EnclosingClass;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1894" endline="1902">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1874" endline="1893">
<![CDATA[
 	}
 
 	sealed class FieldRVATable 
 	{
 		internal const int Index = 0x1D;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3772" endline="3791">
<![CDATA[
 
     ''' <summary>
     ''' SubSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSubSignature(ByVal Parent As ParsedObject) As SubSignature
         Dim result As New SubSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2014" endline="2028">
<![CDATA[
 
     Private Function ParseCCharExpression(ByVal Parent As ParsedObject) As CCharExpression
         Dim result As New CCharExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CChar)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2404" endline="2417">
<![CDATA[
 
     Private Function ParseUnaryPlusExpression(ByVal Info As ExpressionParseInfo) As UnaryPlusExpression
         Dim result As New UnaryPlusExpression(Info.Parent)
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Add)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1999" endline="2013">
<![CDATA[
 
     Private Function ParseCBoolExpression(ByVal Parent As ParsedObject) As CBoolExpression
         Dim result As New CBoolExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CBool)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2345" endline="2359">
<![CDATA[
 
 
     Private Function ParseUnaryMinusExpression(ByVal Info As ExpressionParseInfo) As UnaryMinusExpression
         Dim result As New UnaryMinusExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Minus)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2209" endline="2223">
<![CDATA[
 
     Private Function ParseCUShortExpression(ByVal Parent As ParsedObject) As CUShortExpression
         Dim result As New CUShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2194" endline="2208">
<![CDATA[
 
     Private Function ParseCULngExpression(ByVal Parent As ParsedObject) As CULngExpression
         Dim result As New CULngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CULng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2179" endline="2193">
<![CDATA[
 
     Private Function ParseCUIntExpression(ByVal Parent As ParsedObject) As CUIntExpression
         Dim result As New CUIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2164" endline="2178">
<![CDATA[
 
     Private Function ParseCStrExpression(ByVal Parent As ParsedObject) As CStrExpression
         Dim result As New CStrExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CStr)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2149" endline="2163">
<![CDATA[
 
     Private Function ParseCSngExpression(ByVal Parent As ParsedObject) As CSngExpression
         Dim result As New CSngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2134" endline="2148">
<![CDATA[
 
     Private Function ParseCShortExpression(ByVal Parent As ParsedObject) As CShortExpression
         Dim result As New CShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2119" endline="2133">
<![CDATA[
 
     Private Function ParseCSByteExpression(ByVal Parent As ParsedObject) As CSByteExpression
         Dim result As New CSByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2029" endline="2043">
<![CDATA[
 
     Private Function ParseCDateExpression(ByVal Parent As ParsedObject) As CDateExpression
         Dim result As New CDateExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDate)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2104" endline="2118">
<![CDATA[
 
     Private Function ParseCObjExpression(ByVal Parent As ParsedObject) As CObjExpression
         Dim result As New CObjExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CObj)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2089" endline="2103">
<![CDATA[
 
     Private Function ParseCLngExpression(ByVal Parent As ParsedObject) As CLngExpression
         Dim result As New CLngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CLng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2074" endline="2088">
<![CDATA[
 
     Private Function ParseCIntExpression(ByVal Parent As ParsedObject) As CIntExpression
         Dim result As New CIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2059" endline="2073">
<![CDATA[
 
     Private Function ParseCDecExpression(ByVal Parent As ParsedObject) As CDecExpression
         Dim result As New CDecExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDec)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2044" endline="2058">
<![CDATA[
 
     Private Function ParseCDblExpression(ByVal Parent As ParsedObject) As CDblExpression
         Dim result As New CDblExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDbl)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1985" endline="1998">
<![CDATA[
 
     Private Function ParseCByteExpression(ByVal Parent As ParsedObject) As CByteExpression
         Dim result As New CByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5270" endline="5288">
<![CDATA[
 
     ''' <summary>
     ''' ErrorStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseErrorStatement(ByVal Parent As ParsedObject) As ErrorStatement
         Dim result As New ErrorStatement(Parent)
 
         Dim m_ErrNumber As Expression
 
         tm.AcceptIfNotInternalError(KS.Error)
 
         m_ErrNumber = ParseExpression(result)
         If m_ErrNumber Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_ErrNumber)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5183" endline="5204">
<![CDATA[
 
     ''' <summary>
     ''' EraseStatement  
     ''' EraseExpressions  
     '''	  Expression  |
     '''	  EraseExpressions  ,  Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEraseStatement(ByVal Parent As ParsedObject) As EraseStatement
         Dim result As New EraseStatement(Parent)
 
         Dim m_Targets As ExpressionList
 
         tm.AcceptIfNotInternalError(KS.Erase)
 
         m_Targets = ParseExpressionList(Parent)
         If m_Targets Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Targets)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="58" endline="74">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_WithExpression Is m_WithVariableExpression = False Then
             m_WithVariable = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, m_WithExpression.ExpressionType), "WithVariable" & Me.ObjectID.ToString)
             result = m_WithExpression.GenerateCode(Info.Clone(Me, True, False, m_WithVariable.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_WithVariable)
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         Emitter.FreeLocal(m_WithVariable)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="521" endline="532">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			LabeledStatement stmt = Block == null ? null 
 			if (stmt == null)
 				return Parent.AddGotoOrigin (vector, goto_stmt);
 
 			// forward jump
 			goto_stmt.SetResolvedTarget (stmt);
 			stmt.AddUsageVector (vector);
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="570" endline="584">
<![CDATA[
 		}
 
 		//
 		// Resolves all type parameter constraints
 		//
 		public bool ResolveConstraints (IMemberContext context)
 		{
 			if (constraints != null)
 				return constraints.Resolve (context, this);
 
 			if (spec.BaseType == null)
 				spec.BaseType = TypeManager.object_type;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1413" endline="1426">
<![CDATA[
 		}
 
 		//
 		// Returns true if this is a default constructor
 		//
 		public bool IsDefault ()
 		{
 			if ((ModFlags & Modifiers.STATIC) != 0)
 				return parameters.IsEmpty;
 
 			return parameters.IsEmpty &&
 					(Initializer is ConstructorBaseInitializer) &&
 					(Initializer.Arguments == null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1369" endline="1379">
<![CDATA[
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			if (IsAssigned (ec))
 				return true;
 
 			ec.Report.Error (165, loc,
 				      "Use of unassigned local variable `" + Name + "'");
 			ec.CurrentBranching.SetAssigned (this);
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="336" endline="343">
<![CDATA[
 
 		public FullNamedExpression Lookup (CompilerContext ctx, string name, int arity, Location loc)
 		{
 			if (arity == 0 && namespaces.ContainsKey (name))
 				return namespaces [name];
 
 			return LookupType (ctx, name, arity, false, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="75" endline="87">
<![CDATA[
 
     ReadOnly Property ConstantValue() As Object
         Get
             If m_Resolved = False Then
                 Dim result As Boolean
                 result = ResolveConstantValue(ResolveInfo.Default(Compiler))
                 If result = False Then
                     Helper.AddError(Me, "")
                     Return Nothing
                 End If
             End If
             Return m_ConstantValue
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="225" endline="238">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns the resolved method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethod() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If m_Group.Count = 0 Then Return Nothing
             Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="35" endline="43">
<![CDATA[
     End Property
 
     Public Function GetAllNames() As String()
         Dim result() As String
         ReDim result(m_lstCollections.Count - 1)
         m_lstCollections.Keys.CopyTo(result, 0)
         Array.Sort(result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="760" endline="769">
<![CDATA[
     End Property
 
 #End Region
 
     ReadOnly Property AllArgumentsAsArray() As String()
         Get
             Dim result(m_lstAllArgs.Count - 1) As String
             m_lstAllArgs.CopyTo(result, 0)
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\Expressions.vb" startline="34" endline="41">
<![CDATA[
     End Property
 
     Shadows Function ToArray() As Expression()
         Dim result As Expression()
         ReDim result(Count - 1)
         Array.Copy(MyBase.ToArray, result, Count)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="645" endline="652">
<![CDATA[
 
 		public NamespaceEntry[] Namespaces {
 			get {
 				ReadData ();
 				NamespaceEntry[] retval = new NamespaceEntry [namespaces.Count];
 				namespaces.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="476" endline="482">
<![CDATA[
 
 		public CapturedVariable[] CapturedVariables {
 			get {
 				CapturedVariable[] retval = new CapturedVariable [captured_vars.Count];
 				captured_vars.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="489" endline="495">
<![CDATA[
 
 		public CapturedScope[] CapturedScopes {
 			get {
 				CapturedScope[] retval = new CapturedScope [captured_scopes.Count];
 				captured_scopes.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3296" endline="3307">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			if (GenericMethod != null)
 				GenericMethod.VerifyClsCompliance ();
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2485" endline="2493">
<![CDATA[
 
 		protected override bool ResolveMemberType ()
 		{
 			if (!base.ResolveMemberType ())
 				return false;
 
 			flags |= MethodAttributes.SpecialName | MethodAttributes.HideBySig;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="311" endline="318">
<![CDATA[
 
 		protected virtual string GetTypeNameSignature ()
 		{
 			if (!IsGeneric)
 				return null;
 
 			return "<" + TypeManager.CSharpName (MemberDefinition.TypeParameters) + ">";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="58" endline="66">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1511" endline="1519">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (!Define (ec))
 				return null;
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="113" endline="121">
<![CDATA[
 
 		protected override bool CheckBase ()
 		{
 			// Check whether arguments were correct.
 			if (!DefineParameters (parameters))
 				return false;
 
 			return base.CheckBase ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="793" endline="812">
<![CDATA[
 
 	bool MethodIsExplicitIfaceImpl (MethodBase mb)
 	{
 		if (!(mb.IsFinal && mb.IsVirtual && mb.IsPrivate))
 			return false;
 		
 		// UGH msft has no way to get the info about what method is
 		// getting overriden. Another reason to use cecil 
 		//
 		//MethodInfo mi = mb as MethodInfo;
 		//if (mi == null)
 		//	return false;
 		//
 		//Console.WriteLine (mi.GetBaseDefinition ().DeclaringType);
 		//return mi.GetBaseDefinition ().DeclaringType.IsInterface;
 		
 		// So, we guess that virtual final private methods only come
 		// from ifaces 
 		return true;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2548" endline="2555">
<![CDATA[
 
     Shared Function GetPropertyOrPropertyBuilder(ByVal Compiler As Compiler, ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.PropertyReference
         If Compiler.Assembly.IsDefinedHere([Property]) Then
             Return [Property]
         Else
             Return [Property]
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2968" endline="2976">
<![CDATA[
 
     <Obsolete()> Private Function ParseExpression() As Expression
         Dim result As Expression = Nothing
 
         Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         '        result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3498" endline="3506">
<![CDATA[
 
     Shared Function IsFirstLessGeneric(ByVal Context As BaseObject) As Boolean
         'A member M is determined to be less generic than a member N using the following steps
         '-	If M has fewer method type parameters than N, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the method, or Mj is less generic with respect to type parameters on the method, and at least one Mj is less generic than Nj, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the type, or Mj is less generic with respect to type parameters on the type, and at least one Mj is less generic than Nj, then M is less generic than N.
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="130" endline="141">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The type of the expression.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="482" endline="490">
<![CDATA[
 
 		private static Type[] NormalizeAndCopy(Type[][] array, int index)
 		{
 			if (array == null || array.Length == 0)
 			{
 				return null;
 			}
 			return NormalizeAndCopy(array[index]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="322" endline="330">
<![CDATA[
 		}
 
 		public CodeBlockEntry CurrentBlock {
 			get {
 				if ((_block_stack != null) && (_block_stack.Count > 0))
 					return (CodeBlockEntry) _block_stack.Peek ();
 				else
 					return null;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="590" endline="598">
<![CDATA[
 
 		protected bool DefineAccessors ()
 		{
 			first.Define (Parent);
 			if (AccessorSecond != null)
 				AccessorSecond.Define (Parent);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="290" endline="300">
<![CDATA[
 		}
 
 		#endregion
 
 		public MethodSpec GetGenericMethodDefinition ()
 		{
 			if (!IsGeneric && !DeclaringType.IsGeneric)
 				return this;
 
 			return MemberCache.GetMember (declaringType, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="326" endline="332">
<![CDATA[
 
 		public virtual TypeSpec ResolveType ()
 		{
 			if (Type == null && !resolve_error)
 				ResolveAttributeType ();
 			return Type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="669" endline="678">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     ReadOnly Property Encoding() As System.Text.Encoding
         Get
             If m_Encoding Is Nothing Then m_Encoding = System.Text.Encoding.Default
             Return m_Encoding
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="298" endline="330">
<![CDATA[
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   This method can only deal with fully formed input
 		///   strings and does not provide a completion mechanism.
 		///   If you must deal with partial input (for example for
 		///   interactive use) use the other overload. 
 		///
 		///   On success, a delegate is returned that can be used
 		///   to invoke the method.
 		///
 	        /// </remarks>
 		static public CompiledMethod Compile (string input)
 		{
 			CompiledMethod compiled;
 
 			// Ignore partial inputs
 			if (Compile (input, out compiled) != null){
 				// Error, the input was partial.
 				return null;
 			}
 
 			// Either null (on error) or the compiled method.
 			return compiled;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="270" endline="279">
<![CDATA[
 		}
 
 		public override Type GetGenericTypeDefinition()
 		{
 			if (IsGenericTypeDefinition)
 			{
 				return this;
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="210" endline="218">
<![CDATA[
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (this.IsGenericMethodDefinition)
 			{
 				return this;
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6120" endline="6136">
<![CDATA[
 
 static bool IsUnaryOperator (Operator.OpType op)
 {
 	switch (op) {
 		
 	case Operator.OpType.LogicalNot
 	case Operator.OpType.OnesComplement
 	case Operator.OpType.Increment
 	case Operator.OpType.Decrement
 	case Operator.OpType.True
 	case Operator.OpType.False
 	case Operator.OpType.UnaryPlus
 	case Operator.OpType.UnaryNegation
 		return true;
 	}
 	return false;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="100" endline="111">
<![CDATA[
 
     Function GenerateVariableCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.IsRHS, "With variables can't be assigned to...")
 
         If Info.IsRHS Then
             Emitter.EmitLoadVariable(Info, m_WithVariable)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="124" endline="133">
<![CDATA[
 
     Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, New ArgumentList(Parent, m_Parameters), ResolvedMethod)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="40" endline="47">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitBranchOrLeave(Info, m_Destination.GetLabel(Info), Me, m_Destination)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="162" endline="175">
<![CDATA[
 
 
     ''' <summary>
     ''' Searches for the type with the specified name.
     ''' </summary>
     ''' <param name="Name">The type's name to search for. Not case-sensitive.</param>
     ''' <param name="OnlyCreatedTypes">Specifes whether to search in all types, or only in types compiled now.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function [GetType](ByVal Name As String, ByVal OnlyCreatedTypes As Boolean) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         result.AddRange(Me.GetType(Name, Types, OnlyCreatedTypes))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1159" endline="1165">
<![CDATA[
 
 		internal int GetSignatureBlobIndex(Signature sig)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			sig.WriteSig(this, bb);
 			return this.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1605" endline="1611">
<![CDATA[
 
 		public byte[] ToArray ()
 		{
 			byte[] buf = new byte[pos];
 			Array.Copy (buffer, buf, pos);
 			return buf;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3086" endline="3093">
<![CDATA[
 
     Shared Function IsParamArrayParameter(ByVal Context As BaseObject, ByVal Parameter As Mono.Cecil.ParameterReference) As Boolean
         Dim result As Boolean
         Dim pD As Mono.Cecil.ParameterDefinition = CecilHelper.FindDefinition(Parameter)
         result = CecilHelper.IsDefined(pD.CustomAttributes, Context.Compiler.TypeCache.System_ParamArrayAttribute)
         LogResolutionMessage(Context.Compiler, "IsParamArrayParameter
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="906" endline="927">
<![CDATA[
 				String.Format (
 					"CloneTo not implemented for expression {0}", this.GetType ()));
 		}
 
 		//
 		// Clones an expression created by the parser.
 		//
 		// We only support expressions created by the parser so far, not
 		// expressions that have been resolved (many more classes would need
 		// to implement CloneTo).
 		//
 		// This infrastructure is here merely for Lambda expressions which
 		// compile the same code using different type values for the same
 		// arguments to find the correct overload
 		//
 		public virtual Expression Clone (CloneContext clonectx)
 		{
 			Expression cloned = (Expression) MemberwiseClone ();
 			CloneTo (clonectx, cloned);
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1034" endline="1040">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var tps = (TypeParameterSpec) MemberwiseClone ();
 			InflateConstraints (inflator, tps);
 			return tps;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="53" endline="59">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             Dim value As Object = Expression.ConstantValue
             Return value
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="384" endline="390">
<![CDATA[
 
 		public override Type[] GetRequiredCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetRequiredCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="376" endline="383">
<![CDATA[
 		}
 
 		public override Type[] GetOptionalCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetOptionalCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetRefExpression.vb" startline="52" endline="59">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="71" endline="83">
<![CDATA[
 
 		//
 		// This routine must be overrided in derived classes and make copies
 		// of all the data that might be modified if resolved
 		// 
 		protected abstract void CloneTo (CloneContext clonectx, Statement target);
 
 		public Statement Clone (CloneContext clonectx)
 		{
 			Statement s = (Statement) this.MemberwiseClone ();
 			CloneTo (clonectx, s);
 			return s;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="589" endline="595">
<![CDATA[
 
 		public Module __AddModule(RawModule module)
 		{
 			Module mod = module.ToModule(this);
 			addedModules.Add(mod);
 			return mod;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="672" endline="678">
<![CDATA[
 
 	string GetFullName (Type t)
 	{
 		StringBuilder sb = new StringBuilder ();
 		GetFullName_recursed (sb, t, false);
 		return sb.ToString ();
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="48" endline="55">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.MarkLabel(Info, GetLabel(Info))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="900" endline="906">
<![CDATA[
 
 		internal static LineNumberTable Read (MonoSymbolFile file, MyBinaryReader br)
 		{
 			LineNumberTable lnt = new LineNumberTable (file);
 			lnt.DoRead (file, br);
 			return lnt;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="657" endline="663">
<![CDATA[
 
 	string GetTypeName (Type t)
 	{
 		StringBuilder sb = new StringBuilder ();
 		GetTypeName (sb, t);
 		return sb.ToString ();
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="63" endline="69">
<![CDATA[
     End Property
 
     Function GetAllDictionaries() As Generic.List(Of TypeDictionary)
         Dim result As New Generic.List(Of TypeDictionary)
         result.AddRange(Values)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New PropertyAccessClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="36" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyClassExpression.vb" startline="31" endline="39">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="74" endline="82">
<![CDATA[
     End Property
 
     Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="196" endline="203">
<![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="136" endline="147">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="124" endline="135">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="118" endline="129">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="595" endline="604">
<![CDATA[
 
 	//
 	// Returns the method specification for a method named `name' defined
 	// in type `t' which takes arguments of types `args'
 	//
 	public static MethodSpec GetPredefinedMethod (TypeSpec t, string name, Location loc, params TypeSpec [] args)
 	{
 		var pc = ParametersCompiled.CreateFullyResolved (args);
 		return GetPredefinedMethod (t, MemberFilter.Method (name, 0, pc, null), false, loc);
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="106" endline="117">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="586" endline="594">
<![CDATA[
 
 	//
 	// Returns the ConstructorInfo for "args"
 	//
 	public static MethodSpec GetPredefinedConstructor (TypeSpec t, Location loc, params TypeSpec [] args)
 	{
 		var pc = ParametersCompiled.CreateFullyResolved (args);
 		return GetPredefinedMember (t, MemberFilter.Constructor (pc), false, loc) as MethodSpec;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="213" endline="219">
<![CDATA[
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return IsGeneric ? GenericDefinition.TypeParametersCount 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1637" endline="1644">
<![CDATA[
 
 		public Expression CreateReferenceExpression (ResolveContext rc, Location loc)
 		{
 			if (IsConstant && const_value != null)
 				return Constant.CreateConstantFromValue (Type, const_value.GetValue (), loc).Resolve (rc);
 
 			return new LocalVariableReference (this, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="218" endline="227">
<![CDATA[
 
 		public int CountTypeArguments {
 			get {
 				if (TypeArguments != null)
 					return TypeArguments.Count;
 				else if (Left != null)
 					return Left.CountTypeArguments; 
 				else
 					return 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="374" endline="389">
<![CDATA[
 		}
 
 		internal int WriteBlob(ModuleBuilder moduleBuilder)
 		{
 			ByteBuffer bb = new ByteBuffer(100);
 			if (blob != null)
 			{
 				bb.Write(blob);
 			}
 			else
 			{
 				BlobWriter bw = new BlobWriter(moduleBuilder, this, bb);
 				bw.WriteCustomAttributeBlob();
 			}
 			return moduleBuilder.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="410" endline="420">
<![CDATA[
 
 		public ConstructorInfo Constructor
 		{
 			get
 			{
 				if (lazyConstructor == null)
 				{
 					lazyConstructor = (ConstructorInfo)module.ResolveMethod(module.CustomAttribute.records[index].Type);
 				}
 				return lazyConstructor;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="64" endline="72">
<![CDATA[
     End Property
 
     Public ReadOnly Property EventField() As Mono.Cecil.FieldDefinition
         Get
             Helper.Assert(m_Variable IsNot Nothing)
             Helper.Assert(m_Variable.IsFieldVariable)
             Helper.Assert(m_Variable.FieldBuilder IsNot Nothing)
             Return m_Variable.FieldBuilder
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8627" endline="8635">
<![CDATA[
 
 		protected override void Error_ThisNotAvailable (ResolveContext ec)
 		{
 			if (ec.IsStatic) {
 				ec.Report.Error (1511, loc, "Keyword `base' is not available in a static method");
 			} else {
 				ec.Report.Error (1512, loc, "Keyword `base' is not available in the current context");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="659" endline="669">
<![CDATA[
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, modifiers, callingConvention, gtpb == null ? 0 
 				}
 				return methodSignature;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="58" endline="68">
<![CDATA[
 
 		internal override PropertySignature PropertySignature
 		{
 			get
 			{
 				if (sig == null)
 				{
 					sig = PropertySignature.ReadSig(module, module.GetBlob(module.Property.records[index].Type), declaringType);
 				}
 				return sig;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1369" endline="1381">
<![CDATA[
 		}
 
 		//
 		// Inflated type parameters with constraints array, mapping with type arguments is based on index
 		//
 		public TypeParameterSpec[] Constraints {
 			get {
 				if (constraints == null) {
 					constraints = TypeParameterSpec.InflateConstraints (MemberDefinition.TypeParameters, l => l.CreateLocalInflator (), this);
 				}
 
 				return constraints;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2004" endline="2015">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr != null) {
 				type = expr.Type;
 				eclass = expr.eclass;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="45" endline="56">
<![CDATA[
 		{
 			if (UseNativeFusion)
 			{
 				bool equivalent;
 				Marshal.ThrowExceptionForHR(CompareAssemblyIdentity(assemblyIdentity1, unified1, assemblyIdentity2, unified2, out equivalent, out result));
 				return equivalent;
 			}
 			else
 			{
 				return CompareAssemblyIdentityPure(assemblyIdentity1, unified1, assemblyIdentity2, unified2, out result);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3515" endline="3522">
<![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal [Property] As Mono.Cecil.PropertyReference) As Boolean
         If Caller Is Nothing Then
             Return Helper.IsAccessible(Context, GetPropertyAccess([Property]), [Property].DeclaringType)
         Else
             Return Helper.IsAccessible(Context, GetPropertyAccess([Property]), [Property].DeclaringType, Caller)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="439" endline="478">
<![CDATA[
 
 		private sealed class TrackingGenericContext 
 		{
 			private readonly IGenericContext context;
 			private bool used;
 
 			internal TrackingGenericContext(IGenericContext context)
 			{
 				this.context = context;
 			}
 
 			internal bool IsUsed
 			{
 				get { return used; }
 			}
 
 			public Type GetGenericTypeArgument(int index)
 			{
 				used = true;
 				return context.GetGenericTypeArgument(index);
 			}
 
 			public Type GetGenericMethodArgument(int index)
 			{
 				used = true;
 				return context.GetGenericMethodArgument(index);
 			}
 		}
 
 		public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if ((metadataToken >> 24) == TypeSpecTable.Index)
 			{
 				return ResolveType(metadataToken, new GenericContext(genericTypeArguments, genericMethodArguments));
 			}
 			else
 			{
 				return ResolveType(metadataToken, null);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1827" endline="1838">
<![CDATA[
 
 		protected override string GetSuffix()
 		{
 			if (rank == 1)
 			{
 				return "[*]";
 			}
 			else
 			{
 				return "[" + new String(',', rank - 1) + "]";
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="273" endline="289">
<![CDATA[
 
 		private static Type ReadTypeOrByRef(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.PeekByte() == ELEMENT_TYPE_BYREF)
 			{
 				br.ReadByte();
 				// LAMESPEC it is allowed (by C++/CLI, ilasm and peverify) to have custom modifiers after the BYREF
 				// (which makes sense, as it is analogous to pointers)
 				CustomModifiers mods = ReadCustomModifiers(module, br, context);
 				// C++/CLI generates void& local variables, so we need to use ReadTypeOrVoid here
 				return ReadTypeOrVoid(module, br, context).__MakeByRefType(mods.required, mods.optional);
 			}
 			else
 			{
 				return ReadType(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2774" endline="2784">
<![CDATA[
 		}
 
 		public override void RegisterFieldForInitialization (MemberCore field, FieldInitializer expression)
 		{
 			if ((field.ModFlags & Modifiers.STATIC) == 0) {
 				Report.Error (573, field.Location, "`{0}'
 					field.GetSignatureForError ());
 				return;
 			}
 			base.RegisterFieldForInitialization (field, expression);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
<![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="444" endline="455">
<![CDATA[
 		}
 
 		// 
 		// Returns full member name for error message
 		//
 		public virtual string GetSignatureForError ()
 		{
 			if (Parent == null || Parent.Parent == null)
 				return member_name.GetSignatureForError ();
 
 			return Parent.GetSignatureForError () + "." + member_name.GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="700" endline="710">
<![CDATA[
 
 	//
 	// Null is considered to be a reference type
 	//			
 	public static bool IsReferenceType (TypeSpec t)
 	{
 		if (t.IsGenericParameter)
 			return ((TypeParameterSpec) t).IsReferenceType;
 
 		return !t.IsStruct && !IsEnumType (t);
 	}			
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9507" endline="9516">
<![CDATA[
 
 		protected override IMemoryLocation EmitAddressOf (EmitContext ec, AddressOp Mode)
 		{
 			instance = base.EmitAddressOf (ec, Mode);
 
 			if (!initializers.IsEmpty)
 				initializers.Emit (ec);
 
 			return instance;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="344" endline="352">
<![CDATA[
 		}
 
 		public void AddLocal (int index, string name)
 		{
 			if (_locals == null)
 				_locals = new List<LocalVariableEntry> ();
 			int block_idx = CurrentBlock != null ? CurrentBlock.Index 
 			_locals.Add (new LocalVariableEntry (index, name, block_idx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="532" endline="542">
<![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			if (resolved == null)
 				return;
 			
 			if (resolved != this)
 				resolved.EmitStatement (ec);
 			else
 				base.EmitStatement (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="51" endline="59">
<![CDATA[
 		{
 			Signature = br.ReadUInt32();
 			if (Signature != IMAGE_NT_HEADERS.MAGIC_SIGNATURE)
 			{
 				throw new BadImageFormatException();
 			}
 			FileHeader.Read(br);
 			OptionalHeader.Read(br);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7531" endline="7540">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			string name = Name;
 			if (targs != null) {
 				name = Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return alias + "
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="696" endline="706">
<![CDATA[
 
 		public TypeSpec GetCoClassAttributeValue ()
 		{
 			if (!arg_resolved)
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return GetArgumentType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="520" endline="532">
<![CDATA[
 
 		public MethodToken GetMethodToken(MethodInfo method)
 		{
 			MethodBuilder mb = method as MethodBuilder;
 			if (mb != null && mb.ModuleBuilder == this)
 			{
 				return new MethodToken(mb.MetadataToken);
 			}
 			else
 			{
 				return new MethodToken(ImportMember(method));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="551" endline="562">
<![CDATA[
 
 		public MethodToken GetConstructorToken(ConstructorInfo constructor)
 		{
 			if (constructor.Module == this && constructor.GetMethodInfo() is MethodBuilder)
 			{
 				return new MethodToken(constructor.MetadataToken);
 			}
 			else
 			{
 				return new MethodToken(ImportMember(constructor));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="64" endline="70">
<![CDATA[
 
     Function GetLabel(ByVal Info As EmitInfo) As Label
         If m_LabelBuilder.HasValue = False Then
             m_LabelBuilder = Emitter.DefineLabel(Info)
         End If
         Return m_LabelBuilder.Value
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="420" endline="432">
<![CDATA[
 
     ''' <summary>
     ''' Compares two vb-names (case-insensitive)
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, StringComparison.OrdinalIgnoreCase)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="452" endline="464">
<![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareNameOrdinal(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, System.StringComparison.Ordinal)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="278" endline="284">
<![CDATA[
 
 		internal int Add(Guid guid)
 		{
 			Debug.Assert(!frozen);
 			list.Add(guid);
 			return list.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="283" endline="289">
<![CDATA[
 			set {
 				if (value == XmlCommentState.Allowed) {
 					check_incorrect_doc_comment ();
 					reset_doc_comment ();
 				}
 				xml_doc_state = value;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9235" endline="9242">
<![CDATA[
 	
 		public override void EmitStatement (EmitContext ec)
 		{
 			if (source is CollectionOrObjectInitializers)
 				source.Emit (ec);
 			else
 				base.EmitStatement (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5003" endline="5011">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			return Parameter.ExpressionTreeVariableReference ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="104" endline="115">
<![CDATA[
 
 		public static Expression Create (Expression expr)
 		{
 			//
 			// Avoid unwraping and wraping of same type
 			//
 			Wrap wrap = expr as Wrap;
 			if (wrap != null)
 				return wrap.Child;
 
 			return Create (expr, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="127" endline="135">
<![CDATA[
 
 		public static int DefineNamespace (string name, CompileUnitEntry source,
 						   string[] using_clauses, int parent)
 		{
 			if (symwriter != null)
 				return symwriter.DefineNamespace (name, source, using_clauses, parent);
 			else
 				return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="437" endline="451">
<![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String, ByVal Ordinal As Boolean) As Boolean
         If Ordinal Then
             Return CompareNameOrdinal(Value1, Value2)
         Else
             Return CompareName(Value1, Value2)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="94" endline="102">
<![CDATA[
 
 		public static SourceMethodBuilder OpenMethod (ICompileUnit file, int ns_id,
 							      IMethodDef method)
 		{
 			if (symwriter != null)
 				return symwriter.OpenMethod (file, ns_id, method);
 			else
 				return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="409" endline="415">
<![CDATA[
 
 		public virtual void RemoveTypeContainer (TypeContainer next_part)
 		{
 			if (types != null)
 				types.Remove (next_part);
 			RemoveMemberType (next_part);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="905" endline="912">
<![CDATA[
 
 		protected override string FormatText (string txt)
 		{
 			if (prefix != null)
 				return prefix + txt + postfix;
 
 			return txt;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1654" endline="1662">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1645" endline="1653">
<![CDATA[
 
 		public void Emit (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Ldloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="108" endline="114">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property Keyword() As KS
         Get
             Helper.Assert(m_Keyword = KS.Is OrElse m_Keyword = KS.IsNot)
             Return m_Keyword
         End Get
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6266" endline="6274">
<![CDATA[
 
 Block
 end_block (Location loc)
 {
 	Block retval = current_block.Explicit;
 	retval.SetEndLocation (loc);
 	current_block = retval.Parent;
 	return retval;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="62" endline="71">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As Parameter = Nothing) As ParameterIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterIdentifier(NewParent)
         result.m_Identifier = m_Identifier
         If m_ArrayNameModifier IsNot Nothing Then
             result.m_ArrayNameModifier = m_ArrayNameModifier.clone(result)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="71" endline="79">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameter
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameter(NewParent)
         result.m_Identifier = m_Identifier
         If m_TypeParameterConstraints IsNot Nothing Then result.m_TypeParameterConstraints = m_TypeParameterConstraints.Clone(result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1272" endline="1282">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal method As EventReference) As EventDefinition
         If method Is Nothing Then Return Nothing
         Dim type As TypeDefinition = FindDefinition(method.DeclaringType)
         'method = method.GetOriginalMethod
         'If Helper.CompareNameOrdinal(method.Name, MethodDefinition.Cctor) OrElse Helper.CompareNameOrdinal(method.Name, MethodDefinition.Ctor) Then
         '    Return GetMethod(type.Constructors, method)
         'Else
         Return GetEvent(type.Events, method)
         'End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="348" endline="359">
<![CDATA[
 
     Function DereferenceByRef() As Expression
         Dim result As Expression
 
         If CecilHelper.IsByRef(ExpressionType) Then
             result = New DeRefExpression(Me, Me)
         Else
             result = Me
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="653" endline="664">
<![CDATA[
 		}
 
 		public SourceFileEntry[] IncludeFiles {
 			get {
 				ReadData ();
 				if (include_files == null)
 					return new SourceFileEntry [0];
 
 				SourceFileEntry[] retval = new SourceFileEntry [include_files.Count];
 				include_files.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="538" endline="549">
<![CDATA[
 
 		public Assembly LoadAssembly(RawModule module)
 		{
 			string refname = module.GetAssemblyName().FullName;
 			Assembly asm = GetLoadedAssembly(refname);
 			if (asm == null)
 			{
 				asm = module.ToAssembly();
 				assemblies.Add(asm);
 			}
 			return asm;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="978" endline="986">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			Attribute a = obj as Attribute;
 			if (a == null)
 				return false;
 
 			return Type == a.Type && Target == a.Target;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="636" endline="650">
<![CDATA[
 
 		private int ImportAssemblyRef(Assembly asm)
 		{
 			int token;
 			if (!referencedAssemblies.TryGetValue(asm, out token))
 			{
 				// We can't write the AssemblyRef record here yet, because the identity of the assembly can still change
 				// (if it's an AssemblyBuilder).
 				// We set the high bit of rid in the token to make sure we emit obviously broken metadata,
 				// if we forget to patch up the token somewhere.
 				token = 0x23800001 + referencedAssemblies.Count;
 				referencedAssemblies.Add(asm, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="39" endline="45">
<![CDATA[
         Get
             If m_First IsNot Nothing Then
                 Return m_First.AsString & "." & m_Second.Identifier
             Else
                 Return "." & m_Second.Identifier
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="253" endline="264">
<![CDATA[
 		}
 
 		public byte[] ResolveSignature(int metadataToken)
 		{
 			ModuleReader rdr = this as ModuleReader;
 			if (rdr != null)
 			{
 				ByteReader br = rdr.ResolveSignature(metadataToken);
 				return br.ReadBytes(br.Length);
 			}
 			throw new NotSupportedException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="389" endline="396">
<![CDATA[
 
     Private Function IsPropertyHandlesHandler() As Boolean
         Dim propD As PropertyDeclaration
 
         propD = TryCast(Parent, PropertyDeclaration)
         If propD Is Nothing Then Return False
         Return propD.HandlesField IsNot Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="505" endline="519">
<![CDATA[
 
 
     '
     'Emittable
     ' - 1Declarations/GenericProperty1 shows one case where vbnc and cecil/cil wants different things (method return type shouldn't be inflated for cecil/cil)
     '
     '
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodReference, ByVal Type As TypeReference, Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim mD As MethodDefinition = TryCast(Member, MethodDefinition)
 
         If mD IsNot Nothing Then Return GetCorrectMember(mD, Type, Emittable)
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="335" endline="342">
<![CDATA[
 
 		void AddSourceFile (string f)
 		{
 			if (first_source == null)
 				first_source = f;
 
 			Location.AddFile (Report, f);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="255" endline="261">
<![CDATA[
 		}
 
 		internal override MethodBase BindTypeParameters(Type type)
 		{
 			System.Diagnostics.Debug.Assert(methodArgs == null);
 			return new GenericMethodInstance(declaringType.BindTypeParameters(type), method, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="299" endline="310">
<![CDATA[
 		}
 
 		// .NET 4.0 API
 		public virtual Type GetEnumUnderlyingType()
 		{
 			if (!this.IsEnum)
 			{
 				throw new ArgumentException();
 			}
 			CheckBaked();
 			return GetEnumUnderlyingTypeImpl();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="134" endline="141">
<![CDATA[
 
 		internal void FixupToken(int parameterToken)
 		{
 			if (lazyPseudoToken != 0)
 			{
 				moduleBuilder.RegisterTokenFixup(lazyPseudoToken, parameterToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="1204" endline="1216">
<![CDATA[
 
 		public void AddTypeContainer (TypeContainer current_container, TypeContainer tc)
 		{
 			if (current_container == tc){
 				Console.Error.WriteLine ("Internal error
 				return;
 			}
 
 			if (undo_types == null)
 				undo_types = new List<KeyValuePair<TypeContainer, TypeContainer>> ();
 
 			undo_types.Add (new KeyValuePair<TypeContainer, TypeContainer> (current_container, tc));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="896" endline="906">
<![CDATA[
 		}
 
 		public override bool CheckRethrow (Location loc)
 		{
 			if (!Parent.CheckRethrow (loc))
 				return false;
 			if (finally_vector == null)
 				return true;
 			Report.Error (724, loc, "A throw statement with no arguments is not allowed inside of a finally clause nested inside of the innermost catch clause");
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6096" endline="6107">
<![CDATA[
 
 [System.Diagnostics.Conditional ("FULL_AST")]
 void StoreModifierLocation (object token, Location loc)
 {
 	if (lbag == null)
 		return;
 
 	if (mod_locations == null)
   		mod_locations = new List<Tuple<Modifiers, Location>> ();
 
 	mod_locations.Add (Tuple.Create ((Modifiers) token, loc));
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="44" endline="54">
<![CDATA[
 		{
 			if (attrs == null)
 				return;
 
 			if (attributes == null)
 				attributes = attrs;
 			else
 				throw new NotImplementedException ();
 
 			attributes.AttachTo (this, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="221" endline="231">
<![CDATA[
 
 		internal void DefineAnonymousScope (int id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			if (anonymous_scopes == null)
 				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>  ();
 
 			anonymous_scopes.Add (id, new AnonymousScopeEntry (id));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="396" endline="410">
<![CDATA[
 
 		private PropertyBuilder DefinePropertyImpl(string name, PropertyAttributes attributes, CallingConventions callingConvention, bool patchCallingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			if (properties == null)
 			{
 				properties = new List<PropertyBuilder>();
 			}
 			PropertySignature sig = PropertySignature.Create(callingConvention, returnType, returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers,
 				parameterTypes, parameterTypeOptionalCustomModifiers, parameterTypeRequiredCustomModifiers);
 			PropertyBuilder pb = new PropertyBuilder(this, name, attributes, sig, patchCallingConvention);
 			properties.Add(pb);
 			return pb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="205" endline="220">
<![CDATA[
 
 		public MethodEntry DefineMethod (CompileUnitEntry comp_unit, int token,
 						 ScopeVariable[] scope_vars, LocalVariableEntry[] locals,
 						 LineNumberEntry[] lines, CodeBlockEntry[] code_blocks,
 						 string real_name, MethodEntry.Flags flags,
 						 int namespace_id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			MethodEntry method = new MethodEntry (
 				this, comp_unit, token, scope_vars, locals, lines, code_blocks, 
 				real_name, flags, namespace_id);
 			AddMethod (method);
 			return method;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="814" endline="821">
<![CDATA[
 
 		void SetCustomAttribute (MethodSpec ctor, byte[] data)
 		{
 			if (module_target_attrs != null)
 				module_target_attrs.AddAssemblyAttribute (ctor, data);
 			else
 				Builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), data);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1867" endline="1879">
<![CDATA[
 
 		public virtual void Error_AlreadyDeclared (string name, INamedBlockVariable variable, string reason)
 		{
 			if (reason == null) {
 				Error_AlreadyDeclared (name, variable);
 				return;
 			}
 
 			ParametersBlock.TopBlock.Report.Error (136, variable.Location,
 				"A local variable named `{0}' cannot be declared in this scope because it would give a different meaning " +
 				"to `{0}', which is already used in a `{1}' scope to denote something else",
 				name, reason);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="239" endline="251">
<![CDATA[
 		}
 
 		private void WriteRVA(MetadataWriter mw, uint rva)
 		{
 			if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 			{
 				mw.Write(rva);
 			}
 			else
 			{
 				mw.Write((ulong)rva);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1243" endline="1254">
<![CDATA[
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			EventBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="148" endline="158">
<![CDATA[
 
 		public void __SetAssemblyKeyPair(StrongNameKeyPair keyPair)
 		{
 			AssemblyName oldName = GetName();
 			this.keyPair = keyPair;
 			if (keyPair != null)
 			{
 				this.publicKey = keyPair.PublicKey;
 			}
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1559" endline="1567">
<![CDATA[
 
 			set {
 				// Only copy the vector if we're actually modifying it.
 				if (this [index] != value) {
 					if (vector == null)
 						initialize_vector ();
 					vector [index] = value;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="351" endline="362">
<![CDATA[
 		}
 
 		public void Error (int code, Location loc, string error)
 		{
 			if (reporting_disabled > 0)
 				return;
 
 			ErrorMessage msg = new ErrorMessage (code, loc, error, extra_information);
 			extra_information.Clear ();
 
 			printer.Print (msg);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="233" endline="255">
<![CDATA[
 	}
 
 	/// <summary>
 	///   An exception used to terminate the compiler resolution phase and provide completions
 	/// </summary>
 	/// <remarks>
 	///   This is thrown when we want to return the completions or
 	///   terminate the completion process by AST nodes used in
 	///   the completion process.
 	/// </remarks>
 	public class CompletionResult 
 		string [] result;
 		string base_text;
 		
 		public CompletionResult (string base_text, string [] res)
 		{
 			if (base_text == null)
 				throw new ArgumentNullException ("base_text");
 			this.base_text = base_text;
 
 			result = res;
 			Array.Sort (result);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8834" endline="8905">
<![CDATA[
 
 		public readonly int Dimension;
 		public readonly Location Location;
 
 		public ComposedTypeSpecifier (int specifier, Location loc)
 		{
 			this.Dimension = specifier;
 			this.Location = loc;
 		}
 
 		#region Properties
 		public bool IsNullable {
 			get {
 				return Dimension == -1;
 			}
 		}
 
 		public bool IsPointer {
 			get {
 				return Dimension == -2;
 			}
 		}
 
 		public ComposedTypeSpecifier Next { get; set; }
 
 		#endregion
 
 		public static ComposedTypeSpecifier CreateArrayDimension (int dimension, Location loc)
 		{
 			return new ComposedTypeSpecifier (dimension, loc);
 		}
 
 		public static ComposedTypeSpecifier CreateNullable (Location loc)
 		{
 			return new ComposedTypeSpecifier (-1, loc);
 		}
 
 		public static ComposedTypeSpecifier CreatePointer (Location loc)
 		{
 			return new ComposedTypeSpecifier (-2, loc);
 		}
 
 		public string GetSignatureForError ()
 		{
 			string s =
 				IsPointer ? "*" 
 				IsNullable ? "?" 
 				ArrayContainer.GetPostfixSignature (Dimension);
 
 			return Next != null ? s + Next.GetSignatureForError () 
 		}
 	}
 
 	// <summary>
 	//   This class is used to "construct" the type during a typecast
 	//   operation.  Since the Type.GetType class in .NET can parse
 	//   the type specification, we just use this to construct the type
 	//   one bit at a time.
 	// </summary>
 	public class ComposedCast 
 		FullNamedExpression left;
 		ComposedTypeSpecifier spec;
 		
 		public ComposedCast (FullNamedExpression left, ComposedTypeSpecifier spec)
 		{
 			if (spec == null)
 				throw new ArgumentNullException ("spec");
 
 			this.left = left;
 			this.spec = spec;
 			this.loc = spec.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="794" endline="802">
<![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, true);
 			else
 				base.EmitStatement (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="785" endline="793">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, false);
 			else
 				base.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="277" endline="284">
<![CDATA[
 
 		public void Emit (OpCode opcode, FieldSpec field)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				field = field.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 			ig.Emit (opcode, field.GetMetaInfo ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="269" endline="276">
<![CDATA[
 
 		public void Emit (OpCode opcode, TypeSpec type)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				type = CurrentAnonymousMethod.Storey.Mutator.Mutate (type);
 
 			ig.Emit (opcode, type.GetMetaInfo ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="51" endline="57">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
         If Arguments IsNot Nothing Then
             m_Arguments.AddRange(Arguments)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="85" endline="95">
<![CDATA[
 		public BlockContext (IMemberContext mc, ExplicitBlock block, TypeSpec returnType)
 			
 		{
 			if (returnType == null)
 				throw new ArgumentNullException ("returnType");
 
 			this.return_type = returnType;
 
 			// TODO
 			CurrentBlock = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="187" endline="196">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// TODO
 			base.Emit (ec);
 
 			// Release temporary variable when used
 			if (variable != null)
 				variable.Release (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="526" endline="533">
<![CDATA[
 
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			if (Oper == Operator.LogicalNot)
 				Expr.EmitBranchable (ec, target, !on_true);
 			else
 				base.EmitBranchable (ec, target, on_true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="281" endline="290">
<![CDATA[
 
 		public void AddMember (InterfaceMemberBase imb, string exlicitName, MemberSpec ms)
 		{
 			// Explicit names cannot be looked-up but can be used for
 			// collision checking (no name mangling needed)
 			if (imb.IsExplicitImpl)
 				AddMember (exlicitName, ms);
 			else
 				AddMember (ms);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="46" endline="52">
<![CDATA[
 
     Sub AddInheritsClause(ByVal Clause As NonArrayTypeName)
         If m_InheritsClauses Is Nothing Then
             m_InheritsClauses = New Generic.List(Of NonArrayTypeName)
         End If
         m_InheritsClauses.Add(Clause)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1928" endline="1936">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// cast to object
 			if (type != targetType)
 				enc.Encode (type);
 
 			enc.Encode (Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5095" endline="5106">
<![CDATA[
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5040" endline="5048">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			SetAssigned (ec);
 			return base.DoResolveLValue (ec, right_side);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="62" endline="68">
<![CDATA[
 
 		internal byte ReadByte()
 		{
 			if (pos == end)
 				throw new BadImageFormatException();
 			return buffer[pos++];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="531" endline="539">
<![CDATA[
 
 		[Conditional ("FULL_AST")]
 		public void AddStatement (object element, params Location[] locations)
 		{
 			if (locations.Length == 0)
 				throw new ArgumentException ("Statement is missing semicolon location");
 
 			simple_locs.Add (element, locations);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="387" endline="394">
<![CDATA[
 
 		public void UsingNamespace(string usingNamespace)
 		{
 			if (moduleBuilder.symbolWriter != null)
 			{
 				moduleBuilder.symbolWriter.UsingNamespace(usingNamespace);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="62" endline="75">
<![CDATA[
 		}
 
 		protected abstract void WriteImpl(MetadataWriter mw);
 	}
 
 	abstract class SimpleHeap 
 	{
 		internal void Freeze()
 		{
 			if (frozen)
 				throw new InvalidOperationException();
 			frozen = true;
 			unalignedlength = GetLength();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="531" endline="540">
<![CDATA[
 
 		public Block LookupBlock (Block from)
 		{
 			Block result;
 			if (!block_map.TryGetValue (from, out result)) {
 				result = (Block) from.Clone (this);
 			}
 
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2012" endline="2020">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldnull);
 
 			// Only to make verifier happy
 			if (TypeManager.IsGenericParameter (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="286" endline="297">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Call StartResolve to enable check for recursive resolving.
     ''' Call EndResolve when finished resolving.
     ''' </summary>
     ''' <remarks></remarks>
     Protected Sub EndResolve(ByVal result As Boolean)
         If Not m_Resolving Then Throw New InternalException(Me)
         m_Resolving = False
         m_Resolved = result
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="46" endline="53">
<![CDATA[
 
 		public Argument (Expression expr)
 		{
 			if (expr == null)
 				throw new ArgumentNullException ();
 
 			this.Expr = expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="660" endline="670">
<![CDATA[
 
 	public static bool IsBuiltinOrEnum (TypeSpec t)
 	{
 		if (IsBuiltinType (t))
 			return true;
 		
 		if (IsEnumType (t))
 			return true;
 
 		return false;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2210" endline="2219">
<![CDATA[
 
 		bool eval_val (string s)
 		{
 			if (s == "true")
 				return true;
 			if (s == "false")
 				return false;
 
 			return file_name.IsConditionalDefined (s);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="747" endline="762">
<![CDATA[
 
 	//
 	// Checks whether `type' is a subclass or nested child of `base_type'.
 	//
 	public static bool IsNestedFamilyAccessible (TypeSpec type, TypeSpec base_type)
 	{
 		do {
 			if (IsFamilyAccessible (type, base_type))
 				return true;
 
 			// Handle nested types.
 			type = type.DeclaringType;
 		} while (type != null);
 
 		return false;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="134" endline="149">
<![CDATA[
 
 		internal static int GetCompressedIntLength(int value)
 		{
 			if (value <= 0x7F)
 			{
 				return 1;
 			}
 			else if (value <= 0x3FFF)
 			{
 				return 2;
 			}
 			else
 			{
 				return 4;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7356" endline="7364">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = ec.Module.PredefinedTypes.FieldInfo.Resolve (loc);
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="779" endline="788">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="539" endline="550">
<![CDATA[
 
     ''' <summary>
     ''' This function returns the members list in the cache, or nothing
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattenedMembers(ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim cache As MemberCacheEntry = LookupFlattened(Name)
         If cache Is Nothing Then Return Nothing
         Return cache.Members
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2643" endline="2652">
<![CDATA[
 
 		private int consume_identifier (int s)
 		{
 			int res = consume_identifier (s, false);
 
 			if (doc_state == XmlCommentState.Allowed)
 				doc_state = XmlCommentState.NotAllowed;
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1138" endline="1145">
<![CDATA[
 
 		public bool GetBoolean () 
 		{
 			Expression e = GetValue ();
 			if (e is BoolConstant)
 				return ((BoolConstant)e).Value;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1127" endline="1135">
<![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddContinueOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1100" endline="1108">
<![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddBreakOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="677" endline="821">
<![CDATA[
 	}
 
 	// A 'return' or a 'yield break'
 	public abstract class ExitStatement 
 	{
 		protected bool unwind_protect;
 		protected abstract bool DoResolve (BlockContext ec);
 
 		public virtual void Error_FinallyClause (Report Report)
 		{
 			Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 		}
 
 		public sealed override bool Resolve (BlockContext ec)
 		{
 			if (!DoResolve (ec))
 				return false;
 
 			unwind_protect = ec.CurrentBranching.AddReturnOrigin (ec.CurrentBranching.CurrentUsageVector, this);
 			if (unwind_protect)
 				ec.NeedReturnLabel ();
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
 	}
 
 	/// <summary>
 	///   Implements the return statement
 	/// </summary>
 	public class Return 
 	{
 		protected Expression Expr;
 		public Return (Expression expr, Location l)
 		{
 			Expr = expr;
 			loc = l;
 		}
 
 		#region Properties
 		public Expression Expression {
 			get {
 				return Expr;
 			}
 		}
 		#endregion
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			if (Expr == null) {
 				if (ec.ReturnType == TypeManager.void_type)
 					return true;
 
 				if (ec.CurrentIterator != null) {
 					Error_ReturnFromIterator (ec);
 				} else {
 					ec.Report.Error (126, loc,
 						"An object of a type convertible to `{0}' is required for the return statement",
 						ec.ReturnType.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			Expr = Expr.Resolve (ec);
 
 			AnonymousExpression am = ec.CurrentAnonymousMethod;
 			if (am == null) {
 				if (ec.ReturnType == TypeManager.void_type) {
 					ec.Report.Error (127, loc,
 						"`{0}'
 						ec.GetSignatureForError ());
 				}
 			} else {
 				if (am.IsIterator) {
 					Error_ReturnFromIterator (ec);
 					return false;
 				}
 
 				var l = am as AnonymousMethodBody;
 				if (l != null && l.ReturnTypeInference != null && Expr != null) {
 					l.ReturnTypeInference.AddCommonTypeBound (Expr.Type);
 					return true;
 				}
 			}
 
 			if (Expr == null)
 				return false;
 
 			if (Expr.Type != ec.ReturnType) {
 				Expr = Convert.ImplicitConversionRequired (ec, Expr, ec.ReturnType, loc);
 
 				if (Expr == null) {
 					if (am != null) {
 						ec.Report.Error (1662, loc,
 							"Cannot convert `{0}' to delegate type `{1}' because some of the return types in the block are not implicitly convertible to the delegate return type",
 							am.ContainerType, am.GetSignatureForError ());
 					}
 					return false;
 				}
 			}
 
 			return true;			
 		}
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (Expr != null) {
 				Expr.Emit (ec);
 
 				if (unwind_protect)
 					ec.Emit (OpCodes.Stloc, ec.TemporaryReturn ());
 			}
 
 			if (unwind_protect)
 				ec.Emit (OpCodes.Leave, ec.ReturnLabel);
 			else
 				ec.Emit (OpCodes.Ret);
 		}
 
 		void Error_ReturnFromIterator (ResolveContext rc)
 		{
 			rc.Report.Error (1622, loc,
 				"Cannot return a value from iterators. Use the yield return statement to return a value, or yield break to end the iteration");
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Return target = (Return) t;
 			// It's null for simple return;
 			if (Expr != null)
 				target.Expr = Expr.Clone (clonectx);
 		}
 	}
 
 	public class Goto 
 		string target;
 		LabeledStatement label;
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddGotoOrigin (ec.CurrentBranching.CurrentUsageVector, this);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="747" endline="756">
<![CDATA[
 		}
 
 		public TypeSpec ExtensionMethodType {
 			get {
 				if (Count == 0)
 					return null;
 
 				return FixedParameters [0].HasExtensionMethodModifier ?
 					types [0] 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="63" endline="77">
<![CDATA[
 		}
 
 		public Parameter.Modifier Modifier {
 			get {
 				switch (ArgType) {
 				case AType.Out
 					return Parameter.Modifier.OUT;
 
 				case AType.Ref
 					return Parameter.Modifier.REF;
 
 				default
 					return Parameter.Modifier.NONE;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="801" endline="808">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Return target = (Return) t;
 			// It's null for simple return;
 			if (Expr != null)
 				target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1084" endline="1091">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Throw target = (Throw) t;
 
 			if (expr != null)
 				target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7074" endline="7081">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Arglist target = (Arglist) t;
 
 			if (Arguments != null)
 				target.Arguments = Arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="357" endline="364">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (Value)
 				ec.Emit (OpCodes.Ldc_I4_1);
 			else
 				ec.Emit (OpCodes.Ldc_I4_0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8547" endline="8554">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			IndexerExpr target = (IndexerExpr) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9303" endline="9309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CollectionElementInitializer target = (CollectionElementInitializer) t;
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="365" endline="372">
<![CDATA[
 
 		public void CreateSymbolFile (Guid guid, FileStream fs)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			Write (new MyBinaryWriter (fs), guid);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="803" endline="810">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (!prepared)
 				expr.Emit (ec);
 			
 			ec.EmitLoadFromPtr (Type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="219" endline="227">
<![CDATA[
 		}
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			if (leave_copy)
 				Load (ec);
 
 			Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="35" endline="41">
<![CDATA[
 		}
 
 		public void RegisterNamespace (Namespace child)
 		{
 			if (child != this)
 				all_namespaces.Add (child.Name, child);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="451" endline="458">
<![CDATA[
 
 		public void SetMetaInfo (MethodInfo info)
 		{
 			if (this.metaInfo != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.metaInfo = info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="435" endline="442">
<![CDATA[
 
 		public void SetMetaInfo (MetaType info)
 		{
 			if (this.info != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.info = info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="101" endline="107">
<![CDATA[
     End Property
 
     Sub Write(ByVal Level As ReportLevels, Optional ByVal Value As String = "")
         If Level <= m_ReportLevel Then
             Write(Value)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="228" endline="237">
<![CDATA[
 
 		#region IAssignMethod Members
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Emit (ec);
 
 			if (leave_copy)
 				Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1841" endline="1847">
<![CDATA[
 		}
 
 		public void EmitAttribute (ConstructorBuilder builder)
 		{
 			if (ResolveBuilder ())
 				builder.SetCustomAttribute (GetCtorMetaInfo (), AttributeEncoder.Empty);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\rootcontext.cs" startline="242" endline="248">
<![CDATA[
 
 		public static void AddConditional (string p)
 		{
 			if (AllDefines.Contains (p))
 				return;
 			AllDefines.Add (p);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="574" endline="584">
<![CDATA[
 
 		internal int ImportMember(FieldInfo member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="563" endline="573">
<![CDATA[
 
 		internal int ImportMember(MethodBase member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="66" endline="78">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructor() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="79" endline="91">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructorCecil() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="39" endline="50">
<![CDATA[
 
 		public static bool CheckContext (ResolveContext ec, Location loc)
 		{
 			if (!ec.CurrentAnonymousMethod.IsIterator) {
 				ec.Report.Error (1621, loc,
 					      "The yield statement cannot be used inside " +
 					      "anonymous method blocks");
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="182" endline="195">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddEnumMember (EnumMember em)
 		{
 			if (em.Name == UnderlyingValueField) {
 				Report.Error (76, em.Location, "An item in an enumeration cannot have an identifier `{0}'",
 					UnderlyingValueField);
 				return;
 			}
 
 			AddConstant (em);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="287" endline="298">
<![CDATA[
 
 		internal void WriteParam(int index)
 		{
 			if (bigParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="275" endline="286">
<![CDATA[
 
 		internal void WriteMethodDef(int index)
 		{
 			if (bigMethodDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="263" endline="274">
<![CDATA[
 
 		internal void WriteField(int index)
 		{
 			if (bigField)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="347" endline="358">
<![CDATA[
 
 		internal void WriteModuleRef(int index)
 		{
 			if (bigModuleRef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="550" endline="563">
<![CDATA[
 
 		internal void WriteHasFieldMarshal(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasFieldMarshal)
 			{
 				Write(encodedToken & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="335" endline="346">
<![CDATA[
 
 		internal void WriteGenericParam(int index)
 		{
 			if (bigGenericParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="299" endline="310">
<![CDATA[
 
 		internal void WriteTypeDef(int index)
 		{
 			if (bigTypeDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="323" endline="334">
<![CDATA[
 
 		internal void WriteProperty(int index)
 		{
 			if (bigProperty)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="311" endline="322">
<![CDATA[
 
 		internal void WriteEvent(int index)
 		{
 			if (bigEvent)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="200" endline="208">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			IMemoryLocation ml = expr as VariableReference;
 			if (ml != null)
 				ml.AddressOf (ec, mode);
 			else
 				LocalVariable.AddressOf (ec, mode);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4554" endline="4562">
<![CDATA[
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="150" endline="161">
<![CDATA[
 
 		internal void WriteStringIndex(int index)
 		{
 			if (bigStrings)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="513" endline="526">
<![CDATA[
 
 		internal void WriteHasDeclSecurity(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasDeclSecurity)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="499" endline="512">
<![CDATA[
 
 		internal void WriteTypeOrMethodDef(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigTypeOrMethodDef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="162" endline="173">
<![CDATA[
 
 		internal void WriteGuidIndex(int index)
 		{
 			if (bigGuids)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="457" endline="470">
<![CDATA[
 
 		internal void WriteHasSemantics(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasSemantics)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="174" endline="185">
<![CDATA[
 
 		internal void WriteBlobIndex(int index)
 		{
 			if (bigBlobs)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="214" endline="225">
<![CDATA[
 
 		internal void WriteEncodedTypeDefOrRef(int encodedToken)
 		{
 			if (bigTypeDefOrRef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="226" endline="239">
<![CDATA[
 
 		internal void WriteHasCustomAttribute(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasCustomAttribute)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="174" endline="186">
<![CDATA[
 		}
 
 		void Store (EmitContext ec)
 		{
 			if (expr is VariableReference)
 				return;
 
 			if (temp != null)
 				return;
 
 			expr.Emit (ec);
 			LocalVariable.Store (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6012" endline="6018">
<![CDATA[
 {
 	if (expr is Invocation){
 		Report.Error (1002, expr.Location, "Expecting `;'");
 	} else {
 		Expression.Error_InvalidExpressionStatement (Report, expr.Location);
 	}
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="109" endline="118">
<![CDATA[
 
 		public static int OpenScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				return symwriter.OpenScope (offset);
 			} else {
 				return -1;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7213" endline="7219">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			TypeOf target = (TypeOf) t;
 			if (QueriedType != null)
 				target.QueriedType = (FullNamedExpression) QueriedType.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="37" endline="43">
<![CDATA[
         Get
             If TypeOf m_Value.LiteralValue Is String Then
                 Return """" & m_Value.LiteralValue.ToString & """"
             Else
                 Return m_Value.LiteralValue.ToString()
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="306" endline="312">
<![CDATA[
 
     Shared Function FindAssembly(ByVal member As Mono.Cecil.MemberReference) As Mono.Cecil.AssemblyDefinition
         Helper.Assert(member IsNot Nothing)
         Dim type As Mono.Cecil.TypeReference = TryCast(member, Mono.Cecil.TypeReference)
         If type IsNot Nothing Then Return FindAssembly(type)
         Return FindAssembly(member.DeclaringType)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="391" endline="401">
<![CDATA[
 
     Shared Function IsKeyword(ByVal str As Char(), ByVal length As Integer, ByRef Keyword As KS) As Boolean
         Dim special As KS
         special = Enums.GetKS(str, length)
         If special <> KS.None Then
             Keyword = special
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="473" endline="489">
<![CDATA[
 
     ''' <summary>
     ''' Intrinsic type
     ''' </summary>
     ''' <param name="Compiler"></param>
     ''' <param name="Type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsIntrinsicType(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Dim tC As TypeCode = GetTypeCode(Compiler, Type)
 
         If tC = TypeCode.Object Then
             Return Helper.CompareType(Type, Compiler.TypeCache.System_Object)
         Else
             Return True
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="63" endline="81">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the specified child of the namespace.
     ''' Returns nothing if nothing is found.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Child"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Overloads ReadOnly Property Item(ByVal Parent As [Namespace], ByVal Child As String) As [Namespace]
         Get
             Dim name As String = Parent.Name & "." & Child
             If ContainsKey(name) Then
                 Return Item(name)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="74" endline="82">
<![CDATA[
     End Property
 
     Private Overloads Shared Function ToString(ByVal obj As Object) As String
         If obj Is Nothing Then
             Return "Nothing"
         Else
             Return "Type
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="394" endline="409">
<![CDATA[
 
     ''' <summary>
     ''' Returns all the types within the specified namespace.
     ''' Never returns nothing and never throws an exception.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetTypesByNamespace(ByVal [Namespace] As String) As TypeDictionary
         If [Namespace] Is Nothing Then [Namespace] = ""
         If m_CecilTypesByNamespace.ContainsKey([Namespace]) Then
             Return m_CecilTypesByNamespace([Namespace])
         Else
             Return New TypeDictionary()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="132" endline="140">
<![CDATA[
 
     Shared Function RemoveGlobal(ByVal ns As String) As String
         If IsGlobal(ns) Then
             Return ns.Substring(7)
         Else
             Helper.Assert(ns.StartsWith("Global.", Helper.StringComparison) = False)
             Return ns
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1130" endline="1137">
<![CDATA[
 
 		public string GetString () 
 		{
 			Expression e = GetValue ();
 			if (e is StringConstant)
 				return ((StringConstant)e).Value;
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="405" endline="413">
<![CDATA[
 
     Function AcceptEndOfFile() As Boolean
         If CurrentToken.IsEndOfFile Then
             NextToken()
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="66" endline="73">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As LiteralTypeCharacters_Characters) As String
         If chr = LiteralTypeCharacters_Characters.None Then
             Return ""
         Else
             Return m_Characters(chr - 1)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="68" endline="77">
<![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             If Me.IsAliasClause Then
                 Return Me.AsAliasClause.Name
             Else
                 Return ""
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2143" endline="2149">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			Constant new_value = value.ConvertExplicitly (in_checked_context, target_type);
 			return new_value == null ? null 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="47" endline="62">
<![CDATA[
 
     ''' <summary>
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal [Namespace] As String) As TypeDictionary
         Get
             If MyBase.ContainsKey([Namespace]) Then
                 Return MyBase.Item([Namespace])
             Else
                 Return TypeDictionary.EmptyDictionary
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="56" endline="71">
<![CDATA[
 
     ''' <summary>
     ''' Returns nothing if the specified key is not found.
     ''' </summary>
     ''' <param name="key"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal key As String) As Mono.Cecil.TypeReference
         Get
             If MyBase.ContainsKey(key) Then
                 Return MyBase.Item(key)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="78" endline="85">
<![CDATA[
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2117" endline="2124">
<![CDATA[
 
 		public override string AssemblyQualifiedName
 		{
 			get
 			{
 				string fn = FullName;
 				return fn == null ? null 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="118" endline="127">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If Me.IsConstant Then 'Necessary, since the property loads the constant value if it is a constant.
                 Return m_ConstantValue
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="106" endline="114">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             If MyBase.IsResolved Then
                 Return m_ExpressionType
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="148" endline="154">
<![CDATA[
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4740" endline="4748">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool VerifyAssigned (ResolveContext ec)
 		{
 			VariableInfo variable_info = local_info.VariableInfo;
 			return variable_info == null || variable_info.IsAssigned (ec, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="541" endline="552">
<![CDATA[
 
 		///
 		/// Remaps block to cloned copy if one exists.
 		///
 		public Block RemapBlockCopy (Block from)
 		{
 			Block mapped_to;
 			if (!block_map.TryGetValue (from, out mapped_to))
 				return from;
 
 			return mapped_to;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="148" endline="160">
<![CDATA[
 		}
 
 		public string FullName
 		{
 			get
 			{
 				string str = name.FullName;
 				if (culture != null)
 				{
 					str = str.Replace("Culture=neutral", "Culture=" + culture);
 				}
 				return str;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="52" endline="61">
<![CDATA[
 
 		public override string ToString()
 		{
 			string str = name.ToString();
 			if (culture != null)
 			{
 				str = str.Replace("Culture=neutral", "Culture=" + culture);
 			}
 			return str;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4745" endline="4754">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Catch target = (Catch) t;
 
 			if (type_expr != null)
 				target.type_expr = (FullNamedExpression) type_expr.Clone (clonectx);
 
 			target.block = clonectx.LookupBlock (block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4802" endline="4810">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			TryFinally target = (TryFinally) t;
 
 			target.stmt = (Statement) stmt.Clone (clonectx);
 			if (fini != null)
 				target.fini = clonectx.LookupBlock (fini);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8148" endline="8156">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			ElementAccess target = (ElementAccess) t;
 
 			target.Expr = Expr.Clone (clonectx);
 			if (Arguments != null)
 				target.Arguments = Arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2306" endline="2317">
<![CDATA[
 
 		protected override bool DoDefineMembers ()
 		{
 			CheckProtectedModifier ();
 
 			base.DoDefineMembers ();
 
 			if (default_static_constructor != null)
 				default_static_constructor.Define ();
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="155" endline="164">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompletionMemberAccess target = (CompletionMemberAccess) t;
 
 			if (targs != null)
 				target.targs = targs.Clone ();
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="82" endline="89">
<![CDATA[
 
     Shared Operator &(ByVal str As String, ByVal ns As [Namespace]) As [Namespace]
         If ns.Global Then
             Throw New InternalException("")
         Else
             Return New [Namespace](ns.Parent, str & "." & ns.ToString, False)
         End If
     End Operator
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="50" endline="57">
<![CDATA[
 
     Shared Function GetBuiltInType(ByVal chr As LiteralTypeCharacters_Characters) As BuiltInDataTypes
         If chr = LiteralTypeCharacters_Characters.None Then
             Throw New InternalException("")
         Else
             Return m_Types(chr - 1)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="167" endline="179">
<![CDATA[
 
 		// <summary>
 		//   Ends a code branching.  Merges the state of locals and parameters
 		//   from all the children of the ending branching.
 		// </summary>
 		public bool EndFlowBranching ()
 		{
 			FlowBranching old = current_flow_branching;
 			current_flow_branching = current_flow_branching.Parent;
 
 			FlowBranching.UsageVector vector = current_flow_branching.MergeChild (old);
 			return vector.IsUnreachable;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6067" endline="6076">
<![CDATA[
 
 DeclSpace pop_current_class ()
 {
 	DeclSpace retval = current_class;
 
 	current_class = current_class.Parent;
 	current_container = current_class.PartialContainer;
 
 	return retval;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="257" endline="263">
<![CDATA[
 		}
 
 		Expression IParameterData.DefaultValue {
 			get {
 				var expr = default_expr as DefaultParameterValueExpression;
 				return expr == null ? default_expr 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5093" endline="5099">
<![CDATA[
 
 		#region Properties
 
 		public Expression Expression {
 			get {
 				return decl.Variable == null ? decl.Initializer 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="755" endline="764">
<![CDATA[
 		}
 
 		public void SetAutoGenerated ()
 		{
 			if (!creating)
 				throw new InvalidOperationException ();
 
 			auto_generated = true;
 			file.OffsetTable.FileFlags |= OffsetTable.Flags.IsAspxSource;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="76" endline="88">
<![CDATA[
 
 		protected abstract int GetLength();
 	}
 
 	sealed class TableHeap 
 	{
 		internal void Freeze(MetadataWriter mw)
 		{
 			if (frozen)
 				throw new InvalidOperationException();
 			frozen = true;
 			unalignedlength = GetLength(mw);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="52" endline="61">
<![CDATA[
 		}
 
 		internal int Length
 		{
 			get
 			{
 				if (!frozen)
 					throw new InvalidOperationException();
 				return (unalignedlength + 3) & ~3;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1617" endline="1623">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var spec = (IndexerSpec) base.InflateMember (inflator);
 			spec.parameters = parameters.Inflate (inflator);
 			return spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="975" endline="982">
<![CDATA[
 
 		internal override void CheckBaked()
 		{
 			if ((typeFlags & TypeFlags.Baked) == 0)
 			{
 				throw new NotSupportedException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="285" endline="295">
<![CDATA[
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="87" endline="93">
<![CDATA[
 
     Shared Function EmitBeginExceptionBlock(ByVal Info As EmitInfo) As Label
         Helper.Assert(Info.InExceptionFilter = False)
         Dim result As Label
         result = Info.ILGen.BeginExceptionBlock
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="274" endline="283">
<![CDATA[
 
     Public Function DeclareLocal(ByVal localType As Mono.Cecil.TypeReference) As Mono.Cecil.Cil.VariableDefinition
         Helper.Assert(Helper.IsEmittableMember(Compiler, localType))
         Log("DeclareLocal({0})", localType.ToString)
         Dim local As Mono.Cecil.Cil.VariableDefinition
         local = New Mono.Cecil.Cil.VariableDefinition(localType)
         m_CilBody.Variables.Add(local)
         m_CilBody.InitLocals = True
         Return local
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="531" endline="539">
<![CDATA[
 
 		public void IsClsCompliant (IMemberContext ctx)
 		{
 			if (parameter_type.IsCLSCompliant ())
 				return;
 
 			ctx.Compiler.Report.Warning (3001, 1, Location,
 				"Argument type `{0}' is not CLS-compliant", parameter_type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4762" endline="4777">
<![CDATA[
 
     ''' <summary>
     ''' LocalDeclarationStatement  
     ''' </summary>
     Private Function ParseLocalDeclarationStatement(ByVal Parent As CodeBlock) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.LocalModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_Modifiers, New ParseAttributableInfo(Compiler, Nothing))
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4795" endline="4811">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseLocalVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4778" endline="4794">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseTypeVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As Generic.List(Of TypeVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseTypeVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4854" endline="4862">
<![CDATA[
 
     Private Function ParseLocalVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
         If ParseVariableDeclarator(Parent, Modifiers, Info, result, True) = False Then
             Console.WriteLine("Returned false")
             Return Nothing
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="376" endline="397">
<![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim qi As QualifiedIdentifier = Nothing
         qi = ParseQualifiedIdentifier(result, str)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(qi)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="797" endline="806">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1 + op2 * 19)
         If chr = "X"c Then
             Return Nothing
         Else
             Return CType(Microsoft.VisualBasic.Asc(chr) - Microsoft.VisualBasic.Asc("A"), TypeCode)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="340" endline="360">
<![CDATA[
 
 		//
 		// Returns a MemberInfo that is referenced in XML documentation
 		// (by "see" or "seealso" elements).
 		//
 		private static MemberSpec FindDocumentedMember (MemberCore mc,
 			TypeSpec type, string member_name, AParametersCollection param_list, 
 			DeclSpace ds, out int warning_type, string cref,
 			bool warn419, string name_for_error, Report r)
 		{
 //			for (; type != null; type = type.DeclaringType) {
 				var mi = FindDocumentedMemberNoNest (
 					mc, type, member_name, param_list, ds,
 					out warning_type, cref, warn419,
 					name_for_error, r);
 				if (mi != null)
 					return mi; // new FoundMember (type, mi);
 //			}
 			warning_type = 0;
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="408" endline="421">
<![CDATA[
 
     ReadOnly Property UpmostBlock() As CodeBlock
         Get
             Dim result As CodeBlock = Nothing
             Dim tmp As CodeBlock
 
             tmp = Me
             Do Until tmp Is Nothing
                 result = tmp
                 tmp = tmp.FindFirstParent(Of CodeBlock)()
             Loop
             Do Until tmp Is Nothing
                 result = tmp
                 tmp = tmp.FindFirstParent(Of CodeBlock)()
             Loop
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="535" endline="543">
<![CDATA[
 
 		public Attribute ResolveAssemblyAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("assembly", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="544" endline="552">
<![CDATA[
 
 		Attribute ResolveModuleAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("module", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="155" endline="161">
<![CDATA[
 
 		internal long ReadInt64()
 		{
 			ulong lo = ReadUInt32();
 			ulong hi = ReadUInt32();
 			return (long)(lo | (hi << 32));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="189" endline="199">
<![CDATA[
 
 		internal int DefineType (Type type)
 		{
 			int index;
 			if (type_hash.TryGetValue (type, out index))
 				return index;
 
 			index = ++last_type_index;
 			type_hash.Add (type, index);
 			return index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="812" endline="825">
<![CDATA[
 
 		public ImportedAssemblyDefinition GetAssemblyDefinition (Assembly assembly)
 		{
 			ImportedAssemblyDefinition def;
 			if (!assembly_2_definition.TryGetValue (assembly, out def)) {
 
 				// This can happen in dynamic context only
 				def = new ImportedAssemblyDefinition (assembly, this);
 				assembly_2_definition.Add (assembly, def);
 				def.ReadAttributes ();
 			}
 
 			return def;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="673" endline="689">
<![CDATA[
 		}
 
 		internal override MetaType GetTypeImpl (string typeName)
 		{
 			//
 			// We are loading a type from missing reference
 			// this itself is fine. The error will be reported
 			// later when the type is actually used
 			//
 			MetaType t;
 			if (!types.TryGetValue (typeName, out t)) {
 				t = new MissingType (typeName, this);
 				types.Add (typeName, t);
 			}
 
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="387" endline="399">
<![CDATA[
 
 		public abstract AssemblyName[] __GetReferencedAssemblies();
 
 		internal Type CanonicalizeType(Type type)
 		{
 			Type canon;
 			if (!universe.canonicalizedTypes.TryGetValue(type, out canon))
 			{
 				canon = type;
 				universe.canonicalizedTypes.Add(canon, canon);
 			}
 			return canon;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1057" endline="1067">
<![CDATA[
 
 		public static TypeInfo GetTypeInfo (TypeSpec type)
 		{
 			TypeInfo info;
 			if (type_hash.TryGetValue (type, out info))
 				return info;
 
 			info = new TypeInfo (type);
 			type_hash.Add (type, info);
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="633" endline="648">
<![CDATA[
 
 		/// <summary>
 		/// Returns condition of ConditionalAttribute
 		/// </summary>
 		public string GetConditionalAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments[0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="617" endline="632">
<![CDATA[
 
 		/// <summary>
 		/// Returns custom name of indexer
 		/// </summary>
 		public string GetIndexerAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments [0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="678" endline="695">
<![CDATA[
 
 		/// <summary>
 		/// Returns value of CLSCompliantAttribute contructor parameter but because the method can be called
 		/// before ApplyAttribute. We need to resolve the arguments.
 		/// This situation occurs when class deps is differs from Emit order.  
 		/// </summary>
 		public bool GetClsCompliantAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return false;
 
 			return ((BoolConstant) PosArguments[0].Expr).Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="525" endline="535">
<![CDATA[
 
 		Expression LiftExpression (ResolveContext ec, Expression expr)
 		{
 			TypeExpr lifted_type = new NullableType (expr.Type, expr.Location);
 			lifted_type = lifted_type.ResolveAsTypeTerminal (ec, false);
 			if (lifted_type == null)
 				return null;
 
 			expr.Type = lifted_type.Type;
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="381" endline="391">
<![CDATA[
 		}
 
 		public string Name {
 			get {
 				int index = File;
 				if (token == 0 || index == 0)
 					return "Internal";
 
 				SourceFile file = (SourceFile) source_list [index - 1];
 				return file.Name;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1335" endline="1345">
<![CDATA[
 
     Private Function ParseBuiltinTypeName(ByVal Parent As ParsedObject) As BuiltInTypeName
         Dim m_Typename As KS
 
         If vbnc.BuiltInTypeName.IsBuiltInTypeName(tm) = False Then Throw New InternalException(Parent)
 
         m_Typename = tm.CurrentToken.Keyword
         tm.NextToken()
 
         Return New BuiltInTypeName(Parent, m_Typename)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="258" endline="268">
<![CDATA[
 
 		public bool CheckWarningCode (int code, Location loc)
 		{
 			if (AllWarningsHashSet == null)
 				AllWarningsHashSet = new HashSet<int> (AllWarnings);
 
 			if (AllWarningsHashSet.Contains (code))
 				return true;
 
 			return CheckWarningCode (code.ToString (), loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodBase.cs" startline="41" endline="48">
<![CDATA[
 			{
 				if ((this.Attributes & MethodAttributes.RTSpecialName) != 0)
 				{
 					string name = this.Name;
 					return name == ConstructorInfo.ConstructorName || name == ConstructorInfo.TypeConstructorName;
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1450" endline="1464">
<![CDATA[
 		}
 
 		internal virtual Type BindTypeParameters(IGenericBinder binder)
 		{
 			if (IsGenericTypeDefinition)
 			{
 				Type[] args = GetGenericArguments();
 				Type.InplaceBindTypeParameters(binder, args);
 				return GenericTypeInstance.Make(this, args, null, null);
 			}
 			else
 			{
 				return this;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2106" endline="2114">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			value = value.Resolve (rc);
 
 			type = value.Type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2407" endline="2415">
<![CDATA[
 
 		static bool IsUnsigned (TypeSpec t)
 		{
 			if (t.IsPointer)
 				return true;
 
 			return (t == TypeManager.uint32_type || t == TypeManager.uint64_type ||
 				t == TypeManager.ushort_type || t == TypeManager.byte_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="771" endline="790">
<![CDATA[
 		
 		//
 		// According to section 16.3.1 (using-alias-directive), the namespace-or-type-name is
 		// resolved as if the immediately containing namespace body has no using-directives.
 		//
 		// Section 16.3.2 says that the same rule is applied when resolving the namespace-name
 		// in the using-namespace-directive.
 		//
 		// To implement these rules, the expressions in the using directives are resolved using 
 		// the "doppelganger" (ghostly bodiless duplicate).
 		//
 		NamespaceEntry doppelganger;
 		NamespaceEntry Doppelganger {
 			get {
 				if (!IsImplicit && doppelganger == null) {
 					doppelganger = new NamespaceEntry (ctx, ImplicitParent, file, ns, true);
 					doppelganger.using_aliases = using_aliases;
 				}
 				return doppelganger;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1333" endline="1343">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// It can be null for static initializers
 			if (base_ctor == null)
 				return;
 			
 			ec.Mark (loc);
 
 			Invocation.EmitCall (ec, new CompilerGeneratedThis (type, loc), base_ctor, argument_list, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="536" endline="545">
<![CDATA[
 
 		protected override Expression ResolveEnumOperator (ResolveContext ec, Expression expr)
 		{
 			expr = base.ResolveEnumOperator (ec, expr);
 			if (expr == null)
 				return null;
 
 			Expr = LiftExpression (ec, Expr);
 			return LiftExpression (ec, expr);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="311" endline="322">
<![CDATA[
 
 		public static Expression Create (Expression expr, TypeSpec type)
 		{
 			//
 			// Avoid unwraping and wraping of the same type
 			//
 			Unwrap unwrap = expr as Unwrap;
 			if (unwrap != null && expr.Type == NullableInfo.GetUnderlyingType (type))
 				return unwrap.Original;
 		
 			return new Wrap (expr, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="706" endline="717">
<![CDATA[
 
 		// note that context is slightly different from the calling assembly (System.Type.GetType),
 		// because context is passed to the AssemblyResolve event as the RequestingAssembly
 		public Type GetType(Assembly context, string assemblyQualifiedTypeName, bool throwOnError)
 		{
 			TypeNameParser parser = TypeNameParser.Parse(assemblyQualifiedTypeName, throwOnError);
 			if (parser.Error)
 			{
 				return null;
 			}
 			return parser.GetType(this, context, throwOnError, assemblyQualifiedTypeName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1397" endline="1407">
<![CDATA[
 
     Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference = Nothing
 
         If Params Is Nothing Then Return result
         ReDim result(Params.Count - 1)
         For i As Integer = 0 To Params.Count - 1
             result(i) = Params(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="124" endline="132">
<![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal labels() As Label)
         Dim tmpCecil As Mono.Cecil.Cil.Instruction()
         ReDim tmpCecil(labels.Length - 1)
         For i As Integer = 0 To labels.Length - 1
             tmpCecil(i) = labels(i).CecilLabel
         Next
         Emit(opcode, tmpCecil)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="334" endline="348">
<![CDATA[
 
     Shared Function GetParameterTypes(ByVal Context As BaseObject, ByVal member As Mono.Cecil.MemberReference) As Mono.Cecil.TypeReference()
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = GetParameters(Context, member)
         Dim result() As Mono.Cecil.TypeReference
 
         If params Is Nothing Then Return Nothing
 
         ReDim result(params.Count - 1)
 
         For i As Integer = 0 To params.Count - 1
             result(i) = params(i).ParameterType
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="35" endline="44">
<![CDATA[
 
     ReadOnly Property AsTypeArray() As Type()
         Get
             Dim t As Type = GetType(System.Collections.Generic.Dictionary(Of ,))
             Dim result(m_TypeParameters.Length - 1) As Type
             For i As Integer = 0 To result.Length - 1
                 'result(i) = m_TypeParameters(i).Parameters
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="30" endline="36">
<![CDATA[
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For i As Integer = 0 To m_List.Count - 1
             m_List(i).Initialize(Parent)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1943" endline="1959">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if CallerType is a nested class of CalledType.
     ''' Returns false if both types are equal.
     ''' </summary>
     ''' <param name="CalledType"></param>
     ''' <param name="CallerType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsNested(ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         Dim tmp As Mono.Cecil.TypeReference = CecilHelper.FindDefinition(CallerType).DeclaringType
         Do Until tmp Is Nothing
             If CompareType(CalledType, tmp) Then Return True
             tmp = CecilHelper.FindDefinition(tmp).DeclaringType
         Loop
         Do Until tmp Is Nothing
             If CompareType(CalledType, tmp) Then Return True
             tmp = CecilHelper.FindDefinition(tmp).DeclaringType
         Loop
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="503" endline="523">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             Dim var As LocalVariableDeclaration = m_Variables(i)
             result = CreateLabelForCurrentInstruction(Info) AndAlso result
             result = var.DefineLocalVariable(Info) AndAlso result
         Next
 
         For i As Integer = 0 To m_Sequence.Count - 1
             Dim stmt As BaseObject = m_Sequence.Item(i)
 
             Emitter.MarkSequencePoint(Info, stmt.Location)
 
             result = CreateLabelForCurrentInstruction(Info) AndAlso result
             result = stmt.GenerateCode(Info) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="341" endline="358">
<![CDATA[
 
 		private static bool ParsePublicKey(string str, out string publicKeyToken)
 		{
 			if (str == null)
 			{
 				publicKeyToken = null;
 				return false;
 			}
 			// HACK use AssemblyName to convert PublicKey to PublicKeyToken
 			byte[] token = new AssemblyName("Foo, PublicKey=" + str).GetPublicKeyToken();
 			StringBuilder sb = new StringBuilder(token.Length * 2);
 			for (int i = 0; i < token.Length; i++)
 			{
 				sb.AppendFormat("{0
 			}
 			for (int i = 0; i < token.Length; i++)
 			{
 				sb.AppendFormat("{0
 			}
 			publicKeyToken = sb.ToString();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2419" endline="2431">
<![CDATA[
 
 		internal int FindOrAddRecord(Record record)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(record);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2910" endline="2928">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if all types in both arrays are the exact same types.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareTypes(ByVal Types1() As Mono.Cecil.TypeReference, ByVal Types2() As Mono.Cecil.TypeReference) As Boolean
         If Types1 Is Nothing AndAlso Types2 Is Nothing Then
             Return True
         ElseIf Types1 Is Nothing Xor Types2 Is Nothing Then
             Return False
         Else
             If Types1.Length <> Types2.Length Then Return False
             For i As Integer = 0 To Types1.Length - 1
                 If Helper.CompareType(Types1(i), Types2(i)) = False Then Return False
             Next
             Return True
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="98" endline="108">
<![CDATA[
 
     Public ReadOnly Property IsExternalDeclaration() As Boolean
         Get
             If TypeOf Me Is ExternalSubDeclaration Then Return True
             If CustomAttributes Is Nothing Then Return False
             For i As Integer = 0 To CustomAttributes.Count - 1
                 If CustomAttributes(i).ResolvedType Is Nothing Then Continue For
                 If Helper.CompareType(CustomAttributes(i).ResolvedType, Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then Return True
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3488" endline="3497">
<![CDATA[
 
     Shared Function IsLiteral0Expression(ByVal Compiler As Compiler, ByVal exp As Expression) As Boolean
         If exp Is Nothing Then Return False
         Dim litExp As LiteralExpression = TryCast(exp, LiteralExpression)
         If litExp Is Nothing Then Return False
         If litExp.ConstantValue Is Nothing Then Return False
         If Compiler.TypeResolution.IsIntegralType(CecilHelper.GetType(Compiler, litExp.ConstantValue)) = False Then Return False
         If CDbl(litExp.ConstantValue) = 0.0 Then Return True
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="42" endline="50">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="669" endline="685">
<![CDATA[
 
 		/// <summary>
 		/// Returns true when MemberCore is exposed from assembly.
 		/// </summary>
 		public bool IsExposedFromAssembly ()
 		{
 			if ((ModFlags & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 				return false;
 			
 			DeclSpace parentContainer = Parent.PartialContainer;
 			while (parentContainer != null && parentContainer.ModFlags != 0) {
 				if ((parentContainer.ModFlags & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 					return false;
 				parentContainer = parentContainer.Parent;
 			}
 			while (parentContainer != null && parentContainer.ModFlags != 0) {
 				if ((parentContainer.ModFlags & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 					return false;
 				parentContainer = parentContainer.Parent;
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6862" endline="6878">
<![CDATA[
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			if (ae == null)
 				return null;
 
 			AnonymousMethodStorey storey = ae.Storey;
 			while (storey != null) {
 				AnonymousMethodStorey temp = storey.Parent as AnonymousMethodStorey;
 				if (temp == null)
 					return storey.HoistedThis;
 
 				storey = temp;
 			}
 			while (storey != null) {
 				AnonymousMethodStorey temp = storey.Parent as AnonymousMethodStorey;
 				if (temp == null)
 					return storey.HoistedThis;
 
 				storey = temp;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2053" endline="2073">
<![CDATA[
 
 		//
 		// Used for visiblity checks to tests whether this definition shares
 		// base type baseType, it does member-definition search
 		//
 		public bool IsBaseTypeDefinition (TypeSpec baseType)
 		{
 			// RootContext check
 			if (TypeBuilder == null)
 				return false;
 
 			var type = spec;
 			do {
 				if (type.MemberDefinition == baseType.MemberDefinition)
 					return true;
 
 				type = type.BaseType;
 			} while (type != null);
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1266" endline="1276">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			Array.Sort(records, 0, rowCount, this);
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].PackingSize);
 				mw.Write(records[i].ClassSize);
 				mw.WriteTypeDef(records[i].Parent);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].PackingSize);
 				mw.Write(records[i].ClassSize);
 				mw.WriteTypeDef(records[i].Parent);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1836" endline="1846">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MappingFlags);
 				mw.WriteMemberForwarded(records[i].MemberForwarded);
 				mw.WriteStringIndex(records[i].ImportName);
 				mw.WriteModuleRef(records[i].ImportScope);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MappingFlags);
 				mw.WriteMemberForwarded(records[i].MemberForwarded);
 				mw.WriteStringIndex(records[i].ImportName);
 				mw.WriteModuleRef(records[i].ImportScope);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2198" endline="2208">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2294" endline="2304">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Number);
 				mw.Write(records[i].Flags);
 				mw.WriteTypeOrMethodDef(records[i].Owner);
 				mw.WriteStringIndex(records[i].Name);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Number);
 				mw.Write(records[i].Flags);
 				mw.WriteTypeOrMethodDef(records[i].Owner);
 				mw.WriteStringIndex(records[i].Name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2174" endline="2197">
<![CDATA[
 	}
 
 	sealed class ManifestResourceTable 
 	{
 		internal const int Index = 0x28;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Flags;
 			internal int Name;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1812" endline="1835">
<![CDATA[
 	}
 
 	sealed class ImplMapTable 
 	{
 		internal const int Index = 0x1C;
 
 		internal struct Record
 		{
 			internal short MappingFlags;
 			internal int MemberForwarded;
 			internal int ImportName;
 			internal int ImportScope;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2268" endline="2293">
<![CDATA[
 	}
 
 	sealed class GenericParamTable 
 	{
 		internal const int Index = 0x2A;
 
 		internal struct Record
 		{
 			internal short Number;
 			internal short Flags;
 			internal int Owner;
 			internal int Name;
 			// not part of the table, we use it to be able to fixup the GenericParamConstraint table
 			internal int unsortedIndex;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6724" endline="6735">
<![CDATA[
 
 		//
 		// Converts static initializer only
 		//
 		void UnifyInitializerElement (ResolveContext ec)
 		{
 			for (int i = 0; i < array_data.Count; ++i) {
 				Expression e = array_data[i];
 				if (e != null)
 					array_data [i] = Convert.ImplicitConversion (ec, e, array_element_type, Location.Null);
 			}
 			for (int i = 0; i < array_data.Count; ++i) {
 				Expression e = array_data[i];
 				if (e != null)
 					array_data [i] = Convert.ImplicitConversion (ec, e, array_element_type, Location.Null);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="715" endline="727">
<![CDATA[
 
 		internal void WriteSymbolTokenMap()
 		{
 			for (int i = 0; i < resolvedTokens.Count; i++)
 			{
 				int newToken = resolvedTokens[i];
 				// The symbol API doesn't support remapping arbitrary integers, the types have to be the same,
 				// so we copy the type from the newToken, because our pseudo tokens don't have a type.
 				// (see MethodToken.SymbolToken)
 				int oldToken = (i + 1) | (newToken & ~0xFFFFFF);
 				SymbolSupport.RemapToken(symbolWriter, oldToken, newToken);
 			}
 			for (int i = 0; i < resolvedTokens.Count; i++)
 			{
 				int newToken = resolvedTokens[i];
 				// The symbol API doesn't support remapping arbitrary integers, the types have to be the same,
 				// so we copy the type from the newToken, because our pseudo tokens don't have a type.
 				// (see MethodToken.SymbolToken)
 				int oldToken = (i + 1) | (newToken & ~0xFFFFFF);
 				SymbolSupport.RemapToken(symbolWriter, oldToken, newToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1911" endline="1923">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder, int sdataRVA)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].RVA += sdataRVA;
 				if (moduleBuilder.IsPseudoToken(records[i].Field))
 				{
 					records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].RVA += sdataRVA;
 				if (moduleBuilder.IsPseudoToken(records[i].Field))
 				{
 					records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="767" endline="788">
<![CDATA[
 	}
 
 	sealed class MemberRefTable 
 	{
 		internal const int Index = 0x0A;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2071" endline="2092">
<![CDATA[
 	}
 
 	sealed class FileTable 
 	{
 		internal const int Index = 0x26;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int Name;
 			internal int HashValue;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1548" endline="1577">
<![CDATA[
 	}
 
 	sealed class MethodSemanticsTable 
 	{
 		internal const int Index = 0x18;
 
 		// semantics
 		internal const short Setter = 0x0001;
 		internal const short Getter = 0x0002;
 		internal const short Other = 0x0004;
 		internal const short AddOn = 0x0008;
 		internal const short RemoveOn = 0x0010;
 		internal const short Fire = 0x0020;
 
 		internal struct Record
 		{
 			internal short Semantics;
 			internal int Method;
 			internal int Association;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="833" endline="854">
<![CDATA[
 	}
 
 	sealed class ConstantTable 
 	{
 		internal const int Index = 0x0B;
 
 		internal struct Record
 		{
 			internal short Type;
 			internal int Parent;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1684" endline="1705">
<![CDATA[
 	}
 
 	sealed class MethodImplTable 
 	{
 		internal const int Index = 0x19;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int MethodBody;
 			internal int MethodDeclaration;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1256" endline="1265">
<![CDATA[
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].PackingSize = mr.ReadInt16();
 				records[i].ClassSize = mr.ReadInt32();
 				records[i].Parent = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].PackingSize = mr.ReadInt16();
 				records[i].ClassSize = mr.ReadInt32();
 				records[i].Parent = mr.ReadTypeDef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1507" endline="1528">
<![CDATA[
 	}
 
 	sealed class PropertyTable 
 	{
 		internal const int Index = 0x17;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Type;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="660" endline="681">
<![CDATA[
 	}
 
 	sealed class ParamTable 
 	{
 		internal const int Index = 0x08;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal short Sequence;
 			internal int Name;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1156" endline="1177">
<![CDATA[
 	}
 
 	sealed class DeclSecurityTable 
 	{
 		internal const int Index = 0x0E;
 
 		internal struct Record
 		{
 			internal short Action;
 			internal int Parent;
 			internal int PermissionSet;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1429" endline="1450">
<![CDATA[
 	}
 
 	sealed class EventTable 
 	{
 		internal const int Index = 0x14;
 
 		internal struct Record
 		{
 			internal short EventFlags;
 			internal int Name;
 			internal int EventType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="484" endline="505">
<![CDATA[
 	}
 
 	sealed class TypeRefTable 
 	{
 		internal const int Index = 0x01;
 
 		internal struct Record
 		{
 			internal int ResolutionScope;
 			internal int TypeName;
 			internal int TypeNameSpace;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="575" endline="596">
<![CDATA[
 	}
 
 	sealed class FieldTable 
 	{
 		internal const int Index = 0x04;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="965" endline="986">
<![CDATA[
 	}
 
 	sealed class CustomAttributeTable 
 	{
 		internal const int Index = 0x0C;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int Type;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="344" endline="360">
<![CDATA[
 		}
 
 		public override Type[] GetGenericParameterConstraints()
 		{
 			IGenericContext context = (this.DeclaringMethod as IGenericContext) ?? this.DeclaringType;
 			List<Type> list = new List<Type>();
 			int token = this.MetadataToken;
 			// TODO use binary search
 			for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
 			{
 				if (module.GenericParamConstraint.records[i].Owner == token)
 				{
 					list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
 				}
 			}
 			for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
 			{
 				if (module.GenericParamConstraint.records[i].Owner == token)
 				{
 					list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="297" endline="317">
<![CDATA[
 
 		public override Type DeclaringType
 		{
 			get
 			{
 				// note that we cannot use Type.IsNested for this, because that calls DeclaringType
 				if ((this.Attributes & TypeAttributes.VisibilityMask & ~TypeAttributes.Public) == 0)
 				{
 					return null;
 				}
 				// TODO use binary search (if sorted)
 				int token = this.MetadataToken;
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				throw new InvalidOperationException();
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="103" endline="115">
<![CDATA[
 
 		internal override Type GetTypeImpl(string typeName)
 		{
 			Type type = manifestModule.GetType(typeName);
 			for (int i = 0; type == null && i < externalModules.Length; i++)
 			{
 				if ((manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 				{
 					type = GetModule(i).GetType(typeName);
 				}
 			}
 			for (int i = 0; type == null && i < externalModules.Length; i++)
 			{
 				if ((manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 				{
 					type = GetModule(i).GetType(typeName);
 				}
 			}
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2480" endline="2489">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			int[] fixups = moduleBuilder.GenericParam.GetIndexFixup();
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Owner = fixups[records[i].Owner - 1] + 1;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Owner = fixups[records[i].Owner - 1] + 1;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1340" endline="1348">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="541" endline="555">
<![CDATA[
 
 	static public string CSharpName (IList<TypeSpec> types)
 	{
 		if (types.Count == 0)
 			return string.Empty;
 
 		StringBuilder sb = new StringBuilder ();
 		for (int i = 0; i < types.Count; ++i) {
 			if (i > 0)
 				sb.Append (",");
 
 			sb.Append (CSharpName (types [i]));
 		}
 		for (int i = 0; i < types.Count; ++i) {
 			if (i > 0)
 				sb.Append (",");
 
 			sb.Append (CSharpName (types [i]));
 		}
 		return sb.ToString ();
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2138" endline="2149">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.Write(records[i].TypeDefId);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNamespace);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.Write(records[i].TypeDefId);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNamespace);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="450" endline="461">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Generation);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteGuidIndex(records[i].Mvid);
 				mw.WriteGuidIndex(records[i].EncId);
 				mw.WriteGuidIndex(records[i].EncBaseId);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Generation);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteGuidIndex(records[i].Mvid);
 				mw.WriteGuidIndex(records[i].EncId);
 				mw.WriteGuidIndex(records[i].EncBaseId);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="40" endline="50">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeModifiers
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeModifiers(NewParent)
         Dim mods(m_ArrayTypeModifiers.GetUpperBound(0)) As ArrayTypeModifier
         For i As Integer = 0 To mods.GetUpperBound(0)
             mods(i) = m_ArrayTypeModifiers(i).Clone(result)
         Next
         result.Init(mods)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="111" endline="129">
<![CDATA[
 
 
     ''' <summary>
     ''' Creates an array of the specified type and number of elements (and ranks)
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="arraytype"></param>
     ''' <param name="Elements"></param>
     ''' <remarks></remarks>
     Public Shared Sub EmitArrayCreation(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Elements As Generic.List(Of Integer))
         If Elements.Count = 0 Then
             Emitter.EmitLoadI4Value(Info, 0)
         Else
             For i As Integer = 0 To Elements.Count - 1
                 Emitter.EmitLoadI4Value(Info, Elements(i))
             Next
         End If
         EmitArrayConstructor(Info, ArrayType, Elements.Count)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2056" endline="2062">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			for (int ix = 0; ix < statements.Count; ix++){
 				statements [ix].Emit (ec);
 			}
 			for (int ix = 0; ix < statements.Count; ix++){
 				statements [ix].Emit (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1786" endline="1798">
<![CDATA[
 	}
 
 	sealed class TypeSpecTable 
 	{
 		internal const int Index = 0x1B;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1746" endline="1758">
<![CDATA[
 	}
 
 	sealed class ModuleRefTable 
 	{
 		internal const int Index = 0x1A;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1354" endline="1366">
<![CDATA[
 	}
 
 	sealed class StandAloneSigTable 
 	{
 		internal const int Index = 0x11;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1367" endline="1374">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1759" endline="1766">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1799" endline="1806">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="109" endline="115">
<![CDATA[
 
     Sub NextToken(ByVal Jump As Integer)
         Helper.Assert(Jump >= 0)
         For i As Integer = 1 To Jump
             NextToken()
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1884" endline="1898">
<![CDATA[
 
     Private Function ParseBuiltInTypeExpression(ByVal Parent As ParsedObject) As BuiltInTypeExpression
         Dim result As New BuiltInTypeExpression(Parent)
 
         Dim m_Type As BuiltInDataTypes
 
         Helper.Assert(tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames))
 
         m_Type = CType(tm.CurrentToken.Keyword, BuiltInDataTypes)
         tm.NextToken()
 
         result.Init(m_Type)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="400" endline="410">
<![CDATA[
 
 		public LocalBuilder DeclareLocal(Type localType, bool pinned)
 		{
 			LocalBuilder local = new LocalBuilder(localType, locals.Count, pinned);
 			locals.Add(local);
 			if (scope != null)
 			{
 				scope.locals.Add(local);
 			}
 			return local;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="92" endline="111">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Store the stack value into the loop control variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitStoreVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Info.RHSExpression IsNot Nothing)
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             result = Info.RHSExpression.Classification.GenerateCode(Info.Clone(Me, True, False, m_Declaration.LocalBuilder.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="148" endline="158">
<![CDATA[
 
     ReadOnly Property VariableType() As Mono.Cecil.TypeReference
         Get
             If m_Expression IsNot Nothing Then
                 Return m_Expression.ExpressionType
             ElseIf m_TypeName IsNot Nothing Then
                 Return m_TypeName.ResolvedType
             Else
                 Return m_Declaration.VariableType
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="480" endline="499">
<![CDATA[
 
 		//
 		// For named arguments when the order of execution is different
 		// to order of invocation
 		//
 		public Arguments MarkOrderedArgument (NamedArgument a)
 		{
 			//
 			// Constant expression have no effect on left-to-right execution
 			//
 			if (a.Expr is Constant)
 				return this;
 
 			ArgumentsOrdered ra = this as ArgumentsOrdered;
 			if (ra == null)
 				ra = new ArgumentsOrdered (this);
 
 			ra.AddOrdered (a);
 			return ra;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3097" endline="3109">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			this.eclass = ExprClass.MethodGroup;
 
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (ec);
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="469" endline="479">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (user_operator != null)
 				return user_operator.CreateExpressionTree (ec);
 
 			if (Oper == Operator.UnaryPlus)
 				return Expr.CreateExpressionTree (ec);
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="889" endline="901">
<![CDATA[
 
 		protected bool VerifyExplicitParameters (ResolveContext ec, TypeSpec delegate_type, AParametersCollection parameters)
 		{
 			if (VerifyParameterCompatibility (ec, delegate_type, parameters, ec.IsInProbingMode))
 				return true;
 
 			if (!ec.IsInProbingMode)
 				ec.Report.Error (1661, loc,
 					"Cannot convert `{0}' to delegate type `{1}' since there is a parameter mismatch",
 					GetSignatureForError (), TypeManager.CSharpName (delegate_type));
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="35" endline="59">
<![CDATA[
 
 		/// <summary>
 		///   We already know that the statement is unreachable, but we still
 		///   need to resolve it to catch errors.
 		/// </summary>
 		public virtual bool ResolveUnreachable (BlockContext ec, bool warn)
 		{
 			//
 			// This conflicts with csc's way of doing this, but IMHO it's
 			// the right thing to do.
 			//
 			// If something is unreachable, we still check whether it's
 			// correct.  This means that you cannot use unassigned variables
 			// in unreachable code, for instance.
 			//
 
 			if (warn)
 				ec.Report.Warning (162, 2, loc, "Unreachable code detected");
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Block, loc);
 			bool ok = Resolve (ec);
 			ec.KillFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1379" endline="1387">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (Value >= 0 && type == TypeManager.uint64_type) {
 				return new ULongConstant ((ulong) Value, loc).Resolve (rc);
 			}
 
 			return base.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4001" endline="4011">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			// System.Reflection.Emit automatically emits a 'leave' at the end of a try clause
 			// So, ensure there's some IL code after this statement.
 			if (!code_follows && resume_points == null && ec.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				ec.NeedReturnLabel ();
 
 			iter = ec.CurrentIterator;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="208" endline="224">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a constructorinfo.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedConstructor() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="192" endline="207">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a methodinfo.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethodInfo() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="259" endline="265">
<![CDATA[
 
 		internal byte[] ToArray()
 		{
 			byte[] buf = new byte[pos];
 			Buffer.BlockCopy(buffer, 0, buf, 0, pos);
 			return buf;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="759" endline="768">
<![CDATA[
 
 		protected abstract Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet);
 
 		protected virtual Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			var setter_args = new Arguments (Arguments.Count + 1);
 			setter_args.AddRange (Arguments);
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="298" endline="305">
<![CDATA[
 
 		private MethodBuilder CreateMethodBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention)
 		{
 			this.ModuleBuilder.MethodDef.AddVirtualRecord();
 			MethodBuilder mb = new MethodBuilder(this, name, attributes, callingConvention);
 			methods.Add(mb);
 			return mb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="411" endline="418">
<![CDATA[
 
 		public Label DefineLabel()
 		{
 			Label label = new Label(labels.Count);
 			labels.Add(-1);
 			labelStackHeight.Add(-1);
 			return label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="753" endline="759">
<![CDATA[
 
 		private AssemblyBuilder DefineDynamicAssemblyImpl(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 		{
 			AssemblyBuilder asm = new AssemblyBuilder(this, name, dir, requiredPermissions, optionalPermissions, refusedPermissions);
 			dynamicAssemblies.Add(asm);
 			return asm;
  		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="369" endline="375">
<![CDATA[
 
 		public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes)
 		{
 			FieldBuilder fb = new FieldBuilder(this, fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes);
 			fields.Add(fb);
 			return fb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="141" endline="147">
<![CDATA[
 
 		public SourceFileEntry DefineDocument (string url, byte[] guid, byte[] checksum)
 		{
 			SourceFileEntry entry = new SourceFileEntry (file, url, guid, checksum);
 			sources.Add (entry);
 			return entry;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EnumBuilder.cs" startline="59" endline="66">
<![CDATA[
 		}
 
 		public FieldBuilder DefineLiteral(string literalName, object literalValue)
 		{
 			FieldBuilder fb = typeBuilder.DefineField(literalName, typeBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
 			fb.SetConstant(literalValue);
 			return fb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="205" endline="211">
<![CDATA[
 
 		public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
 		{
 			ModuleBuilder module = new ModuleBuilder(this, name, fileName, emitSymbolInfo);
 			modules.Add(module);
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="148" endline="154">
<![CDATA[
 
 		public CompileUnitEntry DefineCompilationUnit (SourceFileEntry source)
 		{
 			CompileUnitEntry entry = new CompileUnitEntry (file, source);
 			comp_units.Add (entry);
 			return entry;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="134" endline="140">
<![CDATA[
 
 		public SourceFileEntry DefineDocument (string url)
 		{
 			SourceFileEntry entry = new SourceFileEntry (file, url);
 			sources.Add (entry);
 			return entry;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6215" endline="6222">
<![CDATA[
 
 string ConsumeStoredComment ()
 {
 	string s = tmpComment;
 	tmpComment = null;
 	Lexer.doc_state = XmlCommentState.Allowed;
 	return s;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="291" endline="297">
<![CDATA[
 
     Public Function CreateAndEmitNop() As Mono.Cecil.Cil.Instruction
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         CilWorker.Append(result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="756" endline="762">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddBreakOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="763" endline="769">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddContinueOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="770" endline="776">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement exit_stmt)
 		{
 			Parent.AddReturnOrigin (vector, exit_stmt);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1836" endline="1846">
<![CDATA[
 		}
 
 		#endregion
 
 		public Block CreateSwitchBlock (Location start)
 		{
 			// FIXME
 			var new_block = new Block (this, start, start);
 			new_block.IsCompilerGenerated = true;
 			return new_block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="588" endline="594">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (continue_origins);
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="564" endline="570">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (break_origins);
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="280" endline="288">
<![CDATA[
 
     Function IsIntegerLiteral() As Boolean
         Select Case m_TokenType
             Case TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="260" endline="269">
<![CDATA[
     End Property
 
     Function IsLiteral() As Boolean
         Select Case m_TokenType
             Case TokenType.DateLiteral, TokenType.CharLiteral, TokenType.DecimalLiteral, TokenType.DoubleLiteral, TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.SingleLiteral, TokenType.StringLiteral, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="175" endline="184">
<![CDATA[
 		}
 
 		#endregion
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var ps = (PropertySpec) base.InflateMember (inflator);
 			ps.memberType = inflator.Inflate (memberType);
 			return ps;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="315" endline="321">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var fs = (FieldSpec) base.InflateMember (inflator);
 			fs.memberType = inflator.Inflate (memberType);
 			return fs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1362" endline="1368">
<![CDATA[
 
 		public bool IsAssigned (ResolveContext ec)
 		{
 			return !ec.DoFlowAnalysis ||
 				(ec.OmitStructFlowAnalysis && TypeInfo.Type.IsStruct) ||
 				ec.CurrentBranching.IsAssigned (this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="203" endline="210">
<![CDATA[
 
 		public int Peek ()
 		{
 			if ((pos >= char_count) && !ReadBuffer ())
 				return -1;
 
 			return buffer [pos];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="109" endline="119">
<![CDATA[
 		}
 
 		// <summary>
 		//   Starts a new code branching.  This inherits the state of all local
 		//   variables and parameters from the current branching.
 		// </summary>
 		public FlowBranching StartFlowBranching (FlowBranching.BranchingType type, Location loc)
 		{
 			current_flow_branching = FlowBranching.CreateBranching (CurrentBranching, type, null, loc);
 			return current_flow_branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3649" endline="3657">
<![CDATA[
 
     Shared Function GetEventAccess(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetEventAttributes([Event])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3640" endline="3648">
<![CDATA[
 
     Shared Function GetPropertyAccess(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetPropertyAttributes([Property])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="95" endline="106">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.IsRHS)
 
         Emitter.EmitLoadVariable(Info, m_Local)
         Emitter.EmitLoadI4Value(Info, m_Index)
         Emitter.EmitLoadElement(Info, m_Local.VariableType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="79" endline="88">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_MethodGroup.Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_MethodGroup.InstanceExpression, m_MethodGroup.FinalArguments, Helper.GetMethodOrMethodReference(Compiler, m_MethodGroup.ResolvedMethod))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="80" endline="87">
<![CDATA[
 
 		internal FieldSignature ExpandTypeParameters(Type declaringType)
 		{
 			return new FieldSignature(
 				fieldType.BindTypeParameters(declaringType),
 				BindTypeParameters(declaringType, optionalCustomModifiers),
 				BindTypeParameters(declaringType, requiredCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="146" endline="153">
<![CDATA[
 
     Overridable Function CreateTypeConversion() As Boolean
         Dim result As Boolean = True
 
         m_RSide = Helper.CreateTypeConversion(Me, m_RSide, m_LSide.ExpressionType, result)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="480" endline="490">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the flattened cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattened(ByVal Name As String, ByVal From As Mono.Cecil.TypeReference) As MemberCacheEntry
         Return LookupFlattened(Name, Helper.GetVisibility(Compiler, From, m_Type))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="107" endline="116">
<![CDATA[
     End Property
 
     ReadOnly Property OperandTypeCode() As TypeCode
         Get
             Dim result As TypeCode
 
             result = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, LeftType, RightType)
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1630" endline="1636">
<![CDATA[
 
 		public static LocalVariable CreateCompilerGenerated (TypeSpec type, Block block, Location loc)
 		{
 			LocalVariable li = new LocalVariable (block, "<$$>", Flags.CompilerGenerated | Flags.Used, loc);
 			li.Type = type;
 			return li;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="203" endline="209">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6915" endline="6924">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (this));
 			
 			// Use typeless constant for ldarg.0 to save some
 			// space and avoid problems with anonymous stories
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="132" endline="139">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = callingConvention;
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="327" endline="333">
<![CDATA[
 
 		public Type[] GetTypes()
 		{
 			List<Type> list = new List<Type>();
 			GetTypesImpl(list);
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\PowerAssignStatement.vb" startline="32" endline="39">
<![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Dim result As Expression = New ExponentExpression(Me, LSide, RSide)
         result = ConversionExpression.GetTypeConversion(Me, result, LSide.ExpressionType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="50" endline="57">
<![CDATA[
 	}
 
 	static class NullableInfo
 	{
 		public static MethodSpec GetConstructor (TypeSpec nullableType)
 		{
 			return TypeManager.GetPredefinedConstructor (nullableType, Location.Null, GetUnderlyingType (nullableType));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="202" endline="237">
<![CDATA[
 
 		public static LineNumberEntry Null = new LineNumberEntry (0, 0, 0);
 
 		private class OffsetComparerClass 
 		{
 			public int Compare (LineNumberEntry l1, LineNumberEntry l2)
 			{
 				if (l1.Offset < l2.Offset)
 					return -1;
 				else if (l1.Offset > l2.Offset)
 					return 1;
 				else
 					return 0;
 			}
 		}
 
 		private class RowComparerClass 
 		{
 			public int Compare (LineNumberEntry l1, LineNumberEntry l2)
 			{
 				if (l1.Row < l2.Row)
 					return -1;
 				else if (l1.Row > l2.Row)
 					return 1;
 				else
 					return 0;
 			}
 		}
 
 		public static readonly IComparer<LineNumberEntry> OffsetComparer = new OffsetComparerClass ();
 		public static readonly IComparer<LineNumberEntry> RowComparer = new RowComparerClass ();
 
 		public override string ToString ()
 		{
 			return String.Format ("[Line {0}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1080" endline="1086">
<![CDATA[
 
     Public Shared Function GetSetMethod(ByVal Prop As PropertyReference) As MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.SetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1073" endline="1079">
<![CDATA[
 
     Public Shared Function GetGetMethod(ByVal Prop As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.GetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="517" endline="524">
<![CDATA[
 
 		public override EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			EmitContext ec = new EmitContext (this, ig, MemberType);
 
 			ec.CurrentAnonymousMethod = host.Iterator;
 			return ec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="39" endline="47">
<![CDATA[
     End Property
 
     Private Function GetTypeAttributes() As Mono.Cecil.TypeAttributes
         Dim result As Mono.Cecil.TypeAttributes
 
         result = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1120" endline="1130">
<![CDATA[
 		
 		public int peek_token ()
 		{
 			int the_token;
 
 			PushPosition ();
 			the_token = token ();
 			PopPosition ();
 			
 			return the_token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="996" endline="1007">
<![CDATA[
 
 		public delegate void Simple ();
 		
 		/// <summary>
 		///   Times the execution of the given delegate
 		/// </summary>
 		static public TimeSpan Time (Simple a)
 		{
 			DateTime start = DateTime.Now;
 			a ();
 			return DateTime.Now - start;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="82" endline="91">
<![CDATA[
 		}
 
 		#endregion
 
 		public Argument Clone (Expression expr)
 		{
 			Argument a = (Argument) MemberwiseClone ();
 			a.Expr = expr;
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="120" endline="128">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             Helper.Assert(TypeOf originalValue Is Date)
             Return originalValue
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2619" endline="2627">
<![CDATA[
 
     Private Function ParseMyClassExpression(ByVal Parent As ParsedObject) As MyClassExpression
         Dim result As MyClassExpression
 
         tm.AcceptIfNotInternalError(KS.MyClass)
         result = New MyClassExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2628" endline="2636">
<![CDATA[
 
     Private Function ParseMyBaseExpression(ByVal Parent As ParsedObject) As MyBaseExpression
         Dim result As MyBaseExpression
 
         tm.AcceptIfNotInternalError(KS.MyBase)
         result = New MyBaseExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2637" endline="2645">
<![CDATA[
 
     Private Function ParseMeExpression(ByVal Parent As ParsedObject) As MeExpression
         Dim result As MeExpression
 
         tm.AcceptIfNotInternalError(KS.Me)
         result = New MeExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="466" endline="473">
<![CDATA[
 
 		public static MonoSymbolFile ReadSymbolFile (Assembly assembly)
 		{
 			string filename = assembly.Location;
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, assembly);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="132" endline="138">
<![CDATA[
 
 		public FlowBranchingTryCatch StartFlowBranching (TryCatch stmt)
 		{
 			FlowBranchingTryCatch branching = new FlowBranchingTryCatch (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="139" endline="145">
<![CDATA[
 
 		public FlowBranchingException StartFlowBranching (ExceptionStatement stmt)
 		{
 			FlowBranchingException branching = new FlowBranchingException (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="146" endline="152">
<![CDATA[
 
 		public FlowBranchingLabeled StartFlowBranching (LabeledStatement stmt)
 		{
 			FlowBranchingLabeled branching = new FlowBranchingLabeled (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4787" endline="4794">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="539" endline="546">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			Report.Debug (2, "  MERGING SIBLINGS", Name);
 			UsageVector vector = UsageVector.MergeSiblings (sibling_list, Location);
 			Report.Debug (2, "  MERGING SIBLINGS DONE", Name, vector);
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="364" endline="373">
<![CDATA[
 
     Private Function ResolveLateBoundArrayInvocation(ByVal Context As ParsedObject) As Boolean
         Dim result As Boolean = True
 
         Classification = New LateBoundAccessClassification(Me, Expression, Nothing, Nothing)
 
         m_IsLateBoundArray = True
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2985" endline="2992">
<![CDATA[
 
     Public Function ParseExpression(ByVal Parent As ParsedObject) As Expression
         Dim result As Expression = Nothing
 
         result = ParseOr_OrElse_Xor(New ExpressionParseInfo(Parent))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="253" endline="260">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="270" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Shows the multiline message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message() As Messages, ByVal Location As Span, ByVal ParamArray Parameters()() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="278" endline="285">
<![CDATA[
 
     ''' <summary>
     ''' Saves the message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function SaveMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(True, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GlobalExpression.vb" startline="36" endline="42">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
 
         Classification = New NamespaceClassification(Me, New GlobalNamespace(Me))
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7049" endline="7055">
<![CDATA[
 		}
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (1952, loc, "An expression tree cannot contain a method with variable arguments");
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1432" endline="1440">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (1945, loc, "An expression tree cannot contain an anonymous method expression");
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="160" endline="166">
<![CDATA[
 
 		public FlowBranchingToplevel StartFlowBranching (ParametersBlock stmt, FlowBranching parent)
 		{
 			FlowBranchingToplevel branching = new FlowBranchingToplevel (parent, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="153" endline="159">
<![CDATA[
 
 		public FlowBranchingIterator StartFlowBranching (Iterator iterator, FlowBranching parent)
 		{
 			FlowBranchingIterator branching = new FlowBranchingIterator (parent, iterator);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="262" endline="268">
<![CDATA[
 		}
 
 		FieldSpec CreateSiteField (EmitContext ec, FullNamedExpression type)
 		{
 			var site_container = ec.CreateDynamicSite ();
 			return site_container.CreateCallSiteField (type, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1313" endline="1324">
<![CDATA[
 		
 		/// <summary>
 		///   Returns the MemberCore associated with a given name in the declaration
 		///   space. It doesn't return method based symbols !!
 		/// </summary>
 		/// 
 		public MemberCore GetDefinition (string name)
 		{
 			MemberCore mc = null;
 			defined_names.TryGetValue (name, out mc);
 			return mc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5782" endline="5788">
<![CDATA[
 		}
 
 		public static TemporaryVariableReference Create (TypeSpec type, Block block, Location loc)
 		{
 			var li = LocalVariable.CreateCompilerGenerated (type, block, loc);
 			return new TemporaryVariableReference (li, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2977" endline="2984">
<![CDATA[
 
     Private Function ParseExpression(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As Expression = Nothing
 
         result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3058" endline="3074">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// When best candidate is already know this factory can be used
 		// to avoid expensive overload resolution to be called
 		//
 		// NOTE
 		//
 		public static MethodGroupExpr CreatePredefined (MethodSpec best, TypeSpec queriedType, Location loc)
 		{
 			return new MethodGroupExpr (best, queriedType, loc) {
 				best_candidate = best,
 				best_candidate_return = best.ReturnType
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="645" endline="651">
<![CDATA[
 
 		public static DynamicInvocation CreateSpecialNameInvoke (ATypeNameExpression member, Arguments args, Location loc)
 		{
 			return new DynamicInvocation (member, args, loc) {
 				flags = CSharpBinderFlags.InvokeSpecialName
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="626" endline="632">
<![CDATA[
 
 		static public Expression Create (ResolveContext ec, MethodGroupExpr mge,
 						 TypeSpec target_type, Location loc)
 		{
 			ImplicitDelegateCreation d = new ImplicitDelegateCreation (target_type, mge, loc);
 			return d.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="423" endline="429">
<![CDATA[
 
 		public ReportPrinter SetPrinter (ReportPrinter printer)
 		{
 			ReportPrinter old = this.printer;
 			this.printer = printer;
 			return old;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="671" endline="677">
<![CDATA[
 		}
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Report.Error (139, loc, "No enclosing loop out of which to break or continue");
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="804" endline="819">
<![CDATA[
 		
 		/// <summary>
 		///   A sentinel value used to indicate that no value was
 		///   was set by the compiled function.   This is used to
 		///   differentiate between a function not returning a
 		///   value and null.
 		/// </summary>
 		public class NoValueSet {
 		}
 
 		static internal Tuple<FieldSpec, FieldInfo> LookupField (string name)
 		{
 			Tuple<FieldSpec, FieldInfo> fi;
 			fields.TryGetValue (name, out fi);
 			return fi;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="331" endline="340">
<![CDATA[
     ''' <summary>
     ''' GotoNewline defaults to false for this overload.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal ParamArray MessageParameters() As String) As Boolean
         Return AcceptIfNotError(Special, Message, False, MessageParameters)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="446" endline="454">
<![CDATA[
 
     Function MakeGenericParameter(ByVal Parent As ParsedObject, ByVal OpenParameter As Mono.Cecil.ParameterReference, ByVal ParameterType As Mono.Cecil.TypeReference) As Mono.Cecil.ParameterReference
         Dim result As Mono.Cecil.ParameterReference
 
         'result = New GenericParameterDescriptor(Parent, ParameterType, OpenParameter)
         result = Nothing 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="381" endline="387">
<![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, CallingConventions.Standard, true, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="169" endline="175">
<![CDATA[
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="328" endline="334">
<![CDATA[
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed |
 					base.TypeAttr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="157" endline="168">
<![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If m_Property Is Nothing Then
                 Helper.Assert(m_Classification IsNot Nothing)
                 Helper.Assert(m_Classification.IsResolved)
                 m_Property = m_Classification.ResolvedProperty
             End If
             Helper.Assert(m_Property IsNot Nothing)
             Return m_Property.PropertyType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="177" endline="184">
<![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="98" endline="108">
<![CDATA[
 
 		public static void Error_InvalidConstantType (TypeSpec t, Location loc, Report Report)
 		{
 			if (t.IsGenericParameter) {
 				Report.Error (1959, loc,
 					"Type parameter `{0}' cannot be declared const", TypeManager.CSharpName (t));
 			} else {
 				Report.Error (283, loc,
 					"The type `{0}' cannot be declared const", TypeManager.CSharpName (t));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="614" endline="638">
<![CDATA[
 
 		/// <summary>
 		///   ReturnValue creates on demand the LocalBuilder for the
 		///   return value from the function.  By default this is not
 		///   used.  This is only required when returns are found inside
 		///   Try or Catch statements.
 		///
 		///   This method is typically invoked from the Emit phase, so
 		///   we allow the creation of a return label if it was not
 		///   requested during the resolution phase.   Could be cleaned
 		///   up, but it would replicate a lot of logic in the Emit phase
 		///   of the code that uses it.
 		/// </summary>
 		public LocalBuilder TemporaryReturn ()
 		{
 			if (return_value == null){
 				return_value = DeclareLocal (return_type, false);
 				if (!HasReturnLabel){
 					ReturnLabel = DefineLabel ();
 					HasReturnLabel = true;
 				}
 			}
 
 			return return_value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="469" endline="484">
<![CDATA[
 
 		//
 		// Makes const data field inside internal type container
 		//
 		public FieldSpec MakeStaticData (byte[] data, Location loc)
 		{
 			if (static_data == null) {
 				static_data = new StaticDataContainer (this);
 				static_data.CreateType ();
 				static_data.DefineType ();
 
 				AddCompilerGeneratedClass (static_data);
 			}
 
 			return static_data.DefineInitializedData (data, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2895" endline="2913">
<![CDATA[
 		}
 
 		// <summary>
 		//   This is used by non-static `struct' constructors which do not have an
 		//   initializer - in this case, the constructor must initialize all of the
 		//   struct's fields.  To do this, we add a "this" variable and use the flow
 		//   analysis code to ensure that it's been fully initialized before control
 		//   leaves the constructor.
 		// </summary>
 		public LocalVariable AddThisVariable (BlockContext bc, TypeContainer ds, Location l)
 		{
 			if (this_variable == null) {
 				this_variable = new LocalVariable (this, "this", LocalVariable.Flags.IsThis | LocalVariable.Flags.Used, l);
 				this_variable.Type = ds.CurrentType;
 				this_variable.PrepareForFlowAnalysis (bc);
 			}
 
 			return this_variable;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="916" endline="924">
<![CDATA[
 
 		protected override bool DoResolveTypeParameters ()
 		{
 			instance_type = spec;
 			if (mutator != null)
 				instance_type = instance_type.MakeGenericType (mutator.MethodTypeParameters.Select (l => l.Type).ToArray ());
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="750" endline="759">
<![CDATA[
     End Property
 
     ReadOnly Property IsAccessible() As Boolean
         Get
             If Resolver.Caller Is Nothing Then
                 Return Helper.IsAccessibleExternal(Compiler, m_Member)
             Else
                 Return Helper.IsAccessible(Compiler, Resolver.Caller.CecilType, m_Member)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3507" endline="3514">
<![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         If Caller Is Nothing Then
             Return Helper.IsAccessible(Context, CecilHelper.FindDefinition(Method).Attributes, Method.DeclaringType)
         Else
             Return Helper.IsAccessible(Context, CecilHelper.FindDefinition(Method).Attributes, Method.DeclaringType, Caller)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="166" endline="181">
<![CDATA[
 
     ''' <summary>
     ''' A label to just before the last ret instruction of the method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property EndOfMethodLabel() As Label
         Get
             If m_EndOfMethodLabel.HasValue Then
                 Return m_EndOfMethodLabel.Value
             Else
                 Helper.Assert(Me IsNot UpmostBlock)
                 Return Me.UpmostBlock.EndOfMethodLabel
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="778" endline="788">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if ((AccessorFirst.ModFlags & (Modifiers.STATIC | Modifiers.COMPILER_GENERATED)) == Modifiers.COMPILER_GENERATED && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (842, Location,
 					"Automatically implemented property `{0}' cannot be used inside a type with an explicit StructLayout attribute",
 					GetSignatureForError ());
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2394" endline="2401">
<![CDATA[
 
 		public override void AddBasesForPart (DeclSpace part, List<FullNamedExpression> bases)
 		{
 			if (part.Name == "System.Object")
 				Report.Error (537, part.Location,
 					"The class System.Object cannot have a base class or implement an interface.");
 			base.AddBasesForPart (part, bases);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="815" endline="826">
<![CDATA[
 
 		//
 		// Returns a string that represents the signature for this 
 		// member which should be used in XML documentation.
 		//
 		public virtual string GetDocCommentName (DeclSpace ds)
 		{
 			if (ds == null || this is DeclSpace)
 				return DocCommentHeader + Name;
 			else
 				return String.Concat (DocCommentHeader, ds.Name, ".", Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="842" endline="850">
<![CDATA[
 
 		internal MethodInfo GetEntryPoint()
 		{
 			if (cliHeader.EntryPointToken != 0 && (cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT) == 0)
 			{
 				return (MethodInfo)ResolveMethod((int)cliHeader.EntryPointToken);
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="52" endline="61">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property AsString() As String
         Get
             If m_TypeArgumentList Is Nothing OrElse m_TypeArgumentList.Count = 0 Then
                 Return m_Identifier.Identifier
             Else
                 Return m_Identifier.Identifier & "(Of <type arguments>)"
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="504" endline="519">
<![CDATA[
 
 		public FieldToken GetFieldToken(FieldInfo field)
 		{
 			// NOTE for some reason, when TypeBuilder.GetFieldToken() is used on a field in a generic type definition,
 			// a memberref token is returned (confirmed on .NET) unlike for Get(Method|Constructor)Token which always
 			// simply returns the MethodDef token (if the method is from the same module).
 			FieldBuilder fb = field as FieldBuilder;
 			if (fb != null && fb.Module == this && !IsFromGenericTypeDefinition(fb))
 			{
 				return new FieldToken(fb.MetadataToken);
 			}
 			else
 			{
 				return new FieldToken(ImportMember(field));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="1169" endline="1179">
<![CDATA[
 
 		public bool CheckExistingMembersOverloads (MemberCore member, AParametersCollection parameters)
 		{
 			var name = GetLookupName (member);
 			var imb = member as InterfaceMemberBase;
 			if (imb != null && imb.IsExplicitImpl) {
 				name = imb.GetFullName (name);
 			}
 
 			return CheckExistingMembersOverloads (member, name, parameters);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="894" endline="910">
<![CDATA[
 
     ''' <summary>
     ''' Emits a constrained callvirt instructions. 
     ''' Throws an exception if the method is a shared method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitConstrainedCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference, ByVal ConstrainedType As Mono.Cecil.TypeReference)
         Dim OriginalMethod As Mono.Cecil.MethodReference = Method
 
         Helper.Assert(Method IsNot Nothing)
         Helper.Assert(ConstrainedType IsNot Nothing)
 
         EmitConstrained(Info, ConstrainedType)
         EmitCallVirt(Info, Method)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="278" endline="286">
<![CDATA[
     End Property
 
     ReadOnly Property IsNestedType() As Boolean Implements IType.IsNestedType
         Get
             Dim result As Boolean
             result = DeclaringType IsNot Nothing
             Helper.Assert(result = (Me.FindFirstParent(Of IType)() IsNot Nothing))
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4984" endline="4996">
<![CDATA[
 
 		public override void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			//
 			// ParameterReferences might already be a reference
 			//
 			if (IsRef) {
 				EmitLoad (ec);
 				return;
 			}
 
 			base.AddressOf (ec, mode);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="175" endline="196">
<![CDATA[
 
 		/// <summary>
 		///   The base class for the classes that host the user generated code
 		/// </summary>
 		/// <remarks>
 		///
 		///   This is the base class that will host the code
 		///   executed by the Evaluator.  By default
 		///   this is the Mono.CSharp.InteractiveBase class
 		///   which is useful for interactive use.
 		///
 		///   By changing this property you can control the
 		///   base class and the static members that are
 		///   available to your evaluated code.
 		/// </remarks>
 		static public TypeSpec InteractiveBaseClass {
 			get {
 				if (interactive_base_class != null)
 					return interactive_base_class;
 
 				return loader.Importer.ImportType (typeof (InteractiveBase));
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="127" endline="134">
<![CDATA[
 
     Shared Sub EmitBranchOrLeave(ByVal Info As EmitInfo, ByVal Label As Label, ByVal FromStatement As Statement, ByVal ToStatement As Statement)
         If IsLeaveNecessary(FromStatement, ToStatement) Then
             EmitLeave(Info, Label)
         Else
             EmitBranch(Info, Label)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="272" endline="279">
<![CDATA[
 
     Shared Sub EmitMultOrMultOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitMultOvf(Info, OperandType)
         Else
             EmitMult(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="249" endline="256">
<![CDATA[
 
     Shared Sub EmitAddOrAddOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitAddOvf(Info, OperandType)
         Else
             EmitAdd(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="154" endline="161">
<![CDATA[
 
     Shared Sub EmitSubOrSubOvfOrSubOvfUn(ByVal Info As EmitInfo, ByVal SubType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitSubOvf(Info, SubType)
         Else
             EmitSub(Info, SubType)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1514" endline="1521">
<![CDATA[
 
 		public MyBitVector (MyBitVector InheritsFrom, int Count)
 		{
 			if (InheritsFrom != null)
 				shared = InheritsFrom.MakeShared (Count);
 
 			this.Count = Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5888" endline="5895">
<![CDATA[
 
 		protected override void Error_TypeOrNamespaceNotFound (IMemberContext ec)
 		{
 			if (RootContext.Version < LanguageVersion.V_3)
 				base.Error_TypeOrNamespaceNotFound (ec);
 			else
 				ec.Compiler.Report.Error (825, loc, "The contextual keyword `var' may only appear within a local variable declaration");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="245" endline="256">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns true if the method group has successfully been resolved.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property SuccessfullyResolved() As Boolean
         Get
             Return m_Resolved AndAlso (m_Group.Count = 1 OrElse m_Resolver.IsLateBound)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="68" endline="76">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializer
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializer(NewParent)
         If m_IdentifierOrKeyword IsNot Nothing Then result.m_IdentifierOrKeyword = m_IdentifierOrKeyword.Clone(result)
         If m_AttributeArgumentExpression IsNot Nothing Then result.m_AttributeArgumentExpression = m_AttributeArgumentExpression.Clone(result)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="42" endline="50">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArguments
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArguments(NewParent)
         If m_AttributePositionalArgumentList IsNot Nothing Then result.m_AttributePositionalArgumentList = m_AttributePositionalArgumentList.clone(result)
         If m_VariablePropertyInitializerList IsNot Nothing Then result.m_VariablePropertyInitializerList = m_VariablePropertyInitializerList.clone(result)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="62" endline="74">
<![CDATA[
     End Property
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleNameExpression(NewParent)
         If m_TypeArgumentList Is Nothing Then
             result.Init(m_Identifier, Nothing)
         Else
             result.Init(m_Identifier, m_TypeArgumentList.Clone(result))
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="72" endline="87">
<![CDATA[
 
     ''' <summary>
     ''' The returned object will always be a function signature.
     ''' </summary>
     ''' <param name="NewParent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SubSignature
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New FunctionSignature(NewParent)
         MyBase.CloneTo(result)
         If m_ReturnTypeAttributes IsNot Nothing Then result.m_ReturnTypeAttributes = m_ReturnTypeAttributes.clone(result)
         result.m_ReturnType = m_ReturnType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="49" endline="56">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArraySizeInitializationModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArraySizeInitializationModifier(NewParent)
         result.m_BoundList = m_BoundList.Clone(result)
         If m_ArrayTypeModifiers IsNot Nothing Then result.m_ArrayTypeModifiers = m_ArrayTypeModifiers.Clone(result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="40" endline="47">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Constraint
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New Constraint(NewParent)
         If m_TypeName IsNot Nothing Then result.m_TypeName = m_TypeName.Clone(result)
         result.m_Special = m_Special
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="444" endline="458">
<![CDATA[
 		}
 
 		public Type Import(System.Type type)
 		{
 			Type imported;
 			if (!importedTypes.TryGetValue(type, out imported))
 			{
 				imported = ImportImpl(type);
 				if (imported != null)
 				{
 					importedTypes.Add(type, imported);
 				}
 			}
 			return imported;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="527" endline="536">
<![CDATA[
 		}
 
 		public override bool Equals (object obj)
 		{
 			AbstractMessage msg = obj as AbstractMessage;
 			if (msg == null)
 				return false;
 
 			return code == msg.code && location.Equals (msg.location) && message == msg.message;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1418" endline="1428">
<![CDATA[
 
 		public static ReferenceContainer MakeType (TypeSpec element)
 		{
 			ReferenceContainer pc;
 			if (!instances.TryGetValue (element, out pc)) {
 				pc = new ReferenceContainer (element);
 				instances.Add (element, pc);
 			}
 
 			return pc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1460" endline="1470">
<![CDATA[
 
 		public static PointerContainer MakeType (TypeSpec element)
 		{
 			PointerContainer pc;
 			if (!instances.TryGetValue (element, out pc)) {
 				pc = new PointerContainer (element);
 				instances.Add (element, pc);
 			}
 
 			return pc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="27" endline="34">
<![CDATA[
         Get
             Dim result As String = ""
             If m_PropertyGroup.InstanceExpression IsNot Nothing Then
                 result = m_PropertyGroup.InstanceExpression.AsString & "."
             End If
             result &= m_PropertyGroup.Group(0).Name
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="406" endline="413">
<![CDATA[
 
     Public Overrides Function Equals(ByVal obj As Object) As Boolean
         If TypeOf obj Is Token Then
             Return Equals(DirectCast(obj, Token))
         Else
             Throw New InternalException()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="530" endline="539">
<![CDATA[
 
 		/// <summary>
 		/// Checks for ObsoleteAttribute presence. It's used for testing of all non-types elements
 		/// </summary>
 		public virtual void CheckObsoleteness (Location loc)
 		{
 			ObsoleteAttribute oa = GetAttributeObsolete ();
 			if (oa != null)
 				AttributeTester.Report_ObsoleteMessage (oa, GetSignatureForError (), loc, Report);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1153" endline="1161">
<![CDATA[
 
 		public Type __MakeGenericType(Type[] typeArguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			if (!this.IsGenericTypeDefinition)
 			{
 				throw new InvalidOperationException();
 			}
 			return GenericTypeInstance.Make(this, Util.Copy(typeArguments), Util.Copy(requiredCustomModifiers), Util.Copy(optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="56" endline="64">
<![CDATA[
 		}
 
 		private void PatchCallingConvention(MethodBuilder mdBuilder)
 		{
 			if (patchCallingConvention && !mdBuilder.IsStatic)
 			{
 				sig.HasThis = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="556" endline="565">
<![CDATA[
 
 		[Conditional ("FULL_AST")]
 		public void AppendToMember (MemberCore existing, params Location[] locations)
 		{
 			MemberLocations member;
 			if (member_locs.TryGetValue (existing, out member)) {
 				member.AddLocations (locations);
 				return;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="281" endline="287">
<![CDATA[
 
 		public override void DefineConstants ()
 		{
 			if (!Parameters.IsEmpty) {
 				parameters.ResolveDefaultValues (this);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="71" endline="78">
<![CDATA[
 
 		public void Dispose()
 		{
 			if (!imported)
 			{
 				module.stream.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="87" endline="98">
<![CDATA[
 
 		public void AddFile (SourceFile file)
 		{
 			if (file == this)
 				return;
 			
 			if (include_files == null)
 				include_files = new Dictionary<string, SourceFile> ();
 
 			if (!include_files.ContainsKey (file.Path))
 				include_files.Add (file.Path, file);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="36" endline="57">
<![CDATA[
 		{
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					builder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="466" endline="483">
<![CDATA[
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			PropertyBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1312" endline="1323">
<![CDATA[
 
 		public int CompareTo (object obj)
 		{
 			MethodEntry method = (MethodEntry) obj;
 
 			if (method.Token < Token)
 				return 1;
 			else if (method.Token > Token)
 				return -1;
 			else
 				return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="210" endline="222">
<![CDATA[
 
 		internal static bool TypeEquals(Type t1, Type t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return false;
 			}
 			return t1.Equals(t2);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1463" endline="1474">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// Only boxing to object type is supported
 			if (targetType != TypeManager.object_type) {
 				base.EncodeAttributeValue (rc, enc, targetType);
 				return;
 			}
 
 			enc.Encode (child.Type);
 			child.EncodeAttributeValue (rc, enc, child.Type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1993" endline="2002">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2336" endline="2345">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="133" endline="139">
<![CDATA[
 
     Overloads Sub Add(ByVal ns As [Namespace])
         If Not ContainsKey(ns.Name) Then
             MyBase.Add(ns)
             m_Hashed.Add(ns.Name, ns)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5873" endline="5882">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			New target = (New) t;
 
 			target.RequestedType = RequestedType.Clone (clonectx);
 			if (arguments != null){
 				target.arguments = arguments.Clone (clonectx);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="671" endline="682">
<![CDATA[
 		}
 
 		protected override void SetMemberName (MemberName new_name)
 		{
 			base.SetMemberName (new_name);
 
 			if (Get != null)
 				Get.UpdateName (this);
 
 			if (Set != null)
 				Set.UpdateName (this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="712" endline="721">
<![CDATA[
 
 		protected virtual void Dispose (bool disposing)
 		{
 			if (disposing) {
 				if (reader != null) {
 					reader.Close ();
 					reader = null;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1701" endline="1712">
<![CDATA[
 
 		public void PrepareForFlowAnalysis (BlockContext bc)
 		{
 			//
 			// No need for definitely assigned check for these guys
 			//
 			if ((flags & (Flags.Constant | Flags.ReadonlyMask | Flags.CompilerGenerated)) != 0)
 				return;
 
 			VariableInfo = new VariableInfo (this, bc.FlowOffset);
 			bc.FlowOffset += VariableInfo.Length;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2379" endline="2398">
<![CDATA[
 		}
 
 		protected ParametersCompiled parameters;
 		protected ParameterInfo[] parameter_info;
 		bool resolved;
 		protected bool unreachable;
 		protected ToplevelBlock top_block;
 
 		public ParametersBlock (Block parent, ParametersCompiled parameters, Location start)
 			
 		{
 			if (parameters == null)
 				throw new ArgumentNullException ("parameters");
 
 			this.parameters = parameters;
 			ParametersBlock = this;
 
 			this.top_block = parent.ParametersBlock.top_block;
 			ProcessParameters ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1229" endline="1238">
<![CDATA[
 		public EmptyConstantCast (Constant child, TypeSpec type)
 			
 		{
 			if (child == null)
 				throw new ArgumentNullException ("child");
 
 			this.child = child;
 			this.eclass = child.eclass;
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1235" endline="1254">
<![CDATA[
 	}
 
 	//
 	// Before emitting any code we have to change all MVAR references to VAR
 	// when the method is of generic type and has hoisted variables
 	//
 	public class TypeParameterMutator
 	{
 		TypeParameter[] mvar;
 		TypeParameter[] var;
 		Dictionary<TypeSpec, TypeSpec> mutated_typespec = new Dictionary<TypeSpec, TypeSpec> ();
 
 		public TypeParameterMutator (TypeParameter[] mvar, TypeParameter[] var)
 		{
 			if (mvar.Length != var.Length)
 				throw new ArgumentException ();
 
 			this.mvar = mvar;
 			this.var = var;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2399" endline="2408">
<![CDATA[
 
 		protected ParametersBlock (ParametersCompiled parameters, Location start)
 			
 		{
 			if (parameters == null)
 				throw new ArgumentNullException ("parameters");
 
 			this.parameters = parameters;
 			ParametersBlock = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="50" endline="83">
<![CDATA[
 		List<string> extra_information = new List<string> ();
 
 		// 
 		// IF YOU ADD A NEW WARNING YOU HAVE TO ADD ITS ID HERE
 		//
 		public static readonly int[] AllWarnings = new int[] {
 			28, 67, 78,
 			105, 108, 109, 114, 162, 164, 168, 169, 183, 184, 197,
 			219, 251, 252, 253, 278, 282,
 			402, 414, 419, 420, 429, 436, 440, 458, 464, 465, 467, 469, 472,
 			612, 618, 626, 628, 642, 649, 652, 658, 659, 660, 661, 665, 672, 675, 693,
 			728,
 			809,
 			1030, 1058, 1066,
 			1522, 1570, 1571, 1572, 1573, 1574, 1580, 1581, 1584, 1587, 1589, 1590, 1591, 1592,
 			1607, 1616, 1633, 1634, 1635, 1685, 1690, 1691, 1692, 1695, 1696, 1699, 1683,
 			1700, 1701, 1702, 1709, 1717, 1718, 1720,
 			1901, 1981,
 			2002, 2023, 2029,
 			3000, 3001, 3002, 3003, 3005, 3006, 3007, 3008, 3009,
 			3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019,
 			3021, 3022, 3023, 3024, 3026, 3027
 		};
 
 		static HashSet<int> AllWarningsHashSet;
 
 		public Report (ReportPrinter printer)
 		{
 			if (printer == null)
 				throw new ArgumentNullException ("printer");
 
 			this.printer = printer;
 			warning_level = 4;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1113" endline="1122">
<![CDATA[
 
 		public TypeParameterInflator (TypeSpec type, TypeParameterSpec[] tparams, TypeSpec[] targs)
 		{
 			if (tparams.Length != targs.Length)
 				throw new ArgumentException ("Invalid arguments");
 
 			this.tparams = tparams;
 			this.targs = targs;
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="39" endline="45">
<![CDATA[
 		internal GenericMethodInstance(Type declaringType, MethodInfo method, Type[] methodArgs)
 		{
 			System.Diagnostics.Debug.Assert(!(method is GenericMethodInstance));
 			this.declaringType = declaringType;
 			this.method = method;
 			this.methodArgs = methodArgs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="646" endline="654">
<![CDATA[
 
 		private void WriteToken(FieldToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="655" endline="663">
<![CDATA[
 
 		private void WriteToken(MethodToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="62" endline="71">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As ParameterList)
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = Parameters
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="34" endline="40">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_CustomAttributes IsNot Nothing Then m_CustomAttributes.Initialize(Me)
         Helper.Assert(m_Name IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="92" endline="101">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList)
         m_Identifier = Identifier
         m_TypeParameters = TypeParameters
         If ParameterList Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = ParameterList
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2151" endline="2158">
<![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         If m_SharedCompilers.Contains(Compiler) = False Then
             m_SharedCompilers.Add(Compiler)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="81" endline="87">
<![CDATA[
 
     Protected Sub Rename(ByVal Name As String)
         m_Name = Name
         If MemberDescriptor IsNot Nothing Then
             MemberDescriptor.Name = m_Name
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1121" endline="1128">
<![CDATA[
 
 		public OperatorCast (Expression child, TypeSpec target_type, bool find_explicit)
 			
 		{
 			conversion_operator = GetConversionOperator (find_explicit);
 			if (conversion_operator == null)
 				throw new InternalErrorException ("Outer conversion routine is out of sync");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="431" endline="449">
<![CDATA[
 		}
 	}
 
 	public class GroupBy 
 	{
 		Expression element_selector;
 		QueryBlock element_block;
 
 		public GroupBy (QueryBlock block, Expression elementSelector, QueryBlock elementBlock, Expression keySelector, Location loc)
 			
 		{
 			//
 			// Optimizes clauses like `group A by A'
 			//
 			if (!elementSelector.Equals (keySelector)) {
 				this.element_selector = elementSelector;
 				this.element_block = elementBlock;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9022" endline="9034">
<![CDATA[
 	}
 
 	//
 	// Encapsulates a conversion rules required for array indexes
 	//
 	public class ArrayIndexCast 
 	{
 		public ArrayIndexCast (Expression expr)
 			
 		{
 			if (expr.Type == TypeManager.int32_type)
 				throw new ArgumentException ("unnecessary array index conversion");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="512" endline="521">
<![CDATA[
 
 		public override void Emit ()
 		{
 			EmitConstraints (builder);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamespaceExpression.vb" startline="33" endline="39">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal ns As [Namespace])
         MyBase.New(Parent)
         If ns Is Nothing Then Throw New InternalException(Me)
         m_NS = ns
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="747" endline="756">
<![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9517" endline="9524">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			base.CloneTo (clonectx, t);
 
 			NewInitialize target = (NewInitialize) t;
 			target.initializers = (CollectionOrObjectInitializers) initializers.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="464" endline="474">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			GroupBy t = (GroupBy) target;
 			if (element_selector != null) {
 				t.element_selector = element_selector.Clone (clonectx);
 				t.element_block = (QueryBlock) element_block.Clone (clonectx);
 			}
 
 			base.CloneTo (clonectx, t);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="513" endline="520">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			Join t = (Join) target;
 			t.inner_selector = (QueryBlock) inner_selector.Clone (clonectx);
 			t.outer_selector = (QueryBlock) outer_selector.Clone (clonectx);
 			base.CloneTo (clonectx, t);
 		}	
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4518" endline="4526">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Conditional target = (Conditional) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.true_expr = true_expr.Clone (clonectx);
 			target.false_expr = false_expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5755" endline="5763">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Foreach target = (Foreach) t;
 
 			target.type = type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="761" endline="768">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompoundAssign ctarget = (CompoundAssign) t;
 
 			ctarget.right = ctarget.source = source.Clone (clonectx);
 			ctarget.target = target.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4620" endline="4627">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Fixed target = (Fixed) t;
 
 			target.decl = (VariableDeclaration) decl.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5162" endline="5169">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Using target = (Using) t;
 
 			target.decl = (VariableDeclaration) decl.Clone (clonectx);
 			target.stmt = stmt.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="402" endline="409">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Assign _target = (Assign) t;
 
 			_target.target = target.Clone (clonectx);
 			_target.source = source.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1606" endline="1613">
<![CDATA[
 		
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Cast target = (Cast) t;
 
 			target.target_type = target_type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1199" endline="1206">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			NullCoalescingOperator target = (NullCoalescingOperator) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1278" endline="1287">
<![CDATA[
 
 		protected abstract string OperatorName { get; }
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Probe target = (Probe) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.ProbeType = ProbeType.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="329" endline="336">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Do target = (Do) t;
 
 			target.EmbeddedStatement = EmbeddedStatement.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3862" endline="3869">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Binary target = (Binary) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="443" endline="450">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			While target = (While) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.Statement = Statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="177" endline="185">
<![CDATA[
 
 		internal ByteReader Slice(int length)
 		{
 			if (end - pos < length)
 				throw new BadImageFormatException();
 			ByteReader br = new ByteReader(buffer, pos, length);
 			pos += length;
 			return br;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="211" endline="218">
<![CDATA[
 
 		public int Read ()
 		{
 			if ((pos >= char_count) && !ReadBuffer ())
 				return -1;
 
 			return buffer [pos++];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1391" endline="1398">
<![CDATA[
 
 		public void Encode (byte value)
 		{
 			if (pos == buffer.Length)
 				Grow (1);
 
 			buffer [pos++] = value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="94" endline="100">
<![CDATA[
 
 		internal void Write(byte value)
 		{
 			if (pos == buffer.Length)
 				Grow(1);
 			buffer[pos++] = value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="181" endline="188">
<![CDATA[
 
 		public static void OpenCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.OpenCompilerGeneratedBlock (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="189" endline="196">
<![CDATA[
 
 		public static void CloseCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.CloseCompilerGeneratedBlock (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="197" endline="204">
<![CDATA[
 
 		public static void StartIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorBody (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="205" endline="212">
<![CDATA[
 
 		public static void EndIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorBody (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="213" endline="220">
<![CDATA[
 
 		public static void StartIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorDispatcher (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="221" endline="228">
<![CDATA[
 
 		public static void EndIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorDispatcher (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="84" endline="93">
<![CDATA[
 		}
 
 		public static MonoSymbolWriter symwriter;
 
 		public static void DefineLocalVariable (string name, LocalBuilder builder)
 		{
 			if (symwriter != null) {
 				symwriter.DefineLocalVariable (builder.LocalIndex, name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="142" endline="148">
<![CDATA[
 
 		public static void DefineScopeVariable (int scope, LocalBuilder builder)
 		{
 			if (symwriter != null) {
 				symwriter.DefineScopeVariable (scope, builder.LocalIndex);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7242" endline="7249">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="238" endline="261">
<![CDATA[
 
     ''' <summary>
     ''' Call StartResolve to enable check for recursive resolving.
     ''' Call EndResolve when finished resolving.
     ''' </summary>
     ''' <remarks></remarks>
     Protected Sub StartResolve()
         If m_Resolving Then
             'Recursive resolution.
             'TODO
             Throw New InternalException(Me)
         End If
         m_Resolving = True
 #If EXTENDEDDEBUG Then
         If Me.TypeReferencesResolved = False Then
             Compiler.Report.WriteLine("TypeReferences not resolved for expression  " & Me.ToString)
         End If
 #End If
 #If EXTENDEDDEBUG Then
         If m_Resolved Then
             Compiler.Report.WriteLine("Resolving expression " & Me.ToString & " more than once (Location
         End If
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="383" endline="401">
<![CDATA[
 
 		//
 		// 15.2 Delegate compatibility
 		//
 		public static bool IsTypeCovariant (Expression a, TypeSpec b)
 		{
 			//
 			// For each value parameter (a parameter with no ref or out modifier), an 
 			// identity conversion or implicit reference conversion exists from the
 			// parameter type in D to the corresponding parameter type in M
 			//
 			if (a.Type == b)
 				return true;
 
 			if (RootContext.Version == LanguageVersion.ISO_1)
 				return false;
 
 			return Convert.ImplicitReferenceConversionExists (a, b);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="433" endline="446">
<![CDATA[
 		}
 
 		public bool MustCaptureVariable (INamedBlockVariable local)
 		{
 			if (CurrentAnonymousMethod == null)
 				return false;
 
 			// FIXME
 			// block contains yield
 			if (CurrentAnonymousMethod.IsIterator)
 				return true;
 
 			return local.Block.ParametersBlock != CurrentBlock.ParametersBlock.Original;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1204" endline="1215">
<![CDATA[
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			// TODO
 			if (overload is Operator)
 				return overload.EnableOverloadChecks (this);
 
 			if (overload is Indexer)
 				return false;
 
 			return base.EnableOverloadChecks (overload);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1427" endline="1439">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (this.type == type) {
 				return this;
 			}
 
 			if (!Convert.ImplicitStandardConversionExists (this, type)){
 				return null;
 			}
 
 			return Child.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="819" endline="829">
<![CDATA[
 
 		static string GetLookupName (MemberCore mc)
 		{
 			if (mc is Indexer)
 				return IndexerNameAlias;
 
 			if (mc is Constructor)
 				return Constructor.ConstructorName;
 
 			return mc.MemberName.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2675" endline="2688">
<![CDATA[
 
 		static bool IsSameOrBaseQualifier (TypeSpec type, TypeSpec qtype)
 		{
 			do {
 				type = type.GetDefinition ();
 
 				if (type == qtype || TypeManager.IsFamilyAccessible (qtype, type))
 					return true;
 
 				type = type.DeclaringType;
 			} while (type != null);
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="422" endline="439">
<![CDATA[
 
 		//
 		// A special method to work with member lookup only. It returns a list of all members named @name
 		// starting from @container. It's very performance sensitive
 		//
 		public static IList<MemberSpec> FindMembers (TypeSpec container, string name, bool declaredOnly)
 		{
 			IList<MemberSpec> applicable;
 
 			do {
 				if (container.MemberCache.member_hash.TryGetValue (name, out applicable) || declaredOnly)
 					return applicable;
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="154" endline="169">
<![CDATA[
 		}
 
 		// TODO
 		// IsGenericType -- recursive
 		// HasTypeParameter -- non-recursive
 		public bool IsGenericOrParentIsGeneric {
 			get {
 				var ts = this;
 				do {
 					if (ts.IsGeneric)
 						return true;
 					ts = ts.declaringType;
 				} while (ts != null);
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="935" endline="941">
<![CDATA[
 
     Public Shared Function IsGenericMethod(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         If TypeOf Method Is Mono.Cecil.GenericInstanceMethod Then Return True
         If Method.GenericParameters.Count > 0 Then Return True
         Return False
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="947" endline="953">
<![CDATA[
 
     'Cecil's ValueType property returns true for arrays of value types
     Public Shared Function IsValueType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If TypeOf Type Is ArrayType Then Return False
         If TypeOf Type Is ByReferenceType Then Return False
         Return Type.IsValueType
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="634" endline="645">
<![CDATA[
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="377" endline="385">
<![CDATA[
 #endif
 		protected virtual Expression ResolveConversions (ResolveContext ec)
 		{
 			source = Convert.ImplicitConversionRequired (ec, source, target.Type, loc);
 			if (source == null)
 				return null;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1611" endline="1626">
<![CDATA[
 
     ''' <summary>
     ''' Calculates the actual parameter position of the parameter.
     ''' Ready to send to ILGenerator.Emit(...)
     ''' </summary>
     ''' <param name="Parameter"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetParameterPosition(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition) As Integer
         Dim position As Integer = Parameter.Index
         Dim member As IMethodSignature = Parameter.Method
         If member.HasThis Then
             position += 1
         End If
         Return position
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1255" endline="1266">
<![CDATA[
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="97" endline="112">
<![CDATA[
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			bool res = base.CheckOverrideAgainstBase (base_member);
 
 			//
 			// Check that the permissions are not being changed
 			//
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				res = false;
 			}
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="54" endline="61">
<![CDATA[
 
 		#region IEquatable<Tuple<T1,T2>> Members
 
 		public bool Equals (Tuple<T1, T2> other)
 		{
 			return EqualityComparer<T1>.Default.Equals (Item1, other.Item1) &&
 				EqualityComparer<T2>.Default.Equals (Item2, other.Item2);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="534" endline="550">
<![CDATA[
 	
 	static string GetTypeVisibility (Type t)
 	{
                 switch (t.Attributes & TypeAttributes.VisibilityMask){
                 case TypeAttributes.Public
                 case TypeAttributes.NestedPublic
                         return "public";
 
                 case TypeAttributes.NestedFamily
                 case TypeAttributes.NestedFamANDAssem
                 case TypeAttributes.NestedFamORAssem
                         return "protected";
 
                 default
                         return "internal";
                 }
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="826" endline="832">
<![CDATA[
 
 		public void ImportTypeBase (MetaType type)
 		{
 			TypeSpec spec = import_cache[type];
 			if (spec != null)
 				ImportTypeBase (spec, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="322" endline="328">
<![CDATA[
 
 		internal void Write (MonoSymbolFile file, MyBinaryWriter bw)
 		{
 			bw.WriteLeb128 (Index);
 			bw.Write (Name);
 			bw.WriteLeb128 (BlockIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="366" endline="372">
<![CDATA[
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			bw.Write (Name);
 			bw.Write (CapturedName);
 			bw.Write ((byte) Kind);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="127" endline="133">
<![CDATA[
 
 		internal void WriteParamRecord(MetadataWriter mw)
 		{
 			mw.Write(flags);
 			mw.Write(sequence);
 			mw.WriteStringIndex(nameIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4242" endline="4249">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Lock target = (Lock) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.stmt = Statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9130" endline="9136">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			StackAlloc target = (StackAlloc) t;
 			target.count = count.Clone (clonectx);
 			target.t = t.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8223" endline="8231">
<![CDATA[
 
 		//
 		// Load the array arguments into the stack.
 		//
 		void LoadArrayAndArguments (EmitContext ec)
 		{
 			ea.Expr.Emit (ec);
 			ea.Arguments.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="134" endline="140">
<![CDATA[
 
 		public void __SetAssemblyVersion(Version version)
 		{
 			AssemblyName oldName = GetName();
 			SetVersionHelper(version);
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="162" endline="168">
<![CDATA[
 
 		public static void DefineCapturedParameter (int scope_id, string name,
 							    string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedParameter (scope_id, name, captured_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="155" endline="161">
<![CDATA[
 
 		public static void DefineCapturedLocal (int scope_id, string name,
 							string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedLocal (scope_id, name, captured_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="361" endline="367">
<![CDATA[
 
 		public static void Error_TypeDoesNotContainDefinition (ResolveContext ec, Location loc, TypeSpec type, string name)
 		{
 			ec.Report.SymbolRelatedToPreviousError (type);
 			ec.Report.Error (117, loc, "`{0}' does not contain a definition for `{1}'",
 				TypeManager.CSharpName (type), name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="242" endline="248">
<![CDATA[
 
 		public static void Error_VariableOfStaticClass (Location loc, string variable_name, TypeSpec static_class, Report Report)
 		{
 			Report.SymbolRelatedToPreviousError (static_class);
 			Report.Error (723, loc, "`{0}'
 				variable_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3374" endline="3383">
<![CDATA[
 
 		//
 		// Checks if there was incorrect doc comments and raise
 		// warnings.
 		//
 		public void check_incorrect_doc_comment ()
 		{
 			if (xml_comment_buffer.Length > 0)
 				warn_incorrect_doc_comment ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3384" endline="3398">
<![CDATA[
 
 		//
 		// Raises a warning when tokenizer found incorrect doccomment
 		// markup.
 		//
 		private void warn_incorrect_doc_comment ()
 		{
 			if (doc_state != XmlCommentState.Error) {
 				doc_state = XmlCommentState.Error;
 				// in csc, it is 'XML comment is not placed on 
 				// a valid language element'. But that does not
 				// make sense.
 				Report.Warning (1587, 2, Location, "XML comment is not placed on a valid language element");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="119" endline="126">
<![CDATA[
 
 		public static void CloseScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				symwriter.CloseScope (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="270" endline="279">
<![CDATA[
 
     Shared Function IsOnMono() As Boolean
         Dim t As Type = GetType(Integer)
 
         If t.GetType().ToString = "System.MonoType" Then
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="214" endline="225">
<![CDATA[
     End Property
 
     ReadOnly Property AsSpecial() As KS
         Get
             If IsKeyword() Then
                 Return Keyword
             ElseIf IsSymbol() Then
                 Return Symbol
             Else
                 Return KS.None
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="96" endline="107">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             ElseIf Me.IsSimpleTypeName Then
                 Return AsSimpleTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="191" endline="200">
<![CDATA[
 
     Overrides Function ToString() As String
         If IsConstructedTypeName Then
             Return AsConstructedTypeName.Name
         ElseIf IsSimpleTypeName Then
             Return AsSimpleTypeName.Name
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="124" endline="135">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsBuiltInTypeName Then
                 Return AsBuiltInTypeName.Name
             ElseIf IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="136" endline="153">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The namespace or type that is imported.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             If IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             ElseIf IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="456" endline="471">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIntegerLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIntegerLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="446" endline="455">
<![CDATA[
 
     Function AcceptStringLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsStringLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="429" endline="445">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if the current token is an identifier
     ''' and advances to the next token.
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIdentifier(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIdentifier Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3213" endline="3219">
<![CDATA[
 
 		#region IBaseMembersProvider Members
 
 		public virtual IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="161" endline="167">
<![CDATA[
 		}
 
 		public override bool Equals(object obj)
 		{
 			AssemblyName other = obj as AssemblyName;
 			return other != null && other.FullName == this.FullName;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4781" endline="4787">
<![CDATA[
 		}
 
 		public bool IsHoisted {
 			get {
 				IVariableReference hv = InstanceExpression as IVariableReference;
 				return hv != null && hv.IsHoisted;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2088" endline="2094">
<![CDATA[
 
 		#region Properties
 
 		protected int Arity {
 			get {
 				return targs == null ? 0 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="270" endline="279">
<![CDATA[
 		}
 
 		int CurrentTypeParametersStartIndex {
 			get {
 				int total = all_tp_builders.Length;
 				if (CurrentTypeParameters != null) {
 					return total - CurrentTypeParameters.Length;
 				}
 				return total;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="246" endline="255">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			If target = (If) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.TrueStatement = TrueStatement.Clone (clonectx);
 			if (FalseStatement != null)
 				target.FalseStatement = FalseStatement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="684" endline="692">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement stmt)
 		{
 			vector = vector.Clone ();
 			vector.Location = stmt.loc;
 			vector.Next = return_origins;
 			return_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1651" endline="1657">
<![CDATA[
 
 		#region Properties
 
 		public IAssemblyDefinition DeclaringAssembly {
 			get {
 				return importer.GetAssemblyDefinition (provider.Module.Assembly);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="449" endline="456">
<![CDATA[
 
 		public override MemberInfo Member
 		{
 			get
 			{
 				// return the right ConstructorInfo wrapper
 				return method.Module.ResolveMethod(method.MetadataToken);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BuiltInTypeExpression.vb" startline="41" endline="47">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
 
             'Return New TypeDescriptor(TypeResolution.BuiltInTypeToType(m_Type))
             Return Compiler.TypeResolution.BuiltInTypeToType(m_Type)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2758" endline="2764">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			TypeExpr[] ifaces = base.ResolveBaseTypes (out base_class);
 			base_type = TypeManager.value_type;
 			return ifaces;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2078" endline="2084">
<![CDATA[
 
 		#region Properties
 
 		public bool IsCompound {
 			get {
 				return (state & State.Compound) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="988" endline="997">
<![CDATA[
 		}
 
 		//
 		// Return true when this member is a generic in C# terms
 		// A nested non-generic type of generic type will return false
 		//
 		public bool IsGeneric {
 			get {
 				return (state & StateFlags.IsGeneric) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2165" endline="2172">
<![CDATA[
 
 		/// <summary>
 		/// Method container contains Equals method
 		/// </summary>
 		public bool HasEquals {
 			get {
 				return (cached_method & CachedMethods.Equals) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2173" endline="2181">
<![CDATA[
 		}
  
 		/// <summary>
 		/// Method container contains GetHashCode method
 		/// </summary>
 		public bool HasGetHashCode {
 			get {
 				return (cached_method & CachedMethods.GetHashCode) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2423" endline="2432">
<![CDATA[
 
 		#region Properties
 
 		//
 		// Block has been converted to expression tree
 		//
 		public bool IsExpressionTree {
 			get {
 				return (flags & Flags.IsExpressionTree) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="253" endline="267">
<![CDATA[
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="562" endline="571">
<![CDATA[
 
 		public Type[] GetInterfaces()
 		{
 			List<Type> list = new List<Type>();
 			for (Type type = this; type != null; type = type.BaseType)
 			{
 				AddInterfaces(list, type);
 			}
 			for (Type type = this; type != null; type = type.BaseType)
 			{
 				AddInterfaces(list, type);
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="116" endline="127">
<![CDATA[
 		}
 
 		#endregion
 
 		public HoistedStoreyClass GetGenericStorey ()
 		{
 			DeclSpace storey = this;
 			while (storey != null && storey.CurrentTypeParameters == null)
 				storey = storey.Parent;
 			while (storey != null && storey.CurrentTypeParameters == null)
 				storey = storey.Parent;
 
 			return storey as HoistedStoreyClass;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1379" endline="1393">
<![CDATA[
 
 		public static ArrayContainer MakeType (TypeSpec element, int rank)
 		{
 			ArrayContainer ac;
 			var key = new TypeRankPair (element, rank);
 			if (!instances.TryGetValue (key, out ac)) {
 				ac = new ArrayContainer (element, rank) {
 					BaseType = TypeManager.array_type
 				};
 
 				instances.Add (key, ac);
 			}
 
 			return ac;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="806" endline="818">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			Attribute a = null;
 			if (OptAttributes != null) {
 				a = OptAttributes.Search (pa);
 			}
 
 			if (a == null)
 				return null;
 
 			return a.GetAttributeUsageAttribute ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="569" endline="580">
<![CDATA[
 		}
 
 		public int DefineNamespace (string name, string[] using_clauses, int parent)
 		{
 			if (!creating)
 				throw new InvalidOperationException ();
 
 			int index = file.GetNextNamespaceIndex ();
 			NamespaceEntry ns = new NamespaceEntry (name, index, using_clauses, parent);
 			namespaces.Add (ns);
 			return index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="120" endline="131">
<![CDATA[
 
 		// <summary>
 		//   Starts a new code branching for block `block'.
 		// </summary>
 		public FlowBranching StartFlowBranching (Block block)
 		{
 			Set (Options.DoFlowAnalysis);
 
 			current_flow_branching = FlowBranching.CreateBranching (
 				CurrentBranching, FlowBranching.BranchingType.Block, block, block.StartLocation);
 			return current_flow_branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="493" endline="500">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = InternalType.Dynamic;
 			eclass = ExprClass.Value;
 			condition = condition.Resolve (rc);
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="171" endline="177">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1342" endline="1348">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			Child = Child.Resolve (rc);
 			this.eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="353" endline="364">
<![CDATA[
 
 		static bool IsValidArgumentType (TypeSpec t)
 		{
 			if (t.IsArray)
 				t = TypeManager.GetElementType (t);
 
 			return t == TypeManager.string_type ||
 				TypeManager.IsPrimitiveType (t) ||
 				TypeManager.IsEnumType (t) ||
 				t == TypeManager.object_type ||
 				t == TypeManager.type_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9537" endline="9549">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression e = base.DoResolve (ec);
 			if (type == null)
 				return null;
 
 			Expression previous = ec.CurrentInitializerVariable;
 			ec.CurrentInitializerVariable = new InitializerTargetExpression (this);
 			initializers.Resolve (ec);
 			ec.CurrentInitializerVariable = previous;
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1340" endline="1353">
<![CDATA[
 
 		public bool IsSubclassOf(Type type)
 		{
 			Type thisType = this.BaseType;
 			while (thisType != null)
 			{
 				if (thisType.Equals(type))
 				{
 					return true;
 				}
 				thisType = thisType.BaseType;
 			}
 			while (thisType != null)
 			{
 				if (thisType.Equals(type))
 				{
 					return true;
 				}
 				thisType = thisType.BaseType;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="308" endline="324">
<![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal params As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(params.Count >= Me.Count)
 
         For i As Integer = 0 To Count - 1
             result = Item(i).GenerateCode(Info.Clone(Me, True, False, params(i).ParameterType), params(i)) AndAlso result
         Next
 
         For i As Integer = Count To params.Count - 1
             Helper.Assert(params(i).IsOptional)
             Emitter.EmitLoadValue(Info.Clone(Me, params(i).ParameterType), params(i).Constant)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="808" endline="821">
<![CDATA[
 
 		internal int FindOrAddRecord(Record record)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Class == record.Class
 					&& records[i].Name == record.Name
 					&& records[i].Signature == record.Signature)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Class == record.Class
 					&& records[i].Name == record.Name
 					&& records[i].Signature == record.Signature)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(record);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2160" endline="2173">
<![CDATA[
 
 		internal int FindOrAddRecord(Record rec)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Implementation == rec.Implementation
 					&& records[i].TypeName == rec.TypeName
 					&& records[i].TypeNamespace == rec.TypeNamespace)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Implementation == rec.Implementation
 					&& records[i].TypeName == rec.TypeName
 					&& records[i].TypeNamespace == rec.TypeNamespace)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="175" endline="196">
<![CDATA[
 
     ReadOnly Property HasSecurityCustomAttribute() As Boolean
         Get
             Dim checkedAll As Boolean = True
 
             If CustomAttributes Is Nothing Then Return False
 
             If m_HasSecurityCustomAttribute.HasValue Then Return m_HasSecurityCustomAttribute.Value
 
             For i As Integer = 0 To CustomAttributes.Count - 1
                 If CustomAttributes(i).ResolvedType Is Nothing Then
                     checkedAll = False
                 ElseIf Helper.IsSubclassOf(Compiler.TypeCache.System_Security_Permissions_SecurityAttribute, CustomAttributes(i).ResolvedType) Then
                     m_HasSecurityCustomAttribute = True
                     Return True
                 End If
             Next
 
             If checkedAll Then m_HasSecurityCustomAttribute = False
 
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="37" endline="80">
<![CDATA[
 
 #Region "Helper"
 
     'Constant methods.
     'Private Shared m_Asc_Char As MethodInfo ', if the constant string is not empty
     'Private Shared m_Asc_String As MethodInfo ', if the constant string is not empty
     'Private Shared m_AscW_Char As MethodInfo ', if the constant string is not empty
     'Private Shared m_AscW_String As MethodInfo ', if the constant string is not empty
     'Private Shared m_Chr_Integer As MethodInfo ', if the constant value is between 0 and 128
     'Private Shared m_ChrW_Integer As MethodInfo
     'Private Shared m_AllConstantFunctions As ArrayList
 
     'A constant expression is an expression whose value can be fully evaluated at compile time. The type of a constant expression can be Byte, Short, Integer, Long, Char, Single, Double, Decimal, Boolean, String, or any enumeration type. The following constructs are permitted in constant expressions
     'Literals (including Nothing).
     'References to constant type members or constant locals.
     'References to members of enumeration types.
     'Parenthesized subexpressions.
     'Coercion expressions, provided the target type is one of the types listed above. Coercions to and from String are an exception to this rule and not allowed because String conversions are always done in the current culture of the execution environment at run time.
     'The +, - and Not unary operators.
     'The +, -, *, ^, Mod, /, \, <<, >>, &, And, Or, Xor, AndAlso, OrElse, =, <, >, <>, <=, and => binary operators, provided each operand is of a type listed above.
     'The following run-time functions
     'Microsoft.VisualBasic.Strings.ChrW
     'Microsoft.VisualBasic.Strings.Chr, if the constant value is between 0 and 128
     'Microsoft.VisualBasic.Strings.AscW, if the constant string is not empty
     'Microsoft.VisualBasic.Strings.Asc, if the constant string is not empty
 
     'Constant expressions of an integral type (Long, Integer, Short, Byte) can be implicitly converted to a narrower integral type, and constant expressions of type Double can be implicitly converted to Single, provided the value of the constant expression is within the range of the destination type. These narrowing conversions are allowed regardless of whether permissive or strict semantics are being used.
 
     Private Shared Function IsMethod(ByVal m1 As Mono.Cecil.MethodReference, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference, ByVal ReturnType As Mono.Cecil.TypeReference) As Boolean
         If CecilHelper.IsGenericMethod(m1) Then Return False
         If CecilHelper.IsGenericMethodDefinition(m1) Then Return False
 
         If CompareNameOrdinal(m1.Name, Name) = False Then Return False
 
         If Helper.CompareType(m1.ReturnType, ReturnType) = False Then Return False
 
         Dim p1 As Mono.Collections.Generic.Collection(Of Mono.Cecil.ParameterDefinition)
         p1 = m1.Parameters()
         If p1.Count <> 1 Then Return False
 
         If Helper.CompareType(p1(0).ParameterType, ParameterType) = False Then Return False
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="38" endline="60">
<![CDATA[
     End Property
 
     Private Function IsExcluded() As Boolean
         Dim exp As InvocationOrIndexExpression
         Dim method As Mono.Cecil.MethodReference
         Dim classification As MethodGroupClassification
    
         If Not m_Target.Classification.IsVoidClassification Then Return False
 
         exp = TryCast(m_Target, InvocationOrIndexExpression)
 
         If exp Is Nothing Then Return False
         If exp.Expression Is Nothing Then Return False
 
         classification = TryCast(exp.Expression.Classification, MethodGroupClassification)
         If classification Is Nothing Then Return False
 
         method = classification.ResolvedMethodInfo
 
         If method Is Nothing Then Return False
 
         Return Compiler.Scanner.IsConditionallyExcluded(method, Me.Location)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="262" endline="282">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (Kind != MemberKind.Class)
 				throw new InternalErrorException ();
 
 			if (!pa.IsDefined)
 				return Attribute.DefaultUsageAttribute;
 
 			AttributeUsageAttribute aua = null;
 			var type = this;
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 
 			return aua;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2112" endline="2137">
<![CDATA[
 	}
 
 	sealed class ExportedTypeTable 
 	{
 		internal const int Index = 0x27;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeDefId;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeDefId = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeDefId = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="390" endline="449">
<![CDATA[
 		protected int rowCount;
 
 		internal sealed override int RowCount
 		{
 			get { return rowCount; }
 			set { rowCount = value; records = new T[value]; }
 		}
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			throw new InvalidOperationException();
 		}
 
 		internal int AddRecord(T newRecord)
 		{
 			if (rowCount == records.Length)
 			{
 				T[] newarr = new T[records.Length * 2];
 				Array.Copy(records, newarr, records.Length);
 				records = newarr;
 			}
 			records[rowCount++] = newRecord;
 			return rowCount;
 		}
 
 		internal int AddVirtualRecord()
 		{
 			return ++rowCount;
 		}
 
 		internal override void Write(MetadataWriter mw)
 		{
 			throw new InvalidOperationException();
 		}
 	}
 
 	sealed class ModuleTable 
 	{
 		internal const int Index = 0x00;
 
 		internal struct Record
 		{
 			internal short Generation;
 			internal int Name; // -> StringHeap
 			internal int Mvid; // -> GuidHeap
 			internal int EncId; // -> GuidHeap
 			internal int EncBaseId; // -> GuidHeap
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Generation = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Mvid = mr.ReadGuidIndex();
 				records[i].EncId = mr.ReadGuidIndex();
 				records[i].EncBaseId = mr.ReadGuidIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Generation = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Mvid = mr.ReadGuidIndex();
 				records[i].EncId = mr.ReadGuidIndex();
 				records[i].EncBaseId = mr.ReadGuidIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="611" endline="639">
<![CDATA[
 	}
 
 	sealed class MethodDefTable 
 	{
 		internal const int Index = 0x06;
 		private int baseRVA;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal short ImplFlags;
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 			internal int ParamList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="525" endline="552">
<![CDATA[
 	}
 
 	sealed class TypeDefTable 
 	{
 		internal const int Index = 0x02;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Extends;
 			internal int FieldList;
 			internal int MethodList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1725" endline="1740">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MethodBody))
 				{
 					records[i].MethodBody = moduleBuilder.ResolvePseudoToken(records[i].MethodBody);
 				}
 				if (moduleBuilder.IsPseudoToken(records[i].MethodDeclaration))
 				{
 					records[i].MethodDeclaration = moduleBuilder.ResolvePseudoToken(records[i].MethodDeclaration);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MethodBody))
 				{
 					records[i].MethodBody = moduleBuilder.ResolvePseudoToken(records[i].MethodBody);
 				}
 				if (moduleBuilder.IsPseudoToken(records[i].MethodDeclaration))
 				{
 					records[i].MethodDeclaration = moduleBuilder.ResolvePseudoToken(records[i].MethodDeclaration);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="240" endline="251">
<![CDATA[
 
     Private Sub Flatten(ByVal Name As String, ByVal Visibility As MemberVisibility)
         Dim bases As List(Of MemberCache) = GetBaseCache()
 
         If bases.Count = 0 Then
             Flatten(Name, Nothing, Visibility)
         Else
             For i As Integer = 0 To bases.Count - 1
                 Flatten(Name, bases(i), Visibility)
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="175" endline="186">
<![CDATA[
     End Property
 
     ReadOnly Property FieldInfo() As Mono.Cecil.FieldReference
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return m_FieldInfo
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="518" endline="531">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			// Field initializer can be resolved (fail) many times
 			if (source == null)
 				return null;
 
 			if (resolved == null) {
 				var ctx = new FieldInitializerContext (mc, ec);
 				resolved = base.DoResolve (ctx) as ExpressionStatement;
 			}
 
 			return resolved;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2538" endline="2547">
<![CDATA[
 
     Shared Function GetFieldOrFieldReference(ByVal Compiler As Compiler, ByVal field As Mono.Cecil.FieldReference) As Mono.Cecil.FieldReference
         If field.Annotations.Contains("MemberInReflection") Then
             Return DirectCast(field.Annotations("MemberInReflection"), Mono.Cecil.FieldReference)
         ElseIf Compiler.AssemblyBuilderCecil Is field.DeclaringType.Module.Assembly Then
             Return field
         Else
             Return Compiler.AssemblyBuilderCecil.MainModule.Import(field)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3158" endline="3171">
<![CDATA[
 
     Private Function ParseUnaryPlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryExpression
 
         If tm.CurrentToken = KS.Add Then
             result = ParseUnaryPlusExpression(Info)
         ElseIf tm.CurrentToken = KS.Minus Then
             result = ParseUnaryMinusExpression(Info)
         Else
             Return ParseExponent(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="54" endline="65">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If ReclassifiedClassification IsNot Nothing Then
                 Return ReclassifiedClassification.ConstantValue
             ElseIf m_Value IsNot Nothing Then
                 Return m_Value.ConstantValue
             Else
                 Return MyBase.ConstantValue
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="165" endline="174">
<![CDATA[
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="40" endline="49">
<![CDATA[
     End Property
 
     ReadOnly Property Expression() As Expression
         Get
             If m_Group Is Nothing Then
                 If Not CanBeExpression() Then Return Nothing
                 If m_Group Is Nothing Then Return Nothing
             End If
             Return m_Group.DefaultInstanceAlias
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="76" endline="82">
<![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             If TypeOf m_TypeName Is NonArrayTypeName Then Return AsNonArrayTypeName.Name
             If TypeOf m_TypeName Is ArrayTypeName Then Return AsArrayTypeName.Name
             Return DirectCast(m_TypeName, INameable).Name
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="155" endline="164">
<![CDATA[
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="52" endline="58">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Signature IsNot Nothing Then m_Signature.Initialize(Me)
         If m_Code IsNot Nothing Then m_Code.Initialize(Me)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="541" endline="548">
<![CDATA[
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Variables IsNot Nothing Then m_Variables.Initialize(Me)
         If m_Statements IsNot Nothing Then m_Statements.Initialize(Me)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="256" endline="266">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             If Me.IsResolved Then
                 Return m_ExpressionType
             ElseIf m_ExpressionType IsNot Nothing Then
                 Return m_ExpressionType
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="793" endline="805">
<![CDATA[
 		}
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (OptAttributes == null)
 				return null;
 
 			Attribute a = OptAttributes.Search (Module.PredefinedAttributes.CoClass);
 			if (a == null)
 				return null;
 
 			return a.GetCoClassAttributeValue ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1262" endline="1277">
<![CDATA[
 		}
 
 		#endregion
 
 		public static TypeSpec GetMemberDeclaringType (TypeSpec type)
 		{
 			if (type is InflatedTypeSpec) {
 				if (type.DeclaringType == null)
 					return type.GetDefinition ();
 
 				var parent = GetMemberDeclaringType (type.DeclaringType);
 				type = MemberCache.GetMember<TypeSpec> (parent, type);
 			}
 
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1086" endline="1098">
<![CDATA[
 
 		public static Expression Create (Expression child, TypeSpec type)
 		{
 			Constant c = child as Constant;
 			if (c != null)
 				return new EmptyConstantCast (c, type);
 
 			EmptyCast e = child as EmptyCast;
 			if (e != null)
 				return new EmptyCast (e.child, type);
 
 			return new EmptyCast (child, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2209" endline="2223">
<![CDATA[
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is MethodCore) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			// This can only happen with indexers and it will
 			// be catched as indexer difference
 			if (overload is AbstractPropertyEventMethod)
 				return true;
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="979" endline="989">
<![CDATA[
 		{
 			Expression e = Resolve (ec);
 			if (e == null)
 				return null;
 
 			ExpressionStatement es = e as ExpressionStatement;
 			if (es == null)
 				Error_InvalidExpressionStatement (ec);
 
 			return es;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1203" endline="1210">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal field As FieldReference) As FieldDefinition
         If field Is Nothing Then Return Nothing
         Dim fD As FieldDefinition = TryCast(field, FieldDefinition)
         If fD IsNot Nothing Then Return fD
         Dim type As TypeDefinition = FindDefinition(field.DeclaringType)
         Return GetField(type.Fields, field)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1070" endline="1081">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (this.type == type)
 				return this;
 
 			Constant c = TryImplicitIntConversion (type);
 			if (c != null)
 				return c.Resolve (rc);
 
 			return base.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1046" endline="1053">
<![CDATA[
 
     Public Shared Function GetElementType(ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim rT As ByReferenceType = TryCast(Type, ByReferenceType)
         If rT IsNot Nothing Then Return rT.ElementType
         Dim aT As Mono.Cecil.ArrayType = TryCast(Type, Mono.Cecil.ArrayType)
         If aT IsNot Nothing Then Return aT.ElementType
         Throw New InternalException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="113" endline="127">
<![CDATA[
 
 		public bool ResolveMethodGroup (ResolveContext ec)
 		{
 			SimpleName sn = Expr as SimpleName;
 			if (sn != null)
 				Expr = sn.GetMethodGroup ();
 
 			// FIXME
 			//        `out' in a delegate creation expression.
 			Expr = Expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			if (Expr == null)
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1221" endline="1231">
<![CDATA[
 
 		protected override bool ResolveMemberType ()
 		{
 			if (GenericMethod != null) {
 				MethodBuilder = Parent.TypeBuilder.DefineMethod (GetFullName (MemberName), flags);
 				if (!GenericMethod.Define (this))
 					return false;
 			}
 
 			return base.ResolveMemberType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="137" endline="151">
<![CDATA[
 
 		public bool IsConditionalDefined (string value)
 		{
 			if (conditionals != null) {
 				bool res;
 				if (conditionals.TryGetValue (value, out res))
 					return res;
 				
 				// When conditional was undefined
 				if (conditionals.ContainsKey (value))
 					return false;					
 			}
 
 			return RootContext.IsConditionalDefined (value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2481" endline="2493">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (statements.Count == 1) {
 				Expression expr = ((Statement) statements[0]).CreateExpressionTree (ec);
 				if (scope_initializers != null)
 					expr = new BlockScopeExpression (expr, this);
 
 				return expr;
 			}
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="533" endline="550">
<![CDATA[
 
 		// when we refer to a method on a generic type definition in the IL stream,
 		// we need to use a MemberRef (even if the method is in the same module)
 		internal MethodToken GetMethodTokenForIL(MethodInfo method)
 		{
 			if (method.IsGenericMethodDefinition)
 			{
 				method = method.MakeGenericMethod(method.GetGenericArguments());
 			}
 			if (IsFromGenericTypeDefinition(method))
 			{
 				return new MethodToken(ImportMember(method));
 			}
 			else
 			{
 				return GetMethodToken(method);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="874" endline="893">
<![CDATA[
 
 	/// <summary>
 	///   Utility function that can be used to probe whether a type
 	///   is managed or not.  
 	/// </summary>
 	public static bool VerifyUnmanaged (CompilerContext ctx, TypeSpec t, Location loc)
 	{
 		while (t.IsPointer)
 			t = GetElementType (t);
 		while (t.IsPointer)
 			t = GetElementType (t);
 
 		if (IsUnmanagedType (t))
 			return true;
 
 		ctx.Report.SymbolRelatedToPreviousError (t);
 		ctx.Report.Error (208, loc,
 			"Cannot take the address of, get the size of, or declare a pointer to a managed type `{0}'",
 			CSharpName (t));
 
 		return false;	
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="84" endline="95">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant ()) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2041" endline="2055">
<![CDATA[
 
 		public override bool ResolveUnreachable (BlockContext ec, bool warn)
 		{
 			unreachable_shown = true;
 			unreachable = true;
 
 			if (warn)
 				ec.Report.Warning (162, 2, loc, "Unreachable code detected");
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Block, loc);
 			bool ok = Resolve (ec);
 			ec.KillFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4321" endline="4329">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			if (ec.CurrentIterator != null)
 				ec.Report.Error (1629, loc, "Unsafe code may not appear in iterators");
 
 			using (ec.Set (ResolveContext.Options.UnsafeScope))
 				return Block.Resolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="529" endline="540">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property IsOneLiner() As Boolean
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Return False
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="73" endline="81">
<![CDATA[
 
     Shared Operator &(ByVal ns As [Namespace], ByVal str As String) As [Namespace]
         If ns Is Nothing Then Throw New InternalException("")
         If TypeOf ns Is GlobalNamespace Then
             Return New [Namespace](ns.Parent, str, True)
         Else
             Return New [Namespace](ns.Parent, ns, str)
         End If
     End Operator
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="312" endline="319">
<![CDATA[
 
 		internal byte[] GetBlobCopy(int blobIndex)
 		{
 			int len = ReadCompressedInt(blobHeap, ref blobIndex);
 			byte[] buf = new byte[len];
 			Buffer.BlockCopy(blobHeap, blobIndex, buf, 0, len);
 			return buf;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="326" endline="332">
<![CDATA[
 
 		public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			MethodBuilder mb = CreateMethodBuilder(name, attributes, callingConvention);
 			mb.SetSignature(returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 			return mb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="235" endline="242">
<![CDATA[
 
 		protected Field AddCompilerGeneratedField (string name, FullNamedExpression type)
 		{
 			const Modifiers mod = Modifiers.INTERNAL | Modifiers.COMPILER_GENERATED;
 			Field f = new Field (this, type, mod, new MemberName (name, Location), null);
 			AddField (f);
 			return f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5023" endline="5031">
<![CDATA[
 
     Private Function ParseResumeStatement(ByVal Parent As ParsedObject) As ResumeStatement
         Dim m_IsResumeNext As Boolean
 
         tm.AcceptIfNotInternalError(KS.Resume)
         m_IsResumeNext = tm.Accept(KS.Next)
 
         Return New ResumeStatement(Parent, m_IsResumeNext)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="382" endline="397">
<![CDATA[
 
 		public abstract UsageVector CurrentUsageVector {
 			get;
 		}				
 
 		// <summary>
 		//   Creates a sibling of the current usage vector.
 		// </summary>
 		public virtual void CreateSibling (Block block, SiblingType type)
 		{
 			UsageVector vector = new UsageVector (
 				type, Parent.CurrentUsageVector, block, Location);
 			AddSibling (vector);
 
 			Report.Debug (1, "  CREATED SIBLING", CurrentUsageVector);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="534" endline="540">
<![CDATA[
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="912" endline="920">
<![CDATA[
 
 	/// <summary>
 	///   Check whether `type' and `parent' are both instantiations of the same
 	///   generic type.  Note that we do not check the type parameters here.
 	/// </summary>
 	public static bool IsInstantiationOfSameGenericType (TypeSpec type, TypeSpec parent)
 	{
 		return type == parent || type.MemberDefinition == parent.MemberDefinition;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="303" endline="309">
<![CDATA[
 
 		public void BeginExceptFilterBlock()
 		{
 			ExceptionBlock block = BeginFinallyFilterFaultBlock();
 			block.filterOffset = code.Position;
 			UpdateStack(1);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="310" endline="316">
<![CDATA[
 
 		public void BeginFaultBlock()
 		{
 			ExceptionBlock block = BeginFinallyFilterFaultBlock();
 			block.handlerOffset = code.Position;
 			block.exceptionType = FAULT;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="848" endline="855">
<![CDATA[
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="119" endline="126">
<![CDATA[
 		}
 
 		bool IsAnonymousStoreyMutateRequired {
 			get {
 				return CurrentAnonymousMethod != null &&
 					CurrentAnonymousMethod.Storey != null &&
 					CurrentAnonymousMethod.Storey.Mutator != null;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifier(ByVal Modifier As KS) As Modifiers
         m_ModifierMask = m_ModifierMask Or KSToMask(Modifier)
         Return Me
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8341" endline="8349">
<![CDATA[
 
 		public SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source)
 		{
 #if NET_4_0
 			return SLE.Expression.ArrayAccess (ea.Expr.MakeExpression (ctx), MakeExpressionArguments (ctx));
 #else
 			throw new NotImplementedException ();
 #endif
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="108" endline="114">
<![CDATA[
 		}
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			iterator = ec.CurrentIterator;
 			return Yield.CheckContext (ec, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="928" endline="937">
<![CDATA[
 
 		//
 		// Implementation of expression to expression tree conversion
 		//
 		public abstract Expression CreateExpressionTree (ResolveContext ec);
 
 		protected Expression CreateExpressionFactoryCall (ResolveContext ec, string name, Arguments args)
 		{
 			return CreateExpressionFactoryCall (ec, name, null, args, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="358" endline="364">
<![CDATA[
 
 
 		public static MethodSpec GetConstructor (CompilerContext ctx, TypeSpec container_type, TypeSpec delType)
 		{
 			var ctor = MemberCache.FindMember (delType, MemberFilter.Constructor (null), BindingRestriction.DeclaredOnly);
 			return (MethodSpec) ctor;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="102" endline="109">
<![CDATA[
 
 		internal override void WriteSig(ModuleBuilder module, ByteBuffer bb)
 		{
 			bb.Write(FIELD);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
 			WriteType(module, bb, fieldType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9310" endline="9316">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			base.expr = new AddMemberAccess (ec.CurrentInitializerVariable, loc);
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MemberInfo.cs" startline="43" endline="53">
<![CDATA[
 		}
 
 		public abstract Module Module
 		{
 			get;
 		}
 
 		public bool IsDefined(Type attributeType, bool inherit)
 		{
 			return CustomAttributeData.__GetCustomAttributes(this, attributeType, inherit).Count != 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1757" endline="1766">
<![CDATA[
 	}
 
 	sealed class MultiArrayType 
 	{
 		private readonly int rank;
 
 		internal static Type Make(Type type, int rank, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new MultiArrayType(type, rank, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="247" endline="258">
<![CDATA[
 
     ''' <summary>
     ''' Eats the current token if if coincides, if not shows a 
     ''' message "Expected
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         Return AcceptIfNotError(Special, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="745" endline="752">
<![CDATA[
 
 #if NET_4_0
 		[Obsolete]
 #endif
 		public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 		{
 			return DefineDynamicAssemblyImpl(name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1669" endline="1680">
<![CDATA[
 
 		protected abstract string GetSuffix();
 
 		protected abstract Type Wrap(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
 	}
 
 	sealed class ArrayType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ArrayType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="38" endline="48">
<![CDATA[
 		}
 
 		internal abstract int RowCount { get; set; }
 
 		internal abstract void Write(MetadataWriter mw);
 		internal abstract void Read(MetadataReader mr);
 
 		internal int GetLength(MetadataWriter md)
 		{
 			return RowCount * GetRowSize(new RowSizeCalc(md));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1886" endline="1958">
<![CDATA[
 		}
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodInfo method;
 			private readonly Type type;
 			private readonly int pos;
 
 			internal ParameterInfoImpl(MethodInfo method, Type type, int pos)
 			{
 				this.method = method;
 				this.type = type;
 				this.pos = pos;
 			}
 
 			public override Type ParameterType
 			{
 				get { return type; }
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return pos; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { return null; }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method.IsConstructor ? (MethodBase)new ConstructorInfoImpl(method) 
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x8000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 	}
 
 	sealed class ByRefType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ByRefType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1999" endline="2006">
<![CDATA[
 	}
 
 	sealed class PointerType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new PointerType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1221" endline="1233">
<![CDATA[
 
   /** the generated parser, with debugging messages.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @param yydebug debug message writer implementing yyDebug, or null.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
 				 {
     this.debug = (yydebug.yyDebug)yyd;
     return yyparse(yyLex);
   }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="960" endline="967">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Implicit conversions
 		/// </summary>
 		static public Expression ImplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, true, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="968" endline="975">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Explicit conversions
 		/// </summary>
 		static Expression ExplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, false, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1230" endline="1246">
<![CDATA[
 
 
 		/// <summary>
 		///   Attempts to apply the `Standard Implicit
 		///   Conversion' rules to the expression `expr' into
 		///   the `target_type'.  It returns a new expression
 		///   that can be used in a context that expects a
 		///   `target_type'.
 		///
 		///   This is different from `ImplicitConversion' in that the
 		///   user defined implicit conversions are excluded.
 		/// </summary>
 		static public Expression ImplicitConversionStandard (ResolveContext ec, Expression expr,
 								     TypeSpec target_type, Location loc)
 		{
 			return ImplicitConversionStandard (ec, expr, target_type, loc, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="190" endline="205">
<![CDATA[
 
 		public enum Operation {
 			//
 			// If you change this, review the whole InterfaceMethod routine as there
 			// are a couple of assumptions on these three states
 			//
 			Lookup, ClearOne, ClearAll
 		}
 
 		/// <summary>
 		///   Whether the specified method is an interface method implementation
 		/// </summary>
 		public MethodSpec IsInterfaceMethod (MemberName name, TypeSpec ifaceType, MethodData method)
 		{
 			return InterfaceMethod (name, ifaceType, method, Operation.Lookup);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="364" endline="379">
<![CDATA[
 
 		#region Properties
 
 		//
 		// Explicit struct layout set by parent
 		//
 		public CharSet? CharSet {
 			get; set;
 		}		
 
 		#endregion
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ImplicitConversionRequired (rc, TypeManager.int32_type, Location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="304" endline="311">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool AddMember (MemberCore symbol)
 		{
 			return AddToContainer (symbol, symbol.MemberName.Basename);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="105" endline="112">
<![CDATA[
 
 		//
 		//  Returns a constant instance based on Type
 		//
 		public static Constant CreateConstant (ResolveContext rc, TypeSpec t, object v, Location loc)
 		{
 			return CreateConstantFromValue (t, v, loc).Resolve (rc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8608" endline="8616">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (831, loc, "An expression tree may not contain a base access");
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="198" endline="214">
<![CDATA[
 
     ''' <summary>
     ''' Clone the emitinfo for a left hand side expression.
     ''' </summary>
     ''' <param name="RHSExpression"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Clone(ByVal Context As ParsedObject, ByVal RHSExpression As Expression) As EmitInfo
         Dim result As New EmitInfo(Me)
 
         result.m_IsRHS = False
         result.m_RHSExpression = RHSExpression
         result.m_DesiredType = Nothing
         result.m_Context = Context
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="123" endline="131">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.unmanaged = true;
 			sig.unmanagedCallConv = unmanagedCallConv;
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="234" endline="241">
<![CDATA[
 
     Function Clone(ByVal Context As ParsedObject, ByVal DesiredType As Mono.Cecil.TypeReference) As EmitInfo
         Dim result As New EmitInfo(Me)
         result.m_DesiredType = DesiredType
         result.m_RHSExpression = Nothing
         result.m_Context = Context
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="480" endline="487">
<![CDATA[
     End Property
 
     ReadOnly Property HasSharedConstantFields() As Boolean
         Get
             Dim ctors As Generic.List(Of ConstantDeclaration)
             ctors = Me.Members.GetSpecificMembers(Of ConstantDeclaration)()
             Return ctors.Count > 0
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="31" endline="45">
<![CDATA[
 
 		/// <remarks>
 		///   This is different from ToString in that ToString
 		///   is supposed to be there for debugging purposes,
 		///   and is not guaranteed to be useful for anything else,
 		///   AsString() will provide something that can be used
 		///   for round-tripping C# code.  Maybe it can be used
 		///   for IL assembly as well.
 		/// </remarks>
 		public abstract string AsString ();
 
 		override public string ToString ()
 		{
 			return this.GetType ().Name + " (" + AsString () + ")";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="400" endline="406">
<![CDATA[
 
 		public RootNamespace GetRootNamespace (string name)
 		{
 			RootNamespace rn;
 			alias_ns.TryGetValue (name, out rn);
 			return rn;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="433" endline="440">
<![CDATA[
 		}
 
 		internal override Type GetTypeImpl(string typeName)
 		{
 			TypeBuilder type;
 			fullNameToType.TryGetValue(typeName, out type);
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="566" endline="572">
<![CDATA[
 
 		public Location[] GetLocations (object element)
 		{
 			Location[] found;
 			simple_locs.TryGetValue (element, out found);
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="915" endline="927">
<![CDATA[
 
 //	static Comparer TypeComparer = new Comparer (new ComparerFunc (CompareType));
 
 //	static Type [] Sort (Type [] types)
 //	{
 //		Array.Sort (types, TypeComparer);
 //		return types;
 //	}
 	
 	static int CompareMemberInfo (object a, object b)
 	{
 		return string.Compare (((MemberInfo) a).Name, ((MemberInfo) b).Name);
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="573" endline="579">
<![CDATA[
 
 		public MemberLocations GetMemberLocation (MemberCore element)
 		{
 			MemberLocations found;
 			member_locs.TryGetValue (element, out found);
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="403" endline="411">
<![CDATA[
 
 		protected abstract void AddSibling (UsageVector uv);
 
 		protected abstract UsageVector Merge ();
 
 		public UsageVector MergeChild (FlowBranching child)
 		{
 			return CurrentUsageVector.MergeChild (child.Merge (), true);
  		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="481" endline="487">
<![CDATA[
 
 #End Region
 
     Overridable ReadOnly Property AsString() As String
         Get
             Return "<String representation of " & Me.GetType.FullName & " not implemented>"
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5150" endline="5158">
<![CDATA[
 
     ''' <summary>
     ''' EndStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEndStatement(ByVal Parent As ParsedObject) As EndStatement
         tm.AcceptIfNotInternalError(KS.End)
         Return New EndStatement(Parent)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5822" endline="5828">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source)
 		{
 			li.CreateBuilder (ec);
 
 			EmitAssign (ec, source, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5815" endline="5821">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			li.CreateBuilder (ec);
 
 			Emit (ec, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="95" endline="101">
<![CDATA[
     End Property
 
     ReadOnly Property AsNonArrayTypeName() As NonArrayTypeName
         Get
             Helper.Assert(IsNotArray)
             Return DirectCast(m_TypeName, NonArrayTypeName)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="102" endline="108">
<![CDATA[
     End Property
 
     ReadOnly Property AsArrayTypeName() As ArrayTypeName
         Get
             Helper.Assert(IsArray)
             Return DirectCast(m_TypeName, ArrayTypeName)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="130" endline="140">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The end column of the span.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public ReadOnly Property EndColumn() As Byte
         Get
             Return m_EndColumn + m_Column
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="168" endline="174">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="213" endline="219">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="261" endline="269">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessageNoLocation(ByVal Message As Messages, ByVal ParamArray Parameters() As String) As Boolean
         Dim Location As Span = Nothing
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="789" endline="797">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			rc.Report.Error (1947, loc,
 				"A range variable `{0}' cannot be assigned to. Consider using `let' clause to store the value",
 				Name);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7524" endline="7530">
<![CDATA[
 
 		protected override void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			rc.Compiler.Report.Error (687, loc,
 				"A namespace alias qualifier `{0}' did not resolve to a namespace or a type",
 				GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="646" endline="653">
<![CDATA[
 		}
 
 		Options flags;
 
 		public bool HasSet (Options options)
 		{
 			return (this.flags & options) == options;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="843" endline="849">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.ushort_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="725" endline="731">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.short_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="619" endline="625">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.sbyte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="412" endline="418">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.byte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="340" endline="346">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.bool_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="495" endline="501">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.char_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="955" endline="961">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1136" endline="1142">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1398" endline="1404">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1515" endline="1521">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.float_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1638" endline="1644">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.double_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1766" endline="1772">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.decimal_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1892" endline="1898">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="865" endline="873">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasConstant()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1188" endline="1196">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasDeclSecurity()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1461" endline="1469">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1539" endline="1547">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1588" endline="1596">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMethodDef()
 				.WriteHasSemantics()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2103" endline="2111">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2209" endline="2217">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2305" endline="2313">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteTypeOrMethodDef()
 				.WriteStringIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="53" endline="61">
<![CDATA[
 
 #If DEBUG Then
     Protected MustOverride Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
 #End If
     MustOverride ReadOnly Property Keyword() As KS
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(Enums.UnaryOperators)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="388" endline="395">
<![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, callingConvention, false, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="65" endline="72">
<![CDATA[
         Get
             If m_CilBody Is Nothing Then
                 Helper.Assert(m_Method IsNot Nothing)
                 Helper.Assert(m_Method.CecilBuilder IsNot Nothing)
                 m_CilBody = m_Method.CecilBuilder.Body
             End If
             Return m_CilBody
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3369" endline="3380">
<![CDATA[
 
 		//
 		// Any type_name independent checks
 		//
 		protected virtual void DoMemberTypeIndependentChecks ()
 		{
 			if ((Parent.ModFlags & Modifiers.SEALED) != 0 &&
 				(ModFlags & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 				Report.Error (549, Location, "New virtual member `{0}' is declared in a sealed class `{1}'",
 					GetSignatureForError (), Parent.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1536" endline="1543">
<![CDATA[
 
 		protected override string GetTypeNameSignature ()
 		{
 			if (targs.Length == 0 || MemberDefinition is AnonymousTypeClass)
 				return null;
 
 			return "<" + TypeManager.CSharpName (targs) + ">";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="365" endline="378">
<![CDATA[
 		}
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			int owner = module.GenericParam.records[index].Owner;
 			if ((owner >> 24) == MethodDefTable.Index)
 			{
 				return binder.BindMethodParameter(this);
 			}
 			else
 			{
 				return binder.BindTypeParameter(this);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="50" endline="64">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns the specified argument, or nothing if index is out of range
     ''' </summary>
     ''' <param name="Index"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetArgument(ByVal Index As Integer) As Object
         If m_Arguments IsNot Nothing AndAlso Index < m_Arguments.Length Then
             Return m_Arguments(Index)
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="383" endline="390">
<![CDATA[
 
     Public Overloads Function Equals(ByVal Special As KS) As Boolean
         If m_TokenType = TokenType.Keyword OrElse m_TokenType = TokenType.Symbol Then
             Return CInt(m_TokenObject) = CInt(Special)
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8953" endline="8960">
<![CDATA[
 
 		void MakeArray (ComposedTypeSpecifier spec)
 		{
 			if (spec.Next != null)
 				MakeArray (spec.Next);
 
 			type = ArrayContainer.MakeType (type, spec.Dimension);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="592" endline="600">
<![CDATA[
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1596" endline="1610">
<![CDATA[
 
     ''' <summary>
     ''' Loads the address of the parameter.
     ''' Just loads the value if it is a byref parameter.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Variable"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         If CecilHelper.IsByRef(Variable.ParameterType) Then
             EmitLoadParameter(Info, Variable)
         Else
             Info.ILGen.Emit(OpCodes.Ldarga, CShort(GetParameterPosition(Info, Variable)))
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="50" endline="64">
<![CDATA[
     End Property
 #End If
 
     ''' <summary>
     ''' Adds the constant to the collection. 
     ''' If the constant already exists, it is replaced.
     ''' </summary>
     ''' <param name="Constant"></param>
     ''' <remarks></remarks>
     Public Shadows Sub Add(ByVal Constant As ConditionalConstant)
         If MyBase.ContainsKey(Constant.Name) Then
             MyBase.Remove(Constant.Name)
         End If
         MyBase.Add(Constant.Name, Constant)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="28" endline="36">
<![CDATA[
 
     Shadows Sub Add(ByVal Type As Mono.Cecil.TypeReference)
         Dim name As String = Type.Name
         If MyBase.ContainsKey(name) Then
             'System.Console.WriteLine("Already added type
         Else
             MyBase.Add(name, Type)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5076" endline="5082">
<![CDATA[
 		public Invocation (Expression expr, Arguments arguments)
 		{
 			this.expr = expr;		
 			this.arguments = arguments;
 			if (expr != null)
 				loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2323" endline="2376">
<![CDATA[
 	}
 
 	public partial class TypeManager
 	{
 		public static Variance CheckTypeVariance (TypeSpec t, Variance expected, IMemberContext member)
 		{
 			var tp = t as TypeParameterSpec;
 			if (tp != null) {
 				Variance v = tp.Variance;
 				if (expected == Variance.None && v != expected ||
 					expected == Variance.Covariant && v == Variance.Contravariant ||
 					expected == Variance.Contravariant && v == Variance.Covariant) {
 					((TypeParameter)tp.MemberDefinition).ErrorInvalidVariance (member, expected);
 				}
 
 				return expected;
 			}
 
 			if (t.TypeArguments.Length > 0) {
 				var targs_definition = t.MemberDefinition.TypeParameters;
 				TypeSpec[] targs = GetTypeArguments (t);
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 
 				return expected;
 			}
 
 			if (t.IsArray)
 				return CheckTypeVariance (GetElementType (t), expected, member);
 
 			return Variance.None;
 		}
 	}
 
 	//
 	// Implements C# type inference
 	//
 	class TypeInference
 	{
 		//
 		// Tracks successful rate of type inference
 		//
 		int score = int.MaxValue;
 		readonly Arguments arguments;
 		readonly int arg_count;
 
 		public TypeInference (Arguments arguments)
 		{
 			this.arguments = arguments;
 			if (arguments != null)
 				arg_count = arguments.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="684" endline="693">
<![CDATA[
 		}
 
 		public SourceFileEntry (MonoSymbolFile file, string file_name)
 		{
 			this.file = file;
 			this.file_name = file_name;
 			this.Index = file.AddSource (this);
 
 			creating = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="35" endline="503">
<![CDATA[
 
 #if !STATIC
 		// Reflection Emit hacking
 		static readonly Type TypeBuilder;
 		static readonly Type GenericTypeBuilder;
 
 		static TypeSpec ()
 		{
 			var assembly = typeof (object).Assembly;
 			TypeBuilder = assembly.GetType ("System.Reflection.Emit.TypeBuilder");
 			GenericTypeBuilder = assembly.GetType ("System.Reflection.MonoGenericClass");
 			if (GenericTypeBuilder == null)
 				GenericTypeBuilder = assembly.GetType ("System.Reflection.Emit.TypeBuilderInstantiation");
 		}
 #endif
 
 		public TypeSpec (MemberKind kind, TypeSpec declaringType, ITypeDefinition definition, MetaType info, Modifiers modifiers)
 			
 		{
 			this.declaringType = declaringType;
 			this.info = info;
 
 			if (definition != null && definition.TypeParametersCount > 0)
 				state |= StateFlags.IsGeneric;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return MemberDefinition.TypeParametersCount;
 			}
 		}
 
 		public virtual TypeSpec BaseType {
 			get {
 				return base_type;
 			}
 			set {
 				base_type = value;
 			}
 		}
 
 		public virtual BuildinTypeSpec.Type BuildinType {
 			get {
 				return BuildinTypeSpec.Type.None;
 			}
 		}
 
 		public bool HasDynamicElement {
 			get {
 				return (state & StateFlags.HasDynamicElement) != 0;
 			}
 		}
 
 		public virtual IList<TypeSpec> Interfaces {
 			get {
 				return ifaces;
 			}
 			set {
 				ifaces = value;
 			}
 		}
 
 		public bool IsArray {
 			get {
 				return Kind == MemberKind.ArrayType;
 			}
 		}
 
 		public bool IsAttribute {
 			get {
 				if (!IsClass)
 					return false;
 
 				var type = this;
 				do {
 					if (type.IsGeneric)
 						return false;
 
 					if (type == TypeManager.attribute_type)
 						return true;
 					
 					type = type.base_type;
 				} while (type != null);
 
 				return false;
 			}
 		}
 
 		public bool IsInterface {
 			get {
 				return Kind == MemberKind.Interface;
 			}
 		}
 
 		public bool IsClass {
 			get {
 				return Kind == MemberKind.Class;
 			}
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
 		}
 
 		public bool IsDelegate {
 			get {
 				return Kind == MemberKind.Delegate;
 			}
 		}
 
 		public bool IsEnum {
 			get { return Kind == MemberKind.Enum; }
 		}
 
 		// TODO
 		// IsGenericType -- recursive
 		// HasTypeParameter -- non-recursive
 		public bool IsGenericOrParentIsGeneric {
 			get {
 				var ts = this;
 				do {
 					if (ts.IsGeneric)
 						return true;
 					ts = ts.declaringType;
 				} while (ts != null);
 
 				return false;
 			}
 		}
 
 		public bool IsGenericParameter {
 			get { return Kind == MemberKind.TypeParameter; }
 		}
 
 		public bool IsNested {
 			get { return declaringType != null && Kind != MemberKind.TypeParameter; }
 		}
 
 		public bool IsPointer {
 			get {
 				return Kind == MemberKind.PointerType;
 			}
 		}
 
 		public bool IsSealed {
 			get { return (Modifiers & Modifiers.SEALED) != 0; }
 		}
 
 		public bool IsStruct {
 			get { 
 				return Kind == MemberKind.Struct;
 			}
 		}
 
 		public bool IsTypeBuilder {
 			get {
 #if STATIC
 				return true;
 #else
 				var meta = GetMetaInfo().GetType ();
 				return meta == TypeBuilder || meta == GenericTypeBuilder;
 #endif
 			}
 		}
 
 		public MemberCache MemberCache {
 			get {
 				if (cache == null || (state & StateFlags.PendingMemberCacheMembers) != 0)
 					InitializeMemberCache (false);
 
 				return cache;
 			}
 			set {
 				if (cache != null)
 					throw new InternalErrorException ("Membercache reset");
 
 				cache = value;
 			}
 		}
 
 		public MemberCache MemberCacheTypes {
 			get {
 				if (cache == null)
 					InitializeMemberCache (true);
 
 				return cache;
 			}
 		}	
 
 		public new ITypeDefinition MemberDefinition {
 			get {
 				return (ITypeDefinition) definition;
 			}
 		}
 
 		// TODO
 		// remove the property, YES IT WOULD !!!
 		public virtual TypeSpec[] TypeArguments {
 			get { return TypeSpec.EmptyTypes; }
 		}
 
 		#endregion
 
 		public bool AddInterface (TypeSpec iface)
 		{
 			if ((state & StateFlags.InterfacesExpanded) != 0)
 				throw new InternalErrorException ("Modifying expanded interface list");
 
 			if (ifaces == null) {
 				ifaces = new List<TypeSpec> () { iface };
 				return true;
 			}
 
 			if (!ifaces.Contains (iface)) {
 				ifaces.Add (iface);
 				return true;
 			}
 
 			return false;
 		}
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (Kind != MemberKind.Class)
 				throw new InternalErrorException ();
 
 			if (!pa.IsDefined)
 				return Attribute.DefaultUsageAttribute;
 
 			AttributeUsageAttribute aua = null;
 			var type = this;
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 
 			return aua;
 		}
 
 		public virtual MetaType GetMetaInfo ()
 		{
 			return info;
 		}
 
 		public virtual TypeSpec GetDefinition ()
 		{
 			return this;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string s;
 
 			if (IsNested) {
 				s = DeclaringType.GetSignatureForError ();
 			} else if (MemberDefinition is AnonymousTypeClass) {
 				return ((AnonymousTypeClass) MemberDefinition).GetSignatureForError ();
 			} else {
 				s = MemberDefinition.Namespace;
 			}
 
 			if (!string.IsNullOrEmpty (s))
 				s += ".";
 
 			return s + Name + GetTypeNameSignature ();
 		}
 
 		protected virtual string GetTypeNameSignature ()
 		{
 			if (!IsGeneric)
 				return null;
 
 			return "<" + TypeManager.CSharpName (MemberDefinition.TypeParameters) + ">";
 		}
 
 		public bool ImplementsInterface (TypeSpec iface, bool variantly)
 		{
 			var t = this;
 			do {
 				if (t.Interfaces != null) {	// TODO
 					foreach (TypeSpec i in t.Interfaces) {
 						if (i == iface || TypeSpecComparer.IsEqual (i, iface))
 							return true;
 
 						if (variantly && TypeSpecComparer.Variant.IsEqual (i, iface))
 							return true;
 					}
 				}
 
 				t = t.BaseType;
 			} while (t != null);
 
 			return false;
 		}
 
 		protected virtual void InitializeMemberCache (bool onlyTypes)
 		{
 			MemberDefinition.LoadMembers (this, onlyTypes, ref cache);
 
 			if (onlyTypes)
 				state |= StateFlags.PendingMemberCacheMembers;
 			else
 				state &= ~StateFlags.PendingMemberCacheMembers;
 		}
 
 		//
 		// Is @baseClass base implementation of @type. With enabled @dynamicIsEqual the slower
 		// comparison is used to hide differences between `object' and `dynamic' for generic
 		// types. Should not be used for comparisons where G<object> != G<dynamic>
 		//
 		public static bool IsBaseClass (TypeSpec type, TypeSpec baseClass, bool dynamicIsObject)
 		{
 			if (dynamicIsObject && baseClass.IsGeneric) {
 				//
 				// Returns true for a hierarchies like this when passing baseClass of A<dynamic>
 				//
 				// class B 
 				//
 				while (type != null) {
 					type = type.BaseType;
 					if (TypeSpecComparer.IsEqual (type, baseClass))
 						return true;
 				}
 
 				return false;
 			}
 
 			while (type != null) {
 				type = type.BaseType;
 				if (type == baseClass)
 					return true;
 			}
 
 			return false;
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var targs = IsGeneric ? MemberDefinition.TypeParameters 
 
 			//
 			// When inflating nested type from inside the type instance will be same
 			// because type parameters are same for all nested types
 			//
 			if (DeclaringType == inflator.TypeInstance) {
 				return MakeGenericType (targs);
 			}
 
 			return new InflatedTypeSpec (this, inflator.TypeInstance, targs);
 		}
 
 		public InflatedTypeSpec MakeGenericType (TypeSpec[] targs)
 		{
 			if (targs.Length == 0 && !IsNested)
 				throw new ArgumentException ("Empty type arguments for type " + GetSignatureForError ());
 
 			InflatedTypeSpec instance;
 
 			if (inflated_instances == null) {
 				inflated_instances = new Dictionary<TypeSpec[], InflatedTypeSpec> (TypeSpecComparer.Default);
 
 				if (IsNested) {
 					instance = this as InflatedTypeSpec;
 					if (instance != null) {
 						//
 						// Nested types could be inflated on already inflated instances
 						// Caching this type ensured we are using same instance for
 						// inside/outside inflation using local type parameters
 						//
 						inflated_instances.Add (TypeArguments, instance);
 					}
 				}
 			}
 
 			if (!inflated_instances.TryGetValue (targs, out instance)) {
 				if (GetDefinition () != this && !IsNested)
 					throw new InternalErrorException ("`{0}' must be type definition or nested non-inflated type to MakeGenericType",
 						GetSignatureForError ());
 
 				instance = new InflatedTypeSpec (this, declaringType, targs);
 				inflated_instances.Add (targs, instance);
 			}
 
 			return instance;
 		}
 
 		public virtual TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			return this;
 		}
 
 		public void SetMetaInfo (MetaType info)
 		{
 			if (this.info != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.info = info;
 		}
 
 		public void SetExtensionMethodContainer ()
 		{
 			modifiers |= Modifiers.METHOD_EXTENSION;
 		}
 	}
 
 	public sealed class BuildinTypeSpec 
 	{
 		public enum Type
 		{
 			None = 0,
 
 			// TODO
 			Object,
 			ValueType,
 			Attribute,
 			Int,
 			UInt,
 			Long,
 			ULong,
 			Float,
 			Double,
 			Char,
 			Short,
 			Decimal,
 			Bool,
 			SByte,
 			Byte,
 			UShort,
 			String,
 			Enum,
 			Delegate,
 			MulticastDelegate,
 			Void,
 			Array,
 			Type,
 			IEnumerator,
 			IEnumerable,
 			IDisposable,
 			IntPtr,
 			UIntPtr,
 			RuntimeFieldHandle,
 			RuntimeTypeHandle,
 			Exception,
 
 			Null,
 			Dynamic
 		}
 
 		readonly Type type;
 		readonly string ns;
 		readonly string name;
 
 		public BuildinTypeSpec (MemberKind kind, string ns, string name, Type buildinKind)
 			
 		{
 			this.type = buildinKind;
 			this.ns = ns;
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1021" endline="1027">
<![CDATA[
 		protected TypeCast (Expression child, TypeSpec return_type)
 		{
 			eclass = child.eclass;
 			loc = child.Location;
 			type = return_type;
 			this.child = child;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8741" endline="8780">
<![CDATA[
 
 		private EmptyExpressionStatement ()
 		{
 			loc = Location.Null;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return null;
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// Do nothing
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 			type = TypeManager.object_type;
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			// Do nothing
 		}
 	}	
 
 	public class UserCast 
 		MethodSpec method;
 		Expression source;
 		
 		public UserCast (MethodSpec method, Expression source, Location l)
 		{
 			this.method = method;
 			this.source = source;
 			type = method.ReturnType;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8966" endline="8978">
<![CDATA[
 	}
 
 	public class FixedBufferPtr 
 		Expression array;
 
 		public FixedBufferPtr (Expression array, TypeSpec array_type, Location l)
 		{
 			this.array = array;
 			this.loc = l;
 
 			type = PointerContainer.MakeType (array_type);
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1740" endline="1750">
<![CDATA[
 
 		public MethodData (InterfaceMemberBase member,
 				   Modifiers modifiers, MethodAttributes flags, 
 				   IMethodData method, MethodBuilder builder,
 				   GenericMethod generic, MethodSpec parent_method)
 			
 		{
 			this.builder = builder;
 			this.GenericMethod = generic;
 			this.parent_method = parent_method;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="373" endline="389">
<![CDATA[
 	}
 
 	//
 	// Generic lifting expression, supports all S/S? -> T/T? cases
 	//
 	public class Lifted 
 	{
 		Expression expr, null_value;
 		Unwrap unwrap;
 
 		public Lifted (Expression expr, Unwrap unwrap, TypeSpec type)
 		{
 			this.expr = expr;
 			this.unwrap = unwrap;
 			this.loc = expr.Location;
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="205" endline="212">
<![CDATA[
 		public MethodSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition details, TypeSpec returnType,
 			MethodBase info, AParametersCollection parameters, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.parameters = parameters;
 			this.returnType = returnType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="321" endline="328">
<![CDATA[
 
 		public PredefinedType (ModuleContainer module, MemberKind kind, string ns, string name)
 		{
 			this.module = module;
 			this.kind = kind;
 			this.name = name;
 			this.ns = ns;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1729" endline="1739">
<![CDATA[
 		}
 
 		public MethodData (InterfaceMemberBase member,
 				   Modifiers modifiers, MethodAttributes flags, IMethodData method)
 		{
 			this.member = member;
 			this.modifiers = modifiers;
 			this.flags = flags;
 
 			this.method = method;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2070" endline="2077">
<![CDATA[
 
 		public Binary (Operator oper, Expression left, Expression right, Location loc)
 		{
 			this.oper = oper;
 			this.left = left;
 			this.right = right;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="907" endline="921">
<![CDATA[
 		}
 	}
 
 	//
 	// A collection of imported or resolved parameters
 	//
 	public class ParametersImported 
 	{
 		public ParametersImported (IParameterData [] parameters, TypeSpec [] types, bool hasArglist, bool hasParams)
 		{
 			this.parameters = parameters;
 			this.types = types;
 			this.has_arglist = hasArglist;
 			this.has_params = hasParams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2096" endline="2103">
<![CDATA[
 
 		private GenericTypeInstance(Type type, Type[] args, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			this.type = type;
 			this.args = args;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="91" endline="101">
<![CDATA[
 		public EmitContext (IMemberContext rc, ILGenerator ig, TypeSpec return_type)
 		{
 			this.MemberContext = rc;
 			this.ig = ig;
 
 			this.return_type = return_type;
 
 #if STATIC
 			ig.__CleverExceptionBlockAssistance ();
 #endif
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="135" endline="145">
<![CDATA[
 
 		public If (Expression bool_expr,
 			   Statement true_statement,
 			   Statement false_statement,
 			   Location l)
 		{
 			this.expr = bool_expr;
 			TrueStatement = true_statement;
 			FalseStatement = false_statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4395" endline="4409">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   Implements the ternary conditional operator (?
 	/// </summary>
 	public class Conditional 
 		Expression expr, true_expr, false_expr;
 
 		public Conditional (Expression expr, Expression true_expr, Expression false_expr, Location loc)
 		{
 			this.expr = expr;
 			this.true_expr = true_expr;
 			this.false_expr = false_expr;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="99" endline="106">
<![CDATA[
 
 		public CompletionMemberAccess (Expression e, string partial_name, TypeArguments targs, Location l)
 		{
 			this.expr = e;
 			this.loc = l;
 			this.partial_name = partial_name;
 			this.targs = targs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="47" endline="54">
<![CDATA[
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="42" endline="48">
<![CDATA[
 		internal TextSection(PEWriter peWriter, CliHeader cliHeader, ModuleBuilder moduleBuilder, int strongNameSignatureLength)
 		{
 			this.peWriter = peWriter;
 			this.cliHeader = cliHeader;
 			this.moduleBuilder = moduleBuilder;
 			this.strongNameSignatureLength = (uint)strongNameSignatureLength;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3159" endline="3173">
<![CDATA[
 		}
 
 		//
 		// The types allowed to be implicitly cast from
 		// on the governing type
 		//
 		static TypeSpec [] allowed_types;
 
 		public Switch (Expression e, ExplicitBlock block, List<SwitchSection> sects, Location l)
 		{
 			Expr = e;
 			this.block = block;
 			Sections = sects;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="514" endline="524">
<![CDATA[
 	}
 
 	class DynamicConversion 
 	{
 		public DynamicConversion (TypeSpec targetType, CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			type = targetType;
 			base.flags = flags;
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="194" endline="201">
<![CDATA[
 
 		public LineNumberEntry (int file, int row, int offset, bool is_hidden)
 		{
 			this.File = file;
 			this.Row = row;
 			this.Offset = offset;
 			this.IsHidden = is_hidden;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="233" endline="263">
<![CDATA[
 
 		public override string ToString ()
 		{
 			return String.Format ("[Line {0}
 		}
 	}
 
 	public class CodeBlockEntry
 	{
 		public int Index;
 		#region This is actually written to the symbol file
 		public int Parent;
 		public Type BlockType;
 		public int StartOffset;
 		public int EndOffset;
 		#endregion
 
 		public enum Type {
 			Lexical			= 1,
 			CompilerGenerated	= 2,
 			IteratorBody		= 3,
 			IteratorDispatcher	= 4
 		}
 
 		public CodeBlockEntry (int index, int parent, Type type, int start_offset)
 		{
 			this.Index = index;
 			this.Parent = parent;
 			this.BlockType = type;
 			this.StartOffset = start_offset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="38" endline="44">
<![CDATA[
 		public SourceFile (string name, string path, int index, bool is_include)
 		{
 			this.Index = index;
 			this.Name = name;
 			this.Path = path;
 			this.IsIncludeFile = is_include;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1614" endline="1626">
<![CDATA[
 	}
 
 	public class ImplicitCast 
 	{
 		bool arrayAccess;
 
 		public ImplicitCast (Expression expr, TypeSpec target, bool arrayAccess)
 			
 		{
 			this.loc = expr.Location;
 			this.type = target;
 			this.arrayAccess = arrayAccess;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="604" endline="611">
<![CDATA[
 
 		internal CompileUnitEntry (MonoSymbolFile file, MyBinaryReader reader)
 		{
 			this.file = file;
 
 			Index = reader.ReadInt32 ();
 			DataOffset = reader.ReadInt32 ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1200" endline="1215">
<![CDATA[
 			}
 
 			#endregion
 		}
 
 		Expression initializer;
 		protected FullNamedExpression type_expr;
 		protected LocalVariable li;
 		protected List<Declarator> declarators;
 
 		public BlockVariableDeclaration (FullNamedExpression type, LocalVariable li)
 		{
 			this.type_expr = type;
 			this.li = li;
 			this.loc = type_expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ResourceModule.cs" startline="35" endline="41">
<![CDATA[
 		internal ResourceModule(Assembly assembly, string scopeName, string location)
 			
 		{
 			this.assembly = assembly;
 			this.scopeName = scopeName;
 			this.location = location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5759" endline="5768">
<![CDATA[
 		}
 
 		LocalVariable li;
 
 		public TemporaryVariableReference (LocalVariable li, Location loc)
 		{
 			this.li = li;
 			this.type = li.Type;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4761" endline="4768">
<![CDATA[
 
 		public FieldExpr (FieldSpec spec, Location loc)
 		{
 			this.spec = spec;
 			this.loc = loc;
 
 			type = spec.MemberType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1387" endline="1405">
<![CDATA[
 	}
 
 	public class ImportedAssemblyDefinition 
 	{
 		readonly Assembly assembly;
 		readonly AssemblyName aname;
 		readonly MetadataImporter importer;
 		bool cls_compliant;
 		bool contains_extension_methods;
 
 		List<AssemblyName> internals_visible_to;
 		Dictionary<IAssemblyDefinition, AssemblyName> internals_visible_to_cache;
 
 		public ImportedAssemblyDefinition (Assembly assembly, MetadataImporter importer)
 		{
 			this.assembly = assembly;
 			this.aname = assembly.GetName ();
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="633" endline="650">
<![CDATA[
 	}
 	
 	//
 	// A delegate-creation-expression, invoked from the `New' class 
 	//
 	public class NewDelegate 
 	{
 		public Arguments Arguments;
 
 		//
 		// This constructor is invoked from the `New' expression
 		//
 		public NewDelegate (TypeSpec type, Arguments Arguments, Location loc)
 		{
 			this.type = type;
 			this.Arguments = Arguments;
 			this.loc  = loc; 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4549" endline="4561">
<![CDATA[
 		}
 
 
 		VariableDeclaration decl;
 		Statement statement;
 		bool has_ret;
 
 		public Fixed (VariableDeclaration decl, Statement stmt, Location l)
 		{
 			this.decl = decl;
 			statement = stmt;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1019" endline="1031">
<![CDATA[
 	}
 
 	public class NullCoalescingOperator 
 	{
 		Expression left, right;
 		Unwrap unwrap;
 
 		public NullCoalescingOperator (Expression left, Expression right, Location loc)
 		{
 			this.left = left;
 			this.right = right;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="611" endline="625">
<![CDATA[
 
 		#endregion
 	}
 
 	//
 	// Created from the conversion code
 	//
 	public class ImplicitDelegateCreation 
 	{
 		ImplicitDelegateCreation (TypeSpec t, MethodGroupExpr mg, Location l)
 		{
 			type = t;
 			this.method_group = mg;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="922" endline="928">
<![CDATA[
 
 		public ParametersImported (IParameterData[] param, TypeSpec[] types, bool hasParams)
 		{
 			this.parameters = param;
 			this.types = types;
 			this.has_params = hasParams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1207" endline="1221">
<![CDATA[
 	}
 
 	public class LiftedUnaryMutator 
 	{
 		public readonly UnaryMutator.Mode Mode;
 		Expression expr;
 		UnaryMutator underlying;
 		Unwrap unwrap;
 
 		public LiftedUnaryMutator (UnaryMutator.Mode mode, Expression expr, Location loc)
 		{
 			this.expr = expr;
 			this.Mode = mode;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2076" endline="2082">
<![CDATA[
 
 		protected ATypeNameExpression (string name, TypeArguments targs, Location l)
 		{
 			this.name = name;
 			this.targs = targs;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1445" endline="1486">
<![CDATA[
 	}
 
 	//
 	// The information about a user-perceived local variable
 	//
 	public class LocalVariable 
 	{
 		[Flags]
 		public enum Flags
 		{
 			Used = 1,
 			IsThis = 1 << 1,
 			AddressTaken = 1 << 2,
 			CompilerGenerated = 1 << 3,
 			Constant = 1 << 4,
 			ForeachVariable = 1 << 5,
 			FixedVariable = 1 << 6,
 			UsingVariable = 1 << 7,
 //			DefinitelyAssigned = 1 << 8,
 			IsLocked = 1 << 9,
 
 			ReadonlyMask = ForeachVariable | FixedVariable | UsingVariable
 		}
 
 		TypeSpec type;
 		readonly string name;
 		readonly Location loc;
 		readonly Block block;
 		Flags flags;
 		Constant const_value;
 
 		public VariableInfo VariableInfo;
 		HoistedVariable hoisted_variant;
 
 		LocalBuilder builder;
 
 		public LocalVariable (Block block, string name, Location loc)
 		{
 			this.block = block;
 			this.name = name;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="61" endline="80">
<![CDATA[
 		}
 	}
 
 	//
 	// A set of parsed constraints for a type parameter
 	//
 	public class Constraints
 	{
 		SimpleMemberName tparam;
 		List<FullNamedExpression> constraints;
 		Location loc;
 		bool resolved;
 		bool resolving;
 		
 		public Constraints (SimpleMemberName tparam, List<FullNamedExpression> constraints, Location loc)
 		{
 			this.tparam = tparam;
 			this.constraints = constraints;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="851" endline="867">
<![CDATA[
 	}
 
 	public class LabeledStatement 
 		string name;
 		bool defined;
 		bool referenced;
 		Label label;
 		Block block;
 
 		FlowBranching.UsageVector vectors;
 		
 		public LabeledStatement (string name, Block block, Location l)
 		{
 			this.name = name;
 			this.block = block;
 			this.loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1814" endline="1836">
<![CDATA[
 		}
 	}
 
 	//
 	// A type expression of generic type with type arguments
 	//
 	class GenericTypeExpr 
 	{
 		TypeArguments args;
 		TypeSpec open_type;
 		bool constraints_checked;
 
 		/// <summary>
 		///   Instantiate the generic type `t' with the type arguments `args'.
 		///   Use this constructor if you already know the fully resolved
 		///   generic type.
 		/// </summary>		
 		public GenericTypeExpr (TypeSpec open_type, TypeArguments args, Location l)
 		{
 			this.open_type = open_type;
 			loc = l;
 			this.args = args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="337" endline="349">
<![CDATA[
 	}
 
 	public class While 
 		public Expression expr;
 		public Statement Statement;
 		bool infinite, empty;
 
 		public While (BooleanExpression bool_expr, Statement statement, Location l)
 		{
 			this.expr = bool_expr;
 			Statement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="256" endline="267">
<![CDATA[
 	}
 
 	public class Do 
 		public Expression expr;
 		public Statement  EmbeddedStatement;
 
 		public Do (Statement statement, BooleanExpression bool_expr, Location l)
 		{
 			expr = bool_expr;
 			EmbeddedStatement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="240" endline="256">
<![CDATA[
 		}
 
 		readonly Arguments arguments;
 		protected IDynamicBinder binder;
 		protected Expression binder_expr;
 
 		// Used by BinderFlags
 		protected CSharpBinderFlags flags;
 
 		TypeSpec binder_type;
 
 		public DynamicExpressionStatement (IDynamicBinder binder, Arguments args, Location loc)
 		{
 			this.binder = binder;
 			this.arguments = args;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="73" endline="89">
<![CDATA[
 	}
 
 	public sealed class LocalBuilder
 	{
 		private readonly Type localType;
 		private readonly int index;
 		private readonly bool pinned;
 		internal string name;
 		internal int startOffset;
 		internal int endOffset;
 
 		internal LocalBuilder(Type localType, int index, bool pinned)
 		{
 			this.localType = localType;
 			this.index = index;
 			this.pinned = pinned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="968" endline="998">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Mode 
 			IsIncrement    = 0,
 			IsDecrement    = 1,
 			IsPre          = 0,
 			IsPost         = 2,
 			
 			PreIncrement   = 0,
 			PreDecrement   = IsDecrement,
 			PostIncrement  = IsPost,
 			PostDecrement  = IsPost | IsDecrement
 		}
 
 		Mode mode;
 		bool is_expr, recurse;
 
 		Expression expr;
 
 		// Holds the real operation
 		Expression operation;
 
 		static TypeSpec[] predefined;
 
 		public UnaryMutator (Mode m, Expression e, Location loc)
 		{
 			mode = m;
 			this.loc = loc;
 			expr = e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1221" endline="1241">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Base class for the `Is' and `As' classes. 
 	/// </summary>
 	///
 	/// <remarks>
 	///   FIXME
 	///   size. 
 	/// </remarks>
 	public abstract class Probe 
 		public Expression ProbeType;
 		protected Expression expr;
 		protected TypeExpr probe_type_expr;
 		
 		public Probe (Expression expr, Expression probe_type, Location l)
 		{
 			ProbeType = probe_type;
 			loc = l;
 			this.expr = expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="358" endline="371">
<![CDATA[
 	}
 
 	sealed class ParameterInfoImpl 
 	{
 		private readonly MethodDefImpl method;
 		private readonly int position;
 		private readonly int index;
 
 		internal ParameterInfoImpl(MethodDefImpl method, int position, int index)
 		{
 			this.method = method;
 			this.position = position;
 			this.index = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4853" endline="5519">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
 
 		#region Properties
 
 		public override bool IsLockedByStatement {
 			get {
 				return pi.IsLocked;
 			}
 			set	{
 				pi.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return (pi.Parameter.ModFlags & Parameter.Modifier.ISBYREF) != 0; }
 		}
 
 		bool HasOutModifier {
 			get { return pi.Parameter.ModFlags == Parameter.Modifier.OUT; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return pi.Parameter.HoistedVariant;
 		}
 
 		//
 		// A ref or out parameter is classified as a moveable variable, even 
 		// if the argument given for the parameter is a fixed variable
 		//		
 		public override bool IsFixed {
 			get { return !IsRef; }
 		}
 
 		public override string Name {
 			get { return Parameter.Name; }
 		}
 
 		public Parameter Parameter {
 			get { return pi.Parameter; }
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return pi.VariableInfo; }
 		}
 
 		protected override ILocalVariable Variable {
 			get { return Parameter; }
 		}
 
 		#endregion
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			// HACK
 			if (ec.IsInProbingMode)
 				return true;
 			
 			if (!ec.DoFlowAnalysis || !HasOutModifier || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			ec.Report.Error (269, loc, "Use of unassigned out parameter `{0}'", Name);
 			return false;
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			Parameter.HasAddressTaken = true;
 		}
 
 		void SetAssigned (ResolveContext ec)
 		{
 			if (HasOutModifier && ec.DoFlowAnalysis)
 				ec.CurrentBranching.SetAssigned (VariableInfo);
 		}
 
 		bool DoResolveBase (ResolveContext ec)
 		{
 			type = pi.ParameterType;
 			eclass = ExprClass.Variable;
 
 			//
 			// If we are referencing a parameter from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (pi)) {
 				if (Parameter.HasAddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (IsRef) {
 					ec.Report.Error (1628, loc,
 						"Parameter `{0}' cannot be used inside `{1}' when using `ref' or `out' modifier",
 						Name, ec.CurrentAnonymousMethod.ContainerType);
 				}
 
 				if (ec.IsVariableCapturingRequired && !pi.Block.ParametersBlock.IsExpressionTree) {
 					AnonymousMethodStorey storey = pi.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureParameter (ec, this);
 				}
 			}
 
 			return true;
 		}
 
 		public override int GetHashCode ()
 		{
 			return Name.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			ParameterReference pr = obj as ParameterReference;
 			if (pr == null)
 				return false;
 
 			return Name == pr.Name;
 		}
 
 		public override void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			//
 			// ParameterReferences might already be a reference
 			//
 			if (IsRef) {
 				EmitLoad (ec);
 				return;
 			}
 
 			base.AddressOf (ec, mode);
 		}
 		
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			// Nothing to clone
 			return;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			return Parameter.ExpressionTreeVariableReference ();
 		}
 
 		//
 		// Notice that for ref/out parameters, the type exposed is not the
 		// same type exposed externally.
 		//
 		// for "ref int a"
 		//   externally we expose "int&"
 		//   here we expose       "int".
 		//
 		// We record this in "is_ref".  This means that the type system can treat
 		// the type as it is expected, but when we generate the code, we generate
 		// the alternate kind of code.
 		//
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			// HACK
 			if (ec.IsInProbingMode)
 				return this;
 
 			if (HasOutModifier && ec.DoFlowAnalysis &&
 			    (!ec.OmitStructFlowAnalysis || !VariableInfo.TypeInfo.IsStruct) && !IsAssigned (ec, loc))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			SetAssigned (ec);
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		static public void EmitLdArg (EmitContext ec, int x)
 		{
 			switch (x) {
 			case 0
 			case 1
 			case 2
 			case 3
 			default
 				if (x > byte.MaxValue)
 					ec.Emit (OpCodes.Ldarg, x);
 				else
 					ec.Emit (OpCodes.Ldarg_S, (byte) x);
 				break;
 			}
 		}
 	}
 	
 	/// <summary>
 	///   Invocation of methods or delegates.
 	/// </summary>
 	public class Invocation 
 	{
 		protected Arguments arguments;
 		protected Expression expr;
 		protected MethodGroupExpr mg;
 		
 		public Invocation (Expression expr, Arguments arguments)
 		{
 			this.expr = expr;		
 			this.arguments = arguments;
 			if (expr != null)
 				loc = expr.Location;
 		}
 
 		#region Properties
 		public Arguments Arguments {
 			get {
 				return arguments;
 			}
 		}
 		
 		public Expression Expression {
 			get {
 				return expr;
 			}
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
 
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance = mg.IsInstance ?
 				mg.InstanceExpression.CreateExpressionTree (ec) 
 				new NullLiteral (loc);
 
 			var args = Arguments.CreateForExpressionTree (ec, arguments,
 				instance,
 				mg.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression member_expr;
 			var atn = expr as ATypeNameExpression;
 			if (atn != null) {
 				member_expr = atn.LookupNameExpression (ec, MemberLookupRestrictions.InvocableOnly | MemberLookupRestrictions.ReadAccess);
 				if (member_expr != null)
 					member_expr = member_expr.Resolve (ec);
 			} else {
 				member_expr = expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			}
 
 			if (member_expr == null)
 				return null;
 
 			//
 			// Next, evaluate all the expressions in the argument list
 			//
 			bool dynamic_arg = false;
 			if (arguments != null)
 				arguments.Resolve (ec, out dynamic_arg);
 
 			TypeSpec expr_type = member_expr.Type;
 			if (expr_type == InternalType.Dynamic)
 				return DoResolveDynamic (ec, member_expr);
 
 			mg = member_expr as MethodGroupExpr;
 			Expression invoke = null;
 
 			if (mg == null) {
 				if (expr_type != null && TypeManager.IsDelegateType (expr_type)) {
 					invoke = new DelegateInvocation (member_expr, arguments, loc);
 					invoke = invoke.Resolve (ec);
 					if (invoke == null || !dynamic_arg)
 						return invoke;
 				} else {
 					if (member_expr is RuntimeValueExpression) {
 						ec.Report.Error (Report.RuntimeErrorId, loc, "Cannot invoke a non-delegate type `{0}'",
 							member_expr.Type.GetSignatureForError ()); ;
 						return null;
 					}
 
 					MemberExpr me = member_expr as MemberExpr;
 					if (me == null) {
 						member_expr.Error_UnexpectedKind (ec, ResolveFlags.MethodGroup, loc);
 						return null;
 					}
 
 					ec.Report.Error (1955, loc, "The member `{0}' cannot be used as method or delegate",
 							member_expr.GetSignatureForError ());
 					return null;
 				}
 			}
 
 			if (invoke == null) {
 				mg = DoResolveOverload (ec);
 				if (mg == null)
 					return null;
 			}
 
 			if (dynamic_arg)
 				return DoResolveDynamic (ec, member_expr);
 
 			var method = mg.BestCandidate;
 			type = mg.BestCandidateReturnType;
 		
 			if (arguments == null && method.DeclaringType == TypeManager.object_type && method.Name == Destructor.MetadataName) {
 				if (mg.IsBase)
 					ec.Report.Error (250, loc, "Do not directly call your base class Finalize method. It is called automatically from your destructor");
 				else
 					ec.Report.Error (245, loc, "Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available");
 				return null;
 			}
 
 			IsSpecialMethodInvocation (ec, method, loc);
 			
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		protected virtual Expression DoResolveDynamic (ResolveContext ec, Expression memberExpr)
 		{
 			Arguments args;
 			DynamicMemberBinder dmb = memberExpr as DynamicMemberBinder;
 			if (dmb != null) {
 				args = dmb.Arguments;
 				if (arguments != null)
 					args.AddRange (arguments);
 			} else if (mg == null) {
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				args.Insert (0, new Argument (memberExpr));
 				this.expr = null;
 			} else {
 				if (mg.IsBase) {
 					ec.Report.Error (1971, loc,
 						"The base call to method `{0}' cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access",
 						mg.Name);
 					return null;
 				}
 
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				MemberAccess ma = expr as MemberAccess;
 				if (ma != null) {
 					var left_type = ma.LeftExpression as TypeExpr;
 					if (left_type != null) {
 						args.Insert (0, new Argument (new TypeOf (left_type, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						//
 						// Any value type has to be pass as by-ref to get back the same
 						// instance on which the member was called
 						//
 						var mod = TypeManager.IsValueType (ma.LeftExpression.Type) ? Argument.AType.Ref 
 						args.Insert (0, new Argument (ma.LeftExpression.Resolve (ec), mod));
 					}
 				} else {	// is SimpleName
 					if (ec.IsStatic) {
 						args.Insert (0, new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						args.Insert (0, new Argument (new This (loc).Resolve (ec)));
 					}
 				}
 			}
 
 			return new DynamicInvocation (expr as ATypeNameExpression, args, loc).Resolve (ec);
 		}
 
 		protected virtual MethodGroupExpr DoResolveOverload (ResolveContext ec)
 		{
 			return mg.OverloadResolve (ec, ref arguments, null, OverloadResolver.Restrictions.None);
 		}
 
 		static MetaType[] GetVarargsTypes (MethodSpec mb, Arguments arguments)
 		{
 			AParametersCollection pd = mb.Parameters;
 
 			Argument a = arguments[pd.Count - 1];
 			Arglist list = (Arglist) a.Expr;
 
 			return list.ArgumentTypes;
 		}
 
 		//
 		// If a member is a method or event, or if it is a constant, field or property of either a delegate type
 		// or the type dynamic, then the member is invocable
 		//
 		public static bool IsMemberInvocable (MemberSpec member)
 		{
 			switch (member.Kind) {
 			case MemberKind.Event
 				return true;
 			case MemberKind.Field
 			case MemberKind.Property
 				var m = member as IInterfaceMemberSpec;
 				return m.MemberType.IsDelegate || m.MemberType == InternalType.Dynamic;
 			default
 				return false;
 			}
 		}
 
 		public static bool IsSpecialMethodInvocation (ResolveContext ec, MethodSpec method, Location loc)
 		{
 			if (!method.IsReservedMethod)
 				return false;
 
 			if (ec.HasSet (ResolveContext.Options.InvokeSpecialName) || ec.CurrentMemberDefinition.IsCompilerGenerated)
 				return false;
 
 			ec.Report.SymbolRelatedToPreviousError (method);
 			ec.Report.Error (571, loc, "`{0}'
 				method.GetSignatureForError ());
 	
 			return true;
 		}
 
 		//
 		// Used to decide whether call or callvirt is needed
 		//
 		static bool IsVirtualCallRequired (Expression instance, MethodSpec method)
 		{
 			//
 			// There are 2 scenarious where we emit callvirt
 			//
 			// Case 1
 			// Case 2
 			// correct NRE exception when the method is called
 			//
 			var decl_type = method.DeclaringType;
 			if (decl_type.IsStruct || decl_type.IsEnum)
 				return false;
 
 			if (instance is BaseThis)
 				return false;
 
 			//
 			// It's non-virtual and will never be null
 			//
 			if (!method.IsVirtual && (instance is This || instance is New || instance is ArrayCreation || instance is DelegateCreation))
 				return false;
 
 			return true;
 		}
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
 		
 		// `dup_args' leaves an extra copy of the arguments on the stack
 		// `omit_args' does not leave any arguments at all.
 		// So, basically, you could make one call with `dup_args' set to true,
 		// and then another with `omit_args' set to true, and the two calls
 		// would have the same set of arguments. However, each argument would
 		// only have been evaluated once.
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc,
 		                             bool dup_args, bool omit_args)
 		{
 			LocalTemporary this_arg = null;
 
 			// Speed up the check by not doing it on not allowed targets
 			if (method.ReturnType == TypeManager.void_type && method.IsConditionallyExcluded (loc))
 				return;
 
 			OpCode call_op;
 			TypeSpec iexpr_type;
 
 			if (method.IsStatic) {
 				iexpr_type = null;
 				call_op = OpCodes.Call;
 			} else {
 				iexpr_type = instance_expr.Type;
 
 				if (IsVirtualCallRequired (instance_expr, method)) {
 					call_op = OpCodes.Callvirt;
 				} else {
 					call_op = OpCodes.Call;
 				}
 
 				//
 				// If this is ourselves, push "this"
 				//
 				if (!omit_args) {
 					TypeSpec t = iexpr_type;
 
 					//
 					// Push the instance expression
 					//
 					if ((iexpr_type.IsStruct && (call_op == OpCodes.Callvirt || (call_op == OpCodes.Call && method.DeclaringType == iexpr_type))) ||
 						iexpr_type.IsGenericParameter || TypeManager.IsNullableType (method.DeclaringType)) {
 						//
 						// If the expression implements IMemoryLocation, then
 						// we can optimize and use AddressOf on the
 						// return.
 						//
 						// If not we have to use some temporary storage for
 						// it.
 						var iml = instance_expr as IMemoryLocation;
 						if (iml != null) {
 							iml.AddressOf (ec, AddressOp.LoadStore);
 						} else {
 							LocalTemporary temp = new LocalTemporary (iexpr_type);
 							instance_expr.Emit (ec);
 							temp.Store (ec);
 							temp.AddressOf (ec, AddressOp.Load);
 						}
 
 						// avoid the overhead of doing this all the time.
 						if (dup_args)
 							t = ReferenceContainer.MakeType (iexpr_type);
 					} else if (iexpr_type.IsEnum || iexpr_type.IsStruct) {
 						instance_expr.Emit (ec);
 						ec.Emit (OpCodes.Box, iexpr_type);
 						t = iexpr_type = TypeManager.object_type;
 					} else {
 						instance_expr.Emit (ec);
 					}
 
 					if (dup_args) {
 						ec.Emit (OpCodes.Dup);
 						if (Arguments != null && Arguments.Count != 0) {
 							this_arg = new LocalTemporary (t);
 							this_arg.Store (ec);
 						}
 					}
 				}
 			}
 
 			if (!omit_args && Arguments != null) {
 				var dup_arg_exprs = Arguments.Emit (ec, dup_args);
 				if (dup_args) {
 					this_arg.Emit (ec);
 					LocalTemporary lt;
 					foreach (var dup in dup_arg_exprs) {
 						dup.Emit (ec);
 						lt = dup as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 			}
 
 			if (call_op == OpCodes.Callvirt && (iexpr_type.IsGenericParameter || iexpr_type.IsStruct)) {
 				ec.Emit (OpCodes.Constrained, iexpr_type);
 			}
 
 			if (method.Parameters.HasArglist) {
 				var varargs_types = GetVarargsTypes (method, Arguments);
 				ec.Emit (call_op, method, varargs_types);
 				return;
 			}
 
 			//
 			// If you have
 			// this.DoFoo ();
 			// and DoFoo is not virtual, you can omit the callvirt,
 			// because you don't need the null checking behavior.
 			//
 			ec.Emit (call_op, method);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			mg.EmitCall (ec, arguments);
 		}
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return MakeExpression (ctx, mg.InstanceExpression, mg.BestCandidate, arguments);
 		}
 
 		public static SLE.Expression MakeExpression (BuilderContext ctx, Expression instance, MethodSpec mi, Arguments args)
 		{
 #if STATIC
 			throw new NotSupportedException ();
 #else
 			var instance_expr = instance == null ? null 
 			return SLE.Expression.Call (instance_expr, (MethodInfo) mi.GetMetaInfo (), Arguments.MakeExpression (args, ctx));
 #endif
 		}
 	}
 
 	//
 	// Implements simple new expression 
 	//
 	public class New 
 	{
 		protected Arguments arguments;
 
 		//
 		// During bootstrap, it contains the RequestedType,
 		// but if `type' is not null, it *might* contain a NewDelegate
 		// (because of field multi-initialization)
 		//
 		protected Expression RequestedType;
 
 		protected MethodSpec method;
 
 		public New (Expression requested_type, Arguments arguments, Location l)
 		{
 			RequestedType = requested_type;
 			this.arguments = arguments;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="692" endline="708">
<![CDATA[
 	}
 
 	//
 	// Invocation converted to delegate Invoke call
 	//
 	class DelegateInvocation 
 	{
 		readonly Expression InstanceExpr;
 		Arguments arguments;
 		MethodSpec method;
 		
 		public DelegateInvocation (Expression instance_expr, Arguments args, Location loc)
 		{
 			this.InstanceExpr = instance_expr;
 			this.arguments = args;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8032" endline="8049">
<![CDATA[
 	}
 
 	/// <summary>
 	///   An Element Access expression.
 	///
 	///   During semantic analysis these are transformed into 
 	///   IndexerAccess, ArrayAccess or a PointerArithmetic.
 	/// </summary>
 	public class ElementAccess 
 		public Arguments Arguments;
 		public Expression Expr;
 
 		public ElementAccess (Expression e, Arguments args, Location loc)
 		{
 			Expr = e;
 			this.loc = loc;
 			this.Arguments = args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="44" endline="50">
<![CDATA[
 
 		private FieldSignature(Type fieldType, Type[] optionalCustomModifiers, Type[] requiredCustomModifiers)
 		{
 			this.fieldType = fieldType;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9058" endline="9073">
<![CDATA[
 	}
 
 	//
 	// Implements the `stackalloc' keyword
 	//
 	public class StackAlloc 
 		TypeSpec otype;
 		Expression t;
 		Expression count;
 		
 		public StackAlloc (Expression type, Expression count, Location l)
 		{
 			t = type;
 			this.count = count;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="86" endline="98">
<![CDATA[
 	}
 	
 	public class CompletionMemberAccess 
 		Expression expr;
 		string partial_name;
 		TypeArguments targs;
 		
 		public CompletionMemberAccess (Expression e, string partial_name, Location l)
 		{
 			this.expr = e;
 			this.loc = l;
 			this.partial_name = partial_name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1296" endline="1309">
<![CDATA[
 		}
 
 		protected ParametersBlock block;
 
 		public TypeSpec ReturnType;
 
 		object return_label;
 
 		protected AnonymousExpression (ParametersBlock block, TypeSpec return_type, Location loc)
 		{
 			this.ReturnType = return_type;
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="97" endline="108">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParameterList = Nothing) As Parameter
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParameterList)
         Dim result As New Parameter(NewParent)
         result.m_CustomAttributes = m_CustomAttributes
         result.m_Modifiers = m_Modifiers
         result.m_ParameterIdentifier = m_ParameterIdentifier.Clone(result)
         If m_TypeName IsNot Nothing Then result.m_TypeName = m_TypeName.Clone(result)
         If m_ConstantExpression IsNot Nothing Then result.m_ConstantExpression = m_ConstantExpression.Clone(result)
         result.UpdateDefinition()
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="124" endline="136">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attribute
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attribute(NewParent)
         result.m_IsAssembly = m_IsAssembly
         result.m_IsModule = m_IsModule
         If m_SimpleTypeName IsNot Nothing Then result.m_SimpleTypeName = m_SimpleTypeName.Clone(result)
         If m_AttributeArguments IsNot Nothing Then result.m_AttributeArguments = m_AttributeArguments.Clone(result)
         result.m_ResolvedType = m_ResolvedType
         result.m_ResolvedTypeConstructor = m_ResolvedTypeConstructor
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="79" endline="95">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New MemberAccessExpression(NewParent)
 
         Dim m_First As Expression = Nothing
         Dim m_Second As IdentifierOrKeyword = Nothing
         '  Dim m_TypeArguments As TypeParameters
 
         If Me.m_First IsNot Nothing Then m_First = Me.m_First.Clone(result)
         If Me.m_Second IsNot Nothing Then m_Second = Me.m_Second.Clone(result)
         '  If Me.m_TypeArguments IsNot Nothing Then m_TypeArguments = Me.m_TypeArguments.Clone(result)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="520" endline="531">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodReference, ByVal Arguments As Mono.Collections.Generic.Collection(Of TypeReference), Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim mD As MethodDefinition = TryCast(Member, MethodDefinition)
 
         If mD IsNot Nothing Then Return GetCorrectMember(mD, Arguments, Emittable)
         If Member.OriginalMethod IsNot Nothing Then
             mD = TryCast(Member.OriginalMethod, MethodDefinition)
             If mD IsNot Nothing Then Return GetCorrectMember(mD, Arguments, Emittable)
         End If
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="47" endline="57">
<![CDATA[
 
     Shadows Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As IdentifierOrKeywordWithTypeArguments
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New IdentifierOrKeywordWithTypeArguments(NewParent)
         If m_TypeArguments IsNot Nothing Then
             result.Init(Me.Identifier, Me.Keyword, m_TypeArguments.Clone(result))
         Else
             result.Init(Me.Identifier, Me.Keyword, Nothing)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="222" endline="236">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddAnonymousType (AnonymousTypeClass type)
 		{
 			List<AnonymousTypeClass> existing;
 			if (!anonymous_types.TryGetValue (type.Parameters.Count, out existing))
 			if (existing == null) {
 				existing = new List<AnonymousTypeClass> ();
 				anonymous_types.Add (type.Parameters.Count, existing);
 			}
 
 			existing.Add (type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="562" endline="577">
<![CDATA[
 		}
 
 		internal override Type GetTypeImpl(string typeName)
 		{
 			PopulateTypeDef();
 			Type type;
 			if (!types.TryGetValue(typeName, out type))
 			{
 				LazyForwardedType fw;
 				if (forwardedTypes.TryGetValue(typeName, out fw))
 				{
 					return fw.GetType(this, typeName);
 				}
 			}
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1915" endline="1926">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			GenericTypeExpr cobj = obj as GenericTypeExpr;
 			if (cobj == null)
 				return false;
 
 			if ((type == null) || (cobj.type == null))
 				return false;
 
 			return type == cobj.type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="27" endline="35">
<![CDATA[
         Get
             Dim result As String = ""
             If m_PropertyAccess.InstanceExpression IsNot Nothing Then
                 result = m_PropertyAccess.InstanceExpression.AsString & "."
             End If
             result &= m_PropertyAccess.ResolvedProperty.Name
             result &= "(" & m_PropertyAccess.Parameters.AsString & ")"
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="469" endline="475">
<![CDATA[
     End Property
 
     ReadOnly Property SpecialString() As String
         Get
             If TypeOf m_TokenObject Is KS Then Return DirectCast(m_TokenObject, KS).ToString()
             Return "not a symbol"
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="26" endline="32">
<![CDATA[
 
     Sub AddType(ByVal Type As Mono.Cecil.TypeReference)
         Dim [namespace] As String = Type.Namespace
 
         If [namespace] Is Nothing Then [namespace] = String.Empty
         GetTypes([namespace]).Add(Type)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6838" endline="6848">
<![CDATA[
 		}
 
 		#endregion
 
 		public void CheckStructThisDefiniteAssignment (ResolveContext rc)
 		{
 			if (variable_info != null && !variable_info.IsAssigned (rc)) {
 				rc.Report.Error (188, loc,
 					"The `this' object cannot be used before all of its fields are assigned to");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="546" endline="555">
<![CDATA[
 
 		[Conditional ("FULL_AST")]
 		public void AppendTo (object existing, params Location[] locations)
 		{
 			Location[] locs;
 			if (simple_locs.TryGetValue (existing, out locs)) {
 				simple_locs [existing] = locs.Concat (locations).ToArray ();
 				return;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4012" endline="4024">
<![CDATA[
 
 		public void AddResumePoint (ResumableStatement stmt, int pc)
 		{
 			if (resume_points == null) {
 				resume_points = new List<ResumableStatement> ();
 				first_resume_pc = pc;
 			}
 
 			if (pc != first_resume_pc + resume_points.Count)
 				throw new InternalErrorException ("missed an intervening AddResumePoint?");
 
 			resume_points.Add (stmt);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1427" endline="1440">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			ConstructorBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="1394" endline="1408">
<![CDATA[
 
 		void AddAssemblyReference (string alias, string assembly)
 		{
 			if (assembly.Length == 0) {
 				Report.Error (1680, "Invalid reference alias `{0}='. Missing filename", alias);
 				return;
 			}
 
 			if (!IsExternAliasValid (alias)) {
 				Report.Error (1679, "Invalid extern alias for -reference. Alias `{0}' is not a valid identifier", alias);
 				return;
 			}
 
 			RootContext.AssemblyReferencesAliases.Add (Tuple.Create (alias, assembly));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="285" endline="295">
<![CDATA[
 
 		public void Emit (OpCode opcode, MethodSpec method)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				method = method.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 			if (method.IsConstructor)
 				ig.Emit (opcode, (ConstructorInfo) method.GetMetaInfo ());
 			else
 				ig.Emit (opcode, (MethodInfo) method.GetMetaInfo ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ModuleWriter.cs" startline="301" endline="319">
<![CDATA[
 
 		private static int ComputeStrongNameSignatureLength(byte[] publicKey)
 		{
 			if (publicKey == null)
 			{
 				return 0;
 			}
 			else if (publicKey.Length == 16)
 			{
 				// it must be the ECMA pseudo public key, we don't know the key size of the real key, but currently both Mono and Microsoft use a 1024 bit key size
 				return 128;
 			}
 			else
 			{
 				// for the supported strong naming algorithms, the signature size is the same as the key size
 				// (we have to subtract 32 for the header)
 				return publicKey.Length - 32;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2813" endline="2822">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.ComImport && !attributes.Contains (pa.Guid)) {
 				a.Error_MissingGuidAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2063" endline="2074">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (scope_initializers != null)
 				EmitScopeInitializers (ec);
 
 			ec.Mark (StartLocation);
 			DoEmit (ec);
 
 			if (SymbolWriter.HasSymbolWriter)
 				EmitSymbolInfo (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="238" endline="250">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			if (prepare_for_load)
 				throw new NotImplementedException ();
 
 			source.Emit (ec);
 
 			Store (ec);
 
 			if (leave_copy)
 				Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="95" endline="102">
<![CDATA[
 
 		public MemberName (MemberName left, MemberName right, Location loc)
 			
 		{
 			if (right.is_double_colon)
 				throw new InternalErrorException ("Cannot append double_colon member name");
 			this.Left = (right.Left == null) ? left 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="72" endline="81">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = New ParameterList(Me, Parameters)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="152" endline="159">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal EnumVariable As EnumMemberDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(EnumVariable IsNot Nothing)
         m_EnumVariable = EnumVariable
         m_Type = m_EnumVariable.FindFirstParent(Of EnumDeclaration).EnumConstantType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="51" endline="61">
<![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="175" endline="182">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Constant As ConstantDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Constant IsNot Nothing)
         m_Constant = Constant
         m_Type = Constant.FieldType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="62" endline="72">
<![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         m_TypeName = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="74" endline="80">
<![CDATA[
 
     Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String)
         m_Modifiers = Modifiers
         m_Name = Name
 
         If m_Name Is Nothing Then Throw New InternalException(Me.Location.ToString(Compiler))
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="992" endline="1338">
<![CDATA[
 
 		Expression initializer;
 		Field backing_field;
 		List<FieldDeclarator> declarators;
 
 		public EventField (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			Add = new AddDelegateMethod (this);
 			Remove = new RemoveDelegateMethod (this);
 		}
 
 		#region Properties
 
 		bool HasBackingField {
 			get {
 				return !IsInterface && (ModFlags & Modifiers.ABSTRACT) == 0;
 			}
 		}
 
 		public Expression Initializer {
 			get {
 				return initializer;
 			}
 			set {
 				initializer = value;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return HasBackingField ? attribute_targets 
 			}
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Field) {
 				backing_field.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				int errors = Report.Errors;
 				Add.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				if (errors == Report.Errors)
 					Remove.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override bool Define()
 		{
 			var mod_flags_src = ModFlags;
 
 			if (!base.Define ())
 				return false;
 
 			if (declarators != null) {
 				if ((mod_flags_src & Modifiers.DEFAULT_ACCESS_MODIFER) != 0)
 					mod_flags_src &= ~(Modifiers.AccessibilityMask | Modifiers.DEFAULT_ACCESS_MODIFER);
 
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Events.IndexOf (this);
 				foreach (var d in declarators) {
 					var ef = new EventField (Parent, t, mod_flags_src, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 
 					if (d.Initializer != null)
 						ef.initializer = d.Initializer;
 
 					Parent.PartialContainer.Events.Insert (++index, ef);
 				}
 			}
 
 			if (!HasBackingField) {
 				SetIsUsed ();
 				return true;
 			}
 
 			if (Add.IsInterfaceImplementation)
 				SetIsUsed ();
 
 			backing_field = new Field (Parent,
 				new TypeExpression (MemberType, Location),
 				Modifiers.BACKING_FIELD | Modifiers.COMPILER_GENERATED | Modifiers.PRIVATE | (ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE)),
 				MemberName, null);
 
 			Parent.PartialContainer.AddField (backing_field);
 			backing_field.Initializer = Initializer;
 			backing_field.ModFlags &= ~Modifiers.COMPILER_GENERATED;
 
 			// Call define because we passed fields definition
 			backing_field.Define ();
 
 			// Set backing field for event fields
 			spec.BackingField = backing_field.Spec;
 
 			return true;
 		}
 	}
 
 	public abstract class Event 
 	{
 		public abstract class AEventAccessor 
 		{
 			protected readonly Event method;
 			ParametersCompiled parameters;
 
 			static readonly string[] attribute_targets = new string [] { "method", "param", "return" };
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Event;
 			}
 		}
 
 		public AEventAccessor Add {
 			get {
 				return this.add;
 			}
 			set {
 				add = value;
 				Parent.AddMember (value);
 			}
 		}
 
 		public AEventAccessor Remove {
 			get {
 				return this.remove;
 			}
 			set {
 				remove = value;
 				Parent.AddMember (value);
 			}
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			EventBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsDelegateType (MemberType)) {
 				Report.Error (66, Location, "`{0}'
 			}
 
 			if (!CheckBase ())
 				return false;
 
 			//
 			// Now define the accessors
 			//
 			var AddBuilder = Add.Define (Parent);
 			if (AddBuilder == null)
 				return false;
 
 			var RemoveBuilder = remove.Define (Parent);
 			if (RemoveBuilder == null)
 				return false;
 
 			EventBuilder = Parent.TypeBuilder.DefineEvent (GetFullName (MemberName), EventAttributes.None, MemberType.GetMetaInfo ());
 			EventBuilder.SetAddOnMethod (AddBuilder);
 			EventBuilder.SetRemoveOnMethod (RemoveBuilder);
 
 			spec = new EventSpec (Parent.Definition, this, MemberType, ModFlags, Add.Spec, remove.Spec);
 
 			Parent.MemberCache.AddMember (this, Name, spec);
 			Parent.MemberCache.AddMember (this, AddBuilder.Name, Add.Spec);
 			Parent.MemberCache.AddMember (this, RemoveBuilder.Name, remove.Spec);
 
 			return true;
 		}
 
 		public override void Emit ()
 		{
 			CheckReservedNameConflict (null, add.Spec);
 			CheckReservedNameConflict (null, remove.Spec);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			Add.Emit (Parent);
 			Remove.Emit (Parent);
 
 			base.Emit ();
 		}
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { return "E
 		}
 	}
 
 	public class EventSpec 
 	{
 		MethodSpec add, remove;
 		FieldSpec backing_field;
 
 		public EventSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec eventType, Modifiers modifiers, MethodSpec add, MethodSpec remove)
 			
 		{
 			this.AccessorAdd = add;
 			this.AccessorRemove = remove;
 			this.MemberType = eventType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1172" endline="1186">
<![CDATA[
 	}
 
 	/// <summary>
 	/// 	This is an explicit numeric cast from a Decimal
 	/// </summary>
 	public class CastFromDecimal 
 	{
 		static Dictionary<TypeSpec, MethodSpec> operators;
 
 		public CastFromDecimal (Expression child, TypeSpec return_type)
 			
 		{
 			if (child.Type != TypeManager.decimal_type)
 				throw new ArgumentException ("Expected decimal child " + child.Type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="621" endline="627">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			StatementExpression target = (StatementExpression) t;
 
 			target.expr = (ExpressionStatement) expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="150" endline="156">
<![CDATA[
 
 		internal void WriteFieldRecords(MetadataWriter mw)
 		{
 			mw.Write((short)attribs);
 			mw.WriteStringIndex(nameIndex);
 			mw.WriteBlobIndex(signature);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9014" endline="9021">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 			
 			ec.EmitInt (0);
 			ec.Emit (OpCodes.Ldelema, array_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1668" endline="1683">
<![CDATA[
 
 		/// <summary>
 		///  Returns whether an explicit reference conversion can be performed
 		///  from source_type to target_type
 		/// </summary>
 		public static bool ExplicitReferenceConversionExists (TypeSpec source_type, TypeSpec target_type)
 		{
 			Expression e = ExplicitReferenceConversion (null, source_type, target_type);
 			if (e == null)
 				return false;
 
 			if (e == EmptyExpression.Null)
 				return true;
 
 			throw new InternalErrorException ("Invalid probing conversion result");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1682" endline="1692">
<![CDATA[
 
 		public bool IsThisAssigned (BlockContext ec, Block block)
 		{
 			if (VariableInfo == null)
 				throw new Exception ();
 
 			if (!ec.DoFlowAnalysis || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			return VariableInfo.TypeInfo.IsFullyInitialized (ec, VariableInfo, block.StartLocation);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="220" endline="238">
<![CDATA[
 		}
 
 		internal uint StartupStubLength
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64)
 				{
 					return 12;
 				}
 				else if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64)
 				{
 					return 48;
 				}
 				else
 				{
 					return 6;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="818" endline="834">
<![CDATA[
 		}
 
 		public override bool HasUnresolvedConstraints {
 			get {
 				if (CurrentTypeParameters == null)
 					return false;
 
 				// When overriding base method constraints are fetched from
 				// base method but to find it we have to resolve parameters
 				// to find exact base method match
 				if (IsExplicitImpl || (ModFlags & Modifiers.OVERRIDE) != 0)
 					return base_method == null;
 
 				// Even for non-override generic method constraints check has to be
 				// delayed after all constraints are resolved
 				return true;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1935" endline="1949">
<![CDATA[
 
 		public bool ResolveBuilder ()
 		{
 			if (ctor != null)
 				return true;
 
 			//
 			// Handle all parameter-less attributes as optional
 			//
 			if (!IsDefined)
 				return false;
 
 			ctor = TypeManager.GetPredefinedConstructor (type, Location.Null, TypeSpec.EmptyTypes);
 			return ctor != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="150" endline="163">
<![CDATA[
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is MethodCore) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			if (overload is AbstractPropertyEventMethod)
 				return true;
 
 			return base.EnableOverloadChecks (overload);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6282" endline="6299">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (type != null)
 				return this;
 
 			if (!ResolveArrayType (ec))
 				return null;
 
 			//
 			// validate the initializers and fill in any missing bits
 			//
 			if (!ResolveInitializers (ec))
 				return null;
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1625" endline="1641">
<![CDATA[
 
 		//
 		// Look for the best storey for this anonymous method
 		//
 		AnonymousMethodStorey FindBestMethodStorey ()
 		{
 			//
 			// Use the nearest parent block which has a storey
 			//
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 					
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="490" endline="496">
<![CDATA[
 
     Shared Function IsInterface(ByVal Context As BaseObject, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If TypeOf Type Is Mono.Cecil.GenericParameter Then Return False
         If TypeOf Type Is Mono.Cecil.ArrayType Then Return False
         If TypeOf Type Is ByReferenceType Then Return False
         Return CecilHelper.FindDefinition(Type).IsInterface
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1054" endline="1066">
<![CDATA[
 
     Public Shared Function IsPrimitive(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Select Case Helper.GetTypeCode(Compiler, Type)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Char, TypeCode.Double, TypeCode.Single
                 Return True
             Case Else
                 If Helper.CompareType(Type, Compiler.TypeCache.System_IntPtr) Then
                     Return True
                 Else
                     Return False
                 End If
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3380" endline="3397">
<![CDATA[
 
     ''' <summary>
     ''' AddressOfExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddressOfExpression(ByVal Parent As ParsedObject) As AddressOfExpression
         Dim result As New AddressOfExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.AddressOf)
 
         m_Expression = ParseExpression(result)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5880" endline="5891">
<![CDATA[
 
     Private Function ParseCallStatement(ByVal Parent As ParsedObject) As CallStatement
         Dim result As New CallStatement(Parent)
 
         Dim m_Target As Expression
         tm.AcceptIfNotInternalError(KS.Call)
         m_Target = ParseExpression(result)
 
         result.Init(m_Target)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="614" endline="622">
<![CDATA[
 
 		public void Emit (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			ParameterReference.EmitLdArg (ec, arg_idx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4834" endline="4840">
<![CDATA[
 
 		public void SetHasAddressTaken ()
 		{
 			IVariableReference vr = InstanceExpression as IVariableReference;
 			if (vr != null)
 				vr.SetHasAddressTaken ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="285" endline="292">
<![CDATA[
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			bw.WriteLeb128 ((int) BlockType);
 			bw.WriteLeb128 (Parent);
 			bw.WriteLeb128 (StartOffset);
 			bw.WriteLeb128 (EndOffset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5304" endline="5310">
<![CDATA[
 
 		void Error_PropertyNotValid (ResolveContext ec)
 		{
 			ec.Report.SymbolRelatedToPreviousError (best_candidate);
 			ec.Report.Error (1546, loc, "Property or event `{0}' is not supported by the C# language",
 				GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="305" endline="311">
<![CDATA[
 
     Sub Init()
         InitOptimizations()
         InitAssemblies()
         InitInternal()
         InitVBNCTypes()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1205" endline="1211">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			child.Emit (ec);
 
 			ec.Emit (OpCodes.Call, operators [type]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="181" endline="187">
<![CDATA[
 
 		public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes)
 		{
 			this.attr = genericParameterAttributes;
 			// for now we'll back patch the table
 			this.ModuleBuilder.GenericParam.PatchAttribute(paramPseudoIndex, genericParameterAttributes);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="60" endline="70">
<![CDATA[
 				
 		/// <summary>
 		///   Return value indicates whether all code paths emitted return.
 		/// </summary>
 		protected abstract void DoEmit (EmitContext ec);
 
 		public virtual void Emit (EmitContext ec)
 		{
 			ec.Mark (loc);
 			DoEmit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8333" endline="8340">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			var ac = (ArrayContainer) ea.Expr.Type;
 
 			LoadArrayAndArguments (ec);
 			ec.EmitArrayAddress (ac);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="141" endline="147">
<![CDATA[
 
 		public void __SetAssemblyCulture(string cultureName)
 		{
 			AssemblyName oldName = GetName();
 			this.culture = cultureName;
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="72" endline="78">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal InnerException As Exception)
         MyBase.New("", InnerException)
         m_Message = "There has been an internal error in the compiler
 StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="499" endline="519">
<![CDATA[
 
 		/// <summary>
 		///   Emits the code for the expression
 		/// </summary>
 		///
 		/// <remarks>
 		///   The Emit method is invoked to generate the code
 		///   for the expression.  
 		/// </remarks>
 		public abstract void Emit (EmitContext ec);
 
 
 		// Emit code to branch to @target if this expression is equivalent to @on_true.
 		// The default implementation is to emit the value, and then emit a brtrue or brfalse.
 		// Subclasses can provide more efficient implementations, but those MUST be equivalent,
 		// including the use of conditional branches.  Note also that a branch MUST be emitted
 		public virtual void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			Emit (ec);
 			ec.Emit (on_true ? OpCodes.Brtrue 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="206" endline="212">
<![CDATA[
 
 		static void Error_InvalidNamedArgumentType (ResolveContext rc, NamedArgument name)
 		{
 			rc.Report.Error (655, name.Location,
 				"`{0}' is not a valid named attribute argument because it is not a valid attribute parameter type",
 				name.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="198" endline="205">
<![CDATA[
 
 		static void Error_InvalidNamedArgument (ResolveContext rc, NamedArgument name)
 		{
 			rc.Report.Error (617, name.Location, "`{0}' is not a valid named attribute argument. Named attribute arguments " +
 				      "must be fields which are not readonly, static, const or read-write properties which are " +
 				      "public and not static",
 			      name.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="750" endline="756">
<![CDATA[
 
 		public override void Error_AlreadyDeclared (string name, INamedBlockVariable variable)
 		{
 			TopBlock.Report.Error (1930, variable.Location,
 				"A range variable `{0}' has already been declared in this scope",
 				name);		
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="743" endline="749">
<![CDATA[
 
 		public override void Error_AlreadyDeclared (string name, INamedBlockVariable variable, string reason)
 		{
 			TopBlock.Report.Error (1931, variable.Location,
 				"A range variable `{0}' conflicts with a previous declaration of `{0}'",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1899" endline="1905">
<![CDATA[
 					
 		public virtual void Error_AlreadyDeclaredTypeParameter (string name, Location loc)
 		{
 			ParametersBlock.TopBlock.Report.Error (412, loc,
 				"The type parameter name `{0}' is the same as local variable or parameter name",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\literal.cs" startline="200" endline="206">
<![CDATA[
 
 		static void Error_664 (ResolveContext ec, Location loc, string type, string suffix)
 		{
 			ec.Report.Error (664, loc,
 				"Literal of type double cannot be implicitly converted to type `{0}'. Add suffix `{1}' to create a literal of this type",
 				type, suffix);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="66" endline="72">
<![CDATA[
 
 		public override void Error_NamespaceDoesNotExist (Location loc, string name, int arity, IMemberContext ctx)
 		{
 			ctx.Compiler.Report.Error (400, loc,
 				"The type or namespace name `{0}' could not be found in the global namespace (are you missing an assembly reference?)",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="757" endline="763">
<![CDATA[
 
 		public override void Error_AlreadyDeclaredTypeParameter (string name, Location loc)
 		{
 			TopBlock.Report.Error (1948, loc,
 				"A range variable `{0}' conflicts with a method type parameter",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1184" endline="1190">
<![CDATA[
 
 		public static void Error_AddressOfCapturedVar (ResolveContext ec, IVariableReference var, Location loc)
 		{
 			ec.Report.Error (1686, loc,
 				"Local variable or parameter `{0}' cannot have their address taken and be used inside an anonymous method or lambda expression",
 				var.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="325" endline="335">
<![CDATA[
 
     ReadOnly Property Identifier() As String
         Get
             If IsKeyword() Then
                 Return Enums.strSpecial(Keyword)
             ElseIf IsIdentifier() Then
                 Return DirectCast(m_TokenObject, String)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="32" endline="41">
<![CDATA[
 
     Public Overrides Function ToString() As String
         If Me.IsIdentifier Then
             Return Me.Identifier
         ElseIf Me.IsKeyword Then
             Return Me.Identifier
         Else
             Return "<Token>"
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="168" endline="177">
<![CDATA[
 
     Function IdentiferOrKeywordIdentifier() As String
         If IsKeyword() Then
             Return Identifier
         ElseIf IsIdentifier() Then
             Return Identifier
         Else
             Throw New InternalException()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\Statement.vb" startline="24" endline="32">
<![CDATA[
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="63" endline="72">
<![CDATA[
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Me.IsArraySizeInitializationModifier Then
             Return Me.AsArraySizeInitializationModifier.CreateArrayType(OriginalType)
         ElseIf Me.IsArrayTypeModifiers Then
             Return Me.AsArrayTypeModifiers.CreateArrayType(OriginalType)
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="303" endline="320">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal GotoNewline As Boolean, ByVal MessageParameters() As String) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation, MessageParameters)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="507" endline="519">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="472" endline="488">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8560" endline="8566">
<![CDATA[
 
 		#region IBaseMembersProvider Members
 
 		IList<MemberSpec> OverloadResolver.IBaseMembersProvider.GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="186" endline="194">
<![CDATA[
 		}
 
 		public override string Name
 		{
 			get
 			{
 				string fullname = FullName;
 				return fullname.Substring(fullname.LastIndexOf('.') + 1);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1325" endline="1332">
<![CDATA[
 	
 		// 
 		// root_types contains all the types.  All TopLevel types
 		// hence have a parent that points to `root_types', that is
 		// why there is a non-obvious test down here.
 		//
 		public bool IsTopLevel {
 			get { return (Parent != null && Parent.Parent == null); }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="556" endline="563">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = break_origins;
 			break_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="580" endline="587">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = continue_origins;
 			continue_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="645" endline="654">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.WriteParam()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1847" endline="1856">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMemberForwarded()
 				.WriteStringIndex()
 				.WriteModuleRef()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1979" endline="1988">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(16)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2150" endline="2159">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1003" endline="1009">
<![CDATA[
 
 		#region Properties
 
 		bool HasBackingField {
 			get {
 				return !IsInterface && (ModFlags & Modifiers.ABSTRACT) == 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="763" endline="769">
<![CDATA[
 		}
 
 		public static ParameterAttributes GetParameterAttribute (Parameter.Modifier modFlags)
 		{
 			return (modFlags & Parameter.Modifier.OUT) == Parameter.Modifier.OUT ?
 				ParameterAttributes.Out 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="277" endline="283">
<![CDATA[
 
 		#region Properties
 
 		public bool IsReadOnly {
 			get {
 				return (Modifiers & Modifiers.READONLY) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="253" endline="259">
<![CDATA[
 		}
 
 		// When is virtual or abstract
 		public bool IsVirtual {
 			get {
 				return (Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE)) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ParameterInfo.cs" startline="50" endline="64">
<![CDATA[
 
 		public abstract string Name { get; }
 		public abstract Type ParameterType { get; }
 		public abstract ParameterAttributes Attributes { get; }
 		public abstract int Position { get; }
 		public abstract object RawDefaultValue { get; }
 		public abstract Type[] GetOptionalCustomModifiers();
 		public abstract Type[] GetRequiredCustomModifiers();
 		public abstract MemberInfo Member { get; }
 		public abstract int MetadataToken { get; }
 		internal abstract Module Module { get; }
 
 		public bool IsIn
 		{
 			get { return (Attributes & ParameterAttributes.In) != 0; }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\EventInfo.cs" startline="32" endline="45">
<![CDATA[
 		}
 
 		public abstract EventAttributes Attributes { get; }
 		public abstract MethodInfo GetAddMethod(bool nonPublic);
 		public abstract MethodInfo GetRaiseMethod(bool nonPublic);
 		public abstract MethodInfo GetRemoveMethod(bool nonPublic);
 		public abstract MethodInfo[] GetOtherMethods(bool nonPublic);
 		public abstract Type EventHandlerType { get; }
 		internal abstract bool IsPublic { get; }
 		internal abstract bool IsStatic { get; }
 
 		public bool IsSpecialName
 		{
 			get { return (Attributes & EventAttributes.SpecialName) != 0; }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="268" endline="284">
<![CDATA[
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="62" endline="71">
<![CDATA[
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifiers(ByVal Modifier As ModifierMasks) As Modifiers
         m_ModifierMask = m_ModifierMask Or Modifier
         Return Me
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2028" endline="2043">
<![CDATA[
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKeyOrToken = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKeyOrToken = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1929" endline="1962">
<![CDATA[
 	}
 
 	sealed class AssemblyTable 
 	{
 		internal const int Index = 0x20;
 
 		internal struct Record
 		{
 			internal int HashAlgId;
 			internal ushort MajorVersion;
 			internal ushort MinorVersion;
 			internal ushort BuildNumber;
 			internal ushort RevisionNumber;
 			internal int Flags;
 			internal int PublicKey;
 			internal int Name;
 			internal int Culture;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].HashAlgId = mr.ReadInt32();
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKey = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].HashAlgId = mr.ReadInt32();
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKey = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1597" endline="1622">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 				int token = records[i].Association;
 				// do the HasSemantics encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case EventTable.Index
 						token = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case PropertyTable.Index
 						token = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Association = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 				int token = records[i].Association;
 				// do the HasSemantics encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case EventTable.Index
 						token = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case PropertyTable.Index
 						token = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Association = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="163" endline="174">
<![CDATA[
     End Property
 
     ReadOnly Property FieldDefinition() As Mono.Cecil.FieldDefinition
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return CecilHelper.FindDefinition(m_FieldInfo)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1441" endline="1453">
<![CDATA[
 
 		bool Define (ResolveContext ec)
 		{
 			if (!Block.Resolved && Compatible (ec) == null)
 				return false;
 
 			if (block_name == null) {
 				MemberCore mc = (MemberCore) ec.MemberContext;
 				block_name = mc.MemberName.Basename;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="546" endline="562">
<![CDATA[
 
 		protected override Expression ResolveUserOperator (ResolveContext ec, Expression expr)
 		{
 			expr = base.ResolveUserOperator (ec, expr);
 			if (expr == null)
 				return null;
 
 			//
 			// When a user operator is of non-nullable type
 			//
 			if (Expr is Unwrap) {
 				user_operator = LiftExpression (ec, expr);
 				return user_operator;
 			}
 
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1345" endline="1356">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				if (rank == 1)
 					info = Element.GetMetaInfo ().MakeArrayType ();
 				else
 					info = Element.GetMetaInfo ().MakeArrayType (rank);
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="696" endline="720">
<![CDATA[
 
     ''' <summary>
     ''' AttributeArgumentExpression  
     '''   ConstantExpression  |
     '''   GetTypeExpression  |
     '''   ArrayCreationExpression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeArgumentExpression(ByVal Parent As ParsedObject) As AttributeArgumentExpression
         Dim result As New AttributeArgumentExpression(Parent)
 
         Dim m_Expression As Expression
 
         If tm.CurrentToken = KS.GetType Then
             m_Expression = ParseGetTypeExpression(result)
         ElseIf tm.CurrentToken = KS.[New] Then
             m_Expression = ParseArrayCreationExpression(result)
         Else
             m_Expression = ParseExpression(result)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="175" endline="186">
<![CDATA[
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8118" endline="8132">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			type = Expr.Type;
 
 			var res = CreateAccessExpression (ec);
 			if (res == null)
 				return null;
 
 			return res.ResolveLValue (ec, right_side);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8102" endline="8117">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			type = Expr.Type;
 
 			// TODO
 			var res = CreateAccessExpression (ec);
 			if (res == null)
 				return null;
 
 			return res.Resolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1352" endline="1386">
<![CDATA[
 
 		//
 		// Reads assembly attributes which where attached to a special type because
 		// module does have assembly manifest
 		//
 		public List<Attribute> ReadAssemblyAttributes ()
 		{
 			var t = module.GetType (AssemblyAttributesPlaceholder.GetGeneratedName (Name));
 			if (t == null)
 				return null;
 
 			var field = t.GetField (AssemblyAttributesPlaceholder.AssemblyFieldName, BindingFlags.NonPublic | BindingFlags.Static);
 			if (field == null)
 				return null;
 
 			// TODO
 			// add it to OptAttributes before resolving the source code attributes
 			// Need to build module location as well for correct error reporting
 
 			//var assembly_attributes = CustomAttributeData.GetCustomAttributes (field);
 			//var attrs = new List<Attribute> (assembly_attributes.Count);
 			//foreach (var a in assembly_attributes)
 			//{
 			//    var type = metaImporter.ImportType (a.Constructor.DeclaringType);
 			//    var ctor = metaImporter.CreateMethod (a.Constructor, type);
 
 			//    foreach (var carg in a.ConstructorArguments) {
 			//        carg.Value
 			//    }
 
 			//    attrs.Add (new Attribute ("assembly", ctor, null, Location.Null, true));
 			//}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1937" endline="1956">
<![CDATA[
 
 		//
 		// Creates unresolved reduce expression. The original expression has to be
 		// already resolved
 		//
 		public static Expression Create (Expression expr, Expression original_expr)
 		{
 			Constant c = expr as Constant;
 			if (c != null)
 				return Create (c, original_expr);
 
 			ExpressionStatement s = expr as ExpressionStatement;
 			if (s != null)
 				return Create (s, original_expr);
 
 			if (expr.eclass == ExprClass.Unresolved)
 				throw new ArgumentException ("Unresolved expression");
 
 			return new ReducedExpression (expr, original_expr);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="349" endline="361">
<![CDATA[
 
     Shared Function GetGenericParameters(ByVal Member As MemberReference) As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim methodReference As MethodReference
         Dim typeReference As TypeReference
 
         methodReference = TryCast(Member, MethodReference)
         If methodReference IsNot Nothing Then Return CecilHelper.FindDefinition(methodReference).GenericParameters
 
         typeReference = TryCast(Member, TypeReference)
         If typeReference IsNot Nothing Then Return CecilHelper.FindDefinition(typeReference).GenericParameters
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="724" endline="733">
<![CDATA[
 
     Public Shared Function GetAssemblyRef(ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.AssemblyNameReference
         Dim modDef As ModuleDefinition = TryCast(Type.Scope, ModuleDefinition)
         If modDef IsNot Nothing Then Return modDef.Assembly.Name
 
         Dim assemblyRef As Mono.Cecil.AssemblyNameReference = TryCast(Type.Scope, AssemblyNameReference)
         If assemblyRef IsNot Nothing Then Return assemblyRef
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1124" endline="1140">
<![CDATA[
 
     Public Shared Function GetBaseType(ByVal Type As TypeReference) As TypeReference
         Dim result As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition
 
         tD = CecilHelper.FindDefinition(Type)
 
         If tD Is Nothing Then Return Nothing
 
         result = tD.BaseType
 
         If result Is Nothing Then Return Nothing
 
         result = CecilHelper.InflateType(result, Type)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="53" endline="65">
<![CDATA[
 
     Function CreateBaseImplicitMembers() As Boolean
         Dim tD As Mono.Cecil.TypeDefinition
         Dim cD As ClassDeclaration
 
         tD = CecilHelper.FindDefinition(Me.BaseType)
         If tD Is Nothing Then Return True
 
         cD = TryCast(tD.Annotations(Compiler), ClassDeclaration)
         If cD Is Nothing Then Return True
 
         Return cD.CreateImplicitMembers
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1211" endline="1217">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal param As ParameterReference) As ParameterDefinition
         If param Is Nothing Then Return Nothing
         Dim pD As ParameterDefinition = TryCast(param, ParameterDefinition)
         If pD IsNot Nothing Then Return pD
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="161" endline="174">
<![CDATA[
 
 		public override Module GetModule(string name)
 		{
 			if (name.Equals(manifestModule.ScopeName, StringComparison.InvariantCultureIgnoreCase))
 			{
 				return manifestModule;
 			}
 			int index = GetModuleIndex(name);
 			if (index != -1)
 			{
 				return GetModule(index);
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="720" endline="733">
<![CDATA[
 
     Shared Function IsPrivate(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="734" endline="747">
<![CDATA[
 
     Shared Function IsFamilyOrAssembly(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="362" endline="371">
<![CDATA[
 
     Shared Function GetGenericParameterConstraints(ByVal Context As BaseObject, ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, Mono.Cecil.GenericParameter)
 
         If tG IsNot Nothing Then Return tG.Constraints
 
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
         If CecilHelper.IsGenericParameter(Type) = False Then Throw New InternalException("")
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3438" endline="3455">
<![CDATA[
 
 		protected virtual bool ResolveMemberType ()
 		{
 			if (member_type != null)
 				throw new InternalErrorException ("Multi-resolve");
 
 			TypeExpr te = type_expr.ResolveAsTypeTerminal (this, false);
 			if (te == null)
 				return false;
 			
 			//
 			// Replace original type name, error reporting can use fully resolved name
 			//
 			type_expr = te;
 
 			member_type = te.Type;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="433" endline="446">
<![CDATA[
 
 		protected virtual MethodSpec ResolveConstructor (ResolveContext ec)
 		{
 			if (PosArguments != null) {
 				bool dynamic;
 				PosArguments.Resolve (ec, out dynamic);
 				if (dynamic) {
 					Error_AttributeArgumentIsDynamic (ec.MemberContext, loc);
 					return null;
 				}
 			}
 
 			return ConstructorLookup (ec, Type, ref PosArguments, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5288" endline="5302">
<![CDATA[
 
 		public static bool IsSpecialMethodInvocation (ResolveContext ec, MethodSpec method, Location loc)
 		{
 			if (!method.IsReservedMethod)
 				return false;
 
 			if (ec.HasSet (ResolveContext.Options.InvokeSpecialName) || ec.CurrentMemberDefinition.IsCompilerGenerated)
 				return false;
 
 			ec.Report.SymbolRelatedToPreviousError (method);
 			ec.Report.Error (571, loc, "`{0}'
 				method.GetSignatureForError ());
 	
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="249" endline="260">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant () || this is FixedField) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="341" endline="357">
<![CDATA[
 		}
 
 		//TODO
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			parameters.VerifyClsCompliance (this);
 
 			if (!ReturnType.Type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="638" endline="649">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if ((ModFlags & Modifiers.VOLATILE) != 0) {
 				Report.Warning (3026, 1, Location, "CLS-compliant field `{0}' cannot be volatile", GetSignatureForError ());
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1641" endline="1650">
<![CDATA[
 
 		protected virtual void CheckEqualsAndGetHashCode ()
 		{
 			if (methods == null)
 				return;
 
 			if (HasEquals && !HasGetHashCode) {
 				Report.Warning (659, 3, this.Location, "`{0}' overrides Object.Equals(object) but does not override Object.GetHashCode()", this.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="207" endline="222">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="228" endline="234">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source,
 					bool leave_copy, bool prepare_for_load)
 		{
 			InternalWrap wrap = new InternalWrap (source, expr.Type, loc);
 			((IAssignMethod) expr).EmitAssign (ec, wrap, leave_copy, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2264" endline="2270">
<![CDATA[
 
 		public void WrapIntoDestructor (TryFinally tf, ExplicitBlock tryBlock)
 		{
 			tryBlock.statements = statements;
 			statements = new List<Statement> (1);
 			statements.Add (tf);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1819" endline="1826">
<![CDATA[
 		}
 
 		#endregion
 
 		public static bool operator == (TypeSpec type, PredefinedAttribute pa)
 		{
 			return type == pa.type && pa.type != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="236" endline="242">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.enum_type;
 			base_class = base_type_expr;
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="365" endline="376">
<![CDATA[
 
 		//
 		// Returns the "Invoke" from a delegate type
 		//
 		public static MethodSpec GetInvokeMethod (CompilerContext ctx, TypeSpec delType)
 		{
 			var invoke = MemberCache.FindMember (delType,
 				MemberFilter.Method (InvokeMethodName, 0, null, null),
 				BindingRestriction.DeclaredOnly);
 
 			return (MethodSpec) invoke;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="118" endline="125">
<![CDATA[
 		}
 
 		internal uint StrongNameSignatureRVA
 		{
 			get
 			{
 				return (ResourcesRVA + ResourcesLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="134" endline="141">
<![CDATA[
 		}
 
 		private uint MetadataRVA
 		{
 			get
 			{
 				return (StrongNameSignatureRVA + StrongNameSignatureLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="63" endline="70">
<![CDATA[
     End Property
 
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Dim attrib As Attribute = Me.FindFirstParent(Of Attribute)()
             Return attrib IsNot Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8756" endline="8762">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 			type = TypeManager.object_type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="215" endline="233">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Context"></param>
     ''' <param name="IsRHS">Default = True</param>
     ''' <param name="IsExplicitConversion"></param>
     ''' <param name="DesiredType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Clone(ByVal Context As ParsedObject, ByVal IsRHS As Boolean, Optional ByVal IsExplicitConversion As Boolean = False, Optional ByVal DesiredType As Mono.Cecil.TypeReference = Nothing) As EmitInfo
         Dim result As New EmitInfo(Me)
         result.m_IsRHS = IsRHS
         result.m_IsExplicitConversion = IsExplicitConversion
         result.m_DesiredType = DesiredType
         result.m_RHSExpression = Nothing
         result.m_Context = Context
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="42" endline="49">
<![CDATA[
 
 		internal static ByteReader FromBlob(byte[] blobHeap, int blob)
 		{
 			ByteReader br = new ByteReader(blobHeap, blob, 4);
 			int length = br.ReadCompressedInt();
 			br.end = br.pos + length;
 			return br;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="432" endline="438">
<![CDATA[
 		
 		static void AddKeyword (string kw, int token)
 		{
 			keyword_strings.Add (kw, null);
 
 			AddKeyword (keywords, kw, token);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="154" endline="162">
<![CDATA[
 		}
 
 		public override bool IsGenericMethodDefinition
 		{
 			get
 			{
 				PopulateGenericArguments();
 				return typeArgs.Length > 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="457" endline="466">
<![CDATA[
 		}
 
 		public override int MetadataToken
 		{
 			get
 			{
 				// for parameters that don't have a row in the Param table, we return 0x08000000 (because index is -1 in that case),
 				// just like .NET
 				return (ParamTable.Index << 24) + index + 1;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="877" endline="883">
<![CDATA[
 
 		void Error_ObsoleteSecurityAttribute (Attribute a, string option)
 		{
 			Report.Warning (1699, 1, a.Location,
 				"Use compiler option `{0}' or appropriate project settings instead of `{1}' attribute",
 				option, a.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3248" endline="3254">
<![CDATA[
 
 		protected void Error_StaticReturnType ()
 		{
 			Report.Error (722, Location,
 				"`{0}'
 				MemberType.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3715" endline="3721">
<![CDATA[
 
 		public static void Error_ConstructorMismatch (ResolveContext rc, TypeSpec type, int argCount, Location loc)
 		{
 			rc.Report.Error (1729, loc,
 				"The type `{0}' does not contain a constructor that takes `{1}' arguments",
 				type.GetSignatureForError (), argCount.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1342" endline="1354">
<![CDATA[
 		}
 
 		/// <remarks>
 		///  Should be overriten by the appropriate declaration space
 		/// </remarks>
 		public abstract void DefineType ();
 
 		protected void Error_MissingPartialModifier (MemberCore type)
 		{
 			Report.Error (260, type.Location,
 				"Missing partial modifier on declaration of type `{0}'. Another partial declaration of this type exists",
 				type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="321" endline="327">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.multicast_delegate_type;
 			base_class = null;
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="563" endline="574">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.WriteField()
 				.WriteMethodDef()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2060" endline="2070">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(12)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="462" endline="472">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteGuidIndex()
 				.WriteGuidIndex()
 				.WriteGuidIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="91" endline="99">
<![CDATA[
 
 		public MemberFilter (string name, int arity, MemberKind kind, AParametersCollection param, TypeSpec type)
 		{
 			Name = name;
 			Kind = kind;
 			Parameters = param;
 			MemberType = type;
 			this.arity = arity;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="47" endline="58">
<![CDATA[
 
 		public override Type BaseType
 		{
 			get
 			{
 				int extends = module.TypeDef.records[index].Extends;
 				if ((extends & 0xFFFFFF) == 0)
 				{
 					return null;
 				}
 				return module.ResolveType(extends, this);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="559" endline="568">
<![CDATA[
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			IsTypePermitted ();
 
 			if (MemberType.IsStatic)
 				Error_StaticReturnType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="945" endline="2100">
<![CDATA[
 	}
 
 	public class IntConstant 
 		public readonly int Value;
 
 		public IntConstant (int v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.EmitInt (Value);
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override Constant Increment ()
 		{
 			return new IntConstant (checked(Value + 1), loc);
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 		
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 		
 		public override bool IsOneInteger {
 			get {
 				return Value == 1;
 			}
 		}		
 
 		public override bool IsZeroInteger {
 			get { return Value == 0; }
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (this.type == type)
 				return this;
 
 			Constant c = TryImplicitIntConversion (type);
 			if (c != null)
 				return c.Resolve (rc);
 
 			return base.ConvertImplicitly (rc, type);
 		}
 
 		/// <summary>
 		///   Attempts to perform an implicit constant conversion of the IntConstant
 		///   into a different data type using casts (See Implicit Constant
 		///   Expression Conversions)
 		/// </summary>
 		Constant TryImplicitIntConversion (TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type) {
 				if (Value >= SByte.MinValue && Value <= SByte.MaxValue)
 					return new SByteConstant ((sbyte) Value, loc);
 			} 
 			else if (target_type == TypeManager.byte_type) {
 				if (Value >= Byte.MinValue && Value <= Byte.MaxValue)
 					return new ByteConstant ((byte) Value, loc);
 			} 
 			else if (target_type == TypeManager.short_type) {
 				if (Value >= Int16.MinValue && Value <= Int16.MaxValue)
 					return new ShortConstant ((short) Value, loc);
 			} 
 			else if (target_type == TypeManager.ushort_type) {
 				if (Value >= UInt16.MinValue && Value <= UInt16.MaxValue)
 					return new UShortConstant ((ushort) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint32_type) {
 				if (Value >= 0)
 					return new UIntConstant ((uint) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint64_type) {
 				//
 				// we can optimize this case
 				// always fits on a uint64.  But we need an opcode
 				// to do it.
 				//
 				if (Value >= 0)
 					return new ULongConstant ((ulong) Value, loc);
 			} 
 			else if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, loc);
 			else if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, loc);
 
 			return null;
 		}
 	}
 
 	public class UIntConstant 
 		public readonly uint Value;
 
 		public UIntConstant (uint v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.EmitInt (unchecked ((int) Value));
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override Constant Increment ()
 		{
 			return new UIntConstant (checked(Value + 1), loc);
 		}
 	
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return false;
 			}
 		}
 		
 		public override bool IsOneInteger {
 			get {
 				return Value == 1;
 			}
 		}		
 
 		public override bool IsZeroInteger {
 			get { return Value == 0; }
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 	}
 
 	public class LongConstant 
 		public readonly long Value;
 
 		public LongConstant (long v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.EmitLong (Value);
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override Constant Increment ()
 		{
 			return new LongConstant (checked(Value + 1), loc);
 		}
 		
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 		
 		public override bool IsOneInteger {
 			get {
 				return Value == 1;
 			}
 		}		
 
 		public override bool IsZeroInteger {
 			get { return Value == 0; }
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < Int32.MinValue || Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue || Value > UInt32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (Value >= 0 && type == TypeManager.uint64_type) {
 				return new ULongConstant ((ulong) Value, loc).Resolve (rc);
 			}
 
 			return base.ConvertImplicitly (rc, type);
 		}
 	}
 
 	public class ULongConstant 
 		public readonly ulong Value;
 
 		public ULongConstant (ulong v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.EmitLong (unchecked ((long) Value));
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override Constant Increment ()
 		{
 			return new ULongConstant (checked(Value + 1), loc);
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return false;
 			}
 		}
 		
 		public override bool IsOneInteger {
 			get {
 				return Value == 1;
 			}
 		}		
 
 		public override bool IsZeroInteger {
 			get { return Value == 0; }
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value > Byte.MaxValue)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context && Value > ((ulong) SByte.MaxValue))
 					throw new OverflowException ();
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context && Value > ((ulong) Int16.MaxValue))
 					throw new OverflowException ();
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value > UInt16.MaxValue)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if  (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context && Value > Int64.MaxValue)
 					throw new OverflowException ();
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value > Char.MaxValue)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 	}
 
 	public class FloatConstant 
 		public float Value;
 
 		public FloatConstant (float v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.float_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldc_R4, Value);
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < byte.MinValue || Value > byte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < sbyte.MinValue || Value > sbyte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (float) char.MinValue || Value > (float) char.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 	}
 
 	public class DoubleConstant 
 		public double Value;
 
 		public DoubleConstant (double v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.double_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldc_R8, Value);
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (double) char.MinValue || Value > (double) char.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 	}
 
 	public class DecimalConstant 
 		public readonly decimal Value;
 
 		public DecimalConstant (decimal d, Location loc)
 			base (loc)
 		{
 			Value = d;
 		}
 
 		override public string AsString ()
 		{
 			return Value.ToString () + "M";
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.decimal_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override object GetValue ()
 		{
 			return (object) Value;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			int [] words = decimal.GetBits (Value);
 			int power = (words [3] >> 16) & 0xff;
 
 			if (power == 0) {
 				if (Value <= int.MaxValue && Value >= int.MinValue) {
 					if (TypeManager.void_decimal_ctor_int_arg == null) {
 						TypeManager.void_decimal_ctor_int_arg = TypeManager.GetPredefinedConstructor (
 							TypeManager.decimal_type, loc, TypeManager.int32_type);
 
 						if (TypeManager.void_decimal_ctor_int_arg == null)
 							return;
 					}
 
 					ec.EmitInt ((int) Value);
 					ec.Emit (OpCodes.Newobj, TypeManager.void_decimal_ctor_int_arg);
 					return;
 				}
 
 				if (Value <= long.MaxValue && Value >= long.MinValue) {
 					if (TypeManager.void_decimal_ctor_long_arg == null) {
 						TypeManager.void_decimal_ctor_long_arg = TypeManager.GetPredefinedConstructor (
 							TypeManager.decimal_type, loc, TypeManager.int64_type);
 
 						if (TypeManager.void_decimal_ctor_long_arg == null)
 							return;
 					}
 
 					ec.EmitLong ((long) Value);
 					ec.Emit (OpCodes.Newobj, TypeManager.void_decimal_ctor_long_arg);
 					return;
 				}
 			}
 
 			ec.EmitInt (words [0]);
 			ec.EmitInt (words [1]);
 			ec.EmitInt (words [2]);
 
 			// sign
 			ec.EmitInt (words [3] >> 31);
 
 			// power
 			ec.EmitInt (power);
 
 			if (TypeManager.void_decimal_ctor_five_args == null) {
 				TypeManager.void_decimal_ctor_five_args = TypeManager.GetPredefinedConstructor (
 					TypeManager.decimal_type, loc, TypeManager.int32_type, TypeManager.int32_type,
 					TypeManager.int32_type, TypeManager.bool_type, TypeManager.byte_type);
 
 				if (TypeManager.void_decimal_ctor_five_args == null)
 					return;
 			}
 
 			ec.Emit (OpCodes.Newobj, TypeManager.void_decimal_ctor_five_args);
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)Value, loc);
 			if (target_type == TypeManager.byte_type)
 				return new ByteConstant ((byte)Value, loc);
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short)Value, loc);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)Value, loc);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int)Value, loc);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint)Value, loc);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long)Value, loc);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong)Value, loc);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char)Value, loc);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float)Value, loc);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double)Value, loc);
 
 			return null;
 		}
 
 	}
 
 	public class StringConstant 
 		public readonly string Value;
 
 		public StringConstant (string s, Location loc)
 			base (loc)
 		{
 			Value = s;
 		}
 
 		// FIXME
 		override public string AsString ()
 		{
 			return "\"" + Value + "\"";
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (Value == null) {
 				ec.Emit (OpCodes.Ldnull);
 				return;
 			}
 
 			//
 			// Use string.Empty for both literals and constants even if
 			// it's not allowed at language level
 			//
 			if (Value.Length == 0 && RootContext.Optimize && ec.CurrentType != TypeManager.string_type) {
 				if (TypeManager.string_empty == null)
 					TypeManager.string_empty = TypeManager.GetPredefinedField (TypeManager.string_type, "Empty", loc, TypeManager.string_type);
 
 				if (TypeManager.string_empty != null) {
 					ec.Emit (OpCodes.Ldsfld, TypeManager.string_empty);
 					return;
 				}
 			}
 
 			ec.Emit (OpCodes.Ldstr, Value);
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// cast to object
 			if (type != targetType)
 				enc.Encode (type);
 
 			enc.Encode (Value);
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == null;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return false;
 			}
 		}
 
 		public override bool IsNull {
 			get {
 				return IsDefaultValue;
 			}
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			return null;
 		}
 	}
 
 	//
 	// Null constant can have its own type, think of `default (Foo)'
 	//
 	public class NullConstant 
 	{
 		public NullConstant (TypeSpec type, Location loc)
 			
 		{
 			eclass = ExprClass.Value;
 			this.type = type;
 		}
 
 		public override string AsString ()
 		{
 			return GetSignatureForError ();
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (type == InternalType.Null || type == TypeManager.object_type) {
 				// Optimized version, also avoids referencing literal internal type
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (this));
 				return CreateExpressionFactoryCall (ec, "Constant", args);
 			}
 
 			return base.CreateExpressionTree (ec);
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// Type it as string cast
 			if (targetType == TypeManager.object_type || targetType == InternalType.Null)
 				enc.Encode (TypeManager.string_type);
 
 			var ac = targetType as ArrayContainer;
 			if (ac != null) {
 				if (ac.Rank != 1 || ac.Element.IsArray)
 					base.EncodeAttributeValue (rc, enc, targetType);
 				else
 					enc.Encode (uint.MaxValue);
 			} else {
 				enc.Encode (byte.MaxValue);
 			}
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldnull);
 
 			// Only to make verifier happy
 			if (TypeManager.IsGenericParameter (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
 
 		public override string ExprClassName {
 			get {
 				return GetSignatureForError ();
 			}
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return "null";
 		}
 
 		public override Constant ConvertExplicitly (bool inCheckedContext, TypeSpec targetType)
 		{
 			if (targetType.IsPointer) {
 				if (IsLiteral || this is NullPointer)
 					return new EmptyConstantCast (new NullPointer (loc), targetType);
 
 				return null;
 			}
 
 			// Exlude internal compiler types
 			if (targetType.Kind == MemberKind.InternalCompilerType && targetType != InternalType.Dynamic && targetType != InternalType.Null)
 				return null;
 
 			if (!IsLiteral && !Convert.ImplicitStandardConversionExists (this, targetType))
 				return null;
 
 			if (TypeManager.IsReferenceType (targetType))
 				return new NullConstant (targetType, loc);
 
 			if (TypeManager.IsNullableType (targetType))
 				return Nullable.LiftedNull.Create (targetType, loc);
 
 			return null;
 		}
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec targetType)
 		{
 			return ConvertExplicitly (false, targetType);
 		}
 
 		public override object GetValue ()
 		{
 			return null;
 		}
 
 		public override bool IsDefaultValue {
 			get { return true; }
 		}
 
 		public override bool IsNegative {
 			get { return false; }
 		}
 
 		public override bool IsNull {
 			get { return true; }
 		}
 
 		public override bool IsZeroInteger {
 			get { return true; }
 		}
 	}
 
 	/// <summary>
 	///   The value is constant, but when emitted has a side effect.  This is
 	///   used by BitwiseAnd to ensure that the second expression is invoked
 	///   regardless of the value of the left side.  
 	/// </summary>
 	public class SideEffectConstant 
 		public Constant value;
 		Expression side_effect;
 		
 		public SideEffectConstant (Constant value, Expression side_effect, Location loc) 
 		{
 			this.value = value;
 			while (side_effect is SideEffectConstant)
 				side_effect = ((SideEffectConstant) side_effect).side_effect;
 			while (side_effect is SideEffectConstant)
 				side_effect = ((SideEffectConstant) side_effect).side_effect;
 			this.side_effect = side_effect;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1899" endline="1910">
<![CDATA[
 		}
 
 		readonly Expression expr, orig_expr;
 
 		private ReducedExpression (Expression expr, Expression orig_expr)
 		{
 			this.expr = expr;
 			this.eclass = expr.eclass;
 			this.type = expr.Type;
 			this.orig_expr = orig_expr;
 			this.loc = orig_expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="537" endline="548">
<![CDATA[
 		}
 
 		public CompileUnitEntry (MonoSymbolFile file, SourceFileEntry source)
 		{
 			this.file = file;
 			this.source = source;
 
 			this.Index = file.AddCompileUnit (this);
 
 			creating = true;
 			namespaces = new List<NamespaceEntry> ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="516" endline="523">
<![CDATA[
 
 		protected AbstractMessage (AbstractMessage aMsg)
 		{
 			this.code = aMsg.code;
 			this.location = aMsg.location;
 			this.message = aMsg.message;
 			this.extra_info = aMsg.extra_info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="241" endline="266">
<![CDATA[
 	}
 
 	public class SourceMethodBuilder
 	{
 		List<LocalVariableEntry> _locals;
 		List<CodeBlockEntry> _blocks;
 		List<ScopeVariable> _scope_vars;
 #if NET_2_1
 		System.Collections.Stack _block_stack;
 #else		
 		Stack<CodeBlockEntry> _block_stack;
 #endif
 		string _real_name;
 		IMethodDef _method;
 		ICompileUnit _comp_unit;
 //		MethodEntry.Flags _method_flags;
 		int _ns_id;
 
 		public SourceMethodBuilder (ICompileUnit comp_unit, int ns_id, IMethodDef method)
 		{
 			this._comp_unit = comp_unit;
 			this._method = method;
 			this._ns_id = ns_id;
 
 			method_lines = new LineNumberEntry [32];
 		}
 
 		private LineNumberEntry [] method_lines;
 		private int method_lines_pos = 0;
 		public SourceMethodBuilder (ICompileUnit comp_unit, int ns_id, IMethodDef method)
 		{
 			this._comp_unit = comp_unit;
 			this._method = method;
 			this._ns_id = ns_id;
 
 			method_lines = new LineNumberEntry [32];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8362" endline="8381">
<![CDATA[
 	}
 
 	//
 	// Indexer access expression
 	//
 	class IndexerExpr 
 	{
 		LocalTemporary prepared_value;
 		IList<MemberSpec> indexers;
 		Arguments arguments;
 		TypeSpec queried_type;
 		
 		public IndexerExpr (IList<MemberSpec> indexers, TypeSpec queriedType, ElementAccess ea)
 			
 		{
 			this.indexers = indexers;
 			this.queried_type = queriedType;
 			this.InstanceExpression = ea.Expr;
 			this.arguments = ea.Arguments;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="451" endline="471">
<![CDATA[
 	}
 
 	public class For 
 		Expression Test;
 		Statement InitStatement;
 		Statement Increment;
 		public Statement Statement;
 		bool infinite, empty;
 		
 		public For (Statement init_statement,
 			    BooleanExpression test,
 			    Statement increment,
 			    Statement statement,
 			    Location l)
 		{
 			InitStatement = init_statement;
 			Test = test;
 			Increment = increment;
 			Statement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="44" endline="51">
<![CDATA[
 		internal PropertyBuilder(TypeBuilder typeBuilder, string name, PropertyAttributes attributes, PropertySignature sig, bool patchCallingConvention)
 		{
 			this.typeBuilder = typeBuilder;
 			this.name = name;
 			this.attributes = attributes;
 			this.sig = sig;
 			this.patchCallingConvention = patchCallingConvention;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="44" endline="50">
<![CDATA[
 		internal EventBuilder(TypeBuilder typeBuilder, string name, EventAttributes attributes, Type eventtype)
 		{
 			this.typeBuilder = typeBuilder;
 			this.name = name;
 			this.attributes = attributes;
 			this.eventtype = typeBuilder.ModuleBuilder.GetTypeTokenForMemberRef(eventtype);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="476" endline="487">
<![CDATA[
 		}
 
 		Expression condition;
 		ExpressionStatement invoke, assign;
 
 		public DynamicEventCompoundAssign (string name, Arguments args, ExpressionStatement assignment, ExpressionStatement invoke, Location loc)
 		{
 			condition = new IsEvent (name, args, loc);
 			this.invoke = invoke;
 			this.assign = assignment;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="69" endline="246">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Class for applying custom attributes on the return type
 	/// </summary>
 	public class ReturnParameter 
 	{
 		MemberCore method;
 
 		// TODO
 		public ReturnParameter (MemberCore method, MethodBuilder mb, Location location)
 		{
 			this.method = method;
 			try {
 				builder = mb.DefineParameter (0, ParameterAttributes.None, "");			
 			}
 			catch (ArgumentOutOfRangeException) {
 				method.Compiler.Report.RuntimeMissingSupport (location, "custom attributes on the return type");
 			}
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant) {
 				method.Compiler.Report.Warning (3023, 1, a.Location,
 					"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead");
 			}
 
 			// This occurs after Warning -28
 			if (builder == null)
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.ReturnValue;
 			}
 		}
 
 		/// <summary>
 		/// Is never called
 		/// </summary>
 		public override string[] ValidAttributeTargets {
 			get {
 				return null;
 			}
 		}
 	}
 
 	public class ImplicitLambdaParameter 
 	{
 		public ImplicitLambdaParameter (string name, Location loc)
 			
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
 
 		public void SetParameterType (TypeSpec type)
 		{
 			parameter_type = type;
 		}
 	}
 
 	public class ParamsParameter 
 		public ParamsParameter (FullNamedExpression type, string name, Attributes attrs, Location loc)
 			base (type, name, Parameter.Modifier.PARAMS, attrs, loc)
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (base.Resolve (ec, index) == null)
 				return null;
 
 			var ac = parameter_type as ArrayContainer;
 			if (ac == null || ac.Rank != 1) {
 				ec.Compiler.Report.Error (225, Location, "The params parameter must be a single dimensional array");
 				return null;
 			}
 
 			return parameter_type;
 		}
 
 		public override void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			base.ApplyAttributes (mb, cb, index, pa);
 			pa.ParamArray.EmitAttribute (builder);
 		}
 	}
 
 	public class ArglistParameter 
 		// Doesn't have proper type because it's never chosen for better conversion
 		public ArglistParameter (Location loc) 
 			base (null, String.Empty, Parameter.Modifier.NONE, null, loc)
 		{
 			parameter_type = InternalType.Arglist;
 		}
 
 		public override void  ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			// Nothing to do
 		}
 
 		public override bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			return true;
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			return parameter_type;
 		}
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4181" endline="4197">
<![CDATA[
 	}
 
 	public class PointerArithmetic 
 		Expression left, right;
 		Binary.Operator op;
 
 		//
 		// We assume that `l' is always a pointer
 		//
 		public PointerArithmetic (Binary.Operator op, Expression l, Expression r, TypeSpec t, Location loc)
 		{
 			type = t;
 			this.loc = loc;
 			left = l;
 			right = r;
 			this.op = op;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5694" endline="5710">
<![CDATA[
 
 			#endregion
 		}
 
 		Expression type;
 		LocalVariable variable;
 		Expression expr;
 		Statement statement;
 
 		public Foreach (Expression type, LocalVariable var, Expression expr, Statement stmt, Location l)
 		{
 			this.type = type;
 			this.variable = var;
 			this.expr = expr;
 			statement = stmt;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2878" endline="3005">
<![CDATA[
 
 		public abstract void SetTypeArguments (ResolveContext ec, TypeArguments ta);
 	}
 
 	// 
 	// Represents a group of extension method candidates for whole namespace
 	// 
 	class ExtensionMethodGroupExpr 
 	{
 		NamespaceEntry namespace_entry;
 		public readonly Expression ExtensionExpression;
 
 		public ExtensionMethodGroupExpr (IList<MethodSpec> list, NamespaceEntry n, Expression extensionExpr, Location l)
 			
 		{
 			this.namespace_entry = n;
 			this.ExtensionExpression = extensionExpr;
 		}
 
 		public override bool IsStatic {
 			get { return true; }
 		}
 
 		public override IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			if (namespace_entry == null)
 				return null;
 
 			//
 			// For extension methodgroup we are not looking for base members but parent
 			// namespace extension methods
 			//
 			int arity = type_arguments == null ? 0 
 			var found = namespace_entry.LookupExtensionMethod (DeclaringType, Name, arity, ref namespace_entry);
 			if (found == null)
 				return null;
 
 			return found.Cast<MemberSpec> ().ToList ();
 		}
 
 		public override MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			// We are already here
 			return null;
 		}
 
 		public override MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments arguments, OverloadResolver.IErrorHandler ehandler, OverloadResolver.Restrictions restr)
 		{
 			if (arguments == null)
 				arguments = new Arguments (1);
 
 			arguments.Insert (0, new Argument (ExtensionExpression, Argument.AType.ExtensionType));
 			var res = base.OverloadResolve (ec, ref arguments, ehandler ?? this, restr);
 
 			// Store resolved argument and restore original arguments
 			if (res == null) {
 				// Clean-up modified arguments for error reporting
 				arguments.RemoveAt (0);
 				return null;
 			}
 
 			var me = ExtensionExpression as MemberExpr;
 			if (me != null)
 				me.ResolveInstanceExpression (ec, null);
 
 			InstanceExpression = null;
 			return this;
 		}
 
 		#region IErrorHandler Members
 
 		bool OverloadResolver.IErrorHandler.AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument arg, int index)
 		{
 			rc.Report.SymbolRelatedToPreviousError (best);
 			rc.Report.Error (1928, loc,
 				"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' has some invalid arguments",
 				queried_type.GetSignatureForError (), Name, best.GetSignatureForError ());
 
 			if (index == 0) {
 				rc.Report.Error (1929, loc,
 					"Extension method instance type `{0}' cannot be converted to `{1}'",
 					arg.Type.GetSignatureForError (), ((MethodSpec)best).Parameters.ExtensionMethodType.GetSignatureForError ());
 			}
 
 			return true;
 		}
 
 		bool OverloadResolver.IErrorHandler.NoArgumentMatch (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.TypeInferenceFailed (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="41" endline="48">
<![CDATA[
 		private MethodSignature(Type returnType, Type[] parameterTypes, Type[][][] modifiers, CallingConventions callingConvention, int genericParamCount)
 		{
 			this.returnType = returnType;
 			this.parameterTypes = parameterTypes;
 			this.modifiers = modifiers;
 			this.callingConvention = callingConvention;
 			this.genericParamCount = genericParamCount;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="95" endline="103">
<![CDATA[
 		Unwrap (Expression expr, bool useDefaultValue)
 		{
 			this.expr = expr;
 			this.loc = expr.Location;
 			this.useDefaultValue = useDefaultValue;
 
 			type = NullableInfo.GetUnderlyingType (expr.Type);
 			eclass = expr.eclass;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="38" endline="47">
<![CDATA[
 		public UserOperatorCall (MethodSpec oper, Arguments args, Func<ResolveContext, Expression, Expression> expr_tree, Location loc)
 		{
 			this.oper = oper;
 			this.arguments = args;
 			this.expr_tree = expr_tree;
 
 			type = oper.ReturnType;
 			eclass = ExprClass.Value;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="62" endline="71">
<![CDATA[
 
 		public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, PropertyInfo[] namedProperties, object[] propertyValues, FieldInfo[] namedFields, object[] fieldValues)
 		{
 			this.con = con;
 			this.constructorArgs = constructorArgs;
 			this.namedProperties = namedProperties;
 			this.propertyValues = propertyValues;
 			this.namedFields = namedFields;
 			this.fieldValues = fieldValues;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1310" endline="1321">
<![CDATA[
 		}
 
 		protected VariableInfo (string name, TypeSpec type, int offset)
 		{
 			this.Name = name;
 			this.Offset = offset;
 			this.TypeInfo = TypeInfo.GetTypeInfo (type);
 
 			Length = TypeInfo.TotalLength;
 
 			Initialize ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\StandAloneMethodSig.cs" startline="39" endline="47">
<![CDATA[
 		internal __StandAloneMethodSig(bool unmanaged, CallingConvention unmanagedCallingConvention, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
 		{
 			this.unmanaged = unmanaged;
 			this.unmanagedCallingConvention = unmanagedCallingConvention;
 			this.callingConvention = callingConvention;
 			this.returnType = returnType;
 			this.parameterTypes = parameterTypes;
 			this.optionalParameterTypes = optionalParameterTypes;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="49" endline="56">
<![CDATA[
 	public Outline (Type t, TextWriter output, bool declared_only, bool show_private, bool filter_obsolete)
 	{
 		this.t = t;
 		this.o = new IndentedTextWriter (output, "\t");
 		this.declared_only = declared_only;
 		this.show_private = show_private;
 		this.filter_obsolete = filter_obsolete;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="130" endline="139">
<![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal LoopStartExpression As Expression, ByVal LoopEndExpression As Expression, ByVal LoopStepExpression As Expression, ByVal NextExpressionList As ExpressionList, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_LoopStartExpression = LoopStartExpression
         m_LoopEndExpression = LoopEndExpression
         m_LoopStepExpression = LoopStepExpression
         m_NextExpressionList = NextExpressionList
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="55" endline="62">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         MyBase.Init(Modifiers, Identifier.Name)
         m_Identifier = Identifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="30" endline="38">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal Field As Mono.Cecil.FieldReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.New(Parent)
 
         m_Field = Field
         m_InstanceExpression = InstanceExpression
         Me.Classification = New ValueClassification(Me, m_Field.FieldType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="46" endline="53">
<![CDATA[
 
     Shadows Sub Init(ByVal EnumIndex As Integer, ByVal Identifier As Identifier, ByVal ConstantExpression As Expression)
         MyBase.Init(Nothing, Identifier.Identifier)
         m_EnumIndex = EnumIndex
         m_Identifier = Identifier
         m_ConstantExpression = ConstantExpression
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="317" endline="361">
<![CDATA[
 		}
 
 		/// <summary>
 		///   XML documentation comment
 		/// </summary>
 		protected string comment;
 
 		/// <summary>
 		///   Represents header string for documentation comment 
 		///   for each member types.
 		/// </summary>
 		public abstract string DocCommentHeader { get; }
 
 		[Flags]
 		public enum Flags {
 			Obsolete_Undetected = 1,		// Obsolete attribute has not been detected yet
 			Obsolete = 1 << 1,			// Type has obsolete attribute
 			ClsCompliance_Undetected = 1 << 2,	// CLS Compliance has not been detected yet
 			ClsCompliant = 1 << 3,			// Type is CLS Compliant
 			CloseTypeCreated = 1 << 4,		// Tracks whether we have Closed the type
 			HasCompliantAttribute_Undetected = 1 << 5,	// Presence of CLSCompliantAttribute has not been detected
 			HasClsCompliantAttribute = 1 << 6,			// Type has CLSCompliantAttribute
 			ClsCompliantAttributeFalse = 1 << 7,			// Member has CLSCompliant(false)
 			Excluded_Undetected = 1 << 8,		// Conditional attribute has not been detected yet
 			Excluded = 1 << 9,					// Method is conditional
 			MethodOverloadsExist = 1 << 10,		// Test for duplication must be performed
 			IsUsed = 1 << 11,
 			IsAssigned = 1 << 12,				// Field is assigned
 			HasExplicitLayout	= 1 << 13,
 			PartialDefinitionExists	= 1 << 14,	// Set when corresponding partial method definition exists
 			HasStructLayout		= 1 << 15			// Has StructLayoutAttribute
 		}
 
 		/// <summary>
 		///   MemberCore flags at first detected then cached
 		/// </summary>
 		internal Flags caching_flags;
 
 		public MemberCore (DeclSpace parent, MemberName name, Attributes attrs)
 		{
 			this.Parent = parent as TypeContainer;
 			member_name = name;
 			caching_flags = Flags.Obsolete_Undetected | Flags.ClsCompliance_Undetected | Flags.HasCompliantAttribute_Undetected | Flags.Excluded_Undetected;
 			AddAttributes (attrs, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="22" endline="29">
<![CDATA[
 		public RootNamespace (string alias_name)
 			
 		{
 			this.alias_name = alias_name;
 
 			all_namespaces = new Dictionary<string, Namespace> ();
 			all_namespaces.Add ("", this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="146" endline="152">
<![CDATA[
 
     Public Sub New(ByVal FileIndex As UShort, ByVal StartLine As UInteger, ByVal StartColumn As Byte, Optional ByVal EndColumn As Byte = 0)
         m_EndColumn = EndColumn
         m_FileIndex = FileIndex + 1US
         m_Line = StartLine
         m_Column = StartColumn
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="39" endline="45">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal IsResumeNext As Boolean, ByVal Label As Token, ByVal IsGotoMinusOne As Boolean, ByVal IsGotoZero As Boolean)
         MyBase.New(Parent)
         m_IsResumeNext = IsResumeNext
         m_Label = Label
         m_IsGotoMinusOne = IsGotoMinusOne
         m_IsGotoZero = IsGotoZero
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1712" endline="4007">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Binary operators
 	/// </summary>
 	public class Binary 
 	{
 		protected class PredefinedOperator {
 			protected readonly TypeSpec left;
 			protected readonly TypeSpec right;
 			public readonly Operator OperatorsMask;
 			public TypeSpec ReturnType;
 
 			public PredefinedOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask)
 				
 			{
 			}
 
 			public PredefinedOperator (TypeSpec type, Operator op_mask, TypeSpec return_type)
 				
 			{
 			}
 
 			public PredefinedOperator (TypeSpec type, Operator op_mask)
 				
 			{
 			}
 
 			public PredefinedOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask, TypeSpec return_type)
 			{
 				if ((op_mask & Operator.ValuesOnlyMask) != 0)
 					throw new InternalErrorException ("Only masked values can be used");
 
 				this.left = ltype;
 				this.right = rtype;
 				this.OperatorsMask = op_mask;
 				this.ReturnType = return_type;
 			}
 
 			public virtual Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				b.type = ReturnType;
 
 				b.left = Convert.ImplicitConversion (ec, b.left, left, b.left.Location);
 				b.right = Convert.ImplicitConversion (ec, b.right, right, b.right.Location);
 
 				//
 				// A user operators does not support multiple user conversions, but decimal type
 				// is considered to be predefined type therefore we apply predefined operators rules
 				// and then look for decimal user-operator implementation
 				//
 				if (left == TypeManager.decimal_type)
 					return b.ResolveUserOperator (ec, b.left, b.right);
 
 				var c = b.right as Constant;
 				if (c != null) {
 					if (c.IsDefaultValue && (b.oper == Operator.Addition || b.oper == Operator.Subtraction || (b.oper == Operator.BitwiseOr && !(b is Nullable.LiftedBinaryOperator))))
 						return ReducedExpression.Create (b.left, b).Resolve (ec);
 					if ((b.oper == Operator.Multiply || b.oper == Operator.Division) && c.IsOneInteger)
 						return ReducedExpression.Create (b.left, b).Resolve (ec);
 					return b;
 				}
 
 				c = b.left as Constant;
 				if (c != null) {
 					if (c.IsDefaultValue && (b.oper == Operator.Addition || b.oper == Operator.Subtraction || (b.oper == Operator.BitwiseOr && !(b is Nullable.LiftedBinaryOperator))))
 						return ReducedExpression.Create (b.right, b).Resolve (ec);
 					if (b.oper == Operator.Multiply && c.IsOneInteger)
 						return ReducedExpression.Create (b.right, b).Resolve (ec);
 					return b;
 				}
 
 				return b;
 			}
 
 			public bool IsPrimitiveApplicable (TypeSpec ltype, TypeSpec rtype)
 			{
 				//
 				// We are dealing with primitive types only
 				//
 				return left == ltype && ltype == rtype;
 			}
 
 			public virtual bool IsApplicable (ResolveContext ec, Expression lexpr, Expression rexpr)
 			{
 				// Quick path
 				if (left == lexpr.Type && right == rexpr.Type)
 					return true;
 
 				return Convert.ImplicitConversionExists (ec, lexpr, left) &&
 					Convert.ImplicitConversionExists (ec, rexpr, right);
 			}
 
 			public PredefinedOperator ResolveBetterOperator (ResolveContext ec, PredefinedOperator best_operator)
 			{
 				int result = 0;
 				if (left != null && best_operator.left != null) {
 					result = OverloadResolver.BetterTypeConversion (ec, best_operator.left, left);
 				}
 
 				//
 				// When second argument is same as the first one, the result is same
 				//
 				if (right != null && (left != right || best_operator.left != best_operator.right)) {
 					result |= OverloadResolver.BetterTypeConversion (ec, best_operator.right, right);
 				}
 
 				if (result == 0 || result > 2)
 					return null;
 
 				return result == 1 ? best_operator 
 			}
 		}
 
 		class PredefinedStringOperator 
 			public PredefinedStringOperator (TypeSpec type, Operator op_mask)
 				
 			{
 				ReturnType = TypeManager.string_type;
 			}
 
 			public PredefinedStringOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask)
 				
 			{
 				ReturnType = TypeManager.string_type;
 			}
 
 			public override Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				//
 				// Use original expression for nullable arguments
 				//
 				Nullable.Unwrap unwrap = b.left as Nullable.Unwrap;
 				if (unwrap != null)
 					b.left = unwrap.Original;
 
 				unwrap = b.right as Nullable.Unwrap;
 				if (unwrap != null)
 					b.right = unwrap.Original;
 
 				b.left = Convert.ImplicitConversion (ec, b.left, left, b.left.Location);
 				b.right = Convert.ImplicitConversion (ec, b.right, right, b.right.Location);
 
 				//
 				// Start a new concat expression using converted expression
 				//
 				return StringConcat.Create (ec, b.left, b.right, b.loc);
 			}
 		}
 
 		class PredefinedShiftOperator 
 			public PredefinedShiftOperator (TypeSpec ltype, Operator op_mask) 
 				base (ltype, TypeManager.int32_type, op_mask)
 			{
 			}
 
 			public override Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				b.left = Convert.ImplicitConversion (ec, b.left, left, b.left.Location);
 
 				Expression expr_tree_expr = Convert.ImplicitConversion (ec, b.right, TypeManager.int32_type, b.right.Location);
 
 				int right_mask = left == TypeManager.int32_type || left == TypeManager.uint32_type ? 0x1f 
 
 				//
 				// b = b.left >> b.right & (0x1f|0x3f)
 				//
 				b.right = new Binary (Operator.BitwiseAnd,
 					b.right, new IntConstant (right_mask, b.right.Location), b.loc).Resolve (ec);
 
 				//
 				// Expression tree representation does not use & mask
 				//
 				b.right = ReducedExpression.Create (b.right, expr_tree_expr).Resolve (ec);
 				b.type = ReturnType;
 
 				//
 				// Optimize shift by 0
 				//
 				var c = b.right as Constant;
 				if (c != null && c.IsDefaultValue)
 					return ReducedExpression.Create (b.left, b).Resolve (ec);
 
 				return b;
 			}
 		}
 
 		class PredefinedEqualityOperator 
 		{
 			MethodSpec equal_method, inequal_method;
 
 			public PredefinedEqualityOperator (TypeSpec arg, TypeSpec retType)
 				
 			{
 			}
 
 			public override Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				b.type = ReturnType;
 
 				b.left = Convert.ImplicitConversion (ec, b.left, left, b.left.Location);
 				b.right = Convert.ImplicitConversion (ec, b.right, right, b.right.Location);
 
 				Arguments args = new Arguments (2);
 				args.Add (new Argument (b.left));
 				args.Add (new Argument (b.right));
 
 				MethodSpec method;
 				if (b.oper == Operator.Equality) {
 					if (equal_method == null) {
 						equal_method = TypeManager.GetPredefinedMethod (left,
 							new MemberFilter (CSharp.Operator.GetMetadataName (CSharp.Operator.OpType.Equality), 0, MemberKind.Operator, null, ReturnType), b.loc);
 					}
 
 					method = equal_method;
 				} else {
 					if (inequal_method == null) {
 						inequal_method = TypeManager.GetPredefinedMethod (left,
 							new MemberFilter (CSharp.Operator.GetMetadataName (CSharp.Operator.OpType.Inequality), 0, MemberKind.Operator, null, ReturnType), b.loc);
 					}
 
 					method = inequal_method;
 				}
 
 				return new UserOperatorCall (method, args, b.CreateExpressionTree, b.loc);
 			}
 		}
 
 		class PredefinedPointerOperator 
 		{
 			public PredefinedPointerOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask)
 				
 			{
 			}
 
 			public PredefinedPointerOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask, TypeSpec retType)
 				
 			{
 			}
 
 			public PredefinedPointerOperator (TypeSpec type, Operator op_mask, TypeSpec return_type)
 				
 			{
 			}
 
 			public override bool IsApplicable (ResolveContext ec, Expression lexpr, Expression rexpr)
 			{
 				if (left == null) {
 					if (!lexpr.Type.IsPointer)
 						return false;
 				} else {
 					if (!Convert.ImplicitConversionExists (ec, lexpr, left))
 						return false;
 				}
 
 				if (right == null) {
 					if (!rexpr.Type.IsPointer)
 						return false;
 				} else {
 					if (!Convert.ImplicitConversionExists (ec, rexpr, right))
 						return false;
 				}
 
 				return true;
 			}
 
 			public override Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				if (left != null) {
 					b.left = EmptyCast.Create (b.left, left);
 				} else if (right != null) {
 					b.right = EmptyCast.Create (b.right, right);
 				}
 
 				TypeSpec r_type = ReturnType;
 				Expression left_arg, right_arg;
 				if (r_type == null) {
 					if (left == null) {
 						left_arg = b.left;
 						right_arg = b.right;
 						r_type = b.left.Type;
 					} else {
 						left_arg = b.right;
 						right_arg = b.left;
 						r_type = b.right.Type;
 					}
 				} else {
 					left_arg = b.left;
 					right_arg = b.right;
 				}
 
 				return new PointerArithmetic (b.oper, left_arg, right_arg, r_type, b.loc).Resolve (ec);
 			}
 		}
 
 		[Flags]
 		public enum Operator {
 			Multiply	= 0 | ArithmeticMask,
 			Division	= 1 | ArithmeticMask,
 			Modulus		= 2 | ArithmeticMask,
 			Addition	= 3 | ArithmeticMask | AdditionMask,
 			Subtraction = 4 | ArithmeticMask | SubtractionMask,
 
 			LeftShift	= 5 | ShiftMask,
 			RightShift	= 6 | ShiftMask,
 
 			LessThan	= 7 | ComparisonMask | RelationalMask,
 			GreaterThan	= 8 | ComparisonMask | RelationalMask,
 			LessThanOrEqual		= 9 | ComparisonMask | RelationalMask,
 			GreaterThanOrEqual	= 10 | ComparisonMask | RelationalMask,
 			Equality	= 11 | ComparisonMask | EqualityMask,
 			Inequality	= 12 | ComparisonMask | EqualityMask,
 
 			BitwiseAnd	= 13 | BitwiseMask,
 			ExclusiveOr	= 14 | BitwiseMask,
 			BitwiseOr	= 15 | BitwiseMask,
 
 			LogicalAnd	= 16 | LogicalMask,
 			LogicalOr	= 17 | LogicalMask,
 
 			//
 			// Operator masks
 			//
 			ValuesOnlyMask	= ArithmeticMask - 1,
 			ArithmeticMask	= 1 << 5,
 			ShiftMask		= 1 << 6,
 			ComparisonMask	= 1 << 7,
 			EqualityMask	= 1 << 8,
 			BitwiseMask		= 1 << 9,
 			LogicalMask		= 1 << 10,
 			AdditionMask	= 1 << 11,
 			SubtractionMask	= 1 << 12,
 			RelationalMask	= 1 << 13
 		}
 
 		protected enum State
 		{
 			None = 0,
 			Compound = 1 << 1,
 			LeftNullLifted = 1 << 2,
 			RightNullLifted = 1 << 3
 		}
 
 		readonly Operator oper;
 		protected Expression left, right;
 		protected State state;
 		Expression enum_conversion;
 
 		static PredefinedOperator[] standard_operators;
 		static PredefinedOperator[] equality_operators;
 		static PredefinedOperator[] pointer_operators;
 		
 		public Binary (Operator oper, Expression left, Expression right, bool isCompound, Location loc)
 			
 		{
 			if (isCompound)
 				state |= State.Compound;
 		}
 
 		public Binary (Operator oper, Expression left, Expression right, Location loc)
 		{
 			this.oper = oper;
 			this.left = left;
 			this.right = right;
 			this.loc = loc;
 		}
 
 		#region Properties
 
 		public bool IsCompound {
 			get {
 				return (state & State.Compound) != 0;
 			}
 		}
 
 		public Operator Oper {
 			get {
 				return oper;
 			}
 		}
 
 		#endregion
 
 		/// <summary>
 		///   Returns a stringified representation of the Operator
 		/// </summary>
 		string OperName (Operator oper)
 		{
 			string s;
 			switch (oper){
 			case Operator.Multiply
 				s = "*";
 				break;
 			case Operator.Division
 				s = "/";
 				break;
 			case Operator.Modulus
 				s = "%";
 				break;
 			case Operator.Addition
 				s = "+";
 				break;
 			case Operator.Subtraction
 				s = "-";
 				break;
 			case Operator.LeftShift
 				s = "<<";
 				break;
 			case Operator.RightShift
 				s = ">>";
 				break;
 			case Operator.LessThan
 				s = "<";
 				break;
 			case Operator.GreaterThan
 				s = ">";
 				break;
 			case Operator.LessThanOrEqual
 				s = "<=";
 				break;
 			case Operator.GreaterThanOrEqual
 				s = ">=";
 				break;
 			case Operator.Equality
 				s = "==";
 				break;
 			case Operator.Inequality
 				s = "!=";
 				break;
 			case Operator.BitwiseAnd
 				s = "&";
 				break;
 			case Operator.BitwiseOr
 				s = "|";
 				break;
 			case Operator.ExclusiveOr
 				s = "^";
 				break;
 			case Operator.LogicalOr
 				s = "||";
 				break;
 			case Operator.LogicalAnd
 				s = "&&";
 				break;
 			default
 				s = oper.ToString ();
 				break;
 			}
 
 			if (IsCompound)
 				return s + "=";
 
 			return s;
 		}
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Expression left, Expression right, Operator oper, Location loc)
 		{
 			new Binary (oper, left, right, loc).Error_OperatorCannotBeApplied (ec, left, right);
 		}
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Expression left, Expression right, string oper, Location loc)
 		{
 			string l, r;
 			l = TypeManager.CSharpName (left.Type);
 			r = TypeManager.CSharpName (right.Type);
 
 			ec.Report.Error (19, loc, "Operator `{0}' cannot be applied to operands of type `{1}' and `{2}'",
 				oper, l, r);
 		}
 		
 		protected void Error_OperatorCannotBeApplied (ResolveContext ec, Expression left, Expression right)
 		{
 			Error_OperatorCannotBeApplied (ec, left, right, OperName (oper), loc);
 		}
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (oper) {
 			case Operator.Addition
 				return IsCompound ? "AddAssign" 
 			case Operator.BitwiseAnd
 				return IsCompound ? "AndAssign" 
 			case Operator.BitwiseOr
 				return IsCompound ? "OrAssign" 
 			case Operator.Division
 				return IsCompound ? "DivideAssign" 
 			case Operator.ExclusiveOr
 				return IsCompound ? "ExclusiveOrAssign" 
 			case Operator.Equality
 				return "Equal";
 			case Operator.GreaterThan
 				return "GreaterThan";
 			case Operator.GreaterThanOrEqual
 				return "GreaterThanOrEqual";
 			case Operator.Inequality
 				return "NotEqual";
 			case Operator.LeftShift
 				return IsCompound ? "LeftShiftAssign" 
 			case Operator.LessThan
 				return "LessThan";
 			case Operator.LessThanOrEqual
 				return "LessThanOrEqual";
 			case Operator.LogicalAnd
 				return "And";
 			case Operator.LogicalOr
 				return "Or";
 			case Operator.Modulus
 				return IsCompound ? "ModuloAssign" 
 			case Operator.Multiply
 				return IsCompound ? "MultiplyAssign" 
 			case Operator.RightShift
 				return IsCompound ? "RightShiftAssign" 
 			case Operator.Subtraction
 				return IsCompound ? "SubtractAssign" 
 			default
 				throw new NotImplementedException ("Unknown expression type operator " + oper.ToString ());
 			}
 		}
 
 		static CSharp.Operator.OpType ConvertBinaryToUserOperator (Operator op)
 		{
 			switch (op) {
 			case Operator.Addition
 				return CSharp.Operator.OpType.Addition;
 			case Operator.BitwiseAnd
 			case Operator.LogicalAnd
 				return CSharp.Operator.OpType.BitwiseAnd;
 			case Operator.BitwiseOr
 			case Operator.LogicalOr
 				return CSharp.Operator.OpType.BitwiseOr;
 			case Operator.Division
 				return CSharp.Operator.OpType.Division;
 			case Operator.Equality
 				return CSharp.Operator.OpType.Equality;
 			case Operator.ExclusiveOr
 				return CSharp.Operator.OpType.ExclusiveOr;
 			case Operator.GreaterThan
 				return CSharp.Operator.OpType.GreaterThan;
 			case Operator.GreaterThanOrEqual
 				return CSharp.Operator.OpType.GreaterThanOrEqual;
 			case Operator.Inequality
 				return CSharp.Operator.OpType.Inequality;
 			case Operator.LeftShift
 				return CSharp.Operator.OpType.LeftShift;
 			case Operator.LessThan
 				return CSharp.Operator.OpType.LessThan;
 			case Operator.LessThanOrEqual
 				return CSharp.Operator.OpType.LessThanOrEqual;
 			case Operator.Modulus
 				return CSharp.Operator.OpType.Modulus;
 			case Operator.Multiply
 				return CSharp.Operator.OpType.Multiply;
 			case Operator.RightShift
 				return CSharp.Operator.OpType.RightShift;
 			case Operator.Subtraction
 				return CSharp.Operator.OpType.Subtraction;
 			default
 				throw new InternalErrorException (op.ToString ());
 			}
 		}
 
 		public static void EmitOperatorOpcode (EmitContext ec, Operator oper, TypeSpec l)
 		{
 			OpCode opcode;
 
 			switch (oper){
 			case Operator.Multiply
 				if (ec.HasSet (EmitContext.Options.CheckedScope)) {
 					if (l == TypeManager.int32_type || l == TypeManager.int64_type)
 						opcode = OpCodes.Mul_Ovf;
 					else if (!IsFloat (l))
 						opcode = OpCodes.Mul_Ovf_Un;
 					else
 						opcode = OpCodes.Mul;
 				} else
 					opcode = OpCodes.Mul;
 				
 				break;
 				
 			case Operator.Division
 				if (IsUnsigned (l))
 					opcode = OpCodes.Div_Un;
 				else
 					opcode = OpCodes.Div;
 				break;
 				
 			case Operator.Modulus
 				if (IsUnsigned (l))
 					opcode = OpCodes.Rem_Un;
 				else
 					opcode = OpCodes.Rem;
 				break;
 
 			case Operator.Addition
 				if (ec.HasSet (EmitContext.Options.CheckedScope)) {
 					if (l == TypeManager.int32_type || l == TypeManager.int64_type)
 						opcode = OpCodes.Add_Ovf;
 					else if (!IsFloat (l))
 						opcode = OpCodes.Add_Ovf_Un;
 					else
 						opcode = OpCodes.Add;
 				} else
 					opcode = OpCodes.Add;
 				break;
 
 			case Operator.Subtraction
 				if (ec.HasSet (EmitContext.Options.CheckedScope)) {
 					if (l == TypeManager.int32_type || l == TypeManager.int64_type)
 						opcode = OpCodes.Sub_Ovf;
 					else if (!IsFloat (l))
 						opcode = OpCodes.Sub_Ovf_Un;
 					else
 						opcode = OpCodes.Sub;
 				} else
 					opcode = OpCodes.Sub;
 				break;
 
 			case Operator.RightShift
 				if (IsUnsigned (l))
 					opcode = OpCodes.Shr_Un;
 				else
 					opcode = OpCodes.Shr;
 				break;
 				
 			case Operator.LeftShift
 				opcode = OpCodes.Shl;
 				break;
 
 			case Operator.Equality
 				opcode = OpCodes.Ceq;
 				break;
 
 			case Operator.Inequality
 				ec.Emit (OpCodes.Ceq);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				
 				opcode = OpCodes.Ceq;
 				break;
 
 			case Operator.LessThan
 				if (IsUnsigned (l))
 					opcode = OpCodes.Clt_Un;
 				else
 					opcode = OpCodes.Clt;
 				break;
 
 			case Operator.GreaterThan
 				if (IsUnsigned (l))
 					opcode = OpCodes.Cgt_Un;
 				else
 					opcode = OpCodes.Cgt;
 				break;
 
 			case Operator.LessThanOrEqual
 				if (IsUnsigned (l) || IsFloat (l))
 					ec.Emit (OpCodes.Cgt_Un);
 				else
 					ec.Emit (OpCodes.Cgt);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				
 				opcode = OpCodes.Ceq;
 				break;
 
 			case Operator.GreaterThanOrEqual
 				if (IsUnsigned (l) || IsFloat (l))
 					ec.Emit (OpCodes.Clt_Un);
 				else
 					ec.Emit (OpCodes.Clt);
 				
 				ec.Emit (OpCodes.Ldc_I4_0);
 				
 				opcode = OpCodes.Ceq;
 				break;
 
 			case Operator.BitwiseOr
 				opcode = OpCodes.Or;
 				break;
 
 			case Operator.BitwiseAnd
 				opcode = OpCodes.And;
 				break;
 
 			case Operator.ExclusiveOr
 				opcode = OpCodes.Xor;
 				break;
 
 			default
 				throw new InternalErrorException (oper.ToString ());
 			}
 
 			ec.Emit (opcode);
 		}
 
 		static bool IsUnsigned (TypeSpec t)
 		{
 			if (t.IsPointer)
 				return true;
 
 			return (t == TypeManager.uint32_type || t == TypeManager.uint64_type ||
 				t == TypeManager.ushort_type || t == TypeManager.byte_type);
 		}
 
 		static bool IsFloat (TypeSpec t)
 		{
 			return t == TypeManager.float_type || t == TypeManager.double_type;
 		}
 
 		public static void Reset ()
 		{
 			equality_operators = pointer_operators = standard_operators = null;
 		}
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
 
 		// at least one of 'left' or 'right' is an enumeration constant (EnumConstant or SideEffectConstant or ...)
 		// if 'left' is not an enumeration constant, create one from the type of 'right'
 		Constant EnumLiftUp (ResolveContext ec, Constant left, Constant right, Location loc)
 		{
 			switch (oper) {
 			case Operator.BitwiseOr
 			case Operator.BitwiseAnd
 			case Operator.ExclusiveOr
 			case Operator.Equality
 			case Operator.Inequality
 			case Operator.LessThan
 			case Operator.LessThanOrEqual
 			case Operator.GreaterThan
 			case Operator.GreaterThanOrEqual
 				if (TypeManager.IsEnumType (left.Type))
 					return left;
 				
 				if (left.IsZeroInteger)
 					return left.TryReduce (ec, right.Type, loc);
 				
 				break;
 				
 			case Operator.Addition
 			case Operator.Subtraction
 				return left;
 				
 			case Operator.Multiply
 			case Operator.Division
 			case Operator.Modulus
 			case Operator.LeftShift
 			case Operator.RightShift
 				if (TypeManager.IsEnumType (right.Type) || TypeManager.IsEnumType (left.Type))
 					break;
 				return left;
 			}
 			Error_OperatorCannotBeApplied (ec, this.left, this.right);
 			return null;
 		}
 
 		//
 		// The `|' operator used on types which were extended is dangerous
 		//
 		void CheckBitwiseOrOnSignExtended (ResolveContext ec)
 		{
 			OpcodeCast lcast = left as OpcodeCast;
 			if (lcast != null) {
 				if (IsUnsigned (lcast.UnderlyingType))
 					lcast = null;
 			}
 
 			OpcodeCast rcast = right as OpcodeCast;
 			if (rcast != null) {
 				if (IsUnsigned (rcast.UnderlyingType))
 					rcast = null;
 			}
 
 			if (lcast == null && rcast == null)
 				return;
 
 			// FIXME
 
 			ec.Report.Warning (675, 3, loc,
 				"The operator `|' used on the sign-extended type `{0}'. Consider casting to a smaller unsigned type first",
 				TypeManager.CSharpName (lcast != null ? lcast.UnderlyingType 
 		}
 
 		static void CreatePointerOperatorsTable ()
 		{
 			var temp = new List<PredefinedPointerOperator> ();
 
 			//
 			// Pointer arithmetic
 			//
 			// T* operator + (T* x, int y);		T* operator - (T* x, int y);
 			// T* operator + (T* x, uint y);	T* operator - (T* x, uint y);
 			// T* operator + (T* x, long y);	T* operator - (T* x, long y);
 			// T* operator + (T* x, ulong y);	T* operator - (T* x, ulong y);
 			//
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.int32_type, Operator.AdditionMask | Operator.SubtractionMask));
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.uint32_type, Operator.AdditionMask | Operator.SubtractionMask));
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.int64_type, Operator.AdditionMask | Operator.SubtractionMask));
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.uint64_type, Operator.AdditionMask | Operator.SubtractionMask));
 
 			//
 			// T* operator + (int y,   T* x);
 			// T* operator + (uint y,  T *x);
 			// T* operator + (long y,  T *x);
 			// T* operator + (ulong y, T *x);
 			//
 			temp.Add (new PredefinedPointerOperator (TypeManager.int32_type, null, Operator.AdditionMask, null));
 			temp.Add (new PredefinedPointerOperator (TypeManager.uint32_type, null, Operator.AdditionMask, null));
 			temp.Add (new PredefinedPointerOperator (TypeManager.int64_type, null, Operator.AdditionMask, null));
 			temp.Add (new PredefinedPointerOperator (TypeManager.uint64_type, null, Operator.AdditionMask, null));
 
 			//
 			// long operator - (T* x, T *y)
 			//
 			temp.Add (new PredefinedPointerOperator (null, Operator.SubtractionMask, TypeManager.int64_type));
 
 			pointer_operators = temp.ToArray ();
 		}
 
 		static void CreateStandardOperatorsTable ()
 		{
 			var temp = new List<PredefinedOperator> ();
 			TypeSpec bool_type = TypeManager.bool_type;
 
 			temp.Add (new PredefinedOperator (TypeManager.int32_type, Operator.ArithmeticMask | Operator.BitwiseMask));
 			temp.Add (new PredefinedOperator (TypeManager.uint32_type, Operator.ArithmeticMask | Operator.BitwiseMask));
 			temp.Add (new PredefinedOperator (TypeManager.int64_type, Operator.ArithmeticMask | Operator.BitwiseMask));
 			temp.Add (new PredefinedOperator (TypeManager.uint64_type, Operator.ArithmeticMask | Operator.BitwiseMask));
 			temp.Add (new PredefinedOperator (TypeManager.float_type, Operator.ArithmeticMask));
 			temp.Add (new PredefinedOperator (TypeManager.double_type, Operator.ArithmeticMask));
 			temp.Add (new PredefinedOperator (TypeManager.decimal_type, Operator.ArithmeticMask));
 
 			temp.Add (new PredefinedOperator (TypeManager.int32_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.uint32_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.int64_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.uint64_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.float_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.double_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.decimal_type, Operator.ComparisonMask, bool_type));
 
 			temp.Add (new PredefinedStringOperator (TypeManager.string_type, Operator.AdditionMask));
 			temp.Add (new PredefinedStringOperator (TypeManager.string_type, TypeManager.object_type, Operator.AdditionMask));
 			temp.Add (new PredefinedStringOperator (TypeManager.object_type, TypeManager.string_type, Operator.AdditionMask));
 
 			temp.Add (new PredefinedOperator (bool_type,
 				Operator.BitwiseMask | Operator.LogicalMask | Operator.EqualityMask, bool_type));
 
 			temp.Add (new PredefinedShiftOperator (TypeManager.int32_type, Operator.ShiftMask));
 			temp.Add (new PredefinedShiftOperator (TypeManager.uint32_type, Operator.ShiftMask));
 			temp.Add (new PredefinedShiftOperator (TypeManager.int64_type, Operator.ShiftMask));
 			temp.Add (new PredefinedShiftOperator (TypeManager.uint64_type, Operator.ShiftMask));
 
 			standard_operators = temp.ToArray ();
 
 			var equality = new List<PredefinedOperator> () {
 				new PredefinedEqualityOperator (TypeManager.string_type, bool_type),
 				new PredefinedEqualityOperator (TypeManager.delegate_type, bool_type),
 				new PredefinedOperator (bool_type, Operator.EqualityMask, bool_type)
 			};
 
 			equality_operators = equality.ToArray ();
 		}
 
 		//
 		// Rules used during binary numeric promotion
 		//
 		static bool DoNumericPromotion (ResolveContext rc, ref Expression prim_expr, ref Expression second_expr, TypeSpec type)
 		{
 			Expression temp;
 			TypeSpec etype;
 
 			Constant c = prim_expr as Constant;
 			if (c != null) {
 				temp = c.ConvertImplicitly (rc, type);
 				if (temp != null) {
 					prim_expr = temp;
 					return true;
 				}
 			}
 
 			if (type == TypeManager.uint32_type) {
 				etype = prim_expr.Type;
 				if (etype == TypeManager.int32_type || etype == TypeManager.short_type || etype == TypeManager.sbyte_type) {
 					type = TypeManager.int64_type;
 
 					if (type != second_expr.Type) {
 						c = second_expr as Constant;
 						if (c != null)
 							temp = c.ConvertImplicitly (rc, type);
 						else
 							temp = Convert.ImplicitNumericConversion (second_expr, type);
 						if (temp == null)
 							return false;
 						second_expr = temp;
 					}
 				}
 			} else if (type == TypeManager.uint64_type) {
 				//
 				// A compile-time error occurs if the other operand is of type sbyte, short, int, or long
 				//
 				if (type == TypeManager.int32_type || type == TypeManager.int64_type ||
 					type == TypeManager.short_type || type == TypeManager.sbyte_type)
 					return false;
 			}
 
 			temp = Convert.ImplicitNumericConversion (prim_expr, type);
 			if (temp == null)
 				return false;
 
 			prim_expr = temp;
 			return true;
 		}
 
 		//
 		// 7.2.6.2 Binary numeric promotions
 		//
 		public bool DoBinaryOperatorPromotion (ResolveContext ec)
 		{
 			TypeSpec ltype = left.Type;
 			TypeSpec rtype = right.Type;
 			Expression temp;
 
 			foreach (TypeSpec t in ConstantFold.BinaryPromotionsTypes) {
 				if (t == ltype)
 					return t == rtype || DoNumericPromotion (ec, ref right, ref left, t);
 
 				if (t == rtype)
 					return t == ltype || DoNumericPromotion (ec, ref left, ref right, t);
 			}
 
 			TypeSpec int32 = TypeManager.int32_type;
 			if (ltype != int32) {
 				Constant c = left as Constant;
 				if (c != null)
 					temp = c.ConvertImplicitly (ec, int32);
 				else
 					temp = Convert.ImplicitNumericConversion (left, int32);
 
 				if (temp == null)
 					return false;
 				left = temp;
 			}
 
 			if (rtype != int32) {
 				Constant c = right as Constant;
 				if (c != null)
 					temp = c.ConvertImplicitly (ec, int32);
 				else
 					temp = Convert.ImplicitNumericConversion (right, int32);
 
 				if (temp == null)
 					return false;
 				right = temp;
 			}
 
 			return true;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (left == null)
 				return null;
 
 			if ((oper == Operator.Subtraction) && (left is ParenthesizedExpression)) {
 				left = ((ParenthesizedExpression) left).Expr;
 				left = left.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 				if (left == null)
 					return null;
 
 				if (left.eclass == ExprClass.Type) {
 					ec.Report.Error (75, loc, "To cast a negative value, you must enclose the value in parentheses");
 					return null;
 				}
 			} else
 				left = left.Resolve (ec);
 
 			if (left == null)
 				return null;
 
 			Constant lc = left as Constant;
 
 			if (lc != null && lc.Type == TypeManager.bool_type &&
 				((oper == Operator.LogicalAnd && lc.IsDefaultValue) ||
 				 (oper == Operator.LogicalOr && !lc.IsDefaultValue))) {
 
 				// FIXME
 				// right.Resolve (ec);
 
 				ec.Report.Warning (429, 4, loc, "Unreachable expression code detected");
 				return left;
 			}
 
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			Constant rc = right as Constant;
 
 			// The conversion rules are ignored in enum context but why
 			if (!ec.HasSet (ResolveContext.Options.EnumScope) && lc != null && rc != null && (TypeManager.IsEnumType (left.Type) || TypeManager.IsEnumType (right.Type))) {
 				lc = EnumLiftUp (ec, lc, rc, loc);
 				if (lc != null)
 					rc = EnumLiftUp (ec, rc, lc, loc);
 			}
 
 			if (rc != null && lc != null) {
 				int prev_e = ec.Report.Errors;
 				Expression e = ConstantFold.BinaryFold (ec, oper, lc, rc, loc);
 				if (e != null)
 					e = e.Resolve (ec);
 
 				if (e != null || ec.Report.Errors != prev_e)
 					return e;
 			}
 
 			// Comparison warnings
 			if ((oper & Operator.ComparisonMask) != 0) {
 				if (left.Equals (right)) {
 					ec.Report.Warning (1718, 3, loc, "A comparison made to same variable. Did you mean to compare something else?");
 				}
 				CheckUselessComparison (ec, lc, right.Type);
 				CheckUselessComparison (ec, rc, left.Type);
 			}
 
 			if (left.Type == InternalType.Dynamic || right.Type == InternalType.Dynamic) {
 				var lt = left.Type;
 				var rt = right.Type;
 				if (lt == TypeManager.void_type || lt == InternalType.MethodGroup || lt == InternalType.AnonymousMethod ||
 					rt == TypeManager.void_type || rt == InternalType.MethodGroup || rt == InternalType.AnonymousMethod) {
 					Error_OperatorCannotBeApplied (ec, left, right);
 					return null;
 				}
 
 				Arguments args;
 
 				//
 				// Special handling for logical boolean operators which require rhs not to be
 				// evaluated based on lhs value
 				//
 				if ((oper & Operator.LogicalMask) != 0) {
 					Expression cond_left, cond_right, expr;
 
 					args = new Arguments (2);
 
 					if (lt == InternalType.Dynamic) {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (lt, ec.CurrentBlock, loc);
 
 						var cond_args = new Arguments (1);
 						cond_args.Add (new Argument (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left).Resolve (ec)));
 
 						//
 						// dynamic && bool => IsFalse (temp = left) ? temp 
 						// dynamic || bool => IsTrue (temp = left) ? temp 
 						//
 						left = temp.CreateReferenceExpression (ec, loc);
 						if (oper == Operator.LogicalAnd) {
 							expr = DynamicUnaryConversion.CreateIsFalse (cond_args, loc);
 							cond_left = left;
 						} else {
 							expr = DynamicUnaryConversion.CreateIsTrue (cond_args, loc);
 							cond_left = left;
 						}
 
 						args.Add (new Argument (left));
 						args.Add (new Argument (right));
 						cond_right = new DynamicExpressionStatement (this, args, loc);
 					} else {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (TypeManager.bool_type, ec.CurrentBlock, loc);
 
 						args.Add (new Argument (temp.CreateReferenceExpression (ec, loc).Resolve (ec)));
 						args.Add (new Argument (right));
 						right = new DynamicExpressionStatement (this, args, loc);
 
 						//
 						// bool && dynamic => (temp = left) ? temp && right 
 						// bool || dynamic => (temp = left) ? temp 
 						//
 						if (oper == Operator.LogicalAnd) {
 							cond_left = right;
 							cond_right = temp.CreateReferenceExpression (ec, loc);
 						} else {
 							cond_left = temp.CreateReferenceExpression (ec, loc);
 							cond_right = right;
 						}
 
 						expr = new BooleanExpression (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left));
 					}
 
 					return new Conditional (expr, cond_left, cond_right, loc).Resolve (ec);
 				}
 
 				args = new Arguments (2);
 				args.Add (new Argument (left));
 				args.Add (new Argument (right));
 				return new DynamicExpressionStatement (this, args, loc).Resolve (ec);
 			}
 
 			if (RootContext.Version >= LanguageVersion.ISO_2 &&
 				((TypeManager.IsNullableType (left.Type) && (right is NullLiteral || TypeManager.IsNullableType (right.Type) || TypeManager.IsValueType (right.Type))) ||
 				(TypeManager.IsValueType (left.Type) && right is NullLiteral) ||
 				(TypeManager.IsNullableType (right.Type) && (left is NullLiteral || TypeManager.IsNullableType (left.Type) || TypeManager.IsValueType (left.Type))) ||
 				(TypeManager.IsValueType (right.Type) && left is NullLiteral))) {
 				var lifted = new Nullable.LiftedBinaryOperator (oper, left, right, loc);
 				lifted.state = state;
 				return lifted.Resolve (ec);
 			}
 
 			return DoResolveCore (ec, left, right);
 		}
 
 		protected Expression DoResolveCore (ResolveContext ec, Expression left_orig, Expression right_orig)
 		{
 			Expression expr = ResolveOperator (ec);
 			if (expr == null)
 				Error_OperatorCannotBeApplied (ec, left_orig, right_orig);
 
 			if (left == null || right == null)
 				throw new InternalErrorException ("Invalid conversion");
 
 			if (oper == Operator.BitwiseOr)
 				CheckBitwiseOrOnSignExtended (ec);
 
 			return expr;
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			var le = left.MakeExpression (ctx);
 			var re = right.MakeExpression (ctx);
 			bool is_checked = ctx.HasSet (BuilderContext.Options.CheckedScope);
 
 			switch (oper) {
 			case Operator.Addition
 				return is_checked ? SLE.Expression.AddChecked (le, re) 
 			case Operator.BitwiseAnd
 				return SLE.Expression.And (le, re);
 			case Operator.BitwiseOr
 				return SLE.Expression.Or (le, re);
 			case Operator.Division
 				return SLE.Expression.Divide (le, re);
 			case Operator.Equality
 				return SLE.Expression.Equal (le, re);
 			case Operator.ExclusiveOr
 				return SLE.Expression.ExclusiveOr (le, re);
 			case Operator.GreaterThan
 				return SLE.Expression.GreaterThan (le, re);
 			case Operator.GreaterThanOrEqual
 				return SLE.Expression.GreaterThanOrEqual (le, re);
 			case Operator.Inequality
 				return SLE.Expression.NotEqual (le, re);
 			case Operator.LeftShift
 				return SLE.Expression.LeftShift (le, re);
 			case Operator.LessThan
 				return SLE.Expression.LessThan (le, re);
 			case Operator.LessThanOrEqual
 				return SLE.Expression.LessThanOrEqual (le, re);
 			case Operator.LogicalAnd
 				return SLE.Expression.AndAlso (le, re);
 			case Operator.LogicalOr
 				return SLE.Expression.OrElse (le, re);
 			case Operator.Modulus
 				return SLE.Expression.Modulo (le, re);
 			case Operator.Multiply
 				return is_checked ? SLE.Expression.MultiplyChecked (le, re) 
 			case Operator.RightShift
 				return SLE.Expression.RightShift (le, re);
 			case Operator.Subtraction
 				return is_checked ? SLE.Expression.SubtractChecked (le, re) 
 			default
 				throw new NotImplementedException (oper.ToString ());
 			}
 		}
 
 		//
 		// D operator + (D x, D y)
 		// D operator - (D x, D y)
 		//
 		Expression ResolveOperatorDelegate (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			if (l != r && !TypeSpecComparer.Variant.IsEqual (r, l)) {
 				Expression tmp;
 				if (right.eclass == ExprClass.MethodGroup || r == InternalType.AnonymousMethod || r == InternalType.Null) {
 					tmp = Convert.ImplicitConversionRequired (ec, right, l, loc);
 					if (tmp == null)
 						return null;
 					right = tmp;
 					r = right.Type;
 				} else if (left.eclass == ExprClass.MethodGroup || (l == InternalType.AnonymousMethod || l == InternalType.Null)) {
 					tmp = Convert.ImplicitConversionRequired (ec, left, r, loc);
 					if (tmp == null)
 						return null;
 					left = tmp;
 					l = left.Type;
 				} else {
 					return null;
 				}
 			}
 
 			MethodSpec method;
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (left));
 			args.Add (new Argument (right));
 
 			if (oper == Operator.Addition) {
 				if (TypeManager.delegate_combine_delegate_delegate == null) {
 					TypeManager.delegate_combine_delegate_delegate = TypeManager.GetPredefinedMethod (
 						TypeManager.delegate_type, "Combine", loc, TypeManager.delegate_type, TypeManager.delegate_type);
 				}
 
 				method = TypeManager.delegate_combine_delegate_delegate;
 			} else if (oper == Operator.Subtraction) {
 				if (TypeManager.delegate_remove_delegate_delegate == null) {
 					TypeManager.delegate_remove_delegate_delegate = TypeManager.GetPredefinedMethod (
 						TypeManager.delegate_type, "Remove", loc, TypeManager.delegate_type, TypeManager.delegate_type);
 				}
 
 				method = TypeManager.delegate_remove_delegate_delegate;
 			} else {
 				return new EmptyExpression (TypeManager.decimal_type);
 			}
 
 			MethodGroupExpr mg = MethodGroupExpr.CreatePredefined (method, TypeManager.delegate_type, loc);
 			Expression expr = new UserOperatorCall (mg.BestCandidate, args, CreateExpressionTree, loc);
 			return new ClassCast (expr, l);
 		}
 
 		//
 		// Enumeration operators
 		//
 		Expression ResolveOperatorEnum (ResolveContext ec, bool lenum, bool renum, TypeSpec ltype, TypeSpec rtype)
 		{
 			//
 			// bool operator == (E x, E y);
 			// bool operator != (E x, E y);
 			// bool operator < (E x, E y);
 			// bool operator > (E x, E y);
 			// bool operator <= (E x, E y);
 			// bool operator >= (E x, E y);
 			//
 			// E operator & (E x, E y);
 			// E operator | (E x, E y);
 			// E operator ^ (E x, E y);
 			//
 			// U operator - (E e, E f)
 			// E operator - (E e, U x)
 			// E operator - (U x, E e)	// LAMESPEC
 			//
 			// E operator + (E e, U x)
 			// E operator + (U x, E e)
 			//
 			Expression ltemp = left;
 			Expression rtemp = right;
 			TypeSpec underlying_type;
 			TypeSpec underlying_type_result;
 			TypeSpec res_type;
 			Expression expr;
 			
 			//
 			// LAMESPEC
 			// the one which contains more enum parameters always wins even if there
 			// is an implicit conversion involved
 			//
 			if ((oper & (Operator.ComparisonMask | Operator.BitwiseMask)) != 0) {
 				if (renum) {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					expr = Convert.ImplicitConversion (ec, left, rtype, loc);
 					if (expr == null)
 						return null;
 
 					left = expr;
 					ltype = expr.Type;
 				} else if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					expr = Convert.ImplicitConversion (ec, right, ltype, loc);
 					if (expr == null)
 						return null;
 
 					right = expr;
 					rtype = expr.Type;
 				} else {
 					return null;
 				}
 
 				if ((oper & Operator.BitwiseMask) != 0) {
 					res_type = ltype;
 					underlying_type_result = underlying_type;
 				} else {
 					res_type = null;
 					underlying_type_result = null;
 				}
 			} else if (oper == Operator.Subtraction) {
 				if (renum) {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					if (ltype != rtype) {
 						expr = Convert.ImplicitConversion (ec, left, rtype, left.Location);
 						if (expr == null) {
 							expr = Convert.ImplicitConversion (ec, left, underlying_type, left.Location);
 							if (expr == null)
 								return null;
 
 							res_type = rtype;
 						} else {
 							res_type = underlying_type;
 						}
 
 						left = expr;
 					} else {
 						res_type = underlying_type;
 					}
 
 					underlying_type_result = underlying_type;
 				} else if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					expr = Convert.ImplicitConversion (ec, right, ltype, right.Location);
 					if (expr == null || expr is EnumConstant) {
 						expr = Convert.ImplicitConversion (ec, right, underlying_type, right.Location);
 						if (expr == null)
 							return null;
 
 						res_type = ltype;
 					} else {
 						res_type = underlying_type;
 					}
 
 					right = expr;
 					underlying_type_result = underlying_type;
 				} else {
 					return null;
 				}
 			} else if (oper == Operator.Addition) {
 				if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					res_type = ltype;
 
 					if (rtype != underlying_type && (state & (State.RightNullLifted | State.LeftNullLifted)) == 0) {
 						expr = Convert.ImplicitConversion (ec, right, underlying_type, right.Location);
 						if (expr == null)
 							return null;
 
 						right = expr;
 					}
 				} else {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					res_type = rtype;
 					if (ltype != underlying_type) {
 						expr = Convert.ImplicitConversion (ec, left, underlying_type, left.Location);
 						if (expr == null)
 							return null;
 
 						left = expr;
 					}
 				}
 
 				underlying_type_result = underlying_type;
 			} else {
 				return null;
 			}
 
 			// Unwrap the constant correctly, so DoBinaryOperatorPromotion can do the magic
 			// with constants and expressions
 			if (left.Type != underlying_type) {
 				if (left is Constant)
 					left = ((Constant) left).ConvertExplicitly (false, underlying_type).Resolve (ec);
 				else
 					left = EmptyCast.Create (left, underlying_type);
 			}
 
 			if (right.Type != underlying_type) {
 				if (right is Constant)
 					right = ((Constant) right).ConvertExplicitly (false, underlying_type).Resolve (ec);
 				else
 					right = EmptyCast.Create (right, underlying_type);
 			}
 
 			//
 			// C# specification uses explicit cast syntax which means binary promotion
 			// should happen, however it seems that csc does not do that
 			//
 			if (!DoBinaryOperatorPromotion (ec)) {
 				left = ltemp;
 				right = rtemp;
 				return null;
 			}
 
 			if (underlying_type_result != null && left.Type != underlying_type_result) {
 				enum_conversion = Convert.ExplicitNumericConversion (new EmptyExpression (left.Type), underlying_type_result);
 			}
 
 			expr = ResolveOperatorPredefined (ec, standard_operators, true, res_type);
 			if (expr == null)
 				return null;
 
 			if (!IsCompound)
 				return expr;
 
 			//
 			// Section
 			//
 
 			//
 			// If the return type of the selected operator is implicitly convertible to the type of x
 			//
 			if (Convert.ImplicitConversionExists (ec, expr, ltype))
 				return expr;
 
 			//
 			// Otherwise, if the selected operator is a predefined operator, if the return type of the
 			// selected operator is explicitly convertible to the type of x, and if y is implicitly
 			// convertible to the type of x or the operator is a shift operator, then the operation
 			// is evaluated as x = (T)(x op y), where T is the type of x
 			//
 			expr = Convert.ExplicitConversion (ec, expr, ltype, loc);
 			if (expr == null)
 				return null;
 
 			if (Convert.ImplicitConversionExists (ec, ltemp, ltype))
 				return expr;
 
 			return null;
 		}
 
 		//
 		// 7.9.6 Reference type equality operators
 		//
 		Expression ResolveOperatorEquality (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			Expression result;
 			type = TypeManager.bool_type;
 
 			//
 			// a, Both operands are reference-type values or the value null
 			// b, One operand is a value of type T where T is a type-parameter and
 			// the other operand is the value null. Furthermore T does not have the
 			// value type constraint
 			//
 			// LAMESPEC
 			// reference like type-parameter is allowed
 			//
 			var tparam_l = l as TypeParameterSpec;
 			var tparam_r = r as TypeParameterSpec;
 			if (tparam_l != null) {
 				if (right is NullLiteral && !tparam_l.HasSpecialStruct) {
 					left = new BoxedCast (left, TypeManager.object_type);
 					return this;
 				}
 
 				if (!tparam_l.IsReferenceType)
 					return null;
 
 				l = tparam_l.GetEffectiveBase ();
 				left = new BoxedCast (left, l);
 			} else if (left is NullLiteral && tparam_r == null) {
 				if (!TypeManager.IsReferenceType (r) || r.Kind == MemberKind.InternalCompilerType)
 					return null;
 
 				return this;
 			}
 
 			if (tparam_r != null) {
 				if (left is NullLiteral && !tparam_r.HasSpecialStruct) {
 					right = new BoxedCast (right, TypeManager.object_type);
 					return this;
 				}
 
 				if (!tparam_r.IsReferenceType)
 					return null;
 
 				r = tparam_r.GetEffectiveBase ();
 				right = new BoxedCast (right, r);
 			} else if (right is NullLiteral) {
 				if (!TypeManager.IsReferenceType (l) || l.Kind == MemberKind.InternalCompilerType)
 					return null;
 
 				return this;
 			}
 
 			//
 			// LAMESPEC
 			//
 			if (l.IsDelegate) {
 				if (right.eclass == ExprClass.MethodGroup) {
 					result = Convert.ImplicitConversion (ec, right, l, loc);
 					if (result == null)
 						return null;
 
 					right = result;
 					r = l;
 				} else if (r.IsDelegate && l != r) {
 					return null;
 				}
 			} else if (left.eclass == ExprClass.MethodGroup && r.IsDelegate) {
 				result = Convert.ImplicitConversionRequired (ec, left, r, loc);
 				if (result == null)
 					return null;
 
 				left = result;
 				l = r;
 			}
 
 			//
 			// bool operator != (string a, string b)
 			// bool operator == (string a, string b)
 			//
 			// bool operator != (Delegate a, Delegate b)
 			// bool operator == (Delegate a, Delegate b)
 			//
 			// bool operator != (bool a, bool b)
 			// bool operator == (bool a, bool b)
 			//
 			// LAMESPEC
 			// they implement an implicit conversion to any of types above.
 			//
 			if (r != TypeManager.object_type && l != TypeManager.object_type) {
 				result = ResolveOperatorPredefined (ec, equality_operators, false, null);
 				if (result != null)
 					return result;
 			}
 
 			//
 			// bool operator != (object a, object b)
 			// bool operator == (object a, object b)
 			//
 			// An explicit reference conversion exists from the
 			// type of either operand to the type of the other operand.
 			//
 
 			// Optimize common path
 			if (l == r) {
 				return l.Kind == MemberKind.InternalCompilerType || l.Kind == MemberKind.Struct ? null 
 			}
 
 			if (!Convert.ExplicitReferenceConversionExists (l, r) &&
 				!Convert.ExplicitReferenceConversionExists (r, l))
 				return null;
 
 			// Reject allowed explicit conversions like int->object
 			if (!TypeManager.IsReferenceType (l) || !TypeManager.IsReferenceType (r))
 				return null;
 
 			if (l == TypeManager.string_type || l == TypeManager.delegate_type || MemberCache.GetUserOperator (l, CSharp.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (253, 2, loc,
 					"Possible unintended reference comparison. Consider casting the right side expression to type `{0}' to get value comparison",
 					l.GetSignatureForError ());
 
 			if (r == TypeManager.string_type || r == TypeManager.delegate_type || MemberCache.GetUserOperator (r, CSharp.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (252, 2, loc,
 					"Possible unintended reference comparison. Consider casting the left side expression to type `{0}' to get value comparison",
 					r.GetSignatureForError ());
 
 			return this;
 		}
 
 
 		Expression ResolveOperatorPointer (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			//
 			// bool operator == (void* x, void* y);
 			// bool operator != (void* x, void* y);
 			// bool operator < (void* x, void* y);
 			// bool operator > (void* x, void* y);
 			// bool operator <= (void* x, void* y);
 			// bool operator >= (void* x, void* y);
 			//
 			if ((oper & Operator.ComparisonMask) != 0) {
 				Expression temp;
 				if (!l.IsPointer) {
 					temp = Convert.ImplicitConversion (ec, left, r, left.Location);
 					if (temp == null)
 						return null;
 					left = temp;
 				}
 
 				if (!r.IsPointer) {
 					temp = Convert.ImplicitConversion (ec, right, l, right.Location);
 					if (temp == null)
 						return null;
 					right = temp;
 				}
 
 				type = TypeManager.bool_type;
 				return this;
 			}
 
 			if (pointer_operators == null)
 				CreatePointerOperatorsTable ();
 
 			return ResolveOperatorPredefined (ec, pointer_operators, false, null);
 		}
 
 		//
 		// Build-in operators method overloading
 		//
 		protected virtual Expression ResolveOperatorPredefined (ResolveContext ec, PredefinedOperator [] operators, bool primitives_only, TypeSpec enum_type)
 		{
 			PredefinedOperator best_operator = null;
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Operator oper_mask = oper & ~Operator.ValuesOnlyMask;
 
 			foreach (PredefinedOperator po in operators) {
 				if ((po.OperatorsMask & oper_mask) == 0)
 					continue;
 
 				if (primitives_only) {
 					if (!po.IsPrimitiveApplicable (l, r))
 						continue;
 				} else {
 					if (!po.IsApplicable (ec, left, right))
 						continue;
 				}
 
 				if (best_operator == null) {
 					best_operator = po;
 					if (primitives_only)
 						break;
 
 					continue;
 				}
 
 				best_operator = po.ResolveBetterOperator (ec, best_operator);
 
 				if (best_operator == null) {
 					ec.Report.Error (34, loc, "Operator `{0}' is ambiguous on operands of type `{1}' and `{2}'",
 						OperName (oper), TypeManager.CSharpName (l), TypeManager.CSharpName (r));
 
 					best_operator = po;
 					break;
 				}
 			}
 
 			if (best_operator == null)
 				return null;
 
 			Expression expr = best_operator.ConvertResult (ec, this);
 
 			//
 			// Optimize &/&& constant expressions with 0 value
 			//
 			if (oper == Operator.BitwiseAnd || oper == Operator.LogicalAnd) {
 				Constant rc = right as Constant;
 				Constant lc = left as Constant;
 				if (((lc != null && lc.IsDefaultValue) || (rc != null && rc.IsDefaultValue)) && !(this is Nullable.LiftedBinaryOperator)) {
 					//
 					// The result is a constant with side-effect
 					//
 					Constant side_effect = rc == null ?
 						new SideEffectConstant (lc, right, loc) 
 						new SideEffectConstant (rc, left, loc);
 
 					return ReducedExpression.Create (side_effect.Resolve (ec), expr);
 				}
 			}
 
 			if (enum_type == null)
 				return expr;
 
 			//
 			// HACK
 			//
 			expr.Type = enum_type;
 			return EmptyCast.Create (expr, enum_type);
 		}
 
 		//
 		// Performs user-operator overloading
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression left, Expression right)
 		{
 			var op = ConvertBinaryToUserOperator (oper);
 			var l = left.Type;
 			if (TypeManager.IsNullableType (l))
 				l = Nullable.NullableInfo.GetUnderlyingType (l);
 			var r = right.Type;
 			if (TypeManager.IsNullableType (r))
 				r = Nullable.NullableInfo.GetUnderlyingType (r);
 
 			IList<MemberSpec> left_operators = MemberCache.GetUserOperator (l, op, false);
 			IList<MemberSpec> right_operators = null;
 
 			if (l != r) {
 				right_operators = MemberCache.GetUserOperator (r, op, false);
 				if (right_operators == null && left_operators == null)
 					return null;
 			} else if (left_operators == null) {
 				return null;
 			}
 
 			Arguments args = new Arguments (2);
 			Argument larg = new Argument (left);
 			args.Add (larg);
 			Argument rarg = new Argument (right);
 			args.Add (rarg);
 
 			//
 			// User-defined operator implementations always take precedence
 			// over predefined operator implementations
 			//
 			if (left_operators != null && right_operators != null) {
 				left_operators = CombineUserOperators (left_operators, right_operators);
 			} else if (right_operators != null) {
 				left_operators = right_operators;
 			}
 
 			var res = new OverloadResolver (left_operators, OverloadResolver.Restrictions.ProbingOnly | 
 				OverloadResolver.Restrictions.NoBaseMembers | OverloadResolver.Restrictions.BaseMembersIncluded, loc);
 
 			var oper_method = res.ResolveOperator (ec, ref args);
 			if (oper_method == null)
 				return null;
 
 			var llifted = (state & State.LeftNullLifted) != 0;
 			var rlifted = (state & State.RightNullLifted) != 0;
 			if ((Oper & Operator.EqualityMask) != 0) {
 				var parameters = oper_method.Parameters;
 				// LAMESPEC
 				if ((left is Nullable.Unwrap || right is Nullable.Unwrap) && parameters.Types [0] != parameters.Types [1])
 					return null;
 
 				// Binary operation was lifted but we have found a user operator
 				// which requires value-type argument, we downgrade ourself back to
 				// binary operation
 				// LAMESPEC
 				// but compilation succeeds
 				if ((llifted && !parameters.Types[0].IsStruct) || (rlifted && !parameters.Types[1].IsStruct)) {
 					state &= ~(State.LeftNullLifted | State.RightNullLifted);
 				}
 			}
 
 			Expression oper_expr;
 
 			// TODO
 			if ((oper & Operator.LogicalMask) != 0) {
 				oper_expr = new ConditionalLogicalOperator (oper_method, args, CreateExpressionTree,
 					oper == Operator.LogicalAnd, loc).Resolve (ec);
 			} else {
 				oper_expr = new UserOperatorCall (oper_method, args, CreateExpressionTree, loc);
 			}
 
 			if (!llifted)
 				this.left = larg.Expr;
 
 			if (!rlifted)
 				this.right = rarg.Expr;
 
 			return oper_expr;
 		}
 
 		//
 		// Merge two sets of user operators into one, they are mostly distinguish
 		// expect when they share base type and it contains an operator
 		//
 		static IList<MemberSpec> CombineUserOperators (IList<MemberSpec> left, IList<MemberSpec> right)
 		{
 			var combined = new List<MemberSpec> (left.Count + right.Count);
 			combined.AddRange (left);
 			foreach (var r in right) {
 				bool same = false;
 				foreach (var l in left) {
 					if (l.DeclaringType == r.DeclaringType) {
 						same = true;
 						break;
 					}
 				}
 
 				if (!same)
 					combined.Add (r);
 			}
 
 			return combined;
 		}
 
 		public override TypeExpr ResolveAsTypeTerminal (IMemberContext ec, bool silent)
 		{
 			return null;
 		}
 
 		private void CheckUselessComparison (ResolveContext ec, Constant c, TypeSpec type)
 		{
 			if (c == null || !IsTypeIntegral (type)
 				|| c is StringConstant
 				|| c is BoolConstant
 				|| c is FloatConstant
 				|| c is DoubleConstant
 				|| c is DecimalConstant
 				)
 				return;
 
 			long value = 0;
 
 			if (c is ULongConstant) {
 				ulong uvalue = ((ULongConstant) c).Value;
 				if (uvalue > long.MaxValue) {
 					if (type == TypeManager.byte_type ||
 					    type == TypeManager.sbyte_type ||
 					    type == TypeManager.short_type ||
 					    type == TypeManager.ushort_type ||
 					    type == TypeManager.int32_type ||
 					    type == TypeManager.uint32_type ||
 					    type == TypeManager.int64_type ||
 						type == TypeManager.char_type)
 						WarnUselessComparison (ec, type);
 					return;
 				}
 				value = (long) uvalue;
 			}
 			else if (c is ByteConstant)
 				value = ((ByteConstant) c).Value;
 			else if (c is SByteConstant)
 				value = ((SByteConstant) c).Value;
 			else if (c is ShortConstant)
 				value = ((ShortConstant) c).Value;
 			else if (c is UShortConstant)
 				value = ((UShortConstant) c).Value;
 			else if (c is IntConstant)
 				value = ((IntConstant) c).Value;
 			else if (c is UIntConstant)
 				value = ((UIntConstant) c).Value;
 			else if (c is LongConstant)
 				value = ((LongConstant) c).Value;
 			else if (c is CharConstant)
 				value = ((CharConstant)c).Value;
 
 			if (value == 0)
 				return;
 
 			if (IsValueOutOfRange (value, type))
 				WarnUselessComparison (ec, type);
 		}
 
 		static bool IsValueOutOfRange (long value, TypeSpec type)
 		{
 			if (IsTypeUnsigned (type) && value < 0)
 				return true;
 			return type == TypeManager.sbyte_type && (value >= 0x80 || value < -0x80) ||
 				type == TypeManager.byte_type && value >= 0x100 ||
 				type == TypeManager.short_type && (value >= 0x8000 || value < -0x8000) ||
 				type == TypeManager.ushort_type && value >= 0x10000 ||
 				type == TypeManager.int32_type && (value >= 0x80000000 || value < -0x80000000) ||
 				type == TypeManager.uint32_type && value >= 0x100000000;
 		}
 
 		private static bool IsTypeIntegral (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.int64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.int32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.short_type ||
 				type == TypeManager.sbyte_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
 
 		private static bool IsTypeUnsigned (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
 
 		private void WarnUselessComparison (ResolveContext ec, TypeSpec type)
 		{
 			ec.Report.Warning (652, 2, loc, "A comparison between a constant and a variable is useless. The constant is out of the range of the variable type `{0}'",
 				TypeManager.CSharpName (type));
 		}
 
 		/// <remarks>
 		///   EmitBranchable is called from Statement.EmitBoolExpression in the
 		///   context of a conditional bool expression.  This function will return
 		///   false if it is was possible to use EmitBranchable, or true if it was.
 		///
 		///   The expression's code is generated, and we will generate a branch to `target'
 		///   if the resulting expression value is equal to isTrue
 		/// </remarks>
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			//
 			// This is more complicated than it looks, but its just to avoid
 			// duplicated tests
 			// but on top of that we want for == and != to use a special path
 			// if we are comparing against null
 			//
 			if ((oper & Operator.EqualityMask) != 0 && (left is Constant || right is Constant)) {
 				bool my_on_true = oper == Operator.Inequality ? on_true 
 				
 				//
 				// put the constant on the rhs, for simplicity
 				//
 				if (left is Constant) {
 					Expression swap = right;
 					right = left;
 					left = swap;
 				}
 				
 				//
 				// brtrue/brfalse works with native int only
 				//
 				if (((Constant) right).IsZeroInteger && right.Type != TypeManager.int64_type && right.Type != TypeManager.uint64_type) {
 					left.EmitBranchable (ec, target, my_on_true);
 					return;
 				}
 				if (right.Type == TypeManager.bool_type) {
 					// right is a boolean, and it's not 'false' => it is 'true'
 					left.EmitBranchable (ec, target, !my_on_true);
 					return;
 				}
 
 			} else if (oper == Operator.LogicalAnd) {
 
 				if (on_true) {
 					Label tests_end = ec.DefineLabel ();
 					
 					left.EmitBranchable (ec, tests_end, false);
 					right.EmitBranchable (ec, target, true);
 					ec.MarkLabel (tests_end);					
 				} else {
 					//
 					// This optimizes code like this 
 					// if (true && i > 4)
 					//
 					if (!(left is Constant))
 						left.EmitBranchable (ec, target, false);
 
 					if (!(right is Constant)) 
 						right.EmitBranchable (ec, target, false);
 				}
 				
 				return;
 				
 			} else if (oper == Operator.LogicalOr){
 				if (on_true) {
 					left.EmitBranchable (ec, target, true);
 					right.EmitBranchable (ec, target, true);
 					
 				} else {
 					Label tests_end = ec.DefineLabel ();
 					left.EmitBranchable (ec, tests_end, true);
 					right.EmitBranchable (ec, target, false);
 					ec.MarkLabel (tests_end);
 				}
 				
 				return;
 
 			} else if ((oper & Operator.ComparisonMask) == 0) {
 				base.EmitBranchable (ec, target, on_true);
 				return;
 			}
 			
 			left.Emit (ec);
 			right.Emit (ec);
 
 			TypeSpec t = left.Type;
 			bool is_float = IsFloat (t);
 			bool is_unsigned = is_float || IsUnsigned (t);
 			
 			switch (oper){
 			case Operator.Equality
 				if (on_true)
 					ec.Emit (OpCodes.Beq, target);
 				else
 					ec.Emit (OpCodes.Bne_Un, target);
 				break;
 
 			case Operator.Inequality
 				if (on_true)
 					ec.Emit (OpCodes.Bne_Un, target);
 				else
 					ec.Emit (OpCodes.Beq, target);
 				break;
 
 			case Operator.LessThan
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Blt_Un, target);
 					else
 						ec.Emit (OpCodes.Blt, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Bge_Un, target);
 					else
 						ec.Emit (OpCodes.Bge, target);
 				break;
 
 			case Operator.GreaterThan
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Bgt_Un, target);
 					else
 						ec.Emit (OpCodes.Bgt, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Ble_Un, target);
 					else
 						ec.Emit (OpCodes.Ble, target);
 				break;
 
 			case Operator.LessThanOrEqual
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Ble_Un, target);
 					else
 						ec.Emit (OpCodes.Ble, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Bgt_Un, target);
 					else
 						ec.Emit (OpCodes.Bgt, target);
 				break;
 
 
 			case Operator.GreaterThanOrEqual
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Bge_Un, target);
 					else
 						ec.Emit (OpCodes.Bge, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Blt_Un, target);
 					else
 						ec.Emit (OpCodes.Blt, target);
 				break;
 			default
 				throw new InternalErrorException (oper.ToString ());
 			}
 		}
 		
 		public override void Emit (EmitContext ec)
 		{
 			EmitOperator (ec, left.Type);
 		}
 
 		protected virtual void EmitOperator (EmitContext ec, TypeSpec l)
 		{
 			//
 			// Handle short-circuit operators differently
 			// than the rest
 			//
 			if ((oper & Operator.LogicalMask) != 0) {
 				Label load_result = ec.DefineLabel ();
 				Label end = ec.DefineLabel ();
 
 				bool is_or = oper == Operator.LogicalOr;
 				left.EmitBranchable (ec, load_result, is_or);
 				right.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end);
 				
 				ec.MarkLabel (load_result);
 				ec.Emit (is_or ? OpCodes.Ldc_I4_1 
 				ec.MarkLabel (end);
 				return;
 			}
 
 			//
 			// Optimize zero-based operations which cannot be optimized at expression level
 			//
 			if (oper == Operator.Subtraction) {
 				var lc = left as IntegralConstant;
 				if (lc != null && lc.IsDefaultValue) {
 					right.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 					return;
 				}
 			}
 
 			left.Emit (ec);
 			right.Emit (ec);
 			EmitOperatorOpcode (ec, oper, l);
 
 			//
 			// Nullable enum could require underlying type cast and we cannot simply wrap binary
 			// expression because that would wrap lifted binary operation
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			if ((oper & Operator.LogicalMask) != 0 ||
 				(ec.HasSet (EmitContext.Options.CheckedScope) && (oper == Operator.Multiply || oper == Operator.Addition || oper == Operator.Subtraction))) {
 				base.EmitSideEffect (ec);
 			} else {
 				left.EmitSideEffect (ec);
 				right.EmitSideEffect (ec);
 			}
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Binary target = (Binary) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			MemberAccess sle = new MemberAccess (new MemberAccess (
 				new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Linq", loc), "Expressions", loc);
 
 			CSharpBinderFlags flags = 0;
 			if (ec.HasSet (ResolveContext.Options.CheckedScope))
 				flags = CSharpBinderFlags.CheckedContext;
 
 			if ((oper & Operator.LogicalMask) != 0)
 				flags |= CSharpBinderFlags.BinaryOperationLogical;
 
 			binder_args.Add (new Argument (new EnumConstant (new IntLiteral ((int) flags, loc), ec.Module.PredefinedTypes.BinderFlags.Resolve (loc))));
 			binder_args.Add (new Argument (new MemberAccess (new MemberAccess (sle, "ExpressionType", loc), GetOperatorExpressionTypeName (), loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));									
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			return new Invocation (new MemberAccess (new TypeExpression (ec.Module.PredefinedTypes.Binder.TypeSpec, loc), "BinaryOperation", loc), binder_args);
 		}
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return CreateExpressionTree (ec, null);
 		}
 
 		Expression CreateExpressionTree (ResolveContext ec, Expression method)		
 		{
 			string method_name;
 			bool lift_arg = false;
 			
 			switch (oper) {
 			case Operator.Addition
 				if (method == null && ec.HasSet (ResolveContext.Options.CheckedScope) && !IsFloat (type))
 					method_name = "AddChecked";
 				else
 					method_name = "Add";
 				break;
 			case Operator.BitwiseAnd
 				method_name = "And";
 				break;
 			case Operator.BitwiseOr
 				method_name = "Or";
 				break;
 			case Operator.Division
 				method_name = "Divide";
 				break;
 			case Operator.Equality
 				method_name = "Equal";
 				lift_arg = true;
 				break;
 			case Operator.ExclusiveOr
 				method_name = "ExclusiveOr";
 				break;				
 			case Operator.GreaterThan
 				method_name = "GreaterThan";
 				lift_arg = true;
 				break;
 			case Operator.GreaterThanOrEqual
 				method_name = "GreaterThanOrEqual";
 				lift_arg = true;
 				break;
 			case Operator.Inequality
 				method_name = "NotEqual";
 				lift_arg = true;
 				break;
 			case Operator.LeftShift
 				method_name = "LeftShift";
 				break;
 			case Operator.LessThan
 				method_name = "LessThan";
 				lift_arg = true;
 				break;
 			case Operator.LessThanOrEqual
 				method_name = "LessThanOrEqual";
 				lift_arg = true;
 				break;
 			case Operator.LogicalAnd
 				method_name = "AndAlso";
 				break;
 			case Operator.LogicalOr
 				method_name = "OrElse";
 				break;
 			case Operator.Modulus
 				method_name = "Modulo";
 				break;
 			case Operator.Multiply
 				if (method == null && ec.HasSet (ResolveContext.Options.CheckedScope) && !IsFloat (type))
 					method_name = "MultiplyChecked";
 				else
 					method_name = "Multiply";
 				break;
 			case Operator.RightShift
 				method_name = "RightShift";
 				break;
 			case Operator.Subtraction
 				if (method == null && ec.HasSet (ResolveContext.Options.CheckedScope) && !IsFloat (type))
 					method_name = "SubtractChecked";
 				else
 					method_name = "Subtract";
 				break;
 
 			default
 				throw new InternalErrorException ("Unknown expression tree binary operator " + oper);
 			}
 
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (left.CreateExpressionTree (ec)));
 			args.Add (new Argument (right.CreateExpressionTree (ec)));
 			if (method != null) {
 				if (lift_arg)
 					args.Add (new Argument (new BoolLiteral (false, loc)));
 
 				args.Add (new Argument (method));
 			}
 			
 			return CreateExpressionFactoryCall (ec, method_name, args);
 		}
 	}
 	
 	//
 	// Represents the operation a + b [+ c [+ d [+ ...]]], where a is a string
 	// b, c, d... may be strings or objects.
 	//
 	public class StringConcat 
 		Arguments arguments;
 		static IList<MemberSpec> concat_members;
 		
 		public StringConcat (Expression left, Expression right, Location loc)
 		{
 			this.loc = loc;
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 
 			arguments = new Arguments (2);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="73" endline="81">
<![CDATA[
 
     Shadows Sub Init(ByVal Condition As Expression, ByVal FalseCode As CodeBlock, ByVal TrueCode As CodeBlock, ByVal OneLiner As Boolean, ByVal ElseIfs As BaseObjects(Of ElseIfStatement))
         MyBase.Init(TrueCode)
 
         m_Condition = Condition
         m_FalseCode = FalseCode
         m_ElseIfs = ElseIfs
         m_OneLiner = OneLiner
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="123" endline="129">
<![CDATA[
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1330" endline="1347">
<![CDATA[
 	}
 
 	public struct NamespaceEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly string Name;
 		public readonly int Index;
 		public readonly int Parent;
 		public readonly string[] UsingClauses;
 		#endregion
 
 		public NamespaceEntry (string name, int index, string[] using_clauses, int parent)
 		{
 			this.Name = name;
 			this.Index = index;
 			this.Parent = parent;
 			this.UsingClauses = using_clauses != null ? using_clauses 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="91" endline="118">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This is an arbitrarily seekable StreamReader wrapper.
 	///
 	///   It uses a self-tuning buffer to cache the seekable data,
 	///   but if the seek is too far, it may read the underly
 	///   stream all over from the beginning.
 	/// </summary>
 	public class SeekableStreamReader 
 	{
 		StreamReader reader;
 		Stream stream;
 
 		static char[] buffer;
 		int read_ahead_length;	// the length of read buffer
 		int buffer_start;       // in chars
 		int char_count;         // count of filled characters in buffer[]
 		int pos;                // index into buffer[]
 
 		public SeekableStreamReader (Stream stream, Encoding encoding)
 		{
 			this.stream = stream;
 
 			const int default_read_ahead = 2048;
 			InitializeStream (default_read_ahead);
 			reader = new StreamReader (stream, encoding, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="83" endline="94">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new define with the specified values.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Symbol As String, ByVal Value As String)
         Me.m_Symbol = Symbol
         Me.m_Value = Value
         Me.m_Compiler = Compiler
 
         Parse()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="109" endline="118">
<![CDATA[
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages(), ByVal Parameters()() As String, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = Message
         Me.m_Location = Location
         Me.m_Parameters = Parameters
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="585" endline="598">
<![CDATA[
 			}
 		}
 
 		readonly string full_name;
 		readonly Module module;
 		Dictionary<string, MetaType> types;
 
 		public MissingAssembly (Universe universe, string fullName)
 			
 		{
 			this.full_name = fullName;
 			this.module = new MissingModule (universe, this);
 			types = new Dictionary<string, MetaType> ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="459" endline="736">
<![CDATA[
 	}
 
 	public abstract class MethodOrOperator 
 	{
 		public MethodBuilder MethodBuilder;
 		ReturnParameter return_attributes;
 		SecurityType declarative_security;
 		protected MethodData MethodData;
 
 		static string[] attribute_targets = new string [] { "method", "return" };
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Method; 
 			}
 		}
 
 		protected override bool CheckForDuplications ()
 		{
 			return Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 		}
 
 		public virtual EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, MemberType);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
 
 		public bool IsPartialDefinition {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block == null;
 			}
 		}
 
 		public bool IsPartialImplementation {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block != null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#region IMethodData Members
 
 		public TypeSpec ReturnType {
 			get {
 				return MemberType;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return GenericMethod;
 			}
 		}
 
 		public virtual void EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 
 		#endregion
 
 	}
 
 	public class SourceMethod 
 	{
 		MethodBase method;
 		SourceMethodBuilder builder;
 
 		protected SourceMethod (DeclSpace parent, MethodBase method, ICompileUnit file)
 		{
 			this.method = method;
 			
 			builder = SymbolWriter.OpenMethod (file, parent.NamespaceEntry.SymbolFileID, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="169" endline="176">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Property] As Mono.Cecil.PropertyReference, ByVal InstanceExpression As Expression, ByVal Parameters As ArgumentList)
         MyBase.New(Classifications.PropertyAccess, Parent)
         m_Property = [Property]
         m_InstanceExpression = InstanceExpression
         m_Parameters = Parameters
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="84" endline="98">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="InstanceExpression">May be Nothing</param>
     ''' <param name="TypeArguments">May be Nothing</param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Name As String)
         MyBase.New(Classifications.LateBoundAccess, Parent)
         m_InstanceExpression = InstanceExpression
         m_Name = Name
         m_TypeArguments = TypeArguments
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="75" endline="81">
<![CDATA[
 		{
 			Name = name;
 			Kind = kind;
 			Parameters = null;
 			MemberType = null;
 			arity = -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1311" endline="1323">
<![CDATA[
 	}
 
 	/// <summary>
 	///   A TypeExpr which already resolved to a type parameter.
 	/// </summary>
 	public class TypeParameterExpr 
 		
 		public TypeParameterExpr (TypeParameter type_parameter, Location loc)
 		{
 			this.type = type_parameter.Type;
 			this.eclass = ExprClass.TypeParameter;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="58" endline="65">
<![CDATA[
 
     Shadows Sub Init(ByVal Variable As Identifier, ByVal TypeName As NonArrayTypeName, ByVal [When] As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_Variable = Variable
         m_TypeName = TypeName
         m_When = [When]
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="60" endline="67">
<![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal InExpression As Expression, ByVal NextExpression As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_InExpression = InExpression
         m_NextExpression = NextExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="66" endline="73">
<![CDATA[
 
     Shadows Sub Init(ByVal PreCondition As Expression, ByVal PostCondition As Expression, ByVal IsWhile As Boolean, ByVal Code As CodeBlock)
         MyBase.Init(Code)
 
         m_PreCondition = PreCondition
         m_PostCondition = PostCondition
         m_IsWhile = IsWhile
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="28" endline="34">
<![CDATA[
 		public NullableType (TypeExpr underlying, Location l)
 		{
 			this.underlying = underlying;
 			loc = l;
 
 			eclass = ExprClass.Type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" startline="50" endline="61">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Initializing constructor.
     ''' </summary>
     ''' <param name="LeftSide"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, Optional ByVal LeftSide As Boolean = False, Optional ByVal IsInTypeOf As Boolean = False)
         m_IsLeftSide = LeftSide
         m_IsInTypeOf = IsInTypeOf
         m_Parent = Parent
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="117" endline="123">
<![CDATA[
 
     Sub Init(ByVal IsAssembly As Boolean, ByVal IsModule As Boolean, ByVal SimpleTypeName As SimpleTypeName, ByVal AttributeArguments As AttributeArguments)
         m_IsAssembly = IsAssembly
         m_IsModule = IsModule
         m_SimpleTypeName = SimpleTypeName
         m_AttributeArguments = AttributeArguments
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resource.vb" startline="64" endline="73">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a new resource with the specified values.
     ''' </summary>
     Sub New(ByVal Filename As String, ByVal Identifier As String, Optional ByVal [Public] As Boolean = True)
         Me.m_Filename = Filename
         Me.m_Identifier = Identifier
         Me.m_Public = [Public]
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="37" endline="43">
<![CDATA[
 
     Sub Init(ByVal Target As Expression, ByVal Start As Expression, ByVal Length As Expression, ByVal Source As Expression)
         m_Target = Target
         m_Start = Start
         m_Length = Length
         m_Source = Source
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="57" endline="82">
<![CDATA[
 	}
 
 	#region Dynamic runtime binder expressions
 
 	//
 	// Expression created from runtime dynamic object value by dynamic binder
 	//
 	public class RuntimeValueExpression 
 	{
 #if !NET_4_0
 		public class DynamicMetaObject
 		{
 			public TypeSpec RuntimeType;
 			public TypeSpec LimitType;
 			public SLE.Expression Expression;
 		}
 #endif
 
 		readonly DynamicMetaObject obj;
 
 		public RuntimeValueExpression (DynamicMetaObject obj, TypeSpec type)
 		{
 			this.obj = obj;
 			this.type = type;
 			this.eclass = ExprClass.Variable;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="45" endline="51">
<![CDATA[
 		public DynamicTypeExpr (Location loc)
 		{
 			this.loc = loc;
 
 			type = InternalType.Dynamic;
 			eclass = ExprClass.Type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="76" endline="82">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier, ByVal TypeName As TypeName, ByVal Expression As Expression)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
         m_TypeName = TypeName
         m_Expression = Expression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="81" endline="94">
<![CDATA[
 End Class
 
 Public Class LoadElementExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     Private m_Index As Integer
 
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition, ByVal Index As Integer)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
         m_Index = Index
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="39" endline="45">
<![CDATA[
 		internal AssemblyReader(string location, ModuleReader manifestModule)
 			
 		{
 			this.location = location;
 			this.manifestModule = manifestModule;
 			externalModules = new Module[manifestModule.File.records.Length];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="319" endline="337">
<![CDATA[
 	}
 
 	//
 	// A type parameter for a generic type or generic method definition
 	//
 	public class TypeParameter 
 	{
 		static readonly string[] attribute_target = new string [] { "type parameter" };
 		
 		Constraints constraints;
 		GenericTypeParameterBuilder builder;
 		TypeParameterSpec spec;
 
 		public TypeParameter (DeclSpace parent, int index, MemberName name, Constraints constraints, Attributes attrs, Variance variance)
 			
 		{
 			this.constraints = constraints;
 			this.spec = new TypeParameterSpec (null, index, this, SpecialConstraint.None, variance, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1370" endline="1405">
<![CDATA[
 	}
 	
 	public class Constructor 
 		public ConstructorBuilder ConstructorBuilder;
 		public ConstructorInitializer Initializer;
 		SecurityType declarative_security;
 		bool has_compliant_args;
 
 		// <summary>
 		//   Modifiers allowed for a constructor.
 		// </summary>
 		public const Modifiers AllowedModifiers =
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.STATIC |
 			Modifiers.UNSAFE |
 			Modifiers.EXTERN |		
 			Modifiers.PRIVATE;
 
 		static readonly string[] attribute_targets = new string [] { "method" };
 
 		public static readonly string ConstructorName = ".ctor";
 		public static readonly string TypeConstructorName = ".cctor";
 
 		//
 		// The spec claims that static is not permitted, but
 		// my very own code has static constructors.
 		//
 		public Constructor (DeclSpace parent, string name, Modifiers mod, Attributes attrs, ParametersCompiled args,
 				    ConstructorInitializer init, Location loc)
 			
 				new MemberName (name, loc), attrs, args)
 		{
 			Initializer = init;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="48" endline="55">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_ReturnType = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="56" endline="63">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="64" endline="71">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="31" endline="37">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal CodeGenerator As GenerateCodeDelegate, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         m_Delegate = CodeGenerator
         m_ExpressionType = ExpressionType
         MyBase.Classification = New ValueClassification(Me)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2637" endline="2645">
<![CDATA[
 
 		public ToplevelBlock (CompilerContext ctx, ParametersCompiled parameters, Location start)
 			
 		{
 			this.compiler = ctx;
 			top_block = this;
 
 			ProcessParameters ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9587" endline="9602">
<![CDATA[
 	}
 
 	public class NewAnonymousType 
 	{
 		static readonly AnonymousTypeParameter[] EmptyParameters = new AnonymousTypeParameter[0];
 
 		List<AnonymousTypeParameter> parameters;
 		readonly TypeContainer parent;
 		AnonymousTypeClass anonymous_type;
 
 		public NewAnonymousType (List<AnonymousTypeParameter> parameters, TypeContainer parent, Location loc)
 			 
 		{
 			this.parameters = parameters;
 			this.parent = parent;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="413" endline="420">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal variable As VariableDeclaration, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.New(Classifications.Variable, Parent)
         m_Variable = variable
         m_LocalVariable = TryCast(m_Variable, LocalVariableDeclaration)
         m_TypeVariable = TryCast(m_Variable, TypeVariableDeclaration)
         m_InstanceExpression = InstanceExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="82" endline="90">
<![CDATA[
 
 		public MemberFilter (MethodSpec m)
 		{
 			Name = m.Name;
 			Kind = MemberKind.Method;
 			Parameters = m.Parameters;
 			MemberType = m.ReturnType;
 			arity = m.Arity;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4310" endline="4320">
<![CDATA[
 	}
 
 	public class Unsafe 
 		public Block Block;
 
 		public Unsafe (Block b, Location loc)
 		{
 			Block = b;
 			Block.Unsafe = true;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4280" endline="4290">
<![CDATA[
 	}
 
 	public class Checked 
 		public Block Block;
 		
 		public Checked (Block b, Location loc)
 		{
 			Block = b;
 			b.Unchecked = false;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4250" endline="4260">
<![CDATA[
 	}
 
 	public class Unchecked 
 		public Block Block;
 		
 		public Unchecked (Block b, Location loc)
 		{
 			Block = b;
 			b.Unchecked = true;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="44" endline="50">
<![CDATA[
 
     Sub Init(ByVal LSide As Expression, ByVal RSide As Expression)
         m_LSide = LSide
         m_RSide = RSide
         m_LSide.Parent = Me
         m_RSide.Parent = Me
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="349" endline="519">
<![CDATA[
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		//
 		// Explicit struct layout set by parent
 		//
 		public CharSet? CharSet {
 			get; set;
 		}		
 
 		#endregion
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ImplicitConversionRequired (rc, TypeManager.int32_type, Location);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsPrimitiveType (MemberType)) {
 				Report.Error (1663, Location,
 					"`{0}'
 					GetSignatureForError ());
 			} else if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Fields.IndexOf (this);
 				foreach (var d in declarators) {
 					var f = new FixedField (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					f.initializer = d.Initializer;
 					((ConstInitializer) f.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 			}
 			
 			// Create nested fixed buffer container
 			string name = String.Format ("<{0}>__FixedBuffer{1}", Name, GlobalCounter++);
 			fixed_buffer_type = Parent.TypeBuilder.DefineNestedType (name, Parent.Module.DefaultCharSetType |
 				TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit, TypeManager.value_type.GetMetaInfo ());
 
 			fixed_buffer_type.DefineField (FixedElementName, MemberType.GetMetaInfo (), FieldAttributes.Public);
 			
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, fixed_buffer_type, ModifiersExtensions.FieldAttr (ModFlags));
 			var element_spec = new FieldSpec (null, this, MemberType, FieldBuilder, ModFlags);
 			spec = new FixedFieldSpec (Parent.Definition, this, FieldBuilder, element_spec, ModFlags);
 
 			Parent.MemberCache.AddMember (spec);
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			if (!IsUnsafe)
 				Expression.UnsafeError (Report, Location);
 
 			if (Parent.PartialContainer.Kind != MemberKind.Struct) {
 				Report.Error (1642, Location, "`{0}'
 					GetSignatureForError ());
 			}
 		}
 
 		public override void Emit()
 		{
 			ResolveContext rc = new ResolveContext (this);
 			IntConstant buffer_size_const = initializer.Resolve (rc) as IntConstant;
 			if (buffer_size_const == null)
 				return;
 
 			int buffer_size = buffer_size_const.Value;
 
 			if (buffer_size <= 0) {
 				Report.Error (1665, Location, "`{0}'
 				return;
 			}
 
 			int type_size = Expression.GetTypeSize (MemberType);
 
 			if (buffer_size > int.MaxValue / type_size) {
 				Report.Error (1664, Location, "Fixed size buffer `{0}' of length `{1}' and type `{2}' exceeded 2^31 limit",
 					GetSignatureForError (), buffer_size.ToString (), TypeManager.CSharpName (MemberType));
 				return;
 			}
 
 			EmitFieldSize (buffer_size);
 
 			Module.PredefinedAttributes.UnsafeValueType.EmitAttribute (fixed_buffer_type);
 			Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (fixed_buffer_type);
 			fixed_buffer_type.CreateType ();
 
 			base.Emit ();
 		}
 
 		void EmitFieldSize (int buffer_size)
 		{
 			PredefinedAttribute pa;
 			AttributeEncoder encoder;
 
 			pa = Module.PredefinedAttributes.StructLayout;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.short_type))
 				return;
 
 			var char_set_type = Module.PredefinedTypes.CharSet.Resolve (Location);
 			if (char_set_type == null)
 				return;
 
 			var field_size = pa.GetField ("Size", TypeManager.int32_type, Location);
 			var field_charset = pa.GetField ("CharSet", char_set_type, Location);
 			if (field_size == null || field_charset == null)
 				return;
 
 			var char_set = CharSet ?? Module.DefaultCharSet;
 
 			encoder = new AttributeEncoder ();
 			encoder.Encode ((short)LayoutKind.Sequential);
 			encoder.EncodeNamedArguments (
 				new [] { field_size, field_charset },
 				new Constant [] { new IntConstant (buffer_size, Location), new IntConstant ((int) char_set, Location) }
 			);
 
 			pa.EmitAttribute (fixed_buffer_type, encoder);
 
 			//
 			// Don't emit FixedBufferAttribute attribute for private types
 			//
 			if ((ModFlags & Modifiers.PRIVATE) != 0)
 				return;
 
 			pa = Module.PredefinedAttributes.FixedBuffer;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.type_type, TypeManager.int32_type))
 				return;
 
 			encoder = new AttributeEncoder ();
 			encoder.EncodeTypeName (MemberType);
 			encoder.Encode (buffer_size);
 			encoder.EncodeEmptyNamedArguments ();
 
 			pa.EmitAttribute (FieldBuilder, encoder);
 		}
 	}
 
 	class FixedFieldSpec 
 	{
 		readonly FieldSpec element;
 
 		public FixedFieldSpec (TypeSpec declaringType, IMemberDefinition definition, FieldInfo info, FieldSpec element, Modifiers modifiers)
 			
 		{
 			this.element = element;
 
 			// It's never CLS-Compliant
 			state &= ~StateFlags.CLSCompliant_Undetected;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9707" endline="9713">
<![CDATA[
 		
 		public AnonymousTypeParameter (Parameter parameter)
 			
 		{
 			this.Name = parameter.Name;
 			this.loc = parameter.Location;
 		}		
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5986" endline="6030">
<![CDATA[
 		}
 	}
 
 	/// <summary>
 	///   14.5.10.2
 	/// </summary>
 	///
 	/// <remarks>
 	///   There are two possible scenarios here
 	///   expression that specifies the dimensions and optionally the
 	///   initialization data and the other which does not need dimensions
 	///   specified but where initialization data is mandatory.
 	/// </remarks>
 	public class ArrayCreation 
 	{
 		FullNamedExpression requested_base_type;
 		ArrayInitializer initializers;
 
 		//
 		// The list of Argument types.
 		// This is used to construct the `newarray' or constructor signature
 		//
 		protected List<Expression> arguments;
 		
 		protected TypeSpec array_element_type;
 		int num_arguments = 0;
 		protected int dimensions;
 		protected readonly ComposedTypeSpecifier rank;
 		Expression first_emit;
 		LocalTemporary first_emit_temp;
 
 		protected List<Expression> array_data;
 
 		Dictionary<int, int> bounds;
 
 		// The number of constants in array initializers
 		int const_initializers_count;
 		bool only_constant_initializers;
 
 		public ArrayCreation (FullNamedExpression requested_base_type, List<Expression> exprs, ComposedTypeSpecifier rank, ArrayInitializer initializers, Location l)
 			
 		{
 			arguments = new List<Expression> (exprs);
 			num_arguments = arguments.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1349" endline="1355">
<![CDATA[
 
 		public VariableInfo (LocalVariable local_info, int offset)
 			
 		{
 			this.LocalInfo = local_info;
 			this.IsParameter = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2646" endline="2658">
<![CDATA[
 
 		//
 		// Recreates a top level block from parameters block. Used for
 		// compiler generated methods where the original block comes from
 		// explicit child block. This works for already resolved blocks
 		// only to ensure we resolve them in the correct flow order
 		//
 		public ToplevelBlock (ParametersBlock source, ParametersCompiled parameters)
 			
 		{
 			this.compiler = source.TopBlock.compiler;
 			top_block = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="96" endline="110">
<![CDATA[
 
 	}
 
 	public class PropertySpec 
 	{
 		PropertyInfo info;
 		TypeSpec memberType;
 		MethodSpec set, get;
 
 		public PropertySpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, PropertyInfo info, Modifiers modifiers)
 			
 		{
 			this.info = info;
 			this.memberType = memberType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="63" endline="276">
<![CDATA[
 
 		protected FieldBase (DeclSpace parent, FullNamedExpression type, Modifiers mod,
 				     Modifiers allowed_mod, MemberName name, Attributes attrs)
 			
 				name, attrs)
 		{
 			if ((mod & Modifiers.ABSTRACT) != 0)
 				Report.Error (681, Location, "The modifier 'abstract' is not valid on fields. Try using a property instead");
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Field;
 			}
 		}
 
 		public Expression Initializer {
 			get {
 				return initializer;
 			}
 			set {
 				this.initializer = value;
 			}
 		}
 
 		public FieldSpec Spec {
 			get {
 				return spec;
 			}
 		}
 
 		public override string[] ValidAttributeTargets  {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.FieldOffset) {
 				status |= Status.HAS_OFFSET;
 
 				if (!Parent.PartialContainer.HasExplicitLayout) {
 					Report.Error (636, Location, "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)");
 					return;
 				}
 
 				if ((ModFlags & Modifiers.STATIC) != 0 || this is Const) {
 					Report.Error (637, Location, "The FieldOffset attribute is not allowed on static or const fields");
 					return;
 				}
 			}
 
 			if (a.Type == pa.FixedBuffer) {
 				Report.Error (1716, Location, "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead");
 				return;
 			}
 
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					FieldBuilder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public void SetCustomAttribute (MethodSpec ctor, byte[] data)
 		{
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), data);
 		}
 
  		protected override bool CheckBase ()
 		{
  			if (!base.CheckBase ())
  				return false;
 
 			MemberSpec candidate;
 			var conflict_symbol = MemberCache.FindBaseMember (this, out candidate);
 			if (conflict_symbol == null)
 				conflict_symbol = candidate;
 
  			if (conflict_symbol == null) {
  				if ((ModFlags & Modifiers.NEW) != 0) {
  					Report.Warning (109, 4, Location, "The member `{0}' does not hide an inherited member. The new keyword is not required",
 						GetSignatureForError ());
  				}
  			} else {
 				if ((ModFlags & (Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.BACKING_FIELD)) == 0) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Warning (108, 2, Location, "`{0}' hides inherited member `{1}'. Use the new keyword if hiding was intended",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 
 				if (conflict_symbol.IsAbstract) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Error (533, Location, "`{0}' hides inherited abstract member `{1}'",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 			}
  
  			return true;
  		}
 
 		public virtual Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ConvertImplicitly (rc, MemberType);
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsGenericParameter)
 				return;
 
 			if (MemberType.IsStatic)
 				Error_VariableOfStaticClass (Location, GetSignatureForError (), MemberType, Report);
 
 			CheckBase ();
 			IsTypePermitted ();
 		}
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { return "F
 		}
 
 		public override void Emit ()
 		{
 			if (member_type == InternalType.Dynamic) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder);
 			} else if (!(Parent is CompilerGeneratedClass) && member_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder, member_type, Location);
 			}
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (FieldBuilder);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			if (((status & Status.HAS_OFFSET) == 0) && (ModFlags & (Modifiers.STATIC | Modifiers.BACKING_FIELD)) == 0 && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (625, Location, "`{0}'
 			}
 
 			base.Emit ();
 		}
 
 		public static void Error_VariableOfStaticClass (Location loc, string variable_name, TypeSpec static_class, Report Report)
 		{
 			Report.SymbolRelatedToPreviousError (static_class);
 			Report.Error (723, loc, "`{0}'
 				variable_name);
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant () || this is FixedField) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
 	}
 
 	//
 	// Field specification
 	//
 	public class FieldSpec 
 	{
 		FieldInfo metaInfo;
 		TypeSpec memberType;
 
 		public FieldSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, FieldInfo info, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.memberType = memberType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4125" endline="4139">
<![CDATA[
 	}
 
 	//
 	// User-defined conditional logical operator
 	//
 	public class ConditionalLogicalOperator 
 		readonly bool is_and;
 		Expression oper_expr;
 
 		public ConditionalLogicalOperator (MethodSpec oper, Arguments arguments, Func<ResolveContext, Expression, Expression> expr_tree, bool is_and, Location loc)
 			
 		{
 			this.is_and = is_and;
 			eclass = ExprClass.Unresolved;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="736" endline="828">
<![CDATA[
 	}
 
 	//
 	// Any member binder which can be source and target of assignment
 	//
 	abstract class DynamicMemberAssignable 
 	{
 		Expression setter;
 		Arguments setter_args;
 
 		protected DynamicMemberAssignable (Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			//
 			// DoResolve always uses getter
 			//
 			return CreateCallSiteBinder (ec, args, false);
 		}
 
 		protected abstract Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet);
 
 		protected virtual Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			var setter_args = new Arguments (Arguments.Count + 1);
 			setter_args.AddRange (Arguments);
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				right_side.DoResolveLValue (rc, this);
 				return null;
 			}
 
 			if (DoResolveCore (rc)) {
 				setter_args = CreateSetterArguments (rc, right_side);
 				setter = CreateCallSiteBinder (rc, setter_args, true);
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, false);
 			else
 				base.Emit (ec);
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, true);
 			else
 				base.EmitStatement (ec);
 		}
 
 		#region IAssignMethod Members
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			EmitCall (ec, setter, setter_args, !leave_copy);
 		}
 
 		#endregion
 	}
 
 	class DynamicUnaryConversion 
 	{
 		readonly string name;
 
 		public DynamicUnaryConversion (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="624" endline="635">
<![CDATA[
 	}
 
 	class DynamicInvocation 
 	{
 		ATypeNameExpression member;
 
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 			this.member = member;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="591" endline="603">
<![CDATA[
 		}
 
 		// Used for underlying binary operator
 		readonly Binary.Operator op;
 		Expression right;
 		Expression left;
 
 		public CompoundAssign (Binary.Operator op, Expression target, Expression source, Location loc)
 			
 		{
 			right = source;
 			this.op = op;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="537" endline="546">
<![CDATA[
 	}
 
 	class DynamicConstructorBinder 
 	{
 		public DynamicConstructorBinder (TypeSpec type, Arguments args, Location loc)
 			
 		{
 			this.type = type;
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1402" endline="1409">
<![CDATA[
 		public AnonymousMethodBody (ParametersCompiled parameters,
 					ParametersBlock block, TypeSpec return_type, TypeSpec delegate_type,
 					Location loc)
 			
 		{
 			this.type = delegate_type;
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1796" endline="1802">
<![CDATA[
 
 		public TypeParameterName (string name, Attributes attrs, Variance variance, Location loc)
 			
 		{
 			attributes = attrs;
 			this.variance = variance;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="174" endline="180">
<![CDATA[
 
 		public NamedArgument (string name, Location loc, Expression expr, AType modifier)
 			
 		{
 			this.Name = name;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="694" endline="701">
<![CDATA[
 
 		public SourceFileEntry (MonoSymbolFile file, string file_name,
 					byte[] guid, byte[] checksum)
 			
 		{
 			this.guid = guid;
 			this.hash = checksum;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2458" endline="2534">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Represents a namespace or a type.  The name of the class was inspired by
 	///   section 10.8.1 (Fully Qualified Names).
 	/// </summary>
 	public abstract class FullNamedExpression 
 	{
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			// Do nothing, most unresolved type expressions cannot be
 			// resolved to different type
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			throw new NotSupportedException ("ET");
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new InternalErrorException ("FullNamedExpression `{0}' found in resolved tree",
 				GetSignatureForError ());
 		}
 	}
 	
 	/// <summary>
 	///   Expression that evaluates to a type
 	/// </summary>
 	public abstract class TypeExpr 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			TypeExpr t = DoResolveAsTypeStep (ec);
 			if (t == null)
 				return null;
 
 			eclass = ExprClass.Type;
 			return t;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return ResolveAsTypeTerminal (ec, false);
 		}
 
 		protected abstract TypeExpr DoResolveAsTypeStep (IMemberContext ec);
 
 		public override bool Equals (object obj)
 		{
 			TypeExpr tobj = obj as TypeExpr;
 			if (tobj == null)
 				return false;
 
 			return Type == tobj.Type;
 		}
 
 		public override int GetHashCode ()
 		{
 			return Type.GetHashCode ();
 		}
 	}
 
 	/// <summary>
 	///   Fully resolved Expression that already evaluated to a type
 	/// </summary>
 	public class TypeExpression 
 		public TypeExpression (TypeSpec t, Location l)
 		{
 			Type = t;
 			eclass = ExprClass.Type;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8697" endline="8703">
<![CDATA[
 
 		public EmptyExpression (TypeSpec t)
 		{
 			type = t;
 			eclass = ExprClass.Value;
 			loc = Location.Null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="52" endline="60">
<![CDATA[
 
     Sub Init(ByVal First As Expression, ByVal Second As IdentifierOrKeyword)
         m_First = First
         m_Second = Second
 
         m_Expression = New MemberAccessExpression(Me)
         m_Expression.Init(m_First, m_Second)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="248" endline="868">
<![CDATA[
 			new char [] {' ', '\t', '\n', '\r'};
 
 		//
 		// returns a full runtime type name from a name which might
 		// be C# specific type name.
 		//
 		private static TypeSpec FindDocumentedType (MemberCore mc, string name, DeclSpace ds, string cref, Report r)
 		{
 			bool is_array = false;
 			string identifier = name;
 			if (name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				if (tmp [tmp.Length - 1] == '[') {
 					identifier = tmp.Substring (0, tmp.Length - 1).Trim (wsChars);
 					is_array = true;
 				}
 			}
 			TypeSpec t = FindDocumentedTypeNonArray (mc, identifier, ds, cref, r);
 			if (t != null && is_array)
 				t = ArrayContainer.MakeType (t);
 			return t;
 		}
 
 		private static TypeSpec FindDocumentedTypeNonArray (MemberCore mc, 
 			string identifier, DeclSpace ds, string cref, Report r)
 		{
 			switch (identifier) {
 			case "int"
 				return TypeManager.int32_type;
 			case "uint"
 				return TypeManager.uint32_type;
 			case "short"
 				return TypeManager.short_type;;
 			case "ushort"
 				return TypeManager.ushort_type;
 			case "long"
 				return TypeManager.int64_type;
 			case "ulong"
 				return TypeManager.uint64_type;;
 			case "float"
 				return TypeManager.float_type;;
 			case "double"
 				return TypeManager.double_type;
 			case "char"
 				return TypeManager.char_type;;
 			case "decimal"
 				return TypeManager.decimal_type;;
 			case "byte"
 				return TypeManager.byte_type;;
 			case "sbyte"
 				return TypeManager.sbyte_type;;
 			case "object"
 				return TypeManager.object_type;;
 			case "bool"
 				return TypeManager.bool_type;;
 			case "string"
 				return TypeManager.string_type;;
 			case "void"
 				return TypeManager.void_type;;
 			}
 			FullNamedExpression e = ds.LookupNamespaceOrType (identifier, 0, mc.Location, false);
 			if (e != null) {
 				if (!(e is TypeExpr))
 					return null;
 				return e.Type;
 			}
 			int index = identifier.LastIndexOf ('.');
 			if (index < 0)
 				return null;
 
 			var nsName = identifier.Substring (0, index);
 			var typeName = identifier.Substring (index + 1);
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (nsName, false);
 			ns = ns ?? mc.Module.GlobalRootNamespace.GetNamespace(nsName, false);
 			if (ns != null) {
 				var te = ns.LookupType(mc.Compiler, typeName, 0, true, mc.Location);
 				if(te != null)
 					return te.Type;
 			}
 
 			int warn;
 			TypeSpec parent = FindDocumentedType (mc, identifier.Substring (0, index), ds, cref, r);
 			if (parent == null)
 				return null;
 			// no need to detect warning 419 here
 			var ts = FindDocumentedMember (mc, parent,
 				identifier.Substring (index + 1),
 				null, ds, out warn, cref, false, null, r) as TypeSpec;
 			if (ts != null)
 				return ts;
 			return null;
 		}
 
 		//
 		// Returns a MemberInfo that is referenced in XML documentation
 		// (by "see" or "seealso" elements).
 		//
 		private static MemberSpec FindDocumentedMember (MemberCore mc,
 			TypeSpec type, string member_name, AParametersCollection param_list, 
 			DeclSpace ds, out int warning_type, string cref,
 			bool warn419, string name_for_error, Report r)
 		{
 //			for (; type != null; type = type.DeclaringType) {
 				var mi = FindDocumentedMemberNoNest (
 					mc, type, member_name, param_list, ds,
 					out warning_type, cref, warn419,
 					name_for_error, r);
 				if (mi != null)
 					return mi; // new FoundMember (type, mi);
 //			}
 			warning_type = 0;
 			return null;
 		}
 
 		private static MemberSpec FindDocumentedMemberNoNest (
 			MemberCore mc, TypeSpec type, string member_name,
 			AParametersCollection param_list, DeclSpace ds, out int warning_type, 
 			string cref, bool warn419, string name_for_error, Report Report)
 		{
 			warning_type = 0;
 //			var filter = new MemberFilter (member_name, 0, MemberKind.All, param_list, null);
 			IList<MemberSpec> found = null;
 			while (type != null && found == null) {
 				found = MemberCache.FindMembers (type, member_name, false);
 				type = type.DeclaringType;
 			}
 
 			if (found == null)
 				return null;
 
 			if (warn419 && found.Count > 1) {
 				Report419 (mc, name_for_error, found.ToArray (), Report);
 			}
 
 			return found [0];
 
 /*
 			if (param_list == null) {
 				// search for fields/events etc.
 				mis = TypeManager.MemberLookup (type, null,
 					type, MemberKind.All,
 					BindingRestriction.None,
 					member_name, null);
 				mis = FilterOverridenMembersOut (mis);
 				if (mis == null || mis.Length == 0)
 					return null;
 				if (warn419 && IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			MethodSignature msig = new MethodSignature (member_name, null, param_list);
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 
 			if (warn419 && mis.Length > 0) {
 				if (IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			// search for operators (whose parameters exactly
 			// matches with the list) and possibly report CS1581.
 			string oper = null;
 			string return_type_name = null;
 			if (member_name.StartsWith ("implicit operator ")) {
 				Operator.GetMetadataName (Operator.OpType.Implicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("explicit operator ")) {
 				oper = Operator.GetMetadataName (Operator.OpType.Explicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("operator ")) {
 				oper = member_name.Substring (9).Trim (wsChars);
 				switch (oper) {
 				// either unary or binary
 				case "+"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Addition) 
 						Operator.GetMetadataName (Operator.OpType.UnaryPlus);
 					break;
 				case "-"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Subtraction) 
 						Operator.GetMetadataName (Operator.OpType.UnaryNegation);
 					break;
 				default
 					oper = Operator.GetMetadataName (oper);
 					if (oper != null)
 						break;
 
 					warning_type = 1584;
 					Report.Warning (1020, 1, mc.Location, "Overloadable {0} operator is expected", param_list.Length == 2 ? "binary" 
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					return null;
 				}
 			}
 			// here we still don't consider return type (to
 			// detect CS1581 or CS1002+CS1584).
 			msig = new MethodSignature (oper, null, param_list);
 
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 			if (mis.Length == 0)
 				return null; // CS1574
 			var mi = mis [0];
 			TypeSpec expected = mi is MethodSpec ?
 				((MethodSpec) mi).ReturnType 
 				mi is PropertySpec ?
 				((PropertySpec) mi).PropertyType 
 				null;
 			if (return_type_name != null) {
 				TypeSpec returnType = FindDocumentedType (mc, return_type_name, ds, cref, Report);
 				if (returnType == null || returnType != expected) {
 					warning_type = 1581;
 					Report.Warning (1581, 1, mc.Location, "Invalid return type in XML comment cref attribute `{0}'", cref);
 					return null;
 				}
 			}
 			return mis [0];
 */ 
 		}
 
 		//
 		// Processes "see" or "seealso" elements.
 		// Checks cref attribute.
 		//
 		private static void HandleXrefCommon (MemberCore mc,
 			DeclSpace ds, XmlElement xref, Report Report)
 		{
 			string cref = xref.GetAttribute ("cref").Trim (wsChars);
 			// when, XmlReader, "if (cref == null)"
 			if (!xref.HasAttribute ("cref"))
 				return;
 			if (cref.Length == 0)
 				Report.Warning (1001, 1, mc.Location, "Identifier expected");
 				// ... and continue until CS1584.
 
 			string signature; // "x
 			string name; // method invokation "(...)" are removed
 			string parameters; // method parameter list
 
 			// When it found '?
 			// MS ignores not only its member kind, but also
 			// the entire syntax correctness. Nor it also does
 			// type fullname resolution i.e. "T
 			// as T
 			// T
 			if (cref.Length > 2 && cref [1] == '
 				return;
 			else
 				signature = cref;
 
 			// Also note that without "T
 			// indication fails.
 
 			int parens_pos = signature.IndexOf ('(');
 			int brace_pos = parens_pos >= 0 ? -1 
 				signature.IndexOf ('[');
 			if (parens_pos > 0 && signature [signature.Length - 1] == ')') {
 				name = signature.Substring (0, parens_pos).Trim (wsChars);
 				parameters = signature.Substring (parens_pos + 1, signature.Length - parens_pos - 2).Trim (wsChars);
 			}
 			else if (brace_pos > 0 && signature [signature.Length - 1] == ']') {
 				name = signature.Substring (0, brace_pos).Trim (wsChars);
 				parameters = signature.Substring (brace_pos + 1, signature.Length - brace_pos - 2).Trim (wsChars);
 			}
 			else {
 				name = signature;
 				parameters = null;
 			}
 			Normalize (mc, ref name, Report);
 
 			string identifier = GetBodyIdentifierFromName (name);
 
 			// Check if identifier is valid.
 			// This check is not necessary to mark as error, but
 			// csc specially reports CS1584 for wrong identifiers.
 			string [] name_elems = identifier.Split ('.');
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 
 			// check if parameters are valid
 			AParametersCollection parameter_types;
 			if (parameters == null)
 				parameter_types = null;
 			else if (parameters.Length == 0)
 				parameter_types = ParametersCompiled.EmptyReadOnlyParameters;
 			else {
 				string [] param_list = parameters.Split (',');
 				var plist = new List<TypeSpec> ();
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 
 				parameter_types = ParametersCompiled.CreateFullyResolved (plist.ToArray ());
 			}
 
 			TypeSpec type = FindDocumentedType (mc, name, ds, cref, Report);
 			if (type != null
 				// delegate must not be referenced with args
 				&& (!type.IsDelegate
 				|| parameter_types == null)) {
 				string result = GetSignatureForDoc (type)
 					+ (brace_pos < 0 ? String.Empty 
 				xref.SetAttribute ("cref", "T
 				return; // a type
 			}
 
 			int period = name.LastIndexOf ('.');
 			if (period > 0) {
 				string typeName = name.Substring (0, period);
 				string member_name = name.Substring (period + 1);
 				string lookup_name = member_name == "this" ? MemberCache.IndexerNameAlias 
 				Normalize (mc, ref lookup_name, Report);
 				Normalize (mc, ref member_name, Report);
 				type = FindDocumentedType (mc, typeName, ds, cref, Report);
 				int warn_result;
 				if (type != null) {
 					var mi = FindDocumentedMember (mc, type, lookup_name, parameter_types, ds, out warn_result, cref, true, name, Report);
 					if (warn_result > 0)
 						return;
 					if (mi != null) {
 						// we cannot use 'type' directly
 						// to get its name, since mi
 						// could be from DeclaringType
 						// for nested types.
 						xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + member_name + GetParametersFormatted (mi));
 						return; // a member of a type
 					}
 				}
 			} else {
 				int warn_result;
 				var mi = FindDocumentedMember (mc, ds.PartialContainer.Definition, name, parameter_types, ds, out warn_result, cref, true, name, Report);
 
 				if (warn_result > 0)
 					return;
 				if (mi != null) {
 					// we cannot use 'type' directly
 					// to get its name, since mi
 					// could be from DeclaringType
 					// for nested types.
 					xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + name + GetParametersFormatted (mi));
 					return; // local member name
 				}
 			}
 
 			// It still might be part of namespace name.
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (name, false);
 			if (ns != null) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 			if (mc.Module.GlobalRootNamespace.IsNamespace (name)) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 
 			Report.Warning (1574, 1, mc.Location, "XML comment on `{0}' has cref attribute `{1}' that could not be resolved",
 				mc.GetSignatureForError (), cref);
 
 			xref.SetAttribute ("cref", "!
 		}
 
 		static string GetParametersFormatted (MemberSpec mi)
 		{
 			var pm = mi as IParametersMember;
 			if (pm == null || pm.Parameters.IsEmpty)
 				return string.Empty;
 
 			AParametersCollection parameters = pm.Parameters;
 /*
 			if (parameters == null || parameters.Count == 0)
 				return String.Empty;
 */
 			StringBuilder sb = new StringBuilder ();
 			sb.Append ('(');
 			for (int i = 0; i < parameters.Count; i++) {
 //				if (is_setter && i + 1 == parameters.Count)
 //					break; // skip "value".
 				if (i > 0)
 					sb.Append (',');
 				TypeSpec t = parameters.Types [i];
 				sb.Append (GetSignatureForDoc (t));
 			}
 			sb.Append (')');
 			return sb.ToString ();
 		}
 
 		static string GetBodyIdentifierFromName (string name)
 		{
 			string identifier = name;
 
 			if (name.Length > 0 && name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				int last = tmp.LastIndexOf ('[');
 				if (last > 0)
 					identifier = tmp.Substring (0, last).Trim (wsChars);
 			}
 
 			return identifier;
 		}
 
 		static void Report419 (MemberCore mc, string member_name, MemberSpec [] mis, Report Report)
 		{
 			Report.Warning (419, 3, mc.Location, 
 				"Ambiguous reference in cref attribute `{0}'. Assuming `{1}' but other overloads including `{2}' have also matched",
 				member_name,
 				TypeManager.GetFullNameSignature (mis [0]),
 				TypeManager.GetFullNameSignature (mis [1]));
 		}
 
 		//
 		// Get a prefix from member type for XML documentation (used
 		// to formalize cref target name).
 		//
 		static string GetMemberDocHead (MemberSpec type)
 		{
 			if (type is FieldSpec)
 				return "F
 			if (type is MethodSpec)
 				return "M
 			if (type is EventSpec)
 				return "E
 			if (type is PropertySpec)
 				return "P
 			if (type is TypeSpec)
 				return "T
 
 			return "!
 		}
 
 		// MethodCore
 
 		//
 		// Returns a string that represents the signature for this 
 		// member which should be used in XML documentation.
 		//
 		public static string GetMethodDocCommentName (MemberCore mc, ParametersCompiled parameters, DeclSpace ds)
 		{
 			IParameterData [] plist = parameters.FixedParameters;
 			string paramSpec = String.Empty;
 			if (plist != null) {
 				StringBuilder psb = new StringBuilder ();
 				int i = 0;
 				foreach (Parameter p in plist) {
 					psb.Append (psb.Length != 0 ? "," 
 					psb.Append (GetSignatureForDoc (parameters.Types [i++]));
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 						psb.Append ('@');
 				}
 				paramSpec = psb.ToString ();
 			}
 
 			if (paramSpec.Length > 0)
 				paramSpec += ")";
 
 			string name = mc.Name;
 			if (mc is Constructor)
 				name = "#ctor";
 			else if (mc is InterfaceMemberBase) {
 				var imb = (InterfaceMemberBase) mc;
 				name = imb.GetFullName (imb.ShortName);
 			}
 			name = name.Replace ('.', '#');
 
 			if (mc.MemberName.TypeArguments != null && mc.MemberName.TypeArguments.Count > 0)
 				name += "``" + mc.MemberName.CountTypeArguments;
 
 			string suffix = String.Empty;
 			Operator op = mc as Operator;
 			if (op != null) {
 				switch (op.OperatorType) {
 				case Operator.OpType.Implicit
 				case Operator.OpType.Explicit
 					suffix = "~" + GetSignatureForDoc (op.ReturnType);
 					break;
 				}
 			}
 			return String.Concat (mc.DocCommentHeader, ds.Name, ".", name, paramSpec, suffix);
 		}
 
 		static string GetSignatureForDoc (TypeSpec type)
 		{
 			var tp = type as TypeParameterSpec;
 			if (tp != null) {
 				int c = 0;
 				type = type.DeclaringType;
 				while (type != null && type.DeclaringType != null) {
 					type = type.DeclaringType;
 					c += type.MemberDefinition.TypeParametersCount;
 				}
 				var prefix = tp.IsMethodOwned ? "``" 
 				return prefix + (c + tp.DeclaredPosition);
 			}
 
 			var pp = type as PointerContainer;
 			if (pp != null)
 				return GetSignatureForDoc (pp.Element) + "*";
 
 			ArrayContainer ap = type as ArrayContainer;
 			if (ap != null)
 				return GetSignatureForDoc (ap.Element) +
 					ArrayContainer.GetPostfixSignature (ap.Rank);
 
 			if (TypeManager.IsGenericType (type)) {
 				string g = type.MemberDefinition.Namespace;
 				if (g != null && g.Length > 0)
 					g += '.';
 				int idx = type.Name.LastIndexOf ('`');
 				g += (idx < 0 ? type.Name 
 				int argpos = 0;
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (type))
 					g += (argpos++ > 0 ? "," 
 				g += '}';
 				return g;
 			}
 
 			string name = type.GetMetaInfo ().FullName != null ? type.GetMetaInfo ().FullName 
 			return name.Replace ("+", ".").Replace ('&', '@');
 		}
 
 		//
 		// Raised (and passed an XmlElement that contains the comment)
 		// when GenerateDocComment is writing documentation expectedly.
 		//
 		// FIXME
 		// that means removal of DOM use.
 		//
 		internal static void OnMethodGenerateDocComment (
 			MethodCore mc, XmlElement el, Report Report)
 		{
 			var paramTags = new Dictionary<string, string> ();
 			foreach (XmlElement pelem in el.SelectNodes ("param")) {
 				string xname = pelem.GetAttribute ("name");
 				if (xname.Length == 0)
 					continue; // really? but MS looks doing so
 				if (xname != "" && mc.ParameterInfo.GetParameterIndexByName (xname) < 0)
 					Report.Warning (1572, 2, mc.Location, "XML comment on `{0}' has a param tag for `{1}', but there is no parameter by that name",
 						mc.GetSignatureForError (), xname);
 				else if (paramTags.ContainsKey (xname))
 					Report.Warning (1571, 2, mc.Location, "XML comment on `{0}' has a duplicate param tag for `{1}'",
 						mc.GetSignatureForError (), xname);
 				paramTags [xname] = xname;
 			}
 			IParameterData [] plist = mc.ParameterInfo.FixedParameters;
 			foreach (Parameter p in plist) {
 				if (paramTags.Count > 0 && !paramTags.ContainsKey (p.Name))
 					Report.Warning (1573, 4, mc.Location, "Parameter `{0}' has no matching param tag in the XML comment for `{1}'",
 						p.Name, mc.GetSignatureForError ());
 			}
 		}
 
 		private static void Normalize (MemberCore mc, ref string name, Report Report)
 		{
 			if (name.Length > 0 && name [0] == '@')
 				name = name.Substring (1);
 			else if (name == "this")
 				name = "Item";
 			else if (Tokenizer.IsKeyword (name) && !IsTypeName (name))
 				Report.Warning (1041, 1, mc.Location, "Identifier expected. `{0}' is a keyword", name);
 		}
 
 		private static bool IsTypeName (string name)
 		{
 			switch (name) {
 			case "bool"
 			case "byte"
 			case "char"
 			case "decimal"
 			case "double"
 			case "float"
 			case "int"
 			case "long"
 			case "object"
 			case "sbyte"
 			case "short"
 			case "string"
 			case "uint"
 			case "ulong"
 			case "ushort"
 			case "void"
 				return true;
 			}
 			return false;
 		}
 	}
 
 	//
 	// Implements XML documentation generation.
 	//
 	public class Documentation
 	{
 		public Documentation (string xml_output_filename)
 		{
 			docfilename = xml_output_filename;
 			XmlDocumentation = new XmlDocument ();
 			XmlDocumentation.PreserveWhitespace = false;
 		}
 
 		private string docfilename;
 
 		//
 		// Used to create element which helps well-formedness checking.
 		//
 		public XmlDocument XmlDocumentation;
 
 		//
 		// The output for XML documentation.
 		//
 		public XmlWriter XmlCommentOutput;
 
 		//
 		// Stores XmlDocuments that are included in XML documentation.
 		// Keys are included filenames, values are XmlDocuments.
 		//
 		public Dictionary<string, XmlDocument> StoredDocuments = new Dictionary<string, XmlDocument> ();
 		public Documentation (string xml_output_filename)
 		{
 			docfilename = xml_output_filename;
 			XmlDocumentation = new XmlDocument ();
 			XmlDocumentation.PreserveWhitespace = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ParseTypeInfo.vb" startline="36" endline="42">
<![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler, ByVal Attributes As Attributes, ByVal [Namespace] As String, ByVal BaseType As IType)
         MyBase.New(Compiler, Attributes)
         m_Namespace = [Namespace]
         m_BaseType = BaseType
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1322" endline="1336">
<![CDATA[
 	}
 
 	/// <summary>
 	///  This class is used to wrap literals which belong inside Enums
 	/// </summary>
 	public class EnumConstant 
 	{
 		public Constant Child;
 
 		public EnumConstant (Constant child, TypeSpec enum_type)
 			
 		{
 			this.Child = child;
 			this.type = enum_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="141" endline="153">
<![CDATA[
 	}
 
 	public class ConstInitializer 
 	{
 		bool in_transit;
 		readonly FieldBase field;
 
 		public ConstInitializer (FieldBase field, Expression value, Location loc)
 			
 		{
 			this.loc = loc;
 			this.field = field;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="142" endline="154">
<![CDATA[
 
 			#endregion
 		}
 
 		public AQueryClause next;
 		public QueryBlock block;
 
 		protected AQueryClause (QueryBlock block, Expression expr, Location loc)
 			 
 		{
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1550" endline="1564">
<![CDATA[
 		}
 	}
 	
 	//
 	// This represents a typecast in the source language.
 	//
 	public class Cast 
 		Expression target_type;
 
 		public Cast (Expression cast_type, Expression expr, Location loc)
 			
 		{
 			this.target_type = cast_type;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="425" endline="431">
<![CDATA[
 		public DynamicLoader (ReflectionImporter importer, CompilerContext compiler)
 			
 		{
 			paths.Add (GetSystemDir ());
 
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8689" endline="8696">
<![CDATA[
 
 		EmptyExpression ()
 		{
 			// FIXME
 			type = TypeManager.object_type;
 			eclass = ExprClass.Value;
 			loc = Location.Null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="84" endline="90">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal EventInfo As Mono.Cecil.EventReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.new(Classifications.EventAccess, Parent)
         m_EventInfo = EventInfo
         m_InstanceExpression = InstanceExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="183" endline="189">
<![CDATA[
 
     Sub New(ByVal ParentAndValue As Expression)
         Me.New(DirectCast(ParentAndValue, ParsedObject))
         m_Type = ParentAndValue.ExpressionType
         m_Value = ParentAndValue
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="190" endline="196">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Value As Expression)
         Me.New(DirectCast(Parent, ParsedObject))
         m_Type = Value.ExpressionType
         m_Value = Value
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="77" endline="83">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Constant As Object, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
         m_Value = Constant
         m_ExpressionType = ExpressionType
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="315" endline="321">
<![CDATA[
 
 		internal LocalVariableEntry (MonoSymbolFile file, MyBinaryReader reader)
 		{
 			Index = reader.ReadLeb128 ();
 			Name = reader.ReadString ();
 			BlockIndex = reader.ReadLeb128 ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="359" endline="365">
<![CDATA[
 
 		internal CapturedVariable (MyBinaryReader reader)
 		{
 			Name = reader.ReadString ();
 			CapturedName = reader.ReadString ();
 			Kind = (CapturedKind) reader.ReadByte ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8594" endline="8600">
<![CDATA[
 
 		public BaseThis (TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 			eclass = ExprClass.Variable;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="595" endline="604">
<![CDATA[
 	}
 	
 	public class StatementExpression 
 		ExpressionStatement expr;
 		
 		public StatementExpression (ExpressionStatement expr)
 		{
 			this.expr = expr;
 			loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1932" endline="1943">
<![CDATA[
 	}
 
 	//
 	// Generic type with unbound type arguments, used for typeof (G<,,>)
 	//
 	class GenericOpenTypeExpr 
 	{
 		public GenericOpenTypeExpr (TypeSpec type, /*UnboundTypeArguments args,*/ Location loc)
 		{
 			this.type = type.GetDefinition ();
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1982" endline="1995">
<![CDATA[
 	}
 
 	//
 	// Standard composite pattern
 	//
 	public abstract class CompositeExpression 
 	{
 		protected Expression expr;
 
 		protected CompositeExpression (Expression expr)
 		{
 			this.expr = expr;
 			this.loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="106" endline="790">
<![CDATA[
 	}
 	
 	//
 	//   Unary implements unary expressions.
 	//
 	public class Unary 
 	{
 		public enum Operator 
 			UnaryPlus, UnaryNegation, LogicalNot, OnesComplement,
 			AddressOf,  TOP
 		}
 
 		static TypeSpec[][] predefined_operators;
 
 		public readonly Operator Oper;
 		public Expression Expr;
 		Expression enum_conversion;
 
 		public Unary (Operator op, Expression expr, Location loc)
 		{
 			Oper = op;
 			Expr = expr;
 			this.loc = loc;
 		}
 
 		// <summary>
 		//   This routine will attempt to simplify the unary expression when the
 		//   argument is a constant.
 		// </summary>
 		Constant TryReduceConstant (ResolveContext ec, Constant e)
 		{
 			if (e is EmptyConstantCast)
 				return TryReduceConstant (ec, ((EmptyConstantCast) e).child);
 			
 			if (e is SideEffectConstant) {
 				Constant r = TryReduceConstant (ec, ((SideEffectConstant) e).value);
 				return r == null ? null 
 			}
 
 			TypeSpec expr_type = e.Type;
 			
 			switch (Oper){
 			case Operator.UnaryPlus
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type || expr_type == TypeManager.uint32_type ||
 				    expr_type == TypeManager.int64_type || expr_type == TypeManager.uint64_type ||
 				    expr_type == TypeManager.float_type || expr_type == TypeManager.double_type ||
 				    expr_type == TypeManager.decimal_type) {
 					return e;
 				}
 				
 				return null;
 				
 			case Operator.UnaryNegation
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (-((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (-((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (-((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (-((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (-((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type) {
 					int value = ((IntConstant)e).Value;
 					if (value == int.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new IntConstant (-value, e.Location);
 				}
 				if (expr_type == TypeManager.int64_type) {
 					long value = ((LongConstant)e).Value;
 					if (value == long.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new LongConstant (-value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint32_type) {
 					UIntLiteral uil = e as UIntLiteral;
 					if (uil != null) {
 						if (uil.Value == int.MaxValue + (uint) 1)
 							return new IntLiteral (int.MinValue, e.Location);
 						return new LongLiteral (-uil.Value, e.Location);
 					}
 					return new LongConstant (-((UIntConstant)e).Value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint64_type) {
 					ULongLiteral ull = e as ULongLiteral;
 					if (ull != null && ull.Value == 9223372036854775808)
 						return new LongLiteral (long.MinValue, e.Location);
 					return null;
 				}
 				
 				if (expr_type == TypeManager.float_type) {
 					FloatLiteral fl = e as FloatLiteral;
 					// For better error reporting
 					if (fl != null)
 						return new FloatLiteral (-fl.Value, e.Location);
 
 					return new FloatConstant (-((FloatConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.double_type) {
 					DoubleLiteral dl = e as DoubleLiteral;
 					// For better error reporting
 					if (dl != null)
 						return new DoubleLiteral (-dl.Value, e.Location);
 
 					return new DoubleConstant (-((DoubleConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.decimal_type)
 					return new DecimalConstant (-((DecimalConstant)e).Value, e.Location);
 				
 				return null;
 				
 			case Operator.LogicalNot
 				if (expr_type != TypeManager.bool_type)
 					return null;
 				
 				bool b = (bool)e.GetValue ();
 				return new BoolConstant (!b, e.Location);
 				
 			case Operator.OnesComplement
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (~((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (~((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (~((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (~((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (~((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type)
 					return new IntConstant (~((IntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint32_type)
 					return new UIntConstant (~((UIntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.int64_type)
 					return new LongConstant (~((LongConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint64_type){
 					return new ULongConstant (~((ULongConstant)e).Value, e.Location);
 				}
 				if (e is EnumConstant) {
 					e = TryReduceConstant (ec, ((EnumConstant)e).Child);
 					if (e != null)
 						e = new EnumConstant (e, expr_type);
 					return e;
 				}
 				return null;
 			}
 			throw new Exception ("Can not constant fold
 		}
 		
 		protected virtual Expression ResolveOperator (ResolveContext ec, Expression expr)
 		{
 			eclass = ExprClass.Value;
 
 			if (predefined_operators == null)
 				CreatePredefinedOperatorsTable ();
 
 			TypeSpec expr_type = expr.Type;
 			Expression best_expr;
 
 			//
 			// Primitive types first
 			//
 			if (TypeManager.IsPrimitiveType (expr_type)) {
 				best_expr = ResolvePrimitivePredefinedType (expr);
 				if (best_expr == null)
 					return null;
 
 				type = best_expr.Type;
 				Expr = best_expr;
 				return this;
 			}
 
 			//
 			// E operator ~(E x);
 			//
 			if (Oper == Operator.OnesComplement && TypeManager.IsEnumType (expr_type))
 				return ResolveEnumOperator (ec, expr);
 
 			return ResolveUserType (ec, expr);
 		}
 
 		protected virtual Expression ResolveEnumOperator (ResolveContext ec, Expression expr)
 		{
 			TypeSpec underlying_type = EnumSpec.GetUnderlyingType (expr.Type);
 			Expression best_expr = ResolvePrimitivePredefinedType (EmptyCast.Create (expr, underlying_type));
 			if (best_expr == null)
 				return null;
 
 			Expr = best_expr;
 			enum_conversion = Convert.ExplicitNumericConversion (new EmptyExpression (best_expr.Type), underlying_type);
 			type = expr.Type;
 			return EmptyCast.Create (this, type);
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return CreateExpressionTree (ec, null);
 		}
 
 		Expression CreateExpressionTree (ResolveContext ec, Expression user_op)
 		{
 			string method_name;
 			switch (Oper) {
 			case Operator.AddressOf
 				Error_PointerInsideExpressionTree (ec);
 				return null;
 			case Operator.UnaryNegation
 				if (ec.HasSet (ResolveContext.Options.CheckedScope) && user_op == null && !IsFloat (type))
 					method_name = "NegateChecked";
 				else
 					method_name = "Negate";
 				break;
 			case Operator.OnesComplement
 			case Operator.LogicalNot
 				method_name = "Not";
 				break;
 			case Operator.UnaryPlus
 				method_name = "UnaryPlus";
 				break;
 			default
 				throw new InternalErrorException ("Unknown unary operator " + Oper.ToString ());
 			}
 
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (Expr.CreateExpressionTree (ec)));
 			if (user_op != null)
 				args.Add (new Argument (user_op));
 
 			return CreateExpressionFactoryCall (ec, method_name, args);
 		}
 
 		static void CreatePredefinedOperatorsTable ()
 		{
 			predefined_operators = new TypeSpec [(int) Operator.TOP] [];
 
 			//
 			// 7.6.1 Unary plus operator
 			//
 			predefined_operators [(int) Operator.UnaryPlus] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.2 Unary minus operator
 			//
 			predefined_operators [(int) Operator.UnaryNegation] = new TypeSpec [] {
 				TypeManager.int32_type, 
 				TypeManager.int64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.3 Logical negation operator
 			//
 			predefined_operators [(int) Operator.LogicalNot] = new TypeSpec [] {
 				TypeManager.bool_type
 			};
 
 			//
 			// 7.6.4 Bitwise complement operator
 			//
 			predefined_operators [(int) Operator.OnesComplement] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type
 			};
 		}
 
 		//
 		// Unary numeric promotions
 		//
 		static Expression DoNumericPromotion (Operator op, Expression expr)
 		{
 			TypeSpec expr_type = expr.Type;
 			if ((op == Operator.UnaryPlus || op == Operator.UnaryNegation || op == Operator.OnesComplement) &&
 				expr_type == TypeManager.byte_type || expr_type == TypeManager.sbyte_type ||
 				expr_type == TypeManager.short_type || expr_type == TypeManager.ushort_type ||
 				expr_type == TypeManager.char_type)
 				return Convert.ImplicitNumericConversion (expr, TypeManager.int32_type);
 
 			if (op == Operator.UnaryNegation && expr_type == TypeManager.uint32_type)
 				return Convert.ImplicitNumericConversion (expr, TypeManager.int64_type);
 
 			return expr;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (Oper == Operator.AddressOf) {
 				return ResolveAddressOf (ec);
 			}
 
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			if (Expr.Type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (Expr));
 				return new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (Expr.Type))
 				return new Nullable.LiftedUnaryOperator (Oper, Expr, loc).Resolve (ec);
 
 			//
 			// Attempt to use a constant folding operation.
 			//
 			Constant cexpr = Expr as Constant;
 			if (cexpr != null) {
 				cexpr = TryReduceConstant (ec, cexpr);
 				if (cexpr != null)
 					return cexpr.Resolve (ec);
 			}
 
 			Expression expr = ResolveOperator (ec, Expr);
 			if (expr == null)
 				Error_OperatorCannotBeApplied (ec, loc, OperName (Oper), Expr.Type);
 			
 			//
 			// Reduce unary operator on predefined types
 			//
 			if (expr == this && Oper == Operator.UnaryPlus)
 				return Expr;
 
 			return expr;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right)
 		{
 			return null;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			EmitOperator (ec, type);
 		}
 
 		protected void EmitOperator (EmitContext ec, TypeSpec type)
 		{
 			switch (Oper) {
 			case Operator.UnaryPlus
 				Expr.Emit (ec);
 				break;
 				
 			case Operator.UnaryNegation
 				if (ec.HasSet (EmitContext.Options.CheckedScope) && !IsFloat (type)) {
 					ec.Emit (OpCodes.Ldc_I4_0);
 					if (type == TypeManager.int64_type)
 						ec.Emit (OpCodes.Conv_U8);
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Sub_Ovf);
 				} else {
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 				}
 				
 				break;
 				
 			case Operator.LogicalNot
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				ec.Emit (OpCodes.Ceq);
 				break;
 				
 			case Operator.OnesComplement
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Not);
 				break;
 				
 			case Operator.AddressOf
 				((IMemoryLocation)Expr).AddressOf (ec, AddressOp.LoadStore);
 				break;
 				
 			default
 				throw new Exception ("This should not happen
 						     + Oper.ToString ());
 			}
 
 			//
 			// Same trick as in Binary expression
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
 
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			if (Oper == Operator.LogicalNot)
 				Expr.EmitBranchable (ec, target, !on_true);
 			else
 				base.EmitBranchable (ec, target, on_true);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			Expr.EmitSideEffect (ec);
 		}
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Location loc, string oper, TypeSpec t)
 		{
 			ec.Report.Error (23, loc, "The `{0}' operator cannot be applied to operand of type `{1}'",
 				oper, TypeManager.CSharpName (t));
 		}
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (Oper) {
 			case Operator.OnesComplement
 				return "OnesComplement";
 			case Operator.LogicalNot
 				return "Not";
 			case Operator.UnaryNegation
 				return "Negate";
 			case Operator.UnaryPlus
 				return "UnaryPlus";
 			default
 				throw new NotImplementedException ("Unknown express type operator " + Oper.ToString ());
 			}
 		}
 
 		static bool IsFloat (TypeSpec t)
 		{
 			return t == TypeManager.float_type || t == TypeManager.double_type;
 		}
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			var expr = Expr.MakeExpression (ctx);
 			bool is_checked = ctx.HasSet (BuilderContext.Options.CheckedScope);
 
 			switch (Oper) {
 			case Operator.UnaryNegation
 				return is_checked ? SLE.Expression.NegateChecked (expr) 
 			case Operator.LogicalNot
 				return SLE.Expression.Not (expr);
 #if NET_4_0
 			case Operator.OnesComplement
 				return SLE.Expression.OnesComplement (expr);
 #endif
 			default
 				throw new NotImplementedException (Oper.ToString ());
 			}
 		}
 
 		public static void Reset ()
 		{
 			predefined_operators = null;
 		}
 
 		Expression ResolveAddressOf (ResolveContext ec)
 		{
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			Expr = Expr.DoResolveLValue (ec, EmptyExpression.UnaryAddress);
 			if (Expr == null || Expr.eclass != ExprClass.Variable) {
 				ec.Report.Error (211, loc, "Cannot take the address of the given expression");
 				return null;
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, Expr.Type, loc)) {
 				return null;
 			}
 
 			IVariableReference vr = Expr as IVariableReference;
 			bool is_fixed;
 			if (vr != null) {
 				VariableInfo vi = vr.VariableInfo;
 				if (vi != null) {
 					if (vi.LocalInfo != null)
 						vi.LocalInfo.SetIsUsed ();
 
 					//
 					// A variable is considered definitely assigned if you take its address.
 					//
 					vi.SetAssigned (ec);
 				}
 
 				is_fixed = vr.IsFixed;
 				vr.SetHasAddressTaken ();
 
 				if (vr.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, vr, loc);
 				}
 			} else {
 				IFixedExpression fe = Expr as IFixedExpression;
 				is_fixed = fe != null && fe.IsFixed;
 			}
 
 			if (!is_fixed && !ec.HasSet (ResolveContext.Options.FixedInitializerScope)) {
 				ec.Report.Error (212, loc, "You can only take the address of unfixed expression inside of a fixed statement initializer");
 			}
 
 			type = PointerContainer.MakeType (Expr.Type);
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		Expression ResolvePrimitivePredefinedType (Expression expr)
 		{
 			expr = DoNumericPromotion (Oper, expr);
 			TypeSpec expr_type = expr.Type;
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				if (t == expr_type)
 					return expr;
 			}
 			return null;
 		}
 
 		//
 		// Perform user-operator overload resolution
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression expr)
 		{
 			CSharp.Operator.OpType op_type;
 			switch (Oper) {
 			case Operator.LogicalNot
 				op_type = CSharp.Operator.OpType.LogicalNot; break;
 			case Operator.OnesComplement
 				op_type = CSharp.Operator.OpType.OnesComplement; break;
 			case Operator.UnaryNegation
 				op_type = CSharp.Operator.OpType.UnaryNegation; break;
 			case Operator.UnaryPlus
 				op_type = CSharp.Operator.OpType.UnaryPlus; break;
 			default
 				throw new InternalErrorException (Oper.ToString ());
 			}
 
 			var methods = MemberCache.GetUserOperator (expr.Type, op_type, false);
 			if (methods == null)
 				return null;
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (expr));
 
 			var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var oper = res.ResolveOperator (ec, ref args);
 
 			if (oper == null)
 				return null;
 
 			Expr = args [0].Expr;
 			return new UserOperatorCall (oper, args, CreateExpressionTree, expr.Location);
 		}
 
 		//
 		// Unary user type overload resolution
 		//
 		Expression ResolveUserType (ResolveContext ec, Expression expr)
 		{
 			Expression best_expr = ResolveUserOperator (ec, expr);
 			if (best_expr != null)
 				return best_expr;
 
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				Expression oper_expr = Convert.ImplicitUserConversion (ec, expr, t, expr.Location);
 				if (oper_expr == null)
 					continue;
 
 				//
 				// decimal type is predefined but has user-operators
 				//
 				if (oper_expr.Type == TypeManager.decimal_type)
 					oper_expr = ResolveUserType (ec, oper_expr);
 				else
 					oper_expr = ResolvePrimitivePredefinedType (oper_expr);
 
 				if (oper_expr == null)
 					continue;
 
 				if (best_expr == null) {
 					best_expr = oper_expr;
 					continue;
 				}
 
 				int result = OverloadResolver.BetterTypeConversion (ec, best_expr.Type, t);
 				if (result == 0) {
 					ec.Report.Error (35, loc, "Operator `{0}' is ambiguous on an operand of type `{1}'",
 						OperName (Oper), TypeManager.CSharpName (expr.Type));
 					break;
 				}
 
 				if (result == 2)
 					best_expr = oper_expr;
 			}
 			
 			if (best_expr == null)
 				return null;
 			
 			//
 			// HACK
 			//
 			if (best_expr.Type == TypeManager.decimal_type)
 				return best_expr;			
 
 			Expr = best_expr;
 			type = best_expr.Type;
 			return this;			
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Unary target = (Unary) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
 	}
 
 	//
 	// Unary operators are turned into Indirection expressions
 	// after semantic analysis (this is so we can take the address
 	// of an indirection).
 	//
 	public class Indirection 
 		Expression expr;
 		LocalTemporary temporary;
 		bool prepared;
 		
 		public Indirection (Expression expr, Location l)
 		{
 			this.expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1641" endline="1654">
<![CDATA[
 	}
 	
 	//
 	// C# 2.0 Default value expression
 	//
 	public class DefaultValueExpression 
 	{
 		Expression expr;
 
 		public DefaultValueExpression (Expression expr, Location loc)
 		{
 			this.expr = expr;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4527" endline="4703">
<![CDATA[
 	}
 
 	public abstract class VariableReference 
 		LocalTemporary temp;
 
 		#region Abstract
 		public abstract HoistedVariable GetHoistedVariable (AnonymousExpression ae);
 
 		public abstract bool IsLockedByStatement { get; set; }
 
 		public abstract bool IsFixed { get; }
 		public abstract bool IsRef { get; }
 		public abstract string Name { get; }
 		public abstract void SetHasAddressTaken ();
 
 		//
 		// Variable IL data, it has to be protected to encapsulate hoisted variables
 		//
 		protected abstract ILocalVariable Variable { get; }
 		
 		//
 		// Variable flow-analysis data
 		//
 		public abstract VariableInfo VariableInfo { get; }
 		#endregion
 
 		public virtual void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (IsLockedByStatement) {
 				rc.Report.Warning (728, 2, loc,
 					"Possibly incorrect assignment to `{0}' which is the argument to a using or lock statement",
 					Name);
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			// do nothing
 		}
 
 		//
 		// This method is used by parameters that are references, that are
 		// being passed as references
 		// is already stored in the parameter, not the address of the pointer,
 		// and not the value of the variable).
 		//
 		public void EmitLoad (EmitContext ec)
 		{
 			Variable.Emit (ec);
 		}
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
 
 
 		public HoistedVariable GetHoistedVariable (ResolveContext rc)
 		{
 			return GetHoistedVariable (rc.CurrentAnonymousMethod);
 		}
 
 		public HoistedVariable GetHoistedVariable (EmitContext ec)
 		{
 			return GetHoistedVariable (ec.CurrentAnonymousMethod);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Name;
 		}
 
 		public bool IsHoisted {
 			get { return GetHoistedVariable ((AnonymousExpression) null) != null; }
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="786" endline="1264">
<![CDATA[
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
 
 		protected Method (DeclSpace parent, FullNamedExpression return_type, Modifiers mod, Modifiers amod,
 					MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		public override TypeParameter[] CurrentTypeParameters {
 			get {
 				if (GenericMethod != null)
 					return GenericMethod.CurrentTypeParameters;
 
 				return null;
 			}
 		}
 
 		public override bool HasUnresolvedConstraints {
 			get {
 				if (CurrentTypeParameters == null)
 					return false;
 
 				// When overriding base method constraints are fetched from
 				// base method but to find it we have to resolve parameters
 				// to find exact base method match
 				if (IsExplicitImpl || (ModFlags & Modifiers.OVERRIDE) != 0)
 					return base_method == null;
 
 				// Even for non-override generic method constraints check has to be
 				// delayed after all constraints are resolved
 				return true;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				// TODO
 				return CurrentTypeParameters.Select (l => l.Type).ToArray ();
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return CurrentTypeParameters == null ? 0 
 			}
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
 
 		void Error_DuplicateEntryPoint (Method b)
 		{
 			Report.Error (17, b.Location,
 				"Program `{0}' has more than one entry point defined
 				b.Module.Builder.ScopeName, b.GetSignatureForError ());
 		}
 
 		bool IsEntryPoint ()
 		{
 			if (ReturnType != TypeManager.void_type &&
 				ReturnType != TypeManager.int32_type)
 				return false;
 
 			if (parameters.IsEmpty)
 				return true;
 
 			if (parameters.Count > 1)
 				return false;
 
 			var ac = parameters.Types [0] as ArrayContainer;
 			return ac != null && ac.Rank == 1 && ac.Element == TypeManager.string_type &&
 					(parameters[0].ModFlags & ~Parameter.Modifier.PARAMS) == Parameter.Modifier.NONE;
 		}
 
 		public override FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			if (arity == 0) {
 				TypeParameter[] tp = CurrentTypeParameters;
 				if (tp != null) {
 					TypeParameter t = TypeParameter.FindTypeParameter (tp, name);
 					if (t != null)
 						return new TypeParameterExpr (t, loc);
 				}
 			}
 
 			return base.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				if (IsExplicitImpl) {
 					Error_ConditionalAttributeIsNotValid ();
 					return;
 				}
 
 				if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 					Report.Error (243, Location, "Conditional not valid on `{0}' because it is an override method", GetSignatureForError ());
 					return;
 				}
 
 				if (ReturnType != TypeManager.void_type) {
 					Report.Error (578, Location, "Conditional not valid on `{0}' because its return type is not void", GetSignatureForError ());
 					return;
 				}
 
 				if (IsInterface) {
 					Report.Error (582, Location, "Conditional not valid on interface members");
 					return;
 				}
 
 				if (MethodData.implementing != null) {
 					Report.SymbolRelatedToPreviousError (MethodData.implementing.DeclaringType);
 					Report.Error (629, Location, "Conditional member `{0}' cannot implement interface member `{1}'",
 						GetSignatureForError (), TypeManager.CSharpSignature (MethodData.implementing));
 					return;
 				}
 
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		protected virtual void DefineTypeParameters ()
 		{
 			var tparams = CurrentTypeParameters;
 
 			TypeParameterSpec[] base_tparams = null;
 			TypeParameterSpec[] base_decl_tparams = TypeParameterSpec.EmptyTypes;
 			TypeSpec[] base_targs = TypeSpec.EmptyTypes;
 			if (((ModFlags & Modifiers.OVERRIDE) != 0 || IsExplicitImpl)) {
 				if (base_method != null) {
 					base_tparams = base_method.GenericDefinition.TypeParameters;
 				
 					if (base_method.DeclaringType.IsGeneric) {
 						base_decl_tparams = base_method.DeclaringType.MemberDefinition.TypeParameters;
 
 						var base_type_parent = CurrentType;
 						while (base_type_parent.BaseType != base_method.DeclaringType) {
 							base_type_parent = base_type_parent.BaseType;
 						}
 
 						base_targs = base_type_parent.BaseType.TypeArguments;
 					}
 
 					if (base_method.IsGeneric) {
 						ObsoleteAttribute oa;
 						foreach (var base_tp in base_tparams) {
 							oa = base_tp.BaseType.GetAttributeObsolete ();
 							if (oa != null) {
 								AttributeTester.Report_ObsoleteMessage (oa, base_tp.BaseType.GetSignatureForError (), Location, Report);
 							}
 
 							if (base_tp.InterfacesDefined != null) {
 								foreach (var iface in base_tp.InterfacesDefined) {
 									oa = iface.GetAttributeObsolete ();
 									if (oa != null) {
 										AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 									}
 								}
 							}
 						}
 
 						if (base_decl_tparams.Length != 0) {
 							base_decl_tparams = base_decl_tparams.Concat (base_tparams).ToArray ();
 							base_targs = base_targs.Concat (tparams.Select<TypeParameter, TypeSpec> (l => l.Type)).ToArray ();
 						} else {
 							base_decl_tparams = base_tparams;
 							base_targs = tparams.Select (l => l.Type).ToArray ();
 						}
 					}
 				} else if (MethodData.implementing != null) {
 					base_tparams = MethodData.implementing.GenericDefinition.TypeParameters;
 					if (MethodData.implementing.DeclaringType.IsGeneric) {
 						base_decl_tparams = MethodData.implementing.DeclaringType.MemberDefinition.TypeParameters;
 						foreach (var iface in Parent.CurrentType.Interfaces) {
 							if (iface == MethodData.implementing.DeclaringType) {
 								base_targs = iface.TypeArguments;
 								break;
 							}
 						}
 					}
 				}
 			}
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 
 				if (!tp.ResolveConstraints (this))
 					continue;
 
 				//
 				// Copy base constraints for override/explicit methods
 				//
 				if (base_tparams != null) {
 					var base_tparam = base_tparams[i];
 					var local_tparam = tp.Type;
 					local_tparam.SpecialConstraint = base_tparam.SpecialConstraint;
 
 					var inflator = new TypeParameterInflator (CurrentType, base_decl_tparams, base_targs);
 					base_tparam.InflateConstraints (inflator, local_tparam);
 
 					//
 					// Check all type argument constraints for possible collision
 					// introduced by inflating inherited constraints in this context
 					//
 					// Conflict example
 					//
 					// class A<T> { virtual void Foo<U> () where U 
 					// class B 
 					//
 					var local_tparam_targs = local_tparam.TypeArguments;
 					if (local_tparam_targs != null) {					
 						for (int ii = 0; ii < local_tparam_targs.Length; ++ii) {
 							var ta = local_tparam_targs [ii];
 							if (!ta.IsClass && !ta.IsStruct)
 								continue;
 
 							if (Constraints.CheckConflictingInheritedConstraint (local_tparam, ta, this, Location)) {
 								local_tparam.ChangeTypeArgumentToBaseType (ii);
 							}
 						}
 					}
 
 					continue;
 				}
 				
 				if (MethodData.implementing != null) {
 					var base_tp = MethodData.implementing.Constraints[i];
 					if (!tp.Type.HasSameConstraintsImplementation (base_tp)) {
 						Report.SymbolRelatedToPreviousError (MethodData.implementing);
 						Report.Error (425, Location,
 							"The constraints for type parameter `{0}' of method `{1}' must match the constraints for type parameter `{2}' of interface method `{3}'. Consider using an explicit interface implementation instead",
 							tp.GetSignatureForError (), GetSignatureForError (), base_tp.GetSignatureForError (), MethodData.implementing.GetSignatureForError ());
 					}
 				}
 			}
 		}
 
 		//
 		// Creates the type
 		//
 		public override bool Define ()
 		{
 			if (type_expr.Type == TypeManager.void_type && parameters.IsEmpty && MemberName.Arity == 0 && MemberName.Name == Destructor.MetadataName) {
 				Report.Warning (465, 1, Location, "Introducing `Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?");
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (partialMethodImplementation != null && IsPartialDefinition)
 				MethodBuilder = partialMethodImplementation.MethodBuilder;
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ReturnType)) {
 				Error1599 (Location, ReturnType, Report);
 				return false;
 			}
 
 			if (CurrentTypeParameters == null) {
 				if (base_method != null) {
 					if (parameters.Count == 1 && ParameterTypes[0] == TypeManager.object_type && Name == "Equals")
 						Parent.PartialContainer.Mark_HasEquals ();
 					else if (parameters.IsEmpty && Name == "GetHashCode")
 						Parent.PartialContainer.Mark_HasGetHashCode ();
 				}
 					
 			} else {
 				DefineTypeParameters ();
 			}
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			if ((ModFlags & Modifiers.STATIC) == 0)
 				return true;
 
 			if (parameters.HasExtensionMethodType) {
 				if (Parent.PartialContainer.IsStatic && !Parent.IsGeneric) {
 					if (!Parent.IsTopLevel)
 						Report.Error (1109, Location, "`{0}'
 							GetSignatureForError ());
 
 					PredefinedAttribute pa = Module.PredefinedAttributes.Extension;
 					if (!pa.IsDefined) {
 						Report.Error (1110, Location,
 							"`{0}'
 							GetSignatureForError ());
 					}
 
 					ModFlags |= Modifiers.METHOD_EXTENSION;
 					Parent.PartialContainer.ModFlags |= Modifiers.METHOD_EXTENSION;
 					Spec.DeclaringType.SetExtensionMethodContainer ();
 					Parent.Module.HasExtensionMethod = true;
 				} else {
 					Report.Error (1106, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 
 			//
 			// This is used to track the Entry Point,
 			//
 			if (RootContext.NeedsEntryPoint &&
 				Name == "Main" &&
 				(RootContext.MainClass == null ||
 				RootContext.MainClass == Parent.TypeBuilder.FullName)){
 				if (IsEntryPoint ()) {
 
 					if (Parent.DeclaringAssembly.EntryPoint == null) {
 						if (Parent.IsGeneric || MemberName.IsGeneric) {
 							Report.Warning (402, 4, Location, "`{0}'
 								GetSignatureForError ());
 						} else {
 							SetIsUsed ();
 							Parent.DeclaringAssembly.EntryPoint = this;
 						}
 					} else {
 						Error_DuplicateEntryPoint (Parent.DeclaringAssembly.EntryPoint);
 						Error_DuplicateEntryPoint (this);
 					}
 				} else {
 					Report.Warning (28, 4, Location, "`{0}' has the wrong signature to be an entry point",
 						GetSignatureForError ());
 				}
 			}
 
 			return true;
 		}
 
 		//
 		// Emits the code
 		// 
 		public override void Emit ()
 		{
 			try {
 				if (IsPartialDefinition) {
 					//
 					// Use partial method implementation builder for partial method declaration attributes
 					//
 					if (partialMethodImplementation != null) {
 						MethodBuilder = partialMethodImplementation.MethodBuilder;
 					}
 
 					return;
 				}
 				
 				if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.PartialDefinitionExists) == 0) {
 					Report.Error (759, Location, "A partial method `{0}' implementation is missing a partial method declaration",
 						GetSignatureForError ());
 				}
 
 				if (CurrentTypeParameters != null) {
 					var ge = type_expr as GenericTypeExpr;
 					if (ge != null)
 						ge.CheckConstraints (this);
 
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 				}
 
 				base.Emit ();
 				
 				if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 					Module.PredefinedAttributes.Extension.EmitAttribute (MethodBuilder);
 			} catch {
 				Console.WriteLine ("Internal compiler error at {0}
 						   Location, MethodBuilder);
 				throw;
 			}
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			// TODO
 			if (overload is Operator)
 				return overload.EnableOverloadChecks (this);
 
 			if (overload is Indexer)
 				return false;
 
 			return base.EnableOverloadChecks (overload);
 		}
 
 		public static void Error1599 (Location loc, TypeSpec t, Report Report)
 		{
 			Report.Error (1599, loc, "Method or delegate cannot return type `{0}'", TypeManager.CSharpName (t));
 		}
 
 		protected override bool ResolveMemberType ()
 		{
 			if (GenericMethod != null) {
 				MethodBuilder = Parent.TypeBuilder.DefineMethod (GetFullName (MemberName), flags);
 				if (!GenericMethod.Define (this))
 					return false;
 			}
 
 			return base.ResolveMemberType ();
 		}
 
 		public void SetPartialDefinition (Method methodDefinition)
 		{
 			caching_flags |= Flags.PartialDefinitionExists;
 			methodDefinition.partialMethodImplementation = this;
 
 			// Ensure we are always using method declaration parameters
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 
 			if (methodDefinition.attributes == null)
 				return;
 
 			if (attributes == null) {
 				attributes = methodDefinition.attributes;
 			} else {
 				attributes.Attrs.AddRange (methodDefinition.attributes.Attrs);
 			}
 		}
 	}
 
 	public abstract class ConstructorInitializer 
 	{
 		Arguments argument_list;
 		MethodSpec base_ctor;
 
 		public ConstructorInitializer (Arguments argument_list, Location loc)
 		{
 			this.argument_list = argument_list;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="44" endline="253">
<![CDATA[
 
 		bool is_double_colon;
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    TypeArguments args, Location loc)
 			
 		{
 			if (args != null && args.Count > 0)
 				this.TypeArguments = args;
 		}
 
 		public MemberName (string name)
 			
 		{ }
 
 		public MemberName (string name, Location loc)
 			
 		{ }
 
 		public MemberName (string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (string alias, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right, Location loc)
 			
 		{
 			if (right.is_double_colon)
 				throw new InternalErrorException ("Cannot append double_colon member name");
 			this.Left = (right.Left == null) ? left 
 		}
 
 		// TODO
 		public string GetName ()
 		{
 			return GetName (false);
 		}
 
 		public int Arity {
 			get {
 				return TypeArguments == null ? 0 
 			}
 		}
 
 		public bool IsGeneric {
 			get {
 				if (TypeArguments != null)
 					return true;
 				else if (Left != null)
 					return Left.IsGeneric;
 				else
 					return false;
 			}
 		}
 
 		public string GetName (bool is_generic)
 		{
 			string name = is_generic ? Basename 
 			if (Left != null)
 				return Left.GetName (is_generic) + (is_double_colon ? "
 
 			return name;
 		}
 
 		public ATypeNameExpression GetTypeExpression ()
 		{
 			if (Left == null) {
 				if (TypeArguments != null)
 					return new SimpleName (Name, TypeArguments, Location);
 				
 				return new SimpleName (Name, Location);
 			}
 
 			if (is_double_colon) {
 				if (Left.Left != null)
 					throw new InternalErrorException ("The left side of a 
 				return new QualifiedAliasMember (Left.Name, Name, TypeArguments, Location);
 			}
 
 			Expression lexpr = Left.GetTypeExpression ();
 			return new MemberAccess (lexpr, Name, TypeArguments, Location);
 		}
 
 		public MemberName Clone ()
 		{
 			MemberName left_clone = Left == null ? null 
 			return new MemberName (left_clone, Name, is_double_colon, TypeArguments, Location);
 		}
 
 		public string Basename {
 			get {
 				if (TypeArguments != null)
 					return MakeName (Name, TypeArguments);
 				return Name;
 			}
 		}
 
 		public string GetSignatureForError ()
 		{
 			string append = TypeArguments == null ? "" 
 			if (Left == null)
 				return Name + append;
 			string connect = is_double_colon ? "
 			return Left.GetSignatureForError () + connect + Name + append;
 		}
 
 		public override bool Equals (object other)
 		{
 			return Equals (other as MemberName);
 		}
 
 		public bool Equals (MemberName other)
 		{
 			if (this == other)
 				return true;
 			if (other == null || Name != other.Name)
 				return false;
 			if (is_double_colon != other.is_double_colon)
 				return false;
 
 			if ((TypeArguments != null) &&
 			    (other.TypeArguments == null || TypeArguments.Count != other.TypeArguments.Count))
 				return false;
 
 			if ((TypeArguments == null) && (other.TypeArguments != null))
 				return false;
 
 			if (Left == null)
 				return other.Left == null;
 
 			return Left.Equals (other.Left);
 		}
 
 		public override int GetHashCode ()
 		{
 			int hash = Name.GetHashCode ();
 			for (MemberName n = Left; n != null; n = n.Left)
 				hash ^= n.Name.GetHashCode ();
 			if (is_double_colon)
 				hash ^= 0xbadc01d;
 
 			if (TypeArguments != null)
 				hash ^= TypeArguments.Count << 5;
 
 			return hash & 0x7FFFFFFF;
 		}
 
 		public int CountTypeArguments {
 			get {
 				if (TypeArguments != null)
 					return TypeArguments.Count;
 				else if (Left != null)
 					return Left.CountTypeArguments; 
 				else
 					return 0;
 			}
 		}
 
 		public static string MakeName (string name, TypeArguments args)
 		{
 			if (args == null)
 				return name;
 
 			return name + "`" + args.Count;
 		}
 
 		public static string MakeName (string name, int count)
 		{
 			return name + "`" + count;
 		}
 	}
 
 	public class SimpleMemberName
 	{
 		public string Value;
 		public Location Location;
 
 		public SimpleMemberName (string name, Location loc)
 		{
 			this.Value = name;
 			this.Location = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="701" endline="713">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the return statement
 	/// </summary>
 	public class Return 
 	{
 		protected Expression Expr;
 		public Return (Expression expr, Location l)
 		{
 			Expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="694" endline="706">
<![CDATA[
 		}
 	}
 
 	public class MissingType 
 	{
 		readonly string full_name;
 		readonly MissingAssembly assembly;
 
 		public MissingType (string typeName, MissingAssembly assembly)
 		{
 			this.full_name = typeName;
 			this.assembly = assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5892" endline="5909">
<![CDATA[
 	}
 
 	//
 	// Array initializer expression, the expression is allowed in
 	// variable or field initialization only which makes it tricky as
 	// the type has to be infered based on the context either from field
 	// type or variable type (think of multiple declarators)
 	//
 	public class ArrayInitializer 
 	{
 		List<Expression> elements;
 		BlockVariableDeclaration variable;
 
 		public ArrayInitializer (List<Expression> init, Location loc)
 		{
 			elements = init;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7082" endline="7095">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the typeof operator
 	/// </summary>
 	public class TypeOf 
 		FullNamedExpression QueriedType;
 		TypeSpec typearg;
 
 		public TypeOf (FullNamedExpression queried_type, Location l)
 		{
 			QueriedType = queried_type;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7220" endline="7292">
<![CDATA[
 	}
 
 	class TypeOfMethod 
 	{
 		public TypeOfMethod (MethodSpec method, Location loc)
 			
 		{
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (member.IsConstructor) {
 				type = ec.Module.PredefinedTypes.ConstructorInfo.Resolve (loc);
 			} else {
 				type = ec.Module.PredefinedTypes.MethodInfo.Resolve (loc);
 			}
 
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
 
 		protected override string GetMethodName {
 			get { return "GetMethodFromHandle"; }
 		}
 
 		protected override PredefinedType GetDeclaringType (PredefinedTypes types)
 		{
 			return types.MethodBase;
 		}
 
 		protected override PredefinedType GetRuntimeHandle (PredefinedTypes types)
 		{
 			return types.RuntimeMethodHandle;
 		}
 
 		protected override MethodSpec TypeFromHandle {
 			get {
 				return TypeManager.methodbase_get_type_from_handle;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle = value;
 			}
 		}
 
 		protected override MethodSpec TypeFromHandleGeneric {
 			get {
 				return TypeManager.methodbase_get_type_from_handle_generic;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle_generic = value;
 			}
 		}
 	}
 
 	abstract class TypeOfMember<T> 
 	{
 		protected readonly T member;
 
 		protected TypeOfMember (T member, Location loc)
 		{
 			this.member = member;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7402" endline="7416">
<![CDATA[
 		}
 	}
 
 	/// <summary>
 	///   Implements the sizeof expression
 	/// </summary>
 	public class SizeOf 
 		readonly Expression QueriedType;
 		TypeSpec type_queried;
 		
 		public SizeOf (Expression queried_type, Location l)
 		{
 			this.QueriedType = queried_type;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="100" endline="291">
<![CDATA[
 		private readonly int position;
 
 		private sealed class DummyModule 
 		{
 			internal DummyModule()
 				
 			{
 			}
 
 			public override bool Equals(object obj)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int GetHashCode()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ToString()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int MDStreamVersion
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Assembly Assembly
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			internal override Type GetTypeImpl(string typeName)
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override void GetTypesImpl(List<Type> list)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string FullyQualifiedName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override string Name
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Guid ModuleVersionId
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ResolveString(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ScopeName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override AssemblyName[] __GetReferencedAssemblies()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override Type GetModuleType()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override ByteReader GetBlob(int blobIndex)
 			{
 				throw new InvalidOperationException();
 			}
 		}
 
 		internal static Type Make(int position)
 		{
 			return module.CanonicalizeType(new UnboundGenericMethodParameter(position));
 		}
 
 		private UnboundGenericMethodParameter(int position)
 		{
 			this.position = position;
 		}
 
 		public override bool Equals(object obj)
 		{
 			UnboundGenericMethodParameter other = obj as UnboundGenericMethodParameter;
 			return other != null && other.position == position;
 		}
 
 		public override int GetHashCode()
 		{
 			return position;
 		}
 
 		public override string Namespace
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override string Name
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override int MetadataToken
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Module Module
 		{
 			get { return module; }
 		}
 
 		public override int GenericParameterPosition
 		{
 			get { return position; }
 		}
 
 		public override Type DeclaringType
 		{
 			get { return null; }
 		}
 
 		public override MethodBase DeclaringMethod
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Type[] GetGenericParameterConstraints()
 		{
 			throw new InvalidOperationException();
 		}
 
 		public override GenericParameterAttributes GenericParameterAttributes
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			return binder.BindMethodParameter(this);
 		}
 	}
 
 	sealed class GenericTypeParameter 
 	{
 		private readonly ModuleReader module;
 		private readonly int index;
 
 		internal GenericTypeParameter(ModuleReader module, int index)
 		{
 			this.module = module;
 			this.index = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1122" endline="1248">
<![CDATA[
 
 			public AttributeUsageAttribute AttributeUsage;
 			public ObsoleteAttribute Obsolete;
 			public string[] Conditionals;
 			public string DefaultIndexerName;
 			public bool IsNotCLSCompliant;
 			public TypeSpec CoClass;
 			
 			public static AttributesBag Read (MemberInfo mi, MetadataImporter importer)
 			{
 				AttributesBag bag = null;
 				List<string> conditionals = null;
 
 				// It should not throw any loading exception
 				IList<CustomAttributeData> attrs = CustomAttributeData.GetCustomAttributes (mi);
 
 				string ns, name;
 				foreach (var a in attrs) {
 					importer.GetCustomAttributeTypeName (a, out ns, out name);
 					if (name == "ObsoleteAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						var args = a.ConstructorArguments;
 
 						if (args.Count == 1) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value);
 						} else if (args.Count == 2) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value, (bool) args[1].Value);
 						} else {
 							bag.Obsolete = new ObsoleteAttribute ();
 						}
 
 						continue;
 					}
 
 					if (name == "ConditionalAttribute") {
 						if (ns != "System.Diagnostics")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						if (conditionals == null)
 							conditionals = new List<string> (2);
 
 						conditionals.Add ((string) a.ConstructorArguments[0].Value);
 						continue;
 					}
 
 					if (name == "CLSCompliantAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						bag.IsNotCLSCompliant = !(bool) a.ConstructorArguments[0].Value;
 						continue;
 					}
 
 					// Type only attributes
 					if (mi.MemberType == MemberTypes.TypeInfo || mi.MemberType == MemberTypes.NestedType) {
 						if (name == "DefaultMemberAttribute") {
 							if (ns != "System.Reflection")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.DefaultIndexerName = (string) a.ConstructorArguments[0].Value;
 							continue;
 						}
 
 						if (name == "AttributeUsageAttribute") {
 							if (ns != "System")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.AttributeUsage = new AttributeUsageAttribute ((AttributeTargets) a.ConstructorArguments[0].Value);
 							foreach (var named in a.NamedArguments) {
 								if (named.MemberInfo.Name == "AllowMultiple")
 									bag.AttributeUsage.AllowMultiple = (bool) named.TypedValue.Value;
 								else if (named.MemberInfo.Name == "Inherited")
 									bag.AttributeUsage.Inherited = (bool) named.TypedValue.Value;
 							}
 							continue;
 						}
 
 						// Interface only attribute
 						if (name == "CoClassAttribute") {
 							if (ns != "System.Runtime.InteropServices")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.CoClass = importer.ImportType ((MetaType) a.ConstructorArguments[0].Value);
 							continue;
 						}
 					}
 				}
 
 				if (bag == null)
 					return Default;
 
 				if (conditionals != null)
 					bag.Conditionals = conditionals.ToArray ();
 				
 				return bag;
 			}
 		}
 
 		protected readonly MemberInfo provider;
 		protected AttributesBag cattrs;
 		protected readonly MetadataImporter importer;
 
 		public ImportedDefinition (MemberInfo provider, MetadataImporter importer)
 		{
 			this.provider = provider;
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7471" endline="7928">
<![CDATA[
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, TypeArguments targs, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, int arity, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			if (alias == GlobalAlias) {
 				expr = ec.Module.GlobalRootNamespace;
 				return base.ResolveAsTypeStep (ec, silent);
 			}
 
 			int errors = ec.Compiler.Report.Errors;
 			expr = ec.LookupNamespaceAlias (alias);
 			if (expr == null) {
 				if (errors == ec.Compiler.Report.Errors)
 					ec.Compiler.Report.Error (432, loc, "Alias `{0}' not found", alias);
 				return null;
 			}
 
 			FullNamedExpression fne = base.ResolveAsTypeStep (ec, silent);
 			if (fne == null)
 				return null;
 
 			if (expr.eclass == ExprClass.Type) {
 				if (!silent) {
 					ec.Compiler.Report.Error (431, loc,
 						"Alias `{0}' cannot be used with '
 				}
 				return null;
 			}
 
 			return fne;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return ResolveAsTypeStep (ec, false);
 		}
 
 		protected override void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			rc.Compiler.Report.Error (687, loc,
 				"A namespace alias qualifier `{0}' did not resolve to a namespace or a type",
 				GetSignatureForError ());
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name = Name;
 			if (targs != null) {
 				name = Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return alias + "
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			return DoResolve (rc);
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing 
 		}
 	}
 
 	/// <summary>
 	///   Implements the member access expression
 	/// </summary>
 	public class MemberAccess 
 	{
 		protected Expression expr;
 
 		public MemberAccess (Expression expr, string id)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, TypeArguments args, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, int arity, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public Expression LeftExpression {
 			get {
 				return expr;
 			}
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return DoResolveName (ec, null);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			return DoResolveName (ec, right_side);
 		}
 
 		Expression DoResolveName (ResolveContext rc, Expression right_side)
 		{
 			Expression e = LookupNameExpression (rc, right_side == null ? MemberLookupRestrictions.ReadAccess 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 					e.Error_UnexpectedKind (rc, ResolveFlags.VariableOrValue, loc);
 					return null;
 				}
 
 				e = e.ResolveLValue (rc, right_side);
 			} else {
 				e = e.Resolve (rc, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 			}
 
 			return e;
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			var sn = expr as SimpleName;
 			const ResolveFlags flags = ResolveFlags.VariableOrValue | ResolveFlags.Type;
 
 			//
 			// Resolve the expression with flow analysis turned off, we'll do the definite
 			// assignment checks later.  This is because we don't know yet what the expression
 			// will resolve to - it may resolve to a FieldExpr and in this case we must do the
 			// definite assignment check on the actual field and not on the whole struct.
 			//
 			using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 				if (sn != null) {
 					expr = sn.LookupNameExpression (rc, MemberLookupRestrictions.ReadAccess | MemberLookupRestrictions.ExactArity);
 
 					// Call resolve on expression which does have type set as we need expression type
 					// TODO
 					if (expr is VariableReference || expr is ConstantExpr || expr is Linq.TransparentMemberAccess) {
 						using (rc.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 							expr = expr.Resolve (rc);
 						}
 					} else if (expr is TypeParameterExpr) {
 						expr.Error_UnexpectedKind (rc, flags, sn.Location);
 						expr = null;
 					}
 				} else {
 					expr = expr.Resolve (rc, flags);
 				}
 			}
 
 			if (expr == null)
 				return null;
 
 			Namespace ns = expr as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 					return null;
 				}
 
 				if (HasTypeArguments)
 					return new GenericTypeExpr (retval.Type, targs, loc);
 
 				return retval;
 			}
 
 			MemberExpr me;
 			TypeSpec expr_type = expr.Type;
 			if (expr_type == InternalType.Dynamic) {
 				me = expr as MemberExpr;
 				if (me != null)
 					me.ResolveInstanceExpression (rc, null);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new DynamicMemberBinder (Name, args, loc);
 			}
 
 			const MemberKind dot_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.Delegate | MemberKind.Enum |
 				MemberKind.Interface | MemberKind.TypeParameter | MemberKind.ArrayType;
 
 			if ((expr_type.Kind & dot_kinds) == 0 || expr_type == TypeManager.void_type) {
 				if (expr_type == InternalType.Null && rc.Compiler.IsRuntimeBinder)
 					rc.Report.Error (Report.RuntimeErrorId, loc, "Cannot perform member binding on `null' value");
 				else
 					Unary.Error_OperatorCannotBeApplied (rc, loc, ".", expr_type);
 				return null;
 			}
 
 			var current_type = rc.CurrentType;
 			var lookup_arity = Arity;
 			bool errorMode = false;
 			Expression member_lookup;
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 
 			TypeExpr texpr = member_lookup as TypeExpr;
 			if (texpr != null) {
 				if (!(expr is TypeExpr)) {
 					me = expr as MemberExpr;
 					if (me == null || me.ProbeIdenticalTypeName (rc, expr, sn) == expr) {
 						rc.Report.Error (572, loc, "`{0}'
 							Name, member_lookup.GetSignatureForError ());
 						return null;
 					}
 				}
 
 				if (!texpr.Type.IsAccessible (rc.CurrentType)) {
 					rc.Report.SymbolRelatedToPreviousError (member_lookup.Type);
 					ErrorIsInaccesible (rc, member_lookup.Type.GetSignatureForError (), loc);
 					return null;
 				}
 
 				if (HasTypeArguments) {
 					return new GenericTypeExpr (member_lookup.Type, targs, loc);
 				}
 
 				return member_lookup;
 			}
 
 			me = member_lookup as MemberExpr;
 
 			if (sn != null && me.IsStatic)
 				expr = me.ProbeIdenticalTypeName (rc, expr, sn);
 
 			me = me.ResolveMemberAccess (rc, expr, sn);
 
 			if (Arity > 0) {
 				if (!targs.Resolve (rc))
 					return null;
 
 				me.SetTypeArguments (rc, targs);
 			}
 
 			if (sn != null && (!TypeManager.IsValueType (expr_type) || me is PropertyExpr)) {
 				if (me.IsInstance) {
 					LocalVariableReference var = expr as LocalVariableReference;
 					if (var != null && !var.VerifyAssigned (rc))
 						return null;
 				}
 			}
 
 			return me;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			return ResolveNamespaceOrType (ec, silent);
 		}
 
 		public FullNamedExpression ResolveNamespaceOrType (IMemberContext rc, bool silent)
 		{
 			FullNamedExpression expr_resolved = expr.ResolveAsTypeStep (rc, silent);
 
 			if (expr_resolved == null)
 				return null;
 
 			Namespace ns = expr_resolved as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					if (!silent)
 						ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 				} else if (HasTypeArguments) {
 					retval = new GenericTypeExpr (retval.Type, targs, loc).ResolveAsTypeStep (rc, silent);
 				}
 
 				return retval;
 			}
 
 			TypeExpr tnew_expr = expr_resolved.ResolveAsTypeTerminal (rc, false);
 			if (tnew_expr == null)
 				return null;
 
 			TypeSpec expr_type = tnew_expr.Type;
 			if (TypeManager.IsGenericParameter (expr_type)) {
 				rc.Compiler.Report.Error (704, loc, "A nested type cannot be specified through a type parameter `{0}'",
 					tnew_expr.GetSignatureForError ());
 				return null;
 			}
 
 			TypeSpec nested = null;
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			
 			TypeExpr texpr;
 			if (Arity > 0) {
 				if (HasTypeArguments) {
 					texpr = new GenericTypeExpr (nested, targs, loc);
 				} else {
 					texpr = new GenericOpenTypeExpr (nested, loc);
 				}
 			} else {
 				texpr = new TypeExpression (nested, loc);
 			}
 
 			return texpr.ResolveAsTypeStep (rc, false);
 		}
 
 		protected virtual void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			var nested = MemberCache.FindNestedType (expr_type, Name, -System.Math.Max (1, Arity));
 
 			if (nested != null) {
 				Error_TypeArgumentsCannotBeUsed (rc.Compiler.Report, expr.Location, nested, Arity);
 				return;
 			}
 
 			var any_other_member = MemberLookup (null, rc.CurrentType, expr_type, Name, 0, MemberLookupRestrictions.None, loc);
 			if (any_other_member != null) {
 				any_other_member.Error_UnexpectedKind (rc.Compiler.Report, null, "type", loc);
 				return;
 			}
 
 			rc.Compiler.Report.Error (426, loc, "The nested type `{0}' does not exist in the type `{1}'",
 				Name, expr_type.GetSignatureForError ());
 		}
 
 		protected override void Error_TypeDoesNotContainDefinition (ResolveContext ec, TypeSpec type, string name)
 		{
 			if (RootContext.Version > LanguageVersion.ISO_2 && !ec.Compiler.IsRuntimeBinder && MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (1061, loc,
 					"Type `{0}' does not contain a definition for `{1}' and no extension method `{1}' of type `{0}' could be found (are you missing a using directive or an assembly reference?)",
 					type.GetSignatureForError (), name);
 				return;
 			}
 
 			base.Error_TypeDoesNotContainDefinition (ec, type, name);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return expr.GetSignatureForError () + "." + base.GetSignatureForError ();
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	/// <summary>
 	///   Implements checked expressions
 	/// </summary>
 	public class CheckedExpr 
 
 		public Expression Expr;
 
 		public CheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7977" endline="7990">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the unchecked expression
 	/// </summary>
 	public class UnCheckedExpr 
 
 		public Expression Expr;
 
 		public UnCheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1306" endline="1318">
<![CDATA[
 	}
 
 	public class ImportedModuleDefinition
 	{
 		readonly Module module;
 		bool cls_compliant;
 		readonly MetadataImporter importer;
 		
 		public ImportedModuleDefinition (Module module, MetadataImporter importer)
 		{
 			this.module = module;
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8157" endline="8176">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements array access 
 	/// </summary>
 	public class ArrayAccess 
 		//
 		// Points to our "data" repository
 		//
 		ElementAccess ea;
 
 		LocalTemporary temp, expr_copy;
 		Expression[] prepared_arguments;
 		bool prepared;
 		
 		public ArrayAccess (ElementAccess ea_data, Location l)
 		{
 			ea = ea_data;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9317" endline="9334">
<![CDATA[
 	}
 	
 	//
 	// A block of object or collection initializers
 	//
 	public class CollectionOrObjectInitializers 
 	{
 		IList<Expression> initializers;
 		bool is_collection_initialization;
 		
 		public static readonly CollectionOrObjectInitializers Empty = 
 			new CollectionOrObjectInitializers (Array.AsReadOnly (new Expression [0]), Location.Null);
 
 		public CollectionOrObjectInitializers (IList<Expression> initializers, Location loc)
 		{
 			this.initializers = initializers;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="192" endline="695">
<![CDATA[
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
 
 		#region Properties
 
 		public DefaultParameterValueExpression DefaultValue {
 			get {
 				return default_expr as DefaultParameterValueExpression;
 			}
 			set {
 				default_expr = value;
 			}
 		}
 
 		Expression IParameterData.DefaultValue {
 			get {
 				var expr = default_expr as DefaultParameterValueExpression;
 				return expr == null ? default_expr 
 			}
 		}
 
 		bool HasOptionalExpression {
 			get {
 				return default_expr is DefaultParameterValueExpression;
 			}
 		}
 
 		public Location Location {
 			get {
 				return loc;
 			}
 		}
 
 		public TypeSpec Type {
 			get {
 				return parameter_type;
 			}
 		}
 
 		public FullNamedExpression TypeExpression  {
 			get {
 				return texpr;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.In && ModFlags == Modifier.OUT) {
 				a.Report.Error (36, a.Location, "An out parameter cannot have the `In' attribute");
 				return;
 			}
 
 			if (a.Type == pa.ParamArray) {
 				a.Report.Error (674, a.Location, "Do not use `System.ParamArrayAttribute'. Use the `params' keyword instead");
 				return;
 			}
 
 			if (a.Type == pa.Out && (ModFlags & Modifier.REF) == Modifier.REF &&
 			    !OptAttributes.Contains (pa.In)) {
 				a.Report.Error (662, a.Location,
 					"Cannot specify only `Out' attribute on a ref parameter. Use both `In' and `Out' attributes or neither");
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				a.Report.Warning (3022, 1, a.Location, "CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead");
 			}
 
 			if (a.Type == pa.DefaultParameterValue || a.Type == pa.OptionalParameter) {
 				if (HasOptionalExpression) {
 					a.Report.Error (1745, a.Location,
 						"Cannot specify `{0}' attribute on optional parameter `{1}'",
 						TypeManager.CSharpName (a.Type).Replace ("Attribute", ""), Name);
 				}
 
 				if (a.Type == pa.DefaultParameterValue)
 					return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 		
 		public virtual bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			if (parameter_type == null)
 				return true;
 
 			return member.IsAccessibleAs (parameter_type);
 		}
 
 		public static void Reset ()
 		{
 			parameter_expr_tree_type = null;
 		}
 
 		// <summary>
 		//   Resolve is used in method definitions
 		// </summary>
 		public virtual TypeSpec Resolve (IMemberContext rc, int index)
 		{
 			if (parameter_type != null)
 				return parameter_type;
 
 			if (attributes != null)
 				attributes.AttachTo (this, rc);
 
 			var expr = texpr.ResolveAsTypeTerminal (rc, false);
 			if (expr == null)
 				return null;
 
 			this.idx = index;
 			texpr = expr;
 			parameter_type = texpr.Type;
 	
 			if ((modFlags & Parameter.Modifier.ISBYREF) != 0 &&
 				TypeManager.IsSpecialType (parameter_type)) {
 				rc.Compiler.Report.Error (1601, Location, "Method or delegate parameter cannot be of type `{0}'",
 					GetSignatureForError ());
 				return null;
 			}
 
 			TypeManager.CheckTypeVariance (parameter_type,
 				(modFlags & Parameter.Modifier.ISBYREF) != 0 ? Variance.None 
 				rc);
 
 			if (parameter_type.IsStatic) {
 				rc.Compiler.Report.Error (721, Location, "`{0}'
 					texpr.GetSignatureForError ());
 				return parameter_type;
 			}
 
 			if ((modFlags & Modifier.This) != 0 && (parameter_type.IsPointer || parameter_type == InternalType.Dynamic)) {
 				rc.Compiler.Report.Error (1103, Location, "The extension method cannot be of type `{0}'",
 					TypeManager.CSharpName (parameter_type));
 			}
 
 			return parameter_type;
 		}
 
 		public void ResolveDefaultValue (ResolveContext rc)
 		{
 			//
 			// Default value was specified using an expression
 			//
 			if (default_expr != null) {
 				((DefaultParameterValueExpression)default_expr).Resolve (rc, this);
 				return;
 			}
 
 			if (attributes == null)
 				return;
 			
 			var opt_attr = attributes.Search (rc.Module.PredefinedAttributes.OptionalParameter);
 			var def_attr = attributes.Search (rc.Module.PredefinedAttributes.DefaultParameterValue);
 			if (def_attr != null) {
 				if (def_attr.Resolve () == null)
 					return;
 
 				var default_expr_attr = def_attr.GetParameterDefaultValue ();
 				if (default_expr_attr == null)
 					return;
 
 				var dpa_rc = def_attr.CreateResolveContext ();
 				default_expr = default_expr_attr.Resolve (dpa_rc);
 
 				if (default_expr is BoxedCast)
 					default_expr = ((BoxedCast) default_expr).Child;
 
 				Constant c = default_expr as Constant;
 				if (c == null) {
 					if (parameter_type == TypeManager.object_type) {
 						rc.Compiler.Report.Error (1910, default_expr.Location,
 							"Argument of type `{0}' is not applicable for the DefaultParameterValue attribute",
 							default_expr.Type.GetSignatureForError ());
 					} else {
 						rc.Compiler.Report.Error (1909, default_expr.Location,
 							"The DefaultParameterValue attribute is not applicable on parameters of type `{0}'",
 							default_expr.Type.GetSignatureForError ()); ;
 					}
 
 					default_expr = null;
 					return;
 				}
 
 				if (TypeSpecComparer.IsEqual (default_expr.Type, parameter_type) ||
 					(default_expr is NullConstant && TypeManager.IsReferenceType (parameter_type) && !parameter_type.IsGenericParameter) ||
 					TypeSpecComparer.IsEqual (parameter_type, TypeManager.object_type)) {
 					return;
 				}
 
 				//
 				// LAMESPEC
 				// User operators returning same type as parameter type are considered
 				// valid for this attribute only
 				//
 				// struct S { public static implicit operator S (int i) {} }
 				//
 				// void M ([DefaultParameterValue (3)]S s)
 				//
 				var expr = Convert.ImplicitUserConversion (dpa_rc, default_expr, parameter_type, loc);
 				if (expr != null && TypeSpecComparer.IsEqual (expr.Type, parameter_type)) {
 					return;
 				}
 				
 				rc.Compiler.Report.Error (1908, default_expr.Location, "The type of the default value should match the type of the parameter");
 				return;
 			}
 
 			if (opt_attr != null) {
 				default_expr = EmptyExpression.MissingValue;
 			}
 		}
 
 		public bool HasDefaultValue {
 			get { return default_expr != null; }
 		}
 
 		public bool HasExtensionMethodModifier {
 			get { return (modFlags & Modifier.This) != 0; }
 		}
 
 		//
 		// Hoisted parameter variant
 		//
 		public HoistedVariable HoistedVariant {
 			get {
 				return hoisted_variant;
 			}
 			set {
 				hoisted_variant = value;
 			}
 		}
 
 		public Modifier ModFlags {
 			get { return modFlags & ~Modifier.This; }
 		}
 
 		public string Name {
 			get { return name; }
 			set { name = value; }
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Parameter;
 			}
 		}
 
 		public virtual string GetSignatureForError ()
 		{
 			string type_name;
 			if (parameter_type != null)
 				type_name = TypeManager.CSharpName (parameter_type);
 			else
 				type_name = texpr.GetSignatureForError ();
 
 			string mod = GetModifierSignature (modFlags);
 			if (mod.Length > 0)
 				return String.Concat (mod, " ", type_name);
 
 			return type_name;
 		}
 
 		public static string GetModifierSignature (Modifier mod)
 		{
 			switch (mod) {
 			case Modifier.OUT
 				return "out";
 			case Modifier.PARAMS
 				return "params";
 			case Modifier.REF
 				return "ref";
 			case Modifier.This
 				return "this";
 			default
 				return "";
 			}
 		}
 
 		public void IsClsCompliant (IMemberContext ctx)
 		{
 			if (parameter_type.IsCLSCompliant ())
 				return;
 
 			ctx.Compiler.Report.Warning (3001, 1, Location,
 				"Argument type `{0}' is not CLS-compliant", parameter_type.GetSignatureForError ());
 		}
 
 		public virtual void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			if (builder != null)
 				throw new InternalErrorException ("builder already exists");
 
 			var pattrs = ParametersCompiled.GetParameterAttribute (modFlags);
 			if (HasOptionalExpression)
 				pattrs |= ParameterAttributes.Optional;
 
 			if (mb == null)
 				builder = cb.DefineParameter (index, pattrs, Name);
 			else
 				builder = mb.DefineParameter (index, pattrs, Name);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (HasDefaultValue) {
 				//
 				// Emit constant values for true constants only, the other
 				// constant-like expressions will rely on default value expression
 				//
 				var def_value = DefaultValue;
 				Constant c = def_value != null ? def_value.Child as Constant 
 				if (c != null) {
 					if (default_expr.Type == TypeManager.decimal_type) {
 						pa.DecimalConstant.EmitAttribute (builder, (decimal) c.GetValue (), c.Location);
 					} else {
 						builder.SetConstant (c.GetValue ());
 					}
 				} else if (default_expr.Type.IsStruct) {
 					//
 					// Handles special case where default expression is used with value-type
 					//
 					// void Foo (S s = default (S)) {}
 					//
 					builder.SetConstant (null);
 				}
 			}
 
 			if (parameter_type != null) {
 				if (parameter_type == InternalType.Dynamic) {
 					pa.Dynamic.EmitAttribute (builder);
 				} else if (parameter_type.HasDynamicElement) {
 					pa.Dynamic.EmitAttribute (builder, parameter_type, Location);
 				}
 			}
 		}
 
 		public Parameter Clone ()
 		{
 			Parameter p = (Parameter) MemberwiseClone ();
 			if (attributes != null)
 				p.attributes = attributes.Clone ();
 
 			return p;
 		}
 
 		public ExpressionStatement CreateExpressionTreeVariable (BlockContext ec)
 		{
 			if ((modFlags & Modifier.ISBYREF) != 0)
 				ec.Report.Error (1951, Location, "An expression tree parameter cannot use `ref' or `out' modifier");
 
 			expr_tree_variable = TemporaryVariableReference.Create (ResolveParameterExpressionType (ec, Location).Type, ec.CurrentBlock.ParametersBlock, Location);
 			expr_tree_variable = (TemporaryVariableReference) expr_tree_variable.Resolve (ec);
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (new TypeOf (
 				new TypeExpression (parameter_type, Location), Location)));
 			arguments.Add (new Argument (new StringConstant (Name, Location)));
 			return new SimpleAssign (ExpressionTreeVariableReference (),
 				Expression.CreateExpressionFactoryCall (ec, "Parameter", null, arguments, Location));
 		}
 
 		public void Emit (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			ParameterReference.EmitLdArg (ec, arg_idx);
 		}
 
 		public void EmitAssign (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			if (arg_idx <= 255)
 				ec.Emit (OpCodes.Starg_S, (byte) arg_idx);
 			else
 				ec.Emit (OpCodes.Starg, arg_idx);
 		}
 
 		public void EmitAddressOf (EmitContext ec)
 		{
 			int arg_idx = idx;
 
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			bool is_ref = (ModFlags & Modifier.ISBYREF) != 0;
 			if (is_ref) {
 				ParameterReference.EmitLdArg (ec, arg_idx);
 			} else {
 				if (arg_idx <= 255)
 					ec.Emit (OpCodes.Ldarga_S, (byte) arg_idx);
 				else
 					ec.Emit (OpCodes.Ldarga, arg_idx);
 			}
 		}
 
 		public TemporaryVariableReference ExpressionTreeVariableReference ()
 		{
 			return expr_tree_variable;
 		}
 
 		//
 		// System.Linq.Expressions.ParameterExpression type
 		//
 		public static TypeExpr ResolveParameterExpressionType (IMemberContext ec, Location location)
 		{
 			if (parameter_expr_tree_type != null)
 				return parameter_expr_tree_type;
 
 			TypeSpec p_type = ec.Module.PredefinedTypes.ParameterExpression.Resolve (location);
 			parameter_expr_tree_type = new TypeExpression (p_type, location).
 				ResolveAsTypeTerminal (ec, false);
 
 			return parameter_expr_tree_type;
 		}
 
 		public void Warning_UselessOptionalParameter (Report Report)
 		{
 			Report.Warning (1066, 1, Location,
 				"The default value specified for optional parameter `{0}' will never be used",
 				Name);
 		}
 	}
 
 	//
 	// Imported or resolved parameter information
 	//
 	public class ParameterData 
 	{
 		readonly string name;
 		readonly Parameter.Modifier modifiers;
 		readonly Expression default_value;
 
 		public ParameterData (string name, Parameter.Modifier modifiers)
 		{
 			this.name = name;
 			this.modifiers = modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8826" endline="8842">
<![CDATA[
 	}
 
 	//
 	// Holds additional type specifiers like ?, *, []
 	//
 	public class ComposedTypeSpecifier
 	{
 		public static readonly ComposedTypeSpecifier SingleDimension = new ComposedTypeSpecifier (1, Location.Null);
 
 		public readonly int Dimension;
 		public readonly Location Location;
 
 		public ComposedTypeSpecifier (int specifier, Location loc)
 		{
 			this.Dimension = specifier;
 			this.Location = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5408" endline="5579">
<![CDATA[
 	}
 
 	abstract class PropertyOrIndexerExpr<T> 
 	{
 		// getter and setter can be different for base calls
 		MethodSpec getter, setter;
 		protected T best_candidate;
 
 		protected LocalTemporary temp;
 		protected bool prepared;
 
 		protected PropertyOrIndexerExpr (Location l)
 		{
 			loc = l;
 		}
 
 		#region Properties
 
 		public MethodSpec Getter {
 			get {
 				return getter;
 			}
 			set {
 				getter = value;
 			}
 		}
 
 		public MethodSpec Setter {
 			get {
 				return setter;
 			}
 			set {
 				setter = value;
 			}
 		}
 
 		#endregion
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, null);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.Resolve (ec);
 			}
 
 			if (!ResolveGetter (ec))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				// TODO
 				INamedBlockVariable variable = null;
 				if (best_candidate != null && ec.CurrentBlock.ParametersBlock.TopBlock.GetLocalName (best_candidate.Name, ec.CurrentBlock, ref variable) && variable is Linq.RangeVariable) {
 					ec.Report.Error (1939, loc, "A range variable `{0}' may not be passes as `ref' or `out' parameter",
 						best_candidate.Name);
 				} else {
 					right_side.DoResolveLValue (ec, this);
 				}
 				return null;
 			}
 
 			// if the property/indexer returns a value type, and we try to set a field in it
 			if (right_side == EmptyExpression.LValueMemberAccess || right_side == EmptyExpression.LValueMemberOutAccess) {
 				Error_CannotModifyIntermediateExpressionValue (ec);
 			}
 
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, right_side);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.ResolveLValue (ec, right_side);
 			}
 
 			if (!ResolveSetter (ec))
 				return null;
 
 			return this;
 		}
 
 		//
 		// Implements the IAssignMethod interface for assignments
 		//
 		public abstract void Emit (EmitContext ec, bool leave_copy);
 		public abstract void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load);
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public abstract SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source);
 
 		protected abstract Expression OverloadResolve (ResolveContext rc, Expression right_side);
 
 		bool ResolveGetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasGet) {
 				if (InstanceExpression != EmptyExpression.Null) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate);
 					rc.Report.Error (154, loc, "The property or indexer `{0}' cannot be used in this context because it lacks the `get' accessor",
 						best_candidate.GetSignatureForError ());
 					return false;
 				}
 			} else if (!best_candidate.Get.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					rc.Report.Error (271, loc, "The property or indexer `{0}' cannot be used in this context because the get accessor is inaccessible",
 						TypeManager.CSharpSignature (best_candidate));
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					ErrorIsInaccesible (rc, best_candidate.Get.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility) {
 				CheckProtectedMemberAccess (rc, best_candidate.Get);
 			}
 
 			getter = CandidateToBaseOverride (rc, best_candidate.Get);
 			return true;
 		}
 
 		bool ResolveSetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasSet) {
 				rc.Report.Error (200, loc, "Property or indexer `{0}' cannot be assigned to (it is read-only)",
 					GetSignatureForError ());
 				return false;
 			}
 
 			if (!best_candidate.Set.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					rc.Report.Error (272, loc, "The property or indexer `{0}' cannot be used in this context because the set accessor is inaccessible",
 						GetSignatureForError ());
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					ErrorIsInaccesible (rc, best_candidate.Set.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility)
 				CheckProtectedMemberAccess (rc, best_candidate.Set);
 
 			setter = CandidateToBaseOverride (rc, best_candidate.Set);
 			return true;
 		}
 	}
 
 	/// <summary>
 	///   Fully resolved expression that evaluates to an Event
 	/// </summary>
 	public class EventExpr 
 	{
 		readonly EventSpec spec;
 		MethodSpec op;
 
 		public EventExpr (EventSpec spec, Location loc)
 		{
 			this.spec = spec;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="60" endline="69">
<![CDATA[
 	}
 	
 	public class CompletionSimpleName 
 		public string Prefix;
 		
 		public CompletionSimpleName (string prefix, Location l)
 		{
 			this.loc = l;
 			this.Prefix = prefix;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="150" endline="174">
<![CDATA[
 				AppendResults (results, partial_name, r);
 			}
 
 			throw new CompletionResult (partial_name == null ? "" 
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompletionMemberAccess target = (CompletionMemberAccess) t;
 
 			if (targs != null)
 				target.targs = targs.Clone ();
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	public class CompletionElementInitializer 
 		string partial_name;
 		
 		public CompletionElementInitializer (string partial_name, Location l)
 		{
 			this.partial_name = partial_name;
 			this.loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4628" endline="4642">
<![CDATA[
 	}
 
 	public class Catch 
 	{
 		Block block;
 		LocalVariable li;
 		FullNamedExpression type_expr;
 		CompilerAssign assign;
 		TypeSpec type;
 		
 		public Catch (Block block, Location loc)
 		{
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2979" endline="4697">
<![CDATA[
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
 
 		public MethodGroupExpr (MethodSpec m, TypeSpec type, Location loc)
 			
 		{
 		}
 
 		#region Properties
 
 		public MethodSpec BestCandidate {
 			get {
 				return best_candidate;
 			}
 		}
 
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return;
 			}
 		}
 
 		protected override TypeSpec DeclaringType {
 			get {
 				return queried_type;
 			}
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override string Name {
 			get {
 				if (best_candidate != null)
 					return best_candidate.Name;
 
 				// TODO
 				return Methods.First ().Name;
 			}
 		}
 
 		#endregion
 
 		//
 		// When best candidate is already know this factory can be used
 		// to avoid expensive overload resolution to be called
 		//
 		// NOTE
 		//
 		public static MethodGroupExpr CreatePredefined (MethodSpec best, TypeSpec queriedType, Location loc)
 		{
 			return new MethodGroupExpr (best, queriedType, loc) {
 				best_candidate = best,
 				best_candidate_return = best.ReturnType
 			};
 		}
 
 		public override string GetSignatureForError ()
 		{
 			if (best_candidate != null)
 				return best_candidate.GetSignatureForError ();
 
 			return Methods.First ().GetSignatureForError ();
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (best_candidate == null) {
 				ec.Report.Error (1953, loc, "An expression tree cannot contain an expression with method group");
 				return null;
 			}
 
 			if (best_candidate.IsConditionallyExcluded (loc))
 				ec.Report.Error (765, loc,
 					"Partial methods with only a defining declaration or removed conditional methods cannot be used in an expression tree");
 			
 			return new TypeOfMethod (best_candidate, loc);
 		}
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			this.eclass = ExprClass.MethodGroup;
 
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (ec);
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotSupportedException ();
 		}
 		
 		public void EmitCall (EmitContext ec, Arguments arguments)
 		{
 			Invocation.EmitCall (ec, InstanceExpression, best_candidate, arguments, loc);			
 		}
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			ec.Report.Error (428, loc, "Cannot convert method group `{0}' to non-delegate type `{1}'. Consider using parentheses to invoke the method",
 				Name, TypeManager.CSharpName (target));
 		}
 
 		public static bool IsExtensionMethodArgument (Expression expr)
 		{
 			//
 			// LAMESPEC
 			//
 			return !(expr is TypeExpr) && !(expr is BaseThis);
 		}
 
 		/// <summary>
 		///   Find the Applicable Function Members (7.4.2.1)
 		///
 		///   me
 		///       it might contain constructors or methods (or anything
 		///       that maps to a method).
 		///
 		///   Arguments
 		///
 		///   loc
 		///        location for "probing" purposes.
 		///
 		///   Returns
 		///            that is the best match of me on Arguments.
 		///
 		/// </summary>
 		public virtual MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments args, OverloadResolver.IErrorHandler cerrors, OverloadResolver.Restrictions restr)
 		{
 			// TODO
 			if (best_candidate != null && best_candidate.Kind == MemberKind.Destructor)
 				return this;
 
 			var r = new OverloadResolver (Methods, type_arguments, restr, loc);
 			if ((restr & OverloadResolver.Restrictions.NoBaseMembers) == 0) {
 				r.BaseMembersProvider = this;
 			}
 
 			if (cerrors != null)
 				r.CustomErrors = cerrors;
 
 			// TODO
 			best_candidate = r.ResolveMember<MethodSpec> (ec, ref args);
 			if (best_candidate == null)
 				return r.BestCandidateIsDynamic ? this 
 
 			// Overload resolver had to create a new method group, all checks bellow have already been executed
 			if (r.BestCandidateNewMethodGroup != null)
 				return r.BestCandidateNewMethodGroup;
 
 			if (best_candidate.Kind == MemberKind.Method && (restr & OverloadResolver.Restrictions.ProbingOnly) == 0) {
 				if (InstanceExpression != null) {
 					if (best_candidate.IsExtensionMethod && args[0].Expr == InstanceExpression) {
 						InstanceExpression = null;
 					} else {
 						if (best_candidate.IsStatic && simple_name != null) {
 							InstanceExpression = ProbeIdenticalTypeName (ec, InstanceExpression, simple_name);
 						}
 
 						InstanceExpression.Resolve (ec);
 					}
 				}
 
 				ResolveInstanceExpression (ec, null);
 				if (InstanceExpression != null)
 					CheckProtectedMemberAccess (ec, best_candidate);
 			}
 
 			var base_override = CandidateToBaseOverride (ec, best_candidate);
 			if (base_override == best_candidate) {
 				best_candidate_return = r.BestCandidateReturnType;
 			} else {
 				best_candidate = base_override;
 				best_candidate_return = best_candidate.ReturnType;
 			}
 
 			return this;
 		}
 
 		public override MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			simple_name = original;
 			return base.ResolveMemberAccess (ec, left, original);
 		}
 
 		public override void SetTypeArguments (ResolveContext ec, TypeArguments ta)
 		{
 			type_arguments = ta;
 		}
 
 		#region IBaseMembersProvider Members
 
 		public virtual IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
 
 		public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			return MemberCache.FindMember (queried_type, new MemberFilter ((MethodSpec) member),
 				BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
 
 		//
 		// Extension methods lookup after ordinary methods candidates failed to apply
 		//
 		public virtual MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			if (InstanceExpression == null)
 				return null;
 
 			InstanceExpression = InstanceExpression.Resolve (rc);
 			if (!IsExtensionMethodArgument (InstanceExpression))
 				return null;
 
 			int arity = type_arguments == null ? 0 
 			NamespaceEntry methods_scope = null;
 			var methods = rc.LookupExtensionMethod (InstanceExpression.Type, Methods[0].Name, arity, ref methods_scope);
 			if (methods == null)
 				return null;
 
 			var emg = new ExtensionMethodGroupExpr (methods, methods_scope, InstanceExpression, loc);
 			emg.SetTypeArguments (rc, type_arguments);
 			return emg;
 		}
 
 		#endregion
 	}
 
 	public struct OverloadResolver
 	{
 		[Flags]
 		public enum Restrictions
 		{
 			None = 0,
 			DelegateInvoke = 1,
 			ProbingOnly	= 1 << 1,
 			CovariantDelegate = 1 << 2,
 			NoBaseMembers = 1 << 3,
 			BaseMembersIncluded = 1 << 4
 		}
 
 		public interface IBaseMembersProvider
 		{
 			IList<MemberSpec> GetBaseMembers (TypeSpec baseType);
 			IParametersMember GetOverrideMemberParameters (MemberSpec member);
 			MethodGroupExpr LookupExtensionMethod (ResolveContext rc);
 		}
 
 		public interface IErrorHandler
 		{
 			bool AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous);
 			bool ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument a, int index);
 			bool NoArgumentMatch (ResolveContext rc, MemberSpec best);
 			bool TypeInferenceFailed (ResolveContext rc, MemberSpec best);
 		}
 
 		sealed class NoBaseMembers 
 		{
 			public static readonly IBaseMembersProvider Instance = new NoBaseMembers ();
 
 			public IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 			{
 				return null;
 			}
 
 			public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 			{
 				return null;
 			}
 
 			public MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 			{
 				return null;
 			}
 		}
 
 		struct AmbiguousCandidate
 		{
 			public readonly MemberSpec Member;
 			public readonly bool Expanded;
 			public readonly AParametersCollection Parameters;
 
 			public AmbiguousCandidate (MemberSpec member, AParametersCollection parameters, bool expanded)
 			{
 				Member = member;
 				Parameters = parameters;
 				Expanded = expanded;
 			}
 		}
 
 		Location loc;
 		IList<MemberSpec> members;
 		TypeArguments type_arguments;
 		IBaseMembersProvider base_provider;
 		IErrorHandler custom_errors;
 		Restrictions restrictions;
 		MethodGroupExpr best_candidate_extension_group;
 		TypeSpec best_candidate_return_type;
 
 		SessionReportPrinter lambda_conv_msgs;
 		ReportPrinter prev_recorder;
 
 		public OverloadResolver (IList<MemberSpec> members, Restrictions restrictions, Location loc)
 			
 		{
 		}
 
 		public OverloadResolver (IList<MemberSpec> members, TypeArguments targs, Restrictions restrictions, Location loc)
 			
 		{
 			if (members == null || members.Count == 0)
 				throw new ArgumentException ("empty members set");
 
 			this.members = members;
 			this.loc = loc;
 			type_arguments = targs;
 			this.restrictions = restrictions;
 			if (IsDelegateInvoke)
 				this.restrictions |= Restrictions.NoBaseMembers;
 
 			base_provider = NoBaseMembers.Instance;
 		}
 
 		#region Properties
 
 		public IBaseMembersProvider BaseMembersProvider {
 			get {
 				return base_provider;
 			}
 			set {
 				base_provider = value;
 			}
 		}
 
 		public bool BestCandidateIsDynamic { get; set; }
 
 		//
 		// Best candidate was found in newly created MethodGroupExpr, used by extension methods
 		//
 		public MethodGroupExpr BestCandidateNewMethodGroup {
 			get {
 				return best_candidate_extension_group;
 			}
 		}
 
 		//
 		// Return type can be different between best candidate and closest override
 		//
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return_type;
 			}
 		}
 
 		public IErrorHandler CustomErrors {
 			get {
 				return custom_errors;
 			}
 			set {
 				custom_errors = value;
 			}
 		}
 
 		TypeSpec DelegateType {
 			get {
 				if ((restrictions & Restrictions.DelegateInvoke) == 0)
 					throw new InternalErrorException ("Not running in delegate mode", loc);
 
 				return members [0].DeclaringType;
 			}
 		}
 
 		bool IsProbingOnly {
 			get {
 				return (restrictions & Restrictions.ProbingOnly) != 0;
 			}
 		}
 
 		bool IsDelegateInvoke {
 			get {
 				return (restrictions & Restrictions.DelegateInvoke) != 0;
 			}
 		}
 
 		#endregion
 
 		//
 		//  7.4.3.3  Better conversion from expression
 		//  Returns 
 		//              2    if a->q is better,
 		//              0 if neither is better
 		//
 		static int BetterExpressionConversion (ResolveContext ec, Argument a, TypeSpec p, TypeSpec q)
 		{
 			TypeSpec argument_type = a.Type;
 
 			//
 			// If argument is an anonymous function
 			//
 			if (argument_type == InternalType.AnonymousMethod && RootContext.Version > LanguageVersion.ISO_2) {
 				//
 				// p and q are delegate types or expression tree types
 				//
 				if (p.GetDefinition () == TypeManager.expression_type || q.GetDefinition () == TypeManager.expression_type) {
 					if (q.MemberDefinition != p.MemberDefinition) {
 						return 0;
 					}
 
 					//
 					// Uwrap delegate from Expression<T>
 					//
 					q = TypeManager.GetTypeArguments (q)[0];
 					p = TypeManager.GetTypeArguments (p)[0];
 				}
 
 				var p_m = Delegate.GetInvokeMethod (ec.Compiler, p);
 				var q_m = Delegate.GetInvokeMethod (ec.Compiler, q);
 
 				//
 				// With identical parameter lists
 				//
 				if (!TypeSpecComparer.Equals (p_m.Parameters.Types,q_m.Parameters.Types))
 					return 0;
 
 				p = p_m.ReturnType;
 				q = q_m.ReturnType;
 
 				//
 				// if p is void returning, and q has a return type Y, then C2 is the better conversion.
 				//
 				if (p == TypeManager.void_type) {
 					return q != TypeManager.void_type ? 2 
 				}
 
 				//
 				// if p has a return type Y, and q is void returning, then C1 is the better conversion.
 				//
 				if (q == TypeManager.void_type) {
 					return p != TypeManager.void_type ? 1
 				}
 			} else {
 				if (argument_type == p)
 					return 1;
 
 				if (argument_type == q)
 					return 2;
 			}
 
 			return BetterTypeConversion (ec, p, q);
 		}
 
 		//
 		// 7.4.3.4  Better conversion from type
 		//
 		public static int BetterTypeConversion (ResolveContext ec, TypeSpec p, TypeSpec q)
 		{
 			if (p == null || q == null)
 				throw new InternalErrorException ("BetterTypeConversion got a null conversion");
 
 			if (p == TypeManager.int32_type) {
 				if (q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.int64_type) {
 				if (q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.sbyte_type) {
 				if (q == TypeManager.byte_type || q == TypeManager.ushort_type ||
 					q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.short_type) {
 				if (q == TypeManager.ushort_type || q == TypeManager.uint32_type ||
 					q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 2;
 			}
 
 			if (q == TypeManager.int32_type) {
 				if (p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.int64_type) {
 				if (p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == TypeManager.sbyte_type) {
 				if (p == TypeManager.byte_type || p == TypeManager.ushort_type ||
 					p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.short_type) {
 				if (p == TypeManager.ushort_type || p == TypeManager.uint32_type ||
 					p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 1;
 			}
 
 			// FIXME
 
 			// TODO
 			Expression p_tmp = new EmptyExpression (p);
 			Expression q_tmp = new EmptyExpression (q);
 
 			bool p_to_q = Convert.ImplicitConversionExists (ec, p_tmp, q);
 			bool q_to_p = Convert.ImplicitConversionExists (ec, q_tmp, p);
 
 			if (p_to_q && !q_to_p)
 				return 1;
 
 			if (q_to_p && !p_to_q)
 				return 2;
 
 			return 0;
 		}
 
 		/// <summary>
 		///   Determines "Better function" between candidate
 		///   and the current best match
 		/// </summary>
 		/// <remarks>
 		///    Returns a boolean indicating 
 		///     false if candidate ain't better
 		///     true  if candidate is better than the current best match
 		/// </remarks>
 		static bool BetterFunction (ResolveContext ec, Arguments args, MemberSpec candidate, AParametersCollection cparam, bool candidate_params,
 			MemberSpec best, AParametersCollection bparam, bool best_params)
 		{
 			AParametersCollection candidate_pd = ((IParametersMember) candidate).Parameters;
 			AParametersCollection best_pd = ((IParametersMember) best).Parameters;
 
 			bool better_at_least_one = false;
 			bool same = true;
 			int args_count = args == null ? 0 
 			int j = 0;
 			Argument a = null;
 			TypeSpec ct, bt;
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 
 			if (better_at_least_one)
 				return true;
 
 			//
 			// This handles the case
 			//
 			//   Add (float f1, float f2, float f3);
 			//   Add (params decimal [] foo);
 			//
 			// The call Add (3, 4, 5) should be ambiguous.  Without this check, the
 			// first candidate would've chosen as better.
 			//
 			if (!same && !a.IsDefaultArgument)
 				return false;
 
 			//
 			// The two methods have equal non-optional parameter types, apply tie-breaking rules
 			//
 
 			//
 			// This handles the following cases
 			//
 			//  Foo (int i) is better than Foo (int i, long l = 0)
 			//  Foo (params int[] args) is better than Foo (int i = 0, params int[] args)
 			//
 			// Prefer non-optional version
 			//
 			// LAMESPEC
 			//
 			if (candidate_params == best_params && candidate_pd.Count != best_pd.Count) {
 				if (candidate_pd.Count >= best_pd.Count)
 					return false;
 
 				if (j < candidate_pd.Count && candidate_pd.FixedParameters[j].HasDefaultValue)
 					return false;
 
 				return true;
 			}
 
 			//
 			// One is a non-generic method and second is a generic method, then non-generic is better
 			//
 			if (best.IsGeneric != candidate.IsGeneric)
 				return best.IsGeneric;
 
 			//
 			// This handles the following cases
 			//
 			//   Trim () is better than Trim (params char[] chars)
 			//   Concat (string s1, string s2, string s3) is better than
 			//     Concat (string s1, params string [] srest)
 			//   Foo (int, params int [] rest) is better than Foo (params int [] rest)
 			//
 			// Prefer non-expanded version
 			//
 			if (candidate_params != best_params)
 				return best_params;
 
 			int candidate_param_count = candidate_pd.Count;
 			int best_param_count = best_pd.Count;
 
 			if (candidate_param_count != best_param_count)
 				// can only happen if (candidate_params && best_params)
 				return candidate_param_count > best_param_count && best_pd.HasParams;
 
 			//
 			// Both methods have the same number of parameters, and the parameters have equal types
 			// Pick the "more specific" signature using rules over original (non-inflated) types
 			//
 			var candidate_def_pd = ((IParametersMember) candidate.MemberDefinition).Parameters;
 			var best_def_pd = ((IParametersMember) best.MemberDefinition).Parameters;
 
 			bool specific_at_least_once = false;
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 
 			if (specific_at_least_once)
 				return true;
 
 			return false;
 		}
 
 		public static void Error_ConstructorMismatch (ResolveContext rc, TypeSpec type, int argCount, Location loc)
 		{
 			rc.Report.Error (1729, loc,
 				"The type `{0}' does not contain a constructor that takes `{1}' arguments",
 				type.GetSignatureForError (), argCount.ToString ());
 		}
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
 
 		//
 		// Tests argument compatibility with the parameter
 		// The possible return values are
 		// 0 - success
 		// 1 - modifier mismatch
 		// 2 - type mismatch
 		// -1 - dynamic binding required
 		//
 		int IsArgumentCompatible (ResolveContext ec, Argument argument, Parameter.Modifier param_mod, TypeSpec parameter)
 		{
 			//
 			// Types have to be identical when ref or out modifer
 			// is used and argument is not of dynamic type
 			//
 			if ((argument.Modifier | param_mod) != 0) {
 				if (argument.Type != parameter) {
 					//
 					// Do full equality check after quick path
 					//
 					if (!TypeSpecComparer.IsEqual (argument.Type, parameter)) {
 						//
 						// Using dynamic for ref/out parameter can still succeed at runtime
 						//
 						if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 							return -1;
 
 						return 2;
 					}
 				}
 
 				if (argument.Modifier != param_mod) {
 					//
 					// Using dynamic for ref/out parameter can still succeed at runtime
 					//
 					if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 						return -1;
 
 					return 1;
 				}
 
 			} else {
 				if (argument.Type == InternalType.Dynamic && (restrictions & Restrictions.CovariantDelegate) == 0)
 					return -1;
 
 				//
 				// Deploy custom error reporting for lambda methods. When probing lambda methods
 				// keep all errors reported in separate set and once we are done and no best
 				// candidate found, this set is used to report more details about what was wrong
 				// with lambda body
 				//
 				if (argument.Expr.Type == InternalType.AnonymousMethod) {
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 				}
 
 				if (!Convert.ImplicitConversionExists (ec, argument.Expr, parameter)) {
 					if (lambda_conv_msgs != null) {
 						lambda_conv_msgs.EndSession ();
 					}
 
 					return 2;
 				}
 			}
 
 			return 0;
 		}
 
 		static TypeSpec MoreSpecific (TypeSpec p, TypeSpec q)
 		{
 			if (TypeManager.IsGenericParameter (p) && !TypeManager.IsGenericParameter (q))
 				return q;
 			if (!TypeManager.IsGenericParameter (p) && TypeManager.IsGenericParameter (q))
 				return p;
 
 			var ac_p = p as ArrayContainer;
 			if (ac_p != null) {
 				var ac_q = ((ArrayContainer) q);
 				TypeSpec specific = MoreSpecific (ac_p.Element, ac_q.Element);
 				if (specific == ac_p.Element)
 					return p;
 				if (specific == ac_q.Element)
 					return q;
 			} else if (TypeManager.IsGenericType (p)) {
 				var pargs = TypeManager.GetTypeArguments (p);
 				var qargs = TypeManager.GetTypeArguments (q);
 
 				bool p_specific_at_least_once = false;
 				bool q_specific_at_least_once = false;
 
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 
 				if (p_specific_at_least_once && !q_specific_at_least_once)
 					return p;
 				if (!p_specific_at_least_once && q_specific_at_least_once)
 					return q;
 			}
 
 			return null;
 		}
 
 		//
 		// Find the best method from candidate list
 		//
 		public T ResolveMember<T> (ResolveContext rc, ref Arguments args) where T 
 		{
 			List<AmbiguousCandidate> ambiguous_candidates = null;
 
 			MemberSpec best_candidate;
 			Arguments best_candidate_args = null;
 			bool best_candidate_params = false;
 			bool best_candidate_dynamic = false;
 			int best_candidate_rate;
 			IParametersMember best_parameter_member = null;
 
 			int args_count = args != null ? args.Count 
 
 			Arguments candidate_args = args;
 			bool error_mode = false;
 			var current_type = rc.CurrentType;
 			MemberSpec invocable_member = null;
 
 			// Be careful, cannot return until error reporter is restored
 			while (true) {
 				best_candidate = null;
 				best_candidate_rate = int.MaxValue;
 
 				var type_members = members;
 				try {
 
 					do {
 						for (int i = 0; i < type_members.Count; ++i) {
 							var member = type_members[i];
 
 							//
 							// Methods in a base class are not candidates if any method in a derived
 							// class is applicable
 							//
 							if ((member.Modifiers & Modifiers.OVERRIDE) != 0)
 								continue;
 
 							if (!error_mode) {
 								if (!member.IsAccessible (current_type))
 									continue;
 
 								if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (current_type))
 									continue;
 							}
 
 							IParametersMember pm = member as IParametersMember;
 							if (pm == null) {
 								//
 								// Will use it later to report ambiguity between best method and invocable member
 								//
 								if (Invocation.IsMemberInvocable (member))
 									invocable_member = member;
 
 								continue;
 							}
 
 							//
 							// Overload resolution is looking for base member but using parameter names
 							// and default values from the closest member. That means to do expensive lookup
 							// for the closest override for virtual or abstract members
 							//
 							if ((member.Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 								var override_params = base_provider.GetOverrideMemberParameters (member);
 								if (override_params != null)
 									pm = override_params;
 							}
 
 							//
 							// Check if the member candidate is applicable
 							//
 							bool params_expanded_form = false;
 							bool dynamic_argument = false;
 							TypeSpec rt = pm.MemberType;
 							int candidate_rate = IsApplicable (rc, ref candidate_args, args_count, ref member, pm, ref params_expanded_form, ref dynamic_argument, ref rt);
 
 							//
 							// How does it score compare to others
 							//
 							if (candidate_rate < best_candidate_rate) {
 								best_candidate_rate = candidate_rate;
 								best_candidate = member;
 								best_candidate_args = candidate_args;
 								best_candidate_params = params_expanded_form;
 								best_candidate_dynamic = dynamic_argument;
 								best_parameter_member = pm;
 								best_candidate_return_type = rt;
 							} else if (candidate_rate == 0) {
 								//
 								// The member look is done per type for most operations but sometimes
 								// it's not possible like for binary operators overload because they
 								// are unioned between 2 sides
 								//
 								if ((restrictions & Restrictions.BaseMembersIncluded) != 0) {
 									if (TypeSpec.IsBaseClass (best_candidate.DeclaringType, member.DeclaringType, true))
 										continue;
 								}
 
 								bool is_better;
 								if (best_candidate.DeclaringType.IsInterface && member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 									//
 									// We pack all interface members into top level type which makes the overload resolution
 									// more complicated for interfaces. We accomodate for this by removing methods with same
 									// signature when building the cache hence this path should not really be hit often
 									//
 									// Example
 									// interface IA { void Foo (int arg); }
 									// interface IB 
 									//
 									// IB
 									//
 									is_better = true;
 									if (ambiguous_candidates != null) {
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										}
 
 										if (is_better)
 											ambiguous_candidates = null;
 									}
 								} else {
 									// Is the new candidate better
 									is_better = BetterFunction (rc, candidate_args, member, pm.Parameters, params_expanded_form, best_candidate, best_parameter_member.Parameters, best_candidate_params);
 								}
 
 								if (is_better) {
 									best_candidate = member;
 									best_candidate_args = candidate_args;
 									best_candidate_params = params_expanded_form;
 									best_candidate_dynamic = dynamic_argument;
 									best_parameter_member = pm;
 									best_candidate_return_type = rt;
 								} else {
 									// It's not better but any other found later could be but we are not sure yet
 									if (ambiguous_candidates == null)
 										ambiguous_candidates = new List<AmbiguousCandidate> ();
 
 									ambiguous_candidates.Add (new AmbiguousCandidate (member, pm.Parameters, params_expanded_form));
 								}
 							}
 
 							// Restore expanded arguments
 							if (candidate_args != args)
 								candidate_args = args;
 						}
 					} while (best_candidate_rate != 0 && (type_members = base_provider.GetBaseMembers (type_members[0].DeclaringType.BaseType)) != null);
 				} finally {
 					if (prev_recorder != null)
 						rc.Report.SetPrinter (prev_recorder);
 				}
 
 				//
 				// We've found exact match
 				//
 				if (best_candidate_rate == 0)
 					break;
 
 				//
 				// Try extension methods lookup when no ordinary method match was found and provider enables it
 				//
 				if (!error_mode) {
 					var emg = base_provider.LookupExtensionMethod (rc);
 					if (emg != null) {
 						emg = emg.OverloadResolve (rc, ref args, null, restrictions);
 						if (emg != null) {
 							best_candidate_extension_group = emg;
 							return (T) (MemberSpec) emg.BestCandidate;
 						}
 					}
 				}
 
 				// Don't run expensive error reporting mode for probing
 				if (IsProbingOnly)
 					return null;
 
 				if (error_mode)
 					break;
 
 				lambda_conv_msgs = null;
 				error_mode = true;
 			}
 
 			//
 			// No best member match found, report an error
 			//
 			if (best_candidate_rate != 0 || error_mode) {
 				ReportOverloadError (rc, best_candidate, best_parameter_member, best_candidate_args, best_candidate_params);
 				return null;
 			}
 
 			if (best_candidate_dynamic) {
 				if (args[0].ArgType == Argument.AType.ExtensionType) {
 					rc.Report.Error (1973, loc,
 						"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' cannot be dynamically dispatched. Consider calling the method without the extension method syntax",
 						args [0].Type.GetSignatureForError (), best_candidate.Name, best_candidate.GetSignatureForError ());
 				}
 
 				BestCandidateIsDynamic = true;
 				return null;
 			}
 
 			if (ambiguous_candidates != null) {
 				//
 				// Now check that there are no ambiguities i.e the selected method
 				// should be better than all the others
 				//
 				for (int ix = 0; ix < ambiguous_candidates.Count; ix++) {
 					var candidate = ambiguous_candidates [ix];
 
 					if (!BetterFunction (rc, best_candidate_args, best_candidate, best_parameter_member.Parameters, best_candidate_params, candidate.Member, candidate.Parameters, candidate.Expanded)) {
 						var ambiguous = candidate.Member;
 						if (custom_errors == null || !custom_errors.AmbiguousCandidates (rc, best_candidate, ambiguous)) {
 							rc.Report.SymbolRelatedToPreviousError (best_candidate);
 							rc.Report.SymbolRelatedToPreviousError (ambiguous);
 							rc.Report.Error (121, loc, "The call is ambiguous between the following methods or properties
 								best_candidate.GetSignatureForError (), ambiguous.GetSignatureForError ());
 						}
 
 						return (T) best_candidate;
 					}
 				}
 			}
 
 			if (invocable_member != null) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.SymbolRelatedToPreviousError (invocable_member);
 				rc.Report.Warning (467, 2, loc, "Ambiguity between method `{0}' and invocable non-method `{1}'. Using method group",
 					best_candidate.GetSignatureForError (), invocable_member.GetSignatureForError ());
 			}
 
 			//
 			// And now check if the arguments are all
 			// compatible, perform conversions if
 			// necessary etc. and return if everything is
 			// all right
 			//
 			if (!VerifyArguments (rc, ref best_candidate_args, best_candidate, best_parameter_member, best_candidate_params))
 				return null;
 
 			if (best_candidate == null)
 				return null;
 
 			//
 			// Check ObsoleteAttribute on the best method
 			//
 			ObsoleteAttribute oa = best_candidate.GetAttributeObsolete ();
 			if (oa != null && !rc.IsObsolete)
 				AttributeTester.Report_ObsoleteMessage (oa, best_candidate.GetSignatureForError (), loc, rc.Report);
 
 			var dep = best_candidate.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			best_candidate.MemberDefinition.SetIsUsed ();
 
 			args = best_candidate_args;
 			return (T) best_candidate;
 		}
 
 		public MethodSpec ResolveOperator (ResolveContext rc, ref Arguments args)
 		{
 			return ResolveMember<MethodSpec> (rc, ref args);
 		}
 
 		void ReportArgumentMismatch (ResolveContext ec, int idx, MemberSpec method,
 													Argument a, AParametersCollection expected_par, TypeSpec paramType)
 		{
 			if (custom_errors != null && custom_errors.ArgumentMismatch (ec, method, a, idx))
 				return;
 
 			if (a is CollectionElementInitializer.ElementInitializerArgument) {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				if ((expected_par.FixedParameters[idx].ModFlags & Parameter.Modifier.ISBYREF) != 0) {
 					ec.Report.Error (1954, loc, "The best overloaded collection initalizer method `{0}' cannot have 'ref', or `out' modifier",
 						TypeManager.CSharpSignature (method));
 					return;
 				}
 				ec.Report.Error (1950, loc, "The best overloaded collection initalizer method `{0}' has some invalid arguments",
 					  TypeManager.CSharpSignature (method));
 			} else if (IsDelegateInvoke) {
 				ec.Report.Error (1594, loc, "Delegate `{0}' has some invalid arguments",
 					DelegateType.GetSignatureForError ());
 			} else {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				ec.Report.Error (1502, loc, "The best overloaded method match for `{0}' has some invalid arguments",
 					method.GetSignatureForError ());
 			}
 
 			Parameter.Modifier mod = idx >= expected_par.Count ? 0 
 
 			string index = (idx + 1).ToString ();
 			if (((mod & (Parameter.Modifier.REF | Parameter.Modifier.OUT)) ^
 				(a.Modifier & (Parameter.Modifier.REF | Parameter.Modifier.OUT))) != 0) {
 				if ((mod & Parameter.Modifier.ISBYREF) == 0)
 					ec.Report.Error (1615, loc, "Argument `#{0}' does not require `{1}' modifier. Consider removing `{1}' modifier",
 						index, Parameter.GetModifierSignature (a.Modifier));
 				else
 					ec.Report.Error (1620, loc, "Argument `#{0}' is missing `{1}' modifier",
 						index, Parameter.GetModifierSignature (mod));
 			} else {
 				string p1 = a.GetSignatureForError ();
 				string p2 = TypeManager.CSharpName (paramType);
 
 				if (p1 == p2) {
 					ec.Report.ExtraInformation (loc, "(equally named types possibly from different assemblies in previous ");
 					ec.Report.SymbolRelatedToPreviousError (a.Expr.Type);
 					ec.Report.SymbolRelatedToPreviousError (paramType);
 				}
 
 				ec.Report.Error (1503, loc,
 					"Argument `#{0}' cannot convert `{1}' expression to type `{2}'", index, p1, p2);
 			}
 		}
 
 		//
 		// We have failed to find exact match so we return error info about the closest match
 		//
 		void ReportOverloadError (ResolveContext rc, MemberSpec best_candidate, IParametersMember pm, Arguments args, bool params_expanded)
 		{
 			int ta_count = type_arguments == null ? 0 
 			int arg_count = args == null ? 0 
 
 			if (ta_count != best_candidate.Arity && (ta_count > 0 || ((IParametersMember) best_candidate).Parameters.IsEmpty)) {
 				var mg = new MethodGroupExpr (new [] { best_candidate }, best_candidate.DeclaringType, loc);
 				mg.Error_TypeArgumentsCannotBeUsed (rc.Report, loc, best_candidate, ta_count);
 				return;
 			}
 
 			if (lambda_conv_msgs != null) {
 				if (lambda_conv_msgs.Merge (rc.Report.Printer))
 					return;
 			}
 
 			//
 			// For candidates which match on parameters count report more details about incorrect arguments
 			//
 			if (pm != null) {
 				int unexpanded_count = ((IParametersMember) best_candidate).Parameters.HasParams ? pm.Parameters.Count - 1 
 				if (pm.Parameters.Count == arg_count || params_expanded || unexpanded_count == arg_count) {
 					// Reject any inaccessible member
 					if (!best_candidate.IsAccessible (rc.CurrentType) || !best_candidate.DeclaringType.IsAccessible (rc.CurrentType)) {
 						rc.Report.SymbolRelatedToPreviousError (best_candidate);
 						Expression.ErrorIsInaccesible (rc, best_candidate.GetSignatureForError (), loc);
 						return;
 					}
 
 					var ms = best_candidate as MethodSpec;
 					if (ms != null && ms.IsGeneric) {
 						bool constr_ok = true;
 						if (ms.TypeArguments != null)
 							constr_ok = new ConstraintChecker (rc.MemberContext).CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc);
 
 						if (ta_count == 0) {
 							if (custom_errors != null && custom_errors.TypeInferenceFailed (rc, best_candidate))
 								return;
 
 							if (constr_ok) {
 								rc.Report.Error (411, loc,
 									"The type arguments for method `{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly",
 									ms.GetGenericMethodDefinition ().GetSignatureForError ());
 							}
 
 							return;
 						}
 					}
 
 					VerifyArguments (rc, ref args, best_candidate, pm, params_expanded);
 					return;
 				}
 			}
 
 			//
 			// We failed to find any method with correct argument count, report best candidate
 			//
 			if (custom_errors != null && custom_errors.NoArgumentMatch (rc, best_candidate))
 				return;
 
 			if (best_candidate.Kind == MemberKind.Constructor) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				Error_ConstructorMismatch (rc, best_candidate.DeclaringType, arg_count, loc);
 			} else if (IsDelegateInvoke) {
 				rc.Report.SymbolRelatedToPreviousError (DelegateType);
 				rc.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					DelegateType.GetSignatureForError (), arg_count.ToString ());
 			} else {
 				string name = best_candidate.Kind == MemberKind.Indexer ? "this" 
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.Error (1501, loc, "No overload for method `{0}' takes `{1}' arguments",
 					name, arg_count.ToString ());
 			}
 		}
 
 		bool VerifyArguments (ResolveContext ec, ref Arguments args, MemberSpec member, IParametersMember pm, bool chose_params_expanded)
 		{
 			var pd = pm.Parameters;
 			TypeSpec[] ptypes = ((IParametersMember) member).Parameters.Types;
 
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 			int a_idx = 0, a_pos = 0;
 			Argument a = null;
 			ArrayInitializer params_initializers = null;
 			bool has_unsafe_arg = pm.MemberType.IsPointer;
 			int arg_count = args == null ? 0 
 
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 
 			if (a_idx != arg_count) {
 				ReportArgumentMismatch (ec, a_pos, member, a, pd, pt);
 				return false;
 			}
 
 			//
 			// Fill not provided arguments required by params modifier
 			//
 			if (params_initializers == null && pd.HasParams && arg_count + 1 == pd.Count) {
 				if (args == null)
 					args = new Arguments (1);
 
 				pt = ptypes[pd.Count - 1];
 				pt = TypeManager.GetElementType (pt);
 				has_unsafe_arg |= pt.IsPointer;
 				params_initializers = new ArrayInitializer (0, loc);
 			}
 
 			//
 			// Append an array argument with all params arguments
 			//
 			if (params_initializers != null) {
 				args.Add (new Argument (
 					new ArrayCreation (new TypeExpression (pt, loc), params_initializers, loc).Resolve (ec)));
 				arg_count++;
 			}
 
 			if (has_unsafe_arg && !ec.IsUnsafe) {
 				Expression.UnsafeError (ec, loc);
 			}
 
 			//
 			// We could infer inaccesible type arguments
 			//
 			if (type_arguments == null && member.IsGeneric) {
 				var ms = (MethodSpec) member;
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 			}
 
 			return true;
 		}
 	}
 
 	public class ConstantExpr 
 	{
 		ConstSpec constant;
 
 		public ConstantExpr (ConstSpec constant, Location loc)
 		{
 			this.constant = constant;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3921" endline="3938">
<![CDATA[
 	}
 
 	// Base class for statements that are implemented in terms of try...finally
 	public abstract class ExceptionStatement 
 	{
 		bool code_follows;
 		Iterator iter;
 		List<ResumableStatement> resume_points;
 		int first_resume_pc;
 		protected Statement stmt;
 		Label dispose_try_block;
 		bool prepared_for_dispose, emitted_dispose;
 
 		protected ExceptionStatement (Statement stmt, Location loc)
 		{
 			this.stmt = stmt;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2986" endline="3007">
<![CDATA[
 	}
 	
 	public class SwitchLabel {
 		Expression label;
 		object converted;
 		Location loc;
 
 		Label il_label;
 		bool  il_label_set;
 		Label il_label_code;
 		bool  il_label_code_set;
 
 		public static readonly object NullStringCase = new object ();
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="523" endline="534">
<![CDATA[
 	}
 
 	sealed class GenericEventInfo 
 	{
 		private readonly Type typeInstance;
 		private readonly EventInfo eventInfo;
 
 		internal GenericEventInfo(Type typeInstance, EventInfo eventInfo)
 		{
 			this.typeInstance = typeInstance;
 			this.eventInfo = eventInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1042" endline="1051">
<![CDATA[
 	}
 	
 	public class Throw 
 		Expression expr;
 		
 		public Throw (Expression expr, Location l)
 		{
 			this.expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="972" endline="985">
<![CDATA[
 	}
 
 	/// <summary>
 	///   `goto case' statement
 	/// </summary>
 	public class GotoCase 
 		Expression expr;
 		SwitchLabel sl;
 		
 		public GotoCase (Expression e, Location l)
 		{
 			expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4689" endline="4867">
<![CDATA[
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return local_info.VariableInfo; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return local_info.HoistedVariant;
 		}
 
 		#region Properties
 
 		//		
 		// A local variable is always fixed
 		//
 		public override bool IsFixed {
 			get {
 				return true;
 			}
 		}
 
 		public override bool IsLockedByStatement {
 			get {
 				return local_info.IsLocked;
 			}
 			set {
 				local_info.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return false; }
 		}
 
 		public override string Name {
 			get { return local_info.Name; }
 		}
 
 		#endregion
 
 		public bool VerifyAssigned (ResolveContext ec)
 		{
 			VariableInfo variable_info = local_info.VariableInfo;
 			return variable_info == null || variable_info.IsAssigned (ec, loc);
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			local_info.AddressTaken = true;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			Arguments arg = new Arguments (1);
 			arg.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", arg);
 		}
 
 		void DoResolveBase (ResolveContext ec)
 		{
 			VerifyAssigned (ec);
 
 			//
 			// If we are referencing a variable from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (local_info)) {
 				if (local_info.AddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (ec.IsVariableCapturingRequired) {
 					AnonymousMethodStorey storey = local_info.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureLocalVariable (ec, local_info);
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			type = local_info.Type;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			// is out param
 			if (right_side == EmptyExpression.OutAccess.Instance)
 				local_info.SetIsUsed ();
 
 			if (local_info.IsReadonly && !ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.UsingInitializerScope)) {
 				int code;
 				string msg;
 				if (right_side == EmptyExpression.OutAccess.Instance) {
 					code = 1657; msg = "Cannot pass `{0}' as a ref or out argument because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberAccess) {
 					code = 1654; msg = "Cannot assign to members of `{0}' because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberOutAccess) {
 					code = 1655; msg = "Cannot pass members of `{0}' as ref or out arguments because it is a `{1}'";
 				} else if (right_side == EmptyExpression.UnaryAddress) {
 					code = 459; msg = "Cannot take the address of {1} `{0}'";
 				} else {
 					code = 1656; msg = "Cannot assign to `{0}' because it is a `{1}'";
 				}
 				ec.Report.Error (code, loc, msg, Name, local_info.GetReadOnlyContext ());
 			} else if (VariableInfo != null) {
 				VariableInfo.SetAssigned (ec);
 			}
 
 			DoResolveBase (ec);
 
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		public override int GetHashCode ()
 		{
 			return local_info.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			LocalVariableReference lvr = obj as LocalVariableReference;
 			if (lvr == null)
 				return false;
 
 			return local_info == lvr.local_info;
 		}
 
 		protected override ILocalVariable Variable {
 			get { return local_info; }
 		}
 
 		public override string ToString ()
 		{
 			return String.Format ("{0} ({1}
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing
 		}
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="526" endline="567">
<![CDATA[
 
 		public void AddBlockMap (Block from, Block to)
 		{
 			block_map.Add (from, to);
 		}
 
 		public Block LookupBlock (Block from)
 		{
 			Block result;
 			if (!block_map.TryGetValue (from, out result)) {
 				result = (Block) from.Clone (this);
 			}
 
 			return result;
 		}
 
 		///
 		/// Remaps block to cloned copy if one exists.
 		///
 		public Block RemapBlockCopy (Block from)
 		{
 			Block mapped_to;
 			if (!block_map.TryGetValue (from, out mapped_to))
 				return from;
 
 			return mapped_to;
 		}
 	}
 
 	//
 	// Main compiler context
 	//
 	public class CompilerContext
 	{
 		readonly Report report;
 		readonly BuildinTypes buildin_types;
 
 		public CompilerContext (Report report)
 		{
 			this.report = report;
 			this.buildin_types = new BuildinTypes ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="830" endline="839">
<![CDATA[
 		}
 
 		Dictionary<TypeSpec, Expression> compatibles;
 		public ParametersBlock Block;
 
 		public AnonymousMethodExpression (Location loc)
 		{
 			this.loc = loc;
 			this.compatibles = new Dictionary<TypeSpec, Expression> ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resources.vb" startline="41" endline="49">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' A new resource list.
     ''' </summary>	
     Sub New(ByVal Compiler As Compiler, ByVal LinkedResources As Boolean)
         m_Compiler = Compiler
         m_IsLinkedResources = LinkedResources
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="299" endline="314">
<![CDATA[
 	}
 
 	public struct LocalVariableEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly int Index;
 		public readonly string Name;
 		public readonly int BlockIndex;
 		#endregion
 
 		public LocalVariableEntry (int index, string name, int block)
 		{
 			this.Index = index;
 			this.Name = name;
 			this.BlockIndex = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="335" endline="358">
<![CDATA[
 	}
 
 	public struct CapturedVariable
 	{
 		#region This is actually written to the symbol file
 		public readonly string Name;
 		public readonly string CapturedName;
 		public readonly CapturedKind Kind;
 		#endregion
 
 		public enum CapturedKind 
 		{
 			Local,
 			Parameter,
 			This
 		}
 
 		public CapturedVariable (string name, string captured_name,
 					 CapturedKind kind)
 		{
 			this.Name = name;
 			this.CapturedName = captured_name;
 			this.Kind = kind;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="95" endline="101">
<![CDATA[
 
 		public void SetLocalSymInfo(string name, int startOffset, int endOffset)
 		{
 			this.name = name;
 			this.startOffset = startOffset;
 			this.endOffset = endOffset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="548" endline="560">
<![CDATA[
 
     Shared Function GetUnaryResultType(ByVal op As KS, ByVal op1 As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(op1)
             Case KS.Minus
                 Return GetUnaryMinusResultType(op1)
             Case KS.Not
                 Return GetUnaryNotResultType(op1)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="612" endline="624">
<![CDATA[
 
     Shared Function GetUnaryOperandType(ByVal op As KS, ByVal operand As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(operand)
             Case KS.Minus
                 Return GetUnaryMinusResultType(operand)
             Case KS.Not
                 Return GetUnaryNotResultType(operand)
             Case Else
                 Throw New NotImplementedException
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="63" endline="75">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeName(NewParent)
         If Me.IsNonArrayTypeName Then
             result.Init(Me.AsNonArrayTypeName.clone)
         ElseIf Me.IsArrayTypeName Then
             result.Init(Me.AsArrayTypeName.clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="45" endline="57">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SimpleTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleTypeName(NewParent)
         If Me.IsBuiltInTypeName Then
             result.Init(Me.AsBuiltInTypeName.Clone(result))
         ElseIf Me.IsQualifiedIdentifier Then
             result.Init(Me.AsQualifiedIdentifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="50" endline="62">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayNameModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayNameModifier(NewParent)
         If Me.IsArrayTypeModifiers Then
             result.Init(Me.AsArrayTypeModifiers.Clone(result))
         ElseIf Me.IsArraySizeInitializationModifier Then
             result.Init(Me.AsArraySizeInitializationModifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5037" endline="5052">
<![CDATA[
 		}
 
 		public override bool Equals (object obj)
 		{
 			FieldExpr fe = obj as FieldExpr;
 			if (fe == null)
 				return false;
 
 			if (spec != fe.spec)
 				return false;
 
 			if (InstanceExpression == null || fe.InstanceExpression == null)
 				return true;
 
 			return InstanceExpression.Equals (fe.InstanceExpression);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="158" endline="165">
<![CDATA[
 
 		private static void AddAccessor(List<MethodInfo> list, bool nonPublic, MethodInfo method)
 		{
 			if (method != null && (nonPublic || method.IsPublic))
 			{
 				list.Add(method);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1728" endline="1741">
<![CDATA[
 
 		void initialize_vector ()
 		{
 			// Post-condition
 			if (shared == null) {
 				vector = new System.Collections.BitArray (Count, true);
 				return;
 			}
 
 			vector = new System.Collections.BitArray (shared);
 			if (Count != vector.Count)
 				vector.Length = Count;
 			shared = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\literal.cs" startline="44" endline="61">
<![CDATA[
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec t, bool expl)
 		{
 			if (t.IsGenericParameter) {
 				ec.Report.Error(403, loc,
 					"Cannot convert null to the type parameter `{0}' because it could be a value " +
 					"type. Consider using `default ({0})' instead", t.Name);
 				return;
 			}
 
 			if (TypeManager.IsValueType (t)) {
 				ec.Report.Error(37, loc, "Cannot convert null to `{0}' because it is a value type",
 					TypeManager.CSharpName(t));
 				return;
 			}
 
 			base.Error_ValueCannotBeConverted (ec, loc, t, expl);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="308" endline="319">
<![CDATA[
 
 		public void EmitArrayNew (ArrayContainer ac)
 		{
 			if (ac.Rank == 1) {
 				Emit (OpCodes.Newarr, ac.Element);
 			} else {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Newobj, ac.GetConstructor ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="1409" endline="1424">
<![CDATA[
 
 		void AddResource (AssemblyResource res)
 		{
 			if (RootContext.Resources == null) {
 				RootContext.Resources = new List<AssemblyResource> ();
 				RootContext.Resources.Add (res);
 				return;
 			}
 
 			if (RootContext.Resources.Contains (res)) {
 				ctx.Report.Error (1508, "The resource identifier `{0}' has already been used in this assembly", res.Name);
 				return;
 			}
 
 			RootContext.Resources.Add (res);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="856" endline="868">
<![CDATA[
 
 		protected override void EmitOperator (EmitContext ec, TypeSpec l)
 		{
 			if (user_operator != null) {
 				user_operator.Emit (ec);
 				return;
 			}
 
 			if (TypeManager.IsNullableType (l))
 				l = TypeManager.GetTypeArguments (l) [0];
 
 			base.EmitOperator (ec, l);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="167" endline="174">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Variable As Mono.Cecil.FieldReference, ByVal InstanceExpression As Expression)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Variable IsNot Nothing)
         m_Classification = New VariableClassification(Me.Parent, Variable, InstanceExpression)
         m_Type = DirectCast(m_Classification, VariableClassification).Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="47" endline="53">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
     Private m_ShowErrors As Boolean = True
 
     Private ReadOnly Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         tm = m_Compiler.tm
         Helper.Assert(tm IsNot Nothing)
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
         m_Compiler = Compiler
         tm = New tm(Compiler, TokenReader)
         tm.NextToken()
         Helper.Assert(tm IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="160" endline="166">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Variable As VariableDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Variable IsNot Nothing)
         m_Classification = New VariableClassification(Me.Parent, Variable)
         m_Type = DirectCast(m_Classification, VariableClassification).Type
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="40" endline="46">
<![CDATA[
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
     Private m_ShowErrors As Boolean = True
 
     Private ReadOnly Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         tm = m_Compiler.tm
         Helper.Assert(tm IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="84" endline="96">
<![CDATA[
     End Property
 
     Sub Init(ByVal Attributes As Attributes, ByVal Modifiers As Modifiers, ByVal ParameterIdentifier As ParameterIdentifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         m_CustomAttributes = Attributes
         m_Modifiers = Modifiers
         m_ParameterIdentifier = ParameterIdentifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
 
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="436" endline="449">
<![CDATA[
 
     ''' <summary>
     ''' Creates a variable classification for an array access.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Arguments"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal ArrayVariableExpression As Expression, ByVal Arguments As ArgumentList)
         MyBase.New(Classifications.Variable, Parent)
         m_ArrayVariable = ArrayVariableExpression
         m_Arguments = Arguments
         Helper.Assert(ArrayVariable IsNot Nothing)
         Helper.Assert(Arguments IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="244" endline="250">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="237" endline="243">
<![CDATA[
 
     Sub New(ByVal Classification As LateBoundAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="230" endline="236">
<![CDATA[
 
     Sub New(ByVal Classification As MethodPointerClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="223" endline="229">
<![CDATA[
 
     Sub New(ByVal Classification As MethodGroupClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="216" endline="222">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyGroupClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="209" endline="215">
<![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="49" endline="58">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal ImplementsClause As MemberImplementsClause)
         MyBase.Init(Modifiers, Identifier.Name)
 
         m_Identifier = Identifier
         m_ImplementsClause = ImplementsClause
 
         Helper.Assert(m_Identifier IsNot Nothing)
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="46" endline="52">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
 
         If Identifier.Identifier Is Nothing Then Throw New InternalException("No identifier
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="270" endline="280">
<![CDATA[
 
     ''' <summary>
     ''' If the current token is not the specified keyword / symbol, then a
     ''' InternalException is thrown. (In which case it doesn't return,
     ''' so this is not a function).
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <remarks></remarks>
     Sub AcceptIfNotInternalError(ByVal Special As KS)
         If Not Accept(Special) Then Throw New InternalException("Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2326" endline="2335">
<![CDATA[
 		
 		public Operator (DeclSpace parent, OpType type, FullNamedExpression ret_type,
 				 Modifiers mod_flags, ParametersCompiled parameters,
 				 ToplevelBlock block, Attributes attrs, Location loc)
 			
 				new MemberName (GetMetadataName (type), loc), attrs, parameters)
 		{
 			OperatorType = type;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="936" endline="942">
<![CDATA[
 
 		public AssemblyResource (string fileName, string name, bool isPrivate)
 		{
 			FileName = fileName;
 			Name = name;
 			Attributes = isPrivate ? ResourceAttributes.Private 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="986" endline="1002">
<![CDATA[
 			}
 		}
 
 
 		static readonly string[] attribute_targets = new string [] { "event", "field", "method" };
 		static readonly string[] attribute_targets_interface = new string[] { "event", "method" };
 
 		Expression initializer;
 		Field backing_field;
 		List<FieldDeclarator> declarators;
 
 		public EventField (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			Add = new AddDelegateMethod (this);
 			Remove = new RemoveDelegateMethod (this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1213" endline="1219">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			AnonymousMethodExpression target = (AnonymousMethodExpression) t;
 
 			target.Block = (ParametersBlock) clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1035" endline="1041">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			GotoCase target = (GotoCase) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1214" endline="1220">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnaryMutator target = (UnaryMutator) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7908" endline="7914">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1698" endline="1711">
<![CDATA[
 
 #if NET_4_0 && !STATIC
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return SLE.Expression.Default (type.GetMetaInfo ());
 		}
 #endif
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			DefaultValueExpression target = (DefaultValueExpression) t;
 			
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7970" endline="7976">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CheckedExpr target = (CheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8025" endline="8031">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnCheckedExpr target = (UnCheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4273" endline="4279">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unchecked target = (Unchecked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4335" endline="4341">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unsafe target = (Unsafe) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="82" endline="88">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Yield target = (Yield) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="767" endline="773">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Unary target = (Unary) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1475" endline="1481">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 			
 			ec.Emit (OpCodes.Box, child.Type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1508" endline="1514">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 
 			ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2111" endline="2122">
<![CDATA[
 
 		bool ResolveTransformationCtor (Location loc)
 		{
 			if (tctor != null)
 				return true;
 
 			if (Resolve (loc) == null)
 				return false;
 
 			tctor = TypeManager.GetPredefinedConstructor (type, Location.Null, ArrayContainer.MakeType (TypeManager.bool_type));
 			return tctor != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1950" endline="1961">
<![CDATA[
 
 		public bool ResolveConstructor (Location loc, params TypeSpec[] argType)
 		{
 			if (ctor != null)
 				throw new InternalErrorException ("Predefined ctor redefined");
 
 			if (Resolve (loc) == null)
 				return false;
 
 			ctor = TypeManager.GetPredefinedConstructor (type, loc, argType);
 			return ctor != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="936" endline="947">
<![CDATA[
 
 		public FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			// Precondition
 			FullNamedExpression resolved = null;
 			for (NamespaceEntry curr_ns = this; curr_ns != null; curr_ns = curr_ns.ImplicitParent) {
 				if ((resolved = curr_ns.Lookup (name, arity, loc, ignore_cs0104)) != null)
 					break;
 			}
 			for (NamespaceEntry curr_ns = this; curr_ns != null; curr_ns = curr_ns.ImplicitParent) {
 				if ((resolved = curr_ns.Lookup (name, arity, loc, ignore_cs0104)) != null)
 					break;
 			}
 
 			return resolved;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="57" endline="69">
<![CDATA[
 
     ReadOnly Property Name() As String
         Get
             If TypeOf Me Is MeExpression Then
                 Return KS.Me.ToString
             ElseIf TypeOf Me Is MyBaseExpression Then
                 Return KS.MyBase.ToString
             ElseIf TypeOf Me Is MyClassExpression Then
                 Return KS.MyClass.ToString
             Else
                 Throw New InternalException("Invalid instance expression.")
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="125" endline="136">
<![CDATA[
 
     Public Shared Function IsValidType(ByVal type As TypeReference) As Boolean
         Dim arrayType As ArrayType
 
         If type Is Nothing Then Return True
         If TypeOf type Is PointerType Then Return False
 
         arrayType = TryCast(type, ArrayType)
         If arrayType IsNot Nothing AndAlso IsValidType(arrayType.ElementType) = False Then Return False
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="295" endline="305">
<![CDATA[
 
     Shared Function IsEmittableMember(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean
 
         If Member Is Nothing Then Return True
         If TypeOf Member Is Mono.Cecil.GenericParameter Then Return True
         If TypeOf Member Is Mono.Cecil.ArrayType Then Return True
         result = FindAssembly(Member) Is Compiler.AssemblyBuilderCecil
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="74" endline="84">
<![CDATA[
 
 		public string ReadString (int offset)
 		{
 			long old_pos = BaseStream.Position;
 			BaseStream.Position = offset;
 
 			string text = ReadString ();
 
 			BaseStream.Position = old_pos;
 			return text;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2391" endline="2403">
<![CDATA[
 
     Private Function ParseUnaryNotExpression(ByVal Info As ExpressionParseInfo) As UnaryNotExpression
         Dim result As New UnaryNotExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Not)
 
         m_Expression = ParseComparison(Info)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="94" endline="104">
<![CDATA[
 
 		public ImportedModuleDefinition ImportModule (Module module, RootNamespace targetNamespace)
 		{
 			var module_definition = new ImportedModuleDefinition (module, this);
 			module_definition.ReadAttributes ();
 
 			var all_types = module.GetTypes ();
 			ImportTypes (all_types, targetNamespace, false);
 
 			return module_definition;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="689" endline="695">
<![CDATA[
 
 		public void Emit(OpCode opc, MethodInfo method)
 		{
 			Emit(opc);
 			WriteToken(moduleBuilder.GetMethodTokenForIL(method));
 			UpdateStack(opc, method.HasThis, method.ReturnType, method.ParameterCount);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="364" endline="372">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp Mode)
 		{
 			LocalTemporary value_target = new LocalTemporary (type);
 				
 			value_target.AddressOf (ec, AddressOp.Store);
 			ec.Emit (OpCodes.Initobj, type);
 			((IMemoryLocation) value_target).AddressOf (ec, Mode);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1049" endline="1059">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Stobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Stobj, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1060" endline="1070">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Ldobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="738" endline="746">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Invocation on delegates call the virtual Invoke member
 			// so we are always `instance' calls
 			//
 			Invocation.EmitCall (ec, InstanceExpr, method, arguments, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="87" endline="95">
<![CDATA[
 	}
 
 	public class ParenthesizedExpression 
 	{
 		public ParenthesizedExpression (Expression expr)
 			
 		{
 			loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4320" endline="4332">
<![CDATA[
 	}
 
 	//
 	// A boolean-expression is an expression that yields a result
 	// of type bool
 	//
 	public class BooleanExpression 
 	{
 		public BooleanExpression (Expression expr)
 			
 		{
 			this.loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1098" endline="1105">
<![CDATA[
 
 		public void DefineUnmanagedResource(string resourceFileName)
 		{
 			// This method reads the specified resource file (Win32 .res file) and converts it into the appropriate format and embeds it in the .rsrc section,
 			// also setting the Resource Directory entry.
 			unmanagedResources = new ResourceSection();
 			unmanagedResources.ExtractResources(System.IO.File.ReadAllBytes(resourceFileName));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="749" endline="757">
<![CDATA[
 		}
 		
 		/// <summary>
 		///   Reports that we were expecting `expr' to be of class `expected'
 		/// </summary>
 		public void Error_UnexpectedKind (Report r, MemberCore mc, string expected, Location loc)
 		{
 			Error_UnexpectedKind (r, mc, expected, ExprClassName, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="159" endline="166">
<![CDATA[
 
 		// this is used in combination with delay signing
 		public void __SetAssemblyPublicKey(byte[] publicKey)
 		{
 			AssemblyName oldName = GetName();
 			this.publicKey = publicKey == null ? null 
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="196" endline="202">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="39" endline="49">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Location As Span)
         MyBase.new()
         'If Location IsNot Nothing Then
         m_Message = "There has been an internal error in the compiler caused by the line
         'Else
         'm_Message = "There has been an internal error in the compiler."
         'End If
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="89" endline="95">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal strMsg As String)
         MyBase.new()
         m_Message = "There has been an internal error in the compiler
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="583" endline="599">
<![CDATA[
 		}
 
 		public readonly TypeSpec OriginalIteratorType;
 
 		IteratorStorey IteratorHost;
 
 		public enum State {
 			Running = -3, // Used only in CurrentPC, never stored into $PC
 			Uninitialized = -2,
 			After = -1,
 			Start = 0
 		}
 
 		public void EmitYieldBreak (EmitContext ec, bool unwind_protect)
 		{
 			ec.Emit (unwind_protect ? OpCodes.Leave 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="638" endline="644">
<![CDATA[
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="673" endline="679">
<![CDATA[
 
 		public void Warning_UselessOptionalParameter (Report Report)
 		{
 			Report.Warning (1066, 1, Location,
 				"The default value specified for optional parameter `{0}' will never be used",
 				Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2380" endline="2386">
<![CDATA[
 
 		void Error_UnexpectedDirective (string extra)
 		{
 			Report.Error (
 				1028, Location,
 				"Unexpected processor directive ({0})", extra);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="233" endline="242">
<![CDATA[
 
 		/// <summary>
 		/// This is rather hack. We report many emit attribute error with same error to be compatible with
 		/// csc. But because csc has to report them this way because error came from ilasm we needn't.
 		/// </summary>
 		public void Error_AttributeEmitError (string inner)
 		{
 			Report.Error (647, Location, "Error during emitting `{0}' attribute. The reason is `{1}'",
 				      TypeManager.CSharpName (Type), inner);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="321" endline="330">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal GotoNewline As Boolean, ByVal MessageParameter As String) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation, MessageParameter)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="285" endline="302">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="899" endline="906">
<![CDATA[
 		}
 
 		public void AddUsageVector (FlowBranching.UsageVector vector)
 		{
 			vector = vector.Clone ();
 			vector.Next = vectors;
 			vectors = vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3126" endline="3133">
<![CDATA[
 
 		public static bool IsExtensionMethodArgument (Expression expr)
 		{
 			//
 			// LAMESPEC
 			//
 			return !(expr is TypeExpr) && !(expr is BaseThis);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\rootcontext.cs" startline="120" endline="170">
<![CDATA[
 		}
 
 
 		// 
 		// The default compiler checked state
 		//
 		static public bool Checked;
 
 		//
 		// If true, it means that the compiler is executing as
 		// in eval mode so unresolved variables are resolved in
 		// static classes maintained by the eval engine.
 		//
 		static public bool EvalMode;
 
 		//
 		// If true, the compiler is operating in statement mode,
 		// this currently turns local variable declaration into
 		// static variables of a class
 		//
 		static public bool StatementMode;
 		
 		//
 		// Whether to allow Unsafe code
 		//
 		static public bool Unsafe;
 
 		static public string Win32ResourceFile;
 		static public string Win32IconFile;
 
 		//
 		// A list of resource files for embedding
 		//
 		static public  List<AssemblyResource> Resources;
 
 		static public bool GenerateDebugInfo;
 
 		// Compiler debug flags only
 		public static bool ParseOnly, TokenizeOnly;
 
 		//
 		// Whether we are being linked against the standard libraries.
 		// This is only used to tell whether `System.Object' should
 		// have a base class or not.
 		//
 		public static bool StdLib;
 
 		public static RuntimeVersion StdLibRuntimeVersion;
 
 		public static bool NeedsEntryPoint {
 			get { return Target == Target.Exe || Target == Target.WinExe; }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1963" endline="1978">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2044" endline="2059">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="874" endline="901">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasConstant encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case PropertyTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasConstant encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case PropertyTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1197" endline="1225">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasDeclSecurity encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case MethodDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case AssemblyTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Parent = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasDeclSecurity encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case MethodDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case AssemblyTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Parent = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2314" endline="2339">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Owner;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the TypeOrMethodDef encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case MethodDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].unsortedIndex = i;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Owner;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the TypeOrMethodDef encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case MethodDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].unsortedIndex = i;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="732" endline="757">
<![CDATA[
 
 		internal void Fixup()
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1627" endline="1640">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			if (arrayAccess)
 				expr = ConvertExpressionToArrayIndex (ec, expr);
 			else
 				expr = Convert.ImplicitConversionRequired (ec, expr, type, loc);
 
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2125" endline="2144">
<![CDATA[
 		}
 
 		public override Type BaseType
 		{
 			get
 			{
 				if (baseType == null)
 				{
 					Type rawBaseType = type.BaseType;
 					if (rawBaseType == null)
 					{
 						baseType = rawBaseType;
 					}
 					else
 					{
 						baseType = rawBaseType.BindTypeParameters(this);
 					}
 				}
 				return baseType;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3492" endline="3509">
<![CDATA[
 
     Private Function ParseBooleanLiteralExpression(ByVal Parent As ParsedObject) As BooleanLiteralExpression
         Dim result As New BooleanLiteralExpression(Parent)
 
         Dim m_Value As Boolean
 
         If tm.Accept(KS.True) Then
             m_Value = True
         ElseIf tm.Accept(KS.False) Then
             m_Value = False
         Else
             Throw New InternalException(result)
         End If
 
         result.Init(m_Value)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2899" endline="2916">
<![CDATA[
 		}
 
 		public override IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			if (namespace_entry == null)
 				return null;
 
 			//
 			// For extension methodgroup we are not looking for base members but parent
 			// namespace extension methods
 			//
 			int arity = type_arguments == null ? 0 
 			var found = namespace_entry.LookupExtensionMethod (DeclaringType, Name, arity, ref namespace_entry);
 			if (found == null)
 				return null;
 
 			return found.Cast<MemberSpec> ().ToList ();
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6223" endline="6239">
<![CDATA[
 
 Location GetLocation (object obj)
 {
 	var lt = obj as Tokenizer.LocatedToken;
 	if (lt != null)
 		return lt.Location;
 		
 	var mn = obj as MemberName;
 	if (mn != null)
 		return mn.Location;
 		
 	var expr = obj as Expression;
 	if (expr != null)
 		return expr.Location;
 
 	return lexer.Location;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="244" endline="278">
<![CDATA[
 #else
 			ResolveAssemblySecurityAttributes ();
 			var an = CreateAssemblyName ();
 
 			try {
 				Builder = file_name == null ?
 					domain.DefineDynamicAssembly (an, access) 
 					domain.DefineDynamicAssembly (an, access, Dirname (file_name));
 			} catch (ArgumentException) {
 				// specified key may not be exportable outside it's container
 				if (RootContext.StrongNameKeyContainer != null) {
 					Report.Error (1548, "Could not access the key inside the container `" +
 						RootContext.StrongNameKeyContainer + "'.");
 				}
 				throw;
 			}
 
 			builder_extra = new AssemblyBuilderMonoSpecific (Builder, Compiler);
 			return true;
 #endif
 		}
 
 		static string Dirname (string name)
 		{
 			int pos = name.LastIndexOf ('/');
 
 			if (pos != -1)
 				return name.Substring (0, pos);
 
 			pos = name.LastIndexOf ('\\');
 			if (pos != -1)
 				return name.Substring (0, pos);
 
 			return ".";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="499" endline="514">
<![CDATA[
 		}
 
 		public virtual string GetSignatureForError ()
 		{
 			string type_name;
 			if (parameter_type != null)
 				type_name = TypeManager.CSharpName (parameter_type);
 			else
 				type_name = texpr.GetSignatureForError ();
 
 			string mod = GetModifierSignature (modFlags);
 			if (mod.Length > 0)
 				return String.Concat (mod, " ", type_name);
 
 			return type_name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1437" endline="1449">
<![CDATA[
 
 		public bool IsFieldAssigned (ResolveContext ec, string name, Location loc)
 		{
 			if (!ec.DoFlowAnalysis ||
 				ec.OmitStructFlowAnalysis && TypeInfo.IsStruct ||
 				ec.CurrentBranching.IsFieldAssigned (this, name))
 				return true;
 
 			ec.Report.Error (170, loc,
 				      "Use of possibly unassigned field `" + name + "'");
 			ec.CurrentBranching.SetFieldAssigned (this, name);
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4915" endline="4930">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			// HACK
 			if (ec.IsInProbingMode)
 				return true;
 			
 			if (!ec.DoFlowAnalysis || !HasOutModifier || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			ec.Report.Error (269, loc, "Use of unassigned out parameter `{0}'", Name);
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="689" endline="700">
<![CDATA[
 
 		public sealed override bool Resolve (BlockContext ec)
 		{
 			if (!DoResolve (ec))
 				return false;
 
 			unwind_protect = ec.CurrentBranching.AddReturnOrigin (ec.CurrentBranching.CurrentUsageVector, this);
 			if (unwind_protect)
 				ec.NeedReturnLabel ();
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="243" endline="256">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (UnderlyingType == TypeManager.uint32_type ||
 				UnderlyingType == TypeManager.uint64_type ||
 				UnderlyingType == TypeManager.ushort_type) {
 				Report.Warning (3009, 1, Location, "`{0}'
 			}
 
 			return true;
 		}	
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="415" endline="427">
<![CDATA[
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			if (!IsUnsafe)
 				Expression.UnsafeError (Report, Location);
 
 			if (Parent.PartialContainer.Kind != MemberKind.Struct) {
 				Report.Error (1642, Location, "`{0}'
 					GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1307" endline="1316">
<![CDATA[
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="606" endline="616">
<![CDATA[
 		}
 	
 		protected readonly AnonymousMethodStorey storey;
 		protected Field field;
 		Dictionary<AnonymousExpression, FieldExpr> cached_inner_access; // TODO
 		FieldExpr cached_outer_access;
 
 		protected HoistedVariable (AnonymousMethodStorey storey, string name, TypeSpec type)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="547" endline="555">
<![CDATA[
 	}
 
 	public class FlowBranchingBreakable 
 	{
 		UsageVector break_origins;
 
 		public FlowBranchingBreakable (FlowBranching parent, BranchingType type, SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="571" endline="579">
<![CDATA[
 	}
 
 	public class FlowBranchingContinuable 
 	{
 		UsageVector continue_origins;
 
 		public FlowBranchingContinuable (FlowBranching parent, BranchingType type, SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="833" endline="840">
<![CDATA[
 		}
 
 		static readonly string[] attribute_targets = new string [] { "event" };
 
 		public EventProperty (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="102" endline="112">
<![CDATA[
 
 		public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, Signature.PROPERTY);
 			sig.callingConvention = callingConvention;
 			sig.returnType = returnType;
 			sig.returnTypeOptionalCustomModifiers = requiredReturnTypeCustomModifiers;
 			sig.returnTypeRequiredCustomModifiers = optionalReturnTypeCustomModifiers;
 			sig.AddArguments(parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers);
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="723" endline="742">
<![CDATA[
 		}
 
 		#endregion
 	}
 
 	public abstract class AParametersCollection
 	{
 		protected bool has_arglist;
 		protected bool has_params;
 
 		// Null object pattern
 		protected IParameterData [] parameters;
 		protected TypeSpec [] types;
 
 		public CallingConventions CallingConvention {
 			get {
 				return has_arglist ?
 					CallingConventions.VarArgs 
 					CallingConventions.Standard;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="856" endline="862">
<![CDATA[
 
 		void Error_DuplicateEntryPoint (Method b)
 		{
 			Report.Error (17, b.Location,
 				"Program `{0}' has more than one entry point defined
 				b.Module.Builder.ScopeName, b.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="81" endline="90">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal ArgumentList As ArgumentList, ByVal VariableInitializer As VariableInitializer, ByVal IsVariableDeclaration As Boolean, ByVal VariableDeclaration As LocalVariableDeclaration)
         m_Identifier = Identifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_ArgumentList = ArgumentList
         m_VariableInitializer = VariableInitializer
         m_IsVariableDeclaration = IsVariableDeclaration
         m_VariableDeclaration = VariableDeclaration
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="162" endline="171">
<![CDATA[
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="49" endline="55">
<![CDATA[
 		public MethodCore (DeclSpace parent, GenericMethod generic,
 			FullNamedExpression type, Modifiers mod, Modifiers allowed_mod,
 			MemberName name, Attributes attrs, ParametersCompiled parameters)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1276" endline="1284">
<![CDATA[
 		internal ArrayMethod(Module module, Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
 		{
 			this.module = module;
 			this.arrayClass = arrayClass;
 			this.methodName = methodName;
 			this.callingConvention = callingConvention;
 			this.returnType = returnType ?? module.universe.System_Void;
 			this.parameterTypes = Util.Copy(parameterTypes);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1085" endline="1095">
<![CDATA[
 
 		TypeInfo (StructInfo struct_info, int offset)
 		{
 			this.struct_info = struct_info;
 			this.Offset = offset;
 			this.Length = struct_info.Length;
 			this.TotalLength = struct_info.TotalLength;
 			this.SubStructInfo = struct_info.StructFields;
 			this.Type = struct_info.Type;
 			this.IsStruct = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="39" endline="46">
<![CDATA[
 		internal ParameterBuilder(ModuleBuilder moduleBuilder, int sequence, ParameterAttributes attribs, string name)
 		{
 			this.moduleBuilder = moduleBuilder;
 			this.flags = (short)attribs;
 			this.sequence = (short)sequence;
 			this.nameIndex = name == null ? 0 
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="700" endline="709">
<![CDATA[
 
 		private NamespaceEntry (ModuleContainer ctx, NamespaceEntry parent, CompilationUnit file, Namespace ns, bool slave)
 		{
 			this.ctx = ctx;
 			this.parent = parent;
 			this.file = file;
 			this.IsImplicit = true;
 			this.ns = ns;
 			this.SlaveDeclSpace = slave ? new RootDeclSpace (this) 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="926" endline="937">
<![CDATA[
 		public int ID = counter++;
 #endif
 
 		protected MemberSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition definition, Modifiers modifiers)
 		{
 			this.Kind = kind;
 			this.declaringType = declaringType;
 			this.definition = definition;
 			this.modifiers = modifiers;
 
 			state = StateFlags.Obsolete_Undetected | StateFlags.CLSCompliant_Undetected | StateFlags.MissingDependency_Undetected;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="48" endline="58">
<![CDATA[
 
 		private PropertySignature(CallingConventions callingConvention, Type propertyType, Type[] optionalCustomModifiers, Type[] requiredCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeOptionalCustomModifiers, Type[][] parameterTypeRequiredCustomModifiers)
 		{
 			this.callingConvention = callingConvention;
 			this.propertyType = propertyType;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 			this.parameterTypes = parameterTypes;
 			this.parameterOptionalCustomModifiers = parameterTypeOptionalCustomModifiers;
 			this.parameterRequiredCustomModifiers = parameterTypeRequiredCustomModifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="766" endline="778">
<![CDATA[
 
 		//
 		// Our constructor
 		//
 		public Iterator (ParametersBlock block, IMethodData method, TypeContainer host, TypeSpec iterator_type, bool is_enumerable)
 			
 		{
 			this.OriginalMethod = method;
 			this.OriginalIteratorType = iterator_type;
 			this.IsEnumerable = is_enumerable;
 			this.Host = host;
 			this.type = method.ReturnType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="242" endline="254">
<![CDATA[
 
     ''' <summary>
     ''' Create a new EmitInfo copying the values from the specified info.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Private Sub New(ByVal Info As EmitInfo)
         Me.m_DesiredType = Info.m_DesiredType
         Me.m_IsExplicitConversion = Info.m_IsExplicitConversion
         Me.m_IsRHS = Info.m_IsRHS
         Me.m_Method = Info.m_Method
         Me.m_RHSExpression = Info.m_RHSExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="579" endline="587">
<![CDATA[
 
 		public void SetDefinition (TypeSpec ts)
 		{
 			this.definition = ts.MemberDefinition;
 			this.info = ts.GetMetaInfo ();
 			this.BaseType = ts.BaseType;
 			this.Interfaces = ts.Interfaces;
 			this.modifiers = ts.Modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="283" endline="290">
<![CDATA[
 
     Protected Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent)
         m_LeftExpression = LExp
         m_LeftExpression.Parent = Me
         m_RightExpression = RExp
         m_RightExpression.Parent = Me
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="793" endline="828">
<![CDATA[
 		}
 
 		public readonly int LineBase;
 		public readonly int LineRange;
 		public readonly byte OpcodeBase;
 		public readonly int MaxAddressIncrement;
 
 #region Configurable constants
 		public const int Default_LineBase = -1;
 		public const int Default_LineRange = 8;
 		public const byte Default_OpcodeBase = 9;
 
 		public const bool SuppressDuplicates = true;
 #endregion
 
 		public const byte DW_LNS_copy = 1;
 		public const byte DW_LNS_advance_pc = 2;
 		public const byte DW_LNS_advance_line = 3;
 		public const byte DW_LNS_set_file = 4;
 		public const byte DW_LNS_const_add_pc = 8;
 
 		public const byte DW_LNE_end_sequence = 1;
 
 		// MONO extensions.
 		public const byte DW_LNE_MONO_negate_is_hidden = 0x40;
 
 		internal const byte DW_LNE_MONO__extensions_start = 0x40;
 		internal const byte DW_LNE_MONO__extensions_end   = 0x7f;
 
 		protected LineNumberTable (MonoSymbolFile file)
 		{
 			this.LineBase = file.OffsetTable.LineNumberTable_LineBase;
 			this.LineRange = file.OffsetTable.LineNumberTable_LineRange;
 			this.OpcodeBase = (byte) file.OffsetTable.LineNumberTable_OpcodeBase;
 			this.MaxAddressIncrement = (255 - OpcodeBase) / LineRange;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="327" endline="629">
<![CDATA[
 		
 		Constraints constraints;
 		GenericTypeParameterBuilder builder;
 		TypeParameterSpec spec;
 
 		public TypeParameter (DeclSpace parent, int index, MemberName name, Constraints constraints, Attributes attrs, Variance variance)
 			
 		{
 			this.constraints = constraints;
 			this.spec = new TypeParameterSpec (null, index, this, SpecialConstraint.None, variance, null);
 		}
 
 		public TypeParameter (TypeParameterSpec spec, DeclSpace parent, TypeSpec parentSpec, MemberName name, Attributes attrs)
 			
 		{
 			this.spec = new TypeParameterSpec (parentSpec, spec.DeclaredPosition, spec.MemberDefinition, spec.SpecialConstraint, spec.Variance, null) {
 				BaseType = spec.BaseType,
 				InterfacesDefined = spec.InterfacesDefined,
 				TypeArguments = spec.TypeArguments
 			};
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.GenericParameter;
 			}
 		}
 
 		public IAssemblyDefinition DeclaringAssembly {
 			get	{
 				return Module.DeclaringAssembly;
 			}
 		}
 
 		public override string DocCommentHeader {
 			get {
 				throw new InvalidOperationException (
 					"Unexpected attempt to get doc comment from " + this.GetType ());
 			}
 		}
 
 		public bool IsMethodTypeParameter {
 			get {
 				return spec.IsMethodOwned;
 			}
 		}
 
 		public string Namespace {
 			get {
 				return null;
 			}
 		}
 
 		public TypeParameterSpec Type {
 			get {
 				return spec;
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return 0;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				return null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_target;
 			}
 		}
 
 		public Variance Variance {
 			get {
 				return spec.Variance;
 			}
 		}
 
 		#endregion
 
 		//
 		// This is called for each part of a partial generic type definition.
 		//
 		// If partial type parameters constraints are not null and we don't
 		// already have constraints they become our constraints. If we already
 		// have constraints, we must check that they're the same.
 		//
 		public bool AddPartialConstraints (TypeContainer part, TypeParameter tp)
 		{
 			if (builder == null)
 				throw new InvalidOperationException ();
 
 			var new_constraints = tp.constraints;
 			if (new_constraints == null)
 				return true;
 
 			// TODO
 			//tp.Define (null, -1, part.Definition);
 			tp.spec.DeclaringType = part.Definition;
 			if (!tp.ResolveConstraints (part))
 				return false;
 
 			if (constraints != null)
 				return spec.HasSameConstraintsDefinition (tp.Type);
 
 			// Copy constraint from resolved part to partial container
 			spec.SpecialConstraint = tp.spec.SpecialConstraint;
 			spec.InterfacesDefined = tp.spec.InterfacesDefined;
 			spec.TypeArguments = tp.spec.TypeArguments;
 			spec.BaseType = tp.spec.BaseType;
 			
 			return true;
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public void CheckGenericConstraints ()
 		{
 			if (constraints != null)
 				constraints.CheckGenericConstraints (this);
 		}
 
 		public TypeParameter CreateHoistedCopy (TypeContainer declaringType, TypeSpec declaringSpec)
 		{
 			return new TypeParameter (spec, declaringType, declaringSpec, MemberName, null);
 		}
 
 		public override bool Define ()
 		{
 			return true;
 		}
 
 		//
 		// This is the first method which is called during the resolving
 		// process; we're called immediately after creating the type parameters
 		// with SRE (by calling `DefineGenericParameters()' on the TypeBuilder /
 		// MethodBuilder).
 		//
 		public void Define (GenericTypeParameterBuilder type, TypeSpec declaringType)
 		{
 			if (builder != null)
 				throw new InternalErrorException ();
 
 			this.builder = type;
 			spec.DeclaringType = declaringType;
 			spec.SetMetaInfo (type);
 		}
 
 		public void EmitConstraints (GenericTypeParameterBuilder builder)
 		{
 			var attr = GenericParameterAttributes.None;
 			if (spec.Variance == Variance.Contravariant)
 				attr |= GenericParameterAttributes.Contravariant;
 			else if (spec.Variance == Variance.Covariant)
 				attr |= GenericParameterAttributes.Covariant;
 
 			if (spec.HasSpecialClass)
 				attr |= GenericParameterAttributes.ReferenceTypeConstraint;
 			else if (spec.HasSpecialStruct)
 				attr |= GenericParameterAttributes.NotNullableValueTypeConstraint | GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.HasSpecialConstructor)
 				attr |= GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.BaseType != TypeManager.object_type)
 				builder.SetBaseTypeConstraint (spec.BaseType.GetMetaInfo ());
 
 			if (spec.InterfacesDefined != null)
 				builder.SetInterfaceConstraints (spec.InterfacesDefined.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			if (spec.TypeArguments != null)
 				builder.SetInterfaceConstraints (spec.TypeArguments.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			builder.SetGenericParameterAttributes (attr);
 		}
 
 		public override void Emit ()
 		{
 			EmitConstraints (builder);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			base.Emit ();
 		}
 
 		public void ErrorInvalidVariance (IMemberContext mc, Variance expected)
 		{
 			Report.SymbolRelatedToPreviousError (mc.CurrentMemberDefinition);
 			string input_variance = Variance == Variance.Contravariant ? "contravariant" 
 			string gtype_variance;
 			switch (expected) {
 			case Variance.Contravariant
 			case Variance.Covariant
 			default
 			}
 
 			Delegate d = mc as Delegate;
 			string parameters = d != null ? d.Parameters.GetSignatureForError () 
 
 			Report.Error (1961, Location,
 				"The {2} type parameter `{0}' must be {3} valid on `{1}{4}'",
 					GetSignatureForError (), mc.GetSignatureForError (), input_variance, gtype_variance, parameters);
 		}
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			return null;
 		}
 
 		public string GetAttributeDefaultMember ()
 		{
 			throw new NotSupportedException ();
 		}
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			throw new NotSupportedException ();
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return MemberName.Name;
 		}
 
 		bool ITypeDefinition.IsInternalAsPublic (IAssemblyDefinition assembly)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public void LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			throw new NotSupportedException ("Not supported for compiled definition");
 		}
 
 		//
 		// Resolves all type parameter constraints
 		//
 		public bool ResolveConstraints (IMemberContext context)
 		{
 			if (constraints != null)
 				return constraints.Resolve (context, this);
 
 			if (spec.BaseType == null)
 				spec.BaseType = TypeManager.object_type;
 
 			return true;
 		}
 
 		public static TypeParameter FindTypeParameter (TypeParameter[] tparams, string name)
 		{
 			foreach (var tp in tparams) {
 				if (tp.Name == name)
 					return tp;
 			}
 
 			return null;
 		}
 
 		public override bool IsClsComplianceRequired ()
 		{
 			return false;
 		}
 
 		public new void VerifyClsCompliance ()
 		{
 			if (constraints != null)
 				constraints.VerifyClsCompliance (Report);
 		}
 	}
 
 	[System.Diagnostics.DebuggerDisplay ("{DisplayDebugInfo()}")]
 	public class TypeParameterSpec 
 	{
 		public static readonly new TypeParameterSpec[] EmptyTypes = new TypeParameterSpec[0];
 
 		Variance variance;
 		SpecialConstraint spec;
 		readonly int tp_pos;
 		TypeSpec[] targs;
 		TypeSpec[] ifaces_defined;
 
 		//
 		// Creates type owned type parameter
 		//
 		public TypeParameterSpec (TypeSpec declaringType, int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 			this.variance = variance;
 			this.spec = spec;
 			state &= ~StateFlags.Obsolete_Undetected;
 			tp_pos = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6011" endline="6044">
<![CDATA[
 		int num_arguments = 0;
 		protected int dimensions;
 		protected readonly ComposedTypeSpecifier rank;
 		Expression first_emit;
 		LocalTemporary first_emit_temp;
 
 		protected List<Expression> array_data;
 
 		Dictionary<int, int> bounds;
 
 		// The number of constants in array initializers
 		int const_initializers_count;
 		bool only_constant_initializers;
 
 		public ArrayCreation (FullNamedExpression requested_base_type, List<Expression> exprs, ComposedTypeSpecifier rank, ArrayInitializer initializers, Location l)
 			
 		{
 			arguments = new List<Expression> (exprs);
 			num_arguments = arguments.Count;
 		}
 
 		//
 		// For expressions like int[] foo = new int[] { 1, 2, 3 };
 		//
 		public ArrayCreation (FullNamedExpression requested_base_type, ComposedTypeSpecifier rank, ArrayInitializer initializers, Location loc)
 		{
 			this.requested_base_type = requested_base_type;
 			this.rank = rank;
 			this.initializers = initializers;
 			this.loc = loc;
 
 			if (rank != null)
 				num_arguments = rank.Dimension;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="39" endline="45">
<![CDATA[
 
     Sub New(ByVal Compiler As Compiler, Optional ByVal SkipFunctionReturnVariable As Boolean = False, Optional ByVal CanFail As Boolean = False, Optional ByVal CanBeImplicitSimpleName As Boolean = True)
     Private m_Bits As New Collections.BitArray(32)
     Private Const c_SkipFunctionReturnVariable As Integer = 0
     Private Const c_CanFail As Integer = 1
     Private Const c_CanBeLateCall As Integer = 2
     Private Const c_CanBeImplicitSimpleName As Integer = 3
     Private Const c_EventResolution As Integer = 4
 
     Public Compiler As Compiler
 
     Private Shared DefaultInfo As ResolveInfo
 
     Shared Function [Default](ByVal Compiler As Compiler) As ResolveInfo
         If DefaultInfo Is Nothing OrElse Compiler Is DefaultInfo.Compiler = False Then
             DefaultInfo = New ResolveInfo(Compiler)
         End If
 
         Return DefaultInfo
     End Function
 
     Sub New(ByVal Compiler As Compiler, Optional ByVal SkipFunctionReturnVariable As Boolean = False, Optional ByVal CanFail As Boolean = False, Optional ByVal CanBeImplicitSimpleName As Boolean = True)
         Me.SkipFunctionReturnVariable = SkipFunctionReturnVariable
         Me.CanFail = CanFail
         Me.CanBeImplicitSimpleName = CanBeImplicitSimpleName
         Me.Compiler = Compiler
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="445" endline="454">
<![CDATA[
 
 		public void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark)
 		{
 			versionInfo = new VersionInfo();
 			versionInfo.product = product;
 			versionInfo.informationalVersion = productVersion;
 			versionInfo.company = company;
 			versionInfo.copyright = copyright;
 			versionInfo.trademark = trademark;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="45" endline="55">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="46" endline="54">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal Signature As SubSignature)
         MyBase.Init(Modifiers, Signature, Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="433" endline="442">
<![CDATA[
 
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Method As MethodDeclaration)
         MyBase.New(Classifications.MethodGroup, Parent)
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         m_Group.Add(Method.CecilBuilder)
         m_Resolved = True
         m_InstanceExpression = InstanceExpression
         m_TypeArguments = TypeArguments
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="47" endline="59">
<![CDATA[
     End Property
 End Class
 
 Public Class LoadLocalExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1244" endline="1253">
<![CDATA[
 	}
 
 	public class Attributes {
 		public readonly List<Attribute> Attrs;
 
 		public Attributes (Attribute a)
 		{
 			Attrs = new List<Attribute> ();
 			Attrs.Add (a);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1593" endline="1603">
<![CDATA[
 	}
 
 	public class IndexerSpec 
 	{
 		AParametersCollection parameters;
 
 		public IndexerSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, AParametersCollection parameters, PropertyInfo info, Modifiers modifiers)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="572" endline="578">
<![CDATA[
 
 		public void SetDefinition (ITypeDefinition td, MetaType type, Modifiers mod)
 		{
 			this.definition = td;
 			this.info = type;
 			this.modifiers |= (mod & ~Modifiers.AccessibilityMask);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="591" endline="600">
<![CDATA[
 
 End Class
 
 Public Class MemberCacheEntry
     Public Name As String
     Public Members As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
     Sub New(ByVal Name As String)
     Public Members As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
     Sub New(ByVal Name As String)
         Me.Name = Name
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="524" endline="536">
<![CDATA[
 		}
 	}
 
 	public class GroupJoin 
 	{
 		readonly RangeVariable into;
 
 		public GroupJoin (QueryBlock block, RangeVariable lt, Expression inner,
 			QueryBlock outerSelector, QueryBlock innerSelector, RangeVariable into, Location loc)
 			
 		{
 			this.into = into;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2229" endline="2235">
<![CDATA[
 
 		public GenericMethod (NamespaceEntry ns, DeclSpace parent, MemberName name, TypeParameter[] tparams,
 					  FullNamedExpression return_type, ParametersCompiled parameters)
 			
 		{
 			this.type_params = tparams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="718" endline="1185">
<![CDATA[
 				switch (ExplicitTarget) {
 				case "return"
 				case "param"
 				case "field"
 				case "method"
 				case "property"
 				case "module"
 				}
 				throw new InternalErrorException ("Unknown explicit target
 			}
 				
 			StringBuilder sb = new StringBuilder ();
 			foreach (string s in valid_targets) {
 				sb.Append (s);
 				sb.Append (", ");
 			}
 			sb.Remove (sb.Length - 2, 2);
 			Report.Error (657, Location, "`{0}' is not a valid attribute location for this declaration. " +
 				"Valid attribute locations for this declaration are `{1}'", ExplicitTarget, sb.ToString ());
 			return false;
 		}
 
 		/// <summary>
 		/// Tests permitted SecurityAction for assembly or other types
 		/// </summary>
 		protected virtual bool IsSecurityActionValid (bool for_assembly)
 		{
 			SecurityAction action = GetSecurityActionValue ();
 
 			switch (action) {
 #pragma warning disable 618
 			case SecurityAction.Demand
 			case SecurityAction.Assert
 			case SecurityAction.Deny
 			case SecurityAction.PermitOnly
 			case SecurityAction.LinkDemand
 			case SecurityAction.InheritanceDemand
 				if (!for_assembly)
 					return true;
 				break;
 
 			case SecurityAction.RequestMinimum
 			case SecurityAction.RequestOptional
 			case SecurityAction.RequestRefuse
 				if (for_assembly)
 					return true;
 				break;
 #pragma warning restore 618
 
 			default
 				Error_AttributeEmitError ("SecurityAction is out of range");
 				return false;
 			}
 
 			Error_AttributeEmitError (String.Concat ("SecurityAction `", action, "' is not valid for this declaration"));
 			return false;
 		}
 
 		System.Security.Permissions.SecurityAction GetSecurityActionValue ()
 		{
 			return (SecurityAction) ((Constant) PosArguments[0].Expr).GetValue ();
 		}
 
 		/// <summary>
 		/// Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
 		/// </summary>
 		/// <returns></returns>
 		public void ExtractSecurityPermissionSet (MethodSpec ctor, ref SecurityType permissions)
 		{
 #if STATIC
 			object[] values = new object [PosArguments.Count];
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 
 			PropertyInfo[] prop;
 			object[] prop_values;
 			if (named_values == null) {
 				prop = null;
 				prop_values = null;
 			} else {
 				prop = new PropertyInfo[named_values.Count];
 				prop_values = new object [named_values.Count];
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			var cab = new CustomAttributeBuilder ((ConstructorInfo) ctor.GetMetaInfo (), values, prop, prop_values);
 			permissions.Add (cab);
 #else
 			Type orig_assembly_type = null;
 
 			if (Type.MemberDefinition is TypeContainer) {
 				if (!RootContext.StdLib) {
 					orig_assembly_type = System.Type.GetType (Type.GetMetaInfo ().FullName);
 				} else {
 					string orig_version_path = Environment.GetEnvironmentVariable ("__SECURITY_BOOTSTRAP_DB");
 					if (orig_version_path == null) {
 						Error_AttributeEmitError ("security custom attributes can not be referenced from defining assembly");
 						return;
 					}
 
 					if (orig_sec_assembly == null) {
 						string file = Path.Combine (orig_version_path, Path.GetFileName (RootContext.OutputFile));
 						orig_sec_assembly = Assembly.LoadFile (file);
 					}
 
 					orig_assembly_type = orig_sec_assembly.GetType (Type.GetMetaInfo ().FullName, true);
 					if (orig_assembly_type == null) {
 						Report.Warning (-112, 1, Location, "Self-referenced security attribute `{0}' " +
 								"was not found in previous version of assembly");
 						return;
 					}
 				}
 			}
 
 			SecurityAttribute sa;
 			object[] args;
 
 			// For all non-selfreferencing security attributes we can avoid all hacks
 			if (orig_assembly_type == null) {
 				args = new object[PosArguments.Count];
 				for (int j = 0; j < args.Length; ++j) {
 					args[j] = ((Constant) PosArguments[j].Expr).GetValue ();
 				}
 
 				sa = (SecurityAttribute) Activator.CreateInstance (Type.GetMetaInfo (), args);
 
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						pi.SetValue (sa, ((Constant) named_values [i].Value.Expr).GetValue (), null);
 					}
 				}
 			} else {
 				// HACK
 				args = new object[] { GetSecurityActionValue () };
 				sa = (SecurityAttribute) Activator.CreateInstance (orig_assembly_type, args);
 
 				// All types are from newly created assembly but for invocation with old one we need to convert them
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo emited_pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						// FIXME
 						// TODO
 						PropertyInfo pi = orig_assembly_type.GetProperty (emited_pi.Name);
 
 						pi.SetValue (sa, ((Constant) named_values[i].Value.Expr).GetValue (), null);
 					}
 				}
 			}
 
 			IPermission perm;
 			perm = sa.CreatePermission ();
 			SecurityAction action = (SecurityAction) args [0];
 
 			// IS is correct because for corlib we are using an instance from old corlib
 			if (!(perm is System.Security.CodeAccessPermission)) {
 				switch (action) {
 				case SecurityAction.Demand
 					action = (SecurityAction)13;
 					break;
 				case SecurityAction.LinkDemand
 					action = (SecurityAction)14;
 					break;
 				case SecurityAction.InheritanceDemand
 					action = (SecurityAction)15;
 					break;
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			PermissionSet ps;
 			if (!permissions.TryGetValue (action, out ps)) {
 				if (sa is PermissionSetAttribute)
 					ps = new PermissionSet (sa.Unrestricted ? PermissionState.Unrestricted 
 				else
 					ps = new PermissionSet (PermissionState.None);
 
 				permissions.Add (action, ps);
 			} else if (!ps.IsUnrestricted () && (sa is PermissionSetAttribute) && sa.Unrestricted) {
 				ps = ps.Union (new PermissionSet (PermissionState.Unrestricted));
 				permissions [action] = ps;
 			}
 			ps.AddPermission (perm);
 #endif
 		}
 
 		public Constant GetNamedValue (string name)
 		{
 			if (named_values == null)
 				return null;
 
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 
 			return null;
 		}
 
 		public CharSet GetCharSetValue ()
 		{
 			return (CharSet)System.Enum.Parse (typeof (CharSet), ((Constant) PosArguments [0].Expr).GetValue ().ToString ());
 		}
 
 		public bool HasField (string fieldName)
 		{
 			if (named_values == null)
 				return false;
 
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 
 			return false;
 		}
 
 		//
 		// Returns true for MethodImplAttribute with MethodImplOptions.InternalCall value
 		// 
 		public bool IsInternalCall ()
 		{
 			MethodImplOptions options = 0;
 			if (PosArguments.Count == 1) {
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			} else if (HasField ("Value")) {
 				var named = GetNamedValue ("Value");
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), named.GetValue ().ToString ());
 			}
 
 			return (options & MethodImplOptions.InternalCall) != 0;
 		}
 
 		//
 		// Returns true for StructLayoutAttribute with LayoutKind.Explicit value
 		// 
 		public bool IsExplicitLayoutKind ()
 		{
 			if (PosArguments == null || PosArguments.Count != 1)
 				return false;
 
 			var value = (LayoutKind) System.Enum.Parse (typeof (LayoutKind), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			return value == LayoutKind.Explicit;
 		}
 
 		public Expression GetParameterDefaultValue ()
 		{
 			if (PosArguments == null)
 				return null;
 
 			return PosArguments[0].Expr;
 		}
 
 		public override bool Equals (object obj)
 		{
 			Attribute a = obj as Attribute;
 			if (a == null)
 				return false;
 
 			return Type == a.Type && Target == a.Target;
 		}
 
 		public override int GetHashCode ()
 		{
 			return type.GetHashCode () ^ Target.GetHashCode ();
 		}
 
 		/// <summary>
 		/// Emit attribute for Attributable symbol
 		/// </summary>
 		public void Emit (Dictionary<Attribute, List<Attribute>> allEmitted)
 		{
 			var ctor = Resolve ();
 			if (ctor == null)
 				return;
 
 			var predefined = context.Module.PredefinedAttributes;
 
 			AttributeUsageAttribute usage_attr = Type.GetAttributeUsage (predefined.AttributeUsage);
 			if ((usage_attr.ValidOn & Target) == 0) {
 				Report.Error (592, Location, "The attribute `{0}' is not valid on this declaration type. " +
 					      "It is valid on `{1}' declarations only",
 					GetSignatureForError (), GetValidTargets ());
 				return;
 			}
 
 			byte[] cdata;
 			if (PosArguments == null && named_values == null) {
 				cdata = AttributeEncoder.Empty;
 			} else {
 				AttributeEncoder encoder = new AttributeEncoder ();
 
 				if (PosArguments != null) {
 					var param_types = ctor.Parameters.Types;
 					for (int j = 0; j < PosArguments.Count; ++j) {
 						var pt = param_types[j];
 						var arg_expr = PosArguments[j].Expr;
 						if (j == 0) {
 							if (Type == predefined.IndexerName || Type == predefined.Conditional) {
 								string v = ((StringConstant) arg_expr).Value;
 								if (!Tokenizer.IsValidIdentifier (v) || Tokenizer.IsKeyword (v)) {
 									context.Compiler.Report.Error (633, arg_expr.Location,
 										"The argument to the `{0}' attribute must be a valid identifier", GetSignatureForError ());
 								}
 							} else if (Type == predefined.Guid) {
 								try {
 									string v = ((StringConstant) arg_expr).Value;
 									new Guid (v);
 								} catch (Exception e) {
 									Error_AttributeEmitError (e.Message);
 									return;
 								}
 							} else if (Type == predefined.AttributeUsage) {
 								int v = ((IntConstant) ((EnumConstant) arg_expr).Child).Value;
 								if (v == 0) {
 									context.Compiler.Report.Error (591, Location, "Invalid value for argument to `{0}' attribute",
 										"System.AttributeUsage");
 								}
 							} else if (Type == predefined.MarshalAs) {
 								if (PosArguments.Count == 1) {
 									var u_type = (UnmanagedType) System.Enum.Parse (typeof (UnmanagedType), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 									if (u_type == UnmanagedType.ByValArray && !(Owner is FieldBase)) {
 										Error_AttributeEmitError ("Specified unmanaged type is only valid on fields");
 									}
 								}
 							} else if (Type == predefined.DllImport) {
 								if (PosArguments.Count == 1) {
 									var value = ((Constant) PosArguments[0].Expr).GetValue () as string;
 									if (string.IsNullOrEmpty (value))
 										Error_AttributeEmitError ("DllName cannot be empty");
 								}
 							} else if (Type == predefined.MethodImpl && pt == TypeManager.short_type &&
 								!System.Enum.IsDefined (typeof (MethodImplOptions), ((Constant) arg_expr).GetValue ().ToString ())) {
 								Error_AttributeEmitError ("Incorrect argument value.");
 								return;
 							}
 						}
 
 						arg_expr.EncodeAttributeValue (context, encoder, pt);
 					}
 				}
 
 				if (named_values != null) {
 					encoder.Encode ((ushort) named_values.Count);
 					foreach (var na in named_values) {
 						if (na.Key is FieldExpr)
 							encoder.Encode ((byte) 0x53);
 						else
 							encoder.Encode ((byte) 0x54);
 
 						encoder.Encode (na.Key.Type);
 						encoder.Encode (na.Value.Name);
 						na.Value.Expr.EncodeAttributeValue (context, encoder, na.Key.Type);
 					}
 				} else {
 					encoder.EncodeEmptyNamedArguments ();
 				}
 
 				cdata = encoder.ToArray ();
 			}
 
 			try {
 				foreach (Attributable target in targets)
 					target.ApplyAttributeBuilder (this, ctor, cdata, predefined);
 			} catch (Exception e) {
 				Error_AttributeEmitError (e.Message);
 				return;
 			}
 
 			if (!usage_attr.AllowMultiple && allEmitted != null) {
 				if (allEmitted.ContainsKey (this)) {
 					var a = allEmitted [this];
 					if (a == null) {
 						a = new List<Attribute> (2);
 						allEmitted [this] = a;
 					}
 					a.Add (this);
 				} else {
 					allEmitted.Add (this, null);
 				}
 			}
 
 			if (!RootContext.VerifyClsCompliance)
 				return;
 
 			// Here we are testing attribute arguments for array usage (error 3016)
 			if (Owner.IsClsComplianceRequired ()) {
 				if (PosArguments != null)
 					PosArguments.CheckArrayAsAttribute (context.Compiler);
 			
 				if (NamedArguments == null)
 					return;
 
 				NamedArguments.CheckArrayAsAttribute (context.Compiler);
 			}
 		}
 
 		private Expression GetValue () 
 		{
 			if (PosArguments == null || PosArguments.Count < 1)
 				return null;
 
 			return PosArguments [0].Expr;
 		}
 
 		public string GetString () 
 		{
 			Expression e = GetValue ();
 			if (e is StringConstant)
 				return ((StringConstant)e).Value;
 			return null;
 		}
 
 		public bool GetBoolean () 
 		{
 			Expression e = GetValue ();
 			if (e is BoolConstant)
 				return ((BoolConstant)e).Value;
 			return false;
 		}
 
 		public TypeSpec GetArgumentType ()
 		{
 			TypeOf e = GetValue () as TypeOf;
 			if (e == null)
 				return null;
 			return e.TypeArgument;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			throw new NotSupportedException ("ET");
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 	}
 	
 
 	/// <summary>
 	/// For global attributes (assembly, module) we need special handling.
 	/// Attributes can be located in the several files
 	/// </summary>
 	public class GlobalAttribute 
 	{
 		public readonly NamespaceEntry ns;
 
 		public GlobalAttribute (NamespaceEntry ns, string target, ATypeNameExpression expression,
 					Arguments[] args, Location loc, bool nameEscaped)
 			base (target, expression, args, loc, nameEscaped)
 		{
 			this.ns = ns;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="929" endline="945">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Represents the methods parameters
 	/// </summary>
 	public class ParametersCompiled 
 	{
 		public static readonly ParametersCompiled EmptyReadOnlyParameters = new ParametersCompiled ();
 		
 		// Used by C# 2.0 delegates
 		public static readonly ParametersCompiled Undefined = new ParametersCompiled ();
 
 		private ParametersCompiled ()
 		{
 			parameters = new Parameter [0];
 			types = TypeSpec.EmptyTypes;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="139" endline="267">
<![CDATA[
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
 
 		public Enum (NamespaceEntry ns, DeclSpace parent, TypeExpression type,
 			     Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			base_type_expr = type;
 			var accmods = IsTopLevel ? Modifiers.INTERNAL 
 			ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod_flags, accmods, Location, Report);
 			spec = new EnumSpec (null, this, null, null, ModFlags);
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Enum;
 			}
 		}
 
 		public TypeExpr BaseTypeExpression {
 			get {
 				return base_type_expr;
 			}
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
 		}
 
 		public TypeSpec UnderlyingType {
 			get {
 				return ((EnumSpec) spec).UnderlyingType;
 			}
 		}
 
 		#endregion
 
 		public void AddEnumMember (EnumMember em)
 		{
 			if (em.Name == UnderlyingValueField) {
 				Report.Error (76, em.Location, "An item in an enumeration cannot have an identifier `{0}'",
 					UnderlyingValueField);
 				return;
 			}
 
 			AddConstant (em);
 		}
 
 		public static void Error_1008 (Location loc, Report Report)
 		{
 			Report.Error (1008, loc,
 				"Type byte, sbyte, short, ushort, int, uint, long or ulong expected");
 		}
 
 		protected override bool DefineNestedTypes ()
 		{
 			((EnumSpec) spec).UnderlyingType = base_type_expr == null ? TypeManager.int32_type 
 
 			TypeBuilder.DefineField (UnderlyingValueField, UnderlyingType.GetMetaInfo (),
 				FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
 
 			if (!RootContext.StdLib)
 				Module.hack_corlib_enums.Add (this);
 
 			return true;
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			if (constants != null) {
 				for (int i = 0; i < constants.Count; ++i) {
 					EnumMember em = (EnumMember) constants [i];
 					if (em.Initializer == null) {
 						em.Initializer = new ImplicitInitializer (em, i == 0 ? null 
 					}
 
 					em.Define ();
 				}
 			}
 
 			return true;
 		}
 
 		public override bool IsUnmanagedType ()
 		{
 			return true;
 		}
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.enum_type;
 			base_class = base_type_expr;
 			return null;
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (UnderlyingType == TypeManager.uint32_type ||
 				UnderlyingType == TypeManager.uint64_type ||
 				UnderlyingType == TypeManager.ushort_type) {
 				Report.Warning (3009, 1, Location, "`{0}'
 			}
 
 			return true;
 		}	
 	}
 
 	class EnumSpec 
 	{
 		TypeSpec underlying;
 
 		public EnumSpec (TypeSpec declaringType, ITypeDefinition definition, TypeSpec underlyingType, MetaType info, Modifiers modifiers)
 			
 		{
 			this.underlying = underlyingType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="85" endline="91">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As TypeName)
         MyBase.Init(Modifiers, Name)
         m_TypeName = VariableType
 
         Helper.Assert(m_TypeName IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="36" endline="42">
<![CDATA[
 		private readonly IMAGE_NT_HEADERS hdr = new IMAGE_NT_HEADERS();
 
 		internal PEWriter(Stream stream)
 		{
 			bw = new BinaryWriter(stream);
 			WriteMSDOSHeader();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="186" endline="476">
<![CDATA[
 	}
 
 	public interface IGenericMethodDefinition 
 	{
 		TypeParameterSpec[] TypeParameters { get; }
 		int TypeParametersCount { get; }
 
 //		MethodInfo MakeGenericMethod (TypeSpec[] targs);
 	}
 
 	public sealed class MethodSpec 
 	{
 		MethodBase metaInfo, inflatedMetaInfo;
 		AParametersCollection parameters;
 		TypeSpec returnType;
 
 		TypeSpec[] targs;
 		TypeParameterSpec[] constraints;
 
 		public MethodSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition details, TypeSpec returnType,
 			MethodBase info, AParametersCollection parameters, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.parameters = parameters;
 			this.returnType = returnType;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return IsGeneric ? GenericDefinition.TypeParametersCount 
 			}
 		}
 
 		public TypeParameterSpec[] Constraints {
 			get {
 				if (constraints == null && IsGeneric)
 					constraints = GenericDefinition.TypeParameters;
 
 				return constraints;
 			}
 		}
 
 		public bool IsConstructor {
 			get {
 				return Kind == MemberKind.Constructor;
 			}
 		}
 
 		public IGenericMethodDefinition GenericDefinition {
 			get {
 				return (IGenericMethodDefinition) definition;
 			}
 		}
 
 		public bool IsExtensionMethod {
 			get {
 				return IsStatic && parameters.HasExtensionMethodType;
 			}
 		}
 
 		public bool IsSealed {
 			get {
 				return (Modifiers & Modifiers.SEALED) != 0;
 			}
 		}
 
 		// When is virtual or abstract
 		public bool IsVirtual {
 			get {
 				return (Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE)) != 0;
 			}
 		}
 
 		public bool IsReservedMethod {
 			get {
 				return Kind == MemberKind.Operator || IsAccessor;
 			}
 		}
 
 		TypeSpec IInterfaceMemberSpec.MemberType {
 			get {
 				return returnType;
 			}
 		}
 
 		public AParametersCollection Parameters {
 			get { 
 				return parameters;
 			}
 		}
 
 		public TypeSpec ReturnType {
 			get {
 				return returnType;
 			}
 		}
 
 		public TypeSpec[] TypeArguments {
 			get {
 				return targs;
 			}
 		}
 
 		#endregion
 
 		public MethodSpec GetGenericMethodDefinition ()
 		{
 			if (!IsGeneric && !DeclaringType.IsGeneric)
 				return this;
 
 			return MemberCache.GetMember (declaringType, this);
 		}
 
 		public MethodBase GetMetaInfo ()
 		{
 			//
 			// inflatedMetaInfo is extra field needed for cases where we
 			// inflate method but another nested type can later inflate
 			// again (the cache would be build with inflated metaInfo) and
 			// TypeBuilder can work with method definitions only
 			//
 			if (inflatedMetaInfo == null) {
 				if ((state & StateFlags.PendingMetaInflate) != 0) {
 					var dt_meta = DeclaringType.GetMetaInfo ();
 
 					if (DeclaringType.IsTypeBuilder) {
 						if (IsConstructor)
 							inflatedMetaInfo = TypeBuilder.GetConstructor (dt_meta, (ConstructorInfo) metaInfo);
 						else
 							inflatedMetaInfo = TypeBuilder.GetMethod (dt_meta, (MethodInfo) metaInfo);
 					} else {
 #if STATIC
 						// it should not be reached
 						throw new NotImplementedException ();
 #else
 						inflatedMetaInfo = MethodInfo.GetMethodFromHandle (metaInfo.MethodHandle, dt_meta.TypeHandle);
 #endif
 					}
 
 					state &= ~StateFlags.PendingMetaInflate;
 				} else {
 					inflatedMetaInfo = metaInfo;
 				}
 			}
 
 			if ((state & StateFlags.PendingMakeMethod) != 0) {
 				var sre_targs = new MetaType[targs.Length];
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 
 				inflatedMetaInfo = ((MethodInfo) inflatedMetaInfo).MakeGenericMethod (sre_targs);
 				state &= ~StateFlags.PendingMakeMethod;
 			}
 
 			return inflatedMetaInfo;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name;
 			if (IsConstructor) {
 				name = DeclaringType.GetSignatureForError () + "." + DeclaringType.Name;
 			} else if (Kind == MemberKind.Operator) {
 				var op = Operator.GetType (Name).Value;
 				if (op == Operator.OpType.Implicit || op == Operator.OpType.Explicit) {
 					name = DeclaringType.GetSignatureForError () + "." + Operator.GetName (op) + " operator " + returnType.GetSignatureForError ();
 				} else {
 					name = DeclaringType.GetSignatureForError () + ".operator " + Operator.GetName (op);
 				}
 			} else if (IsAccessor) {
 				int split = Name.IndexOf ('_');
 				name = Name.Substring (split + 1);
 				var postfix = Name.Substring (0, split);
 				if (split == 3) {
 					var pc = parameters.Count;
 					if (pc > 0 && postfix == "get") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc);
 					} else if (pc > 1 && postfix == "set") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc - 1);
 					}
 				}
 
 				return DeclaringType.GetSignatureForError () + "." + name + "." + postfix;
 			} else {
 				name = base.GetSignatureForError ();
 				if (targs != null)
 					name += "<" + TypeManager.CSharpName (targs) + ">";
 				else if (IsGeneric)
 					name += "<" + TypeManager.CSharpName (GenericDefinition.TypeParameters) + ">";
 			}
 
 			return name + parameters.GetSignatureForError ();
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var ms = (MethodSpec) base.InflateMember (inflator);
 			ms.inflatedMetaInfo = null;
 			ms.returnType = inflator.Inflate (returnType);
 			ms.parameters = parameters.Inflate (inflator);
 			if (IsGeneric)
 				ms.constraints = TypeParameterSpec.InflateConstraints (inflator, Constraints);
 
 			return ms;
 		}
 
 		public MethodSpec MakeGenericMethod (params TypeSpec[] targs)
 		{
 			if (targs == null)
 				throw new ArgumentNullException ();
 // TODO MemberCache
 //			if (generic_intances != null && generic_intances.TryGetValue (targs, out ginstance))
 //				return ginstance;
 
 			//if (generic_intances == null)
 			//    generic_intances = new Dictionary<TypeSpec[], Method> (TypeSpecArrayComparer.Default);
 
 			var inflator = new TypeParameterInflator (DeclaringType, GenericDefinition.TypeParameters, targs);
 
 			var inflated = (MethodSpec) MemberwiseClone ();
 			inflated.declaringType = inflator.TypeInstance;
 			inflated.returnType = inflator.Inflate (returnType);
 			inflated.parameters = parameters.Inflate (inflator);
 			inflated.targs = targs;
 			inflated.constraints = TypeParameterSpec.InflateConstraints (inflator, constraints ?? GenericDefinition.TypeParameters);
 			inflated.state |= StateFlags.PendingMakeMethod;
 
 			//			if (inflated.parent == null)
 			//				inflated.parent = parent;
 
 			//generic_intances.Add (targs, inflated);
 			return inflated;
 		}
 
 		public MethodSpec Mutate (TypeParameterMutator mutator)
 		{
 			var targs = TypeArguments;
 			if (targs != null)
 				targs = mutator.Mutate (targs);
 
 			var decl = DeclaringType;
 			if (DeclaringType.IsGenericOrParentIsGeneric) {
 				decl = mutator.Mutate (decl);
 			}
 
 			if (targs == TypeArguments && decl == DeclaringType)
 				return this;
 
 			var ms = (MethodSpec) MemberwiseClone ();
 			if (decl != DeclaringType) {
 				ms.inflatedMetaInfo = null;
 				ms.declaringType = decl;
 				ms.state |= StateFlags.PendingMetaInflate;
 			}
 
 			if (targs != null) {
 				ms.targs = targs;
 				ms.state |= StateFlags.PendingMakeMethod;
 			}
 
 			return ms;
 		}
 
 		public void SetMetaInfo (MethodInfo info)
 		{
 			if (this.metaInfo != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.metaInfo = info;
 		}
 	}
 
 	public abstract class MethodOrOperator 
 	{
 		public MethodBuilder MethodBuilder;
 		ReturnParameter return_attributes;
 		SecurityType declarative_security;
 		protected MethodData MethodData;
 
 		static string[] attribute_targets = new string [] { "method", "return" };
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="23" endline="45">
<![CDATA[
 
 		private ReferenceEquality ()
 		{
 		}
 
 		public bool Equals (T x, T y)
 		{
 			return ReferenceEquals (x, y);
 		}
 
 		public int GetHashCode (T obj)
 		{
 			return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode (obj);
 		}
 	}
 
 	public class Tuple<T1, T2> 
 	{
 		public Tuple (T1 item1, T2 item2)
 		{
 			Item1 = item1;
 			Item2 = item2;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="728" endline="737">
<![CDATA[
 	}
 
 	public class FlowBranchingTryCatch 
 	{
 		TryCatch stmt;
 		public FlowBranchingTryCatch (FlowBranching parent, TryCatch stmt)
 			
 		{
 			this.stmt = stmt;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="867" endline="877">
<![CDATA[
 		}
 
 		SavedOrigin saved_origins;
 
 		public FlowBranchingException (FlowBranching parent,
 					       ExceptionStatement stmt)
 			
 				null, stmt.loc)
 		{
 			this.stmt = stmt;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="168" endline="176">
<![CDATA[
 	}
 
 	public class ArglistParameter 
 		// Doesn't have proper type because it's never chosen for better conversion
 		public ArglistParameter (Location loc) 
 			base (null, String.Empty, Parameter.Modifier.NONE, null, loc)
 		{
 			parameter_type = InternalType.Arglist;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7462" endline="7476">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the qualified-alias-member (
 	/// </summary>
 	public class QualifiedAliasMember 
 	{
 		readonly string alias;
 		public static readonly string GlobalAlias = "global";
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="558" endline="750">
<![CDATA[
 	}
 
 	class DynamicIndexBinder 
 	{
 		bool can_be_mutator;
 
 		public DynamicIndexBinder (Arguments args, Location loc)
 			
 		{
 		}
 
 		public DynamicIndexBinder (CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			can_be_mutator = true;
 			return base.DoResolve (ec);
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
 
 		protected override Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			//
 			// Indexer has arguments which complicates things as the setter and getter
 			// are called in two steps when unary mutator is used. We have to make a
 			// copy of all variable arguments to not duplicate any side effect.
 			//
 			// ++d[++arg, Foo ()]
 			//
 
 			if (!can_be_mutator)
 				return base.CreateSetterArguments (rc, rhs);
 
 			var setter_args = new Arguments (Arguments.Count + 1);
 			for (int i = 0; i < Arguments.Count; ++i) {
 				var expr = Arguments[i].Expr;
 
 				if (expr is Constant || expr is VariableReference || expr is This) {
 					setter_args.Add (Arguments [i]);
 					continue;
 				}
 
 				LocalVariable temp = LocalVariable.CreateCompilerGenerated (expr.Type, rc.CurrentBlock, loc);
 				expr = new SimpleAssign (temp.CreateReferenceExpression (rc, expr.Location), expr).Resolve (rc);
 				Arguments[i].Expr = temp.CreateReferenceExpression (rc, expr.Location).Resolve (rc);
 				setter_args.Add (Arguments [i].Clone (expr));
 			}
 
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
 	}
 
 	class DynamicInvocation 
 	{
 		ATypeNameExpression member;
 
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 			this.member = member;
 		}
 
 		//
 		// When a return type is known not to be dynamic
 		//
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 		}
 
 		public static DynamicInvocation CreateSpecialNameInvoke (ATypeNameExpression member, Arguments args, Location loc)
 		{
 			return new DynamicInvocation (member, args, loc) {
 				flags = CSharpBinderFlags.InvokeSpecialName
 			};
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (member != null ? 5 
 			bool is_member_access = member is MemberAccess;
 
 			CSharpBinderFlags call_flags;
 			if (!is_member_access && member is SimpleName) {
 				call_flags = CSharpBinderFlags.InvokeSimpleName;
 				is_member_access = true;
 			} else {
 				call_flags = 0;
 			}
 
 			binder_args.Add (new Argument (new BinderFlags (call_flags, this)));
 
 			if (is_member_access)
 				binder_args.Add (new Argument (new StringLiteral (member.Name, member.Location)));
 
 			if (member != null && member.HasTypeArguments) {
 				TypeArguments ta = member.TypeArguments;
 				if (ta.Resolve (ec)) {
 					var targs = new ArrayInitializer (ta.Count, loc);
 					foreach (TypeSpec t in ta.Arguments)
 						targs.Add (new TypeOf (new TypeExpression (t, loc), loc));
 
 					binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (targs, loc)));
 				}
 			} else if (is_member_access) {
 				binder_args.Add (new Argument (new NullLiteral (loc)));
 			}
 
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 
 			Expression real_args;
 			if (args == null) {
 				// Cannot be null because .NET trips over
 				real_args = new ArrayCreation (
 					new MemberAccess (GetBinderNamespace (loc), "CSharpArgumentInfo", loc),
 					new ArrayInitializer (0, loc), loc);
 			} else {
 				real_args = new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc);
 			}
 
 			binder_args.Add (new Argument (real_args));
 
 			return new Invocation (GetBinder (is_member_access ? "InvokeMember" 
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			flags |= CSharpBinderFlags.ResultDiscarded;
 			base.EmitStatement (ec);
 		}
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
 
 		public DynamicMemberBinder (string name, CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
 	}
 
 	//
 	// Any member binder which can be source and target of assignment
 	//
 	abstract class DynamicMemberAssignable 
 	{
 		Expression setter;
 		Arguments setter_args;
 
 		protected DynamicMemberAssignable (Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9137" endline="9150">
<![CDATA[
 	}
 
 	//
 	// An object initializer expression
 	//
 	public class ElementInitializer 
 	{
 		public readonly string Name;
 
 		public ElementInitializer (string name, Expression initializer, Location loc)
 			
 		{
 			this.Name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="125" endline="131">
<![CDATA[
 
     Sub RestoreToPoint(ByVal Point As RestorablePoint)
         m_CurrentIndex = Point.Index
         Current = m_TokenList(m_CurrentIndex)
         'Console.WriteLine(" Restored to
         IgnoreRestoredPoint()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2005" endline="2069">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Operator {
 			Multiply	= 0 | ArithmeticMask,
 			Division	= 1 | ArithmeticMask,
 			Modulus		= 2 | ArithmeticMask,
 			Addition	= 3 | ArithmeticMask | AdditionMask,
 			Subtraction = 4 | ArithmeticMask | SubtractionMask,
 
 			LeftShift	= 5 | ShiftMask,
 			RightShift	= 6 | ShiftMask,
 
 			LessThan	= 7 | ComparisonMask | RelationalMask,
 			GreaterThan	= 8 | ComparisonMask | RelationalMask,
 			LessThanOrEqual		= 9 | ComparisonMask | RelationalMask,
 			GreaterThanOrEqual	= 10 | ComparisonMask | RelationalMask,
 			Equality	= 11 | ComparisonMask | EqualityMask,
 			Inequality	= 12 | ComparisonMask | EqualityMask,
 
 			BitwiseAnd	= 13 | BitwiseMask,
 			ExclusiveOr	= 14 | BitwiseMask,
 			BitwiseOr	= 15 | BitwiseMask,
 
 			LogicalAnd	= 16 | LogicalMask,
 			LogicalOr	= 17 | LogicalMask,
 
 			//
 			// Operator masks
 			//
 			ValuesOnlyMask	= ArithmeticMask - 1,
 			ArithmeticMask	= 1 << 5,
 			ShiftMask		= 1 << 6,
 			ComparisonMask	= 1 << 7,
 			EqualityMask	= 1 << 8,
 			BitwiseMask		= 1 << 9,
 			LogicalMask		= 1 << 10,
 			AdditionMask	= 1 << 11,
 			SubtractionMask	= 1 << 12,
 			RelationalMask	= 1 << 13
 		}
 
 		protected enum State
 		{
 			None = 0,
 			Compound = 1 << 1,
 			LeftNullLifted = 1 << 2,
 			RightNullLifted = 1 << 3
 		}
 
 		readonly Operator oper;
 		protected Expression left, right;
 		protected State state;
 		Expression enum_conversion;
 
 		static PredefinedOperator[] standard_operators;
 		static PredefinedOperator[] equality_operators;
 		static PredefinedOperator[] pointer_operators;
 		
 		public Binary (Operator oper, Expression left, Expression right, bool isCompound, Location loc)
 			
 		{
 			if (isCompound)
 				state |= State.Compound;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9272" endline="9279">
<![CDATA[
 		}
 
 		public CollectionElementInitializer (Expression argument)
 			
 		{
 			base.arguments.Add (new ElementInitializerArgument (argument));
 			this.loc = argument.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="58" endline="64">
<![CDATA[
 
     Friend Sub ChangeQualifiedIdentifier(ByVal qi As QualifiedIdentifier)
         Helper.Assert(IsQualifiedIdentifier)
         'Helper.Assert(AsQualifiedIdentifier.Second IsNot Nothing)
         Helper.Assert(AsQualifiedIdentifier.First Is qi)
         m_TypeName = qi
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="635" endline="644">
<![CDATA[
 	}
 
 	public class FlowBranchingIterator 
 	{
 		Iterator iterator;
 		public FlowBranchingIterator (FlowBranching parent, Iterator iterator)
 			
 		{
 			this.iterator = iterator;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="755" endline="766">
<![CDATA[
 		}
 	}
 
 	class HoistedLocalVariable 
 	{
 		readonly string name;
 
 		public HoistedLocalVariable (AnonymousMethodStorey scope, LocalVariable local, string name)
 			
 		{
 			this.name = local.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="717" endline="725">
<![CDATA[
 		}
 
 		readonly ParameterReference parameter;
 
 		public HoistedParameter (AnonymousMethodStorey scope, ParameterReference par)
 			
 		{
 			this.parameter = par;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1613" endline="1623">
<![CDATA[
 	}
 
 	class ImportedGenericMethodDefinition 
 	{
 		readonly TypeParameterSpec[] tparams;
 
 		public ImportedGenericMethodDefinition (MethodInfo provider, TypeSpec type, AParametersCollection parameters, TypeParameterSpec[] tparams, MetadataImporter importer)
 			
 		{
 			this.tparams = tparams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2214" endline="2228">
<![CDATA[
 	}
 
 	/// <summary>
 	///   A generic method definition.
 	/// </summary>
 	public class GenericMethod 
 	{
 		ParametersCompiled parameters;
 
 		public GenericMethod (NamespaceEntry ns, DeclSpace parent, MemberName name,
 				      FullNamedExpression return_type, ParametersCompiled parameters)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="305" endline="320">
<![CDATA[
 	}
 
 	public class PredefinedType
 	{
 		string name;
 		string ns;
 		int arity;
 		MemberKind kind;
 		ModuleContainer module;
 		protected TypeSpec type;
 
 		public PredefinedType (ModuleContainer module, MemberKind kind, string ns, string name, int arity)
 			
 		{
 			this.arity = arity;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9495" endline="9506">
<![CDATA[
 
 			#endregion
 		}
 
 		CollectionOrObjectInitializers initializers;
 		IMemoryLocation instance;
 
 		public NewInitialize (FullNamedExpression requested_type, Arguments arguments, CollectionOrObjectInitializers initializers, Location l)
 			
 		{
 			this.initializers = initializers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1569" endline="1579">
<![CDATA[
 	}
 
 	class ImportedParameterMemberDefinition 
 	{
 		readonly AParametersCollection parameters;
 
 		public ImportedParameterMemberDefinition (MethodBase provider, TypeSpec type, AParametersCollection parameters, MetadataImporter importer)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8998" endline="9013">
<![CDATA[
 	}
 
 
 	//
 	// This class is used to represent the address of an array, used
 	// only by the Fixed statement, this generates "&a [0]" construct
 	// for fixed (char *pa = a)
 	//
 	public class ArrayPtr 
 		TypeSpec array_type;
 		
 		public ArrayPtr (Expression array, TypeSpec array_type, Location l)
 			base (array, array_type, l)
 		{
 			this.array_type = array_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="636" endline="644">
<![CDATA[
 
 		//
 		// When a return type is known not to be dynamic
 		//
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="268" endline="276">
<![CDATA[
 		}
 
 		protected RangeVariable identifier;
 
 		protected ARangeVariableQueryClause (QueryBlock block, RangeVariable identifier, Expression expr, Location loc)
 			
 		{
 			this.identifier = identifier;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1765" endline="1780">
<![CDATA[
 		}
 	}
 
 	//
 	// Opcode casts expression with 2 opcodes but only
 	// single expression tree node
 	//
 	class OpcodeCastDuplex 
 	{
 		readonly OpCode second;
 
 		public OpcodeCastDuplex (Expression child, TypeSpec returnType, OpCode first, OpCode second)
 			
 		{
 			this.second = second;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="389" endline="397">
<![CDATA[
 	}
 
 	class QueryStartClause 
 	{
 		public QueryStartClause (QueryBlock block, Expression expr, RangeVariable identifier, Location loc)
 			
 		{
 			block.AddRangeVariable (identifier);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="442" endline="456">
<![CDATA[
 	}
 
 	public class AnonymousScopeEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly int ID;
 		#endregion
 
 		List<CapturedVariable> captured_vars = new List<CapturedVariable> ();
 		List<CapturedScope> captured_scopes = new List<CapturedScope> ();
 
 		public AnonymousScopeEntry (int id)
 		{
 			this.ID = id;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="624" endline="635">
<![CDATA[
 	}
 
 	sealed class ManifestModule 
 	{
 		private readonly AssemblyBuilder assembly;
 		private readonly Guid guid = Guid.NewGuid();
 
 		internal ManifestModule(AssemblyBuilder assembly)
 			
 		{
 			this.assembly = assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4094" endline="4105">
<![CDATA[
 	}
 
 	public class Lock 
 		Expression expr;
 		TemporaryVariableReference expr_copy;
 		TemporaryVariableReference lock_taken;
 			
 		public Lock (Expression expr, Statement stmt, Location loc)
 			
 		{
 			this.expr = expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4755" endline="4764">
<![CDATA[
 	}
 
 	public class TryFinally 
 		Block fini;
 
 		public TryFinally (Statement stmt, Block fini, Location loc)
 			 
 		{
 			this.fini = fini;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5078" endline="5086">
<![CDATA[
 		}
 
 		VariableDeclaration decl;
 
 		public Using (VariableDeclaration decl, Statement stmt, Location loc)
 			
 		{
 			this.decl = decl;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1543" endline="1553">
<![CDATA[
 	}
 
 	class ImportedMemberDefinition 
 	{
 		readonly TypeSpec type;
 
 		public ImportedMemberDefinition (MemberInfo member, TypeSpec type, MetadataImporter importer)
 			
 		{
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1737" endline="1747">
<![CDATA[
 	}
 	
 	class OpcodeCast 
 	{
 		readonly OpCode op;
 		
 		public OpcodeCast (Expression child, TypeSpec return_type, OpCode op)
 			
 		{
 			this.op = op;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1261" endline="1272">
<![CDATA[
 
 			#endregion
 		}
 
 		readonly int rank;
 		static Dictionary<TypeRankPair, ArrayContainer> instances = new Dictionary<TypeRankPair, ArrayContainer> ();
 
 		private ArrayContainer (TypeSpec element, int rank)
 			
 		{
 			this.rank = rank;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="38" endline="142">
<![CDATA[
 		private ByteBuffer bb;
 		private List<int> linkOffsets;
 
 		internal void AddVersionInfo(ByteBuffer versionInfo)
 		{
 			root[new OrdinalOrName(RT_VERSION)][new OrdinalOrName(1)][new OrdinalOrName(0)].Data = versionInfo;
 		}
 
 		internal void AddIcon(byte[] iconFile)
 		{
 			BinaryReader br = new BinaryReader(new MemoryStream(iconFile));
 			ushort idReserved = br.ReadUInt16();
 			ushort idType = br.ReadUInt16();
 			ushort idCount = br.ReadUInt16();
 			if (idReserved != 0 || idType != 1)
 			{
 				throw new ArgumentException("The supplied byte array is not a valid .ico file.");
 			}
 			ByteBuffer group = new ByteBuffer(6 + 14 * idCount);
 			group.Write(idReserved);
 			group.Write(idType);
 			group.Write(idCount);
 			for (int i = 0; i < idCount; i++)
 			{
 				byte bWidth = br.ReadByte();
 				byte bHeight = br.ReadByte();
 				byte bColorCount = br.ReadByte();
 				byte bReserved = br.ReadByte();
 				ushort wPlanes = br.ReadUInt16();
 				ushort wBitCount = br.ReadUInt16();
 				uint dwBytesInRes = br.ReadUInt32();
 				uint dwImageOffset = br.ReadUInt32();
 
 				// we start the icon IDs at 2
 				ushort id = (ushort)(2 + i);
 
 				group.Write(bWidth);
 				group.Write(bHeight);
 				group.Write(bColorCount);
 				group.Write(bReserved);
 				group.Write(wPlanes);
 				group.Write(wBitCount);
 				group.Write(dwBytesInRes);
 				group.Write(id);
 
 				byte[] icon = new byte[dwBytesInRes];
 				Buffer.BlockCopy(iconFile, (int)dwImageOffset, icon, 0, icon.Length);
 				root[new OrdinalOrName(RT_ICON)][new OrdinalOrName(id)][new OrdinalOrName(0)].Data = ByteBuffer.Wrap(icon);
 			}
 			root[new OrdinalOrName(RT_GROUP_ICON)][new OrdinalOrName(32512)][new OrdinalOrName(0)].Data = group;
 		}
 
 		internal void ExtractResources(byte[] buf)
 		{
 			ByteReader br = new ByteReader(buf, 0, buf.Length);
 			while (br.Length >= 32)
 			{
 				br.Align(4);
 				RESOURCEHEADER hdr = new RESOURCEHEADER(br);
 				if (hdr.DataSize != 0)
 				{
 					root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
 				}
 			}
 		}
 
 		internal void Finish()
 		{
 			if (bb != null)
 			{
 				throw new InvalidOperationException();
 			}
 			bb = new ByteBuffer(1024);
 			linkOffsets = new List<int>();
 			root.Write(bb, linkOffsets);
 			root = null;
 		}
 
 		internal int Length
 		{
 			get { return bb.Length; }
 		}
 
 		internal void Write(MetadataWriter mw, uint rva)
 		{
 			foreach (int offset in linkOffsets)
 			{
 				bb.Position = offset;
 				bb.Write(bb.GetInt32AtCurrentPosition() + (int)rva);
 			}
 			mw.Write(bb);
 		}
 	}
 
 	sealed class ResourceDirectoryEntry
 	{
 		internal readonly OrdinalOrName OrdinalOrName;
 		internal ByteBuffer Data;
 		private int namedEntries;
 		private readonly List<ResourceDirectoryEntry> entries = new List<ResourceDirectoryEntry>();
 
 		internal ResourceDirectoryEntry(OrdinalOrName id)
 		{
 			this.OrdinalOrName = id;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="329" endline="340">
<![CDATA[
 	}
 
 	//
 	// Represents null literal lifted to nullable type
 	//
 	public class LiftedNull 
 	{
 		private LiftedNull (TypeSpec nullable_type, Location loc)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="291" endline="299">
<![CDATA[
 	}
 
 	public class Wrap 
 	{
 		private Wrap (Expression expr, TypeSpec type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1440" endline="1454">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This kind of cast is used to encapsulate Value Types in objects.
 	///
 	///   The effect of it is to box the value type emitted by the previous
 	///   operation.
 	/// </summary>
 	public class BoxedCast 
 
 		public BoxedCast (Expression expr, TypeSpec target_type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="298" endline="316">
<![CDATA[
 	}
 
 	sealed class BlobHeap 
 	{
 		private Key[] map = new Key[8179];
 		private readonly ByteBuffer buf = new ByteBuffer(32);
 
 		private struct Key
 		{
 			internal Key[] next;
 			internal int len;
 			internal int hash;
 			internal int offset;
 		}
 
 		internal BlobHeap()
 		{
 			buf.Write((byte)0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="107" endline="115">
<![CDATA[
 End Class
 
 Public Class ValueOnStackExpression
     Inherits CompilerGeneratedExpression
 
     Sub New(ByVal Parent As ParsedObject, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent, Nothing, ExpressionType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1493" endline="1513">
<![CDATA[
 	}
 
 	// <summary>
 	//   This is a special bit vector which can inherit from another bit vector doing a
 	//   copy-on-write strategy.  The inherited vector may have a smaller size than the
 	//   current one.
 	// </summary>
 	public class MyBitVector {
 		public readonly int Count;
 		public static readonly MyBitVector Empty = new MyBitVector ();
 
 		// Invariant
 		// Invariant
 		//            i.e., at most one of 'vector' and 'shared' can be non-null.  They can both be null -- that means all-ones
 		// The object in 'shared' cannot be modified, while 'vector' can be freely modified
 		System.Collections.BitArray vector, shared;
 
 		MyBitVector ()
 		{
 			shared = new System.Collections.BitArray (0, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="59" endline="75">
<![CDATA[
     End Property
 
     ReadOnly Property SpecialConstraintAttribute() As Mono.Cecil.GenericParameterAttributes
         Get
             Select Case m_Special
                 Case KS.[New]
                     Return Mono.Cecil.GenericParameterAttributes.DefaultConstructorConstraint
                 Case KS.Class
                     Return Mono.Cecil.GenericParameterAttributes.ReferenceTypeConstraint
                 Case KS.Structure
                     Return Mono.Cecil.GenericParameterAttributes.NotNullableValueTypeConstraint
                 Case KS.None
                     Return Mono.Cecil.GenericParameterAttributes.NonVariant
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3658" endline="3668">
<![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Constructor, MemberTypes.Method
                 Return IsAccessible(Context, Caller, DirectCast(Member, Mono.Cecil.MethodReference))
             Case MemberTypes.Property
                 Return IsAccessible(Context, Caller, DirectCast(Member, Mono.Cecil.PropertyReference))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3541" endline="3551">
<![CDATA[
 
     Shared Function GetMethodAttributes(ByVal Member As Mono.Cecil.MemberReference) As Mono.Cecil.MethodAttributes
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).Attributes
             Case MemberTypes.Property
                 Return GetPropertyAttributes(DirectCast(Member, Mono.Cecil.PropertyReference))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="58" endline="72">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As NonArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New NonArrayTypeName(NewParent)
         result.IsNullable = IsNullable
         If Me.IsConstructedTypeName Then
             result.Init(Me.AsConstructedTypeName.Clone)
         ElseIf Me.IsSimpleTypeName Then
             result.Init(Me.AsSimpleTypeName.Clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="51" endline="67">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As QualifiedIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New QualifiedIdentifier(NewParent, Me.Location)
 
         If Me.IsFirstGlobal Then
             result.Init(Me.FirstAsGlobal.Clone(result), m_Second)
         ElseIf Me.IsFirstIdentifier Then
             result.Init(Me.FirstAsIdentifier.Clone(result), m_Second)
         ElseIf Me.IsFirstQualifiedIdentifier Then
             result.Init(Me.FirstAsQualifiedIdentifier.Clone(result), m_Second)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1669" endline="1685">
<![CDATA[
 
 		/// <summary>
 		/// Common method for Obsolete error/warning reporting.
 		/// </summary>
 		public static void Report_ObsoleteMessage (ObsoleteAttribute oa, string member, Location loc, Report Report)
 		{
 			if (oa.IsError) {
 				Report.Error (619, loc, "`{0}' is obsolete
 				return;
 			}
 
 			if (oa.Message == null || oa.Message.Length == 0) {
 				Report.Warning (612, 1, loc, "`{0}' is obsolete", member);
 				return;
 			}
 			Report.Warning (618, 2, loc, "`{0}' is obsolete
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="837" endline="850">
<![CDATA[
 
 		public void AddUsingAlias (string alias, MemberName name, Location loc)
 		{
 			// TODO
 			if (DeclarationFound){
 				Compiler.Report.Error (1529, loc, "A using clause must precede all other namespace elements except extern alias declarations");
 			}
 
 			if (RootContext.Version != LanguageVersion.ISO_1 && alias == "global")
 				Compiler.Report.Warning (440, 2, loc, "An alias named `global' will not be used when resolving 'global
 					" the global namespace will be used instead");
 
 			AddUsingAlias (new LocalUsingAliasEntry (alias, name, loc));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\literal.cs" startline="185" endline="199">
<![CDATA[
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			if (target == TypeManager.float_type) {
 				Error_664 (ec, loc, "float", "f");
 				return;
 			}
 
 			if (target == TypeManager.decimal_type) {
 				Error_664 (ec, loc, "decimal", "m");
 				return;
 			}
 
 			base.Error_ValueCannotBeConverted (ec, loc, target, expl);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1476" endline="1491">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.IndexerName) {
 				if (IsExplicitImpl) {
 					Report.Error (415, a.Location,
 						"The `{0}' attribute is valid only on an indexer that is not an explicit interface member declaration",
 						TypeManager.CSharpName (a.Type));
 				}
 
 				// Attribute was copied to container
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="503" endline="516">
<![CDATA[
 	}
 
 	class IteratorMethod 
 	{
 		readonly IteratorStorey host;
 
 		public IteratorMethod (IteratorStorey host, FullNamedExpression returnType, Modifiers mod, MemberName name)
 			
 			  name, ParametersCompiled.EmptyReadOnlyParameters, null)
 		{
 			this.host = host;
 
 			Block = new ToplevelBlock (host.Compiler, ParametersCompiled.EmptyReadOnlyParameters, Location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="55" endline="72">
<![CDATA[
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1748" endline="1758">
<![CDATA[
 
     Shared Function IsAccessibleExternal(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         If Compiler.Assembly.IsDefinedHere(Member) Then Return True
 
         If IsPublic(Member) Then Return True
         If IsProtectedFriend(Member) Then Return True
         If IsPrivate(Member) Then Return False
         If IsFriend(Member) Then Return False
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2229" endline="2237">
<![CDATA[
 
     Shared Function IsDebugging() As Boolean
         'Return False
         If Diagnostics.Debugger.IsAttached = False Then Return False
         If Reflection.Assembly.GetEntryAssembly Is Nothing Then Return False
         If Reflection.Assembly.GetEntryAssembly.FullName.Contains("rt") Then Return False
         If AppDomain.CurrentDomain.FriendlyName.Contains("rt") Then Return False
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="961" endline="969">
<![CDATA[
 
 		private int WriteTinyHeaderAndCode(ByteBuffer bb)
 		{
 			int rva = bb.Position;
 			const byte CorILMethod_TinyFormat = 0x2;
 			bb.Write((byte)(CorILMethod_TinyFormat | (code.Length << 2)));
 			WriteCode(bb);
 			return rva;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1689" endline="1697">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			LocalTemporary temp_storage = new LocalTemporary(type);
 
 			temp_storage.AddressOf(ec, AddressOp.LoadStore);
 			ec.Emit(OpCodes.Initobj, type);
 			temp_storage.Emit(ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="354" endline="363">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// TODO
 			LocalTemporary value_target = new LocalTemporary (type);
 
 			value_target.AddressOf (ec, AddressOp.Store);
 			ec.Emit (OpCodes.Initobj, type);
 			value_target.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1901" endline="1911">
<![CDATA[
 
     ''' <summary>
     ''' Emits a box instruction, no checks are done.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitBox(ByVal Info As EmitInfo, ByVal SourceType As Mono.Cecil.TypeReference)
         Dim OriginalDestinationType As Mono.Cecil.TypeReference = SourceType
         SourceType = Helper.GetTypeOrTypeBuilder(Info.Compiler, SourceType)
         Info.ILGen.Emit(OpCodes.Box, SourceType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="885" endline="893">
<![CDATA[
 
 
     Shared Sub EmitConstrained(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Dim OriginalType As Mono.Cecil.TypeReference = Type
 
         Type = Helper.GetTypeOrTypeBuilder(Info.Compiler, Type)
 
         Info.ILGen.Emit(OpCodes.Constrained, Type)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="826" endline="835">
<![CDATA[
 
     ''' <summary>
     ''' Loads Me onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadMe(ByVal Info As EmitInfo, ByVal TypeOfMe As Mono.Cecil.TypeReference)
         TypeOfMe = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeOfMe)
         Info.ILGen.Emit(OpCodes.Ldarg_0)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1493" endline="1500">
<![CDATA[
 
 		//
 		// Used by variable declarators
 		//
 		public LocalVariable (LocalVariable li, string name, Location loc)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="340" endline="363">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Fixed buffer implementation
 	/// </summary>
 	public class FixedField 
 	{
 		public const string FixedElementName = "FixedElementField";
 		static int GlobalCounter = 0;
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="531" endline="556">
<![CDATA[
 		}
 	}
 
 	//
 	// The Field class is used to represents class/struct fields during parsing.
 	//
 	public class Field 
 		// <summary>
 		//   Modifiers allowed in a class declaration
 		// </summary>
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.STATIC |
 			Modifiers.VOLATILE |
 			Modifiers.UNSAFE |
 			Modifiers.READONLY;
 
 		public Field (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name,
 			      Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="630" endline="637">
<![CDATA[
 
 		//
 		// Creates method owned type parameter
 		//
 		public TypeParameterSpec (int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6053" endline="6060">
<![CDATA[
 
 		//
 		// For expressions like int[] foo = { 1, 2, 3 };
 		//
 		public ArrayCreation (FullNamedExpression requested_base_type, ArrayInitializer initializers)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="117" endline="147">
<![CDATA[
 		}
 	}
 
 	public class ImplicitLambdaParameter 
 	{
 		public ImplicitLambdaParameter (string name, Location loc)
 			
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
 
 		public void SetParameterType (TypeSpec type)
 		{
 			parameter_type = type;
 		}
 	}
 
 	public class ParamsParameter 
 		public ParamsParameter (FullNamedExpression type, string name, Attributes attrs, Location loc)
 			base (type, name, Parameter.Modifier.PARAMS, attrs, loc)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="83" endline="89">
<![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
         AddAttribute()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1130" endline="1150">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = moduleBuilder.ResolvePseudoToken(records[i].Parent);
 				// do the HasFieldMarshal encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = moduleBuilder.ResolvePseudoToken(records[i].Parent);
 				// do the HasFieldMarshal encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="799" endline="811">
<![CDATA[
 		}
 
 		public NamespaceEntry ImplicitParent {
 			get {
 				if (parent == null)
 					return null;
 				if (implicit_parent == null) {
 					implicit_parent = (parent.NS == ns.Parent)
 						? parent
 						
 				}
 				return implicit_parent;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1206" endline="1229">
<![CDATA[
 
 		/// <summary>
 		///   Converts implicitly the resolved expression `expr' into the
 		///   `target_type'.  It returns a new expression that can be used
 		///   in a context that expects a `target_type'.
 		/// </summary>
 		static public Expression ImplicitConversion (ResolveContext ec, Expression expr,
 							     TypeSpec target_type, Location loc)
 		{
 			Expression e;
 
 			if (target_type == null)
 				throw new Exception ("Target type is null");
 
 			e = ImplicitConversionStandard (ec, expr, target_type, loc);
 			if (e != null)
 				return e;
 
 			e = ImplicitUserConversion (ec, expr, target_type, loc);
 			if (e != null)
 				return e;
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="119" endline="508">
<![CDATA[
 		int id;
 
 		// <summary>
 		//   The vector contains a BitArray with information about which local variables
 		//   and parameters are already initialized at the current code position.
 		// </summary>
 		public class UsageVector {
 			// <summary>
 			//   The type of this branching.
 			// </summary>
 			public readonly SiblingType Type;
 
 			// <summary>
 			//   Start location of this branching.
 			// </summary>
 			public Location Location;
 
 			// <summary>
 			//   This is only valid for SwitchSection, Try, Catch and Finally.
 			// </summary>
 			public readonly Block Block;
 
 			// <summary>
 			//   The number of locals in this block.
 			// </summary>
 			public readonly int CountLocals;
 
 			// <summary>
 			//   If not null, then we inherit our state from this vector and do a
 			//   copy-on-write.  If null, then we're the first sibling in a top-level
 			//   block and inherit from the empty vector.
 			// </summary>
 			public readonly UsageVector InheritsFrom;
 
 			// <summary>
 			//   This is used to construct a list of UsageVector's.
 			// </summary>
 			public UsageVector Next;
 
 			//
 			// Private.
 			//
 			MyBitVector locals;
 			bool is_unreachable;
 
 			static int next_id = 0;
 			int id;
 
 			//
 			// Normally, you should not use any of these constructors.
 			//
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc, int num_locals)
 			{
 				this.Type = type;
 				this.Block = block;
 				this.Location = loc;
 				this.InheritsFrom = parent;
 				this.CountLocals = num_locals;
 
 				locals = num_locals == 0 
 					? MyBitVector.Empty
 					
 
 				if (parent != null)
 					is_unreachable = parent.is_unreachable;
 
 				id = ++next_id;
 
 			}
 
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc)
 				
 			{ }
 
 			private UsageVector (MyBitVector locals, bool is_unreachable, Block block, Location loc)
 			{
 				this.Type = SiblingType.Block;
 				this.Location = loc;
 				this.Block = block;
 
 				this.is_unreachable = is_unreachable;
 
 				this.locals = locals;
 
 				id = ++next_id;
 
 			}
 
 			// <summary>
 			//   This does a deep copy of the usage vector.
 			// </summary>
 			public UsageVector Clone ()
 			{
 				UsageVector retval = new UsageVector (Type, null, Block, Location, CountLocals);
 
 				retval.locals = locals.Clone ();
 				retval.is_unreachable = is_unreachable;
 
 				return retval;
 			}
 
 			public bool IsAssigned (VariableInfo var, bool ignoreReachability)
 			{
 				if (!ignoreReachability && !var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsAssigned (locals);
 			}
 
 			public void SetAssigned (VariableInfo var)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetAssigned (locals);
 			}
 
 			public bool IsFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsFieldAssigned (locals, name);
 			}
 
 			public void SetFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetFieldAssigned (locals, name);
 			}
 
 			public bool IsUnreachable {
 				get { return is_unreachable; }
 			}
 
 			public void ResetBarrier ()
 			{
 				is_unreachable = false;
 			}
 
 			public void Goto ()
 			{
 				is_unreachable = true;
 			}
 
 			public static UsageVector MergeSiblings (UsageVector sibling_list, Location loc)
 			{
 				if (sibling_list.Next == null)
 					return sibling_list;
 
 				MyBitVector locals = null;
 				bool is_unreachable = sibling_list.is_unreachable;
 
 				if (!sibling_list.IsUnreachable)
 					locals &= sibling_list.locals;
 
 				for (UsageVector child = sibling_list.Next; child != null; child = child.Next) {
 					is_unreachable &= child.is_unreachable;
 
 					if (!child.IsUnreachable)
 						locals &= child.locals;
 				}
 
 				return new UsageVector (locals, is_unreachable, null, loc);
 			}
 
 			// <summary>
 			//   Merges a child branching.
 			// </summary>
 			public UsageVector MergeChild (UsageVector child, bool overwrite)
 			{
 				Report.Debug (2, "    MERGING CHILD EFFECTS", this, child, Type);
 
 				bool new_isunr = child.is_unreachable;
 
 				//
 				// We've now either reached the point after the branching or we will
 				// never get there since we always return or always throw an exception.
 				//
 				// If we can reach the point after the branching, mark all locals and
 				// parameters as initialized which have been initialized in all branches
 				// we need to look at (see above).
 				//
 
 				if ((Type == SiblingType.SwitchSection) && !new_isunr) {
 					Report.Error (163, Location,
 						      "Control cannot fall through from one " +
 						      "case label to another");
 					return child;
 				}
 
 				locals |= child.locals;
 
 				// throw away un-necessary information about variables in child blocks
 				if (locals.Count != CountLocals)
 					locals = new MyBitVector (locals, CountLocals);
 
 				if (overwrite)
 					is_unreachable = new_isunr;
 				else
 					is_unreachable |= new_isunr;
 
 				return child;
 			}
 
 			public void MergeOrigins (UsageVector o_vectors)
 			{
 				Report.Debug (1, "  MERGING BREAK ORIGINS", this);
 
 				if (o_vectors == null)
 					return;
 
 				if (IsUnreachable && locals != null)
 					locals.SetAll (true);
 
 				for (UsageVector vector = o_vectors; vector != null; vector = vector.Next) {
 					Report.Debug (1, "    MERGING BREAK ORIGIN", vector);
 					if (vector.IsUnreachable)
 						continue;
 					locals &= vector.locals;
 					is_unreachable &= vector.is_unreachable;
 				}
 
 				Report.Debug (1, "  MERGING BREAK ORIGINS DONE", this);
 			}
 
 			//
 			// Debugging stuff.
 			//
 
 			public override string ToString ()
 			{
 				return String.Format ("Vector ({0},{1},{2}-{3})", Type, id, is_unreachable, locals);
 			}
 		}
 
 		// <summary>
 		//   Creates a new flow branching which is contained in `parent'.
 		//   You should only pass non-null for the `block' argument if this block
 		//   introduces any new variables - in this case, we need to create a new
 		//   usage vector with a different size than our parent's one.
 		// </summary>
 		protected FlowBranching (FlowBranching parent, BranchingType type, SiblingType stype,
 					 Block block, Location loc)
 		{
 			Parent = parent;
 			Block = block;
 			Location = loc;
 			Type = type;
 			id = ++next_id;
 
 			UsageVector vector;
 			if (Block != null) {
 				UsageVector parent_vector = parent != null ? parent.CurrentUsageVector 
 				vector = new UsageVector (stype, parent_vector, Block, loc, Block.AssignableSlots);
 			} else {
 				vector = new UsageVector (stype, Parent.CurrentUsageVector, null, loc);
 			}
 
 			AddSibling (vector);
 		}
 
 		public abstract UsageVector CurrentUsageVector {
 			get;
 		}				
 
 		// <summary>
 		//   Creates a sibling of the current usage vector.
 		// </summary>
 		public virtual void CreateSibling (Block block, SiblingType type)
 		{
 			UsageVector vector = new UsageVector (
 				type, Parent.CurrentUsageVector, block, Location);
 			AddSibling (vector);
 
 			Report.Debug (1, "  CREATED SIBLING", CurrentUsageVector);
 		}
 
 		public void CreateSibling ()
 		{
 			CreateSibling (null, SiblingType.Conditional);
 		}
 
 		protected abstract void AddSibling (UsageVector uv);
 
 		protected abstract UsageVector Merge ();
 
 		public UsageVector MergeChild (FlowBranching child)
 		{
 			return CurrentUsageVector.MergeChild (child.Merge (), true);
  		}
 
 		public virtual bool CheckRethrow (Location loc)
 		{
 			return Parent.CheckRethrow (loc);
 		}
 
 		public virtual bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			return Parent.AddResumePoint (stmt, loc, out pc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			return Parent.AddBreakOrigin (vector, loc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			return Parent.AddContinueOrigin (vector, loc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddReturnOrigin (UsageVector vector, ExitStatement stmt)
 		{
 			return Parent.AddReturnOrigin (vector, stmt);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			return Parent.AddGotoOrigin (vector, goto_stmt);
 		}
 
 		public bool IsAssigned (VariableInfo vi)
 		{
 			return CurrentUsageVector.IsAssigned (vi, false);
 		}
 
 		public bool IsFieldAssigned (VariableInfo vi, string field_name)
 		{
 			return CurrentUsageVector.IsAssigned (vi, false) || CurrentUsageVector.IsFieldAssigned (vi, field_name);
 		}
 
 		protected static Report Report {
 			get { return RootContext.ToplevelTypes.Compiler.Report; }
 		}
 
 		public void SetAssigned (VariableInfo vi)
 		{
 			CurrentUsageVector.SetAssigned (vi);
 		}
 
 		public void SetFieldAssigned (VariableInfo vi, string name)
 		{
 			CurrentUsageVector.SetFieldAssigned (vi, name);
 		}
 
 #if DEBUG
 		public override string ToString ()
 		{
 			StringBuilder sb = new StringBuilder ();
 			sb.Append (GetType ());
 			sb.Append (" (");
 
 			sb.Append (id);
 			sb.Append (",");
 			sb.Append (Type);
 			if (Block != null) {
 				sb.Append (" - ");
 				sb.Append (Block.ID);
 				sb.Append (" - ");
 				sb.Append (Block.StartLocation);
 			}
 			sb.Append (" - ");
 			// sb.Append (Siblings.Length);
 			// sb.Append (" - ");
 			sb.Append (CurrentUsageVector);
 			sb.Append (")");
 			return sb.ToString ();
 		}
 #endif
 
 		public string Name {
 			get { return String.Format ("{0} ({1}
 		}
 	}
 
 	public class FlowBranchingBlock 
 	{
 		UsageVector sibling_list = null;
 
 		public FlowBranchingBlock (FlowBranching parent, BranchingType type,
 					   SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="242" endline="414">
<![CDATA[
 
 			internal const string Prefix = "set_";
 
 			protected ParametersCompiled parameters;
 
 			public SetMethod (PropertyBase method, Modifiers modifiers, ParametersCompiled parameters, Attributes attrs, Location loc)
 				
 			{
 				this.parameters = parameters;
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override ParametersCompiled ParameterInfo {
 			    get {
 			        return parameters;
 			    }
 			}
 
 			public override MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 				
 				base.Define (parent);
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, null, ParameterInfo, ModFlags);
 
 				method_data = new MethodData (method, ModFlags, flags, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				Spec.SetMetaInfo (method_data.MethodBuilder);
 
 				return method_data.MethodBuilder;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 		}
 
 		static string[] attribute_targets = new string [] { "property" };
 
 		public abstract class PropertyMethod 
 		{
 			public const Modifiers AllowedModifiers =
 				Modifiers.PUBLIC |
 				Modifiers.PROTECTED |
 				Modifiers.INTERNAL |
 				Modifiers.PRIVATE;
 		
 			protected readonly PropertyBase method;
 			protected MethodAttributes flags;
 
 			public PropertyMethod (PropertyBase method, string prefix, Modifiers modifiers, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = modifiers | (method.ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE));
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				TypeContainer container = parent.PartialContainer;
 
 				//
 				// Check for custom access modifier
 				//
 				if ((ModFlags & Modifiers.AccessibilityMask) == 0) {
 					ModFlags |= method.ModFlags;
 					flags = method.flags;
 				} else {
 					if (container.Kind == MemberKind.Interface)
 						Report.Error (275, Location, "`{0}'
 							GetSignatureForError ());
 
 					if ((method.ModFlags & Modifiers.ABSTRACT) != 0 && (ModFlags & Modifiers.PRIVATE) != 0) {
 						Report.Error (442, Location, "`{0}'
 					}
 
 					CheckModifiers (ModFlags);
 					ModFlags |= (method.ModFlags & (~Modifiers.AccessibilityMask));
 					ModFlags |= Modifiers.PROPERTY_CUSTOM;
 					flags = ModifiersExtensions.MethodAttr (ModFlags);
 					flags |= (method.flags & (~MethodAttributes.MemberAccessMask));
 				}
 
 				CheckAbstractAndExtern (block != null);
 				CheckProtectedModifier ();
 
 				if (block != null && block.IsIterator)
 					Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 
 				return null;
 			}
 
 			public bool HasCustomAccessModifier {
 				get {
 					return (ModFlags & Modifiers.PROPERTY_CUSTOM) != 0;
 				}
 			}
 
 			public PropertyBase Property {
 				get {
 					return method;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string GetSignatureForError()
 			{
 				return method.GetSignatureForError () + "." + prefix.Substring (0, 3);
 			}
 
 			void CheckModifiers (Modifiers modflags)
 			{
 				if (!ModifiersExtensions.IsRestrictedModifier (modflags & Modifiers.AccessibilityMask, method.ModFlags & Modifiers.AccessibilityMask)) {
 					Report.Error (273, Location,
 						"The accessibility modifier of the `{0}' accessor must be more restrictive than the modifier of the property or indexer `{1}'",
 						GetSignatureForError (), method.GetSignatureForError ());
 				}
 			}
 		}
 
 		PropertyMethod get, set, first;
 		PropertyBuilder PropertyBuilder;
 
 		public PropertyBase (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags,
 				     Modifiers allowed_mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="651" endline="660">
<![CDATA[
 	}
 
 	public class FlowBranchingToplevel 
 	{
 		UsageVector return_origins;
 
 		public FlowBranchingToplevel (FlowBranching parent, ParametersBlock stmt)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="706" endline="716">
<![CDATA[
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1187" endline="1194">
<![CDATA[
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			return IsDecrement ? "Decrement" 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="49" endline="90">
<![CDATA[
 
 		internal void Read(BinaryReader br)
 		{
 			Signature = br.ReadUInt32();
 			if (Signature != IMAGE_NT_HEADERS.MAGIC_SIGNATURE)
 			{
 				throw new BadImageFormatException();
 			}
 			FileHeader.Read(br);
 			OptionalHeader.Read(br);
 		}
 	}
 
 	sealed class IMAGE_FILE_HEADER
 	{
 		public const WORD IMAGE_FILE_MACHINE_I386 = 0x014c;
 		public const WORD IMAGE_FILE_MACHINE_IA64 = 0x0200;
 		public const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;
 
 		public const WORD IMAGE_FILE_32BIT_MACHINE = 0x0100;
 		public const WORD IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
 		public const WORD IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020;
 		public const WORD IMAGE_FILE_DLL = 0x2000;
 
 		public WORD Machine;
 		public WORD NumberOfSections;
 		public DWORD TimeDateStamp;
 		public DWORD PointerToSymbolTable;
 		public DWORD NumberOfSymbols;
 		public WORD SizeOfOptionalHeader;
 		public WORD Characteristics;
 
 		internal void Read(BinaryReader br)
 		{
 			Machine = br.ReadUInt16();
 			NumberOfSections = br.ReadUInt16();
 			TimeDateStamp = br.ReadUInt32();
 			PointerToSymbolTable = br.ReadUInt32();
 			NumberOfSymbols = br.ReadUInt32();
 			SizeOfOptionalHeader = br.ReadUInt16();
 			Characteristics = br.ReadUInt16();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="40" endline="46">
<![CDATA[
 		internal TypeDefImpl(ModuleReader module, int index)
 		{
 			this.module = module;
 			this.index = index;
 			this.typeName = TypeNameParser.Escape(module.GetString(module.TypeDef.records[index].TypeName));
 			this.typeNamespace = TypeNameParser.Escape(module.GetString(module.TypeDef.records[index].TypeNamespace));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1322" endline="1335">
<![CDATA[
 
 		protected VariableInfo (VariableInfo parent, TypeInfo type)
 		{
 			this.Name = parent.Name;
 			this.TypeInfo = type;
 			this.Offset = parent.Offset + type.Offset;
 			this.Parent = parent;
 			this.Length = type.TotalLength;
 
 			this.IsParameter = parent.IsParameter;
 			this.LocalInfo = parent.LocalInfo;
 
 			Initialize ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2409" endline="2422">
<![CDATA[
 
 		protected ParametersBlock (ParametersBlock source, ParametersCompiled parameters)
 			
 		{
 			this.parameters = parameters;
 			this.statements = source.statements;
 			this.scope_initializers = source.scope_initializers;
 
 			this.resolved = true;
 			this.unreachable = source.unreachable;
 			this.am_storey = source.am_storey;
 
 			ParametersBlock = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="56" endline="66">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="339" endline="347">
<![CDATA[
 
 		public void SetNestedStoryParent (AnonymousMethodStorey parentStorey)
 		{
 			Parent = parentStorey;
 			type_params = null;
 			spec.IsGeneric = false;
 			spec.DeclaringType = parentStorey.CurrentType;
 			MemberName.TypeArguments = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="45" endline="51">
<![CDATA[
 
     Sub New(ByVal Parent As TypeDeclaration, ByVal Name As String, ByVal MethodAttributes As Mono.Cecil.MethodAttributes, ByVal ParameterTypes As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), New SubSignature(Me, Name, ParameterTypes))
         MyBase.MethodAttributes = MethodAttributes
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="67" endline="78">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), Identifier.Name)
 
         m_VariableIdentifier = New VariableIdentifier(Me, Identifier)
         m_IsNew = IsNew
         m_TypeName = New TypeName(Me, TypeName)
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="37" endline="45">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal Identifier As Identifier, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal ParameterList As ParameterList)
         MyBase.Init(Modifiers, New SubSignature(Me, Identifier.Name, ParameterList), Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1666" endline="1678">
<![CDATA[
 		}
 
 		static int types_counter;
 		public const string ClassNamePrefix = "<>__AnonType";
 		public const string SignatureForError = "anonymous type";
 		
 		readonly IList<AnonymousTypeParameter> parameters;
 
 		private AnonymousTypeClass (DeclSpace parent, MemberName name, IList<AnonymousTypeParameter> parameters, Location loc)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="58" endline="64">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As Mono.Cecil.TypeReference)
         MyBase.Init(Modifiers, Name, VariableType)
         UpdateDefinition()
 
         Helper.Assert(FieldType IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="147" endline="153">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As AddressOfExpression, ByVal MethodGroup As MethodGroupClassification)
         MyBase.new(Classifications.MethodPointer, Parent)
         Helper.Assert(MethodGroup IsNot Nothing)
         m_MethodGroup = MethodGroup
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="136" endline="566">
<![CDATA[
 
 		public ModuleContainer (CompilerContext context)
 			
 		{
 			this.context = context;
 
 			caching_flags &= ~(Flags.Obsolete_Undetected | Flags.Excluded_Undetected);
 
 			types = new List<TypeContainer> ();
 			anonymous_types = new Dictionary<int, List<AnonymousTypeClass>> ();
 			global_ns = new GlobalRootNamespace ();
 			alias_ns = new Dictionary<string, RootNamespace> ();
 		}
 
 		#region Properties
 
  		public override AttributeTargets AttributeTargets {
  			get {
  				return AttributeTargets.Assembly;
  			}
 		}
 
 		public ModuleBuilder Builder {
 			get {
 				return builder;
 			}
 		}
 
 		public override CompilerContext Compiler {
 			get {
 				return context;
 			}
 		}
 
 		public override AssemblyDefinition DeclaringAssembly {
 			get {
 				return assembly;
 			}
 		}
 
 		public bool HasDefaultCharSet {
 			get {
 				return has_default_charset;
 			}
 		}
 
 		public bool HasExtensionMethod {
 			get {
 				return has_extenstion_method;
 			}
 			set {
 				has_extenstion_method = value;
 			}
 		}
 
 		//
 		// Returns module global
 		//
 		public RootNamespace GlobalRootNamespace {
 		    get {
 		        return global_ns;
 		    }
 		}
 
 		public override ModuleContainer Module {
 			get {
 				return this;
 			}
 		}
 
 		internal PredefinedAttributes PredefinedAttributes {
 			get {
 				return predefined_attributes;
 			}
 		}
 
 		internal PredefinedTypes PredefinedTypes {
 			get {
 				return predefined_types;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public void AddAnonymousType (AnonymousTypeClass type)
 		{
 			List<AnonymousTypeClass> existing;
 			if (!anonymous_types.TryGetValue (type.Parameters.Count, out existing))
 			if (existing == null) {
 				existing = new List<AnonymousTypeClass> ();
 				anonymous_types.Add (type.Parameters.Count, existing);
 			}
 
 			existing.Add (type);
 		}
 
 		public void AddAttributes (List<Attribute> attrs)
 		{
 			AddAttributes (attrs, this);
 		}
 
 		public void AddAttributes (List<Attribute> attrs, IMemberContext context)
 		{
 			foreach (Attribute a in attrs)
 				a.AttachTo (this, context);
 
 			if (attributes == null) {
 				attributes = new Attributes (attrs);
 				return;
 			}
 			attributes.AddAttributes (attrs);
 		}
 
 		public override TypeContainer AddPartial (TypeContainer nextPart)
 		{
 			return AddPartial (nextPart, nextPart.Name);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Assembly) {
 				assembly.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				Attribute cls = DeclaringAssembly.CLSCompliantAttribute;
 				if (cls == null) {
 					Report.Warning (3012, 1, a.Location,
 						"You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking");
 				} else if (DeclaringAssembly.IsCLSCompliant != a.GetBoolean ()) {
 					Report.SymbolRelatedToPreviousError (cls.Location, cls.GetSignatureForError ());
 					Report.Warning (3017, 1, a.Location,
 						"You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly");
 					return;
 				}
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override void CloseType ()
 		{
 			HackCorlibEnums ();
 
 			foreach (TypeContainer tc in types) {
 				tc.CloseType ();
 			}
 
 			if (compiler_generated != null)
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 		}
 
 		public TypeBuilder CreateBuilder (string name, TypeAttributes attr, int typeSize)
 		{
 			return builder.DefineType (name, attr, null, typeSize);
 		}
 
 		//
 		// Creates alias global namespace
 		//
 		public RootNamespace CreateRootNamespace (string alias)
 		{
 			if (alias == global_ns.Alias) {
 				NamespaceEntry.Error_GlobalNamespaceRedefined (Location.Null, Report);
 				return global_ns;
 			}
 
 			RootNamespace rn;
 			if (!alias_ns.TryGetValue (alias, out rn)) {
 				rn = new RootNamespace (alias);
 				alias_ns.Add (alias, rn);
 			}
 
 			return rn;
 		}
 
 		public new void Define ()
 		{
 			builder = assembly.CreateModuleBuilder ();
 
 			// FIXME
 			static_data = null;
 
 			// TODO
 			// but that require DefineType clean-up
 			ResolveGlobalAttributes ();
 
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 
 			InitializePredefinedTypes ();
 
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 		}
 
 		public override void Emit ()
 		{
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (RootContext.Unsafe) {
 				var pa = PredefinedAttributes.UnverifiableCode;
 				if (pa.IsDefined)
 					pa.EmitAttribute (builder);
 			}
 
 			foreach (var tc in types)
 				tc.DefineConstants ();
 
 			HackCorlib ();
 
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 
 			if (Compiler.Report.Errors > 0)
 				return;
 
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 
 			if (compiler_generated != null)
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 		}
 
 		public AnonymousTypeClass GetAnonymousType (IList<AnonymousTypeParameter> parameters)
 		{
 			List<AnonymousTypeClass> candidates;
 			if (!anonymous_types.TryGetValue (parameters.Count, out candidates))
 				return null;
 
 			int i;
 			foreach (AnonymousTypeClass at in candidates) {
 				for (i = 0; i < parameters.Count; ++i) {
 					if (!parameters [i].Equals (at.Parameters [i]))
 						break;
 				}
 
 				if (i == parameters.Count)
 					return at;
 			}
 
 			return null;
 		}
 
 		public RootNamespace GetRootNamespace (string name)
 		{
 			RootNamespace rn;
 			alias_ns.TryGetValue (name, out rn);
 			return rn;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return "<module>";
 		}
 
 		void HackCorlib ()
 		{
 #if !STATIC
 			if (RootContext.StdLib)
 				return;
 
 			//
 			// HACK
 			// has different predefined types and this method sets mscorlib types
 			// to be same to avoid type check errors in CreateType.
 			//
 			var type = typeof (Type);
 			var system_4_type_arg = new[] { type, type, type, type };
 
 			MethodInfo set_corlib_type_builders =
 				typeof (System.Reflection.Emit.AssemblyBuilder).GetMethod (
 				"SetCorlibTypeBuilders", BindingFlags.NonPublic | BindingFlags.Instance, null,
 				system_4_type_arg, null);
 
 			if (set_corlib_type_builders == null) {
 				Compiler.Report.Warning (-26, 3,
 					"The compilation may fail due to missing `System.Reflection.Emit.AssemblyBuilder.SetCorlibTypeBuilders(...)' method");
 				return;
 			}
 
 			object[] args = new object[4];
 			args[0] = TypeManager.object_type.GetMetaInfo ();
 			args[1] = TypeManager.value_type.GetMetaInfo ();
 			args[2] = TypeManager.enum_type.GetMetaInfo ();
 			args[3] = TypeManager.void_type.GetMetaInfo ();
 			set_corlib_type_builders.Invoke (assembly.Builder, args);
 #endif
 		}
 
 		void HackCorlibEnums ()
 		{
 			if (RootContext.StdLib)
 				return;
 
 			// Another Mono corlib HACK
 			// mono_class_layout_fields requires to have enums created
 			// before creating a class which used the enum for any of its fields
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 		}
 
 		public void InitializePredefinedTypes ()
 		{
 			predefined_attributes = new PredefinedAttributes (this);
 			predefined_types = new PredefinedTypes (this);
 		}
 
 		public override bool IsClsComplianceRequired ()
 		{
 			return DeclaringAssembly.IsCLSCompliant;
 		}
 
 		//
 		// Makes const data field inside internal type container
 		//
 		public FieldSpec MakeStaticData (byte[] data, Location loc)
 		{
 			if (static_data == null) {
 				static_data = new StaticDataContainer (this);
 				static_data.CreateType ();
 				static_data.DefineType ();
 
 				AddCompilerGeneratedClass (static_data);
 			}
 
 			return static_data.DefineInitializedData (data, loc);
 		}
 
 		protected override bool AddMemberType (TypeContainer ds)
 		{
 			if (!AddToContainer (ds, ds.Name))
 				return false;
 			ds.NamespaceEntry.NS.AddType (ds.Definition);
 			return true;
 		}
 
 		protected override void RemoveMemberType (DeclSpace ds)
 		{
 			ds.NamespaceEntry.NS.RemoveDeclSpace (ds.Basename);
 			base.RemoveMemberType (ds);
 		}
 
 		/// <summary>
 		/// It is called very early therefore can resolve only predefined attributes
 		/// </summary>
 		void ResolveGlobalAttributes ()
 		{
 			if (OptAttributes == null)
 				return;
 
 			if (!OptAttributes.CheckTargets ())
 				return;
 
 			// FIXME
 			var DefaultCharSet_attr = new PredefinedAttribute (this, "System.Runtime.InteropServices", "DefaultCharSetAttribute");
 			DefaultCharSet_attr.Define ();
 			Attribute a = ResolveModuleAttribute (DefaultCharSet_attr);
 			if (a != null) {
 				has_default_charset = true;
 				DefaultCharSet = a.GetCharSetValue ();
 				switch (DefaultCharSet) {
 				case CharSet.Ansi
 				case CharSet.None
 					break;
 				case CharSet.Auto
 					DefaultCharSetType = TypeAttributes.AutoClass;
 					break;
 				case CharSet.Unicode
 					DefaultCharSetType = TypeAttributes.UnicodeClass;
 					break;
 				default
 					Report.Error (1724, a.Location, "Value specified for the argument to `{0}' is not valid", 
 						DefaultCharSet_attr.GetSignatureForError ());
 					break;
 				}
 			}
 		}
 
 		public Attribute ResolveAssemblyAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("assembly", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
 
 		Attribute ResolveModuleAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("module", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
 
 		public void SetDeclaringAssembly (AssemblyDefinition assembly)
 		{
 			// TODO
 			this.assembly = assembly;
 		}
 	}
 
 	class RootDeclSpace 
 		public RootDeclSpace (NamespaceEntry ns)
 			
 		{
 			PartialContainer = RootContext.ToplevelTypes;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="1057" endline="1063">
<![CDATA[
 	}
 
 	public class InternalErrorException 
 		public InternalErrorException (MemberCore mc, Exception e)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="162" endline="173">
<![CDATA[
 	}
 
 	sealed class StringHeap 
 	{
 		private List<string> list = new List<string>();
 		private Dictionary<string, int> strings = new Dictionary<string, int>();
 		private int nextOffset;
 
 		internal StringHeap()
 		{
 			Add("");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="202" endline="213">
<![CDATA[
 	}
 
 	sealed class UserStringHeap 
 	{
 		private List<string> list = new List<string>();
 		private Dictionary<string, int> strings = new Dictionary<string, int>();
 		private int nextOffset;
 
 		internal UserStringHeap()
 		{
 			nextOffset = 1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1404" endline="1445">
<![CDATA[
 
 		private ReferenceContainer (TypeSpec element)
 			
 		{
 		}
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakeByRefType ();
 			}
 
 			return info;
 		}
 
 		public static ReferenceContainer MakeType (TypeSpec element)
 		{
 			ReferenceContainer pc;
 			if (!instances.TryGetValue (element, out pc)) {
 				pc = new ReferenceContainer (element);
 				instances.Add (element, pc);
 			}
 
 			return pc;
 		}
 
 		public static void Reset ()
 		{
 			instances = new Dictionary<TypeSpec, ReferenceContainer> ();
 		}
 	}
 
 	class PointerContainer 
 	{
 		static Dictionary<TypeSpec, PointerContainer> instances = new Dictionary<TypeSpec, PointerContainer> ();
 
 		private PointerContainer (TypeSpec element)
 			
 		{
 			// It's never CLS-Compliant
 			state &= ~StateFlags.CLSCompliant_Undetected;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="730" endline="736">
<![CDATA[
 		}
 
 		public QueryBlock (CompilerContext ctx, Block parent, Location start)
 			
 		{
 			flags |= Flags.CompilerGenerated;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3122" endline="3138">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As ModifierMasks) As String
         Select Case Accessibility
             Case ModifierMasks.Protected Or ModifierMasks.Friend
                 Return "Protected Friend"
             Case ModifierMasks.Protected
                 Return "Protected"
             Case ModifierMasks.Friend
                 Return "Friend"
             Case ModifierMasks.Public
                 Return "Public"
             Case ModifierMasks.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="89" endline="102">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant) {
 				method.Compiler.Report.Warning (3023, 1, a.Location,
 					"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead");
 			}
 
 			// This occurs after Warning -28
 			if (builder == null)
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="103" endline="121">
<![CDATA[
     End Property
 
     Function GetMethodAttributeScope() As Mono.Cecil.MethodAttributes
         If Me.Is(ModifierMasks.Public) Then
             Return Mono.Cecil.MethodAttributes.Public
         ElseIf Me.Is(ModifierMasks.Friend) Then
             If Me.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.MethodAttributes.FamORAssem
             Else
                 Return Mono.Cecil.MethodAttributes.Assembly
             End If
         ElseIf Me.Is(ModifierMasks.Protected) Then
             Return Mono.Cecil.MethodAttributes.Family
         ElseIf Me.Is(ModifierMasks.Private) Then
             Return Mono.Cecil.MethodAttributes.Private
         Else
             Return Mono.Cecil.MethodAttributes.Public
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2768" endline="2777">
<![CDATA[
 
     Shared Function IsNullableType(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If CecilHelper.IsValueType(Type) = False Then Return False
         If CompareType(Type, Compiler.TypeCache.System_Nullable1) Then Return True
 
         If CecilHelper.IsGenericTypeDefinition(Type) Then Return False
         If CecilHelper.IsGenericParameter(Type) Then Return False
         If CecilHelper.IsGenericType(Type) = False Then Return False
         Return Helper.CompareType(CecilHelper.GetGenericTypeDefinition(Type), Compiler.TypeCache.System_Nullable1)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="837" endline="857">
<![CDATA[
 
 		//
 		// Constraints have to match by definition but not position, used by
 		// partial classes or methods
 		//
 		public bool HasSameConstraintsDefinition (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			if (BaseType != other.BaseType)
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (InterfacesDefined, other.InterfacesDefined))
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (targs, other.targs))
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="345" endline="357">
<![CDATA[
 
     ''' <summary>
     ''' Emit a newobj.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Constructor"></param>
     ''' <remarks></remarks>
     Shared Sub EmitNew(ByVal Info As EmitInfo, ByVal Constructor As Mono.Cecil.MethodReference)
         Dim vOriginalConstructor As Mono.Cecil.MethodReference = Constructor
         Helper.Assert(Constructor IsNot Nothing)
         Constructor = CecilHelper.MakeEmittable(Constructor)
         Info.ILGen.Emit(OpCodes.Newobj, Constructor)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="365" endline="372">
<![CDATA[
 
     Shared Sub EmitIsInst(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         Dim toOriginal As Mono.Cecil.TypeReference = ToType
 
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Info.ILGen.Emit(OpCodes.Isinst, ToType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="612" endline="1112">
<![CDATA[
 
 		Variance variance;
 		SpecialConstraint spec;
 		readonly int tp_pos;
 		TypeSpec[] targs;
 		TypeSpec[] ifaces_defined;
 
 		//
 		// Creates type owned type parameter
 		//
 		public TypeParameterSpec (TypeSpec declaringType, int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 			this.variance = variance;
 			this.spec = spec;
 			state &= ~StateFlags.Obsolete_Undetected;
 			tp_pos = index;
 		}
 
 		//
 		// Creates method owned type parameter
 		//
 		public TypeParameterSpec (int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 		}
 
 		#region Properties
 
 		public int DeclaredPosition {
 			get {
 				return tp_pos;
 			}
 		}
 
 		public bool HasSpecialConstructor {
 			get {
 				return (spec & SpecialConstraint.Constructor) != 0;
 			}
 		}
 
 		public bool HasSpecialClass {
 			get {
 				return (spec & SpecialConstraint.Class) != 0;
 			}
 		}
 
 		public bool HasSpecialStruct {
 			get {
 				return (spec & SpecialConstraint.Struct) != 0;
 			}
 		}
 
 		public bool HasTypeConstraint {
 			get {
 				return BaseType != TypeManager.object_type && BaseType != TypeManager.value_type;
 			}
 		}
 
 		public override IList<TypeSpec> Interfaces {
 			get {
 				if ((state & StateFlags.InterfacesExpanded) == 0) {
 					if (ifaces != null) {
 						for (int i = 0; i < ifaces.Count; ++i ) {
 							var iface_type = ifaces[i];
 							if (iface_type.Interfaces != null) {
 								if (ifaces_defined == null)
 									ifaces_defined = ifaces.ToArray ();
 
 								for (int ii = 0; ii < iface_type.Interfaces.Count; ++ii) {
 									var ii_iface_type = iface_type.Interfaces [ii];
 
 									AddInterface (ii_iface_type);
 								}
 							}
 						}
 					}
 
 					if (ifaces_defined == null && ifaces != null)
 						ifaces_defined = ifaces.ToArray ();
 
 					state |= StateFlags.InterfacesExpanded;
 				}
 
 				return ifaces;
 			}
 		}
 
 		//
 		// Unexpanded interfaces list
 		//
 		public TypeSpec[] InterfacesDefined {
 			get {
 				if (ifaces_defined == null && ifaces != null)
 					ifaces_defined = ifaces.ToArray ();
 
 				return ifaces_defined;
 			}
 			set {
 				ifaces_defined = value;
 			}
 		}
 
 		public bool IsConstrained {
 			get {
 				return spec != SpecialConstraint.None || ifaces != null || targs != null || HasTypeConstraint;
 			}
 		}
 
 		//
 		// Returns whether the type parameter is "known to be a reference type"
 		//
 		public bool IsReferenceType {
 			get {
 				if ((spec & SpecialConstraint.Class) != 0 || HasTypeConstraint)
 					return true;
 
 				if (targs != null) {
 					foreach (var ta in targs) {
 						if (TypeManager.IsReferenceType (ta))
 							return true;
 					}
 				}
 
 				return false;
 			}
 		}
 
 		public bool IsValueType {	// TODO
 			get {
 				// TODO MemberCache
 				return HasSpecialStruct;
 			}
 		}
 
 		public override string Name {
 			get {
 				return definition.Name;
 			}
 		}
 
 		public bool IsMethodOwned {
 			get {
 				return DeclaringType == null;
 			}
 		}
 
 		public SpecialConstraint SpecialConstraint {
 			get {
 				return spec;
 			}
 			set {
 				spec = value;
 			}
 		}
 
 		//
 		// Types used to inflate the generic type
 		//
 		public new TypeSpec[] TypeArguments {
 			get {
 				return targs;
 			}
 			set {
 				targs = value;
 			}
 		}
 
 		public Variance Variance {
 			get {
 				return variance;
 			}
 		}
 
 		#endregion
 
 		public void ChangeTypeArgumentToBaseType (int index)
 		{
 			BaseType = targs [index];
 			if (targs.Length == 1) {
 				targs = null;
 			} else {
 				var copy = new TypeSpec[targs.Length - 1];
 				if (index > 0)
 					Array.Copy (targs, copy, index);
 
 				Array.Copy (targs, index + 1, copy, index, targs.Length - index - 1);
 				targs = copy;
 			}
 		}
 
 		public string DisplayDebugInfo ()
 		{
 			var s = GetSignatureForError ();
 			return IsMethodOwned ? s + "!!" 
 		}
 
 		//
 		// Finds effective base class
 		//
 		public TypeSpec GetEffectiveBase ()
 		{
 			if (HasSpecialStruct) {
 				return TypeManager.value_type;
 			}
 
 			if (BaseType != null && targs == null)
 				return BaseType;
 
 			var types = targs;
 			if (HasTypeConstraint) {
 				Array.Resize (ref types, types.Length + 1);
 				types[types.Length - 1] = BaseType;
 			}
 
 			if (types != null)
 				return Convert.FindMostEncompassedType (types.Select (l => l.BaseType));
 
 			return TypeManager.object_type;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Name;
 		}
 
 		//
 		// Constraints have to match by definition but not position, used by
 		// partial classes or methods
 		//
 		public bool HasSameConstraintsDefinition (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			if (BaseType != other.BaseType)
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (InterfacesDefined, other.InterfacesDefined))
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (targs, other.targs))
 				return false;
 
 			return true;
 		}
 
 		//
 		// Constraints have to match by using same set of types, used by
 		// implicit interface implementation
 		//
 		public bool HasSameConstraintsImplementation (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			//
 			// It can be same base type or inflated type parameter
 			//
 			// interface I<T> { void Foo<U> where U 
 			// class A 
 			//
 			bool found;
 			if (!TypeSpecComparer.Override.IsEqual (BaseType, other.BaseType)) {
 				if (other.targs == null)
 					return false;
 
 				found = false;
 				foreach (var otarg in other.targs) {
 					if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 						found = true;
 						break;
 					}
 				}
 
 				if (!found)
 					return false;
 			}
 
 			// Check interfaces implementation -> definition
 			if (InterfacesDefined != null) {
 				foreach (var iface in InterfacesDefined) {
 					found = false;
 					if (other.InterfacesDefined != null) {
 						foreach (var oiface in other.InterfacesDefined) {
 							if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (found)
 						continue;
 
 					if (other.targs != null) {
 						foreach (var otarg in other.targs) {
 							if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check interfaces implementation <- definition
 			if (other.InterfacesDefined != null) {
 				if (InterfacesDefined == null)
 					return false;
 
 				foreach (var oiface in other.InterfacesDefined) {
 					found = false;
 					foreach (var iface in InterfacesDefined) {
 						if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation -> definition
 			if (targs != null) {
 				if (other.targs == null)
 					return false;
 
 				foreach (var targ in targs) {
 					found = false;
 					foreach (var otarg in other.targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation <- definition
 			if (other.targs != null) {
 				foreach (var otarg in other.targs) {
 					// Ignore inflated type arguments, were checked above
 					if (!otarg.IsGenericParameter)
 						continue;
 
 					if (targs == null)
 						return false;
 
 					found = false;
 					foreach (var targ in targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}				
 			}
 
 			return true;
 		}
 
 		public static TypeParameterSpec[] InflateConstraints (TypeParameterInflator inflator, TypeParameterSpec[] tparams)
 		{
 			return InflateConstraints (tparams, l => l, inflator);
 		}
 
 		public static TypeParameterSpec[] InflateConstraints<T> (TypeParameterSpec[] tparams, Func<T, TypeParameterInflator> inflatorFactory, T arg)
 		{
 			TypeParameterSpec[] constraints = null;
 			TypeParameterInflator? inflator = null;
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 				if (tp.HasTypeConstraint || tp.Interfaces != null || tp.TypeArguments != null) {
 					if (constraints == null) {
 						constraints = new TypeParameterSpec[tparams.Length];
 						Array.Copy (tparams, constraints, constraints.Length);
 					}
 
 					//
 					// Using a factory to avoid possibly expensive inflator build up
 					//
 					if (inflator == null)
 						inflator = inflatorFactory (arg);
 
 					constraints[i] = (TypeParameterSpec) constraints[i].InflateMember (inflator.Value);
 				}
 			}
 
 			if (constraints == null)
 				constraints = tparams;
 
 			return constraints;
 		}
 
 		public void InflateConstraints (TypeParameterInflator inflator, TypeParameterSpec tps)
 		{
 			tps.BaseType = inflator.Inflate (BaseType);
 			if (ifaces != null) {
 				tps.ifaces = new List<TypeSpec> (ifaces.Count);
 				for (int i = 0; i < ifaces.Count; ++i)
 					tps.ifaces.Add (inflator.Inflate (ifaces[i]));
 			}
 
 			if (targs != null) {
 				tps.targs = new TypeSpec[targs.Length];
 				for (int i = 0; i < targs.Length; ++i)
 					tps.targs[i] = inflator.Inflate (targs[i]);
 			}
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var tps = (TypeParameterSpec) MemberwiseClone ();
 			InflateConstraints (inflator, tps);
 			return tps;
 		}
 
 		//
 		// Populates type parameter members using type parameter constraints
 		// The trick here is to be called late enough but not too late to
 		// populate member cache with all members from other types
 		//
 		protected override void InitializeMemberCache (bool onlyTypes)
 		{
 			cache = new MemberCache ();
 
 			//
 			// For a type parameter the membercache is the union of the sets of members of the types
 			// specified as a primary constraint or secondary constraint
 			//
 			if (BaseType != TypeManager.object_type && BaseType != TypeManager.value_type)
 				cache.AddBaseType (BaseType);
 
 			if (ifaces != null) {
 				foreach (var iface_type in Interfaces) {
 					cache.AddInterface (iface_type);
 				}
 			}
 
 			if (targs != null) {
 				foreach (var ta in targs) {
 					if (ta.BaseType != TypeManager.object_type && ta.BaseType != TypeManager.value_type)
 						cache.AddBaseType (ta.BaseType);
 
 					if (ta.Interfaces != null) {
 						foreach (var iface_type in ta.Interfaces) {
 							cache.AddInterface (iface_type);
 						}
 					}
 				}
 			}
 		}
 
 		public bool IsConvertibleToInterface (TypeSpec iface)
 		{
 			if (Interfaces != null) {
 				foreach (var t in Interfaces) {
 					if (t == iface)
 						return true;
 				}
 			}
 
 			if (TypeArguments != null) {
 				foreach (var t in TypeArguments) {
 					if (((TypeParameterSpec) t).IsConvertibleToInterface (iface))
 						return true;
 				}
 			}
 
 			return false;
 		}
 
 		public override TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			return mutator.Mutate (this);
 		}
 	}
 
 	public struct TypeParameterInflator
 	{
 		readonly TypeSpec type;
 		readonly TypeParameterSpec[] tparams;
 		readonly TypeSpec[] targs;
 
 		public TypeParameterInflator (TypeParameterInflator nested, TypeSpec type)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="880" endline="893">
<![CDATA[
 
 		public override FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			if (arity == 0) {
 				TypeParameter[] tp = CurrentTypeParameters;
 				if (tp != null) {
 					TypeParameter t = TypeParameter.FindTypeParameter (tp, name);
 					if (t != null)
 						return new TypeParameterExpr (t, loc);
 				}
 			}
 
 			return base.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="677" endline="690">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (AsymmetricAlgorithm keypair, bool includePrivateKey) 
 		{
 			if (keypair == null)
 				throw new ArgumentNullException ("keypair");
 
 			// check between RSA and DSA (and potentially others like DH)
 			if (keypair is RSA)
 				return ToCapiKeyBlob ((RSA)keypair, includePrivateKey);
 			else if (keypair is DSA)
 				return ToCapiKeyBlob ((DSA)keypair, includePrivateKey);
 			else
 				return null;	// TODO
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="741" endline="749">
<![CDATA[
 		}
 
 		public override string Namespace
 		{
 			get
 			{
 				// for some reason, TypeBuilder doesn't return null (and mcs depends on this)
 				return base.Namespace ?? "";
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="325" endline="351">
<![CDATA[
 	}
 
 	struct RESOURCEHEADER
 	{
 		internal int DataSize;
 		internal int HeaderSize;
 		internal OrdinalOrName TYPE;
 		internal OrdinalOrName NAME;
 		internal int DataVersion;
 		internal ushort MemoryFlags;
 		internal ushort LanguageId;
 		internal int Version;
 		internal int Characteristics;
 
 		internal RESOURCEHEADER(ByteReader br)
 		{
 			DataSize = br.ReadInt32();
 			HeaderSize = br.ReadInt32();
 			TYPE = ReadOrdinalOrName(br);
 			NAME = ReadOrdinalOrName(br);
 			br.Align(4);
 			DataVersion = br.ReadInt32();
 			MemoryFlags = br.ReadUInt16();
 			LanguageId = br.ReadUInt16();
 			Version = br.ReadInt32();
 			Characteristics = br.ReadInt32();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="504" endline="510">
<![CDATA[
 
 		public BuildinTypeSpec (string name, Type buildinKind)
 			
 		{
 			// Make all internal types CLS-compliant, non-obsolete, compact
 			state = (state & ~(StateFlags.CLSCompliant_Undetected | StateFlags.Obsolete_Undetected | StateFlags.MissingDependency_Undetected)) | StateFlags.CLSCompliant;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="954" endline="967">
<![CDATA[
 
     Public Shared Function IsNullable(ByVal Type As TypeReference) As Boolean
         Dim git As GenericInstanceType
 
         If Type Is Nothing Then Return False
         If Not Type.IsGenericInstance Then Return False
 
         If Helper.CompareNameOrdinal(Type.Name, "Nullable`1") = False Then Return False
 
         git = TryCast(Type, GenericInstanceType)
         If git Is Nothing Then Return False
 
         Return Helper.CompareType(Compiler.CurrentCompiler.TypeCache.System_Nullable1, git.ElementType)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="358" endline="364">
<![CDATA[
 
     Shared Sub EmitCastClass(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Helper.Assert(CecilHelper.IsByRef(ToType) = False)
         Info.ILGen.Emit(OpCodes.Castclass, ToType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\literal.cs" startline="117" endline="132">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			//
 			// The 0 literal can be converted to an enum value
 			//
 			if (Value == 0 && TypeManager.IsEnumType (type)) {
 				Constant c = ConvertImplicitly (rc, EnumSpec.GetUnderlyingType (type));
 				if (c == null)
 					return null;
 
 				return new EnumConstant (c, type).Resolve (rc);
 			}
 
 			return base.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1250" endline="1271">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal method As PropertyReference) As PropertyDefinition
         If method Is Nothing Then Return Nothing
         Dim pD As PropertyDefinition
 
         If method.Annotations.Contains("OriginalProperty") Then
             pD = DirectCast(method.Annotations("OriginalProperty"), PropertyDefinition)
             Return pD
         End If
 
         pD = TryCast(method, PropertyDefinition)
 
         If pD IsNot Nothing Then Return pD
 
         Dim type As TypeDefinition = FindDefinition(method.DeclaringType)
         'method = method.GetOriginalMethod
         'If Helper.CompareNameOrdinal(method.Name, MethodDefinition.Cctor) OrElse Helper.CompareNameOrdinal(method.Name, MethodDefinition.Ctor) Then
         '    Return GetMethod(type.Constructors, method)
         'Else
         Return GetProperty(type.Properties, method)
         'End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="43" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="462" endline="487">
<![CDATA[
 
 		public override void EmitType ()
 		{
 			SymbolWriter.DefineAnonymousScope (ID);
 
 			if (hoisted_this != null)
 				hoisted_this.EmitSymbolInfo ();
 
 			if (hoisted_locals != null) {
 				foreach (HoistedVariable local in hoisted_locals)
 					local.EmitSymbolInfo ();
 				foreach (HoistedVariable local in hoisted_locals)
 					local.EmitSymbolInfo ();
 			}
 
 			if (hoisted_params != null) {
 				foreach (HoistedParameter param in hoisted_params)
 					param.EmitSymbolInfo ();
 				foreach (HoistedParameter param in hoisted_params)
 					param.EmitSymbolInfo ();
 			}
 
 			if (used_parent_storeys != null) {
 				foreach (StoreyFieldPair sf in used_parent_storeys) {
 					SymbolWriter.DefineCapturedScope (ID, sf.Storey.ID, sf.Field.Name);
 				}
 				foreach (StoreyFieldPair sf in used_parent_storeys) {
 					SymbolWriter.DefineCapturedScope (ID, sf.Storey.ID, sf.Field.Name);
 				}
 			}
 
 			base.EmitType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="319" endline="349">
<![CDATA[
 
 		public new void Define ()
 		{
 			builder = assembly.CreateModuleBuilder ();
 
 			// FIXME
 			static_data = null;
 
 			// TODO
 			// but that require DefineType clean-up
 			ResolveGlobalAttributes ();
 
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 
 			InitializePredefinedTypes ();
 
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="44" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1067" endline="1114">
<![CDATA[
 
 		static Modifiers ReadMethodModifiers (MethodBase mb, TypeSpec declaringType)
 		{
 			Modifiers mod;
 			var ma = mb.Attributes;
 			switch (ma & MethodAttributes.MemberAccessMask) {
 			case MethodAttributes.Public
 				mod = Modifiers.PUBLIC;
 				break;
 			case MethodAttributes.Assembly
 				mod = Modifiers.INTERNAL;
 				break;
 			case MethodAttributes.Family
 				mod = Modifiers.PROTECTED;
 				break;
 			case MethodAttributes.FamORAssem
 				mod = Modifiers.PROTECTED | Modifiers.INTERNAL;
 				break;
 			default
 				mod = Modifiers.PRIVATE;
 				break;
 			}
 
 			if ((ma & MethodAttributes.Static) != 0) {
 				mod |= Modifiers.STATIC;
 				return mod;
 			}
 			if ((ma & MethodAttributes.Abstract) != 0 && declaringType.IsClass) {
 				mod |= Modifiers.ABSTRACT;
 				return mod;
 			}
 
 			if ((ma & MethodAttributes.Final) != 0)
 				mod |= Modifiers.SEALED;
 
 			// It can be sealed and override
 			if ((ma & MethodAttributes.Virtual) != 0) {
 				if ((ma & MethodAttributes.NewSlot) != 0 || !declaringType.IsClass) {
 					// No private virtual or sealed virtual
 					if ((mod & (Modifiers.PRIVATE | Modifiers.SEALED)) == 0)
 						mod |= Modifiers.VIRTUAL;
 				} else {
 					mod |= Modifiers.OVERRIDE;
 				}
 			}
 
 			return mod;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="192" endline="236">
<![CDATA[
 
 		public static MethodAttributes MethodAttr (Modifiers mod_flags)
 		{
 			MethodAttributes ma = MethodAttributes.HideBySig;
 
 			switch (mod_flags & Modifiers.AccessibilityMask) {
 			case Modifiers.PUBLIC
 				ma |= MethodAttributes.Public;
 				break;
 			case Modifiers.PRIVATE
 				ma |= MethodAttributes.Private;
 				break;
 			case Modifiers.PROTECTED | Modifiers.INTERNAL
 				ma |= MethodAttributes.FamORAssem;
 				break;
 			case Modifiers.PROTECTED
 				ma |= MethodAttributes.Family;
 				break;
 			case Modifiers.INTERNAL
 				ma |= MethodAttributes.Assembly;
 				break;
 			default
 				throw new NotImplementedException (mod_flags.ToString ());
 			}
 
 			if ((mod_flags & Modifiers.STATIC) != 0)
 				ma |= MethodAttributes.Static;
 			if ((mod_flags & Modifiers.ABSTRACT) != 0) {
 				ma |= MethodAttributes.Abstract | MethodAttributes.Virtual;
 			}
 			if ((mod_flags & Modifiers.SEALED) != 0)
 				ma |= MethodAttributes.Final;
 
 			if ((mod_flags & Modifiers.VIRTUAL) != 0)
 				ma |= MethodAttributes.Virtual;
 
 			if ((mod_flags & Modifiers.OVERRIDE) != 0) {
 				ma |= MethodAttributes.Virtual;
 			} else {
 				if ((ma & MethodAttributes.Virtual) != 0)
 					ma |= MethodAttributes.NewSlot;
 			}
 			
 			return ma;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="136" endline="165">
<![CDATA[
 
 		public static TypeAttributes TypeAttr (Modifiers mod_flags, bool is_toplevel)
 		{
 			TypeAttributes t = 0;
 
 			if (is_toplevel){
 				if ((mod_flags & Modifiers.PUBLIC) != 0)
 					t = TypeAttributes.Public;
 				else if ((mod_flags & Modifiers.PRIVATE) != 0)
 					t = TypeAttributes.NotPublic;
 			} else {
 				if ((mod_flags & Modifiers.PUBLIC) != 0)
 					t = TypeAttributes.NestedPublic;
 				else if ((mod_flags & Modifiers.PRIVATE) != 0)
 					t = TypeAttributes.NestedPrivate;
 				else if ((mod_flags & (Modifiers.PROTECTED | Modifiers.INTERNAL)) == (Modifiers.PROTECTED | Modifiers.INTERNAL))
 					t = TypeAttributes.NestedFamORAssem;
 				else if ((mod_flags & Modifiers.PROTECTED) != 0)
 					t = TypeAttributes.NestedFamily;
 				else if ((mod_flags & Modifiers.INTERNAL) != 0)
 					t = TypeAttributes.NestedAssembly;
 			}
 
 			if ((mod_flags & Modifiers.SEALED) != 0)
 				t |= TypeAttributes.Sealed;
 			if ((mod_flags & Modifiers.ABSTRACT) != 0)
 				t |= TypeAttributes.Abstract;
 
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="166" endline="191">
<![CDATA[
 
 		public static FieldAttributes FieldAttr (Modifiers mod_flags)
 		{
 			FieldAttributes fa = 0;
 
 			if ((mod_flags & Modifiers.PUBLIC) != 0)
 				fa |= FieldAttributes.Public;
 			if ((mod_flags & Modifiers.PRIVATE) != 0)
 				fa |= FieldAttributes.Private;
 			if ((mod_flags & Modifiers.PROTECTED) != 0) {
 				if ((mod_flags & Modifiers.INTERNAL) != 0)
 					fa |= FieldAttributes.FamORAssem;
 				else 
 					fa |= FieldAttributes.Family;
 			} else {
 				if ((mod_flags & Modifiers.INTERNAL) != 0)
 					fa |= FieldAttributes.Assembly;
 			}
 
 			if ((mod_flags & Modifiers.STATIC) != 0)
 				fa |= FieldAttributes.Static;
 			if ((mod_flags & Modifiers.READONLY) != 0)
 				fa |= FieldAttributes.InitOnly;
 
 			return fa;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="45" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2376" endline="2422">
<![CDATA[
 
     'TODO
     Shared Function HexToInt(ByVal str As String) As ULong
         Dim i, n As Integer
         Dim l As Integer = str.Length
         HexToInt = 0
         For i = l To 1 Step -1
             Select Case str.Chars(i - 1)
                 Case "0"c
                     n = 0
                 Case "1"c
                     n = 1
                 Case "2"c
                     n = 2
                 Case "3"c
                     n = 3
                 Case "4"c
                     n = 4
                 Case "5"c
                     n = 5
                 Case "6"c
                     n = 6
                 Case "7"c
                     n = 7
                 Case "8"c
                     n = 8
                 Case "9"c
                     n = 9
                 Case "a"c, "A"c
                     n = 10
                 Case "b"c, "B"c
                     n = 11
                 Case "c"c, "C"c
                     n = 12
                 Case "d"c, "D"c
                     n = 13
                 Case "e"c, "E"c
                     n = 14
                 Case "f"c, "F"c
                     n = 15
                 Case Else
                     Throw New ArgumentOutOfRangeException("str", str, "Invalid hex number
             End Select
 
             HexToInt += CULng(n * (16 ^ (l - i)))
         Next
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2444" endline="2473">
<![CDATA[
 
     'TODO
     Shared Function OctToInt(ByVal str As String) As ULong
         Dim i, n As Integer
         Dim l As Integer = str.Length
         OctToInt = 0
         For i = l To 1 Step -1
             Select Case str.Chars(i - 1)
                 Case "0"c
                     n = 0
                 Case "1"c
                     n = 1
                 Case "2"c
                     n = 2
                 Case "3"c
                     n = 3
                 Case "4"c
                     n = 4
                 Case "5"c
                     n = 5
                 Case "6"c
                     n = 6
                 Case "7"c
                     n = 7
                 Case Else
                     Throw New ArgumentOutOfRangeException("str", str, "Invalid octal number
             End Select
             OctToInt += CULng(n * (8 ^ (l - i)))
         Next
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="46" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryMinusExpression.vb" startline="64" endline="95">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             Dim value As Object = Expression.ConstantValue
             Helper.Assert(value IsNot Nothing)
             Select Case Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))
                 Case TypeCode.SByte
                     Return -CSByte(value)
                 Case TypeCode.Int16
                     Return -CShort(value)
                 Case TypeCode.Int32
                     Return -CInt(value)
                 Case TypeCode.Int64
                     Return -CLng(value)
                 Case TypeCode.Byte
                 Case TypeCode.UInt16
                 Case TypeCode.UInt32
                 Case TypeCode.UInt64
                     Return -CULng(value)
                 Case TypeCode.Decimal
                     Return -CDec(value)
                 Case TypeCode.Double
                     Return -CDbl(value)
                 Case TypeCode.Single
                     Return -CSng(value)
                 Case Else
                     Helper.Stop()
             End Select
             Helper.Stop()
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="59" endline="90">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             Dim value As Object = Expression.ConstantValue
             Helper.Assert(value IsNot Nothing)
             Select Case Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))
                 Case TypeCode.SByte
                     Return Not CSByte(value)
                 Case TypeCode.Byte
                     Return Not CByte(value)
                 Case TypeCode.Int16
                     Return Not CShort(value)
                 Case TypeCode.Int32
                     Return Not CInt(value)
                 Case TypeCode.Int64
                     Return Not CLng(value)
                 Case TypeCode.UInt16
                     Return Not CUShort(value)
                 Case TypeCode.UInt32
                     Return Not CUInt(value)
                 Case TypeCode.UInt64
                     Return Not CULng(value)
                 Case TypeCode.Decimal, TypeCode.Double, TypeCode.Single
                     Throw New InternalException(Me)
                 Case Else
                     Throw New InternalException(Me)
             End Select
             Helper.Stop()
             Return Nothing
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="47" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="341" endline="369">
<![CDATA[
 
     Private Sub CreateDefaultCtorCallCecil()
         Dim type As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim classtype As ClassDeclaration = TryCast(type, ClassDeclaration)
         Dim defaultctor As Mono.Cecil.MethodReference
         If classtype IsNot Nothing Then
             defaultctor = classtype.GetBaseDefaultConstructorCecil()
             If defaultctor IsNot Nothing AndAlso Helper.IsPrivate(defaultctor) = False Then
                 If Helper.IsPrivate(defaultctor) OrElse (Helper.IsFamilyOrAssembly(defaultctor) AndAlso defaultctor.DeclaringType.Module.Assembly IsNot Me.Compiler.AssemblyBuilderCecil) Then
                     Helper.AddError(Compiler, Location, "Base class does not have an accessible default constructor")
                 Else
                     m_DefaultBaseConstructorCecil = defaultctor
                     m_DefaultBaseConstructorCecil = Helper.GetMethodOrMethodReference(Compiler, m_DefaultBaseConstructorCecil)
 
 #If DEBUG Then
                     Try
                         For Each param As Mono.Cecil.ParameterDefinition In m_DefaultBaseConstructor.Parameters
                             Helper.Assert(param.IsOptional)
                         Next
                     Catch ex As Exception
                         Helper.Assert(False)
                     End Try
 #End If
                 End If
             Else
                 Helper.AddError(Compiler, Location, "Base class does not have a default constructor")
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="313" endline="340">
<![CDATA[
 
     Private Sub CreateDefaultCtorCall()
         Dim type As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim classtype As ClassDeclaration = TryCast(type, ClassDeclaration)
         Dim defaultctor As Mono.Cecil.MethodReference
         If classtype IsNot Nothing Then
             defaultctor = classtype.GetBaseDefaultConstructor()
             If defaultctor IsNot Nothing AndAlso Helper.IsPrivate(defaultctor) = False Then
                 If Helper.IsPrivate(defaultctor) OrElse (Helper.IsFriend(defaultctor) AndAlso Not Compiler.Assembly.IsDefinedHere(defaultctor.DeclaringType)) Then
                     Helper.AddError(Me, "Base class does not have an accessible default constructor")
                 Else
                     m_DefaultBaseConstructor = defaultctor
 
 #If DEBUG Then
                     Try
                         For Each param As Mono.Cecil.ParameterDefinition In m_DefaultBaseConstructor.Parameters
                             Helper.Assert(param.IsOptional)
                         Next
                     Catch ex As Exception
                         Helper.Assert(False)
                     End Try
 #End If
                 End If
             Else
                 Helper.AddError(Me, "Base class does not have a default constructor")
             End If
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="48" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="362" endline="393">
<![CDATA[
 
 		/// 
 		/// Looks for extension method in this namespace
 		/// 
 		public List<MethodSpec> LookupExtensionMethod (TypeSpec extensionType, TypeContainer invocationContext, string name, int arity)
 		{
 			if (types == null)
 				return null;
 
 			List<MethodSpec> found = null;
 
 			// TODO
 
 			foreach (var tgroup in types.Values) {
 				foreach (var ts in tgroup) {
 					if ((ts.Modifiers & Modifiers.METHOD_EXTENSION) == 0)
 						continue;
 
 					var res = ts.MemberCache.FindExtensionMethods (invocationContext, extensionType, name, arity);
 					if (res == null)
 						continue;
 
 					if (found == null) {
 						found = res;
 					} else {
 						found.AddRange (res);
 					}
 				}
 				foreach (var ts in tgroup) {
 					if ((ts.Modifiers & Modifiers.METHOD_EXTENSION) == 0)
 						continue;
 
 					var res = ts.MemberCache.FindExtensionMethods (invocationContext, extensionType, name, arity);
 					if (res == null)
 						continue;
 
 					if (found == null) {
 						found = res;
 					} else {
 						found.AddRange (res);
 					}
 				}
 			}
 			foreach (var tgroup in types.Values) {
 				foreach (var ts in tgroup) {
 					if ((ts.Modifiers & Modifiers.METHOD_EXTENSION) == 0)
 						continue;
 
 					var res = ts.MemberCache.FindExtensionMethods (invocationContext, extensionType, name, arity);
 					if (res == null)
 						continue;
 
 					if (found == null) {
 						found = res;
 					} else {
 						found.AddRange (res);
 					}
 				}
 			}
 
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="659" endline="681">
<![CDATA[
 
 		public static IList<MemberSpec> GetCompletitionMembers (TypeSpec container, string name)
 		{
 			var matches = new List<MemberSpec> ();
 			foreach (var entry in container.MemberCache.member_hash) {
 				foreach (var name_entry in entry.Value) {
 					if (name_entry.IsAccessor)
 						continue;
 
 					if ((name_entry.Kind & (MemberKind.Constructor | MemberKind.Destructor | MemberKind.Operator)) != 0)
 						continue;
 
 					if (!name_entry.IsAccessible (InternalType.FakeInternalType))
 						continue;
 
 					if (name == null || name_entry.Name.StartsWith (name)) {
 						matches.Add (name_entry);
 					}
 				}
 				foreach (var name_entry in entry.Value) {
 					if (name_entry.IsAccessor)
 						continue;
 
 					if ((name_entry.Kind & (MemberKind.Constructor | MemberKind.Destructor | MemberKind.Operator)) != 0)
 						continue;
 
 					if (!name_entry.IsAccessible (InternalType.FakeInternalType))
 						continue;
 
 					if (name == null || name_entry.Name.StartsWith (name)) {
 						matches.Add (name_entry);
 					}
 				}
 			}
 			foreach (var entry in container.MemberCache.member_hash) {
 				foreach (var name_entry in entry.Value) {
 					if (name_entry.IsAccessor)
 						continue;
 
 					if ((name_entry.Kind & (MemberKind.Constructor | MemberKind.Destructor | MemberKind.Operator)) != 0)
 						continue;
 
 					if (!name_entry.IsAccessible (InternalType.FakeInternalType))
 						continue;
 
 					if (name == null || name_entry.Name.StartsWith (name)) {
 						matches.Add (name_entry);
 					}
 				}
 			}
 
 			return matches;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="682" endline="708">
<![CDATA[
 
 		//
 		// Returns members of @iface only, base members are ignored
 		//
 		public static IList<MethodSpec> GetInterfaceMethods (TypeSpec iface)
 		{
 			//
 			// MemberCache flatten interfaces, therefore in cases like this one
 			// 
 			// interface IA 
 			// interface IB { void Foo () }
 			//
 			// we would return Foo inside IA which is not expected in this case
 			//
 			var methods = new List<MethodSpec> ();
 			foreach (var entry in iface.MemberCache.member_hash.Values) {
 				foreach (var name_entry in entry) {
 					if (iface == name_entry.DeclaringType) {
 						if (name_entry.Kind == MemberKind.Method) {
 							methods.Add ((MethodSpec) name_entry);
 						}
 					}
 				}
 				foreach (var name_entry in entry) {
 					if (iface == name_entry.DeclaringType) {
 						if (name_entry.Kind == MemberKind.Method) {
 							methods.Add ((MethodSpec) name_entry);
 						}
 					}
 				}
 			}
 			foreach (var entry in iface.MemberCache.member_hash.Values) {
 				foreach (var name_entry in entry) {
 					if (iface == name_entry.DeclaringType) {
 						if (name_entry.Kind == MemberKind.Method) {
 							methods.Add ((MethodSpec) name_entry);
 						}
 					}
 				}
 			}
 
 			return methods;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="49" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="114" endline="156">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.FieldOffset) {
 				status |= Status.HAS_OFFSET;
 
 				if (!Parent.PartialContainer.HasExplicitLayout) {
 					Report.Error (636, Location, "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)");
 					return;
 				}
 
 				if ((ModFlags & Modifiers.STATIC) != 0 || this is Const) {
 					Report.Error (637, Location, "The FieldOffset attribute is not allowed on static or const fields");
 					return;
 				}
 			}
 
 			if (a.Type == pa.FixedBuffer) {
 				Report.Error (1716, Location, "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead");
 				return;
 			}
 
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					FieldBuilder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2402" endline="2430">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.AttributeUsage) {
 				if (!BaseType.IsAttribute && spec != TypeManager.attribute_type) {
 					Report.Error (641, a.Location, "Attribute `{0}' is only valid on classes derived from System.Attribute", a.GetSignatureForError ());
 				}
 			}
 
 			if (a.Type == pa.Conditional && !BaseType.IsAttribute) {
 				Report.Error (1689, a.Location, "Attribute `System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes");
 				return;
 			}
 
 			if (a.Type == pa.ComImport && !attributes.Contains (pa.Guid)) {
 				a.Error_MissingGuidAttribute ();
 				return;
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			if (a.Type.IsConditionallyExcluded (Location))
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="50" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="173" endline="193">
<![CDATA[
 
 		public override PropertyInfo[] __GetDeclaredProperties()
 		{
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.PropertyMap.records.Length; i++)
 			{
 				if (module.PropertyMap.records[i].Parent == token)
 				{
 					int property = module.PropertyMap.records[i].PropertyList - 1;
 					int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1 
 					PropertyInfo[] properties = new PropertyInfo[end - property];
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					return properties;
 				}
 			}
 			for (int i = 0; i < module.PropertyMap.records.Length; i++)
 			{
 				if (module.PropertyMap.records[i].Parent == token)
 				{
 					int property = module.PropertyMap.records[i].PropertyList - 1;
 					int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1 
 					PropertyInfo[] properties = new PropertyInfo[end - property];
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					return properties;
 				}
 			}
 			return Empty<PropertyInfo>.Array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="64" endline="85">
<![CDATA[
 		}
 
 		public override EventInfo[] __GetDeclaredEvents()
 		{
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.EventMap.records.Length; i++)
 			{
 				if (module.EventMap.records[i].Parent == token)
 				{
 					int evt = module.EventMap.records[i].EventList - 1;
 					int end = module.EventMap.records.Length > i + 1 ? module.EventMap.records[i + 1].EventList - 1 
 					EventInfo[] events = new EventInfo[end - evt];
 					for (int j = 0; evt < end; evt++, j++)
 					{
 						events[j] = new EventInfoImpl(module, this, evt);
 					}
 					for (int j = 0; evt < end; evt++, j++)
 					{
 						events[j] = new EventInfoImpl(module, this, evt);
 					}
 					return events;
 				}
 			}
 			for (int i = 0; i < module.EventMap.records.Length; i++)
 			{
 				if (module.EventMap.records[i].Parent == token)
 				{
 					int evt = module.EventMap.records[i].EventList - 1;
 					int end = module.EventMap.records.Length > i + 1 ? module.EventMap.records[i + 1].EventList - 1 
 					EventInfo[] events = new EventInfo[end - evt];
 					for (int j = 0; evt < end; evt++, j++)
 					{
 						events[j] = new EventInfoImpl(module, this, evt);
 					}
 					return events;
 				}
 			}
 			return Empty<EventInfo>.Array;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="51" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="236" endline="266">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.ModuleBuilder.universe;
 			Type type = customBuilder.Constructor.DeclaringType;
 			if (type == u.System_Runtime_InteropServices_DllImportAttribute)
 			{
 				attributes |= MethodAttributes.PinvokeImpl;
 				SetDllImportPseudoCustomAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
 			}
 			else if (type == u.System_Runtime_CompilerServices_MethodImplAttribute)
 			{
 				SetMethodImplAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
 			}
 			else if (type == u.System_Runtime_InteropServices_PreserveSigAttribute)
 			{
 				implFlags |= MethodImplAttributes.PreserveSig;
 			}
 			else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= MethodAttributes.SpecialName;
 			}
 			else
 			{
 				if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
 				{
 					attributes |= MethodAttributes.HasSecurity;
 				}
 				this.ModuleBuilder.SetCustomAttribute(pseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="85" endline="111">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.Module.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_FieldOffsetAttribute)
 			{
 				customBuilder = customBuilder.DecodeBlob(this.Module.Assembly);
 				SetOffset((int)customBuilder.GetConstructorArgument(0));
 			}
 			else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute)
 			{
 				MarshalSpec.SetMarshalAsAttribute(typeBuilder.ModuleBuilder, pseudoToken, customBuilder);
 				attribs |= FieldAttributes.HasFieldMarshal;
 			}
 			else if (customBuilder.Constructor.DeclaringType == u.System_NonSerializedAttribute)
 			{
 				attribs |= FieldAttributes.NotSerialized;
 			}
 			else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attribs |= FieldAttributes.SpecialName;
 			}
 			else
 			{
 				typeBuilder.ModuleBuilder.SetCustomAttribute(pseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="561" endline="590">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.ModuleBuilder.universe;
 			Type type = customBuilder.Constructor.DeclaringType;
 			if (type == u.System_Runtime_InteropServices_StructLayoutAttribute)
 			{
 				SetStructLayoutPseudoCustomAttribute(customBuilder.DecodeBlob(this.Assembly));
 			}
 			else if (type == u.System_SerializableAttribute)
 			{
 				attribs |= TypeAttributes.Serializable;
 			}
 			else if (type == u.System_Runtime_InteropServices_ComImportAttribute)
 			{
 				attribs |= TypeAttributes.Import;
 			}
 			else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attribs |= TypeAttributes.SpecialName;
 			}
 			else
 			{
 				if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
 				{
 					attribs |= TypeAttributes.HasSecurity;
 				}
 				this.ModuleBuilder.SetCustomAttribute(token, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="95" endline="120">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customAttributeBuilder)
 		{
 			Universe u = moduleBuilder.universe;
 			if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_InAttribute)
 			{
 				flags |= (short)ParameterAttributes.In;
 			}
 			else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OutAttribute)
 			{
 				flags |= (short)ParameterAttributes.Out;
 			}
 			else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OptionalAttribute)
 			{
 				flags |= (short)ParameterAttributes.Optional;
 			}
 			else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute)
 			{
 				MarshalSpec.SetMarshalAsAttribute(moduleBuilder, PseudoToken, customAttributeBuilder);
 				flags |= (short)ParameterAttributes.HasFieldMarshal;
 			}
 			else
 			{
 				moduleBuilder.SetCustomAttribute(PseudoToken, customAttributeBuilder);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="52" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="560" endline="615">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="R"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function CheckNamespace(ByVal R As String, ByVal Types As TypeDictionary, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* (...)
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '*
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         '*
         '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
         '** error occurs.
         '---------------------------------------------------------------------------------------------------------
 
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         Dim RName As String = vbnc.Helper.CreateGenericTypename(R, TypeArgumentCount)
 
         Dim foundType As Mono.Cecil.TypeReference
 
         foundType = Types.Item(RName)
         If foundType IsNot Nothing Then
             m_FoundObjects.Add(foundType)
             Return True
         End If
 
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         Dim foundModules As Generic.List(Of Mono.Cecil.TypeReference)
         foundModules = Helper.FilterToModules(FromWhere.Compiler, Types)
         If foundModules.Count > 0 Then
             Dim typesInAllModules As New Generic.List(Of Mono.Cecil.TypeReference)
             For Each [module] As Mono.Cecil.TypeReference In foundModules
                 Dim typeInCurrentModule As Mono.Cecil.TypeReference
                 typeInCurrentModule = CecilHelper.GetNestedType([module], RName)
                 If typeInCurrentModule IsNot Nothing Then typesInAllModules.Add(typeInCurrentModule)
             Next
             If typesInAllModules.Count = 1 Then
                 m_FoundObjects.AddRange(typesInAllModules.ToArray)
                 Return True
             ElseIf typesInAllModules.Count > 1 Then
                 '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
                 '** error occurs.
                 Helper.AddError(Name)
                 Return False
             End If
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="529" endline="559">
<![CDATA[
 
     Private Function CheckModules(ByVal moduletypes As TypeList, ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '**	(...), and R matches the name of an 
         '** accessible nested type in exactly one standard module, (...)
 #If DEBUG Then
         For Each t As Mono.Cecil.TypeReference In moduletypes
             Helper.Assert(Helper.IsModule(FromWhere.Compiler, t))
         Next
 #End If
         Dim allModuleTypes As New Generic.List(Of Mono.Cecil.TypeReference) 'Descriptor)
 
         For Each t As Mono.Cecil.TypeReference In moduletypes
             Dim tFound As Mono.Cecil.TypeReference
             tFound = CecilHelper.GetNestedType(t, R)
             If tFound IsNot Nothing Then
                 allModuleTypes.Add(tFound)
             End If
         Next
 
         If allModuleTypes.Count = 1 Then
             m_FoundObjects.Add(allModuleTypes.Item(0))
             Return True
         ElseIf allModuleTypes.Count > 1 Then
             '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
             '** error occurs.
             Helper.AddError(Name)
             Return False
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="53" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2283" endline="2309">
<![CDATA[
 		
 		bool pp_eq (ref string s)
 		{
 			bool va = pp_unary (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '='){
 					if (len > 2 && s [1] == '='){
 						s = s.Substring (2);
 						return va == pp_unary (ref s);
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} else if (s [0] == '!' && len > 1 && s [1] == '='){
 					s = s.Substring (2);
 
 					return va != pp_unary (ref s);
 
 				} 
 			}
 
 			return va;
 				
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2330" endline="2358">
<![CDATA[
 		
 		//
 		// Evaluates an expression for `#if' or `#elif'
 		//
 		bool pp_expr (ref string s, bool isTerm)
 		{
 			bool va = pp_and (ref s);
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				char c = s [0];
 				
 				if (c == '|'){
 					if (len > 2 && s [1] == '|'){
 						s = s.Substring (2);
 						return va | pp_expr (ref s, isTerm);
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				}
 				if (isTerm) {
 					Error_EndLineExpected ();
 					return false;
 				}
 			}
 			
 			return va;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2262" endline="2282">
<![CDATA[
 		
 		bool pp_unary (ref string s)
 		{
 			s = s.Trim ();
 			int len = s.Length;
 
 			if (len > 0){
 				if (s [0] == '!'){
 					if (len > 1 && s [1] == '='){
 						Error_InvalidDirective ();
 						return false;
 					}
 					s = s.Substring (1);
 					return ! pp_primary (ref s);
 				} else
 					return pp_primary (ref s);
 			} else {
 				Error_InvalidDirective ();
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2310" endline="2329">
<![CDATA[
 		
 		bool pp_and (ref string s)
 		{
 			bool va = pp_eq (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '&'){
 					if (len > 2 && s [1] == '&'){
 						s = s.Substring (2);
 						return (va & pp_and (ref s));
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} 
 			}
 			return va;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="54" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1354" endline="1374">
<![CDATA[
 
     Shared Function IsShadows(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean = True
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).IsHideBySig = False
             Case MemberTypes.Property
                 Return CBool(Helper.GetPropertyAttributes(DirectCast(Member, Mono.Cecil.PropertyReference)) And Mono.Cecil.MethodAttributes.HideBySig) = False
             Case MemberTypes.Field
                 Return True
             Case MemberTypes.TypeInfo
                 Return True
             Case MemberTypes.NestedType
                 Return True
             Case MemberTypes.Event
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference)).AddMethod.IsHideBySig = False
             Case Else
                 Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         End Select
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1375" endline="1396">
<![CDATA[
 
     Shared Function IsShared(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean = True
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).IsStatic
             Case MemberTypes.Property
                 Dim pInfo As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
                 Return CBool(Helper.GetPropertyAttributes(pInfo) And Mono.Cecil.MethodAttributes.Static)
             Case MemberTypes.Field
                 Dim fInfo As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.FieldReference))
                 Return fInfo.IsStatic
             Case MemberTypes.TypeInfo
                 Return False
             Case MemberTypes.NestedType
                 Return False
             Case MemberTypes.Event
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference)).AddMethod.IsStatic
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="61" endline="79">
<![CDATA[
 
     Shared Function TypeCharacterToType(ByVal Compiler As Compiler, ByVal TypeCharacter As TypeCharacters.Characters) As Mono.Cecil.TypeReference
         Select Case GetDataType(TypeCharacter)
             Case KS.Integer
                 Return Compiler.TypeCache.System_Int32
             Case KS.Long
                 Return Compiler.TypeCache.System_Int64
             Case KS.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case KS.Single
                 Return Compiler.TypeCache.System_Single
             Case KS.Double
                 Return Compiler.TypeCache.System_Double
             Case KS.String
                 Return Compiler.TypeCache.System_String
             Case Else
                 Throw New InternalException("Unknown typecharacter
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="55" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="105" endline="143">
<![CDATA[
 		internal readonly ModuleTable ModuleTable = new ModuleTable();
 		internal readonly TypeRefTable TypeRef = new TypeRefTable();
 		internal readonly TypeDefTable TypeDef = new TypeDefTable();
 		internal readonly FieldTable Field = new FieldTable();
 		internal readonly MemberRefTable MemberRef = new MemberRefTable();
 		internal readonly ConstantTable Constant = new ConstantTable();
 		internal readonly CustomAttributeTable CustomAttribute = new CustomAttributeTable();
 		internal readonly FieldMarshalTable FieldMarshal = new FieldMarshalTable();
 		internal readonly DeclSecurityTable DeclSecurity = new DeclSecurityTable();
 		internal readonly ClassLayoutTable ClassLayout = new ClassLayoutTable();
 		internal readonly FieldLayoutTable FieldLayout = new FieldLayoutTable();
 		internal readonly ParamTable Param = new ParamTable();
 		internal readonly InterfaceImplTable InterfaceImpl = new InterfaceImplTable();
 		internal readonly StandAloneSigTable StandAloneSig = new StandAloneSigTable();
 		internal readonly EventMapTable EventMap = new EventMapTable();
 		internal readonly EventTable Event = new EventTable();
 		internal readonly PropertyMapTable PropertyMap = new PropertyMapTable();
 		internal readonly PropertyTable Property = new PropertyTable();
 		internal readonly MethodSemanticsTable MethodSemantics = new MethodSemanticsTable();
 		internal readonly MethodImplTable MethodImpl = new MethodImplTable();
 		internal readonly ModuleRefTable ModuleRef = new ModuleRefTable();
 		internal readonly TypeSpecTable TypeSpec = new TypeSpecTable();
 		internal readonly ImplMapTable ImplMap = new ImplMapTable();
 		internal readonly FieldRVATable FieldRVA = new FieldRVATable();
 		internal readonly AssemblyTable AssemblyTable = new AssemblyTable();
 		internal readonly AssemblyRefTable AssemblyRef = new AssemblyRefTable();
 		internal readonly MethodDefTable MethodDef = new MethodDefTable();
 		internal readonly NestedClassTable NestedClass = new NestedClassTable();
 		internal readonly FileTable File = new FileTable();
 		internal readonly ExportedTypeTable ExportedType = new ExportedTypeTable();
 		internal readonly ManifestResourceTable ManifestResource = new ManifestResourceTable();
 		internal readonly GenericParamTable GenericParam = new GenericParamTable();
 		internal readonly MethodSpecTable MethodSpec = new MethodSpecTable();
 		internal readonly GenericParamConstraintTable GenericParamConstraint = new GenericParamConstraintTable();
 
 		internal Module(Universe universe)
 		{
 			this.universe = universe;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="41" endline="114">
<![CDATA[
 		private readonly Guid mvid = Guid.NewGuid();
 		private long imageBaseAddress = 0x00400000;
 		private readonly AssemblyBuilder asm;
 		internal readonly string moduleName;
 		internal readonly string fileName;
 		internal readonly ISymbolWriterImpl symbolWriter;
 		private readonly TypeBuilder moduleType;
 		private readonly List<TypeBuilder> types = new List<TypeBuilder>();
 		private readonly Dictionary<Type, int> typeTokens = new Dictionary<Type, int>();
 		private readonly Dictionary<Type, int> memberRefTypeTokens = new Dictionary<Type, int>();
 		private readonly Dictionary<string, TypeBuilder> fullNameToType = new Dictionary<string, TypeBuilder>();
 		internal readonly ByteBuffer methodBodies = new ByteBuffer(128 * 1024);
 		internal readonly List<int> tokenFixupOffsets = new List<int>();
 		internal readonly ByteBuffer initializedData = new ByteBuffer(512);
 		internal readonly ByteBuffer manifestResources = new ByteBuffer(512);
 		internal ResourceSection unmanagedResources;
 		private readonly Dictionary<MemberInfo, int> importedMembers = new Dictionary<MemberInfo, int>();
 		private readonly Dictionary<MemberRefKey, int> importedMemberRefs = new Dictionary<MemberRefKey, int>();
 		private readonly Dictionary<Assembly, int> referencedAssemblies = new Dictionary<Assembly, int>();
 		private List<AssemblyName> referencedAssemblyNames;
 		private int nextPseudoToken = -1;
 		private readonly List<int> resolvedTokens = new List<int>();
 		internal readonly TableHeap Tables = new TableHeap();
 		internal readonly StringHeap Strings = new StringHeap();
 		internal readonly UserStringHeap UserStrings = new UserStringHeap();
 		internal readonly GuidHeap Guids = new GuidHeap();
 		internal readonly BlobHeap Blobs = new BlobHeap();
 
 		struct MemberRefKey 
 		{
 			private readonly Type type;
 			private readonly string name;
 			private readonly Signature signature;
 
 			internal MemberRefKey(Type type, string name, Signature signature)
 			{
 				this.type = type;
 				this.name = name;
 				this.signature = signature;
 			}
 
 			public bool Equals(MemberRefKey other)
 			{
 				return other.type.Equals(type)
 					&& other.name == name
 					&& other.signature.Equals(signature);
 			}
 
 			public override bool Equals(object obj)
 			{
 				MemberRefKey? other = obj as MemberRefKey?;
 				return other != null && Equals(other);
 			}
 
 			public override int GetHashCode()
 			{
 				return type.GetHashCode() + name.GetHashCode() + signature.GetHashCode();
 			}
 		}
 
 		internal ModuleBuilder(AssemblyBuilder asm, string moduleName, string fileName, bool emitSymbolInfo)
 			
 		{
 			this.asm = asm;
 			this.moduleName = moduleName;
 			this.fileName = fileName;
 			if (emitSymbolInfo)
 			{
 				symbolWriter = SymbolSupport.CreateSymbolWriterFor(this);
 			}
 			// <Module> must be the first record in the TypeDef table
 			moduleType = new TypeBuilder(this, "<Module>", null, 0);
 			types.Add(moduleType);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="56" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="779" endline="809">
<![CDATA[
 
 		public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
 		{
 			List<PropertyInfo> list = new List<PropertyInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="479" endline="509">
<![CDATA[
 
 		public EventInfo[] GetEvents(BindingFlags bindingAttr)
 		{
 			List<EventInfo> list = new List<EventInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="57" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="57" endline="75">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If IsStatic Then
             If m_FieldBuilderStaticInit Is Nothing AndAlso HasInitializer Then
                 Dim staticName As String
                 Dim attr As Mono.Cecil.FieldAttributes = Mono.Cecil.FieldAttributes.Private
 
                 staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name & "$Init"
                 If DeclaringMethod.IsShared Then attr = attr Or Mono.Cecil.FieldAttributes.Static
 
                 m_FieldBuilderStaticInit = New Mono.Cecil.FieldDefinition(staticName, attr, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag))
                 DeclaringType.CecilType.Fields.Add(m_FieldBuilderStaticInit)
             End If
         Else
             'TODO
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="76" endline="94">
<![CDATA[
 
     Private Function DefineField() As Boolean
         Dim result As Boolean = True
 
         'result = MyBase.Define AndAlso result
 
         If IsStatic AndAlso m_FieldBuilderStatic Is Nothing Then
             Dim staticName As String
             Dim attr As Mono.Cecil.FieldAttributes = Mono.Cecil.FieldAttributes.Private
 
             staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name
             If DeclaringMethod.IsShared Then attr = attr Or Mono.Cecil.FieldAttributes.Static
 
             m_FieldBuilderStatic = New Mono.Cecil.FieldDefinition(staticName, attr, Helper.GetTypeOrTypeReference(Compiler, Me.VariableType))
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderStatic)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="152" endline="165">
<![CDATA[
 
     Friend Function DefineStaticMember() As Boolean
         Dim result As Boolean = True
 
         If FieldBuilder Is Nothing Then
 
             Dim staticName As String
             staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name
             m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(staticName, Helper.GetAttributes(Compiler, Me), Helper.GetTypeOrTypeReference(Compiler, FieldType))
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderCecil)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="58" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="511" endline="542">
<![CDATA[
 		}
 
 		internal int LineNumberCount = 0;
 		internal int LocalCount = 0;
 		internal int StringSize = 0;
 
 		internal int LineNumberSize = 0;
 		internal int ExtendedLineNumberSize = 0;
 
 		public SourceFileEntry GetSourceFile (int index)
 		{
 			if ((index < 1) || (index > ot.SourceCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				SourceFileEntry source;
 				if (source_file_hash.TryGetValue (index, out source))
 					return source;
 
 				long old_pos = reader.BaseStream.Position;
 
 				reader.BaseStream.Position = ot.SourceTableOffset +
 					SourceFileEntry.Size * (index - 1);
 				source = new SourceFileEntry (this, reader);
 				source_file_hash.Add (index, source);
 
 				reader.BaseStream.Position = old_pos;
 				return source;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="554" endline="578">
<![CDATA[
 		}
 
 		public CompileUnitEntry GetCompileUnit (int index)
 		{
 			if ((index < 1) || (index > ot.CompileUnitCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				CompileUnitEntry unit;
 				if (compile_unit_hash.TryGetValue (index, out unit))
 					return unit;
 
 				long old_pos = reader.BaseStream.Position;
 
 				reader.BaseStream.Position = ot.CompileUnitTableOffset +
 					CompileUnitEntry.Size * (index - 1);
 				unit = new CompileUnitEntry (this, reader);
 				compile_unit_hash.Add (index, unit);
 
 				reader.BaseStream.Position = old_pos;
 				return unit;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="59" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="130" endline="172">
<![CDATA[
 
     Shared Function TypeCodeToBuiltInType(ByVal tp As TypeCode) As BuiltInDataTypes
         Select Case tp
             Case TypeCode.Boolean
                 Return BuiltInDataTypes.Boolean
             Case TypeCode.Byte
                 Return BuiltInDataTypes.Byte
             Case TypeCode.Char
                 Return BuiltInDataTypes.Char
             Case TypeCode.DateTime
                 Return BuiltInDataTypes.Date
             Case TypeCode.DBNull
                 Throw New InternalException("")
             Case TypeCode.Decimal
                 Return BuiltInDataTypes.Decimal
             Case TypeCode.Double
                 Return BuiltInDataTypes.Double
             Case TypeCode.Empty
                 Throw New InternalException("")
             Case TypeCode.Int16
                 Return BuiltInDataTypes.Short
             Case TypeCode.Int32
                 Return BuiltInDataTypes.Integer
             Case TypeCode.Int64
                 Return BuiltInDataTypes.Long
             Case TypeCode.Object
                 Return BuiltInDataTypes.Object
             Case TypeCode.SByte
                 Return BuiltInDataTypes.SByte
             Case TypeCode.Single
                 Return BuiltInDataTypes.Single
             Case TypeCode.String
                 Return BuiltInDataTypes.String
             Case TypeCode.UInt16
                 Return BuiltInDataTypes.UShort
             Case TypeCode.UInt32
                 Return BuiltInDataTypes.UInteger
             Case TypeCode.UInt64
                 Return BuiltInDataTypes.ULong
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="298" endline="336">
<![CDATA[
 
     Shared Function KeywordToTypeCode(ByVal Keyword As KS) As TypeCode
         Select Case Keyword
             Case KS.Boolean
                 Return TypeCode.Boolean
             Case KS.Byte
                 Return TypeCode.Byte
             Case KS.Char
                 Return TypeCode.Char
             Case KS.Date
                 Return TypeCode.DateTime
             Case KS.Decimal
                 Return TypeCode.Decimal
             Case KS.Double
                 Return TypeCode.Double
             Case KS.Integer
                 Return TypeCode.Int32
             Case KS.Long
                 Return TypeCode.Int64
             Case KS.Object
                 Return TypeCode.Object
             Case KS.Single
                 Return TypeCode.Single
             Case KS.Short
                 Return TypeCode.Int16
             Case KS.String
                 Return TypeCode.String
             Case KS.SByte
                 Return TypeCode.SByte
             Case KS.UShort
                 Return TypeCode.UInt16
             Case KS.UInteger
                 Return TypeCode.UInt32
             Case KS.ULong
                 Return TypeCode.UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="259" endline="297">
<![CDATA[
 
     Private Shared Function getTypeIndex(ByVal special As BuiltInDataTypes) As Integer
         Select Case special
             Case BuiltInDataTypes.Boolean
                 Return 0
             Case BuiltInDataTypes.Byte
                 Return 1
             Case BuiltInDataTypes.Char
                 Return 2
             Case BuiltInDataTypes.Date
                 Return 3
             Case BuiltInDataTypes.Decimal
                 Return 4
             Case BuiltInDataTypes.Double
                 Return 5
             Case BuiltInDataTypes.Integer
                 Return 6
             Case BuiltInDataTypes.Long
                 Return 7
             Case BuiltInDataTypes.Object
                 Return 8
             Case BuiltInDataTypes.[SByte]
                 Return 9
             Case BuiltInDataTypes.Short
                 Return 10
             Case BuiltInDataTypes.Single
                 Return 11
             Case BuiltInDataTypes.String
                 Return 12
             Case BuiltInDataTypes.[UInteger]
                 Return 13
             Case BuiltInDataTypes.[ULong]
                 Return 14
             Case BuiltInDataTypes.[UShort]
                 Return 15
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="173" endline="211">
<![CDATA[
 
     Shared Function BuiltInTypeToTypeCode(ByVal Type As BuiltInDataTypes) As TypeCode
         Select Case Type
             Case BuiltInDataTypes.Boolean
                 Return TypeCode.Boolean
             Case BuiltInDataTypes.Byte
                 Return TypeCode.Byte
             Case BuiltInDataTypes.Char
                 Return TypeCode.Char
             Case BuiltInDataTypes.Date
                 Return TypeCode.DateTime
             Case BuiltInDataTypes.Decimal
                 Return TypeCode.Decimal
             Case BuiltInDataTypes.Double
                 Return TypeCode.Double
             Case BuiltInDataTypes.Integer
                 Return TypeCode.Int32
             Case BuiltInDataTypes.Long
                 Return TypeCode.Int64
             Case BuiltInDataTypes.Object
                 Return TypeCode.Object
             Case BuiltInDataTypes.SByte
                 Return TypeCode.SByte
             Case BuiltInDataTypes.Short
                 Return TypeCode.Int16
             Case BuiltInDataTypes.Single
                 Return TypeCode.Single
             Case BuiltInDataTypes.String
                 Return TypeCode.String
             Case BuiltInDataTypes.UInteger
                 Return TypeCode.UInt32
             Case BuiltInDataTypes.ULong
                 Return TypeCode.UInt64
             Case BuiltInDataTypes.UShort
                 Return TypeCode.UInt16
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="60" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="324" endline="351">
<![CDATA[
 
 		internal bool MatchParameterTypes(Type[] types)
 		{
 			if (types == parameterTypes)
 			{
 				return true;
 			}
 			if (types == null)
 			{
 				return parameterTypes.Length == 0;
 			}
 			if (parameterTypes == null)
 			{
 				return types.Length == 0;
 			}
 			if (types.Length == parameterTypes.Length)
 			{
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="125" endline="153">
<![CDATA[
 
 		// note that an empty array matches a null reference
 		internal static bool ArrayEquals(Type[] t1, Type[] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="154" endline="181">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][] t1, Type[][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="182" endline="209">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][][] t1, Type[][][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="61" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="144" endline="170">
<![CDATA[
 
 		internal void Write (BinaryWriter bw, int major_version, int minor_version)
 		{
 			bw.Write (TotalFileSize);
 			bw.Write (DataSectionOffset);
 			bw.Write (DataSectionSize);
 			bw.Write (CompileUnitCount);
 			bw.Write (CompileUnitTableOffset);
 			bw.Write (CompileUnitTableSize);
 			bw.Write (SourceCount);
 			bw.Write (SourceTableOffset);
 			bw.Write (SourceTableSize);
 			bw.Write (MethodCount);
 			bw.Write (MethodTableOffset);
 			bw.Write (MethodTableSize);
 			bw.Write (TypeCount);
 
 			bw.Write (AnonymousScopeCount);
 			bw.Write (AnonymousScopeTableOffset);
 			bw.Write (AnonymousScopeTableSize);
 
 			bw.Write (LineNumberTable_LineBase);
 			bw.Write (LineNumberTable_LineRange);
 			bw.Write (LineNumberTable_OpcodeBase);
 
 			bw.Write ((int) FileFlags);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\CliHeader.cs" startline="71" endline="90">
<![CDATA[
 
 		internal void Write(IKVM.Reflection.Writer.MetadataWriter mw)
 		{
 			mw.Write(Cb);
 			mw.Write(MajorRuntimeVersion);
 			mw.Write(MinorRuntimeVersion);
 			mw.Write(MetaDataRVA);
 			mw.Write(MetaDataSize);
 			mw.Write(Flags);
 			mw.Write(EntryPointToken);
 			mw.Write(ResourcesRVA);
 			mw.Write(ResourcesSize);
 			mw.Write(StrongNameSignatureRVA);
 			mw.Write(StrongNameSignatureSize);
 			mw.Write(CodeManagerTable);
 			mw.Write(VTableFixupsRVA);
 			mw.Write(VTableFixupsSize);
 			mw.Write(ExportAddressTableJumps);
 			mw.Write(ManagedNativeHeader);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="100" endline="115">
<![CDATA[
 
 		internal void WriteSectionHeader(SectionHeader sectionHeader)
 		{
 			byte[] name = new byte[8];
 			System.Text.Encoding.UTF8.GetBytes(sectionHeader.Name, 0, sectionHeader.Name.Length, name, 0);
 			bw.Write(name);
 			bw.Write(sectionHeader.VirtualSize);
 			bw.Write(sectionHeader.VirtualAddress);
 			bw.Write(sectionHeader.SizeOfRawData);
 			bw.Write(sectionHeader.PointerToRawData);
 			bw.Write(sectionHeader.PointerToRelocations);
 			bw.Write(sectionHeader.PointerToLinenumbers);
 			bw.Write(sectionHeader.NumberOfRelocations);
 			bw.Write(sectionHeader.NumberOfLinenumbers);
 			bw.Write(sectionHeader.Characteristics);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="83" endline="99">
<![CDATA[
 
 		internal void WritePEHeaders()
 		{
 			bw.Write(hdr.Signature);
 
 			// IMAGE_FILE_HEADER
 			bw.Write(hdr.FileHeader.Machine);
 			bw.Write(hdr.FileHeader.NumberOfSections);
 			bw.Write(hdr.FileHeader.TimeDateStamp);
 			bw.Write(hdr.FileHeader.PointerToSymbolTable);
 			bw.Write(hdr.FileHeader.NumberOfSymbols);
 			bw.Write(hdr.FileHeader.SizeOfOptionalHeader);
 			bw.Write(hdr.FileHeader.Characteristics);
 
 			// IMAGE_OPTIONAL_HEADER
 			hdr.OptionalHeader.Write(bw);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="62" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1226" endline="1249">
<![CDATA[
 
 		public LocalVariableEntry[] GetLocals ()
 		{
 			lock (SymbolFile) {
 				if (locals != null)
 					return locals;
 
 				if (LocalVariableTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = LocalVariableTableOffset;
 
 				int num_locals = reader.ReadLeb128 ();
 				locals = new LocalVariableEntry [num_locals];
 
 				for (int i = 0; i < num_locals; i++)
 					locals [i] = new LocalVariableEntry (SymbolFile, reader);
 				for (int i = 0; i < num_locals; i++)
 					locals [i] = new LocalVariableEntry (SymbolFile, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return locals;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1250" endline="1273">
<![CDATA[
 
 		public CodeBlockEntry[] GetCodeBlocks ()
 		{
 			lock (SymbolFile) {
 				if (code_blocks != null)
 					return code_blocks;
 
 				if (CodeBlockTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = CodeBlockTableOffset;
 
 				int num_code_blocks = reader.ReadLeb128 ();
 				code_blocks = new CodeBlockEntry [num_code_blocks];
 
 				for (int i = 0; i < num_code_blocks; i++)
 					code_blocks [i] = new CodeBlockEntry (i, reader);
 				for (int i = 0; i < num_code_blocks; i++)
 					code_blocks [i] = new CodeBlockEntry (i, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return code_blocks;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1274" endline="1297">
<![CDATA[
 
 		public ScopeVariable[] GetScopeVariables ()
 		{
 			lock (SymbolFile) {
 				if (scope_vars != null)
 					return scope_vars;
 
 				if (ScopeVariableTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = ScopeVariableTableOffset;
 
 				int num_scope_vars = reader.ReadLeb128 ();
 				scope_vars = new ScopeVariable [num_scope_vars];
 
 				for (int i = 0; i < num_scope_vars; i++)
 					scope_vars [i] = new ScopeVariable (reader);
 				for (int i = 0; i < num_scope_vars; i++)
 					scope_vars [i] = new ScopeVariable (reader);
 
 				reader.BaseStream.Position = old_pos;
 				return scope_vars;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1206" endline="1225">
<![CDATA[
 
 		public LineNumberTable GetLineNumberTable ()
 		{
 			lock (SymbolFile) {
 				if (lnt != null)
 					return lnt;
 
 				if (LineNumberTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = LineNumberTableOffset;
 
 				lnt = LineNumberTable.Read (SymbolFile, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return lnt;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1298" endline="1311">
<![CDATA[
 
 		public string GetRealName ()
 		{
 			lock (SymbolFile) {
 				if (real_name != null)
 					return real_name;
 
 				if (RealNameOffset == 0)
 					return null;
 
 				real_name = SymbolFile.BinaryReader.ReadString (RealNameOffset);
 				return real_name;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="63" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1990" endline="2009">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1970" endline="1989">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="64" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="675" endline="697">
<![CDATA[
 
 		public AnonymousScopeEntry GetAnonymousScope (int id)
 		{
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope;
 			lock (this) {
 				if (anonymous_scopes != null) {
 					anonymous_scopes.TryGetValue (id, out scope);
 					return scope;
 				}
 
 				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry> ();
 				reader.BaseStream.Position = ot.AnonymousScopeTableOffset;
 				for (int i = 0; i < ot.AnonymousScopeCount; i++) {
 					scope = new AnonymousScopeEntry (reader);
 					anonymous_scopes.Add (scope.ID, scope);
 				}
 				for (int i = 0; i < ot.AnonymousScopeCount; i++) {
 					scope = new AnonymousScopeEntry (reader);
 					anonymous_scopes.Add (scope.ID, scope);
 				}
 
 				return anonymous_scopes [id];
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="590" endline="612">
<![CDATA[
 		}
 
 		void read_methods ()
 		{
 			lock (this) {
 				if (method_token_hash != null)
 					return;
 
 				method_token_hash = new Dictionary<int, MethodEntry> ();
 				method_list = new List<MethodEntry> ();
 
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = ot.MethodTableOffset;
 
 				for (int i = 0; i < MethodCount; i++) {
 					MethodEntry entry = new MethodEntry (this, reader, i + 1);
 					method_token_hash.Add (entry.Token, entry);
 					method_list.Add (entry);
 				}
 				for (int i = 0; i < MethodCount; i++) {
 					MethodEntry entry = new MethodEntry (this, reader, i + 1);
 					method_token_hash.Add (entry.Token, entry);
 					method_list.Add (entry);
 				}
 
 				reader.BaseStream.Position = old_pos;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="652" endline="674">
<![CDATA[
 		}
 
 		public int FindSource (string file_name)
 		{
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				if (source_name_hash == null) {
 					source_name_hash = new Dictionary<string, int> ();
 
 					for (int i = 0; i < ot.SourceCount; i++) {
 						SourceFileEntry source = GetSourceFile (i + 1);
 						source_name_hash.Add (source.FileName, i);
 					}
 					for (int i = 0; i < ot.SourceCount; i++) {
 						SourceFileEntry source = GetSourceFile (i + 1);
 						source_name_hash.Add (source.FileName, i);
 					}
 				}
 
 				int value;
 				if (!source_name_hash.TryGetValue (file_name, out value))
 					return -1;
 				return value;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="65" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="812" endline="836">
<![CDATA[
 		}
 
 		/// <summary>
 		///   Records a new namespace for resolving name references
 		/// </summary>
 		public void AddUsing (MemberName name, Location loc)
 		{
 			if (DeclarationFound){
 				Compiler.Report.Error (1529, loc, "A using clause must precede all other namespace elements except extern alias declarations");
 			}
 
 			if (using_clauses == null) {
 				using_clauses = new List<UsingEntry> ();
 			} else {
 				foreach (UsingEntry old_entry in using_clauses) {
 					if (name.Equals (old_entry.MemberName)) {
 						Compiler.Report.SymbolRelatedToPreviousError (old_entry.Location, old_entry.GetSignatureForError ());
 						Compiler.Report.Warning (105, 3, loc, "The using directive for `{0}' appeared previously in this namespace", name.GetSignatureForError ());
 						return;
 					}
 				}
 				foreach (UsingEntry old_entry in using_clauses) {
 					if (name.Equals (old_entry.MemberName)) {
 						Compiler.Report.SymbolRelatedToPreviousError (old_entry.Location, old_entry.GetSignatureForError ());
 						Compiler.Report.Warning (105, 3, loc, "The using directive for `{0}' appeared previously in this namespace", name.GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			using_clauses.Add (new UsingEntry (name));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="875" endline="892">
<![CDATA[
 
 		void AddUsingAlias (UsingAliasEntry uae)
 		{
 			if (using_aliases == null) {
 				using_aliases = new List<UsingAliasEntry> ();
 			} else {
 				foreach (UsingAliasEntry entry in using_aliases) {
 					if (uae.Alias == entry.Alias) {
 						Compiler.Report.SymbolRelatedToPreviousError (uae.Location, uae.Alias);
 						Compiler.Report.Error (1537, entry.Location, "The using alias `{0}' appeared previously in this namespace",
 							entry.Alias);
 						return;
 					}
 				}
 				foreach (UsingAliasEntry entry in using_aliases) {
 					if (uae.Alias == entry.Alias) {
 						Compiler.Report.SymbolRelatedToPreviousError (uae.Location, uae.Alias);
 						Compiler.Report.Error (1537, entry.Location, "The using alias `{0}' appeared previously in this namespace",
 							entry.Alias);
 						return;
 					}
 				}
 			}
 
 			using_aliases.Add (uae);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="66" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="422" endline="450">
<![CDATA[
 
 		public MethodSpec Mutate (TypeParameterMutator mutator)
 		{
 			var targs = TypeArguments;
 			if (targs != null)
 				targs = mutator.Mutate (targs);
 
 			var decl = DeclaringType;
 			if (DeclaringType.IsGenericOrParentIsGeneric) {
 				decl = mutator.Mutate (decl);
 			}
 
 			if (targs == TypeArguments && decl == DeclaringType)
 				return this;
 
 			var ms = (MethodSpec) MemberwiseClone ();
 			if (decl != DeclaringType) {
 				ms.inflatedMetaInfo = null;
 				ms.declaringType = decl;
 				ms.state |= StateFlags.PendingMetaInflate;
 			}
 
 			if (targs != null) {
 				ms.targs = targs;
 				ms.state |= StateFlags.PendingMakeMethod;
 			}
 
 			return ms;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1619" endline="1648">
<![CDATA[
 
 		public override TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			var targs = TypeArguments;
 			if (targs != null)
 				targs = mutator.Mutate (targs);
 
 			var decl = DeclaringType;
 			if (IsNested && DeclaringType.IsGenericOrParentIsGeneric)
 				decl = mutator.Mutate (decl);
 
 			if (targs == TypeArguments && decl == DeclaringType)
 				return this;
 
 			var mutated = (InflatedTypeSpec) MemberwiseClone ();
 			if (decl != DeclaringType) {
 				// Gets back MethodInfo in case of metaInfo was inflated
 				//mutated.info = MemberCache.GetMember<TypeSpec> (DeclaringType.GetDefinition (), this).info;
 
 				mutated.declaringType = decl;
 				mutated.state |= StateFlags.PendingMetaInflate;
 			}
 
 			if (targs != null) {
 				mutated.targs = targs;
 				mutated.info = null;
 			}
 
 			return mutated;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="67" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="941" endline="979">
<![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As Expression()) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Length}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Length - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="980" endline="1018">
<![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Count}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Count - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="68" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="40" endline="66">
<![CDATA[
 
     ''' <summary>
     ''' Looks up all the modules imported by all the imports clauses.
     ''' </summary>
     ''' <param name="FromWhere"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetModules(ByVal FromWhere As BaseObject) As TypeList
         Dim result As TypeList = Nothing
         For Each imp As ImportsClause In Me
             If imp.IsNamespaceClause Then
                 Dim ns As ImportsNamespaceClause = imp.AsNamespaceClause
                 If ns.IsTypeImport Then
                     'A type cannot contain a module, nothing to do here.
                 ElseIf ns.IsNamespaceImport Then
                     Dim modules As TypeDictionary = FromWhere.Compiler.TypeManager.GetModulesByNamespace(ns.NamespaceImported.ToString)
                     If modules IsNot Nothing AndAlso modules.Count > 0 Then
                         If result Is Nothing Then result = New TypeList
                         result.AddRange(modules.TypesAsArray)
                     End If
                 Else
                     Continue For 'This import was not resolved correctly, don't use it.
                 End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="71" endline="97">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if a clause with the same imported namespace or alias exists.
     ''' </summary>
     ''' <param name="Clause"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Exists(ByVal Clause As ImportsClause) As Boolean
         For Each cl As ImportsClause In Me
             If cl.IsNamespaceClause Then
                 If Clause.IsNamespaceClause Then
                     If Helper.CompareName(cl.AsNamespaceClause.Name, Clause.AsNamespaceClause.Name) Then
                         Return True
                     End If
                 End If
             ElseIf cl.IsAliasClause Then
                 If Clause.IsAliasClause Then
                     If Helper.CompareName(cl.AsAliasClause.Name, Clause.AsAliasClause.Name) Then
                         Return True
                     End If
                 End If
             Else
                 Throw New InternalException(Me)
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="69" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="106" endline="116">
<![CDATA[
 		public int LineNumberTable_LineBase = LineNumberTable.Default_LineBase;
 		public int LineNumberTable_LineRange = LineNumberTable.Default_LineRange;
 		public int LineNumberTable_OpcodeBase = LineNumberTable.Default_OpcodeBase;
 		#endregion
 
 		internal OffsetTable ()
 		{
 			int platform = (int) Environment.OSVersion.Platform;
 			if ((platform != 4) && (platform != 128))
 				FileFlags |= Flags.WindowsFileNames;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1033" endline="1069">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Flags
 		{
 			LocalNamesAmbiguous	= 1
 		}
 
 		public const int Size = 12;
 
 		internal MethodEntry (MonoSymbolFile file, MyBinaryReader reader, int index)
 		{
 			this.SymbolFile = file;
 			this.index = index;
 
 			Token = reader.ReadInt32 ();
 			DataOffset = reader.ReadInt32 ();
 			LineNumberTableOffset = reader.ReadInt32 ();
 
 			long old_pos = reader.BaseStream.Position;
 			reader.BaseStream.Position = DataOffset;
 
 			CompileUnitIndex = reader.ReadLeb128 ();
 			LocalVariableTableOffset = reader.ReadLeb128 ();
 			NamespaceID = reader.ReadLeb128 ();
 
 			CodeBlockTableOffset = reader.ReadLeb128 ();
 			ScopeVariableTableOffset = reader.ReadLeb128 ();
 
 			RealNameOffset = reader.ReadLeb128 ();
 
 			flags = (Flags) reader.ReadLeb128 ();
 
 			reader.BaseStream.Position = old_pos;
 
 			CompileUnit = file.GetCompileUnit (CompileUnitIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\CliHeader.cs" startline="53" endline="70">
<![CDATA[
 		{
 			Cb = br.ReadUInt32();
 			MajorRuntimeVersion = br.ReadUInt16();
 			MinorRuntimeVersion = br.ReadUInt16();
 			MetaDataRVA = br.ReadUInt32();
 			MetaDataSize = br.ReadUInt32();
 			Flags = br.ReadUInt32();
 			EntryPointToken = br.ReadUInt32();
 			ResourcesRVA = br.ReadUInt32();
 			ResourcesSize = br.ReadUInt32();
 			StrongNameSignatureRVA = br.ReadUInt32();
 			StrongNameSignatureSize = br.ReadUInt32();
 			CodeManagerTable = br.ReadUInt32();
 			VTableFixupsRVA = br.ReadUInt32();
 			VTableFixupsSize = br.ReadUInt32();
 			ExportAddressTableJumps = br.ReadUInt32();
 			ManagedNativeHeader = br.ReadUInt32();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="70" nfragments="143" Csharpe_files="84" vb_files="59" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="581" endline="597">
<![CDATA[
 
 		internal void WriteData (MyBinaryWriter bw)
 		{
 			DataOffset = (int) bw.BaseStream.Position;
 			bw.WriteLeb128 (source.Index);
 
 			int count_includes = include_files != null ? include_files.Count 
 			bw.WriteLeb128 (count_includes);
 			if (include_files != null) {
 				foreach (SourceFileEntry entry in include_files)
 					bw.WriteLeb128 (entry.Index);
 				foreach (SourceFileEntry entry in include_files)
 					bw.WriteLeb128 (entry.Index);
 			}
 
 			bw.WriteLeb128 (namespaces.Count);
 			foreach (NamespaceEntry ns in namespaces)
 				ns.Write (file, bw);
 			foreach (NamespaceEntry ns in namespaces)
 				ns.Write (file, bw);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="496" endline="509">
<![CDATA[
 		}
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			bw.WriteLeb128 (ID);
 
 			bw.WriteLeb128 (captured_vars.Count);
 			foreach (CapturedVariable cv in captured_vars)
 				cv.Write (bw);
 			foreach (CapturedVariable cv in captured_vars)
 				cv.Write (bw);
 
 			bw.WriteLeb128 (captured_scopes.Count);
 			foreach (CapturedScope cs in captured_scopes)
 				cs.Write (bw);
 			foreach (CapturedScope cs in captured_scopes)
 				cs.Write (bw);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1157" endline="1173">
<![CDATA[
 
 		/// <summary>
 		///   Used to validate that all the using clauses are correct
 		///   after we are finished parsing all the files.  
 		/// </summary>
 		void VerifyUsing ()
 		{
 			if (using_aliases != null) {
 				foreach (UsingAliasEntry ue in using_aliases)
 					ue.Resolve (Doppelganger, Doppelganger == null);
 				foreach (UsingAliasEntry ue in using_aliases)
 					ue.Resolve (Doppelganger, Doppelganger == null);
 			}
 
 			if (using_clauses != null) {
 				foreach (UsingEntry ue in using_clauses)
 					ue.Resolve (Doppelganger);
 				foreach (UsingEntry ue in using_clauses)
 					ue.Resolve (Doppelganger);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="282" endline="294">
<![CDATA[
 
 		public override void CloseType ()
 		{
 			HackCorlibEnums ();
 
 			foreach (TypeContainer tc in types) {
 				tc.CloseType ();
 			}
 			foreach (TypeContainer tc in types) {
 				tc.CloseType ();
 			}
 
 			if (compiler_generated != null)
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1365" endline="1384">
<![CDATA[
 
 		public bool ResolveTypeParameters ()
 		{
 			if (!DoResolveTypeParameters ())
 				return false;
 
 			if (types != null) {
 				foreach (var type in types)
 					if (!type.ResolveTypeParameters ())
 						return false;
 				foreach (var type in types)
 					if (!type.ResolveTypeParameters ())
 						return false;
 			}
 
 			if (compiler_generated != null) {
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					if (!c.ResolveTypeParameters ())
 						return false;
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					if (!c.ResolveTypeParameters ())
 						return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="909" endline="920">
<![CDATA[
 
 		internal void ResolveMethodAndFieldTokens(ref int methodToken, ref int fieldToken, ref int parameterToken)
 		{
 			foreach (MethodBuilder method in methods)
 			{
 				method.FixupToken(methodToken++, ref parameterToken);
 			}
 			foreach (MethodBuilder method in methods)
 			{
 				method.FixupToken(methodToken++, ref parameterToken);
 			}
 			foreach (FieldBuilder field in fields)
 			{
 				field.FixupToken(fieldToken++);
 			}
 			foreach (FieldBuilder field in fields)
 			{
 				field.FixupToken(fieldToken++);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="760" endline="775">
<![CDATA[
 
 		internal void RenameAssembly(Assembly assembly, AssemblyName oldName)
 		{
 			List<string> remove = new List<string>();
 			foreach (KeyValuePair<string, Assembly> kv in assembliesByName)
 			{
 				if (kv.Value == assembly)
 				{
 					remove.Add(kv.Key);
 				}
 			}
 			foreach (KeyValuePair<string, Assembly> kv in assembliesByName)
 			{
 				if (kv.Value == assembly)
 				{
 					remove.Add(kv.Key);
 				}
 			}
 			foreach (string key in remove)
 			{
 				assembliesByName.Remove(key);
 			}
 			foreach (string key in remove)
 			{
 				assembliesByName.Remove(key);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="477" endline="490">
<![CDATA[
 
 		public override Type[] GetTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (ModuleBuilder module in modules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (Module module in addedModules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (Module module in addedModules)
 			{
 				module.GetTypesImpl(list);
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4901" endline="4917">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (!inside_try_finally)
 				ec.BeginExceptionBlock ();
 
 			Block.Emit (ec);
 
 			foreach (Catch c in Specific)
 				c.Emit (ec);
 			foreach (Catch c in Specific)
 				c.Emit (ec);
 
 			if (General != null)
 				General.Emit (ec);
 
 			if (!inside_try_finally)
 				ec.EndExceptionBlock ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1240" endline="1263">
<![CDATA[
 
 		public override AssemblyName[] __GetReferencedAssemblies()
 		{
 			List<AssemblyName> list = new List<AssemblyName>();
 			if (referencedAssemblyNames != null)
 			{
 				foreach (AssemblyName name in referencedAssemblyNames)
 				{
 					if (!list.Contains(name))
 					{
 						list.Add(name);
 					}
 				}
 				foreach (AssemblyName name in referencedAssemblyNames)
 				{
 					if (!list.Contains(name))
 					{
 						list.Add(name);
 					}
 				}
 			}
 			foreach (Assembly asm in referencedAssemblies.Keys)
 			{
 				AssemblyName name = asm.GetName();
 				if (!list.Contains(name))
 				{
 					list.Add(name);
 				}
 			}
 			foreach (Assembly asm in referencedAssemblies.Keys)
 			{
 				AssemblyName name = asm.GetName();
 				if (!list.Contains(name))
 				{
 					list.Add(name);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="491" endline="511">
<![CDATA[
 
 		internal override Type GetTypeImpl(string typeName)
 		{
 			foreach (ModuleBuilder mb in modules)
 			{
 				Type type = mb.GetTypeImpl(typeName);
 				if (type != null)
 				{
 					return type;
 				}
 			}
 			foreach (ModuleBuilder mb in modules)
 			{
 				Type type = mb.GetTypeImpl(typeName);
 				if (type != null)
 				{
 					return type;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				Type type = module.GetTypeImpl(typeName);
 				if (type != null)
 				{
 					return type;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				Type type = module.GetTypeImpl(typeName);
 				if (type != null)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="570" endline="588">
<![CDATA[
 
 		public override Module GetModule(string name)
 		{
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="710" endline="730">
<![CDATA[
 
 		//
 		// Populates the Namespace with some using declarations, used by the
 		// eval mode. 
 		//
 		public void Populate (List<UsingAliasEntry> source_using_aliases, List<UsingEntry> source_using_clauses)
 		{
 			foreach (UsingAliasEntry uae in source_using_aliases){
 				if (using_aliases == null)
 					using_aliases = new List<UsingAliasEntry> ();
 				
 				using_aliases.Add (uae);
 			}
 			foreach (UsingAliasEntry uae in source_using_aliases){
 				if (using_aliases == null)
 					using_aliases = new List<UsingAliasEntry> ();
 				
 				using_aliases.Add (uae);
 			}
 
 			foreach (UsingEntry ue in source_using_clauses){
 				if (using_clauses == null)
 					using_clauses = new List<UsingEntry> ();
 				
 				using_clauses.Add (ue);
 			}
 			foreach (UsingEntry ue in source_using_clauses){
 				if (using_clauses == null)
 					using_clauses = new List<UsingEntry> ();
 				
 				using_clauses.Add (ue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="749" endline="765">
<![CDATA[
 
 		internal void FixupMethodBodyTokens()
 		{
 			int methodToken = 0x06000001;
 			int fieldToken = 0x04000001;
 			int parameterToken = 0x08000001;
 			foreach (TypeBuilder type in types)
 			{
 				type.ResolveMethodAndFieldTokens(ref methodToken, ref fieldToken, ref parameterToken);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.ResolveMethodAndFieldTokens(ref methodToken, ref fieldToken, ref parameterToken);
 			}
 			foreach (int offset in tokenFixupOffsets)
 			{
 				methodBodies.Position = offset;
 				int pseudoToken = methodBodies.GetInt32AtCurrentPosition();
 				methodBodies.Write(ResolvePseudoToken(pseudoToken));
 			}
 			foreach (int offset in tokenFixupOffsets)
 			{
 				methodBodies.Position = offset;
 				int pseudoToken = methodBodies.GetInt32AtCurrentPosition();
 				methodBodies.Write(ResolvePseudoToken(pseudoToken));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="550" endline="569">
<![CDATA[
 
 		public override Module[] GetModules(bool getResourceModules)
 		{
 			List<Module> list = new List<Module>();
 			foreach (ModuleBuilder module in modules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1308" endline="1325">
<![CDATA[
 
 		/// <summary>
 		/// Returns all attributes of type 't'. Use it when attribute is AllowMultiple = true
 		/// </summary>
 		public Attribute[] SearchMulti (PredefinedAttribute t)
 		{
 			List<Attribute> ar = null;
 
 			foreach (Attribute a in Attrs) {
 				if (a.ResolveType () == t) {
 					if (ar == null)
 						ar = new List<Attribute> (Attrs.Count);
 					ar.Add (a);
 				}
 			}
 			foreach (Attribute a in Attrs) {
 				if (a.ResolveType () == t) {
 					if (ar == null)
 						ar = new List<Attribute> (Attrs.Count);
 					ar.Add (a);
 				}
 			}
 
 			return ar == null ? null 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="143" endline="157">
<![CDATA[
 
 		public override MethodInfo[] GetAccessors(bool nonPublic)
 		{
 			List<MethodInfo> list = new List<MethodInfo>();
 			AddAccessor(list, nonPublic, getter);
 			AddAccessor(list, nonPublic, setter);
 			if (otherMethods != null)
 			{
 				foreach (MethodInfo method in otherMethods)
 				{
 					AddAccessor(list, nonPublic, method);
 				}
 				foreach (MethodInfo method in otherMethods)
 				{
 					AddAccessor(list, nonPublic, method);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="521" endline="542">
<![CDATA[
 
     ''' <summary>
     ''' Returns all the members in the types with the specified name.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetMembersOfTypes(ByVal Compiler As Compiler, ByVal Types As TypeDictionary, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
 
         If Types Is Nothing Then Return Nothing
 
         For Each type As Mono.Cecil.TypeReference In Types.Values
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             members = Compiler.TypeManager.GetCache(type).LookupFlattenedMembers(Name)
             If members IsNot Nothing Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                 result.AddRange(members)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3593" endline="3604">
<![CDATA[
 
 		SwitchSection FindSection (SwitchLabel label)
 		{
 			foreach (SwitchSection ss in Sections){
 				foreach (SwitchLabel sl in ss.Labels){
 					if (label == sl)
 						return ss;
 				}
 				foreach (SwitchLabel sl in ss.Labels){
 					if (label == sl)
 						return ss;
 				}
 			}
 			foreach (SwitchSection ss in Sections){
 				foreach (SwitchLabel sl in ss.Labels){
 					if (label == sl)
 						return ss;
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="53" endline="72">
<![CDATA[
 
     ''' <summary>
     ''' Might return nothing
     ''' </summary>
     ''' <param name="AttributeType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindAttributes(ByVal AttributeType As Mono.Cecil.TypeReference) As Generic.List(Of Attribute)
         Dim result As Generic.List(Of Attribute) = Nothing
 
         If AttributeType Is Nothing Then Return Nothing
 
         For Each att As Attribute In Me
             If Helper.CompareType(att.AttributeType, AttributeType) Then
                 If result Is Nothing Then result = New Generic.List(Of Attribute)
                 result.Add(att)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="117" endline="132">
<![CDATA[
 
 		public override MethodInfo[] GetOtherMethods(bool nonPublic)
 		{
 			List<MethodInfo> list = new List<MethodInfo>();
 			if (otherMethods != null)
 			{
 				foreach (MethodInfo method in otherMethods)
 				{
 					if (nonPublic || method.IsPublic)
 					{
 						list.Add(method);
 					}
 				}
 				foreach (MethodInfo method in otherMethods)
 				{
 					if (nonPublic || method.IsPublic)
 					{
 						list.Add(method);
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="610" endline="623">
<![CDATA[
 		}
 
 		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
 		{
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				if (attributeType == null || attributeType.IsAssignableFrom(cab.Constructor.DeclaringType))
 				{
 					list.Add(cab.ToData(this));
 				}
 			}
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				if (attributeType == null || attributeType.IsAssignableFrom(cab.Constructor.DeclaringType))
 				{
 					list.Add(cab.ToData(this));
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2318" endline="2337">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if (default_static_constructor == null && PartialContainer.HasStaticFieldInitializer) {
 				DefineDefaultConstructor (true);
 				default_static_constructor.Define ();
 			}
 
 			base.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					TypeBuilder.__AddDeclarativeSecurity (de);
 #else
 					TypeBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					TypeBuilder.__AddDeclarativeSecurity (de);
 #else
 					TypeBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1450" endline="1468">
<![CDATA[
 
 		/// <summary>
 		///   Populates our TypeBuilder with fields and methods
 		/// </summary>
 		public sealed override bool Define ()
 		{
 			if (members_defined)
 				return members_defined_ok;
 
 			members_defined_ok = DoDefineMembers ();
 			members_defined = true;
 
 			if (types != null) {
 				foreach (var nested in types)
 					nested.Define ();
 				foreach (var nested in types)
 					nested.Define ();
 			}
 
 			return members_defined_ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="122" endline="136">
<![CDATA[
 		}
 
 		public override void DefineSymbolInfo (MonoSymbolWriter symwriter)
 		{
 			base.DefineSymbolInfo (symwriter);
 
 			comp_unit = symwriter.DefineCompilationUnit (SourceFileEntry);
 
 			if (include_files != null) {
 				foreach (SourceFile include in include_files.Values) {
 					include.DefineSymbolInfo (symwriter);
 					comp_unit.AddFile (include.SourceFileEntry);
 				}
 				foreach (SourceFile include in include_files.Values) {
 					include.DefineSymbolInfo (symwriter);
 					comp_unit.AddFile (include.SourceFileEntry);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="647" endline="658">
<![CDATA[
 
 		internal void FixupToken(int token, ref int parameterToken)
 		{
 			typeBuilder.ModuleBuilder.RegisterTokenFixup(this.pseudoToken, token);
 			if (parameters != null)
 			{
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="543" endline="564">
<![CDATA[
 
     ''' <summary>
     ''' Returns all the members in the types with the specified name.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetMembersOfTypes(ByVal Compiler As Compiler, ByVal Types As TypeList, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
 
         If Types Is Nothing Then Return Nothing
 
         For Each type As Mono.Cecil.TypeReference In Types
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             members = Compiler.TypeManager.GetCache(type).LookupFlattenedMembers(Name)
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                 result.AddRange(members)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="227" endline="239">
<![CDATA[
 
     Protected Overloads Function [GetType](ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String) As Mono.Cecil.TypeDefinition
         If Type Is Nothing Then Return Nothing
         Dim result As Mono.Cecil.TypeDefinition = Nothing
         For Each item As Mono.Cecil.TypeDefinition In Type.NestedTypes
             If Helper.CompareNameOrdinal(item.Name, Name) Then
                 result = item
                 Exit For
             End If
         Next
         If result Is Nothing Then Compiler.Report.WriteLine(String.Format("Could not load the nested type '{0}' from the type '{1}'", Name, Type.FullName))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="242" endline="256">
<![CDATA[
     End Property
 
     Function FindLabel(ByVal Name As Token) As LabelDeclarationStatement
         Dim cb As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         If cb IsNot Nothing Then
             Return cb.FindLabel(Name)
         Else
             For Each l As LabelDeclarationStatement In m_Labels
                 If l.Label.Equals(Name) Then
                     Return l
                 End If
             Next
         End If
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="100" endline="110">
<![CDATA[
         Get
             If m_BlockStatements Is Nothing Then
                 m_BlockStatements = New Generic.List(Of BlockStatement)
                 For Each stmt As Statement In m_Statements
                     Dim blockStmt As BlockStatement
                     blockStmt = TryCast(stmt, BlockStatement)
                     If blockStmt IsNot Nothing Then m_BlockStatements.Add(blockStmt)
                 Next
             End If
             Return m_BlockStatements
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="929" endline="941">
<![CDATA[
 
 		public bool HasField (string fieldName)
 		{
 			if (named_values == null)
 				return false;
 
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="488" endline="503">
<![CDATA[
 
 		//
 		// Returns a field which holds referenced storey instance
 		//
 		Field GetReferencedStoreyField (AnonymousMethodStorey storey)
 		{
 			if (used_parent_storeys == null)
 				return null;
 
 			foreach (StoreyFieldPair sf in used_parent_storeys) {
 				if (sf.Storey == storey)
 					return sf.Field;
 			}
 			foreach (StoreyFieldPair sf in used_parent_storeys) {
 				if (sf.Storey == storey)
 					return sf.Field;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="166" endline="185">
<![CDATA[
 		}
 
 		private int DirectoryLength
 		{
 			get
 			{
 				if (Data != null)
 				{
 					return 16;
 				}
 				else
 				{
 					int length = 16 + entries.Count * 8;
 					foreach (ResourceDirectoryEntry entry in entries)
 					{
 						length += entry.DirectoryLength;
 					}
 					foreach (ResourceDirectoryEntry entry in entries)
 					{
 						length += entry.DirectoryLength;
 					}
 					return length;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="355" endline="366">
<![CDATA[
 
 		public void CheckArrayAsAttribute (CompilerContext ctx)
 		{
 			foreach (Argument arg in args) {
 				// Type is undefined (was error 246)
 				if (arg.Type == null)
 					continue;
 
 				if (arg.Type.IsArray)
 					ctx.Report.Warning (3016, 1, arg.Expr.Location, "Arrays as attribute arguments are not CLS-compliant");
 			}
 			foreach (Argument arg in args) {
 				// Type is undefined (was error 246)
 				if (arg.Type == null)
 					continue;
 
 				if (arg.Type.IsArray)
 					ctx.Report.Warning (3016, 1, arg.Expr.Location, "Arrays as attribute arguments are not CLS-compliant");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="590" endline="604">
<![CDATA[
 
 		private Assembly GetDynamicAssembly(string refname)
 		{
 			foreach (AssemblyBuilder asm in dynamicAssemblies)
 			{
 				AssemblyComparisonResult result;
 				// We won't allow FX unification here, because our own (non-Fusion) implementation of CompareAssemblyIdentity doesn't support it and
 				// we don't want to create a fundamental functional difference based on that.
 				if (CompareAssemblyIdentity(refname, false, asm.FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
 				{
 					return asm;
 				}
 			}
 			foreach (AssemblyBuilder asm in dynamicAssemblies)
 			{
 				AssemblyComparisonResult result;
 				// We won't allow FX unification here, because our own (non-Fusion) implementation of CompareAssemblyIdentity doesn't support it and
 				// we don't want to create a fundamental functional difference based on that.
 				if (CompareAssemblyIdentity(refname, false, asm.FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
 				{
 					return asm;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="621" endline="632">
<![CDATA[
 
 		private static bool FindMethod(List<MethodInfo> methods, MethodInfo method)
 		{
 			foreach (MethodInfo m in methods)
 			{
 				if (m.Name == method.Name && m.MethodSignature.Equals(method.MethodSignature))
 				{
 					return true;
 				}
 			}
 			foreach (MethodInfo m in methods)
 			{
 				if (m.Name == method.Name && m.MethodSignature.Equals(method.MethodSignature))
 				{
 					return true;
 				}
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="1189" endline="1200">
<![CDATA[
 
 		public bool IsWarningEnabled (int code, int src_line)
 		{
 			bool result = true;
 			foreach (PragmaCmd pragma in regions) {
 				if (src_line < pragma.Line)
 					break;
 
 				result = pragma.IsEnabled (code, result);
 			}
 			foreach (PragmaCmd pragma in regions) {
 				if (src_line < pragma.Line)
 					break;
 
 				result = pragma.IsEnabled (code, result);
 			}
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4918" endline="4931">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			TryCatch target = (TryCatch) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 			if (General != null)
 				target.General = (Catch) General.Clone (clonectx);
 			if (Specific != null){
 				target.Specific = new List<Catch> ();
 				foreach (Catch c in Specific)
 					target.Specific.Add ((Catch) c.Clone (clonectx));
 				foreach (Catch c in Specific)
 					target.Specific.Add ((Catch) c.Clone (clonectx));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="575" endline="589">
<![CDATA[
 
 		public override void LoadReferences (ModuleContainer module)
 		{
 			Assembly corlib;
 			List<Tuple<RootNamespace, Assembly>> loaded;
 			base.LoadReferencesCore (module, out corlib, out loaded);
 
 			if (corlib == null)
 				return;
 
 			importer.ImportAssembly (corlib, module.GlobalRootNamespace);
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="712" endline="721">
<![CDATA[
 
 		public void ResolveFieldInitializers (BlockContext ec)
 		{
 			if (partial_parts != null) {
 				foreach (TypeContainer part in partial_parts) {
 					part.DoResolveFieldInitializers (ec);
 				}
 				foreach (TypeContainer part in partial_parts) {
 					part.DoResolveFieldInitializers (ec);
 				}
 			}
 			DoResolveFieldInitializers (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="636" endline="646">
<![CDATA[
 
 		internal void WriteParamRecords(MetadataWriter mw)
 		{
 			if (parameters != null)
 			{
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.WriteParamRecord(mw);
 				}
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.WriteParamRecord(mw);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="150" endline="168">
<![CDATA[
 
     ''' <summary>
     ''' Searches the namespaces of the current compiling assembly / referenced assemblies to check
     ''' if the name is a namespace.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsNamespace(ByVal Name As String, ByVal onlyExact As Boolean) As Boolean
         Name = vbnc.Namespace.RemoveGlobal(Name)
         If ContainsKey(Name) Then
             Return True
         ElseIf onlyExact = False Then
             For Each strNS As [Namespace] In Me
                 If strNS.StartsWith(Name) Then Return True
             Next
         End If
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1296" endline="1307">
<![CDATA[
 
 		public Attribute Search (string explicitTarget, PredefinedAttribute t)
 		{
 			foreach (Attribute a in Attrs) {
 				if (explicitTarget != null && a.ExplicitTarget != explicitTarget)
 					continue;
 
 				if (a.ResolveType () == t)
 					return a;
 			}
 			foreach (Attribute a in Attrs) {
 				if (explicitTarget != null && a.ExplicitTarget != explicitTarget)
 					continue;
 
 				if (a.ResolveType () == t)
 					return a;
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="1217" endline="1229">
<![CDATA[
 
 		public void ExecuteUndo ()
 		{
 			if (undo_types == null)
 				return;
 
 			foreach (var p in undo_types){
 				TypeContainer current_container = p.Key;
 
 				current_container.RemoveTypeContainer (p.Value);
 			}
 			foreach (var p in undo_types){
 				TypeContainer current_container = p.Key;
 
 				current_container.RemoveTypeContainer (p.Value);
 			}
 			undo_types = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="956" endline="969">
<![CDATA[
 		}
 
 		// helper for ModuleBuilder.ResolveMethod()
 		internal MethodBase LookupMethod(int token)
 		{
 			foreach (MethodBuilder method in methods)
 			{
 				if (method.MetadataToken == token)
 				{
 					return method;
 				}
 			}
 			foreach (MethodBuilder method in methods)
 			{
 				if (method.MetadataToken == token)
 				{
 					return method;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="983" endline="1000">
<![CDATA[
 
 		public override Type[] __GetDeclaredTypes()
 		{
 			if (this.HasNestedTypes)
 			{
 				List<Type> types = new List<Type>();
 				List<int> classes = this.ModuleBuilder.NestedClass.GetNestedClasses(token);
 				foreach (int nestedClass in classes)
 				{
 					types.Add(this.ModuleBuilder.ResolveType(nestedClass));
 				}
 				foreach (int nestedClass in classes)
 				{
 					types.Add(this.ModuleBuilder.ResolveType(nestedClass));
 				}
 				return types.ToArray();
 			}
 			else
 			{
 				return Type.EmptyTypes;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9603" endline="9613">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			if (parameters == null)
 				return;
 
 			NewAnonymousType t = (NewAnonymousType) target;
 			t.parameters = new List<AnonymousTypeParameter> (parameters.Count);
 			foreach (AnonymousTypeParameter atp in parameters)
 				t.parameters.Add ((AnonymousTypeParameter) atp.Clone (clonectx));
 			foreach (AnonymousTypeParameter atp in parameters)
 				t.parameters.Add ((AnonymousTypeParameter) atp.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="304" endline="318">
<![CDATA[
 
 		public void VerifyClsCompliance (Report report)
 		{
 			foreach (var c in constraints)
 			{
 				if (c == null)
 					continue;
 
 				if (!c.Type.IsCLSCompliant ()) {
 					report.SymbolRelatedToPreviousError (c.Type);
 					report.Warning (3024, 1, loc, "Constraint type `{0}' is not CLS-compliant",
 						c.Type.GetSignatureForError ());
 				}
 			}
 			foreach (var c in constraints)
 			{
 				if (c == null)
 					continue;
 
 				if (!c.Type.IsCLSCompliant ()) {
 					report.SymbolRelatedToPreviousError (c.Type);
 					report.Warning (3024, 1, loc, "Constraint type `{0}' is not CLS-compliant",
 						c.Type.GetSignatureForError ());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="229" endline="244">
<![CDATA[
 
 		private void WriteData(ByteBuffer bb)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="574" endline="584">
<![CDATA[
 
 		void ReadModulesAssemblyAttributes ()
 		{
 			foreach (var m in added_modules) {
 				var cattrs = m.ReadAssemblyAttributes ();
 				if (cattrs == null)
 					continue;
 
 				module.OptAttributes.AddAttributes (cattrs);
 			}
 			foreach (var m in added_modules) {
 				var cattrs = m.ReadAssemblyAttributes ();
 				if (cattrs == null)
 					continue;
 
 				module.OptAttributes.AddAttributes (cattrs);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="432" endline="444">
<![CDATA[
 
 		//
 		// At least one argument is of dynamic type
 		//
 		public bool HasDynamic {
 			get {
 				foreach (Argument a in args) {
 					if (a.Type == InternalType.Dynamic && !a.IsByRef)
 						return true;
 				}
 				foreach (Argument a in args) {
 					if (a.Type == InternalType.Dynamic && !a.IsByRef)
 						return true;
 				}
 				
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="212" endline="223">
<![CDATA[
 
 		public ModuleBuilder GetDynamicModule(string name)
 		{
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name == name)
 				{
 					return module;
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name == name)
 				{
 					return module;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="445" endline="458">
<![CDATA[
 		}
 
 		//
 		// At least one argument is named argument
 		//
 		public bool HasNamed {
 			get {
 				foreach (Argument a in args) {
 					if (a is NamedArgument)
 						return true;
 				}
 				foreach (Argument a in args) {
 					if (a is NamedArgument)
 						return true;
 				}
 				
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1279" endline="1290">
<![CDATA[
 
 		/// <summary>
 		/// Checks whether attribute target is valid for the current element
 		/// </summary>
 		public bool CheckTargets ()
 		{
 			foreach (Attribute a in Attrs) {
 				if (!a.CheckTarget ())
 					return false;
 			}
 			foreach (Attribute a in Attrs) {
 				if (!a.CheckTarget ())
 					return false;
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="500" endline="512">
<![CDATA[
 
 		//
 		// Returns dynamic when at least one argument is of dynamic type
 		//
 		public void Resolve (ResolveContext ec, out bool dynamic)
 		{
 			dynamic = false;
 			foreach (Argument a in args) {
 				a.Resolve (ec);
 				if (a.Type == InternalType.Dynamic && !a.IsByRef)
 					dynamic = true;
 			}
 			foreach (Argument a in args) {
 				a.Resolve (ec);
 				if (a.Type == InternalType.Dynamic && !a.IsByRef)
 					dynamic = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="485" endline="491">
<![CDATA[
 
     Function IsIntegralType(ByVal Type As TypeCode) As Boolean
         For Each t As Mono.Cecil.TypeReference In IntegralTypes
             If Helper.GetTypeCode(Compiler, t) = Type Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="39" endline="52">
<![CDATA[
 
     Function IsDefined(ByVal AttributeType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = False
 
         For Each att As Attribute In Me
             If AttributeType Is Nothing Then Return False
             If Helper.CompareType(att.AttributeType, AttributeType) Then
                 result = True
                 Exit For
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="798" endline="807">
<![CDATA[
 
     Shared Function FilterByName(ByVal collection As Generic.List(Of Type), ByVal Name As String) As Generic.List(Of Type)
         Dim result As New Generic.List(Of Type)
         Dim tmpname As String = ""
         For Each obj As Type In collection
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="836" endline="849">
<![CDATA[
 
     ''' <summary>
     ''' Returns a list of type descriptors that only are modules.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterToModules(ByVal Compiler As Compiler, ByVal Types As TypeDictionary) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         For Each t As Mono.Cecil.TypeReference In Types.Values
             If IsModule(Compiler, t) Then result.Add(t)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="820" endline="827">
<![CDATA[
 
     Shared Function FilterByName(ByVal Types As TypeList, ByVal Name As String) As TypeList
         Dim result As New TypeList
         For Each obj As Mono.Cecil.TypeReference In Types
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeList.vb" startline="36" endline="44">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each attrib As Attribute In m_List
             result = attrib.ResolveCode(info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="441" endline="451">
<![CDATA[
 
 		internal override void GetTypesImpl(List<Type> list)
 		{
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3110" endline="3119">
<![CDATA[
 
 		public SwitchSection Clone (CloneContext clonectx)
 		{
 			var cloned_labels = new List<SwitchLabel> ();
 
 			foreach (SwitchLabel sl in Labels)
 				cloned_labels.Add (sl.Clone (clonectx));
 			foreach (SwitchLabel sl in Labels)
 				cloned_labels.Add (sl.Clone (clonectx));
 			
 			return new SwitchSection (cloned_labels, clonectx.LookupBlock (Block));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="207" endline="218">
<![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="219" endline="231">
<![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsTypeString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="367" endline="375">
<![CDATA[
 
 		public Arguments Clone (CloneContext ctx)
 		{
 			Arguments cloned = new Arguments (args.Count);
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="124" endline="132">
<![CDATA[
 
 		public void CheckGenericConstraints (IMemberContext context)
 		{
 			foreach (var c in constraints) {
 				var ge = c as GenericTypeExpr;
 				if (ge != null)
 					ge.CheckConstraints (context);
 			}
 			foreach (var c in constraints) {
 				var ge = c as GenericTypeExpr;
 				if (ge != null)
 					ge.CheckConstraints (context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1756" endline="1764">
<![CDATA[
 
 		public TypeArguments Clone ()
 		{
 			TypeArguments copy = new TypeArguments ();
 			foreach (var ta in args)
 				copy.args.Add (ta);
 			foreach (var ta in args)
 				copy.args.Add (ta);
 
 			return copy;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1394" endline="1410">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement target)
 		{
 			BlockVariableDeclaration t = (BlockVariableDeclaration) target;
 
 			if (type_expr != null)
 				t.type_expr = (FullNamedExpression) type_expr.Clone (clonectx);
 
 			if (initializer != null)
 				t.initializer = initializer.Clone (clonectx);
 
 			if (declarators != null) {
 				t.declarators = null;
 				foreach (var d in declarators)
 					t.AddDeclarator (new Declarator (d, d.Initializer == null ? null 
 				foreach (var d in declarators)
 					t.AddDeclarator (new Declarator (d, d.Initializer == null ? null 
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6623" endline="6639">
<![CDATA[
 		
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			ArrayCreation target = (ArrayCreation) t;
 
 			if (requested_base_type != null)
 				target.requested_base_type = (FullNamedExpression)requested_base_type.Clone (clonectx);
 
 			if (arguments != null){
 				target.arguments = new List<Expression> (arguments.Count);
 				foreach (Expression e in arguments)
 					target.arguments.Add (e.Clone (clonectx));
 				foreach (Expression e in arguments)
 					target.arguments.Add (e.Clone (clonectx));
 			}
 
 			if (initializers != null)
 				target.initializers = (ArrayInitializer) initializers.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="444" endline="458">
<![CDATA[
 
 		public override void LoadReferences (ModuleContainer module)
 		{
 			List<Tuple<RootNamespace, Assembly>> loaded;
 			base.LoadReferencesCore (module, out corlib, out loaded);
 
 			if (corlib != null) {
 				importer.InitializeBuildinTypes (compiler.BuildinTypes, corlib);
 				importer.ImportAssembly (corlib, module.GlobalRootNamespace);
 			}
 
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2075" endline="2086">
<![CDATA[
 
 		protected void EmitScopeInitializers (EmitContext ec)
 		{
 			SymbolWriter.OpenCompilerGeneratedBlock (ec);
 
 			using (ec.With (EmitContext.Options.OmitDebugInfo, true)) {
 				foreach (Statement s in scope_initializers)
 					s.Emit (ec);
 				foreach (Statement s in scope_initializers)
 					s.Emit (ec);
 			}
 
 			SymbolWriter.CloseCompilerGeneratedBlock (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="119" endline="129">
<![CDATA[
 		}
 
 		internal void Write(MetadataWriter mw, uint rva)
 		{
 			foreach (int offset in linkOffsets)
 			{
 				bb.Position = offset;
 				bb.Write(bb.GetInt32AtCurrentPosition() + (int)rva);
 			}
 			foreach (int offset in linkOffsets)
 			{
 				bb.Position = offset;
 				bb.Write(bb.GetInt32AtCurrentPosition() + (int)rva);
 			}
 			mw.Write(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3886" endline="3896">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Switch target = (Switch) t;
 
 			target.Expr = Expr.Clone (clonectx);
 			target.Sections = new List<SwitchSection> ();
 			foreach (SwitchSection ss in Sections){
 				target.Sections.Add (ss.Clone (clonectx));
 			}
 			foreach (SwitchSection ss in Sections){
 				target.Sections.Add (ss.Clone (clonectx));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="1109" endline="1118">
<![CDATA[
 
 		private void WriteCode(ByteBuffer bb)
 		{
 			int codeOffset = bb.Position;
 			foreach (int fixup in this.tokenFixups)
 			{
 				moduleBuilder.tokenFixupOffsets.Add(fixup + codeOffset);
 			}
 			foreach (int fixup in this.tokenFixups)
 			{
 				moduleBuilder.tokenFixupOffsets.Add(fixup + codeOffset);
 			}
 			bb.Write(code);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="668" endline="676">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement target)
 		{
 			StatementList t = (StatementList) target;
 
 			t.statements = new List<Statement> (statements.Count);
 			foreach (Statement s in statements)
 				t.statements.Add (s.Clone (clonectx));
 			foreach (Statement s in statements)
 				t.statements.Add (s.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9280" endline="9288">
<![CDATA[
 
 		public CollectionElementInitializer (List<Expression> arguments, Location loc)
 			
 		{
 			foreach (Expression e in arguments)
 				base.arguments.Add (new ElementInitializerArgument (e));
 			foreach (Expression e in arguments)
 				base.arguments.Add (new ElementInitializerArgument (e));
 
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5952" endline="5961">
<![CDATA[
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			var target = (ArrayInitializer) t;
 
 			target.elements = new List<Expression> (elements.Count);
 			foreach (var element in elements)
 				target.elements.Add (element.Clone (clonectx));
 			foreach (var element in elements)
 				target.elements.Add (element.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="126" endline="135">
<![CDATA[
 
 		internal void WriteTypeDefTable(MetadataWriter mw)
 		{
 			int fieldList = 1;
 			int methodList = 1;
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteTypeDefRecord(mw, ref fieldList, ref methodList);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteTypeDefRecord(mw, ref fieldList, ref methodList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="80" endline="88">
<![CDATA[
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For Each member As MemberDeclaration In m_Members
             member.Initialize(Me)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="136" endline="144">
<![CDATA[
 
 		internal void WriteMethodDefTable(int baseRVA, MetadataWriter mw)
 		{
 			int paramList = 1;
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteMethodDefRecords(baseRVA, mw, ref paramList);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteMethodDefRecords(baseRVA, mw, ref paramList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="446" endline="457">
<![CDATA[
 
 		void HackCorlibEnums ()
 		{
 			if (RootContext.StdLib)
 				return;
 
 			// Another Mono corlib HACK
 			// mono_class_layout_fields requires to have enums created
 			// before creating a class which used the enum for any of its fields
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="108" endline="114">
<![CDATA[
 
     Sub Write(Optional ByVal Value As String = "")
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.Write(Value)
         Next
         Console.Write(Value)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1270" endline="1278">
<![CDATA[
 
 		public Attributes Clone ()
 		{
 			var al = new List<Attribute> (Attrs.Count);
 			foreach (Attribute a in Attrs)
 				al.Add (a.Clone ());
 			foreach (Attribute a in Attrs)
 				al.Add (a.Clone ());
 
 			return new Attributes (al);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="90" endline="98">
<![CDATA[
 
     ReadOnly Property GetAllTypeBases() As ArrayList
         Get
             Dim result As New ArrayList
             For Each i As IndexList In m_lstCollections.Values
                 result.AddRange(i.Values)
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="193" endline="201">
<![CDATA[
 
 		protected override void WriteImpl(MetadataWriter mw)
 		{
 			foreach (string str in list)
 			{
 				mw.Write(System.Text.Encoding.UTF8.GetBytes(str));
 				mw.Write((byte)0);
 			}
 			foreach (string str in list)
 			{
 				mw.Write(System.Text.Encoding.UTF8.GetBytes(str));
 				mw.Write((byte)0);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="28" endline="34">
<![CDATA[
 
     Public Sub New(ByVal CopyFrom As ConditionalConstants)
         Me.New()
         For Each constant As ConditionalConstant In CopyFrom.Values
             Add(constant)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="901" endline="908">
<![CDATA[
 
 		internal void WriteMethodDefRecords(int baseRVA, MetadataWriter mw, ref int paramList)
 		{
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteMethodDefRecord(baseRVA, mw, ref paramList);
 			}
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteMethodDefRecord(baseRVA, mw, ref paramList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="290" endline="297">
<![CDATA[
 
 		protected override void WriteImpl(MetadataWriter mw)
 		{
 			foreach (Guid guid in list)
 			{
 				mw.Write(guid.ToByteArray());
 			}
 			foreach (Guid guid in list)
 			{
 				mw.Write(guid.ToByteArray());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="145" endline="152">
<![CDATA[
 
 		internal void WriteParamTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="921" endline="928">
<![CDATA[
 
 		internal void WriteParamRecords(MetadataWriter mw)
 		{
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteParamRecords(mw);
 			}
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteParamRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="929" endline="936">
<![CDATA[
 
 		internal void WriteFieldRecords(MetadataWriter mw)
 		{
 			foreach (FieldBuilder fb in fields)
 			{
 				fb.WriteFieldRecords(mw);
 			}
 			foreach (FieldBuilder fb in fields)
 			{
 				fb.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="115" endline="125">
<![CDATA[
 
 		internal void PopulatePropertyAndEventTables()
 		{
 			// LAMESPEC the PropertyMap and EventMap tables are not required to be sorted by the CLI spec,
 			// but .NET sorts them and Mono requires them to be sorted, so we have to populate the
 			// tables in the right order
 			foreach (TypeBuilder type in types)
 			{
 				type.PopulatePropertyAndEventTables();
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.PopulatePropertyAndEventTables();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="469" endline="479">
<![CDATA[
     End Property
 
     ReadOnly Property HasInstanceConstructors() As Boolean
         Get
             Dim ctors As Generic.List(Of ConstructorDeclaration)
             ctors = Me.Members.GetSpecificMembers(Of ConstructorDeclaration)()
             For Each item As ConstructorDeclaration In ctors
                 If item.IsShared = False Then Return True
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="276" endline="286">
<![CDATA[
     End Property
 
     ReadOnly Property HasPositionalArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is PositionalArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="266" endline="275">
<![CDATA[
 
     ReadOnly Property HasNamedArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is NamedArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="471" endline="477">
<![CDATA[
 
     Function IsNumericType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In NumericTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="478" endline="484">
<![CDATA[
 
     Function IsIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In IntegralTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="30" endline="38">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attributes
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attributes(NewParent)
         For Each item As Attribute In Me
             result.Add(item.Clone(NewParent))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2792" endline="2801">
<![CDATA[
 
     Shared Function DoesTypeImplementInterface(ByVal Context As BaseObject, ByVal Type As Mono.Cecil.TypeReference, ByVal [Interface] As Mono.Cecil.TypeReference) As Boolean
         Dim ifaces As Mono.Collections.Generic.Collection(Of TypeReference)
         ifaces = CecilHelper.GetInterfaces(Type, True)
         For Each iface As Mono.Cecil.TypeReference In ifaces
             If Helper.IsAssignable(Context, iface, [Interface]) Then Return True
         Next
         Return False
         '        Return Array.IndexOf(CecilHelper.GetInterfaces(Type), [Interface]) >= 0
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="583" endline="590">
<![CDATA[
 
     Function GetAllMembers() As Generic.List(Of Mono.Cecil.MemberReference)
         Dim result As New Generic.List(Of Mono.Cecil.MemberReference)
         For Each item As MemberCacheEntry In Me.Values
             result.AddRange(item.Members)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="859" endline="866">
<![CDATA[
 
 		static internal ICollection<string> GetUsingList ()
 		{
 			var res = new List<string> (using_list.Count);
 			foreach (object ue in using_list)
 				res.Add (ue.ToString ());
 			foreach (object ue in using_list)
 				res.Add (ue.ToString ());
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclarations.vb" startline="67" endline="76">
<![CDATA[
     End Property
 
     ReadOnly Property MemberDeclarations() As Generic.List(Of Mono.Cecil.MemberReference)
         Get
             Dim result As New Generic.List(Of Mono.Cecil.MemberReference)
             For Each member As IMember In Me
                 result.Add(member.MemberDescriptor)
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="654" endline="661">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			foreach (var s in statements)
 				s.Resolve (ec);
 			foreach (var s in statements)
 				s.Resolve (ec);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="109" endline="120">
<![CDATA[
 
     Private Function DefineTypeHierarchy(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineTypeHierarchy AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineTypeHierarchy(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="97" endline="108">
<![CDATA[
 
     Private Function DefineType(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineType AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineType(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1375" endline="1393">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (li.IsConstant)
 				return;
 
 			li.CreateBuilder (ec);
 
 			if (Initializer != null)
 				((ExpressionStatement) Initializer).EmitStatement (ec);
 
 			if (declarators != null) {
 				foreach (var d in declarators) {
 					d.Variable.CreateBuilder (ec);
 					if (d.Initializer != null)
 						((ExpressionStatement) d.Initializer).EmitStatement (ec);
 				}
 				foreach (var d in declarators) {
 					d.Variable.CreateBuilder (ec);
 					if (d.Initializer != null)
 						((ExpressionStatement) d.Initializer).EmitStatement (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9346" endline="9355">
<![CDATA[
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			CollectionOrObjectInitializers t = (CollectionOrObjectInitializers) target;
 
 			t.initializers = new List<Expression> (initializers.Count);
 			foreach (var e in initializers)
 				t.initializers.Add (e.Clone (clonectx));
 			foreach (var e in initializers)
 				t.initializers.Add (e.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="300" endline="310">
<![CDATA[
 
 		// <remarks>
 		//   If we're compiling with debugging support, this is called between parsing
 		//   and code generation to register all the source files with the
 		//   symbol writer.
 		// </remarks>
 		static public void DefineSymbolDocuments (MonoSymbolWriter symwriter)
 		{
 			foreach (CompilationUnit unit in compile_units)
 				unit.DefineSymbolInfo (symwriter);
 			foreach (CompilationUnit unit in compile_units)
 				unit.DefineSymbolInfo (symwriter);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1174" endline="1183">
<![CDATA[
 
 		/// <summary>
 		///   Used to validate that all the using clauses are correct
 		///   after we are finished parsing all the files.  
 		/// </summary>
 		static public void VerifyAllUsing ()
 		{
 			foreach (NamespaceEntry entry in entries)
 				entry.VerifyUsing ();
 			foreach (NamespaceEntry entry in entries)
 				entry.VerifyUsing ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="47" endline="55">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterList(NewParent)
         For Each item As TypeParameter In Me
             result.Add(item.clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="145" endline="156">
<![CDATA[
 
     Friend Function Emit(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.GenerateCode(Nothing) AndAlso result
         result = Type.Members.GenerateCode(Nothing) AndAlso result
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = Emit(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1409" endline="1418">
<![CDATA[
 
 		protected virtual bool DefineNestedTypes ()
 		{
 			if (Types != null) {
 				foreach (TypeContainer tc in Types)
 					tc.DefineType ();
 				foreach (TypeContainer tc in Types)
 					tc.DefineType ();
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="921" endline="932">
<![CDATA[
 
 		//
 		// Fixes full type name of each documented types/members up.
 		//
 		public void GenerateDocComment (Report r)
 		{
 			TypeContainer root = RootContext.ToplevelTypes;
 
 			if (root.Types != null)
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="455" endline="461">
<![CDATA[
 
 		protected virtual void EmitHoistedParameters (EmitContext ec, IList<HoistedParameter> hoisted)
 		{
 			foreach (HoistedParameter hp in hoisted) {
 				hp.EmitHoistingAssignment (ec);
 			}
 			foreach (HoistedParameter hp in hoisted) {
 				hp.EmitHoistingAssignment (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2180" endline="2191">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     <Diagnostics.Conditional("DEBUG")> _
     Shared Sub AssertNotNothing(ByVal Value As IEnumerable)
         If Value Is Nothing Then
             Helper.Stop()
         Else
             For Each obj As Object In Value
                 If obj Is Nothing Then Helper.Stop()
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstraintList.vb" startline="30" endline="38">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstraintList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstraintList(NewParent)
         For Each item As Constraint In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1283" endline="1292">
<![CDATA[
 
     Public Shared Function GetEvent(ByVal collection As ICollection, ByVal reference As EventReference) As EventDefinition
         For Each meth As EventDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1218" endline="1227">
<![CDATA[
 
     Public Shared Function GetField(ByVal collection As ICollection, ByVal reference As FieldReference) As FieldDefinition
         For Each field As FieldDefinition In collection
             If Not Helper.CompareNameOrdinal(field.Name, reference.Name) Then
                 Continue For
             End If
             Return field
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArgumentList.vb" startline="43" endline="52">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeArgumentList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeArgumentList(NewParent)
         For Each item As TypeName In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="44" endline="52">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributePositionalArgumentList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributePositionalArgumentList(NewParent)
         For Each item As AttributeArgumentExpression In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" startline="45" endline="53">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializerList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializerList(NewParent)
         For Each item As VariablePropertyInitializer In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\NamedBaseList.vb" startline="38" endline="55">
<![CDATA[
 
     ''' <summary>
     ''' Finds the list item with the specified name.
     ''' Returns nothing if nothing found.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal Name As String) As T
         Get
             For Each tp As T In Me
                 Dim t As INameable = CType(CObj(tp), INameable)
                 If Helper.CompareName(t.Name, Name) Then
                     Return tp
                 End If
             Next
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="47" endline="57">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For Each exp As Expression In m_Initializers
             result = exp.ResolveExpression(Info) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2103" endline="2110">
<![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IEnumerable, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.GenerateCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2095" endline="2102">
<![CDATA[
 
     Shared Function ResolveStatementCollection(ByVal Collection As IEnumerable, ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As Statement In Collection
             result = obj.ResolveStatement(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2056" endline="2063">
<![CDATA[
 
     Shared Function DefineCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.Define AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2078" endline="2086">
<![CDATA[
 
     Shared Function ResolveTypeReferencesCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             result = obj.ResolveTypeReferences AndAlso result
             'vbnc.Helper.Assert(result = (obj.Compiler.Report.Errors = 0))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Defines.vb" startline="56" endline="65">
<![CDATA[
 
     Default Shadows ReadOnly Property Item(ByVal Name As String) As Define
         Get
             For Each def As Define In Me
                 If Helper.CompareName(def.Symbol, Name) Then
                     Return def
                 End If
             Next
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="30" endline="39">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each Item As EventMemberSpecifier In Me
             result = Item.ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="372" endline="379">
<![CDATA[
 
     Shared Function GetNames(ByVal List As IEnumerable) As String()
         Dim result As New Generic.List(Of String)
         For Each item As INameable In List
             result.Add(item.Name)
         Next
         Return result.ToArray
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071">
<![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="118" endline="126">
<![CDATA[
 #End Region
 
     Shared Function CreateList(ByVal types As System.Collections.IEnumerable) As TypeList
         Dim result As New TypeList
         For Each t As IType In types
             result.Add(t.CecilType)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="282" endline="295">
<![CDATA[
 
     Private Function CreateImplicitMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitMembers(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitMembers In Type.Members.GetSpecificMembers(Of IHasImplicitMembers)()
             result = Member.CreateImplicitMembers() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="205" endline="218">
<![CDATA[
 
     Private Function CreateImplicitTypes(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitTypes(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitTypes In Type.Members.GetSpecificMembers(Of IHasImplicitTypes)()
             result = Member.CreateImplicitTypes() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="212" endline="228">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Show the saved messages. Returns true if any error messages have been shown.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ShowSavedMessages() As Boolean
         Dim result As Boolean = False
 
         For Each msg As Message In m_SavedMessages
             ShowMessage(False, msg) 'Compiler.Report.WriteLine(str)
             If msg.Level >= MessageLevel.Error Then result = True
         Next
         m_SavedMessages.Clear()
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="667" endline="687">
<![CDATA[
 
     Private Function CheckImportsAlias(ByVal R As String, ByVal [Imports] As ImportsClauses, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* If the source file has one or more import aliases, and R matches the name of one of them, then 
         '* the unqualified name refers to that import alias.
         '---------------------------------------------------------------------------------------------------------
         ' (...)
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more import aliases, and R matches the name of one of 
         '* them, then the unqualified name refers to that import alias.
         '---------------------------------------------------------------------------------------------------------
         For Each import As ImportsClause In [Imports]
             If import.IsAliasClause Then
                 If Helper.CompareName(import.AsAliasClause.Name, R) Then
                     m_FoundObjects.Add(import)
                     Return True
                 End If
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="179" endline="190">
<![CDATA[
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1293" endline="1299">
<![CDATA[
 
     Public Shared Function GetMethod(ByVal type As ICollection, ByVal reference As MethodReference) As MethodDefinition
         For Each item As Mono.Cecil.MethodDefinition In type
             If CecilHelper.AreSame(reference, item) Then Return item
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="36" endline="53">
<![CDATA[
 
     ''' <summary>
     ''' Might very well be nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ClassConstraint() As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Nothing
         For Each constraint As Constraint In m_ConstraintList
             If constraint.Special = KS.None Then
                 If CecilHelper.IsClass(constraint.TypeName.ResolvedType) Then
                     Helper.Assert(result Is Nothing)
                     result = constraint.TypeName.ResolvedType
                 End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1312" endline="1327">
<![CDATA[
 
     Public Shared Function GetProperty(ByVal collection As ICollection, ByVal reference As PropertyReference) As PropertyDefinition
         For Each meth As PropertyDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             If Not AreSame(meth.PropertyType, reference.PropertyType) Then
                 Continue For
             End If
             If Not AreSame(meth.Parameters, reference.Parameters) Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="27" endline="39">
<![CDATA[
     Function GetNamespaces(ByVal FromWhere As BaseObject, ByVal Name As String) As Generic.List(Of [Namespace])
         Dim result As New Generic.List(Of [Namespace])
         For Each imp As ImportsClause In Me
             If imp.IsNamespaceClause AndAlso imp.AsNamespaceClause.IsNamespaceImport Then
                 Dim ns As [Namespace]
                 ns = FromWhere.Compiler.TypeManager.Namespaces.Item(imp.AsNamespaceClause.NamespaceImported, Name)
                 If ns IsNot Nothing Then
                     result.Add(ns)
                 End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="71" nfragments="5" Csharpe_files="0" vb_files="5" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="474" endline="493">
<![CDATA[
 
     Sub InferTypeArguments()
         If m_TypeArguments IsNot Nothing AndAlso m_TypeArguments.Count > 0 Then
             Log("Type arguments specified, not inferring them")
             Return
         End If
 
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.InferTypeArguments = False Then
                 Log("TYPE INFERENCE FAILED
                 m_Candidates(i) = Nothing
             Else
                 Log("TYPE INFERENCE PASSED
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="504" endline="518">
<![CDATA[
 
     Sub RemoveInapplicable()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.DefineApplicability = False Then
                 Log("NOT APPLICABLE
                 m_Candidates(i) = Nothing
             Else
                 Log("APPLICABLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="459" endline="473">
<![CDATA[
 
     Sub RemoveInaccessible()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsAccessible = False Then
                 Log("NOT ACCESSIBLE
                 m_Candidates(i) = Nothing
             Else
                 Log("ACCESSIBLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="519" endline="533">
<![CDATA[
 
     Sub RemoveNarrowingExceptObject()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowingExceptObject Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="534" endline="548">
<![CDATA[
 
     Sub RemoveNarrowing()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowing Then
                 Log("NARROWING    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="72" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="73" endline="95">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim selectparent As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         EndLabel = Emitter.DefineLabel(Info)
         m_StartCode = Emitter.DefineLabel(Info)
 
         If m_IsElse = False Then
             For i As Integer = 0 To m_Clauses.Count - 1
                 Dim clause As CaseClause = m_Clauses.Item(i)
                 result = clause.GenerateCode(Info) AndAlso result
             Next
             Emitter.EmitBranch(Info, EndLabel)
         End If
         Emitter.MarkLabel(Info, m_StartCode)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, selectparent.EndLabel)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="57" endline="78">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.EmitBeginExceptionBlock(Info)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         For i As Integer = 0 To m_Catches.Count - 1
             Dim catchstmt As CatchStatement = m_Catches(i)
             result = catchstmt.GenerateCode(Info) AndAlso result
         Next
 
         If m_FinallyBlock IsNot Nothing Then
             Info.ILGen.BeginFinallyBlock()
             result = m_FinallyBlock.GenerateCode(Info) AndAlso result
         End If
 
         Info.ILGen.EndExceptionBlock()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="73" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="832" endline="855">
<![CDATA[
 
 		private static bool IsTypeName (string name)
 		{
 			switch (name) {
 			case "bool"
 			case "byte"
 			case "char"
 			case "decimal"
 			case "double"
 			case "float"
 			case "int"
 			case "long"
 			case "object"
 			case "sbyte"
 			case "short"
 			case "string"
 			case "uint"
 			case "ulong"
 			case "ushort"
 			case "void"
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1129" endline="1156">
<![CDATA[
 
 		public static void Error_NamespaceNotFound (Location loc, string name, Report Report)
 		{
 			Report.Error (246, loc, "The type or namespace name `{0}' could not be found. Are you missing a using directive or an assembly reference?",
 				name);
 
 			switch (name) {
 			case "Gtk"
 				MsgtryPkg ("gtk-sharp");
 				break;
 
 			case "Gdk"
 				MsgtryPkg ("gdk-sharp");
 				break;
 
 			case "Glade"
 				MsgtryPkg ("glade-sharp");
 				break;
 
 			case "System.Drawing"
 			case "System.Web.Services"
 			case "System.Web"
 			case "System.Data"
 			case "System.Windows.Forms"
 				MsgtryRef (name);
 				break;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="74" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="83" endline="110">
<![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Dim result As Mono.Cecil.TypeReference
             Select Case Classification.Classification
                 Case ExpressionClassification.Classifications.Value
                     result = Classification.AsValueClassification.Type
                 Case ExpressionClassification.Classifications.Variable
                     result = Classification.AsVariableClassification.Type
                 Case ExpressionClassification.Classifications.Type
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                     result = Nothing
                 Case ExpressionClassification.Classifications.Namespace
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                     result = Nothing
                 Case ExpressionClassification.Classifications.PropertyGroup
                     result = Classification.AsPropertyGroup.Type
                 Case ExpressionClassification.Classifications.PropertyAccess
                     result = Classification.AsPropertyAccess.Type
                 Case ExpressionClassification.Classifications.MethodGroup
                     result = Classification.AsMethodGroupClassification.Type
                 Case Else
                     Throw New InternalException(Me)
             End Select
             Helper.Assert(result IsNot Nothing)
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="67" endline="94">
<![CDATA[
     End Property
 
     Overloads Function [GetType](ByVal ThrowIfNoType As Boolean) As Mono.Cecil.TypeReference
         Select Case m_Classification
             Case Classifications.Value
                 Return AsValueClassification.Type
             Case Classifications.Variable
                 Return AsVariableClassification.Type
             Case Classifications.MethodGroup
                 Return AsMethodGroupClassification.Type
             Case Classifications.MethodPointer
                 Return AsMethodPointerClassification.Type
             Case Classifications.PropertyAccess
                 Return AsPropertyAccess.Type
             Case Classifications.PropertyGroup
                 Return AsPropertyGroup.Type
             Case Classifications.Void
                 Return Compiler.TypeCache.System_Void
             Case Classifications.LateBoundAccess
                 Return AsLateBoundAccess.Type
             Case Else
                 If ThrowIfNoType Then
                     Throw New InternalException("No type was found")
                 Else
                     Return Nothing
                 End If
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="75" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2564" endline="2587">
<![CDATA[
 
 		/// Search for at least one defined condition in ConditionalAttribute of attribute class
 		/// Valid only for attribute classes.
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 
 			if (OptAttributes == null)
 				return null;
 
 			Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 			if (attrs == null)
 				return null;
 
 			string[] conditions = new string[attrs.Length];
 			for (int i = 0; i < conditions.Length; ++i)
 				conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			for (int i = 0; i < conditions.Length; ++i)
 				conditions[i] = attrs[i].GetConditionalAttributeValue ();
 
 			caching_flags |= Flags.Excluded;
 			return conditions;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="504" endline="529">
<![CDATA[
 
 		/// <summary>
 		/// Returns instance of ObsoleteAttribute for this MemberCore
 		/// </summary>
 		public virtual ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if ((caching_flags & (Flags.Obsolete_Undetected | Flags.Obsolete)) == 0)
 				return null;
 
 			caching_flags &= ~Flags.Obsolete_Undetected;
 
 			if (OptAttributes == null)
 				return null;
 
 			Attribute obsolete_attr = OptAttributes.Search (Module.PredefinedAttributes.Obsolete);
 			if (obsolete_attr == null)
 				return null;
 
 			caching_flags |= Flags.Obsolete;
 
 			ObsoleteAttribute obsolete = obsolete_attr.GetObsoleteAttribute ();
 			if (obsolete == null)
 				return null;
 
 			return obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="701" endline="726">
<![CDATA[
 
 		/// <summary>
 		/// Goes through class hierarchy and gets value of first found CLSCompliantAttribute.
 		/// If no is attribute exists then assembly CLSCompliantAttribute is returned.
 		/// </summary>
 		public bool IsNotCLSCompliant ()
 		{
 			if ((caching_flags & Flags.HasCompliantAttribute_Undetected) == 0)
 				return (caching_flags & Flags.ClsCompliantAttributeFalse) != 0;
 
 			caching_flags &= ~Flags.HasCompliantAttribute_Undetected;
 
 			if (OptAttributes != null) {
 				Attribute cls_attribute = OptAttributes.Search (Module.PredefinedAttributes.CLSCompliant);
 				if (cls_attribute != null) {
 					caching_flags |= Flags.HasClsCompliantAttribute;
 					if (cls_attribute.GetClsCompliantAttributeValue ())
 						return false;
 
 					caching_flags |= Flags.ClsCompliantAttributeFalse;
 					return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="638" endline="663">
<![CDATA[
 
 		/// <summary>
 		/// Analyze whether CLS-Compliant verification must be execute for this MemberCore.
 		/// </summary>
 		public override bool IsClsComplianceRequired ()
 		{
 			if ((caching_flags & Flags.ClsCompliance_Undetected) == 0)
 				return (caching_flags & Flags.ClsCompliant) != 0;
 
 			caching_flags &= ~Flags.ClsCompliance_Undetected;
 
 			if (HasClsCompliantAttribute) {
 				if ((caching_flags & Flags.ClsCompliantAttributeFalse) != 0)
 					return false;
 
 				caching_flags |= Flags.ClsCompliant;
 				return true;
 			}
 
 			if (Parent.PartialContainer.IsClsComplianceRequired ()) {
 				caching_flags |= Flags.ClsCompliant;
 				return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="76" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="424" endline="446">
<![CDATA[
 
     Function RuleNot(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Not) Then
             NextToken()
             RuleNot = RuleRelational(LSide)
 
             Dim op1 As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 LSide = 0
             Else
                 LSide = Not op1
             End If
         Else
             If RuleRelational(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="136" endline="158">
<![CDATA[
 
     Function RuleUnaryNegation(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Minus) Then
             NextToken()
             RuleUnaryNegation = RuleExponent(LSide)
 
             Dim op1 As Double
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 LSide = 0
             Else
                 LSide = -op1
             End If
         Else
             If RuleExponent(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="77" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="205" endline="225">
<![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((addOnMethod != null && addOnMethod.IsPublic) || (removeOnMethod != null && removeOnMethod.IsPublic) || (fireMethod != null && fireMethod.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="226" endline="247">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((addOnMethod != null && addOnMethod.IsStatic) || (removeOnMethod != null && removeOnMethod.IsStatic) || (fireMethod != null && fireMethod.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="230" endline="250">
<![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((getter != null && getter.IsPublic) || (setter != null && setter.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="251" endline="272">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((getter != null && getter.IsStatic) || (setter != null && setter.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="78" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="40" endline="70">
<![CDATA[
 		
 		//
 		// From a one-dimensional array-type S[] to System.Collections.IList<T> and base
 		// interfaces of this interface, provided there is an implicit reference conversion
 		// from S to T.
 		//
 		static bool ArrayToIList (ArrayContainer array, TypeSpec list, bool isExplicit)
 		{
 			if (array.Rank != 1 || !list.IsGeneric)
 				return false;
 
 			var open_version = list.GetDefinition ();
 			if ((open_version != TypeManager.generic_ilist_type) &&
 				(open_version != TypeManager.generic_icollection_type) &&
 				(open_version != TypeManager.generic_ienumerable_type))
 				return false;
 
 			var arg_type = list.TypeArguments[0];
 			if (array.Element == arg_type)
 				return true;
 
 			if (isExplicit)
 				return ExplicitReferenceConversionExists (array.Element, arg_type);
 
 			if (MyEmptyExpr == null)
 				MyEmptyExpr = new EmptyExpression (array.Element);
 			else
 				MyEmptyExpr.SetType (array.Element);
 
 			return ImplicitReferenceConversionExists (MyEmptyExpr, arg_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="71" endline="93">
<![CDATA[
 		
 		static bool IList_To_Array(TypeSpec list, ArrayContainer array)
 		{
 			if (array.Rank != 1 || !list.IsGeneric)
 				return false;
 
 			var open_version = list.GetDefinition ();
 			if ((open_version != TypeManager.generic_ilist_type) &&
 				(open_version != TypeManager.generic_icollection_type) &&
 				(open_version != TypeManager.generic_ienumerable_type))
 				return false;
 
 			var arg_type = list.TypeArguments[0];
 			if (array.Element == arg_type)
 				return true;
 			
 			if (MyEmptyExpr == null)
 				MyEmptyExpr = new EmptyExpression (array.Element);
 			else
 				MyEmptyExpr.SetType (array.Element);
 
 			return ImplicitReferenceConversionExists (MyEmptyExpr, arg_type) || ExplicitReferenceConversionExists (array.Element, arg_type);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="79" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1222" endline="1244">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Long) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
             Return EmitLoadValue(Info, CInt(Value))
         End If
 
         Dim tmp As EmitInfo = Info.Clone(Info.Context, CType(Nothing, Mono.Cecil.TypeReference))
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
         End Select
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1245" endline="1274">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As ULong) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         'If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
         '    Helper.NotImplemented() 'Return EmitLoadValue(Info, CInt(Value))
         'ElseIf Value <= Long.MaxValue AndAlso Value >= Long.MinValue Then
         '    Return EmitLoadValue(Info, CLng(Value))
         'End If
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Int64, TypeCode.UInt64
                 EmitLoadI8Value(Info, Value)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="80" nfragments="5" Csharpe_files="0" vb_files="5" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3356" endline="3379">
<![CDATA[
 
     Private Function ParseOr_OrElse_Xor(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseAnd_AndAlso(Info)
 
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3172" endline="3193">
<![CDATA[
 
     Private Function ParseMultDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseUnaryPlusMinus(Info)
 
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3334" endline="3355">
<![CDATA[
 
     Private Function ParseAnd_AndAlso(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseNot(Info)
 
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3256" endline="3277">
<![CDATA[
 
     Private Function ParseBitshift(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseConcat(Info)
 
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3220" endline="3242">
<![CDATA[
 
     Private Function ParsePlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMod(Info)
 
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="81" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="175" endline="197">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="220" endline="242">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="82" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="169" endline="837">
<![CDATA[
 		bool hidden = false;
 		int ref_line = 1;
 		int line = 1;
 		int col = 0;
 		int previous_col;
 		int current_token;
 		int tab_size;
 		bool handle_get_set = false;
 		bool handle_remove_add = false;
 		bool handle_where = false;
 		bool handle_typeof = false;
 		bool lambda_arguments_parsing;
 		Location current_comment_location = Location.Null;
 		List<Location> escaped_identifiers;
 		int parsing_generic_less_than;
 		
 		//
 		// Used mainly for parser optimizations. Some expressions for instance
 		// can appear only in block (including initializer, base initializer)
 		// scope only
 		//
 		public int parsing_block;
 		internal bool query_parsing;
 		
 		// 
 		// When parsing type only, useful for ambiguous nullable types
 		//
 		public int parsing_type;
 		
 		//
 		// Set when parsing generic declaration (type or method header)
 		//
 		public bool parsing_generic_declaration;
 		
 		//
 		// The value indicates that we have not reach any declaration or
 		// namespace yet
 		//
 		public int parsing_declaration;
 
 		//
 		// The special character to inject on streams to trigger the EXPRESSION_PARSE
 		// token to be returned.   It just happens to be a Unicode character that
 		// would never be part of a program (can not be an identifier).
 		//
 		// This character is only tested just before the tokenizer is about to report
 		// an error;   So on the regular operation mode, this addition will have no
 		// impact on the tokenizer's performance.
 		//
 		
 		public const int EvalStatementParserCharacter = 0x2190;   // Unicode Left Arrow
 		public const int EvalCompilationUnitParserCharacter = 0x2191;  // Unicode Arrow
 		public const int EvalUsingDeclarationsParserCharacter = 0x2192;  // Unicode Arrow
 		
 		//
 		// XML documentation buffer. The save point is used to divide
 		// comments on types and comments on members.
 		//
 		StringBuilder xml_comment_buffer;
 
 		//
 		// See comment on XmlCommentState enumeration.
 		//
 		XmlCommentState xml_doc_state = XmlCommentState.Allowed;
 
 		//
 		// Whether tokens have been seen on this line
 		//
 		bool tokens_seen = false;
 
 		//
 		// Set to true once the GENERATE_COMPLETION token has bee
 		// returned.   This helps produce one GENERATE_COMPLETION,
 		// as many COMPLETE_COMPLETION as necessary to complete the
 		// AST tree and one final EOF.
 		//
 		bool generated;
 		
 		//
 		// Whether a token has been seen on the file
 		// This is needed because `define' is not allowed to be used
 		// after a token has been seen.
 		//
 		bool any_token_seen = false;
 
 		static readonly char[] simple_whitespaces = new char[] { ' ', '\t' };
 
 		public bool PropertyParsing {
 			get { return handle_get_set; }
 			set { handle_get_set = value; }
 		}
 
 		public bool EventParsing {
 			get { return handle_remove_add; }
 			set { handle_remove_add = value; }
 		}
 
 		public bool ConstraintsParsing {
 			get { return handle_where; }
 			set { handle_where = value; }
 		}
 
 		public bool TypeOfParsing {
 			get { return handle_typeof; }
 			set { handle_typeof = value; }
 		}
 
 		public int TabSize {
 			get { return tab_size; }
 			set { tab_size = value; }
 		}
 		
 		public XmlCommentState doc_state {
 			get { return xml_doc_state; }
 			set {
 				if (value == XmlCommentState.Allowed) {
 					check_incorrect_doc_comment ();
 					reset_doc_comment ();
 				}
 				xml_doc_state = value;
 			}
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
 
 		public bool IsEscapedIdentifier (MemberName name)
 		{
 			return escaped_identifiers != null && escaped_identifiers.Contains (name.Location);
 		}
 
 		//
 		// Class variables
 		// 
 		static KeywordEntry<int>[][] keywords;
 		static KeywordEntry<PreprocessorDirective>[][] keywords_preprocessor;
 		static Dictionary<string, object> keyword_strings; 		// TODO
 		static NumberStyles styles;
 		static NumberFormatInfo csharp_format_info;
 
 		// Pragma arguments
 		static readonly char[] pragma_warning = "warning".ToCharArray ();
 		static readonly char[] pragma_warning_disable = "disable".ToCharArray ();
 		static readonly char[] pragma_warning_restore = "restore".ToCharArray ();
 		static readonly char[] pragma_checksum = "checksum".ToCharArray ();
 		
 		//
 		// Values for the associated token returned
 		//
 		internal int putback_char; 	// Used by repl only
 		object val;
 
 		//
 		// Pre-processor
 		//
 		const int TAKING        = 1;
 		const int ELSE_SEEN     = 4;
 		const int PARENT_TAKING = 8;
 		const int REGION        = 16;		
 
 		//
 		// pre-processor if stack state
 		//
 		Stack<int> ifstack;
 
 		static System.Text.StringBuilder string_builder;
 
 		const int max_id_size = 512;
 		static char [] id_builder = new char [max_id_size];
 
 		public static Dictionary<char[], string>[] identifiers = new Dictionary<char[], string>[max_id_size + 1];
 
 		const int max_number_size = 512;
 		static char [] number_builder = new char [max_number_size];
 		static int number_pos;
 
 		static StringBuilder static_cmd_arg = new System.Text.StringBuilder ();
 		
 		public int Line {
 			get {
 				return ref_line;
 			}
 		}
 
 		//
 		// This is used when the tokenizer needs to save
 		// the current position as it needs to do some parsing
 		// on its own to deamiguate a token in behalf of the
 		// parser.
 		//
 		Stack<Position> position_stack = new Stack<Position> (2);
 
 		class Position {
 			public int position;
 			public int line;
 			public int ref_line;
 			public int col;
 			public bool hidden;
 			public int putback_char;
 			public int previous_col;
 			public Stack<int> ifstack;
 			public int parsing_generic_less_than;
 			public int current_token;
 			public object val;
 
 			public Position (Tokenizer t)
 			{
 				position = t.reader.Position;
 				line = t.line;
 				ref_line = t.ref_line;
 				col = t.col;
 				hidden = t.hidden;
 				putback_char = t.putback_char;
 				previous_col = t.previous_col;
 				if (t.ifstack != null && t.ifstack.Count != 0) {
 					// There is no simple way to clone Stack<T> all
 					// methods reverse the order
 					var clone = t.ifstack.ToArray ();
 					Array.Reverse (clone);
 					ifstack = new Stack<int> (clone);
 				}
 				parsing_generic_less_than = t.parsing_generic_less_than;
 				current_token = t.current_token;
 				val = t.val;
 			}
 		}
 		
 		public void PushPosition ()
 		{
 			position_stack.Push (new Position (this));
 		}
 
 		public void PopPosition ()
 		{
 			Position p = position_stack.Pop ();
 
 			reader.Position = p.position;
 			ref_line = p.ref_line;
 			line = p.line;
 			col = p.col;
 			hidden = p.hidden;
 			putback_char = p.putback_char;
 			previous_col = p.previous_col;
 			ifstack = p.ifstack;
 			parsing_generic_less_than = p.parsing_generic_less_than;
 			current_token = p.current_token;
 			val = p.val;
 		}
 
 		// Do not reset the position, ignore it.
 		public void DiscardPosition ()
 		{
 			position_stack.Pop ();
 		}
 		
 		static void AddKeyword (string kw, int token)
 		{
 			keyword_strings.Add (kw, null);
 
 			AddKeyword (keywords, kw, token);
 		}
 
 		static void AddPreprocessorKeyword (string kw, PreprocessorDirective directive)
 		{
 			AddKeyword (keywords_preprocessor, kw, directive);
 		}
 
 		static void AddKeyword<T> (KeywordEntry<T>[][] keywords, string kw, T token)
 		{
 			int length = kw.Length;
 			if (keywords[length] == null) {
 				keywords[length] = new KeywordEntry<T>['z' - '_' + 1];
 			}
 
 			int char_index = kw[0] - '_';
 			var kwe = keywords[length][char_index];
 			if (kwe == null) {
 				keywords[length][char_index] = new KeywordEntry<T> (kw, token);
 				return;
 			}
 
 			while (kwe.Next != null) {
 				kwe = kwe.Next;
 			}
 
 			kwe.Next = new KeywordEntry<T> (kw, token);
 		}
 
 		static void InitTokens ()
 		{
 			keyword_strings = new Dictionary<string, object> ();
 
 			// 11 is the length of the longest keyword for now
 			keywords = new KeywordEntry<int> [11] [];
 
 			AddKeyword ("__arglist", Token.ARGLIST);
 			AddKeyword ("abstract", Token.ABSTRACT);
 			AddKeyword ("as", Token.AS);
 			AddKeyword ("add", Token.ADD);
 			AddKeyword ("base", Token.BASE);
 			AddKeyword ("bool", Token.BOOL);
 			AddKeyword ("break", Token.BREAK);
 			AddKeyword ("byte", Token.BYTE);
 			AddKeyword ("case", Token.CASE);
 			AddKeyword ("catch", Token.CATCH);
 			AddKeyword ("char", Token.CHAR);
 			AddKeyword ("checked", Token.CHECKED);
 			AddKeyword ("class", Token.CLASS);
 			AddKeyword ("const", Token.CONST);
 			AddKeyword ("continue", Token.CONTINUE);
 			AddKeyword ("decimal", Token.DECIMAL);
 			AddKeyword ("default", Token.DEFAULT);
 			AddKeyword ("delegate", Token.DELEGATE);
 			AddKeyword ("do", Token.DO);
 			AddKeyword ("double", Token.DOUBLE);
 			AddKeyword ("else", Token.ELSE);
 			AddKeyword ("enum", Token.ENUM);
 			AddKeyword ("event", Token.EVENT);
 			AddKeyword ("explicit", Token.EXPLICIT);
 			AddKeyword ("extern", Token.EXTERN);
 			AddKeyword ("false", Token.FALSE);
 			AddKeyword ("finally", Token.FINALLY);
 			AddKeyword ("fixed", Token.FIXED);
 			AddKeyword ("float", Token.FLOAT);
 			AddKeyword ("for", Token.FOR);
 			AddKeyword ("foreach", Token.FOREACH);
 			AddKeyword ("goto", Token.GOTO);
 			AddKeyword ("get", Token.GET);
 			AddKeyword ("if", Token.IF);
 			AddKeyword ("implicit", Token.IMPLICIT);
 			AddKeyword ("in", Token.IN);
 			AddKeyword ("int", Token.INT);
 			AddKeyword ("interface", Token.INTERFACE);
 			AddKeyword ("internal", Token.INTERNAL);
 			AddKeyword ("is", Token.IS);
 			AddKeyword ("lock", Token.LOCK);
 			AddKeyword ("long", Token.LONG);
 			AddKeyword ("namespace", Token.NAMESPACE);
 			AddKeyword ("new", Token.NEW);
 			AddKeyword ("null", Token.NULL);
 			AddKeyword ("object", Token.OBJECT);
 			AddKeyword ("operator", Token.OPERATOR);
 			AddKeyword ("out", Token.OUT);
 			AddKeyword ("override", Token.OVERRIDE);
 			AddKeyword ("params", Token.PARAMS);
 			AddKeyword ("private", Token.PRIVATE);
 			AddKeyword ("protected", Token.PROTECTED);
 			AddKeyword ("public", Token.PUBLIC);
 			AddKeyword ("readonly", Token.READONLY);
 			AddKeyword ("ref", Token.REF);
 			AddKeyword ("remove", Token.REMOVE);
 			AddKeyword ("return", Token.RETURN);
 			AddKeyword ("sbyte", Token.SBYTE);
 			AddKeyword ("sealed", Token.SEALED);
 			AddKeyword ("set", Token.SET);
 			AddKeyword ("short", Token.SHORT);
 			AddKeyword ("sizeof", Token.SIZEOF);
 			AddKeyword ("stackalloc", Token.STACKALLOC);
 			AddKeyword ("static", Token.STATIC);
 			AddKeyword ("string", Token.STRING);
 			AddKeyword ("struct", Token.STRUCT);
 			AddKeyword ("switch", Token.SWITCH);
 			AddKeyword ("this", Token.THIS);
 			AddKeyword ("throw", Token.THROW);
 			AddKeyword ("true", Token.TRUE);
 			AddKeyword ("try", Token.TRY);
 			AddKeyword ("typeof", Token.TYPEOF);
 			AddKeyword ("uint", Token.UINT);
 			AddKeyword ("ulong", Token.ULONG);
 			AddKeyword ("unchecked", Token.UNCHECKED);
 			AddKeyword ("unsafe", Token.UNSAFE);
 			AddKeyword ("ushort", Token.USHORT);
 			AddKeyword ("using", Token.USING);
 			AddKeyword ("virtual", Token.VIRTUAL);
 			AddKeyword ("void", Token.VOID);
 			AddKeyword ("volatile", Token.VOLATILE);
 			AddKeyword ("while", Token.WHILE);
 			AddKeyword ("partial", Token.PARTIAL);
 			AddKeyword ("where", Token.WHERE);
 			AddKeyword ("async", Token.ASYNC);
 
 			// LINQ keywords
 			AddKeyword ("from", Token.FROM);
 			AddKeyword ("join", Token.JOIN);
 			AddKeyword ("on", Token.ON);
 			AddKeyword ("equals", Token.EQUALS);
 			AddKeyword ("select", Token.SELECT);
 			AddKeyword ("group", Token.GROUP);
 			AddKeyword ("by", Token.BY);
 			AddKeyword ("let", Token.LET);
 			AddKeyword ("orderby", Token.ORDERBY);
 			AddKeyword ("ascending", Token.ASCENDING);
 			AddKeyword ("descending", Token.DESCENDING);
 			AddKeyword ("into", Token.INTO);
 
 			keywords_preprocessor = new KeywordEntry<PreprocessorDirective>[10][];
 
 			AddPreprocessorKeyword ("region", PreprocessorDirective.Region);
 			AddPreprocessorKeyword ("endregion", PreprocessorDirective.Endregion);
 			AddPreprocessorKeyword ("if", PreprocessorDirective.If);
 			AddPreprocessorKeyword ("endif", PreprocessorDirective.Endif);
 			AddPreprocessorKeyword ("elif", PreprocessorDirective.Elif);
 			AddPreprocessorKeyword ("else", PreprocessorDirective.Else);
 			AddPreprocessorKeyword ("define", PreprocessorDirective.Define);
 			AddPreprocessorKeyword ("undef", PreprocessorDirective.Undef);
 			AddPreprocessorKeyword ("error", PreprocessorDirective.Error);
 			AddPreprocessorKeyword ("warning", PreprocessorDirective.Warning);
 			AddPreprocessorKeyword ("pragma", PreprocessorDirective.Pragma);
 			AddPreprocessorKeyword ("line", PreprocessorDirective.Line);
 		}
 
 		//
 		// Class initializer
 		// 
 		static Tokenizer ()
 		{
 			InitTokens ();			
 			csharp_format_info = NumberFormatInfo.InvariantInfo;
 			styles = NumberStyles.Float;
 
 			string_builder = new System.Text.StringBuilder ();
 		}
 
 		int GetKeyword (char[] id, int id_len)
 		{
 			//
 			// Keywords are stored in an array of arrays grouped by their
 			// length and then by the first character
 			//
 			if (id_len >= keywords.Length || keywords [id_len] == null)
 				return -1;
 
 			int first_index = id [0] - '_';
 			if (first_index > 'z' - '_')
 				return -1;
 
 			var kwe = keywords [id_len] [first_index];
 			if (kwe == null)
 				return -1;
 
 			int res;
 			do {
 				res = kwe.Token;
 				for (int i = 1; i < id_len; ++i) {
 					if (id [i] != kwe.Value [i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 			} while (res == 0 && kwe != null);
 
 			if (res == 0)
 				return -1;
 
 			int next_token;
 			switch (res) {
 			case Token.GET
 			case Token.SET
 				if (!handle_get_set)
 					res = -1;
 				break;
 			case Token.REMOVE
 			case Token.ADD
 				if (!handle_remove_add)
 					res = -1;
 				break;
 			case Token.EXTERN
 				if (parsing_declaration == 0)
 					res = Token.EXTERN_ALIAS;
 				break;
 			case Token.DEFAULT
 				if (peek_token () == Token.COLON) {
 					token ();
 					res = Token.DEFAULT_COLON;
 				}
 				break;
 			case Token.WHERE
 				if (!handle_where && !query_parsing)
 					res = -1;
 				break;
 			case Token.FROM
 				//
 				// A query expression is any expression that starts with `from identifier'
 				// followed by any token except ; , =
 				// 
 				if (!query_parsing) {
 					if (lambda_arguments_parsing) {
 						res = -1;
 						break;
 					}
 
 					PushPosition ();
 					// HACK
 					// store identifiers array
 					parsing_generic_less_than = 1;
 					switch (xtoken ()) {
 					case Token.IDENTIFIER
 					case Token.INT
 					case Token.BOOL
 					case Token.BYTE
 					case Token.CHAR
 					case Token.DECIMAL
 					case Token.FLOAT
 					case Token.LONG
 					case Token.OBJECT
 					case Token.STRING
 					case Token.UINT
 					case Token.ULONG
 						next_token = xtoken ();
 						if (next_token == Token.SEMICOLON || next_token == Token.COMMA || next_token == Token.EQUALS)
 							goto default;
 						
 						res = Token.FROM_FIRST;
 						query_parsing = true;
 						if (RootContext.Version <= LanguageVersion.ISO_2)
 							Report.FeatureIsNotAvailable (Location, "query expressions");
 						break;
 					case Token.VOID
 						Expression.Error_VoidInvalidInTheContext (Location, Report);
 						break;
 					default
 						PopPosition ();
 						// HACK
 						// which has been overwritten before we grabbed the identifier
 						id_builder [0] = 'f'; id_builder [1] = 'r'; id_builder [2] = 'o'; id_builder [3] = 'm';
 						return -1;
 					}
 					PopPosition ();
 				}
 				break;
 			case Token.JOIN
 			case Token.ON
 			case Token.EQUALS
 			case Token.SELECT
 			case Token.GROUP
 			case Token.BY
 			case Token.LET
 			case Token.ORDERBY
 			case Token.ASCENDING
 			case Token.DESCENDING
 			case Token.INTO
 				if (!query_parsing)
 					res = -1;
 				break;
 				
 			case Token.USING
 			case Token.NAMESPACE
 				// TODO
 				check_incorrect_doc_comment ();
 				break;
 				
 			case Token.PARTIAL
 				if (parsing_block > 0) {
 					res = -1;
 					break;
 				}
 
 				// Save current position and parse next token.
 				PushPosition ();
 
 				next_token = token ();
 				bool ok = (next_token == Token.CLASS) ||
 					(next_token == Token.STRUCT) ||
 					(next_token == Token.INTERFACE) ||
 					(next_token == Token.VOID);
 
 				PopPosition ();
 
 				if (ok) {
 					if (next_token == Token.VOID) {
 						if (RootContext.Version == LanguageVersion.ISO_1 ||
 						    RootContext.Version == LanguageVersion.ISO_2)
 							Report.FeatureIsNotAvailable (Location, "partial methods");
 					} else if (RootContext.Version == LanguageVersion.ISO_1)
 						Report.FeatureIsNotAvailable (Location, "partial types");
 
 					return res;
 				}
 
 				if (next_token < Token.LAST_KEYWORD) {
 					Report.Error (267, Location,
 						"The `partial' modifier can be used only immediately before `class', `struct', `interface', or `void' keyword");
 					return token ();
 				}					
 
 				res = -1;
 				break;
 
 			case Token.ASYNC
 				if (parsing_block > 0 || RootContext.Version != LanguageVersion.Future) {
 					res = -1;
 					break;
 				}
 				break;
 			}
 
 			return res;
 		}
 
 		static PreprocessorDirective GetPreprocessorDirective (char[] id, int id_len)
 		{
 			//
 			// Keywords are stored in an array of arrays grouped by their
 			// length and then by the first character
 			//
 			if (id_len >= keywords_preprocessor.Length || keywords_preprocessor[id_len] == null)
 				return PreprocessorDirective.Invalid;
 
 			int first_index = id[0] - '_';
 			if (first_index > 'z' - '_')
 				return PreprocessorDirective.Invalid;
 
 			var kwe = keywords_preprocessor[id_len][first_index];
 			if (kwe == null)
 				return PreprocessorDirective.Invalid;
 
 			PreprocessorDirective res = PreprocessorDirective.Invalid;
 			do {
 				res = kwe.Token;
 				for (int i = 1; i < id_len; ++i) {
 					if (id[i] != kwe.Value[i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 			} while (res == PreprocessorDirective.Invalid && kwe != null);
 
 			return res;
 		}
 
 		public Location Location {
 			get {
 				return new Location (ref_line, hidden ? -1 
 			}
 		}
 
 		public Tokenizer (SeekableStreamReader input, CompilationUnit file, CompilerContext ctx)
 		{
 			this.ref_name = file;
 			this.file_name = file;
 			this.context = ctx;
 			reader = input;
 			
 			putback_char = -1;
 
 			xml_comment_buffer = new StringBuilder ();
 
 			if (Environment.OSVersion.Platform == PlatformID.Win32NT)
 				tab_size = 4;
 			else
 				tab_size = 8;
 
 			//
 			// FIXME
 			// find out why the MS compiler allows this
 			//
 			Mono.CSharp.Location.Push (file, file);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="168" endline="198">
<![CDATA[
 		public WORD Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
 		public BYTE MajorLinkerVersion = 8;
 		public BYTE MinorLinkerVersion = 0;
 		public DWORD SizeOfCode;
 		public DWORD SizeOfInitializedData;
 		public DWORD SizeOfUninitializedData;
 		public DWORD AddressOfEntryPoint;
 		public DWORD BaseOfCode;
 		public DWORD BaseOfData;
 		public ULONGLONG ImageBase;
 		public DWORD SectionAlignment = 0x2000;
 		public DWORD FileAlignment = 0x200;
 		public WORD MajorOperatingSystemVersion = 4;
 		public WORD MinorOperatingSystemVersion = 0;
 		public WORD MajorImageVersion = 0;
 		public WORD MinorImageVersion = 0;
 		public WORD MajorSubsystemVersion = 4;
 		public WORD MinorSubsystemVersion = 0;
 		public DWORD Win32VersionValue = 0;
 		public DWORD SizeOfImage;
 		public DWORD SizeOfHeaders;
 		public DWORD CheckSum = 0;
 		public WORD Subsystem;
 		public WORD DllCharacteristics;
 		public ULONGLONG SizeOfStackReserve = 0x100000;
 		public ULONGLONG SizeOfStackCommit = 0x1000;
 		public ULONGLONG SizeOfHeapReserve = 0x100000;
 		public ULONGLONG SizeOfHeapCommit = 0x1000;
 		public DWORD LoaderFlags = 0;
 		public DWORD NumberOfRvaAndSizes = 16;
 		public IMAGE_DATA_DIRECTORY[] DataDirectory = new IMAGE_DATA_DIRECTORY[16];
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="83" nfragments="7" Csharpe_files="7" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="388" endline="419">
<![CDATA[
 
 		internal void WriteMemberRefParent(int token)
 		{
 			switch (token >> 24)
 			{
 				case TypeDefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 0;
 					break;
 				case TypeRefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 1;
 					break;
 				case ModuleRefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 2;
 					break;
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 3;
 					break;
 				case TypeSpecTable.Index
 					token = (token & 0xFFFFFF) << 3 | 4;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMemberRefParent)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="359" endline="387">
<![CDATA[
 
 		internal void WriteResolutionScope(int token)
 		{
 			switch (token >> 24)
 			{
 				case ModuleTable.Index
 					token = (token & 0xFFFFFF) << 2 | 0;
 					break;
 				case ModuleRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 1;
 					break;
 				case AssemblyRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 2;
 					break;
 				case TypeRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 3;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigResolutionScope)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="471" endline="498">
<![CDATA[
 
 		internal void WriteImplementation(int token)
 		{
 			switch (token >> 24)
 			{
 				case 0
 					break;
 				case FileTable.Index
 					token = (token & 0xFFFFFF) << 2 | 0;
 					break;
 				case AssemblyRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 1;
 					break;
 				case ExportedTypeTable.Index
 					token = (token & 0xFFFFFF) << 2 | 2;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigImplementation)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="186" endline="213">
<![CDATA[
 
 		internal void WriteTypeDefOrRef(int token)
 		{
 			switch (token >> 24)
 			{
 				case 0
 					break;
 				case TypeDefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 0;
 					break;
 				case TypeRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 1;
 					break;
 				case TypeSpecTable.Index
 					token = (token & 0xFFFFFF) << 2 | 2;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigTypeDefOrRef)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="240" endline="262">
<![CDATA[
 
 		internal void WriteCustomAttributeType(int token)
 		{
 			switch (token >> 24)
 			{
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 2;
 					break;
 				case MemberRefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 3;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigCustomAttributeType)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="420" endline="442">
<![CDATA[
 
 		internal void WriteMethodDefOrRef(int token)
 		{
 			switch (token >> 24)
 			{
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 0;
 					break;
 				case MemberRefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 1;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMethodDefOrRef)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="527" endline="549">
<![CDATA[
 
 		internal void WriteMemberForwarded(int token)
 		{
 			switch (token >> 24)
 			{
 				case FieldTable.Index
 					token = (token & 0xFFFFFF) << 1 | 0;
 				    break;
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 1;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMemberForwarded)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="84" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="480" endline="501">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			unwrap = Unwrap.Create (Expr, false);
 			if (unwrap == null)
 				return null;
 
 			Expression res = base.ResolveOperator (ec, unwrap);
 			if (res != this) {
 				if (user_operator == null)
 					return res;
 			} else {
 				res = Expr = LiftExpression (ec, Expr);
 			}
 
 			if (res == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			type = res.Type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1227" endline="1246">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			unwrap = Unwrap.Create (expr, false);
 			if (unwrap == null)
 				return null;
 
 			underlying = (UnaryMutator) new UnaryMutator (Mode, unwrap, loc).Resolve (ec);
 			if (underlying == null)
 				return null;
 
 
 			eclass = ExprClass.Value;
 			type = expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="85" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1418" endline="1428">
<![CDATA[
 
 		public void Encode (int value)
 		{
 			if (pos + 4 > buffer.Length)
 				Grow (4);
 
 			buffer[pos++] = (byte) value;
 			buffer[pos++] = (byte) (value >> 8);
 			buffer[pos++] = (byte) (value >> 16);
 			buffer[pos++] = (byte) (value >> 24);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="124" endline="133">
<![CDATA[
 	
 		internal void Write(int value)
 		{
 			if (pos + 4 > buffer.Length)
 				Grow(4);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 			buffer[pos++] = (byte)(value >> 16);
 			buffer[pos++] = (byte)(value >> 24);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="86" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3688" endline="3712">
<![CDATA[
 
     ''' <summary>
     ''' Gets the parameters in the definition (not inflated)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function GetOriginalParameters(ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return CecilHelper.FindDefinition(mR).Parameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3669" endline="3687">
<![CDATA[
 
     Overloads Shared Function GetParameters(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return mR.ResolvedParameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="87" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="624" endline="639">
<![CDATA[
 
 		private TypeDefImpl FindFieldOwner(int fieldIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="724" endline="740">
<![CDATA[
 		}
 
 		private TypeDefImpl FindMethodOwner(int methodIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="88" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="128" endline="146">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
 
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Char, TypeCode.String
                     Return CStr(originalValue)
                 Case TypeCode.DBNull
                     Return DBNull.Value
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="126" endline="144">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
                 TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Return CDbl(originalValue) 'No range checking needed.
                 Case TypeCode.DBNull
                     Return CDbl(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Double
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="134" endline="152">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
                   TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Return CBool(originalValue) 'No range checking needed.
                 Case TypeCode.DBNull
                     Return CBool(Nothing)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="89" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="231" endline="262">
<![CDATA[
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="435" endline="455">
<![CDATA[
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="90" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="30" endline="51">
<![CDATA[
 
 		protected override Expression CreateExpressionTree (ResolveContext ec, TypeSpec delegate_type)
 		{
 			if (ec.IsInProbingMode)
 				return this;
 
 			BlockContext bc = new BlockContext (ec.MemberContext, ec.ConstructorBlock, TypeManager.void_type) {
 				CurrentAnonymousMethod = ec.CurrentAnonymousMethod
 			};
 
 			Expression args = Parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (delegate_type, loc)),
 				arguments);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="151" endline="166">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			BlockContext bc = new BlockContext (ec.MemberContext, Block, ReturnType);
 			Expression args = parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (type, loc)),
 				arguments);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="91" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="415" endline="443">
<![CDATA[
 
 		//
 		// Optimized default assembly loader version
 		//
 		public override Assembly LoadAssemblyDefault (string assembly)
 		{
 			foreach (var path in paths) {
 				var file = Path.Combine (path, assembly);
 				if (!File.Exists (file))
 					continue;
 
 				try {
 					if (Report.DebugFlags > 0)
 						Console.WriteLine ("Loading default assembly `{0}'", file);
 
 					var a = domain.LoadFile (file);
 					if (a != null) {
 						loaded_names.Add (Tuple.Create (a.GetName (), assembly));
 					}
 
 					return a;
 				} catch {
 					// Default assemblies can fail to load without error
 					return null;
 			foreach (var path in paths) {
 				var file = Path.Combine (path, assembly);
 				if (!File.Exists (file))
 					continue;
 
 				try {
 					if (Report.DebugFlags > 0)
 						Console.WriteLine ("Loading default assembly `{0}'", file);
 
 					var a = domain.LoadFile (file);
 					if (a != null) {
 						loaded_names.Add (Tuple.Create (a.GetName (), assembly));
 					}
 
 					return a;
 				} catch {
 					// Default assemblies can fail to load without error
 					return null;
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="390" endline="414">
<![CDATA[
 
 		public RawModule LoadModuleFile (string moduleName)
 		{
 			foreach (var path in paths) {
 				var file = Path.Combine (path, moduleName);
 				if (!File.Exists (file)) {
 					if (moduleName.EndsWith (".netmodule", StringComparison.Ordinal))
 						continue;
 
 					file += ".netmodule";
 					if (!File.Exists (file))
 						continue;
 				}
 
 				try {
 					return domain.OpenRawModule (file);
 				} catch {
 					Error_FileCorrupted (file);
 					return null;
 			foreach (var path in paths) {
 				var file = Path.Combine (path, moduleName);
 				if (!File.Exists (file)) {
 					if (moduleName.EndsWith (".netmodule", StringComparison.Ordinal))
 						continue;
 
 					file += ".netmodule";
 					if (!File.Exists (file))
 						continue;
 				}
 
 				try {
 					return domain.OpenRawModule (file);
 				} catch {
 					Error_FileCorrupted (file);
 					return null;
 				}
 			}
 
 			Error_FileNotFound (moduleName);
 			return null;				
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="92" nfragments="11" Csharpe_files="8" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="538" endline="557">
<![CDATA[
 
 		/// <summary>
 		///   Returns a fully formed expression after a MemberLookup
 		/// </summary>
 		/// 
 		static Expression ExprClassFromMemberInfo (MemberSpec spec, Location loc)
 		{
 			if (spec is EventSpec)
 				return new EventExpr ((EventSpec) spec, loc);
 			if (spec is ConstSpec)
 				return new ConstantExpr ((ConstSpec) spec, loc);
 			if (spec is FieldSpec)
 				return new FieldExpr ((FieldSpec) spec, loc);
 			if (spec is PropertySpec)
 				return new PropertyExpr ((PropertySpec) spec, loc);
 			if (spec is TypeSpec)
 				return new TypeExpression (((TypeSpec) spec), loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2131" endline="2149">
<![CDATA[
 
 		// TODO
 		public static string GetMemberType (MemberCore mc)
 		{
 			if (mc is Property)
 				return "property";
 			if (mc is Indexer)
 				return "indexer";
 			if (mc is FieldBase)
 				return "field";
 			if (mc is MethodCore)
 				return "method";
 			if (mc is EnumMember)
 				return "enum";
 			if (mc is Event)
 				return "event";
 
 			return "type";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="681" endline="700">
<![CDATA[
 
 		//
 		// Get a prefix from member type for XML documentation (used
 		// to formalize cref target name).
 		//
 		static string GetMemberDocHead (MemberSpec type)
 		{
 			if (type is FieldSpec)
 				return "F
 			if (type is MethodSpec)
 				return "M
 			if (type is EventSpec)
 				return "E
 			if (type is PropertySpec)
 				return "P
 			if (type is TypeSpec)
 				return "T
 
 			return "!
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="89" endline="107">
<![CDATA[
 
     ReadOnly Property DescriptiveType() As String
         Get
             If TypeOf Me Is ClassDeclaration Then
                 Return "class"
             ElseIf TypeOf Me Is ModuleDeclaration Then
                 Return "module"
             ElseIf TypeOf Me Is EnumDeclaration Then
                 Return "enum"
             ElseIf TypeOf Me Is StructureDeclaration Then
                 Return "structure"
             ElseIf TypeOf Me Is DelegateDeclaration Then
                 Return "delegate"
             ElseIf TypeOf Me Is InterfaceDeclaration Then
                 Return "interface"
             Else
                 Return "type"
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="517" endline="533">
<![CDATA[
 
 	static string GetTypeKind (Type t)
 	{
 		if (t.IsEnum)
 			return "enum";
 		if (t.IsClass) {
 			if (t.IsSubclassOf (typeof (System.MulticastDelegate)))
 				return "delegate";
 			else
 				return "class";
 		}
 		if (t.IsInterface)
 			return "interface";
 		if (t.IsValueType)
 			return "struct";
 		return "class";
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="464" endline="477">
<![CDATA[
 
 	static string GetMethodVisibility (MethodBase m)
 	{
 		// itnerfaces have no modifiers here
 		if (m.DeclaringType.IsInterface)
 			return "";
 		
 		if (m.IsPublic)   return "public ";
 		if (m.IsFamily)   return "protected ";
 		if (m.IsPrivate)  return "private ";
 		if (m.IsAssembly) return "internal ";
 			
 		return null;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2485" endline="2505">
<![CDATA[
 
     ''' <summary>
     ''' Converts the value into how it would look in a source file. 
     ''' I.E
     ''' </summary>
     ''' <param name="Value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function ValueToCodeConstant(ByVal Value As Object) As String
         If TypeOf Value Is String Then
             Return """" & Value.ToString.Replace("""", """""") & """"
         ElseIf TypeOf Value Is Char Then
             Return """" & Value.ToString.Replace("""", """""") & """c"
         ElseIf TypeOf Value Is Date Then
             Return "#" & Value.ToString & "#"
         ElseIf Value Is Nothing Then
             Return KS.Nothing.ToString
         Else
             Return Value.ToString
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="478" endline="516">
<![CDATA[
 	
 	static string GetMethodModifiers (MethodBase method)
 	{
 		if (method.IsStatic)
 			return "static ";
 
 		if (method.IsFinal) {
 			// This will happen if you have
 			// class X 
 			//   public void A () {}
 			//   static void Main () {}
 			// }
 			// interface IA {
 			//   void A ();
 			// }
 			//
 			// A needs to be virtual (the CLR requires
 			// methods implementing an iface be virtual),
 			// but can not be inherited. It also can not
 			// be inherited. In C# this is represented
 			// with no special modifiers
 
 			if (method.IsVirtual)
 				return null;
 			return "sealed ";
 		}
 		
 		// all interface methods are "virtual" but we don't say that in c#
 		if (method.IsVirtual && !method.DeclaringType.IsInterface) {
 			if (method.IsAbstract)
 				return "abstract ";
 
 			return ((method.Attributes & MethodAttributes.NewSlot) != 0) ?
 				"virtual " 
 				"override ";	
 		}
 				
 		return null;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="763" endline="784">
<![CDATA[
 
 	//
 	// Checks whether `type' is a nested child of `parent'.
 	//
 	public static bool IsNestedChildOf (TypeSpec type, ITypeDefinition parent)
 	{
 		if (type == null)
 			return false;
 
 		if (type.MemberDefinition == parent)
 			return false;
 
 		type = type.DeclaringType;
 		while (type != null) {
 			if (type.MemberDefinition == parent)
 				return true;
 
 			type = type.DeclaringType;
 		}
 		while (type != null) {
 			if (type.MemberDefinition == parent)
 				return true;
 
 			type = type.DeclaringType;
 		}
 
 		return false;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="97" endline="117">
<![CDATA[
 
     ''' <summary>
     ''' Get the parent code block. Might be nothing!
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindParentCodeBlock() As CodeBlock
         If TypeOf Parent Is CodeBlock Then
             Return DirectCast(Parent, CodeBlock)
         Else
             If TypeOf Parent Is Expression Then
                 Return DirectCast(Parent, Expression).FindParentCodeBlock
             ElseIf TypeOf Parent Is BlockStatement Then
                 Return DirectCast(Parent, BlockStatement).CodeBlock
             ElseIf TypeOf Parent Is Statement Then
                 Return DirectCast(Parent, Statement).FindParentCodeBlock
             Else
                 Return Nothing
             End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="724" endline="746">
<![CDATA[
 
 	public static bool IsFamilyAccessible (TypeSpec type, TypeSpec parent)
 	{
 //		TypeParameter tparam = LookupTypeParameter (type);
 //		TypeParameter pparam = LookupTypeParameter (parent);
 
 		if (type.Kind == MemberKind.TypeParameter && parent.Kind == MemberKind.TypeParameter) { // (tparam != null) && (pparam != null)) {
 			if (type == parent)
 				return true;
 
 			throw new NotImplementedException ("net");
 //			return tparam.IsSubclassOf (parent);
 		}
 
 		do {
 			if (IsInstantiationOfSameGenericType (type, parent))
 				return true;
 
 			type = type.BaseType;
 		} while (type != null);
 
 		return false;
 	}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="93" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="942" endline="964">
<![CDATA[
 		}
 
 		public bool IsPrimitive
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_Boolean
 					|| this == u.System_Byte
 					|| this == u.System_SByte
 					|| this == u.System_Int16
 					|| this == u.System_UInt16
 					|| this == u.System_Int32
 					|| this == u.System_UInt32
 					|| this == u.System_Int64
 					|| this == u.System_UInt64
 					|| this == u.System_IntPtr
 					|| this == u.System_UIntPtr
 					|| this == u.System_Char
 					|| this == u.System_Double
 					|| this == u.System_Single
 					;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1515" endline="1536">
<![CDATA[
 		}
 
 		internal bool IsPseudoCustomAttribute
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_NonSerializedAttribute
 					|| this == u.System_SerializableAttribute
 					|| this == u.System_Runtime_InteropServices_DllImportAttribute
 					|| this == u.System_Runtime_InteropServices_FieldOffsetAttribute
 					|| this == u.System_Runtime_InteropServices_InAttribute
 					|| this == u.System_Runtime_InteropServices_MarshalAsAttribute
 					|| this == u.System_Runtime_InteropServices_OutAttribute
 					|| this == u.System_Runtime_InteropServices_StructLayoutAttribute
 					|| this == u.System_Runtime_InteropServices_OptionalAttribute
 					|| this == u.System_Runtime_InteropServices_PreserveSigAttribute
 					|| this == u.System_Runtime_InteropServices_ComImportAttribute
 					|| this == u.System_Runtime_CompilerServices_SpecialNameAttribute
 					|| this == u.System_Runtime_CompilerServices_MethodImplAttribute
 					;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="94" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="504" endline="518">
<![CDATA[
 
 		private Assembly ResolveAssemblyRefImpl(ref AssemblyRefTable.Record rec)
 		{
 			const int PublicKey = 0x0001;
 			string name = String.Format("{0}, Version={1}.{2}.{3}.{4}, Culture={5}, {6}={7}",
 				GetString(rec.Name),
 				rec.MajorVersion,
 				rec.MinorVersion,
 				rec.BuildNumber,
 				rec.RevisionNumber,
 				rec.Culture == 0 ? "neutral" 
 				(rec.Flags & PublicKey) == 0 ? "PublicKeyToken" 
 				PublicKeyOrTokenToString(rec.PublicKeyOrToken));
 			return universe.Load(name, this.Assembly, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="171" endline="179">
<![CDATA[
 
 		public override string ToString ()
 		{
 			return String.Format (
 				"OffsetTable [{0} - {1}
 				TotalFileSize, DataSectionOffset, DataSectionSize, SourceCount,
 				SourceTableOffset, SourceTableSize, MethodCount, MethodTableOffset,
 				MethodTableSize, TypeCount);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="95" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="86" endline="97">
<![CDATA[
 
 		public override FieldInfo[] __GetDeclaredFields()
 		{
 			int field = module.TypeDef.records[index].FieldList - 1;
 			int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].FieldList - 1 
 			FieldInfo[] fields = new FieldInfo[end - field];
 			for (int i = 0; field < end; i++, field++)
 			{
 				fields[i] = module.GetFieldAt(this, field);
 			}
 			for (int i = 0; field < end; i++, field++)
 			{
 				fields[i] = module.GetFieldAt(this, field);
 			}
 			return fields;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="113" endline="124">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			int method = module.TypeDef.records[index].MethodList - 1;
 			int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].MethodList - 1 
 			MethodBase[] methods = new MethodBase[end - method];
 			for (int i = 0; method < end; method++, i++)
 			{
 				methods[i] = module.GetMethodAt(this, method);
 			}
 			for (int i = 0; method < end; method++, i++)
 			{
 				methods[i] = module.GetMethodAt(this, method);
 			}
 			return methods;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="96" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="174" endline="191">
<![CDATA[
 
     Private Function EmitLoadAddressCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariableLocation(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariableLocation(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="192" endline="209">
<![CDATA[
 
     Private Function EmitLoadCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariable(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="97" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1415" endline="1428">
<![CDATA[
 
     Shared Function GetTypes(ByVal Arguments As Generic.List(Of Argument)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference = New Mono.Cecil.TypeReference() {}
 
         If Arguments Is Nothing Then Return result
         ReDim result(Arguments.Count - 1)
         For i As Integer = 0 To Arguments.Count - 1
             Helper.Assert(Arguments(i) IsNot Nothing)
             If Arguments(i) IsNot Nothing AndAlso Arguments(i).Expression IsNot Nothing Then
                 result(i) = Arguments(i).Expression.ExpressionType
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2574" endline="2590">
<![CDATA[
 
     Shared Function GetTypeOrTypeBuilders(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference(), Optional ByVal OnlySuccessful As Boolean = False) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         If Type Is Nothing Then Return Nothing
 
         ReDim result(Type.GetUpperBound(0))
         For i As Integer = 0 To Type.GetUpperBound(0)
             Dim tmp As Mono.Cecil.TypeReference
             tmp = GetTypeOrTypeBuilder(Compiler, Type(i))
             If tmp Is Nothing AndAlso OnlySuccessful Then
                 result(i) = Type(i)
             Else
                 result(i) = tmp
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="98" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="196" endline="215">
<![CDATA[
 
     Shared Function GetSetMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         Dim methodtypes As Mono.Cecil.TypeReference() = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, ranks + 1)
 
         methodtypes(ranks) = elementType
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Set", ArrayType, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, Mono.Cecil.MethodCallingConvention.Default)
 
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
         result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, elementType)))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="216" endline="232">
<![CDATA[
 
     Shared Function GetAddressMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         Dim methodtypes As Mono.Cecil.TypeReference() = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, ranks)
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Address", ArrayType, CecilHelper.MakeByRefType(elementType), True, False, Mono.Cecil.MethodCallingConvention.Default)
 
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="181" endline="195">
<![CDATA[
 
     Shared Function GetGetMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Get", ArrayType, elementType, True, False, Mono.Cecil.MethodCallingConvention.Default)
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="99" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1032" endline="1060">
<![CDATA[
 
 		//
 		// Returns a list of missing dependencies of this member. The list
 		// will contain types only but it can have numerous values for members
 		// like methods where both return type and all parameters are checked
 		//
 		public List<MissingType> GetMissingDependencies ()
 		{
 			if ((state & (StateFlags.MissingDependency | StateFlags.MissingDependency_Undetected)) == 0)
 				return null;
 
 			state &= ~StateFlags.MissingDependency_Undetected;
 
 			var imported = definition as ImportedDefinition;
 			List<MissingType> missing;
 			if (imported != null) {
 				missing = imported.ResolveMissingDependencies ();
 			} else if (this is ElementTypeSpec) {
 				missing = ((ElementTypeSpec) this).Element.GetMissingDependencies ();
 			} else {
 				missing = null;
 			}
 
 			if (missing != null) {
 				state |= StateFlags.MissingDependency;
 			}
 
 			return missing;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1130" endline="1154">
<![CDATA[
 
 		//
 		// Returns member CLS compliance based on full member hierarchy
 		//
 		public bool IsCLSCompliant ()
 		{
 			if ((state & StateFlags.CLSCompliant_Undetected) != 0) {
 				state &= ~StateFlags.CLSCompliant_Undetected;
 
 				if (IsNotCLSCompliant ())
 					return false;
 
 				bool compliant;
 				if (DeclaringType != null) {
 					compliant = DeclaringType.IsCLSCompliant ();
 				} else {
 					compliant = ((ITypeDefinition) MemberDefinition).DeclaringAssembly.IsCLSCompliant;
 				}
 
 				if (compliant)
 					state |= StateFlags.CLSCompliant;
 			}
 
 			return (state & StateFlags.CLSCompliant) != 0;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="100" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1642" endline="1663">
<![CDATA[
 
 		private static Type[] BindArray(Type[] array, IGenericBinder binder)
 		{
 			if (array ==null || array.Length == 0)
 			{
 				return array;
 			}
 			Type[] result = array;
 			for (int i = 0; i < array.Length; i++)
 			{
 				Type type = array[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(type, array[i]))
 				{
 					if (result == array)
 					{
 						result = (Type[])array.Clone();
 					}
 					result[i] = type;
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				Type type = array[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(type, array[i]))
 				{
 					if (result == array)
 					{
 						result = (Type[])array.Clone();
 					}
 					result[i] = type;
 				}
 			}
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="461" endline="481">
<![CDATA[
 
 		private static Type[] NormalizeAndCopy(Type[] array)
 		{
 			if (array == null || array.Length == 0)
 			{
 				return null;
 			}
 			Type[] copy = null;
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			return copy;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="101" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7871" endline="7889">
<![CDATA[
 
 		protected virtual void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			var nested = MemberCache.FindNestedType (expr_type, Name, -System.Math.Max (1, Arity));
 
 			if (nested != null) {
 				Error_TypeArgumentsCannotBeUsed (rc.Compiler.Report, expr.Location, nested, Arity);
 				return;
 			}
 
 			var any_other_member = MemberLookup (null, rc.CurrentType, expr_type, Name, 0, MemberLookupRestrictions.None, loc);
 			if (any_other_member != null) {
 				any_other_member.Error_UnexpectedKind (rc.Compiler.Report, null, "type", loc);
 				return;
 			}
 
 			rc.Compiler.Report.Error (426, loc, "The nested type `{0}' does not exist in the type `{1}'",
 				Name, expr_type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="161" endline="179">
<![CDATA[
 
 		public virtual void Error_NamespaceDoesNotExist (Location loc, string name, int arity, IMemberContext ctx)
 		{
 			FullNamedExpression retval = Lookup (ctx.Compiler, name, -System.Math.Max (1, arity), loc);
 			if (retval != null) {
 				Error_TypeArgumentsCannotBeUsed (ctx.Compiler.Report, loc, retval.Type, arity);
 				return;
 			}
 
 			Namespace ns;
 			if (arity > 0 && namespaces.TryGetValue (name, out ns)) {
 				ns.Error_TypeArgumentsCannotBeUsed (ctx.Compiler.Report, loc, null, arity);
 				return;
 			}
 
 			ctx.Compiler.Report.Error (234, loc,
 				"The type or namespace name `{0}' does not exist in the namespace `{1}'. Are you missing an assembly reference?",
 				name, GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="102" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1497" endline="1514">
<![CDATA[
 
 		internal bool IsAllowMultipleCustomAttribute
 		{
 			get
 			{
 				IList<CustomAttributeData> cad = GetCustomAttributesData(this.Module.universe.System_AttributeUsageAttribute);
 				if (cad.Count == 1)
 				{
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="594" endline="610">
<![CDATA[
 
 		private static bool IsInheritableAttribute(Type attribute)
 		{
 			Type attributeUsageAttribute = attribute.Module.universe.System_AttributeUsageAttribute;
 			IList<CustomAttributeData> attr = attribute.GetCustomAttributesData(attributeUsageAttribute);
 			if (attr.Count != 0)
 			{
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="921" endline="939">
<![CDATA[
 
 		//
 		// Test for a custom attribute type match. Custom attributes are not really predefined globaly 
 		// they can be assembly specific therefore we do check based on names only
 		//
 		public bool HasAttribute (IList<CustomAttributeData> attributesData, string attrName, string attrNamespace)
 		{
 			if (attributesData.Count == 0)
 				return false;
 
 			string ns, name;
 			foreach (var attr in attributesData) {
 				GetCustomAttributeTypeName (attr, out ns, out name);
 				if (name == attrName && ns == attrNamespace)
 					return true;
 			}
 			foreach (var attr in attributesData) {
 				GetCustomAttributeTypeName (attr, out ns, out name);
 				if (name == attrName && ns == attrNamespace)
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="369" endline="382">
<![CDATA[
 		}
 
 		public MemberInfo[] GetDefaultMembers()
 		{
 			Type defaultMemberAttribute = this.Module.universe.Import(typeof(System.Reflection.DefaultMemberAttribute));
 			foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(this))
 			{
 				if (cad.Constructor.DeclaringType.Equals(defaultMemberAttribute))
 				{
 					return GetMember((string)cad.ConstructorArguments[0].Value);
 				}
 			}
 			foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(this))
 			{
 				if (cad.Constructor.DeclaringType.Equals(defaultMemberAttribute))
 				{
 					return GetMember((string)cad.ConstructorArguments[0].Value);
 				}
 			}
 			return Empty<MemberInfo>.Array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1332" endline="1351">
<![CDATA[
 		}
 
 		#endregion
 
 		public void ReadAttributes ()
 		{
 			IList<CustomAttributeData> attrs = CustomAttributeData.GetCustomAttributes (module);
 
 			string ns, name;
 			foreach (var a in attrs) {
 				importer.GetCustomAttributeTypeName (a, out ns, out name);
 				if (name == "CLSCompliantAttribute") {
 					if (ns != "System")
 						continue;
 
 					cls_compliant = (bool) a.ConstructorArguments[0].Value;
 					continue;
 				}
 			}
 			foreach (var a in attrs) {
 				importer.GetCustomAttributeTypeName (a, out ns, out name);
 				if (name == "CLSCompliantAttribute") {
 					if (ns != "System")
 						continue;
 
 					cls_compliant = (bool) a.ConstructorArguments[0].Value;
 					continue;
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="103" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7997" endline="8012">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, false))
 				Expr = Expr.Resolve (ec);
 
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7935" endline="7950">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, true))
 				Expr = Expr.Resolve (ec);
 			
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="104" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3580" endline="3610">
<![CDATA[
 
     Shared Function GetPropertyAttributes(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
         Dim getA, setA As Mono.Cecil.MethodAttributes
         Dim getM, setM As Mono.Cecil.MethodDefinition
         Dim prop As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition([Property])
 
         getM = CecilHelper.FindDefinition(prop.GetMethod)
         setM = CecilHelper.FindDefinition(prop.SetMethod)
 
         Helper.Assert(getM IsNot Nothing OrElse setM IsNot Nothing)
 
         If getM IsNot Nothing Then
             getA = getM.Attributes
         End If
 
         If setM IsNot Nothing Then
             setA = setM.Attributes
         End If
 
         result = setA Or getA
 
         Dim visibility As Mono.Cecil.MethodAttributes
         visibility = result And Mono.Cecil.MethodAttributes.MemberAccessMask
         If visibility = Mono.Cecil.MethodAttributes.MemberAccessMask Then
             visibility = Mono.Cecil.MethodAttributes.Public
             result = (result And (Not Mono.Cecil.MethodAttributes.MemberAccessMask)) Or visibility
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3611" endline="3639">
<![CDATA[
 
     Shared Function GetEventAttributes(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim ev As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition([Event])
         Dim result As Mono.Cecil.MethodAttributes
         Dim getA, setA, raiseA As Mono.Cecil.MethodAttributes
         Dim getM, setM, raiseM As Mono.Cecil.MethodDefinition
 
         getM = ev.AddMethod
         setM = ev.RemoveMethod
         raiseM = ev.InvokeMethod
 
         Helper.Assert(getM IsNot Nothing OrElse setM IsNot Nothing OrElse raiseM IsNot Nothing)
 
         If getM IsNot Nothing Then
             getA = getM.Attributes
         End If
 
         If setM IsNot Nothing Then
             setA = setM.Attributes
         End If
 
         If raiseM IsNot Nothing Then
             raiseA = raiseM.Attributes
         End If
 
         result = setA Or getA Or raiseA
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="105" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="229" endline="245">
<![CDATA[
 
     Private Sub BeginFinallyBlockCecil()
         Log("BeginFinallyBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Finally)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.HandlerStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.TryEnd = ex.HandlerStart
         block.Handlers.Add(ex)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="199" endline="216">
<![CDATA[
 
     Private Sub BeginExceptFilterBlockCecil()
         Log("BeginExceptFilterBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Filter)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
 
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.FilterStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.HandlerStart = ex.FilterStart
         block.Handlers.Add(ex)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="106" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1667" endline="1682">
<![CDATA[
 		}
 
 		void CheckMemberUsage (List<MemberCore> al, string member_type)
 		{
 			if (al == null)
 				return;
 
 			foreach (MemberCore mc in al) {
 				if ((mc.ModFlags & Modifiers.AccessibilityMask) != Modifiers.PRIVATE)
 					continue;
 
 				if (!mc.IsUsed && (mc.caching_flags & Flags.Excluded) == 0) {
 					Report.Warning (169, 3, mc.Location, "The private {0} `{1}' is never used", member_type, mc.GetSignatureForError ());
 				}
 			}
 			foreach (MemberCore mc in al) {
 				if ((mc.ModFlags & Modifiers.AccessibilityMask) != Modifiers.PRIVATE)
 					continue;
 
 				if (!mc.IsUsed && (mc.caching_flags & Flags.Excluded) == 0) {
 					Report.Warning (169, 3, mc.Location, "The private {0} `{1}' is never used", member_type, mc.GetSignatureForError ());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="459" endline="478">
<![CDATA[
 
 		public void LoadModules (AssemblyDefinitionStatic assembly, RootNamespace targetNamespace)
 		{
 			if (RootContext.Modules.Count == 0)
 				return;
 
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (moduleName);
 				if (m == null)
 					continue;
 
 				if (m.IsManifestModule) {
 					Error_FileCorrupted (moduleName);
 					continue;
 				}
 
 				var md = importer.ImportModule (assembly.IncludeModule (m), targetNamespace);
 				assembly.AddModule (md);
 			}
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (moduleName);
 				if (m == null)
 					continue;
 
 				if (m.IsManifestModule) {
 					Error_FileCorrupted (moduleName);
 					continue;
 				}
 
 				var md = importer.ImportModule (assembly.IncludeModule (m), targetNamespace);
 				assembly.AddModule (md);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="560" endline="574">
<![CDATA[
 
 		public void LoadModules (AssemblyDefinitionDynamic assembly, RootNamespace targetNamespace)
 		{
 			if (RootContext.Modules.Count == 0)
 				return;
 
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (assembly, moduleName);
 				if (m == null)
 					continue;
 
 				var md = importer.ImportModule (m, targetNamespace);
 				assembly.AddModule (md);
 			}
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (assembly, moduleName);
 				if (m == null)
 					continue;
 
 				var md = importer.ImportModule (m, targetNamespace);
 				assembly.AddModule (md);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="107" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="968" endline="984">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			LabeledStatement s = current_vector.Block == null ? null 
 			if (s != null)
 				throw new InternalErrorException ("Shouldn't get here");
 
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddGotoOrigin (vector, goto_stmt);
 				if (errors == Report.Errors)
 					Report.Error (157, goto_stmt.loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new GotoOrigin (saved_origins, vector, goto_stmt);
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="693" endline="711">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			string name = goto_stmt.Target;
 			LabeledStatement s = Block.LookupLabel (name);
 			if (s != null)
 				throw new InternalErrorException ("Shouldn't get here");
 
 			if (Parent == null) {
 				Error_UnknownLabel (goto_stmt.loc, name, Report);
 				return false;
 			}
 
 			int errors = Report.Errors;
 			Parent.AddGotoOrigin (vector, goto_stmt);
 			if (errors == Report.Errors)
 				Report.Error (1632, goto_stmt.loc, "Control cannot leave the body of an anonymous method");
 			return false;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="108" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5320" endline="5343">
<![CDATA[
 
 		public override void Emit (EmitContext ec, bool leave_copy)
 		{
 			//
 			// Special case
 			//
 			if (IsSingleDimensionalArrayLength ()) {
 				if (!prepared)
 					EmitInstance (ec, false);
 				ec.Emit (OpCodes.Ldlen);
 				ec.Emit (OpCodes.Conv_I4);
 				return;
 			}
 
 			Invocation.EmitCall (ec, InstanceExpression, Getter, null, loc, prepared, false);
 			
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (!IsStatic) {
 					temp = new LocalTemporary (this.Type);
 					temp.Store (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4595" endline="4624">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2260" endline="2280">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Type == pa.StructLayout) {
 				PartialContainer.HasStructLayout = true;
 				if (a.IsExplicitLayoutKind ())
 					PartialContainer.HasExplicitLayout = true;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="109" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="502" endline="524">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			if (user_operator != null) {
 				user_operator.Emit (ec);
 			} else {
 				EmitOperator (ec, NullableInfo.GetUnderlyingType (type));
 			}
 
 			ec.Emit (OpCodes.Newobj, NullableInfo.GetConstructor (type));
 			ec.Emit (OpCodes.Br_S, end_label);
 
 			ec.MarkLabel (is_null_label);
 			LiftedNull.Create (type, loc).Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4497" endline="4517">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label false_target = ec.DefineLabel ();
 			Label end_target = ec.DefineLabel ();
 
 			expr.EmitBranchable (ec, false_target, false);
 			true_expr.Emit (ec);
 
 			if (type.IsInterface) {
 				LocalBuilder temp = ec.GetTemporaryLocal (type);
 				ec.Emit (OpCodes.Stloc, temp);
 				ec.Emit (OpCodes.Ldloc, temp);
 				ec.FreeTemporaryLocal (temp, type);
 			}
 
 			ec.Emit (OpCodes.Br, end_target);
 			ec.MarkLabel (false_target);
 			false_expr.Emit (ec);
 			ec.MarkLabel (end_target);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1247" endline="1268">
<![CDATA[
 
 		void DoEmit (EmitContext ec, bool is_expr)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			if (is_expr) {
 				underlying.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end_label);
 			} else {
 				underlying.EmitStatement (ec);
 			}
 
 			ec.MarkLabel (is_null_label);
 			if (is_expr)
 				LiftedNull.Create (type, loc).Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="110" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2454" endline="2480">
<![CDATA[
 		}
 
 		#endregion
 
 		// <summary>
 		//   Check whether all `out' parameters have been assigned.
 		// </summary>
 		public void CheckOutParameters (FlowBranching.UsageVector vector, Location loc)
 		{
 			if (vector.IsUnreachable)
 				return;
 
 			int n = parameter_info == null ? 0 
 
 			for (int i = 0; i < n; i++) {
 				VariableInfo var = parameter_info[i].VariableInfo;
 
 				if (var == null)
 					continue;
 
 				if (vector.IsAssigned (var, false))
 					continue;
 
 				TopBlock.Report.Error (177, loc, "The out parameter `{0}' must be assigned to before control leaves the current method",
 					var.Name);
 			}
 			for (int i = 0; i < n; i++) {
 				VariableInfo var = parameter_info[i].VariableInfo;
 
 				if (var == null)
 					continue;
 
 				if (vector.IsAssigned (var, false))
 					continue;
 
 				TopBlock.Report.Error (177, loc, "The out parameter `{0}' must be assigned to before control leaves the current method",
 					var.Name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2515" endline="2531">
<![CDATA[
 
 		protected void ProcessParameters ()
 		{
 			if (parameters.Count == 0)
 				return;
 
 			parameter_info = new ParameterInfo[parameters.Count];
 			for (int i = 0; i < parameter_info.Length; ++i) {
 				var p = parameters.FixedParameters[i];
 				if (p == null)
 					continue;
 
 				// TODO
 				parameter_info[i] = new ParameterInfo (this, i);
 				AddLocalName (p.Name, parameter_info[i]);
 			}
 			for (int i = 0; i < parameter_info.Length; ++i) {
 				var p = parameters.FixedParameters[i];
 				if (p == null)
 					continue;
 
 				// TODO
 				parameter_info[i] = new ParameterInfo (this, i);
 				AddLocalName (p.Name, parameter_info[i]);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="111" nfragments="12" Csharpe_files="12" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="723" endline="735">
<![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="580" endline="591">
<![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="525" endline="536">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			flags |= ec.HasSet (ResolveContext.Options.CheckedScope) ? CSharpBinderFlags.CheckedContext 
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			return new Invocation (GetBinder ("Convert", loc), binder_args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="547" endline="557">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (0, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			return new Invocation (GetBinder ("InvokeConstructor", loc), binder_args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8786" endline="8795">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (source.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			args.Add (new Argument (new TypeOfMethod (method, loc)));
 			return CreateExpressionFactoryCall (ec, "Convert", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4427" endline="4436">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (expr.CreateExpressionTree (ec)));
 			args.Add (new Argument (true_expr.CreateExpressionTree (ec)));
 			args.Add (new Argument (false_expr.CreateExpressionTree (ec)));
 			return CreateExpressionFactoryCall (ec, "Condition", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="159" endline="167">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7108" endline="7118">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7293" endline="7300">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1655" endline="1662">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9525" endline="9536">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (base.CreateExpressionTree (ec)));
 			if (!initializers.IsEmpty)
 				args.Add (new Argument (initializers.CreateExpressionTree (ec)));
 
 			return CreateExpressionFactoryCall (ec,
 				initializers.IsCollectionInitializer ? "ListInit" 
 				args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="290" endline="309">
<![CDATA[
 
 		protected static Expression CreateRangeVariableType (ResolveContext rc, Parameter parameter, RangeVariable name, Expression init)
 		{
 			var args = new List<AnonymousTypeParameter> (2);
 
 			//
 			// The first argument is the reference to the parameter
 			//
 			args.Add (new AnonymousTypeParameter (new RangeParameterReference (parameter), parameter.Name, parameter.Location));
 
 			//
 			// The second argument is the linq expression
 			//
 			args.Add (new RangeAnonymousTypeParameter (init, name));
 
 			//
 			// Create unique anonymous type
 			//
 			return new NewAnonymousType (args, rc.MemberContext.CurrentMemberDefinition.Parent, name.Location);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="112" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="177" endline="196">
<![CDATA[
 
 		internal void WriteCompressedInt(int value)
 		{
 			if (value <= 0x7F)
 			{
 				Write((byte)value);
 			}
 			else if (value <= 0x3FFF)
 			{
 				Write((byte)(0x80 | (value >> 8)));
 				Write((byte)value);
 			}
 			else
 			{
 				Write((byte)(0xC0 | (value >> 24)));
 				Write((byte)(value >> 16));
 				Write((byte)(value >> 8));
 				Write((byte)value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="114" endline="133">
<![CDATA[
 
 		internal void WriteCompressedInt(int value)
 		{
 			if (value <= 0x7F)
 			{
 				Write((byte)value);
 			}
 			else if (value <= 0x3FFF)
 			{
 				Write((byte)(0x80 | (value >> 8)));
 				Write((byte)value);
 			}
 			else
 			{
 				Write((byte)(0xC0 | (value >> 24)));
 				Write((byte)(value >> 16));
 				Write((byte)(value >> 8));
 				Write((byte)value);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="113" nfragments="25" Csharpe_files="0" vb_files="25" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="84" endline="94">
<![CDATA[
     End Property
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Sub AndAlso tm.PeekToken(i + 2).IsIdentifier
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="43" endline="52">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Function
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="179" endline="188">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.OperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.OperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         If IsOverloadableOperator(tm.PeekToken(i + 1)) = False Then Return False
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="370" endline="378">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Sub) = False Then Return False
         Return tm.PeekToken(i + 1).Equals(KS.[New])
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="79" endline="87">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         Return IsOverloadableConversionOperator(tm.PeekToken(i + 1))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="41" endline="48">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals("Custom") AndAlso tm.PeekToken(i + 1).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="145" endline="153">
<![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Sub AndAlso tm.PeekToken(i + 1).IsIdentifier
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="276" endline="287">
<![CDATA[
 
     ''' <summary>
     ''' Checks for this grammar
     ''' VariableMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         Return i > 0 AndAlso tm.PeekToken(i).IsIdentifier
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceSubDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Sub)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfacePropertyMemberDeclaration.vb" startline="33" endline="40">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceFunctionDeclaration.vb" startline="36" endline="43">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Function)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="541" endline="548">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Class)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MustOverridePropertyDeclaration.vb" startline="32" endline="39">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceEventMemberDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="183" endline="190">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Delegate)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="75" endline="82">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Module)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularPropertyDeclaration.vb" startline="35" endline="42">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="72" endline="79">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Interface)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Enum)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="44" endline="51">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Structure)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Function
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" startline="75" endline="82">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Get
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="63" endline="74">
<![CDATA[
 
     ''' <summary>
     ''' Checks for the following grammar
     ''' ConstantMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Const
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="114" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="86" endline="102">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) AndAlso CBool(rvalue)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="83" endline="99">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) OrElse CBool(rvalue)
             End If
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="115" nfragments="12" Csharpe_files="12" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="142" endline="169">
<![CDATA[
 
 		internal int ReadMemberRefParent()
 		{
 			int codedIndex;
 			if (bigMemberRefParent)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 3);
 				case 1
 					return (TypeRefTable.Index << 24) + (codedIndex >> 3);
 				case 2
 					return (ModuleRefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 4
 					return (TypeSpecTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="92" endline="117">
<![CDATA[
 
 		internal int ReadResolutionScope()
 		{
 			int codedIndex;
 			if (bigResolutionScope)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (ModuleTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ModuleRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 3
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="408" endline="431">
<![CDATA[
 
 		internal int ReadImplementation()
 		{
 			int codedIndex;
 			if (bigImplementation)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FileTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (ExportedTypeTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="340" endline="363">
<![CDATA[
 
 		internal int ReadHasDeclSecurity()
 		{
 			int codedIndex;
 			if (bigHasDeclSecurity)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="272" endline="295">
<![CDATA[
 
 		internal int ReadHasConstant()
 		{
 			int codedIndex;
 			if (bigHasConstant)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (PropertyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="118" endline="141">
<![CDATA[
 
 		internal int ReadTypeDefOrRef()
 		{
 			int codedIndex;
 			if (bigTypeDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (TypeSpecTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
<![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="250" endline="271">
<![CDATA[
 
 		internal int ReadMethodDefOrRef()
 		{
 			int codedIndex;
 			if (bigMethodDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MemberRefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="386" endline="407">
<![CDATA[
 
 		internal int ReadMemberForwarded()
 		{
 			int codedIndex;
 			if (bigMemberForwarded)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="296" endline="317">
<![CDATA[
 
 		internal int ReadHasSemantics()
 		{
 			int codedIndex;
 			if (bigHasSemantics)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (EventTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (PropertyTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="364" endline="385">
<![CDATA[
 
 		internal int ReadTypeOrMethodDef()
 		{
 			int codedIndex;
 			if (bigTypeOrMethodDef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="318" endline="339">
<![CDATA[
 
 		internal int ReadHasFieldMarshal()
 		{
 			int codedIndex;
 			if (bigHasFieldMarshal)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="116" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7599" endline="7618">
<![CDATA[
 
 		Expression DoResolveName (ResolveContext rc, Expression right_side)
 		{
 			Expression e = LookupNameExpression (rc, right_side == null ? MemberLookupRestrictions.ReadAccess 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 					e.Error_UnexpectedKind (rc, ResolveFlags.VariableOrValue, loc);
 					return null;
 				}
 
 				e = e.ResolveLValue (rc, right_side);
 			} else {
 				e = e.Resolve (rc, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 			}
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2436" endline="2457">
<![CDATA[
 		
 		Expression SimpleNameResolve (ResolveContext ec, Expression right_side, bool intermediate)
 		{
 			Expression e = LookupNameExpression (ec, right_side == null ? MemberLookupRestrictions.ReadAccess 
 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 				    e.Error_UnexpectedKind (ec, ResolveFlags.VariableOrValue, loc);
 				    return null;
 				}
 
 				e = e.ResolveLValue (ec, right_side);
 			} else {
 				e = e.Resolve (ec);
 			}
 
 			//if (ec.CurrentBlock == null || ec.CurrentBlock.CheckInvariantMeaningInBlock (Name, e, Location))
 			return e;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="117" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="781" endline="791">
<![CDATA[
 
 		public void EmitCalli(OpCode opc, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
 		{
 			returnType = returnType ?? moduleBuilder.universe.System_Void;
 			optionalParameterTypes = optionalParameterTypes ?? Type.EmptyTypes;
 			Emit(opc);
 			UpdateStack(opc, (callingConvention & CallingConventions.HasThis | CallingConventions.ExplicitThis) == CallingConventions.HasThis, returnType, parameterTypes.Length + optionalParameterTypes.Length);
 			ByteBuffer sig = new ByteBuffer(16);
 			Signature.WriteStandAloneMethodSig(moduleBuilder, sig, callingConvention, returnType, parameterTypes, optionalParameterTypes);
 			code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(sig)));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="771" endline="780">
<![CDATA[
 
 		public void EmitCalli(OpCode opc, CallingConvention callingConvention, Type returnType, Type[] parameterTypes)
 		{
 			returnType = returnType ?? moduleBuilder.universe.System_Void;
 			Emit(opc);
 			UpdateStack(opc, false, returnType, parameterTypes.Length);
 			ByteBuffer sig = new ByteBuffer(16);
 			Signature.WriteStandAloneMethodSig(moduleBuilder, sig, callingConvention, returnType, parameterTypes);
 			code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(sig)));
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="118" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1676" endline="1689">
<![CDATA[
 
 		public static MyBitVector operator | (MyBitVector a, MyBitVector b)
 		{
 			if (a == b)
 				return a;
 			if (a == null)
 				return new MyBitVector (null, b.Count);
 			if (b == null)
 				return new MyBitVector (null, a.Count);
 			if (a.Count > b.Count)
 				return a.Clone ().Or (b);
 			else
 				return b.Clone ().Or (a);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1662" endline="1675">
<![CDATA[
 
 		public static MyBitVector operator & (MyBitVector a, MyBitVector b)
 		{
 			if (a == b)
 				return a;
 			if (a == null)
 				return b.Clone ();
 			if (b == null)
 				return a.Clone ();
 			if (a.Count > b.Count)
 				return a.Clone ().And (b);
 			else
 				return b.Clone ().And (a);					
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1540" endline="1558">
<![CDATA[
 
 		// <summary>
 		//   Get/set bit `index' in the bit vector.
 		// </summary>
 		public bool this [int index] {
 			get {
 				if (index >= Count)
 					// FIXME
 					// throw new ArgumentOutOfRangeException ();
 					return true; 
 
 				if (vector != null)
 					return vector [index];
 				if (shared == null)
 					return true;
 				if (index < shared.Count)
 					return shared [index];
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="198" endline="217">
<![CDATA[
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			//
 			// When delegate returns void, only expression statements can be used
 			//
 			if (ec.ReturnType == TypeManager.void_type) {
 				Expr = Expr.Resolve (ec);
 				if (Expr == null)
 					return false;
 
 				statement = Expr as ExpressionStatement;
 				if (statement == null)
 					Expr.Error_InvalidExpressionStatement (ec);
 
 				return true;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5649" endline="5666">
<![CDATA[
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.EventAddition) {
 				op = spec.AccessorAdd;
 			} else if (right_side == EmptyExpression.EventSubtraction) {
 				op = spec.AccessorRemove;
 			}
 
 			if (op == null) {
 				Error_AssignmentEventOnly (ec);
 				return null;
 			}
 
 			op = CandidateToBaseOverride (ec, op);
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="119" nfragments="8" Csharpe_files="8" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="640" endline="653">
<![CDATA[
 
 		internal MethodBase GetMethodAt(TypeDefImpl owner, int index)
 		{
 			if (methods == null)
 			{
 				methods = new MethodBase[MethodDef.records.Length];
 			}
 			if (methods[index] == null)
 			{
 				MethodDefImpl method = new MethodDefImpl(this, owner ?? FindMethodOwner(index), index);
 				methods[index] = method.IsConstructor ? new ConstructorInfoImpl(method) 
 			}
 			return methods[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="593" endline="605">
<![CDATA[
 
 		internal FieldInfo GetFieldAt(TypeDefImpl owner, int index)
 		{
 			if (fields == null)
 			{
 				fields = new FieldInfo[Field.records.Length];
 			}
 			if (fields[index] == null)
 			{
 				fields[index] = new FieldDefImpl(this, owner ?? FindFieldOwner(index), index);
 			}
 			return fields[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="491" endline="503">
<![CDATA[
 
 		private Assembly ResolveAssemblyRef(int index)
 		{
 			if (assemblyRefs == null)
 			{
 				assemblyRefs = new Assembly[AssemblyRef.RowCount];
 			}
 			if (assemblyRefs[index] == null)
 			{
 				assemblyRefs[index] = ResolveAssemblyRefImpl(ref AssemblyRef.records[index]);
 			}
 			return assemblyRefs[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3083" endline="3096">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (best_candidate == null) {
 				ec.Report.Error (1953, loc, "An expression tree cannot contain an expression with method group");
 				return null;
 			}
 
 			if (best_candidate.IsConditionallyExcluded (loc))
 				ec.Report.Error (765, loc,
 					"Partial methods with only a defining declaration or removed conditional methods cannot be used in an expression tree");
 			
 			return new TypeOfMethod (best_candidate, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="950" endline="966">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			if (ec.Switch == null) {
 				ec.Report.Error (153, loc, "A goto case is only valid inside a switch statement");
 				return false;
 			}
 
 			if (!ec.Switch.GotDefault) {
 				FlowBranchingBlock.Error_UnknownLabel (loc, "default", ec.Report);
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="166" endline="182">
<![CDATA[
 		}
 
 		internal override int ImportTo(ModuleBuilder other)
 		{
 			if (typeBuilder.IsGenericTypeDefinition)
 			{
 				return other.ImportMember(TypeBuilder.GetField(typeBuilder, this));
 			}
 			else if (other == typeBuilder.ModuleBuilder)
 			{
 				return pseudoToken;
 			}
 			else
 			{
 				return other.ImportMethodOrField(typeBuilder, name, fieldSig);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="670" endline="686">
<![CDATA[
 		}
 
 		internal override int ImportTo(ModuleBuilder other)
 		{
 			if (typeBuilder.IsGenericTypeDefinition)
 			{
 				return other.ImportMember(TypeBuilder.GetMethod(typeBuilder, this));
 			}
 			else if (other == typeBuilder.ModuleBuilder)
 			{
 				return pseudoToken;
 			}
 			else
 			{
 				return other.ImportMethodOrField(typeBuilder, name, this.MethodSignature);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1762" endline="1780">
<![CDATA[
 
 		protected override bool AddToContainer (MemberCore symbol, string name)
 		{
 			MemberCore mc = GetDefinition (name);
 
 			if (mc == null) {
 				defined_names.Add (name, symbol);
 				return true;
 			}
 
 			// A conflict between anonymous type members will be reported
 			if (symbol is TypeParameter) {
 				Report.SymbolRelatedToPreviousError (symbol);
 				return false;
 			}
 
 			// Ignore other conflicts
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="120" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="53" endline="68">
<![CDATA[
 
 		protected override MemberKind DetermineKindFromBaseType (MetaType baseType)
 		{
 			string name = baseType.Name;
 
 			if (name == "ValueType" && baseType.Namespace == "System")
 				return MemberKind.Struct;
 
 			if (name == "Enum" && baseType.Namespace == "System")
 				return MemberKind.Enum;
 
 			if (name == "MulticastDelegate" && baseType.Namespace == "System")
 				return MemberKind.Delegate;
 
 			return MemberKind.Class;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6879" endline="6892">
<![CDATA[
 
 		public static bool IsThisAvailable (ResolveContext ec, bool ignoreAnonymous)
 		{
 			if (ec.IsStatic || ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.BaseInitializer | ResolveContext.Options.ConstantScope))
 				return false;
 
 			if (ignoreAnonymous || ec.CurrentAnonymousMethod == null)
 				return true;
 
 			if (TypeManager.IsStruct (ec.CurrentType) && ec.CurrentIterator == null)
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="121" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="167" endline="185">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (parameters.HasArglist) {
 				Report.Warning (3000, 1, Location, "Methods with variable arguments are not CLS-compliant");
 			}
 
 			if (member_type != null && !member_type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 
 			parameters.VerifyClsCompliance (this);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2012" endline="2031">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			// Check this name against other containers
 			NamespaceEntry.NS.VerifyClsCompliance ();
 
 			// Check all container names for user classes
 			if (Kind != MemberKind.Delegate)
 				MemberCache.VerifyClsCompliance (Definition, Report);
 
 			if (BaseType != null && !BaseType.IsCLSCompliant ()) {
 				Report.Warning (3009, 1, Location, "`{0}'
 					GetSignatureForError (), BaseType.GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="122" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="53" endline="70">
<![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject)
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="71" endline="88">
<![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="123" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1159" endline="1173">
<![CDATA[
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1185" endline="1199">
<![CDATA[
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="124" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="302" endline="326">
<![CDATA[
 
 		public Type GetType(string className, bool throwOnError, bool ignoreCase)
 		{
 			if (ignoreCase)
 			{
 				throw new NotImplementedException();
 			}
 			TypeNameParser parser = TypeNameParser.Parse(className, throwOnError);
 			if (parser.Error)
 			{
 				return null;
 			}
 			if (parser.AssemblyName != null)
 			{
 				if (throwOnError)
 				{
 					throw new ArgumentException("Type names passed to Module.GetType() must not specify an assembly.");
 				}
 				else
 				{
 					return null;
 				}
 			}
 			return parser.Expand(GetTypeImpl(parser.FirstNamePart), this.Assembly, throwOnError, className);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="92" endline="112">
<![CDATA[
 
 		public Type GetType(string typeName, bool throwOnError)
 		{
 			TypeNameParser parser = TypeNameParser.Parse(typeName, throwOnError);
 			if (parser.Error)
 			{
 				return null;
 			}
 			if (parser.AssemblyName != null)
 			{
 				if (throwOnError)
 				{
 					throw new ArgumentException("Type names passed to Assembly.GetType() must not specify an assembly.");
 				}
 				else
 				{
 					return null;
 				}
 			}
 			return parser.Expand(GetTypeImpl(parser.FirstNamePart), this, throwOnError, typeName);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="125" nfragments="11" Csharpe_files="2" vb_files="9" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="373" endline="397">
<![CDATA[
 
     Shared Function GetErrorNumberForConversion(ByVal tp1 As TypeCode, ByVal tp2 As TypeCode, ByVal Implicit As Boolean) As Integer
         Select Case GetConversionResultType(tp1, tp2)
             Case "X"c
                 Throw New NotImplementedException
             Case "I"c
                 Return 0
             Case "0"c
                 Return 0
             Case "1"c
                 Return 30311
             Case "2"c
                 Return 32007
             Case "3"c
                 Return 30533
             Case "4"c
                 Return 32006
             Case "5"c
                 Return 30532
             Case "6"c
                 Return 30533
             Case Else
                 Throw New NotImplementedException
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="651" endline="670">
<![CDATA[
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="619" endline="638">
<![CDATA[
 
     Shared Function GetVisibility(ByVal Attributes As Mono.Cecil.MethodAttributes) As ModifierMasks
         Dim attrib As Mono.Cecil.MethodAttributes = Attributes And Mono.Cecil.MethodAttributes.MemberAccessMask
         Select Case attrib
             Case Mono.Cecil.MethodAttributes.Private, Mono.Cecil.MethodAttributes.CompilerControlled
                 Return ModifierMasks.Private
             Case Mono.Cecil.MethodAttributes.FamANDAssem
                 Throw New NotImplementedException
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return ModifierMasks.Friend
             Case Mono.Cecil.MethodAttributes.Family
                 Return ModifierMasks.Protected
             Case Mono.Cecil.MethodAttributes.FamORAssem
                 Return ModifierMasks.Protected Or ModifierMasks.Friend
             Case Mono.Cecil.MethodAttributes.Public
                 Return ModifierMasks.Public
             Case Else
                 Throw New InternalException(String.Format("Attributes
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="639" endline="657">
<![CDATA[
 
     Shared Function GetVisibility(ByVal Attributes As Mono.Cecil.FieldAttributes) As ModifierMasks
         Select Case Attributes And Mono.Cecil.FieldAttributes.FieldAccessMask
             Case Mono.Cecil.FieldAttributes.Private
                 Return ModifierMasks.Private
             Case Mono.Cecil.FieldAttributes.FamANDAssem
                 Throw New NotImplementedException
             Case Mono.Cecil.FieldAttributes.Assembly
                 Return ModifierMasks.Friend
             Case Mono.Cecil.FieldAttributes.Family
                 Return ModifierMasks.Protected
             Case Mono.Cecil.FieldAttributes.FamORAssem
                 Return ModifierMasks.Protected Or ModifierMasks.Friend
             Case Mono.Cecil.FieldAttributes.Public
                 Return ModifierMasks.Public
             Case Else
                 Throw New InternalException
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3139" endline="3158">
<![CDATA[
 
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.FieldAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.FieldAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.FieldAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.FieldAttributes.Public
                 Return "Public"
             Case Mono.Cecil.FieldAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3159" endline="3177">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.MethodAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.MethodAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3523" endline="3540">
<![CDATA[
 
     Shared Function GetMethodAccessibilityString(ByVal Attributes As Mono.Cecil.MethodAttributes) As String
         Attributes = Attributes And Mono.Cecil.MethodAttributes.MemberAccessMask
         Select Case Attributes
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Mono.Cecil.MethodAttributes.FamANDAssem, Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Else
                 Return "Public"
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="658" endline="676">
<![CDATA[
 
     Shared Function GetVisibility(ByVal Attributes As Mono.Cecil.TypeAttributes) As ModifierMasks
         Select Case Attributes And Mono.Cecil.TypeAttributes.VisibilityMask
             Case Mono.Cecil.TypeAttributes.NestedPrivate, Mono.Cecil.TypeAttributes.NotPublic
                 Return ModifierMasks.Private
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Throw New NotImplementedException
             Case Mono.Cecil.TypeAttributes.NestedAssembly
                 Return ModifierMasks.Friend
             Case Mono.Cecil.TypeAttributes.NestedFamily
                 Return ModifierMasks.Protected
             Case Mono.Cecil.TypeAttributes.NestedFamORAssem
                 Return ModifierMasks.Protected Or ModifierMasks.Friend
             Case Mono.Cecil.TypeAttributes.NestedPublic, Mono.Cecil.TypeAttributes.Public
                 Return ModifierMasks.Public
             Case Else
                 Throw New InternalException
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3178" endline="3196">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.TypeAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.TypeAttributes.NestedFamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Return "Protected"
             Case Mono.Cecil.TypeAttributes.NestedAssembly, Mono.Cecil.TypeAttributes.NotPublic
                 Return "Friend"
             Case Mono.Cecil.TypeAttributes.NestedPublic, Mono.Cecil.TypeAttributes.Public
                 Return "Public"
             Case Mono.Cecil.TypeAttributes.NestedPrivate
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="719" endline="748">
<![CDATA[
 		
 		public virtual string ExprClassName
 		{
 			get {
 				switch (eclass){
 				case ExprClass.Unresolved
 					return "Unresolved";
 				case ExprClass.Value
 					return "value";
 				case ExprClass.Variable
 					return "variable";
 				case ExprClass.Namespace
 					return "namespace";
 				case ExprClass.Type
 					return "type";
 				case ExprClass.MethodGroup
 					return "method group";
 				case ExprClass.PropertyAccess
 					return "property access";
 				case ExprClass.EventAccess
 					return "event access";
 				case ExprClass.IndexerAccess
 					return "indexer access";
 				case ExprClass.Nothing
 					return "null";
 				case ExprClass.TypeParameter
 					return "type parameter";
 				}
 				throw new Exception ("Should not happen");
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="512" endline="540">
<![CDATA[
 
 		static string descape (char c)
 		{
 			switch (c){
 			case '\a'
 				return "\\a"; 
 			case '\b'
 				return "\\b"; 
 			case '\n'
 				return "\\n"; 
 			case '\t'
 				return "\\t"; 
 			case '\v'
 				return "\\v"; 
 			case '\r'
 				return "\\r"; 
 			case '\\'
 				return "\\\\";
 			case '\f'
 				return "\\f"; 
 			case '\0'
 				return "\\0"; 
 			case '"'
 				return "\\\""; 
 			case '\''
 				return "\\\'"; 
 			}
 			return c.ToString ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="126" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="450" endline="469">
<![CDATA[
 		List<CapturedVariable> captured_vars = new List<CapturedVariable> ();
 		List<CapturedScope> captured_scopes = new List<CapturedScope> ();
 
 		public AnonymousScopeEntry (int id)
 		{
 			this.ID = id;
 		}
 
 		internal AnonymousScopeEntry (MyBinaryReader reader)
 		{
 			ID = reader.ReadLeb128 ();
 
 			int num_captured_vars = reader.ReadLeb128 ();
 			for (int i = 0; i < num_captured_vars; i++)
 				captured_vars.Add (new CapturedVariable (reader));
 			for (int i = 0; i < num_captured_vars; i++)
 				captured_vars.Add (new CapturedVariable (reader));
 
 			int num_captured_scopes = reader.ReadLeb128 ();
 			for (int i = 0; i < num_captured_scopes; i++)
 				captured_scopes.Add (new CapturedScope (reader));
 			for (int i = 0; i < num_captured_scopes; i++)
 				captured_scopes.Add (new CapturedScope (reader));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="151" endline="166">
<![CDATA[
 
 		private static int ReadArrayShape(ByteReader br)
 		{
 			int rank = br.ReadCompressedInt();
 			int numSizes = br.ReadCompressedInt();
 			for (int i = 0; i < numSizes; i++)
 			{
 				br.ReadCompressedInt();
 			}
 			for (int i = 0; i < numSizes; i++)
 			{
 				br.ReadCompressedInt();
 			}
 			int numLoBounds = br.ReadCompressedInt();
 			for (int i = 0; i < numLoBounds; i++)
 			{
 				br.ReadCompressedInt();
 			}
 			for (int i = 0; i < numLoBounds; i++)
 			{
 				br.ReadCompressedInt();
 			}
 			return rank;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="127" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1826" endline="1837">
<![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitStoreVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitStoreField(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitStoreVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1562" endline="1573">
<![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitLoadVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="165" endline="174">
<![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If m_LocalBuilder IsNot Nothing Then
             Emitter.EmitStoreVariable(Info, m_LocalBuilder)
         ElseIf FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="128" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="267" endline="283">
<![CDATA[
 
 		private LineNumberEntry [] method_lines;
 		private int method_lines_pos = 0;
 
 		public void MarkSequencePoint (int offset, SourceFileEntry file, int line, int column,
 					       bool is_hidden)
 		{
 			if (method_lines_pos == method_lines.Length) {
 				LineNumberEntry [] tmp = method_lines;
 				method_lines = new LineNumberEntry [method_lines.Length * 2];
 				Array.Copy (tmp, method_lines, method_lines_pos);
 			}
 
 			int file_idx = file != null ? file.Index 
 			method_lines [method_lines_pos++] = new LineNumberEntry (
 				file_idx, line, offset, is_hidden);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="401" endline="413">
<![CDATA[
 		}
 
 		internal int AddRecord(T newRecord)
 		{
 			if (rowCount == records.Length)
 			{
 				T[] newarr = new T[records.Length * 2];
 				Array.Copy(records, newarr, records.Length);
 				records = newarr;
 			}
 			records[rowCount++] = newRecord;
 			return rowCount;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="129" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2127" endline="2154">
<![CDATA[
 
 		TypeSpec LookupNestedTypeInHierarchy (string name, int arity)
 		{
 			// TODO
 			if (PartialContainer == null)
 				return null;
 
 			// Has any nested type
 			// Does not work, because base type can have
 			//if (PartialContainer.Types == null)
 			//	return null;
 
 			var container = PartialContainer.CurrentType;
 
 			// Is not Root container
 			if (container == null)
 				return null;
 
 			var t = MemberCache.FindNestedType (container, name, arity);
 			if (t == null)
 				return null;
 
 			// FIXME
 			if (!t.IsAccessible (CurrentType))
 				return null;
 
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="768" endline="785">
<![CDATA[
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5442" endline="5461">
<![CDATA[
 		}
 
 		#endregion
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, null);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.Resolve (ec);
 			}
 
 			if (!ResolveGetter (ec))
 				return null;
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="130" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="227" endline="247">
<![CDATA[
     End Property
 
     ReadOnly Property CanBePropertyAccessClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.PropertyGroup
                     Return True
                 Case Classifications.LateBoundAccess
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBePropertyAccessClassification
                 Case Classifications.Value, Classifications.Variable, Classifications.EventAccess, _
 Classifications.LateBoundAccess, Classifications.MethodGroup, _
 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.Void, Classifications.Namespace
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="208" endline="226">
<![CDATA[
     End Property
 
     ReadOnly Property CanBeValueClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.Value, Classifications.Variable, _
                 Classifications.LateBoundAccess, Classifications.MethodGroup, _
                 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.PropertyGroup
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBeValueClassification
                 Case Classifications.Void, Classifications.Namespace, Classifications.EventAccess
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="131" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9356" endline="9367">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			var expr_initializers = new ArrayInitializer (initializers.Count, loc);
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 
 			return new ImplicitlyTypedArrayCreation (expr_initializers, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="652" endline="665">
<![CDATA[
 
 		internal static void WriteLocalVarSig(ModuleBuilder module, ByteBuffer bb, IList<LocalBuilder> locals)
 		{
 			bb.Write(LOCAL_SIG);
 			bb.WriteCompressedInt(locals.Count);
 			foreach (LocalBuilder local in locals)
 			{
 				if (local.IsPinned)
 				{
 					bb.Write(ELEMENT_TYPE_PINNED);
 				}
 				WriteType(module, bb, local.LocalType);
 			}
 			foreach (LocalBuilder local in locals)
 			{
 				if (local.IsPinned)
 				{
 					bb.Write(ELEMENT_TYPE_PINNED);
 				}
 				WriteType(module, bb, local.LocalType);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="132" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="975" endline="990">
<![CDATA[
 	
 	static int ComparePropertyInfo (object a, object b)
 	{
 		PropertyInfo aa = (PropertyInfo) a, bb = (PropertyInfo) b;
 		
 		bool astatic = (aa.CanRead ? aa.GetGetMethod (true) 
 		bool bstatic = (bb.CanRead ? bb.GetGetMethod (true) 
 		
 		if (astatic == bstatic)
 			return CompareMemberInfo (a, b);
 		
 		if (astatic)
 			return -1;
 		
 		return 1;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="999" endline="1014">
<![CDATA[
 	
 	static int CompareEventInfo (object a, object b)
 	{
 		EventInfo aa = (EventInfo) a, bb = (EventInfo) b;
 		
 		bool astatic = aa.GetAddMethod (true).IsStatic;
 		bool bstatic = bb.GetAddMethod (true).IsStatic;
 		
 		if (astatic == bstatic)
 			return CompareMemberInfo (a, b);
 		
 		if (astatic)
 			return -1;
 		
 		return 1;
 	}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="133" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="76" endline="93">
<![CDATA[
 
     Sub Init(ByVal ArrayType As Mono.Cecil.TypeReference, ByVal ArrayBounds() As Expression, ByVal InitializerElements As Expression())
         m_ExpressionType = ArrayType
 
         If ArrayBounds IsNot Nothing Then
             m_ArrayNameModifier = New ArrayNameModifier(Me)
             Dim newSizes As New ArraySizeInitializationModifier(Me)
             Dim bounds As New BoundList(newSizes)
             bounds.Init(ArrayBounds)
             newSizes.Init(bounds, Nothing)
             m_ArrayNameModifier.Init(newSizes)
         End If
 
         If InitializerElements IsNot Nothing Then
             m_ArrayElementInitializer = New ArrayElementInitializer(Me)
             m_ArrayElementInitializer.Init(InitializerElements)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="113" endline="124">
<![CDATA[
 
     Sub CloneTo(ByVal ClonedSignature As SubSignature)
         ClonedSignature.m_Identifier = m_Identifier
         If m_TypeParameters IsNot Nothing Then
             ClonedSignature.m_TypeParameters = m_TypeParameters.Clone()
             ClonedSignature.m_TypeParameters.Initialize(ClonedSignature)
         End If
         If m_ParameterList IsNot Nothing Then
             ClonedSignature.m_ParameterList = m_ParameterList.Clone(ClonedSignature)
             ClonedSignature.m_ParameterList.Initialize(ClonedSignature)
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="134" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5600" endline="5613">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args;
 			if (method == null) {
 				args = new Arguments (1);
 				args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			} else {
 				args = Arguments.CreateForExpressionTree (ec,
 					arguments, new TypeOfMethod (method, loc));
 			}
 
 			return CreateExpressionFactoryCall (ec, "New", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="48" endline="59">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (expr_tree != null)
 				return expr_tree (ec, new TypeOfMethod (oper, loc));
 
 			Arguments args = Arguments.CreateForExpressionTree (ec, arguments,
 				new NullLiteral (loc),
 				new TypeOfMethod (oper, loc));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4841" endline="4856">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance;
 			if (InstanceExpression == null) {
 				instance = new NullLiteral (loc);
 			} else {
 				instance = InstanceExpression.CreateExpressionTree (ec);
 			}
 
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				instance,
 				CreateTypeOfExpression ());
 
 			return CreateExpressionFactoryCall (ec, "Field", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5107" endline="5120">
<![CDATA[
 
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance = mg.IsInstance ?
 				mg.InstanceExpression.CreateExpressionTree (ec) 
 				new NullLiteral (loc);
 
 			var args = Arguments.CreateForExpressionTree (ec, arguments,
 				instance,
 				mg.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="135" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1549" endline="1558">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)()
         Dim cf As New CodeFile("<Internal>", "", Compiler, Code)
         m_Files.Enqueue(cf)
         Compiler.CommandLine.Files.Add(cf)
         NextFile()
         LoadProjectConstants()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1542" endline="1548">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="136" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ManifestResourceInfo.cs" startline="40" endline="63">
<![CDATA[
 
 		public ResourceLocation ResourceLocation
 		{
 			get
 			{
 				int implementation = module.ManifestResource.records[index].Implementation;
 				if ((implementation >> 24) == AssemblyRefTable.Index)
 				{
 					//return ResourceLocation.ContainedInAnotherAssembly;
 					throw new NotImplementedException();
 				}
 				else if ((implementation >> 24) == FileTable.Index)
 				{
 					if ((implementation & 0xFFFFFF) == 0)
 					{
 						return ResourceLocation.ContainedInManifestFile | ResourceLocation.Embedded;
 					}
 					return 0;
 				}
 				else
 				{
 					throw new BadImageFormatException();
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ManifestResourceInfo.cs" startline="69" endline="88">
<![CDATA[
 		}
 
 		public string FileName
 		{
 			get
 			{
 				int implementation = module.ManifestResource.records[index].Implementation;
 				if ((implementation >> 24) == FileTable.Index)
 				{
 					if ((implementation & 0xFFFFFF) == 0)
 					{
 						return null;
 					}
 					else
 					{
 						return module.GetString(module.File.records[(implementation & 0xFFFFFF) - 1].Name);
 					}
 				}
 				throw new NotImplementedException();
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="137" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="60" endline="112">
<![CDATA[
 		private readonly PEReader peFile = new PEReader();
 		private readonly CliHeader cliHeader = new CliHeader();
 		private string imageRuntimeVersion;
 		private int metadataStreamVersion;
 		private byte[] stringHeap;
 		private byte[] blobHeap;
 		private byte[] userStringHeap;
 		private byte[] guidHeap;
 		private TypeDefImpl[] typeDefs;
 		private TypeDefImpl moduleType;
 		private Assembly[] assemblyRefs;
 		private Type[] typeRefs;
 		private Type[] typeSpecs;
 		private FieldInfo[] fields;
 		private MethodBase[] methods;
 		private MemberInfo[] memberRefs;
 		private Dictionary<int, string> strings = new Dictionary<int, string>();
 		private Dictionary<string, Type> types = new Dictionary<string, Type>();
 		private Dictionary<string, LazyForwardedType> forwardedTypes = new Dictionary<string, LazyForwardedType>();
 
 		private sealed class LazyForwardedType
 		{
 			private readonly int assemblyRef;
 			private Type type;
 
 			internal LazyForwardedType(int assemblyRef)
 			{
 				this.assemblyRef = assemblyRef;
 			}
 
 			internal Type GetType(ModuleReader module, string typeName)
 			{
 				if (type == null)
 				{
 					Assembly asm = module.ResolveAssemblyRef(assemblyRef);
 					type = asm.GetType(typeName, true);
 				}
 				return type;
 			}
 		}
 
 		internal ModuleReader(AssemblyReader assembly, Universe universe, Stream stream, string location)
 			
 		{
 			this.stream = stream;
 			this.location = location;
 			Read();
 			if (assembly == null && AssemblyTable.records.Length != 0)
 			{
 				assembly = new AssemblyReader(location, this);
 			}
 			this.assembly = assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="124" endline="232">
<![CDATA[
 		private readonly List<LocalBuilder> locals = new List<LocalBuilder>();
 		private readonly List<int> tokenFixups = new List<int>();
 		private readonly List<int> labels = new List<int>();
 		private readonly List<int> labelStackHeight = new List<int>();
 		private readonly List<LabelFixup> labelFixups = new List<LabelFixup>();
 		private readonly List<SequencePoint> sequencePoints = new List<SequencePoint>();
 		private readonly List<ExceptionBlock> exceptions = new List<ExceptionBlock>();
 		private readonly Stack<ExceptionBlock> exceptionStack = new Stack<ExceptionBlock>();
 		private ushort maxStack;
 		private int stackHeight;
 		private Scope scope;
 		private byte exceptionBlockAssistanceMode = EBAM_COMPAT;
 		private const byte EBAM_COMPAT = 0;
 		private const byte EBAM_DISABLE = 1;
 		private const byte EBAM_CLEVER = 2;
 
 		private struct LabelFixup
 		{
 			internal int label;
 			internal int offset;
 		}
 
 		private sealed class ExceptionBlock 
 		{
 			internal readonly int ordinal;
 			internal Label labelEnd;
 			internal int tryOffset;
 			internal int tryLength;
 			internal int handlerOffset;
 			internal int handlerLength;
 			internal Type exceptionType;	// null = finally block or handler with filter, FAULT = fault block
 			internal int filterOffset;
 
 			internal ExceptionBlock(int ordinal)
 			{
 				this.ordinal = ordinal;
 			}
 
 			int IComparer<ExceptionBlock>.Compare(ExceptionBlock x, ExceptionBlock y)
 			{
 				// Mono's sort insists on doing unnecessary comparisons
 				if (x == y)
 				{
 					return 0;
 				}
 				if (x.tryOffset >= y.handlerOffset && x.tryOffset + x.tryLength <= y.handlerOffset + y.handlerLength)
 				{
 					return -1;
 				}
 				if (y.tryOffset >= x.handlerOffset && y.tryOffset + y.tryLength <= x.handlerOffset + x.handlerLength)
 				{
 					return 1;
 				}
 				if (x.tryOffset == y.tryOffset && x.tryLength == y.tryLength)
 				{
 					return x.ordinal < y.ordinal ? -1 
 				}
 				if (x.tryOffset + x.tryLength <= y.tryOffset)
 				{
 					return -1;
 				}
 				if (y.tryOffset + y.tryLength <= x.tryOffset)
 				{
 					return 1;
 				}
 				if (x.tryOffset > y.tryOffset || (x.tryOffset == y.tryOffset && x.tryLength < y.tryLength))
 				{
 					return -1;
 				}
 				else
 				{
 					return 1;
 				}
 			}
 		}
 
 		private struct SequencePoint
 		{
 			internal ISymbolDocumentWriter document;
 			internal int offset;
 			internal int startLine;
 			internal int startColumn;
 			internal int endLine;
 			internal int endColumn;
 		}
 
 		private sealed class Scope
 		{
 			internal readonly Scope parent;
 			internal readonly List<Scope> children = new List<Scope>();
 			internal readonly List<LocalBuilder> locals = new List<LocalBuilder>();
 			internal int startOffset;
 			internal int endOffset;
 
 			internal Scope(Scope parent)
 			{
 				this.parent = parent;
 			}
 		}
 
 		internal ILGenerator(ModuleBuilder moduleBuilder, int initialCapacity)
 		{
 			this.code = new ByteBuffer(initialCapacity);
 			this.moduleBuilder = moduleBuilder;
 			if (moduleBuilder.symbolWriter != null)
 			{
 				scope = new Scope(null);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="138" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="92" endline="108">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= PropertyAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="80" endline="96">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= EventAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="139" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="335" endline="354">
<![CDATA[
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="312" endline="325">
<![CDATA[
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="140" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="936" endline="951">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddContinueOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new ContinueOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="920" endline="935">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddBreakOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new BreakOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="952" endline="967">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement exit_stmt)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddReturnOrigin (vector, exit_stmt);
 				if (errors == Report.Errors)
 					exit_stmt.Error_FinallyClause (Report);
 			} else {
 				saved_origins = new ReturnOrigin (saved_origins, vector, exit_stmt);
 			}
 
 			// sets ec.NeedReturnLabel()
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="141" nfragments="11" Csharpe_files="11" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5705" endline="5719">
<![CDATA[
 
 		#endregion
 
 		void Error_AssignmentEventOnly (ResolveContext ec)
 		{
 			if (spec.DeclaringType == ec.CurrentType || TypeManager.IsNestedChildOf (ec.CurrentType, spec.DeclaringType.MemberDefinition)) {
 				ec.Report.Error (79, loc,
 					"The event `{0}' can only appear on the left hand side of `+=' or `-=' operator",
 					GetSignatureForError ());
 			} else {
 				ec.Report.Error (70, loc,
 					"The event `{0}' can only appear on the left hand side of += or -= when used outside of the type `{1}'",
 					GetSignatureForError (), spec.DeclaringType.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="841" endline="852">
<![CDATA[
 	
 		protected void Error_CannotModifyIntermediateExpressionValue (ResolveContext ec)
 		{
 			ec.Report.SymbolRelatedToPreviousError (type);
 			if (ec.CurrentInitializerVariable != null) {
 				ec.Report.Error (1918, loc, "Members of value type `{0}' cannot be assigned using a property `{1}' object initializer",
 					TypeManager.CSharpName (type), GetSignatureForError ());
 			} else {
 				ec.Report.Error (1612, loc, "Cannot modify a value type return value of `{0}'. Consider storing the value in a temporary variable",
 					GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4160" endline="4177">
<![CDATA[
 		
 		protected override void EmitPreTryBody (EmitContext ec)
 		{
 			expr_copy.EmitAssign (ec, expr);
 
 			if (lock_taken != null) {
 				//
 				// Initialize ref variable
 				//
 				lock_taken.EmitAssign (ec, new BoolLiteral (false, loc));
 			} else {
 				//
 				// Monitor.Enter (expr_copy)
 				//
 				expr_copy.Emit (ec);
 				ec.Emit (OpCodes.Call, TypeManager.void_monitor_enter_object);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1323" endline="1333">
<![CDATA[
 
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			if (expr_unwrap != null) {
 				expr_unwrap.EmitCheck (ec);
 			} else {
 				expr.Emit (ec);
 				ec.Emit (OpCodes.Isinst, probe_type_expr.Type);
 			}			
 			ec.Emit (on_true ? OpCodes.Brtrue 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4178" endline="4192">
<![CDATA[
 
 		protected override void EmitTryBody (EmitContext ec)
 		{
 			//
 			// Monitor.Enter (expr_copy, ref lock_taken)
 			//
 			if (lock_taken != null) {
 				expr_copy.Emit (ec);
 				lock_taken.LocalInfo.CreateBuilder (ec);
 				lock_taken.AddressOf (ec, AddressOp.Load);
 				ec.Emit (OpCodes.Call, TypeManager.void_monitor_enter_object);
 			}
 
 			Statement.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4193" endline="4209">
<![CDATA[
 
 		protected override void EmitFinallyBody (EmitContext ec)
 		{
 			//
 			// if (lock_taken) Monitor.Exit (expr_copy)
 			//
 			Label skip = ec.DefineLabel ();
 
 			if (lock_taken != null) {
 				lock_taken.Emit (ec);
 				ec.Emit (OpCodes.Brfalse_S, skip);
 			}
 
 			expr_copy.Emit (ec);
 			ec.Emit (OpCodes.Call, TypeManager.void_monitor_exit_object);
 			ec.MarkLabel (skip);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1310" endline="1322">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (expr_unwrap != null) {
 				expr_unwrap.EmitCheck (ec);
 				return;
 			}
 
 			expr.Emit (ec);
 			ec.Emit (OpCodes.Isinst, probe_type_expr.Type);
 			ec.Emit (OpCodes.Ldnull);
 			ec.Emit (OpCodes.Cgt_Un);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="431" endline="447">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			expr.Emit (ec);
 
 			ec.Emit (OpCodes.Br, end_label);
 			ec.MarkLabel (is_null_label);
 
 			null_value.Emit (ec);
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4165" endline="4180">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label end_target = ec.DefineLabel ();
 
 			//
 			// Emit and duplicate left argument
 			//
 			arguments [0].Expr.Emit (ec);
 			ec.Emit (OpCodes.Dup);
 			arguments.RemoveAt (0);
 
 			oper_expr.EmitBranchable (ec, end_target, true);
 			base.Emit (ec);
 			ec.MarkLabel (end_target);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="288" endline="299">
<![CDATA[
 
 	void OutlineEvent (EventInfo ei)
 	{
 		MethodBase accessor = ei.GetAddMethod (true);
 		
 		o.Write (GetMethodVisibility (accessor));
 		o.Write ("event ");
 		o.Write (FormatType (ei.EventHandlerType));
 		o.Write (" ");
 		o.Write (ei.Name);
 		o.Write (";");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="300" endline="308">
<![CDATA[
 	
 	void OutlineConstructor (ConstructorInfo ci)
 	{
 		o.Write (GetMethodVisibility (ci));
 		o.Write (RemoveGenericArity (t.Name));
 		o.Write (" (");
 		OutlineParams (ci.GetParameters ());
 		o.Write (");");
 	}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="142" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1327" endline="1344">
<![CDATA[
 
 		public MethodInfo GetSetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank + 1];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			arg_types[rank] = Element.GetMetaInfo ();
 
 			var set = mb.GetArrayMethod (
 				GetMetaInfo (), "Set",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				TypeManager.void_type.GetMetaInfo (), arg_types);
 
 			return set;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1295" endline="1310">
<![CDATA[
 
 		public MethodInfo GetAddressMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var address = mb.GetArrayMethod (
 				GetMetaInfo (), "Address",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				ReferenceContainer.MakeType (Element).GetMetaInfo (), arg_types);
 
 			return address;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1311" endline="1326">
<![CDATA[
 
 		public MethodInfo GetGetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var get = mb.GetArrayMethod (
 				GetMetaInfo (), "Get",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				Element.GetMetaInfo (), arg_types);
 
 			return get;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1278" endline="1294">
<![CDATA[
 		}
 
 		public MethodInfo GetConstructor ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var ctor = mb.GetArrayMethod (
 				GetMetaInfo (), Constructor.ConstructorName,
 				CallingConventions.HasThis,
 				null, arg_types);
 
 			return ctor;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="143" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="907" endline="919">
<![CDATA[
 
 		public override bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			int errors = Report.Errors;
 			Parent.AddResumePoint (this.stmt, loc, out pc);
 			if (errors == Report.Errors) {
 				if (finally_vector == null)
 					this.stmt.AddResumePoint (stmt, pc);
 				else
 					Report.Error (1625, loc, "Cannot yield in the body of a finally clause");
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="743" endline="755">
<![CDATA[
 
 		public override bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			int errors = Report.Errors;
 			Parent.AddResumePoint (stmt, loc, out pc);
 			if (errors == Report.Errors) {
 				if (CurrentUsageVector.Next == null)
 					Report.Error (1626, loc, "Cannot yield a value in the body of a try block with a catch clause");
 				else
 					Report.Error (1631, loc, "Cannot yield a value in the body of a catch clause");
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="144" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1404" endline="1412">
<![CDATA[
 
 		public void Encode (short value)
 		{
 			if (pos + 2 > buffer.Length)
 				Grow (2);
 
 			buffer[pos++] = (byte) value;
 			buffer[pos++] = (byte) (value >> 8);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="111" endline="118">
<![CDATA[
 
 		internal void Write(short value)
 		{
 			if (pos + 2 > buffer.Length)
 				Grow(2);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="145" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="639" endline="651">
<![CDATA[
 
 		public MethodEntry[] Methods {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				lock (this) {
 					read_methods ();
 					MethodEntry[] retval = new MethodEntry [MethodCount];
 					method_list.CopyTo (retval, 0);
 					return retval;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="613" endline="625">
<![CDATA[
 
 		public MethodEntry GetMethodByToken (int token)
 		{
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				read_methods ();
 				MethodEntry me;
 				method_token_hash.TryGetValue (token, out me);
 				return me;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="146" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="137" endline="147">
<![CDATA[
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal Location As Span)
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, Location.AsString(Compiler) & " No errors, but compilation failed? ")
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="124" endline="136">
<![CDATA[
     End Property
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal where As String)
         'Console.WriteLine("Verifying consistency
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, where & "
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="147" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1578" endline="1595">
<![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim emittableField As Mono.Cecil.FieldReference
         Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(Field)
 
         emittableField = Emitter.GetFieldRef(Field)
         emittableField = Helper.GetFieldOrFieldBuilder(Info.Compiler, emittableField)
 
         If fD.IsLiteral Then
             EmitLoadValueAddress(Info, fD.Constant)
         Else
             If fD.IsStatic Then
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             Else
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1869" endline="1881">
<![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Variable)
         If CecilHelper.IsByRef(Variable.ParameterType) Then
             If CecilHelper.IsGenericParameter(CecilHelper.GetElementType(Variable.ParameterType)) Then
                 EmitStoreObject(Info, CecilHelper.GetElementType(Variable.ParameterType))
             Else
                 EmitStoreIndirect(Info, Variable.ParameterType)
             End If
         Else
             Info.ILGen.Emit(OpCodes.Starg, position)
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="148" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="606" endline="620">
<![CDATA[
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="621" endline="633">
<![CDATA[
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="149" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="445" endline="458">
<![CDATA[
 		
 		public void AddMethod (MethodOrOperator method)
 		{
 			if (!AddToContainer (method, method.MemberName.Basename))
 				return;
 			
 			if (methods == null)
 				methods = new List<MemberCore> ();
 
 			if (method.MemberName.Left != null) 
 				AddMemberToList (method, methods, true);
 			else 
 				AddMemberToList (method, methods, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="513" endline="526">
<![CDATA[
 
 		public void AddProperty (Property prop)
 		{
 			if (!AddMember (prop))
 				return;
 
 			if (properties == null)
 				properties = new List<MemberCore> ();
 
 			if (prop.MemberName.Left != null)
 				AddMemberToList (prop, properties, true);
 			else 
 				AddMemberToList (prop, properties, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="538" endline="551">
<![CDATA[
 
 		/// <summary>
 		/// Indexer has special handling in constrast to other AddXXX because the name can be driven by IndexerNameAttribute
 		/// </summary>
 		public void AddIndexer (Indexer i)
 		{
 			if (indexers == null)
 				indexers = new List<MemberCore> ();
 
 			if (i.IsExplicitImpl)
 				AddMemberToList (i, indexers, true);
 			else 
 				AddMemberToList (i, indexers, false);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="150" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="54" endline="70">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             Helper.Assert(Me.Classification.IsValueClassification)
             If Me.Classification.CanBeValueClassification Then
                 result = Me.Classification.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="48" endline="63">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             If Me.Classification.IsValueClassification Then
                 result = m_Expression.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="151" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="780" endline="794">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (Expr != null) {
 				Expr.Emit (ec);
 
 				if (unwind_protect)
 					ec.Emit (OpCodes.Stloc, ec.TemporaryReturn ());
 			}
 
 			if (unwind_protect)
 				ec.Emit (OpCodes.Leave, ec.ReturnLabel);
 			else
 				ec.Emit (OpCodes.Ret);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="274" endline="287">
<![CDATA[
 	}
 
 	// FIXME
 	void OutlineAttributes ()
 	{
 		if (t.IsSerializable)
 			o.WriteLine ("[Serializable]");
 
 		if (t.IsDefined (typeof (System.FlagsAttribute), true))
 			o.WriteLine ("[Flags]");
 
 		if (t.IsDefined (typeof (System.ObsoleteAttribute), true))
 			o.WriteLine ("[Obsolete]");
 	}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="152" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="89" endline="104">
<![CDATA[
 
     Shared Function CreateDefaultConstructor(ByVal Parent As TypeDeclaration) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
         Dim modifiers As Modifiers
 
         If Parent.Modifiers.Is(ModifierMasks.MustInherit) Then
             modifiers.AddModifier(KS.Protected)
         End If
         result.Init(modifiers, New SubSignature(result, ConstructorName, New ParameterList(result)), New CodeBlock(result))
 
         If result.ResolveTypeReferences() = False Then
             Helper.ErrorRecoveryNotImplemented(Parent.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="76" endline="88">
<![CDATA[
 
     Shared Function CreateTypeConstructor(ByVal Parent As TypeDeclaration) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
 
         result.Init(New Modifiers(ModifierMasks.Shared), New SubSignature(result, SharedConstructorName, New ParameterList(result)), New CodeBlock(result))
 
         result.UpdateDefinition()
         If result.ResolveTypeReferences() = False Then
             Helper.ErrorRecoveryNotImplemented(Parent.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="153" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="419" endline="427">
<![CDATA[
 		}
 
 		public int CompilationUnitIndex {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].CompilationUnit;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="428" endline="436">
<![CDATA[
 		}
 
 		public int File {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].File;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="154" nfragments="8" Csharpe_files="8" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="343" endline="355">
<![CDATA[
 
 		public override void AddTypeForwarder (TypeSpec type, Location loc)
 		{
 			try {
 				if (add_type_forwarder == null) {
 					add_type_forwarder = typeof (AssemblyBuilder).GetMethod ("AddTypeForwarder", BindingFlags.NonPublic | BindingFlags.Instance);
 				}
 
 				add_type_forwarder.Invoke (builder, new object[] { type.GetMetaInfo () });
 			} catch {
 				base.AddTypeForwarder (type, loc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="356" endline="367">
<![CDATA[
 
 		public override void DefineWin32IconResource (string fileName)
 		{
 			try {
 				if (win32_icon_define == null)
 					win32_icon_define = typeof (AssemblyBuilder).GetMethod ("DefineIconResource", BindingFlags.Instance | BindingFlags.NonPublic);
 
 				win32_icon_define.Invoke (builder, new object[] { fileName });
 			} catch {
 				base.DefineWin32IconResource (fileName);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="319" endline="330">
<![CDATA[
 
 		public override Module AddModule (string module)
 		{
 			try {
 				if (adder_method == null)
 					adder_method = typeof (AssemblyBuilder).GetMethod ("AddModule", BindingFlags.Instance | BindingFlags.NonPublic);
 
 				return (Module) adder_method.Invoke (builder, new object[] { module });
 			} catch {
 				return base.AddModule (module);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="404" endline="415">
<![CDATA[
 
 		public override void SetVersion (Version version, Location loc)
 		{
 			try {
 				if (assembly_version == null)
 					assembly_version = typeof (AssemblyBuilder).GetField ("version", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_version.SetValue (builder, version.ToString (4));
 			} catch {
 				base.SetVersion (version, loc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="392" endline="403">
<![CDATA[
 
 		public override void SetFlags (uint flags, Location loc)
 		{
 			try {
 				if (assembly_flags == null)
 					assembly_flags = typeof (AssemblyBuilder).GetField ("flags", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_flags.SetValue (builder, flags);
 			} catch {
 				base.SetFlags (flags, loc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="368" endline="379">
<![CDATA[
 
 		public override void SetAlgorithmId (uint value, Location loc)
 		{
 			try {
 				if (assembly_algorithm == null)
 					assembly_algorithm = typeof (AssemblyBuilder).GetField ("algid", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_algorithm.SetValue (builder, value);
 			} catch {
 				base.SetAlgorithmId (value, loc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="380" endline="391">
<![CDATA[
 
 		public override void SetCulture (string culture, Location loc)
 		{
 			try {
 				if (assembly_culture == null)
 					assembly_culture = typeof (AssemblyBuilder).GetField ("culture", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_culture.SetValue (builder, culture);
 			} catch {
 				base.SetCulture (culture, loc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="331" endline="342">
<![CDATA[
 
 		public override void AddPermissionRequests (PermissionSet[] permissions)
 		{
 			try {
 				if (add_permission == null)
 					add_permission = typeof (AssemblyBuilder).GetMethod ("AddPermissionRequests", BindingFlags.Instance | BindingFlags.NonPublic);
 
 				add_permission.Invoke (builder, permissions);
 			} catch {
 				base.AddPermissionRequests (permissions);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="155" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="57" endline="69">
<![CDATA[
  		public Delegate (NamespaceEntry ns, DeclSpace parent, FullNamedExpression type,
 				 Modifiers mod_flags, MemberName name, ParametersCompiled param_list,
 				 Attributes attrs)
 			
 
 		{
 			this.ReturnType = type;
 			ModFlags        = ModifiersExtensions.Check (AllowedModifiers, mod_flags,
 							   IsTopLevel ? Modifiers.INTERNAL 
 							   Modifiers.PRIVATE, name.Location, Report);
 			parameters      = param_list;
 			spec = new TypeSpec (Kind, null, this, null, ModFlags | Modifiers.SEALED);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2619" endline="2626">
<![CDATA[
 		public Struct (NamespaceEntry ns, DeclSpace parent, MemberName name,
 			       Modifiers mod, Attributes attrs)
 			
 		{
 			var accmods = parent.Parent == null ? Modifiers.INTERNAL 
 			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, Location, Report) | Modifiers.SEALED ;
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="135" endline="155">
<![CDATA[
 			}
 		}
 
 		public static readonly string UnderlyingValueField = "value__";
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
 
 		public Enum (NamespaceEntry ns, DeclSpace parent, TypeExpression type,
 			     Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			base_type_expr = type;
 			var accmods = IsTopLevel ? Modifiers.INTERNAL 
 			ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod_flags, accmods, Location, Report);
 			spec = new EnumSpec (null, this, null, null, ModFlags);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2785" endline="2812">
<![CDATA[
 
 	}
 
 	/// <summary>
 	///   Interfaces
 	/// </summary>
 	public sealed class Interface 
 
 		/// <summary>
 		///   Modifiers allowed in a class declaration
 		/// </summary>
 		public const Modifiers AllowedModifiers =
 			Modifiers.NEW       |
 			Modifiers.PUBLIC    |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL  |
 		 	Modifiers.UNSAFE    |
 			Modifiers.PRIVATE;
 
 		public Interface (NamespaceEntry ns, DeclSpace parent, MemberName name, Modifiers mod,
 				  Attributes attrs)
 			
 		{
 			var accmods = parent.Parent == null ? Modifiers.INTERNAL 
 
 			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, name.Location, Report);
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="156" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="472" endline="483">
<![CDATA[
 		}
 
 		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
 		{
 			IList<CustomAttributeData> list = base.GetCustomAttributesData(attributeType);
 			if ((this.Attributes & ParameterAttributes.HasFieldMarshal) != 0
 				&& (attributeType == null || attributeType.IsAssignableFrom(this.Module.universe.System_Runtime_InteropServices_MarshalAsAttribute)))
 			{
 				list.Add(MarshalSpec.GetMarshalAsAttribute(this.Module, this.MetadataToken));
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="228" endline="239">
<![CDATA[
 		}
 
 		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
 		{
 			List<CustomAttributeData> list = module.GetCustomAttributes(this.MetadataToken, attributeType);
 			if ((this.Attributes & MethodAttributes.PinvokeImpl) != 0
 				&& (attributeType == null || attributeType.IsAssignableFrom(module.universe.System_Runtime_InteropServices_DllImportAttribute)))
 			{
 				CreateDllImportPseudoCustomAttribute(list);
 			}
 			return list;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="157" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4936" endline="4947">
<![CDATA[
 		static readonly int [] codes = {
 			191,	// instance, write access
 			192,	// instance, out access
 			198,	// static, write access
 			199,	// static, out access
 			1648,	// member of value instance, write access
 			1649,	// member of value instance, out access
 			1650,	// member of value static, write access
 			1651	// member of value static, out access
 		};
 
 		static readonly string [] msgs = {
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="172" endline="187">
<![CDATA[
 	}
 
 	class StaticLoader 
 	{
 		readonly StaticImporter importer;
 		readonly Universe domain;
 		Assembly corlib;
 		List<Tuple<AssemblyName, string>> loaded_names;
 		static readonly Dictionary<SdkVersion, string[]> sdk_directory;
 
 		static StaticLoader ()
 		{
 			sdk_directory = new Dictionary<SdkVersion, string[]> ();
 			sdk_directory.Add (SdkVersion.v2, new string[] { "2.0", "net_2_0", "v2.0.50727" });
 			sdk_directory.Add (SdkVersion.v4, new string[] { "4.0", "net_4_0", "v4.0.30319" });
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="158" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="636" endline="647">
<![CDATA[
 
 	//
 	// This is like IsBuiltinType, but lacks decimal_type, we should also clean up
 	// the pieces in the code where we use IsBuiltinType and special case decimal_type.
 	// 
 	public static bool IsPrimitiveType (TypeSpec t)
 	{
 		return (t == int32_type || t == uint32_type ||
 		    t == int64_type || t == uint64_type || t == float_type || t == double_type ||
 		    t == char_type || t == short_type || t == bool_type ||
 		    t == sbyte_type || t == byte_type || t == ushort_type);
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="46" endline="53">
<![CDATA[
 
 		static bool IsValidEnumType (TypeSpec t)
 		{
 			return (t == TypeManager.int32_type || t == TypeManager.uint32_type || t == TypeManager.int64_type ||
 				t == TypeManager.byte_type || t == TypeManager.sbyte_type || t == TypeManager.short_type ||
 				t == TypeManager.ushort_type || t == TypeManager.uint64_type || t == TypeManager.char_type ||
 				TypeManager.IsEnumType (t));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3612" endline="3624">
<![CDATA[
 
 		private static bool IsTypeIntegral (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.int64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.int32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.short_type ||
 				type == TypeManager.sbyte_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="159" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="86" endline="93">
<![CDATA[
 
 		internal void Write(byte[] value)
 		{
 			if (pos + value.Length > buffer.Length)
 				Grow(value.Length);
 			Buffer.BlockCopy(value, 0, buffer, pos, value.Length);
 			pos += value.Length;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="197" endline="204">
<![CDATA[
 
 		internal void Write(ByteBuffer bb)
 		{
 			if (pos + bb.Length > buffer.Length)
 				Grow(bb.Length);
 			Buffer.BlockCopy(bb.buffer, 0, buffer, pos, bb.Length);
 			pos += bb.Length;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="160" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="233" endline="251">
<![CDATA[
 
 		public void RemoveWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_only == null)
 				warnings_only = new List<int> ();
 
 			warnings_only.Add (id);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="214" endline="232">
<![CDATA[
 
 		public void AddWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_as_error == null)
 				warnings_as_error = new List<int> ();
 			
 			warnings_as_error.Add (id);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="161" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="294" endline="312">
<![CDATA[
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (4);
 
 			default_references.Add ("System.dll");
 			default_references.Add ("System.Xml.dll");
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core.dll");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp.dll");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="437" endline="461">
<![CDATA[
 		}
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (8);
 
 			default_references.Add ("System");
 			default_references.Add ("System.Xml");
 #if NET_2_1
 			default_references.Add ("System.Net");
 			default_references.Add ("System.Windows");
 			default_references.Add ("System.Windows.Browser");
 #endif
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="162" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="758" endline="766">
<![CDATA[
 
 		int IComparer<Record>.Compare(Record x, Record y)
 		{
 			if (x.Class == y.Class)
 			{
 				return x.Interface == y.Interface ? 0 
 			}
 			return x.Class > y.Class ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2340" endline="2348">
<![CDATA[
 
 		int IComparer<Record>.Compare(Record x, Record y)
 		{
 			if (x.Owner == y.Owner)
 			{
 				return x.Number == y.Number ? 0 
 			}
 			return x.Owner > y.Owner ? 1 
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="163" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="203" endline="219">
<![CDATA[
 		}
 
 		internal uint StartupStubRVA
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64)
 				{
 					// note that the alignment is driven by the requirement that the two relocation fixups are in a single page
 					return (ImportDirectoryRVA + ImportDirectoryLength + 15U) & ~15U;
 				}
 				else
 				{
 					// the additional 2 bytes padding are to align the address in the jump (which is a relocation fixup)
 					return 2 + ((ImportDirectoryRVA + ImportDirectoryLength + 3U) & ~3U);
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="98" endline="112">
<![CDATA[
 		}
 
 		private uint ResourcesRVA
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 3) & ~3U;
 				}
 				else
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 15) & ~15U;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="188" endline="202">
<![CDATA[
 		}
 
 		private uint ImportHintNameTableRVA
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return (ImportDirectoryRVA + 48 + 15) & ~15U;
 				}
 				else
 				{
 					return (ImportDirectoryRVA + 48 + 4 + 15) & ~15U;
 				}
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="164" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5793" endline="5809">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 
 			//
 			// Don't capture temporary variables except when using
 			// iterator redirection
 			//
 			if (ec.CurrentAnonymousMethod != null && ec.CurrentAnonymousMethod.IsIterator && ec.IsVariableCapturingRequired) {
 				AnonymousMethodStorey storey = li.Block.Explicit.CreateAnonymousMethodStorey (ec);
 				storey.CaptureLocalVariable (ec, li);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2843" endline="2853">
<![CDATA[
 
 		public virtual MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			if (left != null && left.IsNull && TypeManager.IsReferenceType (left.Type)) {
 				ec.Report.Warning (1720, 1, left.Location,
 					"Expression will always cause a `{0}'", "System.NullReferenceException");
 			}
 
 			InstanceExpression = left;
 			return this;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="165" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="479" endline="500">
<![CDATA[
     End Property
 
     Function VerifyConstraints() As Boolean
         Dim result As Boolean = True
 
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim mit As GenericInstanceMethod
         Dim md As MethodDefinition
 
         mit = TryCast(ResolvedMethod, GenericInstanceMethod)
         md = CecilHelper.FindDefinition(mit)
 
         If mit Is Nothing OrElse md Is Nothing Then Return True
 
         parameters = md.GenericParameters
         arguments = mit.GenericArguments
 
         result = Helper.VerifyConstraints(Me.Parent, parameters, arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="219" endline="239">
<![CDATA[
 
     Function VerifyConstraints() As Boolean
         Dim result As Boolean = True
 
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim git As GenericInstanceType
         Dim td As TypeDefinition
 
         git = TryCast(m_ResolvedType, GenericInstanceType)
         td = CecilHelper.FindDefinition(git)
 
         If git Is Nothing OrElse td Is Nothing Then Return True
 
         parameters = td.GenericParameters
         arguments = git.GenericArguments
 
         result = Helper.VerifyConstraints(Me, parameters, arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="166" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="201" endline="211">
<![CDATA[
 
 		public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize)
 		{
 			if (parent == null && (attr & TypeAttributes.Interface) == 0)
 			{
 				parent = universe.System_Object;
 			}
 			TypeBuilder typeBuilder = new TypeBuilder(this, name, parent, attr);
 			PostDefineType(typeBuilder, packingSize, typesize);
 			return typeBuilder;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4008" endline="4018">
<![CDATA[
 
 		public static StringConcat Create (ResolveContext rc, Expression left, Expression right, Location loc)
 		{
 			if (left.eclass == ExprClass.Unresolved || right.eclass == ExprClass.Unresolved)
 				throw new ArgumentException ();
 
 			var s = new StringConcat (left, right, loc);
 			s.Append (rc, left);
 			s.Append (rc, right);
 			return s;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1151" endline="1160">
<![CDATA[
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			if ((index <= 0) || (DataOffset == 0))
 				throw new InvalidOperationException ();
 
 			bw.Write (Token);
 			bw.Write (DataOffset);
 			bw.Write (LineNumberTableOffset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="180" endline="190">
<![CDATA[
 		}
 
 		public void SetConstant(object defaultValue)
 		{
 			if (lazyPseudoToken == 0)
 			{
 				lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			}
 			attributes |= PropertyAttributes.HasDefault;
 			typeBuilder.ModuleBuilder.AddConstant(lazyPseudoToken, defaultValue);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="167" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="815" endline="822">
<![CDATA[
 
 		public void EmitWriteLine(LocalBuilder local)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("get_Out"));
 			Emit(OpCodes.Ldloc, local);
 			Emit(OpCodes.Callvirt, u.Import(typeof(System.IO.TextWriter)).GetMethod("WriteLine", new Type[] { local.LocalType }));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="792" endline="798">
<![CDATA[
 
 		public void EmitWriteLine(string text)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Ldstr, text);
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("WriteLine", new Type[] { u.System_String }));
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="168" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="49" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			MethodSignature other = obj as MethodSignature;
 			return other != null
 				&& other.callingConvention == callingConvention
 				&& other.genericParamCount == genericParamCount
 				&& other.returnType.Equals(returnType)
 				&& Util.ArrayEquals(other.parameterTypes, parameterTypes)
 				&& Util.ArrayEquals(other.modifiers, modifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2104" endline="2111">
<![CDATA[
 
 		public override bool Equals(object o)
 		{
 			GenericTypeInstance gt = o as GenericTypeInstance;
 			return gt != null && gt.type.Equals(type) && Util.ArrayEquals(gt.args, args)
 				&& Util.ArrayEquals(gt.requiredCustomModifiers, requiredCustomModifiers)
 				&& Util.ArrayEquals(gt.optionalCustomModifiers, optionalCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="46" endline="54">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			GenericMethodInstance other = obj as GenericMethodInstance;
 			return other != null
 				&& other.method.Equals(method)
 				&& other.declaringType.Equals(declaringType)
 				&& Util.ArrayEquals(other.methodArgs, methodArgs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="51" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			FieldSignature other = obj as FieldSignature;
 			return other != null
 				&& other.fieldType.Equals(fieldType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="59" endline="67">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			PropertySignature other = obj as PropertySignature;
 			return other != null
 				&& other.propertyType.Equals(propertyType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1553" endline="1560">
<![CDATA[
 
 		protected bool EqualsHelper(ElementHolderType other)
 		{
 			return other != null
 				&& other.elementType.Equals(elementType)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="169" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1322" endline="1334">
<![CDATA[
 
     Private Function ParseIdentifier(ByVal Parent As ParsedObject) As Identifier
         Dim result As Identifier
 
         If tm.CurrentToken.IsIdentifier Then
             result = New Identifier(Parent, tm.CurrentToken.Identifier, tm.CurrentLocation, tm.CurrentTypeCharacter)
             tm.NextToken()
         Else
             result = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="682" endline="695">
<![CDATA[
 
     Private Function ParseIdentifierOrKeyword(ByVal Parent As ParsedObject) As IdentifierOrKeyword
         Dim result As IdentifierOrKeyword
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             result = New IdentifierOrKeyword(Parent, tm.CurrentToken)
             tm.NextToken()
         Else
             Helper.AddError(Compiler, tm.CurrentLocation)
             result = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="170" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="496" endline="502">
<![CDATA[
 
     Function IsSignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_SByte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int64)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="503" endline="509">
<![CDATA[
 
     Function IsUnsignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_Byte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt64)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="587" endline="600">
<![CDATA[
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="171" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="112" endline="123">
<![CDATA[
 
     Overloads Function Equals(ByVal str As String) As Boolean
         If IsGlobal(str) Then
             If Me.Global = False Then
                 Return False
             Else
                 Return Helper.CompareName(RemoveGlobal(str), Me.Name)
             End If
         Else
             Return Helper.CompareName(str, Me.Name)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="101" endline="112">
<![CDATA[
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         If tm.CurrentToken = KS.LParenthesis Then
             If tm.PeekToken.Equals(KS.Comma, KS.RParenthesis) Then
                 Return False
             Else
                 Return True
             End If
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="172" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="92" endline="103">
<![CDATA[
 
     Private Function GetTypeAttributes() As Mono.Cecil.TypeAttributes
         Dim result As Mono.Cecil.TypeAttributes = MyBase.TypeAttributes
 
         If Me.Modifiers.Is(ModifierMasks.MustInherit) Then
             result = result Or Mono.Cecil.TypeAttributes.Abstract
         ElseIf Me.Modifiers.Is(ModifierMasks.NotInheritable) Then
             result = result Or Mono.Cecil.TypeAttributes.Sealed
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1340" endline="1353">
<![CDATA[
 
     Shared Function GetDefaultMemberAttribute(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.CustomAttribute
         Dim attribs As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim attrib As Mono.Cecil.CustomAttribute = Nothing
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
 
         attribs = CecilHelper.GetCustomAttributes(tD, Compiler.TypeCache.System_Reflection_DefaultMemberAttribute)
 
         If attribs IsNot Nothing AndAlso attribs.Count = 1 Then
             attrib = attribs(0)
         End If
 
         Return attrib
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="173" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="515" endline="530">
<![CDATA[
 
 		public static string GetModifierSignature (Modifier mod)
 		{
 			switch (mod) {
 			case Modifier.OUT
 				return "out";
 			case Modifier.PARAMS
 				return "params";
 			case Modifier.REF
 				return "ref";
 			case Modifier.This
 				return "this";
 			default
 				return "";
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1272" endline="1285">
<![CDATA[
 
 		static TypeCode real_type_suffix (int c)
 		{
 			switch (c){
 			case 'F'
 				return TypeCode.Single;
 			case 'D'
 				return TypeCode.Double;
 			case 'M'
 				return TypeCode.Decimal;
 			default
 				return TypeCode.Empty;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\OpCodes.cs" startline="716" endline="747">
<![CDATA[
 
 		public static bool TakesSingleByteArgument(OpCode inst)
 		{
 			switch (inst.Value)
 			{
 				case 14
 				case 15
 				case 16
 				case 17
 				case 18
 				case 19
 				case 31
 				case 43
 				case 44
 				case 45
 				case 46
 				case 47
 				case 48
 				case 49
 				case 50
 				case 51
 				case 52
 				case 53
 				case 54
 				case 55
 				case 222
 				case -494
 					return true;
 				default
 					return false;
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="174" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="758" endline="769">
<![CDATA[
 
 		public void Error_UnexpectedKind (Report r, MemberCore mc, string expected, string was, Location loc)
 		{
 			string name;
 			if (mc != null)
 				name = mc.GetSignatureForError ();
 			else
 				name = GetSignatureForError ();
 
 			r.Error (118, loc, "`{0}' is a `{1}' but a `{2}' was expected",
 			      name, was, expected);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2171" endline="2180">
<![CDATA[
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Expression left, Expression right, string oper, Location loc)
 		{
 			string l, r;
 			l = TypeManager.CSharpName (left.Type);
 			r = TypeManager.CSharpName (right.Type);
 
 			ec.Report.Error (19, loc, "Operator `{0}' cannot be applied to operands of type `{1}' and `{2}'",
 				oper, l, r);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="175" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="197" endline="213">
<![CDATA[
 
     ''' <summary>
     ''' If not the current token is a newline, then shows the specified message
     ''' and eats the newline. After this sub the current token will be the first after the newline
     ''' Returns false if first symbol isn't a newline
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindNewLineAndShowError(ByVal Message As Messages) As Boolean
         If Not AcceptNewLine() Then
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             GotoNewline(True, False)
             Return False
         Else
             Return True
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="326" endline="334">
<![CDATA[
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="176" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="61" endline="71">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As ExpressionClassification)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="79" endline="88">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As BaseObject, ByVal strMsg As String)
         MyBase.new()
         m_Message = "There has been an internal error in the compiler
         If Obj IsNot Nothing Then
             m_Message &= " caused by the line
         End If
 StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="50" endline="60">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As IBaseObject)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="177" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5820" endline="5831">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			LocalTemporary v = null;
 			if (method == null && TypeManager.IsValueType (type)) {
 				// TODO
 				v = new LocalTemporary (type);
 			}
 
 			if (Emit (ec, v))
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5808" endline="5819">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			LocalTemporary v = null;
 			if (method == null && TypeManager.IsValueType (type)) {
 				// TODO
 				v = new LocalTemporary (type);
 			}
 
 			if (!Emit (ec, v))
 				v.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="178" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="179" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="51" endline="59">
<![CDATA[
 		public TypeSpec (MemberKind kind, TypeSpec declaringType, ITypeDefinition definition, MetaType info, Modifiers modifiers)
 			
 		{
 			this.declaringType = declaringType;
 			this.info = info;
 
 			if (definition != null && definition.TypeParametersCount > 0)
 				state |= StateFlags.IsGeneric;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="55" endline="62">
<![CDATA[
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    TypeArguments args, Location loc)
 			
 		{
 			if (args != null && args.Count > 0)
 				this.TypeArguments = args;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="180" nfragments="8" Csharpe_files="8" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="772" endline="780">
<![CDATA[
 
 		public void SetParameters (Parameter first, Parameter second)
 		{
 			base.parameters = new ParametersCompiled (first, second);
 			base.parameter_info = new ParameterInfo[] {
 				new ParameterInfo (this, 0),
 				new ParameterInfo (this, 1)
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="764" endline="771">
<![CDATA[
 
 		public void SetParameter (Parameter parameter)
 		{
 			base.parameters = new ParametersCompiled (parameter);
 			base.parameter_info = new ParameterInfo[] {
 				new ParameterInfo (this, 0)
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1043" endline="1049">
<![CDATA[
 
 		public static ParametersCompiled MergeGenerated (CompilerContext ctx, ParametersCompiled userParams, bool checkConflicts, Parameter compilerParams, TypeSpec compilerTypes)
 		{
 			return MergeGenerated (ctx, userParams, checkConflicts,
 				new Parameter [] { compilerParams },
 				new TypeSpec [] { compilerTypes });
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="709" endline="716">
<![CDATA[
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, this.arguments,
 				InstanceExpr.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Invoke", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8080" endline="8087">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, Arguments,
 				Expr.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "ArrayIndex", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8406" endline="8417">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, arguments,
 				InstanceExpression.CreateExpressionTree (ec),
 				new TypeOfMethod (Getter, loc));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1469" endline="1477">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeAs", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1301" endline="1309">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeIs", args);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="181" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="453" endline="459">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal ParamArray Methods As Mono.Cecil.MemberReference())
         Me.New(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(New Generic.List(Of Mono.Cecil.MemberReference)(Methods))
         Helper.Assert(Methods.Length > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="467" endline="473">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="460" endline="466">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="182" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3389" endline="3397">
<![CDATA[
 		}
 
 		TypeSpec DelegateType {
 			get {
 				if ((restrictions & Restrictions.DelegateInvoke) == 0)
 					throw new InternalErrorException ("Not running in delegate mode", loc);
 
 				return members [0].DeclaringType;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="126" endline="135">
<![CDATA[
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="183" nfragments="5" Csharpe_files="3" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1478" endline="1487">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			expr.Emit (ec);
 
 			ec.Emit (OpCodes.Isinst, type);
 
 			if (TypeManager.IsGenericParameter (type) || TypeManager.IsNullableType (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1300" endline="1308">
<![CDATA[
 
 		public override void EmitBranchable (EmitContext ec, Label label, bool on_true)
 		{
 			child.EmitBranchable (ec, label, on_true);
 
 			// Only to make verifier happy
 			if (TypeManager.IsGenericParameter (type) && child.IsNull)
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6925" endline="6935">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			ResolveBase (ec);
 
 			if (variable_info != null && type.IsStruct) {
 				CheckStructThisDefiniteAssignment (ec);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MeExpression.vb" startline="36" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Emitter.EmitLoadMe(Info, Me.FindFirstParent(Of IType).CecilType)
         If CecilHelper.IsValueType(Info.DesiredType) AndAlso CecilHelper.IsByRef(Info.DesiredType) = False Then
             Emitter.EmitLoadObject(Info, Info.DesiredType)
         End If
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1668" endline="1681">
<![CDATA[
 
     ''' <summary>
     ''' Loads the value of the parameter.
     ''' Gets the value of byref parameters, not the passed-in address.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Variable"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         EmitLoadParameter(Info, Variable)
         If CecilHelper.IsByRef(Variable.ParameterType) AndAlso CecilHelper.IsByRef(Info.DesiredType) = False Then
             EmitLoadIndirect(Info, Variable.ParameterType)
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="184" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1890" endline="1900">
<![CDATA[
 
     Shared Sub EmitStoreField(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim Field2 As Mono.Cecil.FieldReference = Field
         Field2 = Emitter.GetFieldRef(Field2)
         Field2 = Helper.GetFieldOrFieldBuilder(Info.Compiler, Field2)
         If CecilHelper.IsStatic(Field) Then
             Info.ILGen.Emit(OpCodes.Stsfld, Field2)
         Else
             Info.ILGen.Emit(OpCodes.Stfld, Field2)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1652" endline="1667">
<![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified parameter.
     ''' If it is a byref parameter, the passed-in address is loaded.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Parameter"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadParameterAddress(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Parameter)
         If position <= 255 Then
             Info.ILGen.Emit(OpCodes.Ldarga_S, CByte(position))
         Else
             Info.ILGen.Emit(OpCodes.Ldarga, position)
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="185" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="355" endline="363">
<![CDATA[
 
 		public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration)
 		{
 			MethodImplTable.Record rec = new MethodImplTable.Record();
 			rec.Class = token;
 			rec.MethodBody = this.ModuleBuilder.GetMethodToken(methodInfoBody).Token;
 			rec.MethodDeclaration = this.ModuleBuilder.GetMethodToken(methodInfoDeclaration).Token;
 			this.ModuleBuilder.MethodImpl.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="343" endline="352">
<![CDATA[
 
 		internal void SetCustomAttribute(int token, CustomAttributeBuilder customBuilder)
 		{
 			Debug.Assert(!customBuilder.IsPseudoCustomAttribute);
 			CustomAttributeTable.Record rec = new CustomAttributeTable.Record();
 			rec.Parent = token;
 			rec.Type = this.GetConstructorToken(customBuilder.Constructor).Token;
 			rec.Value = customBuilder.WriteBlob(this);
 			this.CustomAttribute.AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="186" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="355" endline="365">
<![CDATA[
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="414" endline="424">
<![CDATA[
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="425" endline="434">
<![CDATA[
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="187" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="195" endline="208">
<![CDATA[
 		}
 
 		public virtual string Namespace
 		{
 			get
 			{
 				if (IsNested)
 				{
 					return null;
 				}
 				string fullname = FullName;
 				int index = fullname.LastIndexOf('.');
 				return index < 0 ? null 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="271" endline="280">
<![CDATA[
 
 		private static Type ReadType(Module module, ByteReader br)
 		{
 			string str = ReadString(br);
 			if (str == "")
 			{
 				return null;
 			}
 			return module.Assembly.GetType(str) ?? module.universe.GetType(str, true);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="188" nfragments="6" Csharpe_files="3" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="62" endline="77">
<![CDATA[
 		{
 			switch (mod & Modifiers.AccessibilityMask) {
 			case Modifiers.PUBLIC
 				return "public";
 			case Modifiers.PROTECTED
 				return "protected";
 			case Modifiers.PROTECTED | Modifiers.INTERNAL
 				return "protected internal";
 			case Modifiers.INTERNAL
 				return "internal";
 			case Modifiers.PRIVATE
 				return "private";
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="545" endline="563">
<![CDATA[
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (Oper) {
 			case Operator.OnesComplement
 				return "OnesComplement";
 			case Operator.LogicalNot
 				return "Not";
 			case Operator.UnaryNegation
 				return "Negate";
 			case Operator.UnaryPlus
 				return "UnaryPlus";
 			default
 				throw new NotImplementedException ("Unknown express type operator " + Oper.ToString ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="569" endline="589">
<![CDATA[
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1200" endline="1210">
<![CDATA[
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1174" endline="1184">
<![CDATA[
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1226" endline="1236">
<![CDATA[
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="189" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="145" endline="157">
<![CDATA[
     End Property
 
     Private Function IsNegativeStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) < 0
         Else
             Return CDbl(constant) < 0
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="158" endline="169">
<![CDATA[
 
     Private Function IsPositiveStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) > 0
         Else
             Return CDbl(constant) > 0
         End If
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="190" nfragments="4" Csharpe_files="4" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2020" endline="2027">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2028" endline="2035">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2036" endline="2043">
<![CDATA[
 
 		public void EmitAttribute (PropertyBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2044" endline="2051">
<![CDATA[
 
 		public void EmitAttribute (TypeBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="191" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="910" endline="919">
<![CDATA[
 
 		/// <summary>
 		///    Exposes the API of the given assembly to the Evaluator
 		/// </summary>
 		static public void ReferenceAssembly (Assembly a)
 		{
 			lock (evaluator_lock){
 				loader.Importer.ImportAssembly (a, RootContext.ToplevelTypes.GlobalRootNamespace);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="867" endline="873">
<![CDATA[
 		
 		static internal string [] GetVarNames ()
 		{
 			lock (evaluator_lock){
 				return new List<string> (fields.Keys).ToArray ();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="192" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3207" endline="3219">
<![CDATA[
 
     Private Function ParseMod(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIntDiv(Info)
 
         While tm.Accept(KS.Mod)
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Mod)
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3243" endline="3255">
<![CDATA[
 
     Private Function ParseConcat(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParsePlusMinus(Info)
 
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3194" endline="3206">
<![CDATA[
 
     Private Function ParseIntDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMultDiv(Info)
 
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3145" endline="3157">
<![CDATA[
 
     Private Function ParseExponent(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIdentifier(Info)
 
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="193" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2206" endline="2212">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> Shared Function AddError(ByVal Context As BaseObject, Optional ByVal Message As String = Nothing) As Boolean
         If Message Is Nothing Then
             Message = "<no message written yet>"
         End If
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC99999, Context.Location, Message)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2198" endline="2205">
<![CDATA[
 
 
     <Diagnostics.DebuggerHidden()> Shared Function AddError(ByVal Compiler As Compiler, ByVal Location As Span, Optional ByVal Message As String = Nothing) As Boolean
         If Message Is Nothing Then
             Message = "<no message written yet>"
         End If
         Return Compiler.Report.ShowMessage(Messages.VBNC99999, Location, Message)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="194" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="522" endline="538">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function Lookup(ByVal Name As String, ByVal Visibility As MemberVisibility, ByVal PreventLoad As Boolean) As MemberCacheEntry
         Dim cache_insensitive As MemberCacheEntries = Nothing
         Dim result As MemberCacheEntry = Nothing
 
         If Not PreventLoad Then Load(Name, Visibility)
 
         m_CacheInsensitive(Visibility).TryGetValue(Name, result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="491" endline="499">
<![CDATA[
 
     Public Function LookupFlattened(ByVal Name As String, ByVal Visibility As MemberVisibility) As MemberCacheEntry
         Dim result As MemberCacheEntry = Nothing
 
         Load(Name, Visibility)
 
         m_FlattenedCacheInsensitive(Visibility).TryGetValue(Name, result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="195" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="855" endline="866">
<![CDATA[
 
 		public void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn)
 		{
 			SequencePoint sp = new SequencePoint();
 			sp.document = document;
 			sp.offset = code.Position;
 			sp.startLine = startLine;
 			sp.startColumn = startColumn;
 			sp.endLine = endLine;
 			sp.endColumn = endColumn;
 			sequencePoints.Add(sp);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="473" endline="483">
<![CDATA[
 
 		internal void Add(short generation, int name, int mvid, int encid, int encbaseid)
 		{
 			Record record = new Record();
 			record.Generation = generation;
 			record.Name = name;
 			record.Mvid = mvid;
 			record.EncId = encid;
 			record.EncBaseId = encbaseid;
 			AddRecord(record);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="196" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="811" endline="820">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Emit (ec);
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temporary = new LocalTemporary (expr.Type);
 				temporary.Store (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8617" endline="8626">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 
 			if (ec.CurrentType.IsStruct) {
 				ec.Emit (OpCodes.Ldobj, ec.CurrentType);
 				ec.Emit (OpCodes.Box, ec.CurrentType);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="197" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="339" endline="348">
<![CDATA[
 
 		protected virtual void InitializeMemberCache (bool onlyTypes)
 		{
 			MemberDefinition.LoadMembers (this, onlyTypes, ref cache);
 
 			if (onlyTypes)
 				state |= StateFlags.PendingMemberCacheMembers;
 			else
 				state &= ~StateFlags.PendingMemberCacheMembers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="77" endline="91">
<![CDATA[
 		}
 
 		internal bool HasThis
 		{
 			set
 			{
 				if (value)
 				{
 					callingConvention |= CallingConventions.HasThis;
 				}
 				else
 				{
 					callingConvention &= ~CallingConventions.HasThis;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="630" endline="638">
<![CDATA[
 		}
 
 		public virtual void Print (AbstractMessage msg)
 		{
 			if (msg.IsWarning)
 				++warnings;
 			else
 				++errors;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="198" nfragments="5" Csharpe_files="4" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="469" endline="801">
<![CDATA[
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Method; 
 			}
 		}
 
 		protected override bool CheckForDuplications ()
 		{
 			return Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 		}
 
 		public virtual EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, MemberType);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
 
 		public bool IsPartialDefinition {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block == null;
 			}
 		}
 
 		public bool IsPartialImplementation {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block != null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#region IMethodData Members
 
 		public TypeSpec ReturnType {
 			get {
 				return MemberType;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return GenericMethod;
 			}
 		}
 
 		public virtual void EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 
 		#endregion
 
 	}
 
 	public class SourceMethod 
 	{
 		MethodBase method;
 		SourceMethodBuilder builder;
 
 		protected SourceMethod (DeclSpace parent, MethodBase method, ICompileUnit file)
 		{
 			this.method = method;
 			
 			builder = SymbolWriter.OpenMethod (file, parent.NamespaceEntry.SymbolFileID, this);
 		}
 
 		public string Name {
 			get { return method.Name; }
 		}
 
 		public int Token {
 			get {
 				MethodToken token;
 				var mb = method as MethodBuilder;
 				if (mb != null)
 					token = mb.GetToken ();
 				else
 					token = ((ConstructorBuilder) method).GetToken ();
 #if STATIC
 				if (token.IsPseudoToken)
 					return ((ModuleBuilder) method.Module).ResolvePseudoToken (token.Token);
 #endif
 				return token.Token;
 			}
 		}
 
 		public void CloseMethod ()
 		{
 			SymbolWriter.CloseMethod ();
 		}
 
 		public void SetRealMethodName (string name)
 		{
 			if (builder != null)
 				builder.SetRealMethodName (name);
 		}
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1116" endline="1215">
<![CDATA[
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="716" endline="726">
<![CDATA[
 		}
 
 		public Property (DeclSpace parent, FullNamedExpression type, Modifiers mod,
 				 MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="96" endline="102">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression, ByVal Keyword As KS)
         MyBase.New(Parent, LExp, RExp)
         m_Keyword = Keyword
         Helper.Assert(m_Keyword = KS.Is OrElse m_Keyword = KS.IsNot)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1445" endline="1475">
<![CDATA[
 			}
 
 			#endregion
 		}
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.VIRTUAL |
 			Modifiers.SEALED |
 			Modifiers.OVERRIDE |
 			Modifiers.UNSAFE |
 			Modifiers.EXTERN |
 			Modifiers.ABSTRACT;
 
 		const Modifiers AllowedInterfaceModifiers =
 			Modifiers.NEW;
 
 		readonly ParametersCompiled parameters;
 
 		public Indexer (DeclSpace parent, FullNamedExpression type, MemberName name, Modifiers mod,
 				ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedInterfaceModifiers 
 				name, attrs)
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="199" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1545" endline="1556">
<![CDATA[
 
 		//
 		// Encodes single field named argument per call
 		//
 		public void EncodeNamedFieldArgument (FieldSpec field, Constant value)
 		{
 			Encode ((ushort) 1);	// length
 			Encode ((byte) 0x53); // field
 			Encode (field.MemberType);
 			Encode (field.Name);
 			value.EncodeAttributeValue (null, this, field.MemberType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1533" endline="1544">
<![CDATA[
 
 		//
 		// Encodes single property named argument per call
 		//
 		public void EncodeNamedPropertyArgument (PropertySpec property, Constant value)
 		{
 			Encode ((ushort) 1);	// length
 			Encode ((byte) 0x54); // property
 			Encode (property.MemberType);
 			Encode (property.Name);
 			value.EncodeAttributeValue (null, this, property.MemberType);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="200" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="36" endline="53">
<![CDATA[
 		private readonly List<Type> args = new List<Type>();
 		private readonly List<LocalBuilder> locals = new List<LocalBuilder>();
 		private readonly List<Type[]> requiredCustomModifiers = new List<Type[]>();
 		private readonly List<Type[]> optionalCustomModifiers = new List<Type[]>();
 		private readonly List<Type> optionalArgs = new List<Type>();
 		private Type returnType;
 		private Type[] returnTypeRequiredCustomModifiers;
 		private Type[] returnTypeOptionalCustomModifiers;
 		private CallingConventions callingConvention;
 		private CallingConvention unmanagedCallConv;
 		private bool unmanaged;
 		private bool optional;
 
 		private SignatureHelper(ModuleBuilder module, byte type)
 		{
 			this.module = module;
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="53" endline="64">
<![CDATA[
 		Stack<SourceMethodBuilder> current_method_stack = new Stack<SourceMethodBuilder> ();
 #endif
 
 		public MonoSymbolWriter (string filename)
 		{
 			this.methods = new List<SourceMethodBuilder> ();
 			this.sources = new List<SourceFileEntry> ();
 			this.comp_units = new List<CompileUnitEntry> ();
 			this.file = new MonoSymbolFile ();
 
 			this.filename = filename + ".mdb";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="82" endline="143">
<![CDATA[
 		internal readonly Dictionary<Type, Type> canonicalizedTypes = new Dictionary<Type, Type>();
 		private readonly List<Assembly> assemblies = new List<Assembly>();
 		private readonly List<AssemblyBuilder> dynamicAssemblies = new List<AssemblyBuilder>();
 		private readonly Dictionary<string, Assembly> assembliesByName = new Dictionary<string, Assembly>();
 		private readonly Dictionary<System.Type, Type> importedTypes = new Dictionary<System.Type, Type>();
 		private Type typeof_System_Object;
 		private Type typeof_System_ValueType;
 		private Type typeof_System_Enum;
 		private Type typeof_System_Void;
 		private Type typeof_System_Boolean;
 		private Type typeof_System_Char;
 		private Type typeof_System_SByte;
 		private Type typeof_System_Byte;
 		private Type typeof_System_Int16;
 		private Type typeof_System_UInt16;
 		private Type typeof_System_Int32;
 		private Type typeof_System_UInt32;
 		private Type typeof_System_Int64;
 		private Type typeof_System_UInt64;
 		private Type typeof_System_Single;
 		private Type typeof_System_Double;
 		private Type typeof_System_String;
 		private Type typeof_System_IntPtr;
 		private Type typeof_System_UIntPtr;
 		private Type typeof_System_TypedReference;
 		private Type typeof_System_Type;
 		private Type typeof_System_Array;
 		private Type typeof_System_DateTime;
 		private Type typeof_System_DBNull;
 		private Type typeof_System_Decimal;
 		private Type typeof_System_NonSerializedAttribute;
 		private Type typeof_System_SerializableAttribute;
 		private Type typeof_System_AttributeUsageAttribute;
 		private Type typeof_System_Reflection_AssemblyCultureAttribute;
 		private Type typeof_System_Runtime_InteropServices_DllImportAttribute;
 		private Type typeof_System_Runtime_InteropServices_FieldOffsetAttribute;
 		private Type typeof_System_Runtime_InteropServices_InAttribute;
 		private Type typeof_System_Runtime_InteropServices_MarshalAsAttribute;
 		private Type typeof_System_Runtime_InteropServices_UnmanagedType;
 		private Type typeof_System_Runtime_InteropServices_VarEnum;
 		private Type typeof_System_Runtime_InteropServices_OutAttribute;
 		private Type typeof_System_Runtime_InteropServices_StructLayoutAttribute;
 		private Type typeof_System_Runtime_InteropServices_OptionalAttribute;
 		private Type typeof_System_Runtime_InteropServices_PreserveSigAttribute;
 		private Type typeof_System_Runtime_InteropServices_ComImportAttribute;
 		private Type typeof_System_Runtime_CompilerServices_DecimalConstantAttribute;
 		private Type typeof_System_Runtime_CompilerServices_SpecialNameAttribute;
 		private Type typeof_System_Runtime_CompilerServices_MethodImplAttribute;
 		private Type typeof_System_Security_SuppressUnmanagedCodeSecurityAttribute;
 		private Type typeof_System_Reflection_AssemblyCopyrightAttribute;
 		private Type typeof_System_Reflection_AssemblyTrademarkAttribute;
 		private Type typeof_System_Reflection_AssemblyProductAttribute;
 		private Type typeof_System_Reflection_AssemblyCompanyAttribute;
 		private Type typeof_System_Reflection_AssemblyDescriptionAttribute;
 		private Type typeof_System_Reflection_AssemblyTitleAttribute;
 		private Type typeof_System_Reflection_AssemblyInformationalVersionAttribute;
 		private Type typeof_System_Reflection_AssemblyFileVersionAttribute;
 		private Type typeof_System_Security_Permissions_CodeAccessSecurityAttribute;
 		private Type typeof_System_Security_Permissions_HostProtectionAttribute;
 		private Type typeof_System_Security_Permissions_PermissionSetAttribute;
 		private Type typeof_System_Security_Permissions_SecurityAction;
 		private List<ResolveEventHandler> resolvers = new List<ResolveEventHandler>();
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="201" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="59" endline="66">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal DelegateType As Mono.Cecil.TypeReference, ByVal AddressOfExpression As AddressOfExpression)
         MyBase.New(Parent)
 
         m_IsDelegateCreationExpression = True
         m_ResolvedType = DelegateType
         m_ArgumentList = New ArgumentList(Me, AddressOfExpression)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" startline="96" endline="108">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     ''' <param name="Message"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = New Messages() {Message}
         Me.m_Location = Location
         Me.m_Parameters = New String()() {}
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="202" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1326" endline="1339">
<![CDATA[
 
     ''' <summary>
     ''' Loads the boolean value onto the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Overloads Shared Sub EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Boolean)
         If Value Then
             EmitLoadI4Value(Info, 1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1150" endline="1157">
<![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Boolean)
         If I Then
             EmitLoadI4Value(Info, -1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="203" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="296" endline="302">
<![CDATA[
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="313" endline="324">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="204" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="326" endline="334">
<![CDATA[
 		}
 
 		public override Type DeclaringType
 		{
 			get
 			{
 				int owner = module.GenericParam.records[index].Owner;
 				return (owner >> 24) == TypeDefTable.Index ? module.ResolveType(owner) 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="335" endline="343">
<![CDATA[
 		}
 
 		public override MethodBase DeclaringMethod
 		{
 			get
 			{
 				int owner = module.GenericParam.records[index].Owner;
 				return (owner >> 24) == MethodDefTable.Index ? module.ResolveMethod(owner) 
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="205" nfragments="3" Csharpe_files="0" vb_files="3" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="222" endline="228">
<![CDATA[
 
     Shared Sub EmitLE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Cgt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="199" endline="205">
<![CDATA[
 
     Shared Sub EmitGE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Clt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="192" endline="198">
<![CDATA[
 
     Shared Sub EmitNotEquals(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Ceq)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="206" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="165" endline="173">
<![CDATA[
 
 		internal static void SetMarshalAsAttribute(ModuleBuilder module, int token, CustomAttributeBuilder attribute)
 		{
 			attribute = attribute.DecodeBlob(module.Assembly);
 			FieldMarshalTable.Record rec = new FieldMarshalTable.Record();
 			rec.Parent = token;
 			rec.NativeType = WriteMarshallingDescriptor(module, attribute);
 			module.FieldMarshal.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="196" endline="204">
<![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="158" endline="166">
<![CDATA[
 		}
 
 		private void AddConstraint(Type type)
 		{
 			GenericParamConstraintTable.Record rec = new GenericParamConstraintTable.Record();
 			rec.Owner = paramPseudoIndex;
 			rec.Constraint = this.ModuleBuilder.GetTypeTokenForMemberRef(type);
 			this.ModuleBuilder.GenericParamConstraint.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="221" endline="229">
<![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="431" endline="439">
<![CDATA[
 
 		public void AddResourceFile(string name, string fileName, ResourceAttributes attribs)
 		{
 			ResourceFile resfile = new ResourceFile();
 			resfile.Name = name;
 			resfile.FileName = fileName;
 			resfile.Attributes = attribs;
 			resourceFiles.Add(resfile);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="112" endline="119">
<![CDATA[
 
 		public void SetOffset(int iOffset)
 		{
 			FieldLayoutTable.Record rec = new FieldLayoutTable.Record();
 			rec.Offset = iOffset;
 			rec.Field = pseudoToken;
 			typeBuilder.ModuleBuilder.FieldLayout.AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="207" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8355" endline="8361">
<![CDATA[
 
 		SLE.Expression[] MakeExpressionArguments (BuilderContext ctx)
 		{
 			using (ctx.With (BuilderContext.Options.AllCheckStateFlags, true)) {
 				return Arguments.MakeExpression (ea.Arguments, ctx);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7963" endline="7969">
<![CDATA[
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			using (ctx.With (BuilderContext.Options.AllCheckStateFlags, true)) {
 				return Expr.MakeExpression (ctx);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9035" endline="9041">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			using (ec.Set (ResolveContext.Options.CheckedScope)) {
 				return base.CreateExpressionTree (ec);
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="208" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1211" endline="1221">
<![CDATA[
 
 		protected override TypeExpr ResolveAsTypeTerminal (Expression expr, IMemberContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveAsTypeTerminal (expr, ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1222" endline="1232">
<![CDATA[
 
 		protected override MethodSpec ResolveConstructor (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveConstructor (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1233" endline="1243">
<![CDATA[
 
 		protected override bool ResolveNamedArguments (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveNamedArguments (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="209" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="130" endline="136">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="148" endline="154">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="210" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="667" endline="673">
<![CDATA[
 		}
 
 		TypeParameterSpec[] ITypeDefinition.TypeParameters {
 			get {
 				// TODO MemberCache
 				return PartialContainer.type_params.Select (l => l.Type).ToArray ();
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="835" endline="841">
<![CDATA[
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				// TODO
 				return CurrentTypeParameters.Select (l => l.Type).ToArray ();
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="211" nfragments="15" Csharpe_files="0" vb_files="15" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="144" endline="150">
<![CDATA[
 
     Shared Function CreateUInt64Token(ByVal Location As Span, ByVal Value As ULong) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="137" endline="143">
<![CDATA[
 
     Shared Function CreateUInt32Token(ByVal Location As Span, ByVal Value As UInteger) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="130" endline="136">
<![CDATA[
 
     Shared Function CreateUInt16Token(ByVal Location As Span, ByVal Value As UShort) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="123" endline="129">
<![CDATA[
 
     Shared Function CreateInt64Token(ByVal Location As Span, ByVal Value As Long) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="158" endline="164">
<![CDATA[
 
     Shared Function CreateSymbolToken(ByVal Location As Span, ByVal Symbol As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Symbol
         result.m_TokenObject = Symbol
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="116" endline="122">
<![CDATA[
 
     Shared Function CreateInt32Token(ByVal Location As Span, ByVal Value As Integer) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="109" endline="115">
<![CDATA[
 
     Shared Function CreateInt16Token(ByVal Location As Span, ByVal Value As Short) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="102" endline="108">
<![CDATA[
 
     Shared Function CreateDoubleToken(ByVal Location As Span, ByVal Value As Double) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DoubleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="95" endline="101">
<![CDATA[
 
     Shared Function CreateSingleToken(ByVal Location As Span, ByVal Value As Single) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.SingleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="88" endline="94">
<![CDATA[
 
     Shared Function CreateDecimalToken(ByVal Location As Span, ByVal Value As Decimal) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DecimalLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="81" endline="87">
<![CDATA[
 
     Shared Function CreateCharToken(ByVal Location As Span, ByVal Value As Char) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.CharLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="67" endline="73">
<![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="151" endline="157">
<![CDATA[
 
     Shared Function CreateStringLiteral(ByVal Location As Span, ByVal Value As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.StringLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="42" endline="48">
<![CDATA[
 
     Shared Function CreateIdentifierToken(ByVal Location As Span, ByVal Identifier As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Identifier
         result.m_TokenObject = Identifier
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="212" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="291" endline="297">
<![CDATA[
 
 		private static void WriteString(ByteBuffer bb, string str)
 		{
 			byte[] buf = Encoding.UTF8.GetBytes(str);
 			bb.WriteCompressedInt(buf.Length);
 			bb.Write(buf);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="84" endline="93">
<![CDATA[
 
 		public void ImportAssembly (Assembly assembly, RootNamespace targetNamespace)
 		{
 			// It can be used more than once when importing same assembly
 			// into 2 or more global aliases
 			var definition = GetAssemblyDefinition (assembly);
 
 			var all_types = assembly.GetTypes ();
 			ImportTypes (all_types, targetNamespace, definition.HasExtensionMethod);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="213" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="209" endline="218">
<![CDATA[
 
 		public static void Reset ()
 		{
 			source_files = new Dictionary<string, int> ();
 			source_list = new List<SourceFile> ();
 			compile_units = new List<CompilationUnit> ();
 			current_source = 0;
 			current_compile_unit = 0;
 			source_count = 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="53" endline="702">
<![CDATA[
 		static object evaluator_lock = new object ();
 		
 		static string current_debug_name;
 		static int count;
 		static Thread invoke_thread;
 
 		static List<NamespaceEntry.UsingAliasEntry> using_alias_list = new List<NamespaceEntry.UsingAliasEntry> ();
 		internal static List<NamespaceEntry.UsingEntry> using_list = new List<NamespaceEntry.UsingEntry> ();
 		static Dictionary<string, Tuple<FieldSpec, FieldInfo>> fields = new Dictionary<string, Tuple<FieldSpec, FieldInfo>> ();
 
 		static TypeSpec interactive_base_class;
 		static Driver driver;
 		static bool inited;
 
 		static CompilerContext ctx;
 		static DynamicLoader loader;
 		
 		public static TextWriter MessageOutput = Console.Out;
 
 		/// <summary>
 		///   Optional initialization for the Evaluator.
 		/// </summary>
 		/// <remarks>
 		///  Initializes the Evaluator with the command line options
 		///  that would be processed by the command line compiler.  Only
 		///  the first call to Init will work, any future invocations are
 		///  ignored.
 		///
 		///  You can safely avoid calling this method if your application
 		///  does not need any of the features exposed by the command line
 		///  interface.
 		/// </remarks>
 		public static void Init (string [] args)
 		{
 			InitAndGetStartupFiles (args);
 		}
 
 		internal static ReportPrinter SetPrinter (ReportPrinter report_printer)
 		{
 			return ctx.Report.SetPrinter (report_printer);
 		}				
 
 		public static string [] InitAndGetStartupFiles (string [] args)
 		{
 			return InitAndGetStartupFiles (args, null);
 		}
 
 		/// <summary>
 		///   Optional initialization for the Evaluator.
 		/// </summary>
 		/// <remarks>
 		///  Initializes the Evaluator with the command line
 		///  options that would be processed by the command
 		///  line compiler.  Only the first call to
 		///  InitAndGetStartupFiles or Init will work, any future
 		///  invocations are ignored.
 		///
 		///  You can safely avoid calling this method if your application
 		///  does not need any of the features exposed by the command line
 		///  interface.
 		///
 		///  This method return an array of strings that contains any
 		///  files that were specified in `args'.
 		///
 		///  If the unknownOptionParser is not null, this function is invoked
 		///  with the current args array and the index of the option that is not
 		///  known.  A value of true means that the value was processed, otherwise
 		///  it will be reported as an error
 		/// </remarks>
 		public static string [] InitAndGetStartupFiles (string [] args, Func<string [], int, int> unknownOptionParser)
 		{
 			lock (evaluator_lock){
 				if (inited)
 					return new string [0];
 
 				CompilerCallableEntryPoint.Reset ();
 				var crp = new ConsoleReportPrinter ();
 				driver = Driver.Create (args, false, unknownOptionParser, crp);
 				if (driver == null)
 					throw new Exception ("Failed to create compiler driver with the given arguments");
 
 				crp.Fatal = driver.fatal_errors;
 				ctx = driver.ctx;
 
 				RootContext.ToplevelTypes = new ModuleContainer (ctx);
 				
 				var startup_files = new List<string> ();
 				foreach (CompilationUnit file in Location.SourceFiles)
 					startup_files.Add (file.Path);
 				
 				CompilerCallableEntryPoint.PartialReset ();
 
 				var importer = new ReflectionImporter (ctx.BuildinTypes);
 				loader = new DynamicLoader (importer, ctx);
 
 				RootContext.ToplevelTypes.SetDeclaringAssembly (new AssemblyDefinitionDynamic (RootContext.ToplevelTypes, "temp"));
 
 				loader.LoadReferences (RootContext.ToplevelTypes);
 				ctx.BuildinTypes.CheckDefinitions (RootContext.ToplevelTypes);
 				RootContext.ToplevelTypes.InitializePredefinedTypes ();
 
 				RootContext.EvalMode = true;
 				inited = true;
 
 				return startup_files.ToArray ();
 			}
 		}
 
 		static void Init ()
 		{
 			Init (new string [0]);
 		}
 		
 		static void Reset ()
 		{
 			CompilerCallableEntryPoint.PartialReset ();
 			
 			Location.AddFile (null, "{interactive}");
 			Location.Initialize ();
 
 			current_debug_name = "interactive" + (count++) + ".dll";
 		}
 
 		/// <summary>
 		///   The base class for the classes that host the user generated code
 		/// </summary>
 		/// <remarks>
 		///
 		///   This is the base class that will host the code
 		///   executed by the Evaluator.  By default
 		///   this is the Mono.CSharp.InteractiveBase class
 		///   which is useful for interactive use.
 		///
 		///   By changing this property you can control the
 		///   base class and the static members that are
 		///   available to your evaluated code.
 		/// </remarks>
 		static public TypeSpec InteractiveBaseClass {
 			get {
 				if (interactive_base_class != null)
 					return interactive_base_class;
 
 				return loader.Importer.ImportType (typeof (InteractiveBase));
 			}
 		}
 
 		public static void SetInteractiveBaseClass (Type type)
 		{
 			if (type == null)
 				throw new ArgumentNullException ();
 
 			if (!inited)
 				throw new Exception ("Evaluator has to be initiated before seting custom InteractiveBase class");
 
 			lock (evaluator_lock)
 				interactive_base_class = loader.Importer.ImportType (type);
 		}
 
 		/// <summary>
 		///   Interrupts the evaluation of an expression executing in Evaluate.
 		/// </summary>
 		/// <remarks>
 		///   Use this method to interrupt long-running invocations.
 		/// </remarks>
 		public static void Interrupt ()
 		{
 			if (!inited || !invoking)
 				return;
 			
 			if (invoke_thread != null)
 				invoke_thread.Abort ();
 		}
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   If the return value of this function is null,
 		///   this indicates that the parsing was complete.
 		///   If the return value is a string it indicates
 		///   that the input string was partial and that the
 		///   invoking code should provide more code before
 		///   the code can be successfully compiled.
 		///
 		///   If you know that you will always get full expressions or
 		///   statements and do not care about partial input, you can use
 		///   the other Compile overload. 
 		///
 		///   On success, in addition to returning null, the
 		///   compiled parameter will be set to the delegate
 		///   that can be invoked to execute the code.
 		///
 	        /// </remarks>
 		static public string Compile (string input, out CompiledMethod compiled)
 		{
 			if (input == null || input.Length == 0){
 				compiled = null;
 				return null;
 			}
 
 			lock (evaluator_lock){
 				if (!inited)
 					Init ();
 				else
 					ctx.Report.Printer.Reset ();
 
 			//	RootContext.ToplevelTypes = new ModuleContainer (ctx);
 
 				bool partial_input;
 				CSharpParser parser = ParseString (ParseMode.Silent, input, out partial_input);
 				if (parser == null){
 					compiled = null;
 					if (partial_input)
 						return input;
 					
 					ParseString (ParseMode.ReportErrors, input, out partial_input);
 					return null;
 				}
 				
 				object parser_result = parser.InteractiveResult;
 				
 				if (!(parser_result is Class)){
 					int errors = ctx.Report.Errors;
 
 					NamespaceEntry.VerifyAllUsing ();
 					if (errors == ctx.Report.Errors)
 						parser.CurrentNamespace.Extract (using_alias_list, using_list);
 					else
 						NamespaceEntry.Reset ();
 				}
 
 #if STATIC
 				throw new NotSupportedException ();
 #else
 				compiled = CompileBlock (parser_result as Class, parser.undo, ctx.Report);
 				return null;
 #endif
 			}
 		}
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   This method can only deal with fully formed input
 		///   strings and does not provide a completion mechanism.
 		///   If you must deal with partial input (for example for
 		///   interactive use) use the other overload. 
 		///
 		///   On success, a delegate is returned that can be used
 		///   to invoke the method.
 		///
 	        /// </remarks>
 		static public CompiledMethod Compile (string input)
 		{
 			CompiledMethod compiled;
 
 			// Ignore partial inputs
 			if (Compile (input, out compiled) != null){
 				// Error, the input was partial.
 				return null;
 			}
 
 			// Either null (on error) or the compiled method.
 			return compiled;
 		}
 
 		//
 		// Todo
 		// the recording themselves?
 		//
 
 		/// <summary>
 		///   Evaluates and expression or statement and returns any result values.
 		/// </summary>
 		/// <remarks>
 		///   Evaluates the input string as a C# expression or
 		///   statement.  If the input string is an expression
 		///   the result will be stored in the result variable
 		///   and the result_set variable will be set to true.
 		///
 		///   It is necessary to use the result/result_set
 		///   pair to identify when a result was set (for
 		///   example, execution of user-provided input can be
 		///   an expression, a statement or others, and
 		///   result_set would only be set if the input was an
 		///   expression.
 		///
 		///   If the return value of this function is null,
 		///   this indicates that the parsing was complete.
 		///   If the return value is a string, it indicates
 		///   that the input is partial and that the user
 		///   should provide an updated string.
 		/// </remarks>
 		public static string Evaluate (string input, out object result, out bool result_set)
 		{
 			CompiledMethod compiled;
 
 			result_set = false;
 			result = null;
 
 			input = Compile (input, out compiled);
 			if (input != null)
 				return input;
 			
 			if (compiled == null)
 				return null;
 				
 			//
 			// The code execution does not need to keep the compiler lock
 			//
 			object retval = typeof (NoValueSet);
 
 			try {
 				invoke_thread = System.Threading.Thread.CurrentThread;
 				invoking = true;
 				compiled (ref retval);
 			} catch (ThreadAbortException e){
 				Thread.ResetAbort ();
 				Console.WriteLine ("Interrupted!\n{0}", e);
 			} finally {
 				invoking = false;
 			}
 
 			//
 			// We use a reference to a compiler type, in this case
 			// Driver as a flag to indicate that this was a statement
 			//
 			if (retval != typeof (NoValueSet)){
 				result_set = true;
 				result = retval; 
 			}
 
 			return null;
 		}
 
 		public static string [] GetCompletions (string input, out string prefix)
 		{
 			prefix = "";
 			if (input == null || input.Length == 0)
 				return null;
 			
 			lock (evaluator_lock){
 				if (!inited)
 					Init ();
 				
 				bool partial_input;
 				CSharpParser parser = ParseString (ParseMode.GetCompletions, input, out partial_input);
 				if (parser == null){
 					if (CSharpParser.yacc_verbose_flag != 0)
 						Console.WriteLine ("DEBUG
 					return null;
 				}
 				
 				Class parser_result = parser.InteractiveResult as Class;
 				
 				if (parser_result == null){
 					if (CSharpParser.yacc_verbose_flag != 0)
 						Console.WriteLine ("Do not know how to cope with !Class yet");
 					return null;
 				}
 
 				try {
 					var a = new AssemblyDefinitionDynamic (RootContext.ToplevelTypes, "temp");
 					a.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Run);
 					RootContext.ToplevelTypes.SetDeclaringAssembly (a);
 					RootContext.ToplevelTypes.Define ();
 					if (ctx.Report.Errors != 0)
 						return null;
 					
 					MethodOrOperator method = null;
 					foreach (MemberCore member in parser_result.Methods){
 						if (member.Name != "Host")
 							continue;
 						
 						method = (MethodOrOperator) member;
 						break;
 					}
 					if (method == null)
 						throw new InternalErrorException ("did not find the the Host method");
 
 					BlockContext bc = new BlockContext (method, method.Block, method.ReturnType);
 
 					try {
 						method.Block.Resolve (null, bc, method);
 					} catch (CompletionResult cr){
 						prefix = cr.BaseText;
 						return cr.Result;
 					} 
 				} finally {
 					parser.undo.ExecuteUndo ();
 				}
 				
 			}
 			return null;
 		}
 
 		/// <summary>
 		///   Executes the given expression or statement.
 		/// </summary>
 		/// <remarks>
 		///    Executes the provided statement, returns true
 		///    on success, false on parsing errors.  Exceptions
 		///    might be thrown by the called code.
 		/// </remarks>
 		public static bool Run (string statement)
 		{
 			if (!inited)
 				Init ();
 
 			object result;
 			bool result_set;
 
 			bool ok = Evaluate (statement, out result, out result_set) == null;
 			
 			return ok;
 		}
 
 		/// <summary>
 		///   Evaluates and expression or statement and returns the result.
 		/// </summary>
 		/// <remarks>
 		///   Evaluates the input string as a C# expression or
 		///   statement and returns the value.   
 		///
 		///   This method will throw an exception if there is a syntax error,
 		///   of if the provided input is not an expression but a statement.
 		/// </remarks>
 		public static object Evaluate (string input)
 		{
 			object result;
 			bool result_set;
 			
 			string r = Evaluate (input, out result, out result_set);
 
 			if (r != null)
 				throw new ArgumentException ("Syntax error on input
 			
 			if (result_set == false)
 				throw new ArgumentException ("The expression did not set a result");
 
 			return result;
 		}
 
 		enum InputKind {
 			EOF,
 			StatementOrExpression,
 			CompilationUnit,
 			Error
 		}
 
 		//
 		// Deambiguates the input string to determine if we
 		// want to process a statement or if we want to
 		// process a compilation unit.
 		//
 		// This is done using a top-down predictive parser,
 		// since the yacc/jay parser can not deambiguage this
 		// without more than one lookahead token.   There are very
 		// few ambiguities.
 		//
 		static InputKind ToplevelOrStatement (SeekableStreamReader seekable)
 		{
 			Tokenizer tokenizer = new Tokenizer (seekable, (CompilationUnit) Location.SourceFiles [0], ctx);
 			
 			int t = tokenizer.token ();
 			switch (t){
 			case Token.EOF
 				return InputKind.EOF;
 				
 			// These are toplevels
 			case Token.EXTERN
 			case Token.OPEN_BRACKET
 			case Token.ABSTRACT
 			case Token.CLASS
 			case Token.ENUM
 			case Token.INTERFACE
 			case Token.INTERNAL
 			case Token.NAMESPACE
 			case Token.PRIVATE
 			case Token.PROTECTED
 			case Token.PUBLIC
 			case Token.SEALED
 			case Token.STATIC
 			case Token.STRUCT
 				return InputKind.CompilationUnit;
 				
 			// Definitely expression
 			case Token.FIXED
 			case Token.BOOL
 			case Token.BYTE
 			case Token.CHAR
 			case Token.DECIMAL
 			case Token.DOUBLE
 			case Token.FLOAT
 			case Token.INT
 			case Token.LONG
 			case Token.NEW
 			case Token.OBJECT
 			case Token.SBYTE
 			case Token.SHORT
 			case Token.STRING
 			case Token.UINT
 			case Token.ULONG
 				return InputKind.StatementOrExpression;
 
 			// These need deambiguation help
 			case Token.USING
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 
 				if (t == Token.IDENTIFIER)
 					return InputKind.CompilationUnit;
 				return InputKind.StatementOrExpression;
 
 
 			// Distinguish between
 			//    delegate opt_anonymous_method_signature block
 			//    delegate type 
 			case Token.DELEGATE
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 				if (t == Token.OPEN_PARENS || t == Token.OPEN_BRACE)
 					return InputKind.StatementOrExpression;
 				return InputKind.CompilationUnit;
 
 			// Distinguih between
 			//    unsafe block
 			//    unsafe as modifier of a type declaration
 			case Token.UNSAFE
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 				if (t == Token.OPEN_PARENS)
 					return InputKind.StatementOrExpression;
 				return InputKind.CompilationUnit;
 				
 		        // These are errors
 			// from the grammar, ERROR and then everything else
 
 			case Token.READONLY
 			case Token.OVERRIDE
 			case Token.ERROR
 				return InputKind.Error;
 
 			// This catches everything else allowed by
 			// expressions.  We could add one-by-one use cases
 			// if needed.
 			default
 				return InputKind.StatementOrExpression;
 			}
 		}
 		
 		//
 		// Parses the string @input and returns a CSharpParser if succeeful.
 		//
 		// if @silent is set to true then no errors are
 		// reported to the user.  This is used to do various calls to the
 		// parser and check if the expression is parsable.
 		//
 		// @partial_input
 		// parsed expression was partial, and more data is needed
 		//
 		static CSharpParser ParseString (ParseMode mode, string input, out bool partial_input)
 		{
 			partial_input = false;
 			Reset ();
 			queued_fields.Clear ();
 			Tokenizer.LocatedToken.Initialize ();
 
 			Stream s = new MemoryStream (Encoding.Default.GetBytes (input));
 			SeekableStreamReader seekable = new SeekableStreamReader (s, Encoding.Default);
 
 			InputKind kind = ToplevelOrStatement (seekable);
 			if (kind == InputKind.Error){
 				if (mode == ParseMode.ReportErrors)
 					ctx.Report.Error (-25, "Detection Parsing Error");
 				partial_input = false;
 				return null;
 			}
 
 			if (kind == InputKind.EOF){
 				if (mode == ParseMode.ReportErrors)
 					Console.Error.WriteLine ("Internal error
 				partial_input = true;
 				return null;
 				
 			}
 			seekable.Position = 0;
 
 			CSharpParser parser = new CSharpParser (seekable, Location.SourceFiles [0], RootContext.ToplevelTypes);
 
 			if (kind == InputKind.StatementOrExpression){
 				parser.Lexer.putback_char = Tokenizer.EvalStatementParserCharacter;
 				RootContext.StatementMode = true;
 			} else {
 				//
 				// Do not activate EvalCompilationUnitParserCharacter until
 				// I have figured out all the limitations to invoke methods
 				// in the generated classes.  See repl.txt
 				//
 				parser.Lexer.putback_char = Tokenizer.EvalUsingDeclarationsParserCharacter;
 				//parser.Lexer.putback_char = Tokenizer.EvalCompilationUnitParserCharacter;
 				RootContext.StatementMode = false;
 			}
 
 			if (mode == ParseMode.GetCompletions)
 				parser.Lexer.CompleteOnEOF = true;
 
 			ReportPrinter old_printer = null;
 			if ((mode == ParseMode.Silent || mode == ParseMode.GetCompletions) && CSharpParser.yacc_verbose_flag == 0)
 				old_printer = SetPrinter (new StreamReportPrinter (TextWriter.Null));
 
 			try {
 				parser.parse ();
 			} finally {
 				if (ctx.Report.Errors != 0){
 					if (mode != ParseMode.ReportErrors  && parser.UnexpectedEOF)
 						partial_input = true;
 
 					parser.undo.ExecuteUndo ();
 					parser = null;
 				}
 
 				if (old_printer != null)
 					SetPrinter (old_printer);
 			}
 			return parser;
 		}
 
 		//
 		// Queue all the fields that we use, as we need to then go from FieldBuilder to FieldInfo
 		// or reflection gets confused (it basically gets confused, and variables override each
 		// other).
 		//
 		static List<Field> queued_fields = new List<Field> ();
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="214" nfragments="3" Csharpe_files="2" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="113" endline="119">
<![CDATA[
 
     Public Function DefineLabel() As Label
         Log("DefineLabel")
         Dim result As New Label
         result.CecilLabel = DefineLabelCecil()
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="267" endline="282">
<![CDATA[
 	}
 
 	[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
 	struct SingleConverter
 	{
 		[System.Runtime.InteropServices.FieldOffset(0)]
 		private int i;
 		[System.Runtime.InteropServices.FieldOffset(0)]
 		private float f;
 
 		internal static int SingleToInt32Bits(float v)
 		{
 			SingleConverter c = new SingleConverter();
 			c.f = v;
 			return c.i;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="283" endline="289">
<![CDATA[
 
 		internal static float Int32BitsToSingle(int v)
 		{
 			SingleConverter c = new SingleConverter();
 			c.i = v;
 			return c.f;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="215" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="108" endline="161">
<![CDATA[
 		public static readonly AttributeUsageAttribute DefaultUsageAttribute = new AttributeUsageAttribute (AttributeTargets.All);
 		static Assembly orig_sec_assembly;
 		public static readonly object[] EmptyObject = new object [0];
 
 		List<KeyValuePair<MemberExpr, NamedArgument>> named_values;
 
 		// Cache for parameter-less attributes
 		static Dictionary<TypeSpec, MethodSpec> att_cache;
 
 		public Attribute (string target, ATypeNameExpression expr, Arguments[] args, Location loc, bool nameEscaped)
 		{
 			this.expression = expr;
 			if (args != null) {
 				PosArguments = args [0];
 				NamedArguments = args [1];				
 			}
 			this.loc = loc;
 			ExplicitTarget = target;
 			this.nameEscaped = nameEscaped;
 		}
 
 		void AddModuleCharSet (ResolveContext rc)
 		{
 			const string dll_import_char_set = "CharSet";
 
 			//
 			// Only when not customized by user
 			//
 			if (HasField (dll_import_char_set))
 				return;
 
 			if (!rc.Module.PredefinedTypes.CharSet.IsDefined) {
 				return;
 			}
 
 			if (NamedArguments == null)
 				NamedArguments = new Arguments (1);
 
 			var value = Constant.CreateConstant (rc, rc.Module.PredefinedTypes.CharSet.TypeSpec, rc.Module.DefaultCharSet, Location);
 			NamedArguments.Add (new NamedArgument (dll_import_char_set, loc, value));
 		}
 
 		public Attribute Clone ()
 		{
 			Attribute a = new Attribute (ExplicitTarget, expression, null, loc, nameEscaped);
 			a.PosArguments = PosArguments;
 			a.NamedArguments = NamedArguments;
 			return a;
 		}
 
 		static Attribute ()
 		{
 			Reset ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="185" endline="208">
<![CDATA[
 		}
 
 		static List<SourceFile> source_list;
 		static List<CompilationUnit> compile_units;
 		static Dictionary<string, int> source_files;
 		static int checkpoint_bits;
 		static int source_count;
 		static int current_source;
 		static int current_compile_unit;
 		static int line_delta_bits;
 		static int line_delta_mask;
 		static int column_bits;
 		static int column_mask;
 		static Checkpoint [] checkpoints;
 		static int checkpoint_index;
 		
 		public readonly static Location Null = new Location (-1);
 		public static bool InEmacs;
 		
 		static Location ()
 		{
 			Reset ();
 			checkpoints = new Checkpoint [10];
 		}
]]>
</clone_fragment>
</clone_group>
</clones>
